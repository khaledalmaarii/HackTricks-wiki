# WWW2Exec - atexit(), TLS Skladi코tenje & Ostali izmenjeni Pokaziva캜i

{% hint style="success" %}
Nau캜ite & ve쬭ajte AWS Hakovanje:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Obuka AWS Crveni Tim Stru캜njak (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Nau캜ite & ve쬭ajte GCP Hakovanje: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Obuka GCP Crveni Tim Stru캜njak (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## **\_\_atexit Strukture**

{% hint style="danger" %}
Danas je vrlo **캜udno iskoristiti ovo!**
{% endhint %}

**`atexit()`** je funkcija kojoj se **druge funkcije prosle캠uju kao parametri.** Ove **funkcije** 캖e biti **izvr코ene** prilikom izvr코avanja **`exit()`** ili **povratka** iz **main** funkcije.\
Ako mo쬰te **izmeniti** **adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, dobi캖ete **kontrolu** nad **procesom**, ali trenutno je to komplikovanije.\
Trenutno su **adrese funkcija** koje treba izvr코iti **sakrivene** iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, ve캖 su **코ifrovane sa XOR** i pomeraji sa **slu캜ajnim klju캜em**. Tako da je trenutno ovaj vektor napada **nije vrlo koristan bar na x86** i **x64\_86**.\
**Funkcija za 코ifrovanje** je **`PTR_MANGLE`**. **Druga arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za 코ifrovanje** jer **vra캖a isto** 코to je primila kao ulaz. Tako da bi ove arhitekture bile podlo쬹e ovom vektoru napada.

Mo쬰te prona캖i detaljno obja코njenje kako ovo funkcioni코e na [https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html](https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html)

## link\_map

Kao 코to je obja코njeno [**u ovom postu**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure), Ako program iza캠e koriste캖i `return` ili `exit()` pokrenu캖e se `__run_exit_handlers()` koji 캖e pozvati registrovane destruktore.

{% hint style="danger" %}
Ako program iza캠e putem **`_exit()`** funkcije, pozva캖e **`exit` syscall** i hendleri izlaska ne캖e biti izvr코eni. Dakle, da potvrdite da se `__run_exit_handlers()` izvr코ava mo쬰te postaviti prekidnu ta캜ku na nju.
{% endhint %}

Va쬬n kod je ([izvor](https://elixir.bootlin.com/glibc/glibc-2.32/source/elf/dl-fini.c#L131)):
```c
ElfW(Dyn) *fini_array = map->l_info[DT_FINI_ARRAY];
if (fini_array != NULL)
{
ElfW(Addr) *array = (ElfW(Addr) *) (map->l_addr + fini_array->d_un.d_ptr);
size_t sz = (map->l_info[DT_FINI_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr)));

while (sz-- > 0)
((fini_t) array[sz]) ();
}
[...]




// This is the d_un structure
ptype l->l_info[DT_FINI_ARRAY]->d_un
type = union {
Elf64_Xword d_val;	// address of function that will be called, we put our onegadget here
Elf64_Addr d_ptr;	// offset from l->l_addr of our structure
}
```
Primetite kako se `map -> l_addr + fini_array -> d_un.d_ptr` koristi za **izra캜unavanje** pozicije **niza funkcija za pozivanje**.

Postoje **nekoliko opcija**:

* Prepisati vrednost `map->l_addr` kako bi pokazivala na **la쬹i `fini_array`** sa instrukcijama za izvr코avanje proizvoljnog koda
* Prepisati unose `l_info[DT_FINI_ARRAY]` i `l_info[DT_FINI_ARRAYSZ]` (koji su vi코e-manje uzastopni u memoriji), kako bi pokazivali na la쬹u strukturu `Elf64_Dyn` koja 캖e ponovo naterati **`array` da pokazuje na memoriju** kojom upravlja napada캜.&#x20;
* [**Ovaj opis**](https://github.com/nobodyisnobody/write-ups/tree/main/DanteCTF.2023/pwn/Sentence.To.Hell) prepisuje `l_info[DT_FINI_ARRAY]` sa adresom kontrolisane memorije u `.bss` koja sadr쬴 la쬹i `fini_array`. Ovaj la쬹i niz sadr쬴 **prvo adresu** [**one gadgeta**](../rop-return-oriented-programing/ret2lib/one-gadget.md) koja 캖e biti izvr코ena, a zatim **razliku** izme캠u adrese ovog **la쬹og niza** i vrednosti `map->l_addr` tako da 캖e `*array` pokazivati na la쬹i niz.
* Prema glavnoj objavi ove tehnike i [**ovom opisu**](https://activities.tjhsst.edu/csc/writeups/angstromctf-2021-wallstreet) ld.so ostavlja pokaziva캜 na steku koji pokazuje na binarni `link_map` u ld.so. Pomo캖u proizvoljnog pisanja mogu캖e je prepisati ga i naterati da pokazuje na la쬹i `fini_array` koji kontroli코e napada캜 sa adresom [**one gadgeta**](../rop-return-oriented-programing/ret2lib/one-gadget.md) na primer.

Nakon prethodnog koda mo쬰te prona캖i jo코 jedan interesantan odeljak sa kodom:
```c
/* Next try the old-style destructor.  */
ElfW(Dyn) *fini = map->l_info[DT_FINI];
if (fini != NULL)
DL_CALL_DT_FINI (map, ((void *) map->l_addr + fini->d_un.d_ptr));
}
```
U ovom slu캜aju bilo bi mogu캖e prebrisati vrednost `map->l_info[DT_FINI]` koja pokazuje na la쬴ranu strukturu `ElfW(Dyn)`. Prona캠ite [**vi코e informacija ovde**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure).

## Prepisivanje TLS-Skladi코ta dtor\_list u **`__run_exit_handlers`**

Kao 코to je [**obja코njeno ovde**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite), ako program iza캠e putem `return` ili `exit()`, izvr코i캖e se **`__run_exit_handlers()`** koji 캖e pozvati sve registrovane funkcije destruktora.

Kod iz `_run_exit_handlers()`:
```c
/* Call all functions registered with `atexit' and `on_exit',
in the reverse of the order in which they were registered
perform stdio cleanup, and terminate program execution with STATUS.  */
void
attribute_hidden
__run_exit_handlers (int status, struct exit_function_list **listp,
bool run_list_atexit, bool run_dtors)
{
/* First, call the TLS destructors.  */
#ifndef SHARED
if (&__call_tls_dtors != NULL)
#endif
if (run_dtors)
__call_tls_dtors ();
```
Kod iz **`__call_tls_dtors()`** funkcije:
```c
typedef void (*dtor_func) (void *);
struct dtor_list //struct added
{
dtor_func func;
void *obj;
struct link_map *map;
struct dtor_list *next;
};

[...]
/* Call the destructors.  This is called either when a thread returns from the
initial function or when the process exits via the exit function.  */
void
__call_tls_dtors (void)
{
while (tls_dtor_list)		// parse the dtor_list chained structures
{
struct dtor_list *cur = tls_dtor_list;		// cur point to tls-storage dtor_list
dtor_func func = cur->func;
PTR_DEMANGLE (func);						// demangle the function ptr

tls_dtor_list = tls_dtor_list->next;		// next dtor_list structure
func (cur->obj);
[...]
}
}
```
Za svaku registrovanu funkciju u **`tls_dtor_list`**, demantovira캖e pokaziva캜 iz **`cur->func`** i pozva캖e je sa argumentom **`cur->obj`**.

Kori코캖enjem **`tls`** funkcije iz ovog [**forka GEF-a**](https://github.com/bata24/gef), mogu캖e je videti da je **`dtor_list`** veoma **blizu** **stack canary**-ja i **PTR\_MANGLE cookie**-ja. Dakle, sa prekora캜enjem na njemu bilo bi mogu캖e **prepisati** **cookie** i **stack canary**.\
Prepisivanjem PTR\_MANGLE cookie-ja, bilo bi mogu캖e **zaobi캖i funkciju `PTR_DEMANLE`** postavljanjem je na 0x00, 코to zna캜i da je **`xor`** kori코캖en za dobijanje stvarne adrese samo adresa koja je konfigurisana. Zatim, upisivanjem u **`dtor_list`** mogu캖e je **povezati nekoliko funkcija** sa funkcijom **adrese** i njenim **argumentom.**

Na kraju, primetite da uskladi코teni pokaziva캜 ne캖e biti samo ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno ekskluzivno.
```armasm
0x00007fc390444dd4 <+36>:	mov    rax,QWORD PTR [rbx]      --> mangled ptr
0x00007fc390444dd7 <+39>:	ror    rax,0x11		        --> rotate of 17 bits
0x00007fc390444ddb <+43>:	xor    rax,QWORD PTR fs:0x30	--> xor with PTR_MANGLE
```
## Ostali izmenjeni pokaziva캜i u **`__run_exit_handlers`**

Ova tehnika je [**obja코njena ovde**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite) i ponovo zavisi od toga da program **iza캠e pozivaju캖i `return` ili `exit()`** tako da se pozove **`__run_exit_handlers()`**.

Hajde da proverimo vi코e koda ove funkcije:
```c
while (true)
{
struct exit_function_list *cur;

restart:
cur = *listp;

if (cur == NULL)
{
/* Exit processing complete.  We will not allow any more
atexit/on_exit registrations.  */
__exit_funcs_done = true;
break;
}

while (cur->idx > 0)
{
struct exit_function *const f = &cur->fns[--cur->idx];
const uint64_t new_exitfn_called = __new_exitfn_called;

switch (f->flavor)
{
void (*atfct) (void);
void (*onfct) (int status, void *arg);
void (*cxafct) (void *arg, int status);
void *arg;

case ef_free:
case ef_us:
break;
case ef_on:
onfct = f->func.on.fn;
arg = f->func.on.arg;
PTR_DEMANGLE (onfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
onfct (status, arg);
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_at:
atfct = f->func.at;
PTR_DEMANGLE (atfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
atfct ();
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_cxa:
/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
we must mark this function as ef_free.  */
f->flavor = ef_free;
cxafct = f->func.cxa.fn;
arg = f->func.cxa.arg;
PTR_DEMANGLE (cxafct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
cxafct (arg, status);
__libc_lock_lock (__exit_funcs_lock);
break;
}

if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
/* The last exit function, or another thread, has registered
more exit functions.  Start the loop over.  */
goto restart;
}

*listp = cur->next;
if (*listp != NULL)
/* Don't free the last element in the chain, this is the statically
allocate element.  */
free (cur);
}

__libc_lock_unlock (__exit_funcs_lock);
```
Promenljiva `f` pokazuje na strukturu **`initial`** i u zavisnosti od vrednosti `f->flavor` bi캖e pozvane razli캜ite funkcije.\
Adresa funkcije koja 캖e biti pozvana bi캖e na razli캜itom mestu u zavisnosti od vrednosti, ali 캖e uvek biti **demangleovana**.

Osim toga, u opcijama **`ef_on`** i **`ef_cxa`** tako캠e je mogu캖e kontrolisati **argument**.

Mogu캖e je proveriti **strukturu `initial`** u sesiji za debagovanje sa GEF pokretanjem **`gef> p initial`**.

Da biste iskoristili ovo, potrebno je ili **procureti ili izbrisati `PTR_MANGLE` kola캜i캖** a zatim prepisati `cxa` unos u initial sa `system('/bin/sh')`.\
Mo쬰te prona캖i primer ovoga u [**originalnom blog postu o tehnici**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#6---code-execution-via-other-mangled-pointers-in-initial-structure).
