# 기본 이진 파일 악용 방법론

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com) 획득
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## ELF 기본 정보

어떤 것을 악용하기 전에 **ELF 바이너리**의 구조 일부를 이해하는 것이 흥미로울 수 있습니다:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## 악용 도구

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## 스택 오버플로우 방법론

다양한 기술이 있기 때문에 각 기술이 언제 유용할지 알 수 있는 체계를 갖는 것이 좋습니다. 동일한 보호 기능이 다른 기술에 영향을 미칠 수 있음을 유의하십시오. 각 보호 기능 섹션에서 보호 기능을 우회하는 방법을 찾을 수 있지만 이 방법론에서는 다루지 않습니다.

## 흐름 제어

프로그램의 흐름을 제어하는 여러 가지 방법이 있습니다:

* **스택 오버플로우**를 통해 스택에서 반환 포인터 또는 EBP -> ESP -> EIP를 덮어쓰기
* **정수 오버플로우**를 낼 수도 있음
* 또는 **임의 쓰기 + 실행할 내용이 있는 위치로 쓰기**
* **포맷 문자열**: `printf`를 남용하여 임의의 내용을 임의의 주소에 쓰기
* **배열 인덱싱**: 잘못 설계된 인덱싱을 악용하여 일부 배열을 제어하고 임의 쓰기를 얻을 수 있음
* **정수 오버플로우**를 낼 수도 있음
* **bof to WWW via ROP**: 버퍼 오버플로우를 악용하여 ROP를 구성하고 WWW를 얻을 수 있음.

**Write What Where to Execution** 기술은 다음에서 찾을 수 있습니다:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## 영원한 루프

일반적으로 **취약점의 단일 악용만으로는** 성공적인 악용을 실행하는 데 충분하지 않을 수 있음을 고려해야 합니다. 특히 일부 보호 기능을 우회해야 할 수 있습니다. 따라서 **단일 취약점을 동일한 이진 파일 실행 중에 여러 번 악용할 수 있는 옵션을 논의**하는 것이 흥미로울 수 있습니다:

* **ROP** 체인에 **`main` 함수의 주소** 또는 **취약점이 발생하는 주소**를 쓰기
* 적절한 ROP 체인을 제어하여 해당 체인에서 모든 작업을 수행할 수 있음
* **`exit` 주소를 GOT에 쓰기** (또는 종료 전에 이진 파일에서 사용되는 다른 함수)하여 **취약점으로 돌아가는 주소**를 쓰기
* [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)에서 설명한대로 여기에 2개의 함수를 저장하여 취약점을 다시 호출하거나 **`__libc_csu_fini`**를 호출하여 `.fini_array`에서 함수를 다시 호출할 수 있음.

## 악용 목표

### 목표: 기존 함수 호출

* [**ret2win**](./#ret2win): 호출해야 하는 코드에 함수가 있음 (특정 매개변수와 함께) 플래그를 얻기 위해 호출해야 함.
* **PIE** 및 **canary** 없는 일반 bof의 경우 스택에 저장된 반환 주소에 주소를 쓰기만 하면 됨
* [**PIE**](../common-binary-protections-and-bypasses/pie/)가 있는 bof의 경우 우회해야 함
* [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)가 있는 bof의 경우 우회해야 함
* **ret2win** 함수를 올바르게 호출하려면 여러 매개변수를 설정해야 하는 경우:
* 충분한 가젯이 있는 경우 [**ROP**](./#rop-and-ret2...-techniques) 체인을 사용하여 모든 매개변수를 준비할 수 있음
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (이 시스템 호출을 호출할 수 있는 경우)을 사용하여 많은 레지스터를 제어할 수 있음
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) 및 [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)의 가젯을 사용하여 여러 레지스터를 제어할 수 있음
* [**Write What Where**](../arbitrary-write-2-exec/)를 통해 다른 취약점 (bof가 아닌)을 악용하여 **`win`** 함수를 호출할 수 있음.
* [**포인터 리다이렉팅**](../stack-overflow/pointer-redirecting.md): 호출될 함수 또는 흥미로운 함수(system 또는 printf)에서 사용될 문자열로 포인터가 있는 경우 해당 주소를 덮어쓸 수 있음
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) 또는 [**PIE**](../common-binary-protections-and-bypasses/pie/)가 주소에 영향을 줄 수 있음
* [**초기화되지 않은 변수**](../stack-overflow/uninitialized-variables.md): 알 수 없음.

### 목표: RCE

#### nx가 비활성화되어 있거나 셸코드와 ROP를 혼합하는 경우:

* **(스택) 셸코드**: 스택에 셸코드를 저장하고 반환 포인터를 덮거나 덮은 후에 **점프하여 실행**하는 데 유용함:
* 일반 bof에서 **canary**가 있는 경우 우회(유출)해야 함
* **ASLR** 및 **nx**가 없는 경우 스택 주소로 점프할 수 있으므로 주소로 점프할 수 있음
* **ASLR**가 있는 경우 [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md)와 같은 기술을 사용하여 점프할 수 있음
* **nx**가 있는 경우 [**ROP**](../rop-return-oriented-programing/)를 사용하여 `memprotect`를 호출하여 페이지를 `rwx`로 만든 다음 거기에 셸코드를 저장(예: read 호출)한 다음 거기로 점프해야 함
* 이는 셸코드를 ROP 체인과 혼합하는 것입니다.
#### 시스템 콜을 통해

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): 임의의 명령을 실행하기 위해 `execve`를 호출하는 데 유용합니다. **특정 시스템 콜을 호출하는 가젯을 찾을 수 있어야** 합니다.
* 만약 [**ASLR**](../common-binary-protections-and-bypasses/aslr/) 또는 [**PIE**](../common-binary-protections-and-bypasses/pie/)가 활성화되어 있다면 **바이너리나 라이브러리에서 ROP 가젯을 사용하기 위해 이를 우회해야** 합니다.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)은 **ret2execve를 준비하는 데 유용**할 수 있습니다.
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) 및 [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)에서 여러 레지스터를 제어하기 위한 가젯

#### libc를 통해

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): 주로 **`libc`**에서 **`system`**과 같은 함수를 호출하는 데 유용하며 일부 준비된 인수(예: `'/bin/sh'`)로 호출합니다. 호출하려는 함수가 있는 라이브러리를 **바이너리가 로드**해야 합니다(libc 일반적으로).
* **정적으로 컴파일되고** [**PIE**](../common-binary-protections-and-bypasses/pie/)가 없는 경우, `system` 및 `/bin/sh`의 **주소**가 변경되지 않으므로 정적으로 사용할 수 있습니다.
* **ASLR**가 **비활성화되어 있고 로드된 libc 버전을 알고 있는 경우**, `system` 및 `/bin/sh`의 **주소**가 변경되지 않으므로 정적으로 사용할 수 있습니다.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)가 있지만 [**PIE**](../common-binary-protections-and-bypasses/pie/)가 없는 경우, libc를 알고 있고 바이너리가 `system`을 사용하지 않는 경우:
* [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)를 사용하여 `system`의 주소를 해결하고 호출합니다&#x20;
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)를 우회하고 메모리에서 `system` 및 `'/bin/sh'`의 주소를 계산합니다.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) 및 [**PIE**](../common-binary-protections-and-bypasses/pie/)가 모두 활성화되어 있고 libc를 모르는 경우: 다음을 수행해야 합니다:
* [**PIE**](../common-binary-protections-and-bypasses/pie/) 우회
* 사용된 **`libc` 버전** 찾기 (몇 가지 함수 주소 누출)
* 계속하기 위해 **ASLR와 관련된 이전 시나리오** 확인

#### EBP/RBP를 통해

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): 저장된 EBP를 통해 ESP를 제어하여 스택에서 RET를 제어합니다.
* **오프 바이 원** 스택 오버플로우에 유용
* EIP를 제어하는 대체 방법으로 유용하며, EIP를 남용하여 메모리에서 페이로드를 구성한 다음 EBP를 통해 그것으로 이동하는 데 사용됩니다.

#### 기타

* [**포인터 리다이렉팅**](../stack-overflow/pointer-redirecting.md): 호출될 함수 또는 흥미로운 함수(system 또는 printf)에서 사용될 문자열로 이어지는 함수를 가리키는 포인터가 스택에 포함되어 있는 경우 해당 주소를 덮어쓸 수 있습니다.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) 또는 [**PIE**](../common-binary-protections-and-bypasses/pie/)가 주소에 영향을 줄 수 있습니다.
* [**초기화되지 않은 변수**](../stack-overflow/uninitialized-variables.md): 알 수 없습니다.
