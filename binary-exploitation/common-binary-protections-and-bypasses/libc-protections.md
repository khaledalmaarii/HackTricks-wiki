# Za코tita libc biblioteke

{% hint style="success" %}
Nau캜ite i ve쬭ajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Nau캜ite i ve쬭ajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Pomozite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Prinuda poravnanja delova

**Malloc** dodeljuje memoriju u grupama od **8 bajtova (32-bitni) ili 16 bajtova (64-bitni)**. To zna캜i da bi kraj delova u 32-bitnim sistemima trebalo da se poravna sa **0x8**, a u 64-bitnim sistemima sa **0x0**. Bezbednosna funkcija proverava da li se svaki deo **pravilno poravna** na ovim specifi캜nim lokacijama pre kori코캖enja pokaziva캜a iz binova.

### Bezbednosne prednosti

Prinuda poravnanja delova u 64-bitnim sistemima zna캜ajno pobolj코ava sigurnost Malloc-a tako 코to **ograni캜ava postavljanje la쬹ih delova na samo 1 od svakih 16 adresa**. Ovo ote쬬va napore za eksploataciju, posebno u scenarijima gde korisnik ima ograni캜enu kontrolu nad ulaznim vrednostima, 캜ine캖i napade slo쬰nijim i te쬴m za uspe코no izvr코avanje.

* **Napad na Fastbin na \_\_malloc\_hook**

Nove pravila poravnanja u Malloc-u tako캠e spre캜avaju klasi캜an napad koji uklju캜uje `__malloc_hook`. Ranije, napada캜i su mogli manipulisati veli캜inom delova da bi **prepisali ovaj pokaziva캜 funkcije** i stekli **izvr코avanje koda**. Sada, stroga zahtevnost poravnanja osigurava da takve manipulacije vi코e nisu izvodljive, zatvaraju캖i uobi캜ajenu rutu eksploatacije i pobolj코avaju캖i ukupnu sigurnost.

## Mutilacija pokaziva캜a na fastbinovima i tcache-u

**Mutilacija pokaziva캜a** je sigurnosno unapre캠enje koje se koristi za za코titu **fastbin i tcache Fd pokaziva캜a** u operacijama upravljanja memorijom. Ova tehnika poma쬰 u spre캜avanju odre캠enih vrsta taktika eksploatacije memorije, posebno onih koje ne zahtevaju procurele informacije o memoriji ili koje direktno manipuli코u lokacijama memorije relativno u odnosu na poznate pozicije (relativni **prepisivanja**).

Sr ove tehnike je obfuscaciona formula:

**`Novi_Ptr = (L >> 12) XOR P`**

* **L** je **Lokacija skladi코tenja** pokaziva캜a.
* **P** je stvarni **fastbin/tcache Fd Pokaziva캜**.

Razlog bitnog pomeranja lokacije skladi코tenja (L) za 12 bitova udesno pre XOR operacije je klju캜an. Ova manipulacija adresira ranjivost inherentnu u deterministi캜koj prirodi najmanje zna캜ajnih 12 bitova adresa memorije, koji su obi캜no predvidljivi zbog ograni캜enja arhitekture sistema. Pomeranjem bitova, predvidljivi deo se izbacuje iz jedna캜ine, pobolj코avaju캖i nasumi캜nost novog, mutiliranog pokaziva캜a i time 코tite캖i se od eksploatacija koje se oslanjaju na predvidljivost ovih bitova.

Ovaj mutilirani pokaziva캜 koristi postoje캖u nasumi캜nost koju pru쬬 **Randomizacija rasporeda adresnog prostora (ASLR)**, koja nasumi캜no raspore캠uje adrese koje koriste programi kako bi ote쬬la napada캜ima da predvide raspored memorije procesa.

**Demutilacija** pokaziva캜a radi povratka originalne adrese uklju캜uje kori코캖enje iste XOR operacije. Ovde se mutilirani pokaziva캜 tretira kao P u formuli, i kada se XOR-uje sa nepromenjenom lokacijom skladi코tenja (L), rezultira otkrivanjem originalnog pokaziva캜a. Ova simetrija u mutilaciji i demutilaciji osigurava da sistem mo쬰 efikasno enkodirati i dekodirati pokaziva캜e bez zna캜ajnog optere캖enja, dok zna캜ajno pove캖ava sigurnost protiv napada koji manipuli코u pokaziva캜ima memorije.

### Bezbednosne prednosti

Mutilacija pokaziva캜a ima za cilj da **spre캜i delimi캜na i potpuna prepisivanja pokaziva캜a u heap** upravljanju, 코to je zna캜ajno unapre캠enje u sigurnosti. Ova funkcija uti캜e na tehnike eksploatacije na nekoliko na캜ina:

1. **Spre캜avanje relativnih prepisivanja bajtova**: Ranije, napada캜i su mogli promeniti deo pokaziva캜a da bi **preusmerili delove heap-a na razli캜ite lokacije bez poznavanja ta캜nih adresa**, tehnika vidljiva u eksploataciji bez procurele informacije **House of Roman**. Sa mutilacijom pokaziva캜a, takva relativna prepisivanja **bez procurele heap-a sada zahtevaju grubu silu**, zna캜ajno smanjuju캖i verovatno캖u uspeha.
2. **Pove캖ana te쬴na napada na Tcache Bin/Fastbin**: Uobi캜ajeni napadi koji prepisuju pokaziva캜e funkcija (poput `__malloc_hook`) manipulacijom unosa fastbin-a ili tcache-a su ote쬬ni. Na primer, napad mo쬰 uklju캜ivati procurelu LibC adrese, osloba캠anje dela u tcache bin, a zatim prepisivanje Fd pokaziva캜a da bi ga preusmerili na `__malloc_hook` za izvr코avanje proizvoljnog koda. Sa mutilacijom pokaziva캜a, ovi pokaziva캜i moraju biti pravilno mutilirani, **zahtevaju캖i procurelu heap-a za ta캜nu manipulaciju**, time podi쬿캖i barijeru eksploatacije.
3. **Potreba za procurelom heap-a na ne-heap lokacijama**: Kreiranje la쬹og dela na lokacijama van heap-a (kao 코to su stek, .bss sekcija ili PLT/GOT) sada tako캠e **zahteva procurelu heap-a** zbog potrebe za mutilacijom pokaziva캜a. Ovo pro코iruje slo쬰nost eksploatisanja ovih oblasti, sli캜no zahtevu za manipulacijom LibC adresa.
4. **Procurela adresa heap-a postaje izazovnija**: Mutilacija pokaziva캜a ograni캜ava korisnost Fd pokaziva캜a u fastbin i tcache binovima kao izvora procurelih adresa heap-a. Me캠utim, pokaziva캜i u nesortiranim, malim i velikim binovima ostaju nemutilirani, i dalje korisni za procure adresa. Ova promena tera napada캜e da istra쬰 ove binove za iskoristive informacije, iako neke tehnike jo코 uvek mogu omogu캖iti demutilaciju pokaziva캜a pre procure, iako uz ograni캜enja.

### **Demutilacija pokaziva캜a sa procurelom heap-a**

{% hint style="danger" %}
Za bolje obja코njenje procesa [**proverite originalni post ovde**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Pregled algoritma

Formula kori코캖ena za mutilaciju i demutilaciju pokaziva캜a je:&#x20;

**`Novi_Ptr = (L >> 12) XOR P`**

Gde je **L** lokacija skladi코tenja, a **P** je Fd pokaziva캜. Kada se **L** pomeri udesno za 12 bitova, otkriva najzna캜ajnije bitove **P**, zbog prirode **XOR**, koji daje 0 kada se bitovi XOR-uju sa samim sobom.

**Klju캜ni koraci u algoritmu:**

1. **Po캜etna procurela najzna캜ajnijih bitova**: XOR-ovanjem pomerene **L** sa **P**, efikasno dobijate gornjih 12 bitova **P** jer 캖e pomerena deo **L** biti nula, ostavljaju캖i odgovaraju캖e bitove **P** nepromenjene.
2. **Obnova bitova pokaziva캜a**: Po코to je XOR reverzibilan, znaju캖i rezultat i jedan od operanada vam omogu캖ava da izra캜unate drugi operand. Ova osobina se koristi za zaklju캜ivanje celog skupa bitova za **P** sukcesivnim XOR-ovanjem poznatih setova bitova sa delovima mutiliranog pokaziva캜a.
3. **Iterativna demutilacija**: Proces se ponavlja, svaki put koriste캖i novo otkrivene bitove **P** iz prethodnog koraka za dekodiranje slede캖eg segmenta mutiliranog pokaziva캜a, dok se ne oporave svi bitovi.
4. **Rukovanje deterministi캜kim bitovima**: Poslednjih 12 bitova **L** su izgubljeni zbog pomeranja, ali su deterministi캜ki i mogu se rekonstruisati nakon procesa.

Implementaciju ovog algoritma mo쬰te prona캖i ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Za코tita pokaziva캜a

Za코tita pokaziva캜a je tehnika mitigacije eksploatacije kori코캖ena u glibc-u kako bi se za코titili uskladi코teni pokaziva캜i funkcija, posebno oni registrovani pozivima biblioteke poput `atexit()`. Ova za코tita uklju캜uje me코anje pokaziva캜a XOR-ovanjem sa tajnom uskladi코tenom u podacima niti (`fs:0x30`) i primenom bitovske rotacije. Ovaj mehanizam ima za cilj da spre캜i napada캜e da preuzmu kontrolu toka izvr코avanja preko prepisivanja pokaziva캜a funkcija.

### **Bajpasovanje za코tite pokaziva캜a pomo캖u procurivanja**

1. **Razumevanje operacija za코tite pokaziva캜a:** Me코anje pokaziva캜a se vr코i kori코캖enjem makroa `PTR_MANGLE` koji XOR-uje pokaziva캜 sa 64-bitnom tajnom, a zatim vr코i levu rotaciju za 0x11 bitova. Obrnuta operacija za vra캖anje originalnog pokaziva캜a se obavlja pomo캖u `PTR_DEMANGLE`.
2. **Strategija napada:** Napad se zasniva na pristupu poznatog teksta, gde napada캜 mora znati kako originalnu, tako i izmenjenu verziju pokaziva캜a kako bi zaklju캜io tajnu kori코tenu za me코anje.
3. **Eksploatisanje poznatih tekstova:**
* **Identifikacija fiksnih pokaziva캜a funkcija:** Prou캜avanjem izvornog koda glibc-a ili inicijalizovanih tabela pokaziva캜a funkcija (kao 코to su `__libc_pthread_functions`), napada캜 mo쬰 prona캖i predvidljive pokaziva캜e funkcija.
* **Ra캜unanje tajne:** Kori코캖enjem poznatog pokaziva캜a funkcije poput `__pthread_attr_destroy` i njegove izmenjene verzije iz tabele pokaziva캜a funkcija, tajna se mo쬰 izra캜unati obrnutim rotiranjem (desna rotacija) izmenjenog pokaziva캜a, a zatim XOR-ovanjem sa adresom funkcije.
4. **Alternativni poznati tekstovi:** Napada캜 tako캠e mo쬰 eksperimentisati sa me코anjem pokaziva캜a sa poznatim vrednostima poput 0 ili -1 kako bi video da li ove vrednosti proizvode prepoznatljive obrasce u memoriji, potencijalno otkrivaju캖i tajnu kada se ovi obrasci prona캠u u isecima memorije.
5. **Prakti캜na primena:** Nakon 코to se izra캜una tajna, napada캜 mo쬰 manipulisati pokaziva캜ima na kontrolisan na캜in, su코tinski zaobilaze캖i za코titu pokaziva캜a u vi코enitnoj aplikaciji sa znanjem o baznoj adresi libc-a i sposobno코캖u 캜itanja proizvoljnih lokacija memorije.

## Reference

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
