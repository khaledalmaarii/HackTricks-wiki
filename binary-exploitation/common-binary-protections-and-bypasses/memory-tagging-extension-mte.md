# Pro코irenje oznake memorije (MTE)

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodi캜u PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

**Pro코irenje oznake memorije (MTE)** je dizajnirano da pobolj코a pouzdanost i sigurnost softvera **detektovanjem i spre캜avanjem gre코aka povezanih sa memorijom**, kao 코to su preplavljenje bafera i ranjivosti kori코캖enja nakon osloba캠anja. MTE, kao deo **ARM** arhitekture, pru쬬 mehanizam za povezivanje **male oznake sa svakom alokacijom memorije** i **odgovaraju캖om oznakom sa svakim pokaziva캜em** koji referi코e na tu memoriju. Ovaj pristup omogu캖ava detektovanje nelegalnih pristupa memoriji u toku izvr코avanja, zna캜ajno smanjuju캖i rizik od iskori코캖avanja takvih ranjivosti za izvr코avanje proizvoljnog koda.

### **Kako radi pro코irenje oznake memorije**

MTE funkcioni코e tako 코to **deli memoriju na male blokove fiksne veli캜ine, pri 캜emu se svakom bloku dodeljuje oznaka**, obi캜no nekoliko bitova u veli캜ini.&#x20;

Kada se kreira pokaziva캜 koji pokazuje na tu memoriju, on dobija istu oznaku. Ova oznaka se 캜uva u **neiskori코캖enim bitovima pokaziva캜a memorije**, efikasno povezuju캖i pokaziva캜 sa odgovaraju캖im blokom memorije.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokaziva캜a, MTE hardver proverava da li **oznaka pokaziva캜a odgovara oznaci bloka memorije**. Ako se oznake **ne poklapaju**, to ukazuje na **nelegalan pristup memoriji**.

### Oznake pokaziva캜a MTE

Oznake unutar pokaziva캜a se 캜uvaju u 4 bita unutar gornjeg bajta:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omogu캖ava do **16 razli캜itih vrednosti oznaka**.

### Oznake memorije MTE

Svaka **16B fizi캜ke memorije** ima odgovaraju캖u **oznaku memorije**.

Oznake memorije se 캜uvaju u **dedikovanom RAM regionu** (nije dostupan za normalnu upotrebu). Imaju캖i 4bitne oznake za svakih 16B oznaka memorije do 3% RAM-a.

ARM uvodi slede캖e instrukcije za manipulisanje ovim oznakama u dedikovanom RAM memoriji:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Provera re쬴ma

### Sinkrono

CPU proverava oznake **tokom izvr코avanja instrukcije**, ako postoji neslaganje, podi쬰 izuzetak.\
Ovo je najsporije i najsigurnije.

### Asinkrono

CPU proverava oznake **asinkrono**, i kada se prona캠e neslaganje, postavlja bit izuzetka u jedan od sistemskih registara. Br쬰 je od prethodnog, ali **nije u mogu캖nosti da poka쬰** ta캜nu instrukciju koja je uzrokovala neslaganje i ne podi쬰 izuzetak odmah, pru쬬ju캖i vremena napada캜u da zavr코i svoj napad.

### Me코ovito

???

## Primeri implementacije i detekcije

Nazvan Hardverski Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel alokatori (poput `kmalloc`) 캖e **pozvati ovaj modul** koji 캖e pripremiti oznaku za kori코캖enje (nasumi캜no) i prilo쬴ti je na alocirani kernel prostor i na vra캖eni pokaziva캜.

Imajte na umu da 캖e ozna캜iti **samo dovoljno memorijskih granula** (svaka 16B) za tra쬰nu veli캜inu. Dakle, ako je tra쬰na veli캜ina bila 35 i dodeljen je slajb od 60B, ozna캜i캖e prvih 16\*3 = 48B ovom oznakom, a **ostatak** 캖e biti **ozna캜en** tzv. **neva쬰캖om oznakom (0xE)**.

Oznaka **0xF** je **poklapanje svih pokaziva캜a**. Memorija sa ovim pokaziva캜em dozvoljava **bilo koju oznaku za pristup** svojoj memoriji (bez neslaganja). Ovo bi moglo spre캜iti MET da otkrije napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka jer su 0xE i 0xF rezervisani, daju캖i verovatno캖u **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **neva쬰캖oj memorijskoj granuli**, **neslaganje** 캖e biti **detektovano**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima druga캜iju oznaku** (ili neva쬰캖u oznaku), neslaganje 캖e biti **detektovano**. Ako napada캜 ima sre캖e i memorija koristi istu oznaku, ne캖e biti detektovano. Verovatno캖a je oko 7%.

Jo코 jedan problem se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija zatra쬴la 35B, dodeljena je granula od 32 do 48. Stoga, **bajtovi od 36 do 47 koriste istu oznaku** ali nisu bili tra쬰ni. Ako napada캜 pristupi **ovim dodatnim bajtovima, to ne캖e biti detektovano**.

Kada se izvr코i **`kfree()`**, memorija se ponovo ozna캜ava neva쬰캖om oznakom, tako da u **upotrebi nakon osloba캠anja**, kada se memorija ponovo pristupi, **neslaganje se detektuje**.

Me캠utim, u upotrebi nakon osloba캠anja, ako se isti **blok ponovo alocira sa ISTOM oznakom** kao prethodno, napada캜 캖e mo캖i da koristi ovaj pristup i to ne캖e biti detektovano (oko 7% 코anse).

Osim toga, samo **`slab` i `page_alloc`** koriste ozna캜enu memoriju, ali u budu캖nosti 캖e se ovo koristiti i u `vmalloc`, `stack` i `globals` (u trenutku videa ovo jo코 uvek mo쬰 biti zloupotrebljeno).

Kada se **detektuje neslaganje**, kernel 캖e **pani캜iti** kako bi spre캜io dalje iskori코캖avanje i poku코aje eksploatacije (MTE nema la쬹ih pozitiva).

## Reference

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
