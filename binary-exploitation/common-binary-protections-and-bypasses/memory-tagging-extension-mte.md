# Rozszerzenie oznaczania pamiÄ™ci (MTE)

{% hint style="success" %}
Dowiedz siÄ™ i Ä‡wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz siÄ™ i Ä‡wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **UdostÄ™pnij sztuczki hakerskie, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w na GitHubie.

</details>
{% endhint %}

## Podstawowe informacje

**Rozszerzenie oznaczania pamiÄ™ci (MTE)** zostaÅ‚o zaprojektowane w celu zwiÄ™kszenia niezawodnoÅ›ci i bezpieczeÅ„stwa oprogramowania poprzez **wykrywanie i zapobieganie bÅ‚Ä™dom zwiÄ…zanym z pamiÄ™ciÄ…**, takim jak przepeÅ‚nienia bufora i podatnoÅ›ci typu uÅ¼yj-po-zwolnieniu. MTE, jako czÄ™Å›Ä‡ architektury **ARM**, zapewnia mechanizm doÅ‚Ä…czania **maÅ‚ej etykiety do kaÅ¼dej alokacji pamiÄ™ci** oraz **odpowiadajÄ…cej etykiety do kaÅ¼dego wskaÅºnika** odnoszÄ…cego siÄ™ do tej pamiÄ™ci. Ten podejÅ›cie umoÅ¼liwia wykrywanie nielegalnych dostÄ™pÃ³w do pamiÄ™ci w czasie wykonywania, znacznie zmniejszajÄ…c ryzyko wykorzystania takich podatnoÅ›ci do wykonania arbitralnego kodu.

### **Jak dziaÅ‚a Rozszerzenie oznaczania pamiÄ™ci**

MTE dziaÅ‚a poprzez **podziaÅ‚ pamiÄ™ci na maÅ‚e bloki o staÅ‚ym rozmiarze, z przypisanÄ… do kaÅ¼dego bloku etykietÄ…,** zwykle o kilka bitÃ³w.&#x20;

Gdy tworzony jest wskaÅºnik wskazujÄ…cy na tÄ™ pamiÄ™Ä‡, otrzymuje on tÄ™ samÄ… etykietÄ™. Ta etykieta jest przechowywana w **nieuÅ¼ywanych bitach wskaÅºnika pamiÄ™ci**, efektywnie Å‚Ä…czÄ…c wskaÅºnik z odpowiadajÄ…cym mu blokiem pamiÄ™ci.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Gdy program uzyskuje dostÄ™p do pamiÄ™ci za pomocÄ… wskaÅºnika, sprzÄ™t MTE sprawdza, czy **etykieta wskaÅºnika odpowiada etykiecie bloku pamiÄ™ci**. JeÅ›li **etykiety siÄ™ nie zgadzajÄ…**, oznacza to **nielegalny dostÄ™p do pamiÄ™ci.**

### Etykiety wskaÅºnikÃ³w MTE

Etykiety wewnÄ…trz wskaÅºnika sÄ… przechowywane w 4 bitach w gÃ³rnej bajcie:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Dlatego pozwala to na **16 rÃ³Å¼nych wartoÅ›ci etykiet.**

### Etykiety pamiÄ™ci MTE

KaÅ¼de **16B pamiÄ™ci fizycznej** ma odpowiadajÄ…cÄ… **etykietÄ™ pamiÄ™ci.**

Etykiety pamiÄ™ci sÄ… przechowywane w **dedykowanej strefie RAM** (niedostÄ™pnej do normalnego uÅ¼ytku). Posiadanie etykiet 4 bitÃ³w dla kaÅ¼dych 16B etykiet pamiÄ™ci zajmuje do 3% pamiÄ™ci RAM.

ARM wprowadza nastÄ™pujÄ…ce instrukcje do manipulowania tymi etykietami w dedykowanej pamiÄ™ci RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Tryby sprawdzania

### Sync

CPU sprawdza tagi **podczas wykonywania instrukcji**, jeÅ›li wystÄ…pi niezgodnoÅ›Ä‡, generowany jest wyjÄ…tek.\
To najwolniejsze i najbardziej bezpieczne.

### Async

CPU sprawdza tagi **asynchronicznie**, a gdy zostanie znaleziona niezgodnoÅ›Ä‡, ustawia bit wyjÄ…tku w jednym z rejestrÃ³w systemowych. Jest to **szybsze** niÅ¼ poprzednie, ale **nie jest w stanie wskazaÄ‡** dokÅ‚adnej instrukcji, ktÃ³ra spowodowaÅ‚a niezgodnoÅ›Ä‡, i nie generuje wyjÄ…tku natychmiast, dajÄ…c trochÄ™ czasu atakujÄ…cemu na ukoÅ„czenie ataku.

### Mixed

???

## PrzykÅ‚ady implementacji i wykrywania

Nazywane Hardware Tag-Based KASAN, MTE-based KASAN lub in-kernel MTE.\
Alokatory jÄ…dra (np. `kmalloc`) bÄ™dÄ… **wywoÅ‚ywaÄ‡ ten moduÅ‚**, ktÃ³ry przygotuje tag do uÅ¼ycia (losowo) i doÅ‚Ä…czy go do zaalokowanej przestrzeni jÄ…dra oraz do zwrÃ³conego wskaÅºnika.

ZauwaÅ¼, Å¼e zostanÄ… oznaczone tylko wystarczajÄ…ce granule pamiÄ™ci (kaÅ¼dy po 16B) dla Å¼Ä…danej wielkoÅ›ci. Dlatego jeÅ›li Å¼Ä…dana wielkoÅ›Ä‡ wynosiÅ‚a 35, a przydzielono kawaÅ‚ek o wielkoÅ›ci 60B, zostanÄ… oznaczone pierwsze 16\*3 = 48B tym tagiem, a **reszta** zostanie **oznaczona** tzw. **nieprawidÅ‚owym tagiem (0xE)**.

Tag **0xF** to **wskaÅºnik dopasowania wszystkich**. PamiÄ™Ä‡ z tym wskaÅºnikiem pozwala na **uÅ¼ycie dowolnego tagu** do dostÄ™pu do swojej pamiÄ™ci (brak niezgodnoÅ›ci). MoÅ¼e to uniemoÅ¼liwiÄ‡ wykrycie ataku przez MET, jeÅ›li ten tag jest uÅ¼ywany w atakowanej pamiÄ™ci.

Dlatego istnieje tylko **14 wartoÅ›ci**, ktÃ³re moÅ¼na uÅ¼yÄ‡ do generowania tagÃ³w, poniewaÅ¼ 0xE i 0xF sÄ… zarezerwowane, co daje prawdopodobieÅ„stwo **ponownego uÅ¼ycia tagÃ³w** wynoszÄ…ce 1/17 -> okoÅ‚o **7%**.

JeÅ›li jÄ…dro uzyska dostÄ™p do **granulu z nieprawidÅ‚owym tagiem**, zostanie wykryta **niezgodnoÅ›Ä‡**. JeÅ›li uzyska dostÄ™p do innej lokalizacji pamiÄ™ci, a **pamiÄ™Ä‡ ma inny tag** (lub nieprawidÅ‚owy tag), zostanie wykryta **niezgodnoÅ›Ä‡**. JeÅ›li atakujÄ…cy ma szczÄ™Å›cie i pamiÄ™Ä‡ uÅ¼ywa tego samego tagu, nie zostanie to wykryte. Szanse wynoszÄ… okoÅ‚o 7%.

Inny bÅ‚Ä…d wystÄ™puje w **ostatnim granulu** zaalokowanej pamiÄ™ci. JeÅ›li aplikacja zaÅ¼Ä…daÅ‚a 35B, otrzymaÅ‚a granul od 32 do 48. Dlatego **bajty od 36 do 47 uÅ¼ywajÄ… tego samego tagu**, ale nie byÅ‚y Å¼Ä…dane. JeÅ›li atakujÄ…cy uzyska dostÄ™p do **tych dodatkowych bajtÃ³w, nie zostanie to wykryte**.

Gdy zostanie wykonane **`kfree()`**, pamiÄ™Ä‡ zostanie ponownie oznaczona nieprawidÅ‚owym tagiem pamiÄ™ci, wiÄ™c w przypadku **uÅ¼ycia po zwolnieniu**, gdy pamiÄ™Ä‡ zostanie ponownie dostÄ™pna, zostanie wykryta **niezgodnoÅ›Ä‡**.

Jednak w przypadku uÅ¼ycia po zwolnieniu, jeÅ›li ten sam **kawaÅ‚ek zostanie ponownie zaalokowany z TAKIM SAMYM tagiem** jak wczeÅ›niej, atakujÄ…cy bÄ™dzie mÃ³gÅ‚ skorzystaÄ‡ z tego dostÄ™pu, a to nie zostanie wykryte (okoÅ‚o 7% szans).

Ponadto tylko **`slab` i `page_alloc`** uÅ¼ywajÄ… oznaczonej pamiÄ™ci, ale w przyszÅ‚oÅ›ci bÄ™dzie to rÃ³wnieÅ¼ stosowane w `vmalloc`, `stack` i `globals` (w momencie nagrania wciÄ…Å¼ moÅ¼na je naduÅ¼ywaÄ‡).

Gdy zostanie wykryta **niezgodnoÅ›Ä‡**, jÄ…dro **zawiesi siÄ™**, aby zapobiec dalszemu wykorzystaniu i prÃ³bom wykorzystania luki (MTE nie generuje faÅ‚szywych alarmÃ³w).

## Referencje

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
