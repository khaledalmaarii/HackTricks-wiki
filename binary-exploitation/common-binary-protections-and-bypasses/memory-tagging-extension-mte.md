# ProÅ¡irenje oznaka memorije (MTE)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

ProÅ¡irenje oznaka memorije (MTE) dizajnirano je da unapredi pouzdanost i bezbednost softvera **detektovanjem i spreÄavanjem greÅ¡aka povezanih sa memorijom**, kao Å¡to su preplavljenje bafera i ranjivosti nakon oslobaÄ‘anja. MTE, kao deo **ARM** arhitekture, pruÅ¾a mehanizam za prikaÄenje **male oznake svakoj alokaciji memorije** i **odgovarajuÄ‡e oznake svakom pokazivaÄu** koji referiÅ¡e na tu memoriju. Ovaj pristup omoguÄ‡ava detekciju nelegalnih pristupa memoriji u toku izvrÅ¡avanja, znaÄajno smanjujuÄ‡i rizik od iskoriÅ¡Ä‡avanja takvih ranjivosti za izvrÅ¡avanje proizvoljnog koda.

### **Kako radi ProÅ¡irenje oznaka memorije**

MTE funkcioniÅ¡e tako Å¡to **deli memoriju na male blokove fiksne veliÄine, pri Äemu se svakom bloku dodeljuje oznaka**, obiÄno nekoliko bitova u veliÄini.&#x20;

Kada se kreira pokazivaÄ koji pokazuje na tu memoriju, dobija istu oznaku. Ova oznaka se Äuva u **neiskoriÅ¡Ä‡enim bitovima pokazivaÄa memorije**, efikasno povezujuÄ‡i pokazivaÄ sa odgovarajuÄ‡im blokom memorije.

<figure><img src="../../.gitbook/assets/image (1199).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokazivaÄa, MTE hardver proverava da li **oznaka pokazivaÄa odgovara oznaci bloka memorije**. Ako se oznake **ne poklapaju**, to ukazuje na **nelegalan pristup memoriji**.

### Oznake pokazivaÄa MTE

Oznake unutar pokazivaÄa Äuvaju se u 4 bita unutar gornjeg bajta:

<figure><img src="../../.gitbook/assets/image (1200).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omoguÄ‡ava do **16 razliÄitih vrednosti oznaka**.

### Oznake memorije MTE

Svaki **16B fiziÄke memorije** ima odgovarajuÄ‡u **oznaku memorije**.

Oznake memorije Äuvaju se u **dedikovanom RAM regionu** (nije dostupan za normalnu upotrebu). ImajuÄ‡i 4-bitne oznake za svakih 16B oznaka memorije do 3% RAM-a.

ARM uvodi sledeÄ‡e instrukcije za manipulisanje ovim oznakama u dedikovanom RAM memoriji:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Provera reÅ¾ima

### Sinkrono

CPU proverava oznake **tokom izvrÅ¡avanja instrukcije**, ako postoji neusklaÄ‘enost, podiÅ¾e izuzetak.\
Ovo je najsporije i najsigurnije.

### Asinkrono

CPU proverava oznake **asinkrono**, i kada se pronaÄ‘e neusklaÄ‘enost, postavlja bit izuzetka u jednom od sistemskih registara. BrÅ¾e je od prethodnog, ali **nije u moguÄ‡nosti da pokaÅ¾e** taÄnu instrukciju koja je uzrokovala neusklaÄ‘enost i ne podiÅ¾e izuzetak odmah, pruÅ¾ajuÄ‡i vremena napadaÄu da zavrÅ¡i svoj napad.

### MeÅ¡ovito

???

## Primeri implementacije i detekcije

Nazvan Hardverski baziran KASAN sa oznakama, MTE-baziran KASAN ili u-kernel MTE.\
Kernel alokatori (kao Å¡to je `kmalloc`) Ä‡e **pozvati ovaj modul** koji Ä‡e pripremiti oznaku za koriÅ¡Ä‡enje (nasumiÄno) i priloÅ¾iti je na alocirani kernel prostor i na vraÄ‡eni pokazivaÄ.

Imajte na umu da Ä‡e oznaÄiti samo dovoljno memorijskih granula (svaka 16B) za traÅ¾enu veliÄinu. Dakle, ako je traÅ¾ena veliÄina bila 35 i dodeljen je slajb od 60B, oznaÄiÄ‡e prvih 16\*3 = 48B sa ovom oznakom, a **ostatak** Ä‡e biti **oznaÄen** sa tzv. **nevaÅ¾eÄ‡om oznakom (0xE)**.

Oznaka **0xF** je **poklapanje svih pokazivaÄa**. Memorija sa ovim pokazivaÄem dozvoljava **bilo koju oznaku za pristup** svojoj memoriji (bez neusklaÄ‘enosti). Ovo bi moglo spreÄiti MET da otkrije napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka jer su 0xE i 0xF rezervisani, dajuÄ‡i verovatnoÄ‡u **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **nevaÅ¾eÄ‡oj memorijskoj granuli**, **neusklaÄ‘enost** Ä‡e biti **detektovana**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima drugaÄiju oznaku** (ili nevaÅ¾eÄ‡u oznaku), neusklaÄ‘enost Ä‡e biti **detektovana**. Ako napadaÄ ima sreÄ‡e i memorija koristi istu oznaku, neÄ‡e biti detektovana. VerovatnoÄ‡a je oko 7%.

JoÅ¡ jedan problem se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija zatraÅ¾ila 35B, dodeljena je granula od 32 do 48. Stoga, **bajtovi od 36 do 47 koriste istu oznaku** ali nisu bili traÅ¾eni. Ako napadaÄ pristupi **ovim dodatnim bajtovima, to neÄ‡e biti detektovano**.

Kada se izvrÅ¡i **`kfree()`**, memorija se ponovo oznaÄava nevaÅ¾eÄ‡om oznakom, tako da u sluÄaju **koriÅ¡Ä‡enja nakon oslobaÄ‘anja**, kada se memorija ponovo pristupi, **neusklaÄ‘enost se detektuje**.

MeÄ‘utim, u sluÄaju koriÅ¡Ä‡enja nakon oslobaÄ‘anja, ako se isti **blok ponovo alocira sa ISTOM oznakom** kao prethodno, napadaÄ Ä‡e moÄ‡i da koristi ovaj pristup i to neÄ‡e biti detektovano (oko 7% Å¡anse).

Osim toga, samo **`slab` i `page_alloc`** koriste oznaÄenu memoriju, ali u buduÄ‡nosti Ä‡e se ovo koristiti i u `vmalloc`, `stack` i `globals` (u trenutku videa ovo joÅ¡ uvek moÅ¾e biti zloupotrebljeno).

Kada se **detektuje neusklaÄ‘enost**, kernel Ä‡e **paniÄiti** kako bi spreÄio dalje eksploatacije i pokuÅ¡aje eksploatacije (MTE nema laÅ¾ne pozitivne rezultate).

## Reference

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
