# Extens√£o de Marca√ß√£o de Mem√≥ria (MTE)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

A **Extens√£o de Marca√ß√£o de Mem√≥ria (MTE)** √© projetada para aprimorar a confiabilidade e seguran√ßa do software ao **detectar e prevenir erros relacionados √† mem√≥ria**, como estouro de buffer e vulnerabilidades de uso ap√≥s libera√ß√£o. O MTE, como parte da arquitetura **ARM**, fornece um mecanismo para anexar uma **pequena tag a cada aloca√ß√£o de mem√≥ria** e uma **tag correspondente a cada ponteiro** que referencia essa mem√≥ria. Esse m√©todo permite a detec√ß√£o de acessos ilegais √† mem√≥ria em tempo de execu√ß√£o, reduzindo significativamente o risco de explorar tais vulnerabilidades para executar c√≥digo arbitr√°rio.

### **Como a Extens√£o de Marca√ß√£o de Mem√≥ria Funciona**

O MTE opera dividindo a mem√≥ria em blocos pequenos de tamanho fixo, com cada bloco atribu√≠do a uma tag, geralmente de alguns bits de tamanho.&#x20;

Quando um ponteiro √© criado para apontar para essa mem√≥ria, ele recebe a mesma tag. Essa tag √© armazenada nos **bits n√£o utilizados de um ponteiro de mem√≥ria**, vinculando efetivamente o ponteiro ao bloco de mem√≥ria correspondente.

<figure><img src="../../.gitbook/assets/image (1199).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Quando um programa acessa a mem√≥ria por meio de um ponteiro, o hardware MTE verifica se a **tag do ponteiro corresponde √† tag do bloco de mem√≥ria**. Se as tags **n√£o corresponderem**, isso indica um **acesso ilegal √† mem√≥ria**.

### Tags de Ponteiro MTE

As tags dentro de um ponteiro s√£o armazenadas em 4 bits dentro do byte superior:

<figure><img src="../../.gitbook/assets/image (1200).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Portanto, isso permite at√© **16 valores de tag diferentes**.

### Tags de Mem√≥ria MTE

Cada **16B de mem√≥ria f√≠sica** tem uma **tag de mem√≥ria correspondente**.

As tags de mem√≥ria s√£o armazenadas em uma **regi√£o de RAM dedicada** (n√£o acess√≠vel para uso normal). Tendo tags de 4 bits para cada 16B de tags de mem√≥ria, at√© 3% da RAM.

A ARM introduz as seguintes instru√ß√µes para manipular essas tags na mem√≥ria RAM dedicada:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modos de Verifica√ß√£o

### S√≠ncrono

A CPU verifica as tags **durante a execu√ß√£o da instru√ß√£o**, se houver uma diferen√ßa, ela gera uma exce√ß√£o.\
Este √© o mais lento e mais seguro.

### Ass√≠ncrono

A CPU verifica as tags **de forma ass√≠ncrona**, e quando uma diferen√ßa √© encontrada, define um bit de exce√ß√£o em um dos registradores do sistema. √â **mais r√°pido** que o anterior, mas √© **incapaz de apontar** a instru√ß√£o exata que causou a diferen√ßa e n√£o gera a exce√ß√£o imediatamente, dando tempo ao atacante para completar seu ataque.

### Misto

???

## Exemplos de Implementa√ß√£o e Detec√ß√£o

Chamado de KASAN baseado em Tags de Hardware, KASAN baseado em MTE ou MTE no kernel.\
Os alocadores do kernel (como `kmalloc`) ir√£o **chamar este m√≥dulo** que ir√° preparar a tag a ser usada (aleatoriamente), anex√°-la ao espa√ßo do kernel alocado e ao ponteiro retornado.

Observe que ele ir√° **marcar apenas gr√¢nulos de mem√≥ria suficientes** (16B cada) para o tamanho solicitado. Portanto, se o tamanho solicitado foi 35 e um bloco de 60B foi dado, ele marcar√° os primeiros 16\*3 = 48B com esta tag e o **restante** ser√° **marcado** com uma chamada **tag inv√°lida (0xE)**.

A tag **0xF** √© o **ponteiro de correspond√™ncia total**. Uma mem√≥ria com este ponteiro permite **qualquer tag ser usada** para acessar sua mem√≥ria (sem diferen√ßas). Isso poderia impedir o MET de detectar um ataque se esta tag estiver sendo usada na mem√≥ria atacada.

Portanto, existem apenas **14 valores** que podem ser usados para gerar tags, pois 0xE e 0xF s√£o reservados, dando uma probabilidade de **reutiliza√ß√£o de tags** de 1/17 -> cerca de **7%**.

Se o kernel acessar o **gr√¢nulo de tag inv√°lido**, a **diferen√ßa** ser√° **detectada**. Se acessar outra localiza√ß√£o de mem√≥ria, se a **mem√≥ria tiver uma tag diferente** (ou a tag inv√°lida), a diferen√ßa ser√° **detectada**. Se o atacante tiver sorte e a mem√≥ria estiver usando a mesma tag, n√£o ser√° detectado. As chances s√£o de cerca de 7%.

Outro bug ocorre no **√∫ltimo gr√¢nulo** da mem√≥ria alocada. Se a aplica√ß√£o solicitou 35B, foi dado o gr√¢nulo de 32 a 48. Portanto, os **bytes de 36 a 47 est√£o usando a mesma tag** mas n√£o foram solicitados. Se o atacante acessar **esses bytes extras, isso n√£o ser√° detectado**.

Quando o **`kfree()`** √© executado, a mem√≥ria √© retageada com a tag de mem√≥ria inv√°lida, ent√£o em um **uso ap√≥s libera√ß√£o**, quando a mem√≥ria √© acessada novamente, a **diferen√ßa √© detectada**.

No entanto, em um uso ap√≥s libera√ß√£o, se o mesmo **bloco for realocado novamente com a MESMA tag** como anteriormente, um atacante poder√° usar este acesso e isso n√£o ser√° detectado (cerca de 7% de chance).

Al√©m disso, apenas **`slab` e `page_alloc`** usam mem√≥ria marcada, mas no futuro isso tamb√©m ser√° usado em `vmalloc`, `stack` e `globals` (no momento do v√≠deo, esses ainda podem ser explorados).

Quando uma **diferen√ßa √© detectada**, o kernel ir√° **entrar em p√¢nico** para evitar futuras explora√ß√µes e tentativas do exploit (MTE n√£o tem falsos positivos).

## Refer√™ncias

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
