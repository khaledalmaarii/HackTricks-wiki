# Stack Canaries

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## **StackGuard und StackShield**

**StackGuard** f√ºgt einen speziellen Wert, bekannt als **Canary**, vor dem **EIP (Extended Instruction Pointer)** ein, speziell `0x000aff0d` (null, Zeilenumbruch, EOF, Wagenr√ºcklauf), um sich vor Puffer√ºberl√§ufen zu sch√ºtzen. Funktionen wie `recv()`, `memcpy()`, `read()` und `bcopy()` bleiben jedoch anf√§llig, und es sch√ºtzt nicht den **EBP (Base Pointer)**.

**StackShield** geht mit einem **Globalen R√ºckgabestapel** einen anspruchsvolleren Ansatz als StackGuard, der alle R√ºckgabeadressen (**EIPs**) speichert. Diese Einrichtung stellt sicher, dass ein √úberlauf keinen Schaden verursacht, da ein Vergleich zwischen gespeicherten und tats√§chlichen R√ºckgabeadressen erfolgt, um √úberlaufvorkommen zu erkennen. Dar√ºber hinaus kann StackShield die R√ºckgabeadresse gegen einen Grenzwert √ºberpr√ºfen, um festzustellen, ob der **EIP** au√üerhalb des erwarteten Datenspeichers zeigt. Diese Schutzma√ünahme kann jedoch durch Techniken wie Return-to-libc, ROP (Return-Oriented Programming) oder ret2ret umgangen werden, was darauf hindeutet, dass auch StackShield lokale Variablen nicht sch√ºtzt.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Dieser Mechanismus platziert einen **Canary** vor dem **EBP** und ordnet lokale Variablen um, um Puffer an h√∂heren Speicheradressen zu positionieren, um ein √úberschreiben anderer Variablen zu verhindern. Er kopiert auch sicher Argumente, die √ºber den Stapel √ºbergeben werden, √ºber lokale Variablen und verwendet diese Kopien als Argumente. Es sch√ºtzt jedoch keine Arrays mit weniger als 8 Elementen oder Puffer innerhalb einer Benutzerstruktur.

Der **Canary** ist eine Zufallszahl, abgeleitet von `/dev/urandom` oder einem Standardwert von `0xff0a0000`. Er wird im **TLS (Thread Local Storage)** gespeichert, was gemeinsame Speicherbereiche √ºber Threads hinweg erm√∂glicht, um threadspezifische globale oder statische Variablen zu haben. Diese Variablen werden urspr√ºnglich vom Elternprozess kopiert, und Kindprozesse k√∂nnen ihre Daten √§ndern, ohne den Eltern- oder Geschwisterprozess zu beeinflussen. Wenn jedoch ein **`fork()` ohne Erstellung eines neuen Canary verwendet wird, teilen alle Prozesse (Eltern und Kinder) denselben Canary**, was ihn anf√§llig macht. Auf der **i386**-Architektur wird der Canary bei `gs:0x14` und auf **x86\_64** bei `fs:0x28` gespeichert.

Dieser lokale Schutz identifiziert Funktionen mit anf√§lligen Puffern f√ºr Angriffe und f√ºgt Code am Anfang dieser Funktionen ein, um den Canary zu platzieren, und am Ende, um seine Integrit√§t zu √ºberpr√ºfen.

Wenn ein Webserver `fork()` verwendet, erm√∂glicht es einen Brute-Force-Angriff, um das Canary-Byte f√ºr Byte zu erraten. Wenn jedoch `execve()` nach `fork()` verwendet wird, √ºberschreibt es den Speicherbereich und macht den Angriff zunichte. `vfork()` erm√∂glicht es dem Kindprozess, ohne Duplikation auszuf√ºhren, bis er versucht zu schreiben, woraufhin eine Duplikation erstellt wird, was einen anderen Ansatz zur Prozesserstellung und Speicherbehandlung bietet.

### L√§ngen

In `x64`-Bin√§rdateien ist das Canary-Cookie ein **`0x8`** Byte Qword. Die **ersten sieben Bytes sind zuf√§llig** und das letzte Byte ist ein **Nullbyte**.

In `x86`-Bin√§rdateien ist das Canary-Cookie ein **`0x4`** Byte Dword. Die **ersten drei Bytes sind zuf√§llig** und das letzte Byte ist ein **Nullbyte**.

{% hint style="danger" %}
Das am wenigsten signifikante Byte beider Canaries ist ein Nullbyte, da es das erste im Stapel ist, das von niedrigeren Adressen kommt, und daher **Funktionen, die Zeichenfolgen lesen, bevor sie es lesen**, anhalten.
{% endhint %}

## Umgehungen

**Lecken des Canaries** und dann √úberschreiben (z. B. Puffer√ºberlauf) mit seinem eigenen Wert.

* Wenn der **Canary in Kindprozessen geforkt wird**, k√∂nnte es m√∂glich sein, ihn Byte f√ºr Byte **brute-force**:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Wenn es eine interessante **Leck- oder beliebige Leseanf√§lligkeit** in der Bin√§rdatei gibt, k√∂nnte es m√∂glich sein, sie zu leaken:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **√úberschreiben von auf dem Stapel gespeicherten Zeigern**

Der Stapel, der anf√§llig f√ºr einen Stapel√ºberlauf ist, k√∂nnte **Adressen zu Zeichenfolgen oder Funktionen enthalten, die √ºberschrieben werden k√∂nnen**, um die Schwachstelle auszunutzen, ohne den Stapel-Canary erreichen zu m√ºssen. √úberpr√ºfen Sie:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **√Ñndern des Master- und Thread-Canary**

Ein Puffer√ºberlauf in einer threadgesch√ºtzten Funktion, der mit Canary gesch√ºtzt ist, kann verwendet werden, um den Master-Canary des Threads zu √§ndern. Dadurch ist die Schutzma√ünahme nutzlos, da die √úberpr√ºfung mit zwei identischen Canaries erfolgt (obwohl modifiziert).

Dar√ºber hinaus k√∂nnte ein Puffer√ºberlauf in einer threadgesch√ºtzten Funktion verwendet werden, um den im TLS gespeicherten Master-Canary zu √§ndern. Dies liegt daran, dass es m√∂glicherweise m√∂glich ist, die Speicherposition zu erreichen, an der das TLS gespeichert ist (und daher den Canary), √ºber einen **bof im Stapel** eines Threads.\
Als Ergebnis ist die Schutzma√ünahme nutzlos, da die √úberpr√ºfung mit zwei identischen Canaries erfolgt (obwohl modifiziert).\
Dieser Angriff wird im Write-up durchgef√ºhrt: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

√úberpr√ºfen Sie auch die Pr√§sentation von [https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015](https://www.slideshare.net/codeblue\_jp/master-canary-forging-by-yuki-koike-code-blue-2015), die erw√§hnt, dass normalerweise das **TLS** durch **`mmap`** gespeichert wird und wenn ein **Stapel** eines **Threads** erstellt wird, wird er ebenfalls durch `mmap` generiert, was einen √úberlauf erm√∂glichen k√∂nnte, wie im vorherigen Write-up gezeigt.

* **√Ñndern des GOT-Eintrags von `__stack_chk_fail`**

Wenn die Bin√§rdatei Partial RELRO hat, k√∂nnen Sie einen beliebigen Schreibzugriff verwenden, um den **GOT-Eintrag von `__stack_chk_fail`** zu √§ndern, damit er eine Dummy-Funktion ist, die das Programm nicht blockiert, wenn der Canary ge√§ndert wird.

Dieser Angriff wird im Write-up durchgef√ºhrt: [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
## Referenzen

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Heldenniveau mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
