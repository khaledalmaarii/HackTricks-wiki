# Bins & Aloakcije memorije

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Kako bi se poboljÅ¡ala efikasnost Äuvanja delova, svaki deo nije smeÅ¡ten samo u jednoj povezanoj listi, veÄ‡ postoje razliÄite vrste. To su binovi i postoji 5 vrsta binova: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) mali binovi, 63 velika binova, 1 nesortirani bin, 10 brzih binova i 64 tcache binova po niti.

PoÄetna adresa za svaki nesortirani, mali i veliki bin je unutar istog niza. Indeks 0 nije koriÅ¡Ä‡en, 1 je nesortirani bin, binovi 2-64 su mali binovi, a binovi 65-127 su veliki binovi.

### Mali binovi

Mali binovi su brÅ¾i od velikih binova, ali sporiji od brzih binova.

Svaki bin od 62 Ä‡e imati **delove iste veliÄine**: 16, 24, ... (sa maksimalnom veliÄinom od 504 bajta u 32-bitnom i 1024 u 64-bitnom reÅ¾imu). Ovo pomaÅ¾e u brzini pronalaÅ¾enja binova gde treba alocirati prostor i ubacivanju i uklanjanju unosa sa ovih listi.

### Veliki binovi

Za razliku od malih binova, koji upravljaju delovima fiksnih veliÄina, svaki **veliki bin upravlja opsegom veliÄina delova**. Ovo je fleksibilnije, omoguÄ‡avajuÄ‡i sistemu da se prilagodi **razliÄitim veliÄinama** bez potrebe za posebnim binom za svaku veliÄinu.

U alokatoru memorije, veliki binovi poÄinju tamo gde se zavrÅ¡avaju mali binovi. Opsezi za velike binove postaju sve veÄ‡i, Å¡to znaÄi da prvi bin moÅ¾e obuhvatiti delove od 512 do 576 bajtova, dok sledeÄ‡i obuhvata 576 do 640 bajtova. Ovaj obrazac se nastavlja, pri Äemu najveÄ‡i bin sadrÅ¾i sve delove iznad 1MB.

Veliki binovi su sporiji za rad u poreÄ‘enju sa malim binovima jer moraju **sortirati i pretraÅ¾ivati listu delova razliÄitih veliÄina kako bi pronaÅ¡li najbolje odgovarajuÄ‡i** za alokaciju. Kada se deo ubaci u veliki bin, mora biti sortiran, a prilikom alokacije memorije, sistem mora pronaÄ‡i odgovarajuÄ‡i deo. Ovaj dodatni rad ih Äini **sporijim**, ali buduÄ‡i da su velike alokacije manje uobiÄajene od malih, to je prihvatljiva trgovina.

Postoje:

* 32 binova opsega 64B
* 16 binova opsega 512B
* 8 binova opsega 4096B
* 4 binova opsega 32768B
* 2 binova opsega 262144B
* 1 bin za preostale veliÄine

### Nesortirani bin

Nesortirani bin je **brza keÅ¡ memorija** koju koristi menadÅ¾er hipa kako bi ubrzao alokaciju memorije. Evo kako funkcioniÅ¡e: Kada program oslobodi memoriju, menadÅ¾er hipa je ne stavlja odmah u odreÄ‘eni bin. Umesto toga, prvo pokuÅ¡ava **da je spoji sa bilo kojim susednim slobodnim delovima** kako bi stvorio veÄ‡i blok slobodne memorije. Zatim, smeÅ¡ta ovaj novi deo u opÅ¡ti bin nazvan "nesortirani bin".

Kada program **zatraÅ¾i memoriju**, menadÅ¾er hipa **proverava nesortirani bin** da vidi da li postoji deo dovoljne veliÄine. Ako pronaÄ‘e jedan, odmah ga koristi. Ako ne pronaÄ‘e odgovarajuÄ‡i deo, premesti osloboÄ‘ene delove u njihove odgovarajuÄ‡e binove, bilo male ili velike, na osnovu njihove veliÄine.

Dakle, nesortirani bin je naÄin da se ubrza alokacija memorije brzim ponovnim koriÅ¡Ä‡enjem nedavno osloboÄ‘ene memorije i smanjenjem potrebe za vremenski zahtevnim pretragama i spajanjima.

{% hint style="danger" %}
Imajte na umu da Äak i ako su delovi razliÄitih kategorija, ako dostupan deo kolidira sa drugim dostupnim delom (Äak i ako su razliÄitih kategorija), biÄ‡e spojeni.
{% endhint %}

### Brzi binovi

Brzi binovi su dizajnirani da **ubrzaju alokaciju memorije za male delove** Äuvanjem nedavno osloboÄ‘enih delova u strukturi brzog pristupa. Ovi binovi koriste pristup poslednji unutra, prvi napolje (LIFO), Å¡to znaÄi da je **najskorije osloboÄ‘eni deo prvi** koji Ä‡e biti ponovo koriÅ¡Ä‡en kada postoji nova zahtev za alokacijom. Ovo ponaÅ¡anje je korisno za brzinu, jer je brÅ¾e ubaciti i ukloniti sa vrha steka (LIFO) u poreÄ‘enju sa redom (FIFO).

Dodatno, **brzi binovi koriste jednostruko povezane liste**, a ne dvostruko povezane, Å¡to dodatno poboljÅ¡ava brzinu. BuduÄ‡i da se delovi u brzim binovima ne spajaju sa susedima, nema potrebe za sloÅ¾enom strukturom koja omoguÄ‡ava uklanjanje iz sredine. Jednostruko povezana lista je jednostavnija i brÅ¾a za ove operacije.

U osnovi, ovde se deÅ¡ava da je zaglavlje (pokazivaÄ na prvi deo koji treba proveriti) uvek usmereno na najskorije osloboÄ‘eni deo te veliÄine. Dakle:

* Kada se alocira novi deo te veliÄine, zaglavlje pokazuje na slobodan deo za koriÅ¡Ä‡enje. PoÅ¡to ovaj slobodan deo pokazuje na sledeÄ‡i deo za koriÅ¡Ä‡enje, ova adresa je saÄuvana u zaglavlju tako da sledeÄ‡a alokacija zna gde da dobije dostupan deo
* Kada se deo oslobodi, slobodan deo Ä‡e saÄuvati adresu trenutno dostupnog dela i adresa ovog novootvorenog dela Ä‡e biti smeÅ¡tena u zaglavlje

{% hint style="danger" %}
Delovi u brzim binovima nisu automatski postavljeni kao dostupni tako da se zadrÅ¾avaju kao delovi brzih binova neko vreme umesto da mogu da se spoje sa drugim delovima.
{% endhint %}

### Tcache (Tcache po niti)

Iako niti pokuÅ¡avaju da imaju svoj sopstveni hip (videti [Arenas](bins-and-memory-allocations.md#arenas) i [Pod-hipovi](bins-and-memory-allocations.md#subheaps)), postoji moguÄ‡nost da Ä‡e proces sa puno niti (kao Å¡to je veb server) **zavrÅ¡iti deljenjem hipa sa drugim nitima**. U ovom sluÄaju, glavno reÅ¡enje je koriÅ¡Ä‡enje **brava**, koje mogu **znatno usporiti niti**.

Stoga, tcache je sliÄan brzom binu po niti na naÄin da je **jednostruko povezana lista** koja ne spaja delove. Svaka nit ima **64 jednostruko povezana tcache bina**. Svaki bin moÅ¾e imati maksimum [7 delova iste veliÄine](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) u opsegu od [24 do 1032B na 64-bitnim sistemima i od 12 do 516B na 32-bitnim sistemima](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

Kada jedna nit oslobodi deo, **ako nije prevelik** da bi bio alociran u tcache i odgovarajuÄ‡i tcache bin **nije pun** (veÄ‡ 7 delova), **biÄ‡e alociran tamo**. Ako ne moÅ¾e da ide u tcache, moraÄ‡e da saÄeka da se hip zakljuÄa kako bi mogao da izvrÅ¡i globalnu operaciju oslobaÄ‘anja.

Kada se **deo alocira**, ako postoji slobodan deo potrebne veliÄine u **Tcache-u, koristiÄ‡e ga**, ako ne, moraÄ‡e da saÄeka da se hip zakljuÄa kako bi pronaÅ¡ao jedan u globalnim binovima ili kreirao novi.\
Postoji i optimizacija, u ovom sluÄaju, dok ima hip zakljuÄan, nit **Ä‡e popuniti svoj Tcache hip delovima (7) traÅ¾ene veliÄine**, tako da ako zatreba viÅ¡e, moÄ‡i Ä‡e da ih pronaÄ‘e u Tcache-u.
## Tok dodele

{% hint style="success" %}
(Ovo trenutno objaÅ¡njenje je sa [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Proveri poslednju verziju i aÅ¾uriraj je)
{% endhint %}

Dodele se konaÄno vrÅ¡e funkcijom: `void * _int_malloc (mstate av, size_t bytes)` i slede ovaj redosled:

1. AÅ¾urira `bytes` da se pobrine za **poravnanja**, itd.
2. Proverava da li je `av` **NULL** ili nije.
3. U sluÄaju odsustva **upotrebljive arene** (kada je `av` NULL), poziva `sysmalloc` da dobije blok koristeÄ‡i mmap. Ako je uspeÅ¡no, poziva `alloc_perturb`. VraÄ‡a pokazivaÄ.
4. Zavisno od veliÄine:
* \[Dodatak originalu] Koristi tcache pre provere sledeÄ‡eg fastbin-a.
* \[Dodatak originalu] Ako nema tcache-a veÄ‡ se koristi drugi bin (vidi kasniji korak), pokuÅ¡ajte da popunite tcache iz tog bina.
* Ako veliÄina spada u opseg **fastbin-a**:
1. Dobija indeks u nizu fastbin-a da pristupi odgovarajuÄ‡em binu prema veliÄini zahteva.
2. Uklanja prvi blok iz tog bina i Äini da `victim` na njega pokazuje.
3. Ako je `victim` NULL, prelazi na sledeÄ‡i sluÄaj (smallbin).
4. Ako `victim` nije NULL, proverava veliÄinu bloka da bi se osiguralo da pripada tom odreÄ‘enom binu. InaÄe se baca greÅ¡ka ("malloc(): memory corruption (fast)").
5. Poziva `alloc_perturb` i zatim vraÄ‡a pokazivaÄ.
* Ako veliÄina spada u opseg **smallbin-a**:
1. Dobija indeks u nizu smallbin-a da pristupi odgovarajuÄ‡em binu prema veliÄini zahteva.
2. Ako nema blokova u ovom binu, prelazi na sledeÄ‡i sluÄaj. Ovo se proverava poreÄ‘enjem pokazivaÄa `bin` i `bin->bk`.
3. `victim` postaje jednak `bin->bk` (poslednji blok u binu). Ako je NULL (deÅ¡ava se tokom `inicijalizacije`), poziva `malloc_consolidate` i preskaÄe ovaj kompletan korak provere u razliÄitim binovima.
4. InaÄe, kada je `victim` ne NULL, proverava da li su `victim->bk->fd` i `victim` jednaki ili ne. Ako nisu jednaki, baca se greÅ¡ka (`malloc(): smallbin double linked list corrupted`).
5. Postavlja bit PREV\_INSUSE za sledeÄ‡i blok (u memoriji, ne u dvostrukom povezanom listu) za `victim`.
6. Uklanja ovaj blok iz liste binova.
7. Postavlja odgovarajuÄ‡i bit arene za ovaj blok u zavisnosti od `av`.
8. Poziva `alloc_perturb` i zatim vraÄ‡a pokazivaÄ.
* Ako veliÄina ne spada u opseg smallbin-a:
1. Dobija indeks u nizu largebin-a da pristupi odgovarajuÄ‡em binu prema veliÄini zahteva.
2. Vidi da li `av` ima brze blokove ili ne. Ovo se radi proverom `FASTCHUNKS_BIT` u `av->flags`. Ako da, poziva `malloc_consolidate` na `av`.
5. Ako joÅ¡ uvek nije vraÄ‡en pokazivaÄ, to oznaÄava jedan ili viÅ¡e sledeÄ‡ih sluÄajeva:
1. VeliÄina spada u opseg 'fastbin-a' ali nema dostupnih brzih blokova.
2. VeliÄina spada u opseg 'smallbin-a' ali nema dostupnih malih blokova (poziva `malloc_consolidate` tokom inicijalizacije).
3. VeliÄina spada u opseg 'largebin-a'.
6. Zatim se proveravaju **nesortirani blokovi** i pretraÅ¾eni blokovi se smeÅ¡taju u binove. Ovo je jedino mesto gde se blokovi smeÅ¡taju u binove. Iterira se nesortirani bin od 'TAIL'.
1. `victim` pokazuje na trenutni blok koji se razmatra.
2. Proverava da li je veliÄina bloka `victim` unutar minimalnog (`2*SIZE_SZ`) i maksimalnog (`av->system_mem`) opsega. InaÄe se baca greÅ¡ka (`malloc(): memory corruption`).
3. Ako (veliÄina traÅ¾enog bloka spada u opseg smallbin-a) i (`victim` je poslednji preostali blok) i (to je jedini blok u nesortiranom binu) i (veliÄina blokova >= traÅ¾ena): **Podeli blok na 2 bloka**:
* Prvi blok odgovara traÅ¾enoj veliÄini i vraÄ‡a se.
* Preostali blok postaje novi poslednji preostali blok. Ubacuje se nazad u nesortirani bin.
1. Postavlja `chunk_size` i `chunk_prev_size` polja na odgovarajuÄ‡i naÄin za oba bloka.
2. Prvi blok se vraÄ‡a nakon poziva `alloc_perturb`.
3. Ako je gornji uslov netaÄan, kontrola dolazi ovde. Uklanja `victim` iz nesortiranog bin. Ako veliÄina `victim` odgovara taÄno traÅ¾enoj veliÄini, vrati ovaj blok nakon poziva `alloc_perturb`.
4. Ako veliÄina `victim` spada u opseg smallbin-a, dodaj blok u odgovarajuÄ‡i smallbin na `HEAD`.
5. InaÄe ubaci u odgovarajuÄ‡i largebin odrÅ¾avajuÄ‡i sortiran redosled:
6. Prvo proverava poslednji blok (najmanji). Ako je `victim` manji od poslednjeg bloka, ubaci ga na poslednje mesto.
7. InaÄe, petlja da pronaÄ‘e blok sa veliÄinom >= veliÄini `victim`. Ako je veliÄina taÄno ista, uvek ubaci na drugo mesto.
8. Ponovi ovaj korak maksimalno `MAX_ITERS` (10000) puta ili dok se svi blokovi u nesortiranom binu ne iscrpe.
7. Nakon provere nesortiranih blokova, proveri da li traÅ¾ena veliÄina ne spada u opseg smallbin-a, ako da, onda proveri **largebin-ove**.
1. Dobija indeks u nizu largebin-a da pristupi odgovarajuÄ‡em binu prema veliÄini zahteva.
2. Ako je veliÄina najveÄ‡eg bloka (prvi blok u binu) veÄ‡a od traÅ¾ene veliÄine:
1. Iterira od 'TAIL' da pronaÄ‘e blok (`victim`) sa najmanjom veliÄinom >= traÅ¾ene veliÄine.
2. Poziva `unlink` da ukloni blok `victim` iz bina.
3. IzraÄunava `remainder_size` za blok `victim` (ovo Ä‡e biti veliÄina bloka `victim` - traÅ¾ena veliÄina).
4. Ako je ovaj `remainder_size` >= `MINSIZE` (minimalna veliÄina bloka ukljuÄujuÄ‡i zaglavlja), podeli blok na dva bloka. InaÄe, ceo blok `victim` Ä‡e biti vraÄ‡en. Ubaci preostali blok u nesortirani bin (na 'TAIL' kraju). VrÅ¡i se provera u nesortiranom binu da li `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. InaÄe se baca greÅ¡ka ("malloc(): corrupted unsorted chunks").
5. Vrati blok `victim` nakon poziva `alloc_perturb`.
8. Do sada smo proverili nesortirani bin i takoÄ‘e odgovarajuÄ‡i fast, small ili large bin. Napomena da je jedan bin (brzi ili mali) proveren koristeÄ‡i **taÄno** veliÄinu traÅ¾enog bloka. Ponavljajte sledeÄ‡e korake dok se svi binovi ne iscrpe:
1. Indeks u nizu binova se poveÄ‡ava da bi se proverio sledeÄ‡i bin.
2. Koristi `av->binmap` mapu da preskoÄi prazne binove.
3. `victim` pokazuje na 'TAIL' trenutnog bina.
4. KoriÅ¡Ä‡enjem binmapa osigurava se da ako je bin preskoÄen (u prethodnom 2. koraku), definitivno je prazan. MeÄ‘utim, ne garantuje da Ä‡e svi prazni binovi biti preskoÄeni. Proveri da li je `victim` prazan ili ne. Ako je prazan, ponovo preskoÄi bin i ponovi gore navedeni proces (ili 'nastavi' ovu petlju) dok ne stignemo do nepopunjenog bina.
5. Podeli blok (`victim` pokazuje na poslednji blok nepopunjenog bina) na dva bloka. Ubaci preostali blok u nesortirani bin (na 'TAIL' kraju). VrÅ¡i se provera u nesortiranom binu da li `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. InaÄe se baca greÅ¡ka ("malloc(): corrupted unsorted chunks 2").
6. Vrati blok `victim` nakon poziva `alloc_perturb`.
9. Ako joÅ¡ uvek nije pronaÄ‘en prazan bin, 'top' blok Ä‡e se koristiti za obradu zahteva:
1. `victim` pokazuje na `av->top`.
2. Ako je veliÄina 'top' bloka >= 'traÅ¾ena veliÄina' + `MINSIZE`, podeli ga na dva bloka. U ovom sluÄaju, preostali blok postaje novi 'top' blok i drugi blok se vraÄ‡a korisniku nakon poziva `alloc_perturb`.
3. Vidi da li `av` ima brze blokove ili ne. Ovo se radi proverom `FASTCHUNKS_BIT` u `av->flags`. Ako da, poziva `malloc_consolidate` na `av`. Vrati se na korak 6 (gde proveravamo nesortirani bin).
4. Ako `av` nema brze blokove, poziva `sysmalloc` i vraÄ‡a dobijeni pokazivaÄ nakon poziva `alloc_perturb`.
## Slobodan protok

{% hint style="success" %}
(Ovo trenutno objaÅ¡njenje je sa [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Proverite poslednju verziju i aÅ¾urirajte je)
{% endhint %}

KonaÄna funkcija oslobaÄ‘anja delova memorije je `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Proverava da li je `p` pre `p + chunksize(p)` u memoriji (kako bi se izbeglo prelamanje). U suprotnom se baca greÅ¡ka (`free(): invalid pointer`).
2. Proverava da li je veliÄina bloka barem `MINSIZE` ili viÅ¡ekratnik `MALLOC_ALIGNMENT`. U suprotnom se baca greÅ¡ka (`free(): invalid size`).
3. Ako veliÄina bloka spada u listu fastbin:
1. Proverava da li je veliÄina sledeÄ‡eg bloka izmeÄ‘u minimalne i maksimalne veliÄine (`av->system_mem`), inaÄe se baca greÅ¡ka (`free(): invalid next size (fast)`).
2. Poziva `free_perturb` na bloku.
3. Postavlja `FASTCHUNKS_BIT` za `av`.
4. Dobija indeks u nizu fastbin prema veliÄini bloka.
5. Proverava da li vrh bin-a nije blok koji dodajemo. U suprotnom, baca se greÅ¡ka (`double free or corruption (fasttop)`).
6. Proverava da li je veliÄina bloka u fastbin-u na vrhu ista kao veliÄina bloka koji dodajemo. U suprotnom, baca se greÅ¡ka (`invalid fastbin entry (free)`).
7. Ubacuje blok na vrh liste fastbin-a i vraÄ‡a.
4. Ako blok nije mapiran:
1. Proverava da li je blok vrhunski blok ili ne. Ako jeste, baca se greÅ¡ka (`double free or corruption (top)`).
2. Proverava da li je sledeÄ‡i blok (po memoriji) unutar granica arene. Ako nije, baca se greÅ¡ka (`double free or corruption (out)`).
3. Proverava da li je prethodni bit sledeÄ‡eg bloka (po memoriji) oznaÄen kao u upotrebi ili ne. Ako nije, baca se greÅ¡ka (`double free or corruption (!prev)`).
4. Proverava da li je veliÄina sledeÄ‡eg bloka izmeÄ‘u minimalne i maksimalne veliÄine (`av->system_mem`). Ako nije, baca se greÅ¡ka (`free(): invalid next size (normal)`).
5. Poziva `free_perturb` na bloku.
6. Ako prethodni blok (po memoriji) nije u upotrebi, poziva `unlink` na prethodnom bloku.
7. Ako sledeÄ‡i blok (po memoriji) nije vrhunski blok:
1. Ako sledeÄ‡i blok nije u upotrebi, poziva `unlink` na sledeÄ‡em bloku.
2. Spaja blok sa prethodnim, sledeÄ‡im (po memoriji), ako je bilo slobodno i dodaje ga na poÄetak nesortiranog bin-a. Pre ubacivanja, proverava da li `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ili ne. Ako nije, baca se greÅ¡ka ("free(): corrupted unsorted chunks").
8. Ako je sledeÄ‡i blok (po memoriji) bio vrhunski blok, spaja blokove na odgovarajuÄ‡i naÄin u jedan vrhunski blok.
5. Ako je blok bio mapiran, poziva `munmap_chunk`.

## Provere bezbednosti funkcija heap-a

Proverite provere bezbednosti koje vrÅ¡e Äesto koriÅ¡Ä‡ene funkcije u heap-u u:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Reference

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
