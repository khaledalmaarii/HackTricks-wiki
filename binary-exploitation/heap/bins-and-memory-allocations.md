# Bins & Bellek Tahsisi

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin**.
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'lar gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## Temel Bilgiler

ParÃ§alarÄ±n nasÄ±l depolandÄ±ÄŸÄ±ndaki verimliliÄŸi artÄ±rmak iÃ§in her parÃ§a sadece bir baÄŸlÄ± liste iÃ§inde deÄŸil, farklÄ± tÃ¼rlerde bulunur. Bunlar "bins" olarak adlandÄ±rÄ±lÄ±r ve 5 tÃ¼r bin vardÄ±r: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) kÃ¼Ã§Ã¼k bins, 63 bÃ¼yÃ¼k bins, 1 sÄ±ralanmamÄ±ÅŸ bin, 10 hÄ±zlÄ± bins ve her iÅŸ parÃ§acÄ±ÄŸÄ± iÃ§in 64 tcache bin'i.

SÄ±ralanmamÄ±ÅŸ, kÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k bins iÃ§in her birinin baÅŸlangÄ±Ã§ adresi aynÄ± dizinin iÃ§indedir. Ä°ndeks 0 kullanÄ±lmaz, 1 sÄ±ralanmamÄ±ÅŸ bin, 2-64 arasÄ± kÃ¼Ã§Ã¼k bins ve 65-127 arasÄ± bÃ¼yÃ¼k bins olarak belirlenmiÅŸtir.

### KÃ¼Ã§Ã¼k Bins

KÃ¼Ã§Ã¼k bins, bÃ¼yÃ¼k binsden daha hÄ±zlÄ± ancak hÄ±zlÄ± binsden daha yavaÅŸtÄ±r.

62'nin her bir bininde **aynÄ± boyutta parÃ§alar** bulunur: 16, 24, ... (32 bitlerde maksimum 504 bayt, 64 bitlerde 1024 bayta kadar). Bu, bir alana yer tahsis edilecek binin bulunmasÄ±, giriÅŸlerin eklenmesi ve Ã§Ä±karÄ±lmasÄ± hÄ±zÄ±nÄ± artÄ±rÄ±r.

### BÃ¼yÃ¼k Bins

KÃ¼Ã§Ã¼k binslerin aksine, her **bÃ¼yÃ¼k bin bir parÃ§a boyutu aralÄ±ÄŸÄ±nÄ± yÃ¶netir**. Bu, sistemin **farklÄ± boyutlarÄ±** ayrÄ± birer bin olmadan barÄ±ndÄ±rabilmesini saÄŸlar.

Bir bellek tahsisÃ§Ä±sÄ±nda, bÃ¼yÃ¼k binsler kÃ¼Ã§Ã¼k binslerin bittiÄŸi yerden baÅŸlar. BÃ¼yÃ¼k binsler iÃ§in aralÄ±klar giderek daha bÃ¼yÃ¼k hale gelir, yani ilk bin 512 ila 576 bayt arasÄ±ndaki parÃ§alarÄ± kapsarken, bir sonraki 576 ila 640 baytÄ± kapsar. Bu desen devam eder ve en bÃ¼yÃ¼k bin tÃ¼m 1MB Ã¼zerindeki parÃ§alarÄ± iÃ§erir.

BÃ¼yÃ¼k binsler, bir tahsis iÃ§in en iyi uyumu bulmak iÃ§in **farklÄ± parÃ§a boyutlarÄ±nÄ±n listesini sÄ±ralamak ve aramak zorunda olduklarÄ±ndan kÃ¼Ã§Ã¼k binslere gÃ¶re daha yavaÅŸ Ã§alÄ±ÅŸÄ±r**. Bir parÃ§a bÃ¼yÃ¼k bine eklenirken sÄ±ralanmalÄ± ve bellek tahsis edilirken sistem doÄŸru parÃ§ayÄ± bulmalÄ±dÄ±r. Bu ek iÅŸ, onlarÄ± **daha yavaÅŸ** yapar, ancak bÃ¼yÃ¼k tahsisler kÃ¼Ã§Ã¼k olanlardan daha az yaygÄ±n olduÄŸundan, kabul edilebilir bir takas yapÄ±lÄ±r.

Åunlar vardÄ±r:

* 64B aralÄ±ÄŸÄ±ndaki 32 bin
* 512B aralÄ±ÄŸÄ±ndaki 16 bin
* 4096B aralÄ±ÄŸÄ±ndaki 8 bin
* 32768B aralÄ±ÄŸÄ±ndaki 4 bin
* 262144B aralÄ±ÄŸÄ±ndaki 2 bin
* Geri kalan boyutlar iÃ§in 1 bin

### SÄ±ralanmamÄ±ÅŸ Bin

SÄ±ralanmamÄ±ÅŸ bin, bellek tahsisini hÄ±zlandÄ±rmak iÃ§in kullanÄ±lan bir **hÄ±zlÄ± Ã¶nbellektir**. Ä°ÅŸte nasÄ±l Ã§alÄ±ÅŸÄ±r: Bir program belleÄŸi serbest bÄ±raktÄ±ÄŸÄ±nda, bellek yÃ¶neticisi hemen onu belirli bir bine koymaz. Bunun yerine, Ã¶ncelikle yan yana gelen serbest parÃ§alarÄ± birleÅŸtirerek daha bÃ¼yÃ¼k bir serbest bellek bloÄŸu oluÅŸturmaya Ã§alÄ±ÅŸÄ±r. Daha sonra, bu yeni parÃ§ayÄ± "sÄ±ralanmamÄ±ÅŸ bin" adÄ± verilen genel bir bine yerleÅŸtirir.

Bir program **bellek istediÄŸinde**, bellek yÃ¶neticisi **sÄ±ralanmamÄ±ÅŸ bin'i kontrol eder** ve yeterli boyutta bir parÃ§a bulunup bulunmadÄ±ÄŸÄ±nÄ± kontrol eder. Bir uygun parÃ§a bulursa, hemen kullanÄ±r. Uygun bir parÃ§a bulamazsa, serbest bÄ±rakÄ±lan parÃ§alarÄ± boyutlarÄ±na baÄŸlÄ± olarak kÃ¼Ã§Ã¼k veya bÃ¼yÃ¼k bine taÅŸÄ±r.

Bu nedenle, sÄ±ralanmamÄ±ÅŸ bin, bellek tahsisini hÄ±zlandÄ±rmak iÃ§in son zamanlarda serbest bÄ±rakÄ±lan belleÄŸi hÄ±zlÄ± bir ÅŸekilde yeniden kullanarak ve zaman alÄ±cÄ± aramalarÄ± ve birleÅŸtirmeleri azaltarak hafÄ±zayÄ± hÄ±zlandÄ±rÄ±r.

{% hint style="danger" %}
FarklÄ± kategorilerdeki parÃ§alar bile olsa, mevcut bir parÃ§a baÅŸka bir mevcut parÃ§ayla Ã§akÄ±ÅŸÄ±yorsa (farklÄ± kategorilerde olsalar bile), birleÅŸtirileceklerdir.
{% endhint %}

### HÄ±zlÄ± Bins

HÄ±zlÄ± binsler, kÃ¼Ã§Ã¼k parÃ§alar iÃ§in bellek tahsisini hÄ±zlandÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r ve son zamanlarda serbest bÄ±rakÄ±lan parÃ§alarÄ± hÄ±zlÄ± eriÅŸim yapÄ±sÄ±nda tutarak Ã§alÄ±ÅŸÄ±r. Bu binsler, Son Giren Ä°lk Ã‡Ä±kar (LIFO) yaklaÅŸÄ±mÄ±nÄ± kullanÄ±r, yani **en son serbest bÄ±rakÄ±lan parÃ§a**, yeni bir tahsis isteÄŸi olduÄŸunda ilk olarak yeniden kullanÄ±lÄ±r. Bu davranÄ±ÅŸ, hÄ±z iÃ§in avantajlÄ±dÄ±r, Ã§Ã¼nkÃ¼ bir yÄ±ÄŸÄ±nÄ±n Ã¼stÃ¼nden (LIFO) ekleme ve Ã§Ä±karma iÅŸlemleri bir kuyruktan (FIFO) daha hÄ±zlÄ±dÄ±r.

AyrÄ±ca, **hÄ±zlÄ± binsler tek yÃ¶nlÃ¼ baÄŸlÄ± listeleri** kullanÄ±r, Ã§ift yÃ¶nlÃ¼ baÄŸlÄ± listelerden deÄŸil, bu da hÄ±zÄ± artÄ±rÄ±r. HÄ±zlÄ± binslerdeki parÃ§alar komÅŸularla birleÅŸtirilmediÄŸinden, ortadan kaldÄ±rma iÅŸlemleri iÃ§in karmaÅŸÄ±k bir yapÄ±ya gerek yoktur. Tek yÃ¶nlÃ¼ baÄŸlÄ± liste, bu iÅŸlemler iÃ§in daha basit ve daha hÄ±zlÄ±dÄ±r.

Temelde burada olan ÅŸey, baÅŸlÄ±k (kontrol edilecek ilk parÃ§a iÃ§in iÅŸaretÃ§i) her zaman o boyuttaki en son serbest bÄ±rakÄ±lan parÃ§aya iÅŸaret eder. DolayÄ±sÄ±yla:

* Bu boyutta yeni bir parÃ§a tahsis edildiÄŸinde, baÅŸlÄ±k kullanÄ±lacak bir boÅŸ parÃ§aya iÅŸaret eder. Bu boÅŸ parÃ§a bir sonraki kullanÄ±lacak parÃ§aya iÅŸaret ettiÄŸinden, bu adres baÅŸlÄ±kta saklanÄ±r, bÃ¶ylece bir sonraki tahsis nereden alacaÄŸÄ±nÄ± bilir
* Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, boÅŸ parÃ§a mevcut kullanÄ±labilir parÃ§anÄ±n adresini kaydeder ve bu yeni serbest bÄ±rakÄ±lan parÃ§anÄ±n adresi baÅŸlÄ±ÄŸa konur

{% hint style="danger" %}
HÄ±zlÄ± binslerdeki parÃ§alar otomatik olarak kullanÄ±labilir olarak ayarlanmaz, bu nedenle diÄŸer parÃ§alarla birleÅŸebilme yeteneÄŸine sahip olmazlar ve bir sÃ¼re hÄ±zlÄ± bin parÃ§alarÄ± olarak kalÄ±rlar.
{% endhint %}

### Tcache (Ä°ÅŸ ParÃ§acÄ±ÄŸÄ±na Ã–zel Ã–nbellek) Bins

Ä°ÅŸ parÃ§acÄ±klarÄ± kendi belleklerine sahip olmaya Ã§alÄ±ÅŸsa da (bkz. [Arenalar](bins-and-memory-allocations.md#arenas) ve [Alt Bellekler](bins-and-memory-allocations.md#subheaps)), birÃ§ok iÅŸ parÃ§acÄ±ÄŸÄ±na sahip bir sÃ¼recin (Ã¶rneÄŸin bir web sunucusu) **baÅŸka iÅŸ parÃ§acÄ±klarÄ±yla belleÄŸi paylaÅŸmasÄ± olasÄ±lÄ±ÄŸÄ±** vardÄ±r. Bu durumda, ana Ã§Ã¶zÃ¼m **kilitlerin** kullanÄ±lmasÄ±dÄ±r, bu da **iÅŸ parÃ§acÄ±klarÄ±nÄ± Ã¶nemli Ã¶lÃ§Ã¼de yavaÅŸlatabilir**.

Bu nedenle, bir tcache, her iÅŸ parÃ§acÄ±ÄŸÄ± iÃ§in bir hÄ±zlÄ± bin gibi **tek yÃ¶nlÃ¼ baÄŸlÄ± liste** olan bir yapÄ±dÄ±r ve parÃ§alarÄ± birleÅŸtirmez. Her iÅŸ parÃ§acÄ±ÄŸÄ± **64 tek yÃ¶nlÃ¼ tcache bin'ine** sahiptir. Her bir bin, [64 bit sistemlerde 24 ila 1032B ve 32 bit sistemlerde 12 ila 516B arasÄ±nda](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315) olan [7 aynÄ± boyutta parÃ§a](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) iÃ§erebilir.

Bir iÅŸ parÃ§acÄ±ÄŸÄ± bir parÃ§ayÄ± serbest bÄ±raktÄ±ÄŸÄ±nda, **eÄŸer Ã§ok bÃ¼yÃ¼k deÄŸilse** ve ilgili tcache bin **dolu deÄŸilse** (zaten 7 parÃ§a), **oraya tahsis edilir**. Tcache'e gidemiyorsa, genel bine serbest bÄ±rakma iÅŸlemini yapabilmek iÃ§in bellek kilidini beklemek zorunda kalÄ±r.

Bir **parÃ§a tahsis edildiÄŸinde**, eÄŸer **Tcache'te ihtiyaÃ§ duyulan boyutta bir boÅŸ parÃ§a varsa kullanÄ±lÄ±r**, yoksa genel bine bir tane bulmak veya yeni bir tane oluÅŸturmak iÃ§in bellek kilidini beklemek zorunda kalÄ±r.\
Bu durumda bir optimizasyon da vardÄ±r, bellek kilidini alÄ±rken, iÅŸ parÃ§acÄ±ÄŸÄ± **istenen boyutta Tcache'ine heap parÃ§alarÄ± (7) doldurur**, bÃ¶ylece daha fazla ihtiyaÃ§ duyarsa Tcache'te bulabilir.
## Tahsis AkÄ±ÅŸÄ±

{% hint style="success" %}
(Bu mevcut aÃ§Ä±klama [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions) adresinden alÄ±nmÄ±ÅŸtÄ±r. TODO: Son sÃ¼rÃ¼mÃ¼ kontrol edin ve gÃ¼ncelleyin)
{% endhint %}

Tahsisler sonunda ÅŸu iÅŸlevle gerÃ§ekleÅŸtirilir: `void * _int_malloc (mstate av, size_t bytes)` ve ÅŸu sÄ±raya sahiptir:

1. **HizalamalarÄ±** vb. dikkate almak iÃ§in `bytes` gÃ¼ncellenir.
2. `av`'nin **NULL** olup olmadÄ±ÄŸÄ± kontrol edilir.
3. **KullanÄ±labilir alan** eksikliÄŸi durumunda (av NULL olduÄŸunda), mmap kullanarak parÃ§a almak iÃ§in `sysmalloc` Ã§aÄŸrÄ±lÄ±r. BaÅŸarÄ±lÄ± olursa, `alloc_perturb` Ã§aÄŸrÄ±lÄ±r. Ä°ÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼lÃ¼r.
4. Boyuta baÄŸlÄ± olarak:
* \[Orijinal ek] Bir sonraki fastbin'i kontrol etmeden Ã¶nce tcache kullanÄ±lÄ±r.
* \[Orijinal ek] Tcache yoksa ancak farklÄ± bir bin kullanÄ±lÄ±yorsa (daha sonraki adÄ±mlarda gÃ¶rÃ¼lecek), tcache'i o bini doldurmaya Ã§alÄ±ÅŸÄ±r.
* Boyut **fastbin** aralÄ±ÄŸÄ±na dÃ¼ÅŸerse:&#x20;
1. Uygun bir bin eriÅŸmek iÃ§in fastbin dizisine endeks alÄ±nÄ±r.
2. Bu bindeki ilk parÃ§ayÄ± Ã§Ä±karÄ±r ve `victim`'Ä± ona iÅŸaret eder.
3. EÄŸer `victim` NULL ise, bir sonraki duruma geÃ§ilir (smallbin).
4. EÄŸer `victim` NULL deÄŸilse, parÃ§anÄ±n boyutunu kontrol etmek iÃ§in onun o belirli bine ait olduÄŸundan emin olmak iÃ§in kontrol edilir. Aksi takdirde bir hata ("malloc(): bellek bozulmasÄ± (hÄ±zlÄ±)") fÄ±rlatÄ±lÄ±r.
5. `alloc_perturb` Ã§aÄŸrÄ±lÄ±r ve ardÄ±ndan iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼lÃ¼r.
* Boyut **smallbin** aralÄ±ÄŸÄ±na dÃ¼ÅŸerse:
1. Uygun bir bin eriÅŸmek iÃ§in smallbin dizisine endeks alÄ±nÄ±r.
2. Bu binde parÃ§a yoksa, bir sonraki duruma geÃ§ilir. Bu, `bin` ve `bin->bk` iÅŸaretÃ§ilerini karÅŸÄ±laÅŸtÄ±rarak kontrol edilir.
3. `victim`, `bin->bk`'ye (bindeki son parÃ§a) eÅŸitlenir. EÄŸer NULL ise (baÅŸlangÄ±Ã§ta gerÃ§ekleÅŸir), `malloc_consolidate` Ã§aÄŸrÄ±lÄ±r ve farklÄ± binalara bakma adÄ±mÄ± tamamen atlanÄ±r.
4. Aksi takdirde, `victim` NULL deÄŸilse, `victim->bk->fd` ve `victim`'Ä±n eÅŸit olup olmadÄ±ÄŸÄ± kontrol edilir. EÄŸer eÅŸit deÄŸillerse, bir hata (`malloc(): smallbin Ã§ift baÄŸlÄ± liste bozulmuÅŸ`) fÄ±rlatÄ±lÄ±r.
5. `victim` iÃ§in bir sonraki parÃ§a iÃ§in (bellekte, Ã§ift baÄŸlÄ± listede deÄŸil) PREV_INSUSE biti ayarlanÄ±r.
6. Bu parÃ§a bin listesinden Ã§Ä±karÄ±lÄ±r.
7. Bu parÃ§aya uygun arena biti `av`'ye baÄŸlÄ± olarak ayarlanÄ±r.
8. `alloc_perturb` Ã§aÄŸrÄ±lÄ±r ve ardÄ±ndan iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼lÃ¼r.
* Boyut **smallbin** aralÄ±ÄŸÄ±na dÃ¼ÅŸmezse:
1. Uygun bir bin eriÅŸmek iÃ§in largebin dizisine endeks alÄ±nÄ±r.
2. `av`'nin fastchunks'a sahip olup olmadÄ±ÄŸÄ± kontrol edilir. Bu, `av->flags` iÃ§indeki `FASTCHUNKS_BIT`'i kontrol ederek yapÄ±lÄ±r. Ã–yleyse, `av` Ã¼zerinde `malloc_consolidate` Ã§aÄŸrÄ±lÄ±r.
5. HenÃ¼z bir iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼lmemiÅŸse, bu bir veya daha fazla aÅŸaÄŸÄ±daki durumdan birini gÃ¶sterir:
1. Boyut 'fastbin' aralÄ±ÄŸÄ±na dÃ¼ÅŸer ancak hÄ±zlÄ± parÃ§a mevcut deÄŸildir.
2. Boyut 'smallbin' aralÄ±ÄŸÄ±na dÃ¼ÅŸer ancak kÃ¼Ã§Ã¼k parÃ§a mevcut deÄŸildir (baÅŸlangÄ±Ã§ta `malloc_consolidate` Ã§aÄŸrÄ±lÄ±r).
3. Boyut 'largebin' aralÄ±ÄŸÄ±na dÃ¼ÅŸer.
6. Sonra, **sÄ±rasÄ±z parÃ§alar** kontrol edilir ve gezilen parÃ§alar binalara yerleÅŸtirilir. ParÃ§alarÄ±n binalara yerleÅŸtirildiÄŸi tek yer burasÄ±dÄ±r. SÄ±rasÄ±z bin 'TAIL'den iterasyon yapÄ±lÄ±r.
1. `victim`, Ã¼zerinde durulan mevcut parÃ§ayÄ± iÅŸaret eder.
2. `victim`'Ä±n parÃ§a boyutunun minimum (`2*SIZE_SZ`) ve maksimum (`av->system_mem`) aralÄ±ÄŸÄ±nda olup olmadÄ±ÄŸÄ± kontrol edilir. Aksi takdirde bir hata (`malloc(): bellek bozulmasÄ±`) fÄ±rlatÄ±lÄ±r.
3. EÄŸer (istenen parÃ§a boyutu smallbin aralÄ±ÄŸÄ±na dÃ¼ÅŸerse) ve (`victim` son kalan parÃ§a ise) ve (sÄ±rasÄ±z binde tek parÃ§a varsa) ve (parÃ§anÄ±n boyutu istenen boyuttan bÃ¼yÃ¼kse): **ParÃ§ayÄ± 2 parÃ§aya ayÄ±r**:
* Ä°lk parÃ§a istenen boyuta uyar ve dÃ¶ndÃ¼rÃ¼lÃ¼r.
* Geriye kalan parÃ§a yeni son kalan parÃ§a olur. Bu sÄ±rasÄ±z bine geri eklenir.
1. Her iki parÃ§a iÃ§in de `chunk_size` ve `chunk_prev_size` alanlarÄ± uygun ÅŸekilde ayarlanÄ±r.
2. Ä°lk parÃ§a, `alloc_perturb` Ã§aÄŸrÄ±ldÄ±ktan sonra dÃ¶ndÃ¼rÃ¼lÃ¼r.
3. YukarÄ±daki koÅŸul yanlÄ±ÅŸsa, kontrol buraya ulaÅŸÄ±r. `victim` sÄ±rasÄ±z binde Ã§Ä±karÄ±lÄ±r. `victim`'Ä±n boyutu tam olarak istenen boyuta uyuÅŸuyorsa, bu parÃ§a `alloc_perturb` Ã§aÄŸrÄ±ldÄ±ktan sonra dÃ¶ndÃ¼rÃ¼lÃ¼r.
4. EÄŸer `victim`'Ä±n boyutu smallbin aralÄ±ÄŸÄ±na dÃ¼ÅŸerse, parÃ§a uygun smallbin'e `HEAD`'e eklenir.
5. Aksi takdirde, uygun sÄ±ralÄ± dÃ¼zende bÃ¼yÃ¼k bin iÃ§ine eklenir:
6. En kÃ¼Ã§Ã¼k son parÃ§ayÄ± (en kÃ¼Ã§Ã¼k) kontrol eder. EÄŸer `victim` en kÃ¼Ã§Ã¼k parÃ§adan kÃ¼Ã§Ã¼kse, en sona eklenir.
7. Aksi takdirde, `victim`'Ä±n boyutundan bÃ¼yÃ¼k veya eÅŸit bir parÃ§a bulmak iÃ§in dÃ¶ngÃ¼ yapÄ±lÄ±r. Boyut tam olarak aynÄ±ysa, her zaman ikinci pozisyona eklenir.
8. Bu adÄ±m maksimum `MAX_ITERS` (10000) kez veya sÄ±rasÄ±z bindeki tÃ¼m parÃ§alar tÃ¼kenene kadar tekrarlanÄ±r.
7. SÄ±rasÄ±z parÃ§alar kontrol edildikten sonra, istenen boyutun smallbin aralÄ±ÄŸÄ±na dÃ¼ÅŸmediÄŸi kontrol edilir, Ã¶yleyse **largebin'leri** kontrol edilir.
1. Uygun bir bin eriÅŸmek iÃ§in largebin dizisine endeks alÄ±nÄ±r.
2. En bÃ¼yÃ¼k parÃ§anÄ±n boyutu (bindeki ilk parÃ§a) istenen boyuttan bÃ¼yÃ¼kse:
1. Bir parÃ§a (`victim`) bulmak iÃ§in 'TAIL'den iterasyon yapÄ±lÄ±r, istenen boyuttan bÃ¼yÃ¼k veya eÅŸit en kÃ¼Ã§Ã¼k boyuta sahip.
2. `victim` parÃ§asÄ±nÄ± bindeki Ã§Ä±karmak iÃ§in `unlink` Ã§aÄŸrÄ±lÄ±r.
3. `victim`'Ä±n parÃ§asÄ± iÃ§in `remainder_size` hesaplanÄ±r (bu, `victim`'Ä±n parÃ§a boyutu - istenen boyut olacaktÄ±r).
4. EÄŸer bu `remainder_size` >= `MINSIZE` (baÅŸlÄ±k dahil minimum parÃ§a boyutu), parÃ§ayÄ± iki parÃ§aya bÃ¶ler. Aksi takdirde, tÃ¼m `victim` parÃ§asÄ± dÃ¶ndÃ¼rÃ¼lÃ¼r. Geriye kalan parÃ§a sÄ±rasÄ±z bine eklenir ('TAIL' sonunda). SÄ±rasÄ±z binde `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` kontrol edilir. Aksi takÄ±rdi hata fÄ±rlatÄ±lÄ±r ("malloc(): bozuk sÄ±rasÄ±z parÃ§alar").
5. `victim` parÃ§a, `alloc_perturb` Ã§aÄŸrÄ±ldÄ±ktan sonra dÃ¶ndÃ¼rÃ¼lÃ¼r.
8. Åimdiye kadar, sÄ±rasÄ±z bin ve ilgili fast, small veya large bin kontrol edildi. UnutmayÄ±n ki tek bir bin (hÄ±zlÄ± veya kÃ¼Ã§Ã¼k) istenen parÃ§a boyutunun **tam olarak** kontrol edildiÄŸi yerdir. TÃ¼m binalar tÃ¼kenene kadar aÅŸaÄŸÄ±daki adÄ±mlarÄ± tekrarlayÄ±n:
1. Bin dizisine eriÅŸim endeksi artÄ±rÄ±lÄ±r.
2. BoÅŸ olan binalarÄ± atlamak iÃ§in `av->binmap` haritasÄ± kullanÄ±lÄ±r.
3. `victim` mevcut binin 'TAIL'ine iÅŸaret eder.
4. Bin haritasÄ±, bir binin atlandÄ±ÄŸÄ±nÄ± (yukarÄ±daki 2. adÄ±mda) kesinlikle boÅŸ olduÄŸunu saÄŸlar. Ancak, tÃ¼m boÅŸ binalarÄ±n atlanacaÄŸÄ±nÄ± garanti etmez. `victim`'Ä±n boÅŸ olup olmadÄ±ÄŸÄ± kontrol edilir. EÄŸer boÅŸsa, tekrar bin atlanÄ±r ve yukarÄ±daki iÅŸlem tekrarlanÄ±r (veya bu dÃ¶ngÃ¼ 'devam' eder) boÅŸ olmayan bir bine ulaÅŸÄ±lana kadar.
5. ParÃ§a ikiye bÃ¶lÃ¼nÃ¼r (`victim`, dolu olmayan bir binin son parÃ§asÄ±nÄ± iÅŸaret eder). Geriye kalan parÃ§a sÄ±rasÄ±z bine eklenir ('TAIL' sonunda). SÄ±rasÄ±z binde `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` kontrol edilir. Aksi takdirde hata fÄ±rlatÄ±lÄ±r ("malloc(): bozuk sÄ±rasÄ±z parÃ§alar 2").
6. `victim` parÃ§a, `alloc_perturb` Ã§aÄŸrÄ±ldÄ±ktan sonra dÃ¶ndÃ¼rÃ¼lÃ¼r.
9. Hala boÅŸ bir bin bulunamazsa, 'top' parÃ§asÄ± isteÄŸi karÅŸÄ±lamak iÃ§in kullanÄ±lacaktÄ±r:
1. `victim`, `av->top`'a iÅŸaret eder.
2. 'top' parÃ§asÄ±nÄ±n boyutu >= 'istenilen boyut' + `MINSIZE` ise, ikiye bÃ¶lÃ¼nÃ¼r. Bu durumda, geriye kalan parÃ§a yeni 'top' parÃ§a olur ve diÄŸer parÃ§a `alloc_perturb` Ã§aÄŸrÄ±ldÄ±ktan sonra kullanÄ±cÄ±ya dÃ¶ndÃ¼rÃ¼lÃ¼r.
3. `av`'nin fastchunks'a sahip olup olmadÄ±ÄŸÄ± kontrol edilir. Bu, `av->flags` iÃ§indeki `FASTCHUNKS_BIT`'i kontrol ederek yapÄ±lÄ±r. Ã–yleyse, `av` Ã¼zerinde `malloc_consolidate` Ã§aÄŸrÄ±lÄ±r. 6. adÄ±ma geri dÃ¶nÃ¼lÃ¼r (sÄ±rasÄ±z bin kontrol edildiÄŸi yer).
4. EÄŸer `av`'nin fastchunks'u yoksa, `sysmalloc` Ã§aÄŸrÄ±lÄ±r ve `alloc_perturb` Ã§aÄŸrÄ±ldÄ±ktan sonra elde edilen iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼lÃ¼r.
## Serbest AkÄ±ÅŸ

{% hint style="success" %}
(Bu mevcut aÃ§Ä±klama [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions) adresinden alÄ±nmÄ±ÅŸtÄ±r. TODO: Son sÃ¼rÃ¼mÃ¼ kontrol edin ve gÃ¼ncelleyin)
{% endhint %}

HafÄ±za parÃ§alarÄ±nÄ± serbest bÄ±rakan son iÅŸlev `_int_free (mstate av, mchunkptr p, int have_lock)` ÅŸÃ¶yledir:

1. `p`, bellekte `p + chunksize(p)`'den Ã¶nce mi diye kontrol edilir (sarÄ±lma olmamasÄ± iÃ§in). Aksi takdirde bir hata (`free(): invalid pointer`) oluÅŸturulur.
2. ParÃ§anÄ±n en az `MINSIZE` boyutunda veya `MALLOC_ALIGNMENT`'Ä±n katÄ± olup olmadÄ±ÄŸÄ± kontrol edilir. Aksi takdirde bir hata (`free(): invalid size`) oluÅŸturulur.
3. EÄŸer parÃ§anÄ±n boyutu fastbin listesine dÃ¼ÅŸerse:
1. Sonraki parÃ§anÄ±n boyutunun minimum ve maksimum boyut (`av->system_mem`) arasÄ±nda olup olmadÄ±ÄŸÄ± kontrol edilir, aksi takdirde bir hata (`free(): invalid next size (fast)`) oluÅŸturulur.
2. ParÃ§ada `free_perturb` Ã§aÄŸrÄ±lÄ±r.
3. `av` iÃ§in `FASTCHUNKS_BIT` ayarlanÄ±r.
4. ParÃ§anÄ±n boyutuna gÃ¶re fastbin dizisine endeks alÄ±nÄ±r.
5. KovanÄ±n en Ã¼stÃ¼nde ekleyeceÄŸimiz parÃ§anÄ±n parÃ§a olmadÄ±ÄŸÄ± kontrol edilir. Aksi takdirde bir hata (`double free or corruption (fasttop)`) oluÅŸturulur.
6. KovanÄ±n en Ã¼stÃ¼ndeki fastbin parÃ§anÄ±n boyutunun ekleyeceÄŸimiz parÃ§a ile aynÄ± olup olmadÄ±ÄŸÄ± kontrol edilir. Aksi takdirde bir hata (`invalid fastbin entry (free)`) oluÅŸturulur.
7. ParÃ§ayÄ± fastbin listesinin en Ã¼stÃ¼ne ekleyin ve dÃ¶nÃ¼n.
4. EÄŸer parÃ§a mmapped deÄŸilse:
1. ParÃ§anÄ±n en Ã¼st parÃ§a olup olmadÄ±ÄŸÄ± kontrol edilir. EÄŸer Ã¶yleyse, bir hata (`double free or corruption (top)`) oluÅŸturulur.
2. Sonraki parÃ§anÄ±n (bellek tarafÄ±ndan) arenanÄ±n sÄ±nÄ±rlarÄ± iÃ§inde olup olmadÄ±ÄŸÄ± kontrol edilir. DeÄŸilse, bir hata (`double free or corruption (out)`) oluÅŸturulur.
3. Sonraki parÃ§anÄ±n (bellek tarafÄ±ndan) Ã¶nceki kullanÄ±mda iÅŸaretlenmiÅŸ olup olmadÄ±ÄŸÄ± kontrol edilir. DeÄŸilse, bir hata (`double free or corruption (!prev)`) oluÅŸturulur.
4. Sonraki parÃ§anÄ±n boyutunun minimum ve maksimum boyut (`av->system_mem`) arasÄ±nda olup olmadÄ±ÄŸÄ± kontrol edilir. DeÄŸilse, bir hata (`free(): invalid next size (normal)`) oluÅŸturulur.
5. ParÃ§ada `free_perturb` Ã§aÄŸrÄ±lÄ±r.
6. Ã–nceki parÃ§a (bellek tarafÄ±ndan) kullanÄ±mda deÄŸilse, Ã¶nceki parÃ§ada `unlink` Ã§aÄŸrÄ±lÄ±r.
7. Sonraki parÃ§a (bellek tarafÄ±ndan) en Ã¼st parÃ§a deÄŸilse:
1. Sonraki parÃ§a kullanÄ±mda deÄŸilse, sonraki parÃ§ada `unlink` Ã§aÄŸrÄ±lÄ±r.
2. ParÃ§ayÄ± Ã¶nceki, sonraki (bellek tarafÄ±ndan) parÃ§alarla birleÅŸtirin, herhangi biri boÅŸsa ve bunu sÄ±rasÄ±z kovaya ekleyin. Eklerken, `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` olup olmadÄ±ÄŸÄ± kontrol edilir. DeÄŸilse, bir hata ("free(): corrupted unsorted chunks") oluÅŸturulur.
8. Sonraki parÃ§a (bellek tarafÄ±ndan) en Ã¼st parÃ§a ise, parÃ§alarÄ± uygun ÅŸekilde tek bir en Ã¼st parÃ§aya birleÅŸtirin.
5. EÄŸer parÃ§a mmapped ise, `munmap_chunk` Ã§aÄŸrÄ±lÄ±r.

## HafÄ±za Ä°ÅŸlevleri GÃ¼venlik Kontrolleri

HafÄ±zada sÄ±kÃ§a kullanÄ±lan iÅŸlevlerde gerÃ§ekleÅŸtirilen gÃ¼venlik kontrollerini kontrol edin:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Referanslar

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
