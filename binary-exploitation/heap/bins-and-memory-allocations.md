# Bins & Alokacje Pamici

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe Informacje

Aby poprawi efektywno przechowywania kawak贸w, ka偶dy kawaek nie jest przechowywany tylko w jednej licie poczonej, ale istnieje kilka typ贸w. S to tzw. "bins", a istnieje 5 typ贸w bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) maych bins, 63 du偶ych bins, 1 bin niesortowany, 10 szybkich bins i 64 bins tcache na wtek.

Pocztkowy adres do ka偶dego binu niesortowanego, maego i du偶ego znajduje si w tej samej tablicy. Indeks 0 jest nieu偶ywany, 1 to bin niesortowany, biny 2-64 to mae biny, a biny 65-127 to du偶e biny.

### Mae Biny

Mae biny s szybsze ni偶 du偶e biny, ale wolniejsze ni偶 szybkie biny.

Ka偶dy bin spor贸d 62 bdzie mia **kawaki o tej samej wielkoci**: 16, 24, ... (z maksymaln wielkoci 504 bajt贸w w systemach 32-bitowych i 1024 w systemach 64-bitowych). Pomaga to w szybkoci znajdowania bina, w kt贸rym powinno by przydzielone miejsce oraz w wstawianiu i usuwaniu wpis贸w na tych listach.

### Du偶e Biny

W przeciwiestwie do maych bin贸w, kt贸re zarzdzaj kawakami o staych rozmiarach, ka偶dy **du偶y bin obsuguje zakres rozmiar贸w kawak贸w**. Jest to bardziej elastyczne, pozwalajc systemowi na dostosowanie si do **r贸偶nych rozmiar贸w** bez koniecznoci posiadania osobnego bina dla ka偶dego rozmiaru.

W alokatorze pamici, du偶e biny zaczynaj si tam, gdzie kocz si mae biny. Zakresy dla du偶ych bin贸w rosn stopniowo, co oznacza, 偶e pierwszy bin mo偶e obejmowa kawaki od 512 do 576 bajt贸w, podczas gdy nastpny obejmuje 576 do 640 bajt贸w. Ten wzorzec kontynuuje si, a najwikszy bin zawiera wszystkie kawaki powy偶ej 1 MB.

Du偶e biny s wolniejsze w dziaaniu w por贸wnaniu do maych bin贸w, poniewa偶 musz **sortowa i przeszukiwa list r贸偶nych rozmiar贸w kawak贸w, aby znale藕 najlepsze dopasowanie** dla alokacji. Gdy kawaek jest wstawiany do du偶ego bina, musi by posortowany, a podczas alokacji pamici system musi znale藕 odpowiedni kawaek. Dodatkowa praca sprawia, 偶e s one **wolniejsze**, ale poniewa偶 du偶e alokacje s mniej powszechne ni偶 mae, jest to akceptowalny kompromis.

Istniej:

* 32 biny o zakresie 64B
* 16 bin贸w o zakresie 512B
* 8 bin贸w o zakresie 4096B
* 4 biny o zakresie 32768B
* 2 biny o zakresie 262144B
* 1 bin na pozostae rozmiary

### Bin Niesortowany

Bin niesortowany to **szybka pami podrczna** u偶ywana przez mened偶era sterty do przyspieszenia alokacji pamici. Oto jak to dziaa: gdy program zwalnia pami, mened偶er sterty nie umieszcza jej od razu w konkretnym binie. Zamiast tego najpierw pr贸buje **poczy j z ssiednimi wolnymi kawakami**, aby utworzy wikszy blok wolnej pamici. Nastpnie umieszcza ten nowy kawaek w og贸lnym binie o nazwie "bin niesortowany".

Gdy program **prosi o pami**, mened偶er sterty **sprawdza bin niesortowany**, aby zobaczy, czy jest tam kawaek wystarczajcego rozmiaru. Jeli znajdzie odpowiedni kawaek, u偶ywa go od razu. Jeli nie znajdzie odpowiedniego kawaka, przenosi zwolnione kawaki do odpowiadajcych im bin贸w, maych lub du偶ych, w zale偶noci od ich rozmiaru.

Wic bin niesortowany to spos贸b przyspieszenia alokacji pamici poprzez szybkie ponowne wykorzystanie niedawno zwolnionej pamici i zmniejszenie potrzeby czasochonnego wyszukiwania i czenia.

{% hint style="danger" %}
Zauwa偶, 偶e nawet jeli kawaki nale偶 do r贸偶nych kategorii, jeli dostpny kawaek koliduje z innym dostpnym kawakiem (nawet jeli s to r贸偶ne kategorie), zostan one poczone.
{% endhint %}

### Szybkie Biny

Szybkie biny s zaprojektowane, aby **przyspieszy alokacj pamici dla maych kawak贸w**, trzymajc niedawno zwolnione kawaki w strukturze szybkiego dostpu. Te biny u偶ywaj podejcia Last-In, First-Out (LIFO), co oznacza, 偶e **najbardziej niedawno zwolniony kawaek jest pierwszy** do ponownego u偶ycia, gdy wystpuje nowe 偶danie alokacji. To zachowanie jest korzystne dla szybkoci, poniewa偶 jest szybciej wstawia i usuwa z g贸ry stosu (LIFO) w por贸wnaniu do kolejki (FIFO).

Dodatkowo, **szybkie biny u偶ywaj list jednokierunkowych**, a nie dwukierunkowych, co dodatkowo poprawia szybko. Poniewa偶 kawaki w szybkich binach nie s czone z ssiadami, nie ma potrzeby skomplikowanej struktury, kt贸ra pozwala na usuwanie ze rodka. Lista jednokierunkowa jest prostsza i szybsza dla tych operacji.

W zasadzie, to co si dzieje tutaj, to 偶e nag贸wek (wska藕nik do pierwszego kawaka do sprawdzenia) zawsze wskazuje na najnowszy zwolniony kawaek tego rozmiaru. Wic:

* Gdy nowy kawaek jest alokowany o tym rozmiarze, nag贸wek wskazuje na wolny kawaek do u偶ycia. Poniewa偶 ten wolny kawaek wskazuje na nastpny do u偶ycia, ten adres jest przechowywany w nag贸wku, aby nastpna alokacja wiedziaa, gdzie znale藕 dostpny kawaek.
* Gdy kawaek jest zwalniany, wolny kawaek zapisze adres do aktualnie dostpnego kawaka, a adres do tego nowo zwolnionego kawaka zostanie umieszczony w nag贸wku.

{% hint style="danger" %}
Kawaki w szybkich binach nie s automatycznie ustawiane jako dostpne, wic pozostaj jako kawaki szybkich bin贸w przez pewien czas zamiast m贸c czy si z innymi kawakami.
{% endhint %}

### Biny Tcache (Pami Podrczna na Wtek)

Mimo 偶e wtki staraj si mie swoj wasn stert (patrz [Areny](bins-and-memory-allocations.md#arenas) i [Podsterty](bins-and-memory-allocations.md#subheaps)), istnieje mo偶liwo, 偶e proces z wieloma wtkami (np. serwer sieciowy) **bdzie dzieli stert z innymi wtkami**. W takim przypadku g贸wnym rozwizaniem jest u偶ycie **blokad**, kt贸re mog **znacznie spowolni wtki**.

Dlatego tcache jest podobne do szybkiego bina na wtek w taki spos贸b, 偶e jest to **lista jednokierunkowa**, kt贸ra nie czy kawak贸w. Ka偶dy wtek ma **64 jednokierunkowe biny tcache**. Ka偶dy bin mo偶e zawiera maksymalnie [7 kawak贸w tego samego rozmiaru](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) o rozmiarach od [24 do 1032B w systemach 64-bitowych i od 12 do 516B w systemach 32-bitowych](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Gdy wtek zwalnia** kawaek, **jeli nie jest zbyt du偶y** do alokacji w tcache i odpowiedni bin tcache **nie jest peny** (ju偶 7 kawak贸w), **zostanie tam zaalokowany**. Jeli nie mo偶e trafi do tcache, bdzie musia czeka na blokad sterty, aby m贸c wykona operacj zwolnienia globalnie.

Gdy **kawaek jest alokowany**, jeli istnieje wolny kawaek potrzebnego rozmiaru w **tcache, zostanie u偶yty**, jeli nie, bdzie musia czeka na blokad sterty, aby znale藕 go w globalnych binach lub utworzy nowy.\
Istnieje tak偶e optymalizacja, w tym przypadku, podczas posiadania blokady sterty, wtek **wypeni swoje tcache kawakami sterty (7) o 偶danym rozmiarze**, wic jeli potrzebuje wicej, znajdzie je w tcache.
## Przepyw alokacji

{% hint style="success" %}
(Ta obecna wyjanienie pochodzi z [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Sprawd藕 ostatni wersj i zaktualizuj)
{% endhint %}

Alokacje s ostatecznie wykonywane za pomoc funkcji: `void * _int_malloc (mstate av, size_t bytes)` i maj taki porzdek:

1. Aktualizuje `bytes`, aby uwzgldni **wyr贸wnania**, itp.
2. Sprawdza, czy `av` jest **NULL** czy nie.
3. W przypadku braku **dostpnej areny** (gdy `av` jest NULL), wywouje `sysmalloc`, aby uzyska fragment za pomoc mmap. Jeli operacja powiedzie si, wywouje `alloc_perturb`. Zwraca wska藕nik.
4. W zale偶noci od rozmiaru:
* \[Dodatkowe w stosunku do oryginau] U偶yj tcache przed sprawdzeniem nastpnego fastbinu.
* \[Dodatkowe w stosunku do oryginau] Jeli brak tcache, ale u偶ywany jest inny bin (patrz p贸藕niejszy krok), spr贸buj wypeni tcache z tego bina.
* Jeli rozmiar mieci si w zakresie **fastbin**:
1. Uzyskuje indeks do tablicy fastbin贸w, aby uzyska odpowiedni bin zgodnie z 偶danym rozmiarem.
2. Usuwa pierwszy fragment z tego bina i ustawia `victim` na niego.
3. Jeli `victim` jest NULL, przechodzi do nastpnego przypadku (smallbin).
4. Jeli `victim` nie jest NULL, sprawdza rozmiar fragmentu, aby upewni si, 偶e nale偶y on do tego konkretnego bina. W przeciwnym razie zostanie zgoszony bd ("malloc(): pami zostaa uszkodzona (fast)").
5. Wywouje `alloc_perturb`, a nastpnie zwraca wska藕nik.
* Jeli rozmiar mieci si w zakresie **smallbin**:
1. Uzyskuje indeks do tablicy smallbin贸w, aby uzyska odpowiedni bin zgodnie z 偶danym rozmiarem.
2. Jeli w tym binie nie ma fragment贸w, przechodzi do nastpnego przypadku. Sprawdzane jest to poprzez por贸wnanie wska藕nik贸w `bin` i `bin->bk`.
3. `victim` jest ustawiony na `bin->bk` (ostatni fragment w binie). Jeli jest NULL (co zdarza si podczas `inicjalizacji`), wywouje `malloc_consolidate` i pomija ten cay krok sprawdzania r贸偶nych bin贸w.
4. W przeciwnym razie, gdy `victim` nie jest NULL, sprawdza, czy `victim->bk->fd` i `victim` s r贸wne czy nie. Jeli nie s r贸wne, zostanie zgoszony bd (`malloc(): pami listy dwukierunkowej smallbin zostaa uszkodzona`).
5. Ustawia bit PREV\_INSUSE dla nastpnego fragmentu (w pamici, nie w licie dwukierunkowej) dla `victim`.
6. Usuwa ten fragment z listy bina.
7. Ustawia odpowiedni bit areny dla tego fragmentu w zale偶noci od `av`.
8. Wywouje `alloc_perturb`, a nastpnie zwraca wska藕nik.
* Jeli rozmiar nie mieci si w zakresie smallbin:
1. Uzyskuje indeks do tablicy largebin贸w, aby uzyska odpowiedni bin zgodnie z 偶danym rozmiarem.
2. Sprawdza, czy `av` ma fastchunki czy nie. Jest to sprawdzane poprzez sprawdzenie `FASTCHUNKS_BIT` w `av->flags`. Jeli tak, wywouje `malloc_consolidate` na `av`.
5. Jeli jeszcze nie zosta zwr贸cony 偶aden wska藕nik, oznacza to jedno lub wicej z nastpujcych przypadk贸w:
1. Rozmiar mieci si w zakresie 'fastbin', ale brak dostpnych fastchunk贸w.
2. Rozmiar mieci si w zakresie 'smallbin', ale brak dostpnych smallchunk贸w (wywouje `malloc_consolidate` podczas inicjalizacji).
3. Rozmiar mieci si w zakresie 'largebin'.
6. Nastpnie sprawdzane s **nieuporzdkowane fragmenty** i przegldane fragmenty s umieszczane w binach. Jest to jedyne miejsce, gdzie fragmenty s umieszczane w binach. Iteruje si po nieuporzdkowanym binie od 'TAIL'.
1. `victim` wskazuje na bie偶cy rozwa偶any fragment.
2. Sprawdza, czy rozmiar fragmentu `victim` mieci si w zakresie minimalnym (`2*SIZE_SZ`) i maksymalnym (`av->system_mem`). W przeciwnym razie zostanie zgoszony bd (`malloc(): pami zostaa uszkodzona`).
3. Jeli (rozmiar 偶danego fragmentu mieci si w zakresie smallbin) i (`victim` jest ostatnim resztkowym fragmentem) i (jest to jedyny fragment w nieuporzdkowanym binie) i (rozmiar fragment贸w >= 偶dany): **Podziel fragment na 2 fragmenty**:
* Pierwszy fragment pasuje do 偶danego rozmiaru i jest zwracany.
* Pozostay fragment staje si nowym ostatnim resztkowym fragmentem. Jest ponownie wstawiany do nieuporzdkowanego bina.
1. Ustawia pola `chunk_size` i `chunk_prev_size` odpowiednio dla obu fragment贸w.
2. Pierwszy fragment jest zwracany po wywoaniu `alloc_perturb`.
3. Jeli powy偶szy warunek jest faszywy, kontrola dochodzi tutaj. Usuwa `victim` z nieuporzdkowanego bina. Jeli rozmiar `victim` dokadnie pasuje do 偶danego rozmiaru, zwraca ten fragment po wywoaniu `alloc_perturb`.
4. Jeli rozmiar `victim` mieci si w zakresie smallbin, dodaj fragment do odpowiedniego smallbinu na `HEAD`.
5. W przeciwnym razie wstaw do odpowiedniego largebinu, zachowujc porzdek sortowania:
6. Najpierw sprawdza ostatni fragment (najmniejszy). Jeli `victim` jest mniejszy ni偶 ostatni fragment, wstawia go na kocu.
7. W przeciwnym razie ptla znajduje fragment o rozmiarze >= rozmiaru `victim`. Jeli rozmiar jest dokadnie taki sam, zawsze wstawia go na drugiej pozycji.
8. Powtarza ten cay krok maksymalnie `MAX_ITERS` (10000) razy lub dop贸ki wszystkie fragmenty w nieuporzdkowanym binie nie zostan wyczerpane.
7. Po sprawdzeniu nieuporzdkowanych fragment贸w, sprawd藕, czy 偶dany rozmiar nie mieci si w zakresie smallbin, jeli tak, sprawd藕 **largebiny**.
1. Uzyskuje indeks do tablicy largebin贸w, aby uzyska odpowiedni bin zgodnie z 偶danym rozmiarem.
2. Jeli rozmiar najwikszego fragmentu (pierwszy fragment w binie) jest wikszy ni偶 偶dany rozmiar:
1. Iteruje od 'TAIL', aby znale藕 fragment (`victim`) o najmniejszym rozmiarze >= 偶danego rozmiaru.
2. Wywouje `unlink`, aby usun fragment `victim` z bina.
3. Oblicza `remainder_size` dla fragmentu `victim` (bdzie to rozmiar fragmentu `victim` - 偶dany rozmiar).
4. Jeli ten `remainder_size` >= `MINSIZE` (minimalny rozmiar fragmentu, wliczajc nag贸wki), dzieli fragment na dwa fragmenty. W przeciwnym razie cay fragment `victim` zostanie zwr贸cony. Wstaw pozostay fragment do nieuporzdkowanego bina (na kocu 'TAIL'). W nieuporzdkowanym binie sprawdzane jest, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. W przeciwnym razie zostanie zgoszony bd ("malloc(): uszkodzone nieuporzdkowane fragmenty").
5. Zwraca fragment `victim` po wywoaniu `alloc_perturb`.
8. Do tej pory sprawdzilimy nieuporzdkowany bin oraz odpowiedni fast, small lub large bin. Zauwa偶, 偶e pojedynczy bin (fast lub small) by sprawdzany z **dokadnym** rozmiarem 偶danego fragmentu. Powtarzaj nastpujce kroki, a偶 wszystkie biny zostan wyczerpane:
1. Indeks do tablicy bin贸w jest inkrementowany, aby sprawdzi nastpny bin.
2. U偶yj mapy `av->binmap`, aby pomin biny, kt贸re s puste.
3. `victim` wskazuje na 'TAIL' bie偶cego bina.
4. U偶ywajc mapy bin贸w, zapewnia, 偶e jeli bin zostanie pominity (w powy偶szym 2. kroku), na pewno jest pusty. Jednak nie zapewnia, 偶e wszystkie puste biny zostan pominite. Sprawd藕, czy `victim` jest pusty czy nie. Jeli jest pusty, ponownie pomi bin i powt贸rz powy偶szy proces (lub 'kontynuuj' t ptl), a偶 dotrzemy do niepustego bina.
5. Podziel fragment (`victim` wskazuje na ostatni fragment niepustego bina) na dwa fragmenty. Wstaw pozostay fragment do nieuporzdkowanego bina (na kocu 'TAIL'). W nieuporzdkowanym binie sprawdzane jest, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. W przeciwnym razie zostanie zgoszony bd ("malloc(): uszkodzone nieuporzdkowane fragmenty 2").
6. Zwraca fragment `victim` po wywoaniu `alloc_perturb`.
9. Jeli nadal nie zostanie znaleziony pusty bin, fragment 'top' zostanie u偶yty do obsugi 偶dania:
1. `victim` wskazuje na `av->top`.
2. Jeli rozmiar fragmentu 'top' >= '偶dany rozmiar' + `MINSIZE`, dzieli go na dwa fragmenty. W tym przypadku pozostay fragment staje si nowym fragmentem 'top', a inny fragment jest zwracany u偶ytkownikowi po wywoaniu `alloc_perturb`.
3. Sprawdza, czy `av` ma fastchunki czy nie. Jest to sprawdzane poprzez sprawdzenie `FASTCHUNKS_BIT` w `av->flags`. Jeli tak, wywouje `malloc_consolidate` na `av`. Powr贸t do kroku 6 (gdzie sprawdzamy nieuporzdkowany bin).
4. Jeli `av` nie ma fastchunk贸w, wywouje `sysmalloc` i zwraca uzyskany wska藕nik po wywoaniu `alloc_perturb`.
## Wolny przepyw

{% hint style="success" %}
(Tre ta pochodzi z [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Sprawd藕 ostatni wersj i zaktualizuj)
{% endhint %}

Ostateczna funkcja zwalniania fragment贸w pamici to `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Sprawd藕, czy `p` znajduje si przed `p + chunksize(p)` w pamici (aby unikn zawijania). W przeciwnym razie zostanie zgoszony bd (`free(): invalid pointer`).
2. Sprawd藕, czy rozmiar fragmentu wynosi co najmniej `MINSIZE` lub jest wielokrotnoci `MALLOC_ALIGNMENT`. W przeciwnym razie zostanie zgoszony bd (`free(): invalid size`).
3. Jeli rozmiar fragmentu znajduje si na licie fastbin:
1. Sprawd藕, czy rozmiar nastpnego fragmentu mieci si midzy minimalnym a maksymalnym rozmiarem (`av->system_mem`), w przeciwnym razie zgo bd (`free(): invalid next size (fast)`).
2. Wywoaj `free_perturb` na fragmencie.
3. Ustaw `FASTCHUNKS_BIT` dla `av`.
4. Pobierz indeks do tablicy fastbin zgodnie z rozmiarem fragmentu.
5. Sprawd藕, czy g贸ra pojemnika nie jest fragmentem, kt贸ry dodajemy. W przeciwnym razie zgo bd (`double free or corruption (fasttop)`).
6. Sprawd藕, czy rozmiar fragmentu fastbin na g贸rze jest taki sam jak dodawany fragment. W przeciwnym razie zgo bd (`invalid fastbin entry (free)`).
7. Wstaw fragment na g贸r listy fastbin i zwr贸.
4. Jeli fragment nie jest zmapowany:
1. Sprawd藕, czy fragment jest g贸rnym fragmentem czy nie. Jeli tak, zgo bd (`double free or corruption (top)`).
2. Sprawd藕, czy nastpny fragment (wedug pamici) mieci si w granicach areny. Jeli nie, zgo bd (`double free or corruption (out)`).
3. Sprawd藕, czy poprzedni fragment nastpnego fragmentu (wedug pamici) jest oznaczony jako u偶ywany czy nie. Jeli nie, zgo bd (`double free or corruption (!prev)`).
4. Sprawd藕, czy rozmiar nastpnego fragmentu mieci si midzy minimalnym a maksymalnym rozmiarem (`av->system_mem`). Jeli nie, zgo bd (`free(): invalid next size (normal)`).
5. Wywoaj `free_perturb` na fragmencie.
6. Jeli poprzedni fragment (wedug pamici) nie jest u偶ywany, wywoaj `unlink` na poprzednim fragmencie.
7. Jeli nastpny fragment (wedug pamici) nie jest g贸rnym fragmentem:
1. Jeli nastpny fragment nie jest u偶ywany, wywoaj `unlink` na nastpnym fragmencie.
2. Pocz fragment z poprzednim, nastpnym (wedug pamici), jeli kt贸rykolwiek jest wolny, i dodaj go na pocztek nieposortowanego pojemnika. Przed wstawieniem sprawd藕, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` czy nie. Jeli nie, zgo bd ("free(): corrupted unsorted chunks").
8. Jeli nastpny fragment (wedug pamici) by g贸rnym fragmentem, odpowiednio pocz fragmenty w pojedynczy g贸rny fragment.
5. Jeli fragment by zmapowany, wywoaj `munmap_chunk`.

## Sprawdzenia bezpieczestwa funkcji sterty

Sprawd藕 sprawdzenia bezpieczestwa wykonywane przez czsto u偶ywane funkcje w stercie w:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Odnoniki

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
