# Przepenienie sterty

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Przepenienie sterty jest podobne do [**przepenienia stosu**](../stack-overflow/), ale wystpuje w stercie. Oznacza to, 偶e pewna przestrze zostaa zarezerwowana w stercie do przechowywania danych i **przechowywane dane byy wiksze ni偶 zarezerwowana przestrze**.

W przypadku przepenie stosu wiemy, 偶e niekt贸re rejestry, takie jak wska藕nik instrukcji lub ramka stosu, zostan przywr贸cone ze stosu i mo偶liwe jest ich nadu偶ycie. W przypadku przepenie sterty **domylnie nie ma przechowywanych 偶adnych wra偶liwych informacji** w kawaku sterty, kt贸ry mo偶e zosta przepeniony. Jednak偶e mog to by wra偶liwe informacje lub wska藕niki, wic **krytyczno** tej podatnoci **zale偶y** od **tego, kt贸re dane mog zosta nadpisane** i jak atakujcy m贸gby to wykorzysta.

{% hint style="success" %}
Aby znale藕 przesunicia przepenie, mo偶na u偶y tych samych wzorc贸w co w [**przepenieniach stosu**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Przepenienia stosu vs przepenienia sterty

W przypadku przepenie stosu ukad i dane, kt贸re bd obecne na stosie w momencie wywoania podatnoci, s do niezawodne. Wynika to z faktu, 偶e stos jest liniowy, zawsze zwikszajcy si w kolizyjnej pamici, w **konkretnych miejscach dziaania programu pami stosu zazwyczaj przechowuje podobne rodzaje danych** i ma okrelon struktur z pewnymi wska藕nikami na kocu czci stosu u偶ywanej przez ka偶d funkcj.

Jednak w przypadku przepenienia sterty, poniewa偶 u偶ywana pami nie jest liniowa, ale **zarezerwowane kawaki s zazwyczaj w oddzielonych pozycjach pamici** (nie obok siebie) z powodu **koszyk贸w i stref**, kt贸re separuj alokacje wedug rozmiaru i poniewa偶 **poprzednio zwolniona pami jest u偶ywana** przed alokacj nowych kawak贸w. Jest **trudno okreli obiekt, kt贸ry bdzie kolidowa z obiektem podatnym** na przepenienie sterty. Dlatego, gdy znajdowane jest przepenienie sterty, konieczne jest znalezienie **niezawodnego sposobu, aby po偶dany obiekt by nastpny w pamici** od obiektu, kt贸ry mo偶e zosta przepeniony.

Jedn z technik u偶ywanych do tego jest **Grooming sterty**, kt贸ra jest u偶ywana na przykad [**w tym pocie**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). W pocie wyjaniono, 偶e gdy w jdrze iOS strefa wyczerpie pami do przechowywania kawak贸w pamici, rozszerza j o stron jdra, a ta strona jest dzielona na kawaki o oczekiwanych rozmiarach, kt贸re bd u偶ywane w kolejnoci (do wersji iOS 9.2, nastpnie te kawaki s u偶ywane w losowy spos贸b, aby utrudni eksploatacj tych atak贸w).

Dlatego w poprzednim pocie, gdzie wystpuje przepenienie sterty, aby wymusi, aby obiekt podatny na przepenienie kolidowa z obiektem ofiary, kilka **`kallocs` jest wymuszanych przez kilka wtk贸w, aby upewni si, 偶e wszystkie wolne kawaki s wypenione i 偶e zostaje utworzona nowa strona**.

Aby wymusi to wypenienie obiektami o okrelonym rozmiarze, **alokacja poza lini zwizan z portem mach iOS** jest idealnym kandydatem. Poprzez dostosowanie rozmiaru wiadomoci mo偶liwe jest dokadne okrelenie rozmiaru alokacji `kalloc`, a gdy odpowiadajcy port mach zostanie zniszczony, odpowiadajca alokacja zostanie natychmiast zwolniona z powrotem do `kfree`.

Nastpnie niekt贸re z tych miejsc mog by **zwolnione**. Lista zwolnionych element贸w **`kalloc.4096` zwalnia elementy w kolejnoci ostatni wchodzi, pierwszy wychodzi**, co w zasadzie oznacza, 偶e jeli niekt贸re miejsca s zwalniane i exploit pr贸buje alokowa kilka obiekt贸w ofiary podczas pr贸by alokacji obiektu podatnego na przepenienie, jest prawdopodobne, 偶e ten obiekt bdzie nastpowany przez obiekt ofiary.

### Przykad libc

[W tym miejscu](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) mo偶na znale藕 podstawow emulacj przepenienia sterty, kt贸ra pokazuje, jak nadpisanie poprzedniego bitu w u偶yciu nastpnego kawaka i pozycja poprzedniego rozmiaru umo偶liwia **skonsolidowanie u偶ytego kawaka** (poprzez sprawienie, 偶e myli, 偶e jest nieu偶ywany) i **nastpnie ponowne jego alokowanie**, co pozwala na nadpisanie danych u偶ywanych w innym wska藕niku.

Inny przykad z [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) pokazuje bardzo podstawowy przykad CTF, w kt贸rym **przepenienie sterty** mo偶e by wykorzystane do wywoania funkcji zwycizcy i **uzyskania flagi**.

W przykadzie [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) mo偶na zobaczy, jak nadu偶ywajc przepenienia bufora, mo偶liwe jest **nadpisanie w ssiednim kawaku adresu**, gdzie **dowolne dane od u偶ytkownika** zostan zapisane.

### Przykad ARM64

Na stronie [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) znajdziesz przykad przepenienia sterty, gdzie polecenie, kt贸re ma zosta wykonane, jest przechowywane w nastpnym kawaku po przepenionym kawaku. Dlatego mo偶liwe jest zmodyfikowanie wykonywanego polecenia poprzez jego nadpisanie prostym exploitem.
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF** sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
