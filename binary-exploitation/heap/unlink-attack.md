# Unlink Napad

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne Informacije

Kada je ovaj napad otkriven, uglavnom je omogu캖avao WWW (Write What Where), me캠utim, neki **proveri su dodate** 캜ine캖i novu verziju napada interesantnijom i kompleksnijom i **beskorisnom**.

### Primer Koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Napad ne funkcioni코e ako se koriste tcaches (nakon 2.26)

### Cilj

Ovaj napad omogu캖ava **promenu pokaziva캜a na blok tako da pokazuje na 3 adrese pre sebe**. Ako nova lokacija (okolina gde je pokaziva캜 bio sme코ten) sadr쬴 zanimljive stvari, poput drugih kontrolisanih alokacija / steka..., mogu캖e je 캜itati/pisati preko njih kako bi se prouzrokovala ve캖a 코teta.

* Ako je ovaj pokaziva캜 bio sme코ten u steku, jer sada pokazuje 3 adrese pre sebe i korisnik potencijalno mo쬰 da ga 캜ita i menja, bi캖e mogu캖e procuriti osetljive informacije iz steka ili 캜ak izmeniti povratnu adresu (mo쬯a) bez dodirivanja kanara
* U CTF primerima, ovaj pokaziva캜 se nalazi u nizu pokaziva캜a na druge alokacije, stoga, 캜ine캖i ga da pokazuje 3 adrese pre i mogu캖i za 캜itanje i pisanje, mogu캖e je naterati druge pokaziva캜e da pokazuju na druge adrese.\
Po코to korisnik potencijalno mo쬰 캜itati/pisati i druge alokacije, mo쬰 procuriti informacije ili prepisati nove adrese na proizvoljnim lokacijama (kao u GOT).

### Zahtevi

* Odre캠ena kontrola nad memorijom (npr. stekom) kako bi se kreirali par blokova daju캖i vrednosti nekim od atributa.
* Procurenje steka kako bi se postavili pokaziva캜i la쬹og bloka.

### Napad

* Postoje par blokova (blok1 i blok2)
* Napada캜 kontroli코e sadr쬬j bloka1 i zaglavlja bloka2.
* U bloku1 napada캜 kreira strukturu la쬹og bloka:
* Da bi zaobi코ao za코titu, osigurava da je polje `size` ispravno postavljeno kako bi se izbegla gre코ka: `corrupted size vs. prev_size while consolidating`
* i polja `fd` i `bk` la쬹og bloka pokazuju na mesto gde je sme코ten pokaziva캜 bloka1 sa ofsetima -3 i -2, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (steku) gde se zaista nalazi adresa bloka1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Zaglavlja bloka2 se menjaju kako bi se nazna캜ilo da prethodni blok nije kori코캖en i da je veli캜ina veli캜ina la쬹og bloka koji sadr쬴.
* Kada se drugi blok oslobodi, tada se de코ava odvajanje ovog la쬹og bloka:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->fd->bk` pokazuju na isto mesto (lokacija u steku gde je sme코ten `blok1`), tako da je to bila validna povezana lista. Po코to **oboje pokazuju na istu lokaciju**, samo poslednje (`fake_chunk->bk->fd = fake_chunk->fd`) 캖e imati **efekat**.
* Ovo 캖e **prepistati pokaziva캜 na blok1 u steku na adresu (ili bajtove) sme코tene 3 adrese pre u steku**.
* Stoga, ako napada캜 mo쬰 da kontroli코e sadr쬬j bloka1 ponovo, bi캖e u mogu캖nosti da **pi코e unutar steka** i potencijalno prepisuje povratnu adresu preska캜u캖i kanar i menja vrednosti i pokaziva캜e lokalnih promenljivih. 캛ak i ponovno menjanje adrese bloka1 sme코tene u steku na drugu lokaciju gde ako napada캜 ponovo mo쬰 da kontroli코e sadr쬬j bloka1, bi캖e u mogu캖nosti da pi코e bilo gde.
* Imajte na umu da je ovo bilo mogu캖e jer su **adrese sme코tene u steku**. Rizik i eksploatacija mogu zavisiti o **gde su adrese la쬹og bloka sme코tene**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Iako bi bilo 캜udno prona캖i unlink napad 캜ak i u CTF-u, ovde imate neke writeup-ove gde je ovaj napad kori코캖en:
* Primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* U ovom primeru, umesto steka postoji niz malloc adresa. Unlink napad se izvodi kako bi se mogao alocirati blok ovde, stoga je mogu캖e kontrolisati pokaziva캜e niza malloc adresa. Zatim, postoji jo코 jedna funkcionalnost koja omogu캖ava modifikaciju sadr쬬ja blokova na ovim adresama, 코to omogu캖ava usmeravanje adresa ka GOT-u, modifikaciju adresa funkcija za dobijanje procurivanja libc-a i RCE.
* Jo코 jedan primer CTF-a: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Ba코 kao i u prethodnom primeru, postoji niz adresa alokacija. Mogu캖e je izvesti unlink napad kako bi se adresa prve alokacije usmerila na nekoliko pozicija pre po캜etka niza i zatim prepisati ovu alokaciju na novu poziciju. Stoga je mogu캖e prepisati pokaziva캜e drugih alokacija da pokazuju na GOT atoi, ispisati ga da se dobije procurivanje libc-a, a zatim prepisati atoi GOT sa adresom do jednog ged쬰ta.
* CTF primer sa prilago캠enim malloc i free funkcijama koje zloupotrebljavaju ranjivost veoma sli캜nu unlink napadu: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Postoji prelivanje koje omogu캖ava kontrolu FD i BK pokaziva캜a prilago캠enog malloc-a koji 캖e biti (prilago캠eno) oslobo캠en. Osim toga, heap ima exec bit, tako da je mogu캖e procuriti adresu heap-a i usmeriti funkciju iz GOT-a ka heap bloku sa shellkodom za izvr코avanje.

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
