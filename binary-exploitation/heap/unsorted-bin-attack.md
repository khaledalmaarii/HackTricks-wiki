# Atak na nieuporzÄ…dkowany blok

<details>

<summary><strong>Zacznij od zera i staÅ„ siÄ™ ekspertem od hakowania AWS dziÄ™ki</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) albo **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Aby uzyskaÄ‡ wiÄ™cej informacji na temat tego, co oznacza nieuporzÄ…dkowany blok, sprawdÅº tÄ™ stronÄ™:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

NieuporzÄ…dkowane listy mogÄ… zapisaÄ‡ adres w `unsorted_chunks (av)` w adresie `bk` fragmentu. Dlatego jeÅ›li atakujÄ…cy moÅ¼e **zmodyfikowaÄ‡ adres wskaÅºnika bk** w fragmencie wewnÄ…trz nieuporzÄ…dkowanego bloku, moÅ¼e **zapisaÄ‡ ten adres w dowolnym adresie**, co moÅ¼e pomÃ³c w ujawnieniu adresÃ³w libc lub obejÅ›ciu niektÃ³rych zabezpieczeÅ„.

W zasadzie ten atak pozwala **nadpisaÄ‡ dowolny adres duÅ¼Ä… liczbÄ…** (adres, ktÃ³ry moÅ¼e byÄ‡ adresem sterty lub adresem libc), na przykÅ‚ad adresem stosu, ktÃ³ry moÅ¼e byÄ‡ ujawniony, lub jakimÅ› ograniczeniem, takim jak globalna zmienna **`global_max_fast`**, aby umoÅ¼liwiÄ‡ tworzenie blokÃ³w fast bin o wiÄ™kszych rozmiarach (i przejÅ›cie od ataku na nieuporzÄ…dkowany blok do ataku na fast bin).

{% hint style="success" %}
Przyjrzenie siÄ™ przykÅ‚adowi podanemu w [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) i uÅ¼ycie 0x4000 i 0x5000 zamiast 0x400 i 0x500 jako rozmiarÃ³w fragmentÃ³w (aby uniknÄ…Ä‡ tcaches) pozwala zobaczyÄ‡, Å¼e **obecnie** wywoÅ‚ywany jest bÅ‚Ä…d **`malloc(): unsorted double linked list corrupted`**.

Dlatego teraz ten atak na nieuporzÄ…dkowany blok (oprÃ³cz innych sprawdzeÅ„) wymaga rÃ³wnieÅ¼ naprawienia podwÃ³jnej listy poÅ‚Ä…czonej, aby to ominÄ…Ä‡ `victim->bck->fd == victim` lub nie `victim->fd == av (arena)`. Oznacza to, Å¼e adres, w ktÃ³ry chcemy zapisaÄ‡, musi mieÄ‡ adres faÅ‚szywego fragmentu w swojej pozycji `fd`, a faÅ‚szywy fragment `fd` wskazuje na arenÄ™.
{% endhint %}

{% hint style="danger" %}
ZauwaÅ¼, Å¼e ten atak psuje nieuporzÄ…dkowany blok (a takÅ¼e maÅ‚y i duÅ¼y). Dlatego teraz moÅ¼emy **korzystaÄ‡ tylko z alokacji z blokÃ³w fast bin** (bardziej zÅ‚oÅ¼ony program moÅ¼e wykonywaÄ‡ inne alokacje i ulec awarii), a aby to wywoÅ‚aÄ‡, musimy **zaalokowaÄ‡ ten sam rozmiar, w przeciwnym razie program ulegnie awarii**.

ZauwaÅ¼, Å¼e ustawienie **`global_max_fast`** moÅ¼e pomÃ³c w tym przypadku, zakÅ‚adajÄ…c, Å¼e fast bin bÄ™dzie w stanie obsÅ‚uÅ¼yÄ‡ wszystkie inne alokacje, dopÃ³ki exploit nie zostanie zakoÅ„czony.
{% endhint %}

Kod od [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) wyjaÅ›nia to bardzo dobrze, chociaÅ¼ jeÅ›li zmodyfikujesz alokacje pamiÄ™ci tak, aby alokowaÄ‡ pamiÄ™Ä‡ wystarczajÄ…co duÅ¼Ä…, aby nie trafiÄ‡ do tcaches, zobaczysz, Å¼e wczeÅ›niej wspomniany bÅ‚Ä…d uniemoÅ¼liwia zastosowanie tej techniki: **`malloc(): unsorted double linked list corrupted`**

## Atak na nieuporzÄ…dkowany blok wyciek informacji

To wÅ‚aÅ›ciwie bardzo podstawowe pojÄ™cie. Fragmenty w nieuporzÄ…dkowanym bloku bÄ™dÄ… miaÅ‚y wskaÅºniki podwÃ³jne wskaÅºniki, aby utworzyÄ‡ blok. Pierwszy fragment w nieuporzÄ…dkowanym bloku bÄ™dzie faktycznie mieÄ‡ **FD** i **BK** Å‚Ä…cza **wskazujÄ…ce na czÄ™Å›Ä‡ gÅ‚Ã³wnej areny (libc)**.\
Dlatego jeÅ›li moÅ¼esz **umieÅ›ciÄ‡ fragment wewnÄ…trz nieuporzÄ…dkowanego bloku i odczytaÄ‡ go** (uÅ¼yj po zwolnieniu) lub **ponownie go zaalokowaÄ‡ bez nadpisywania co najmniej 1 z wskaÅºnikÃ³w**, aby nastÄ™pnie go **odczytaÄ‡**, moÅ¼esz uzyskaÄ‡ **wyciek informacji z libc**.

## OdwoÅ‚ania i inne przykÅ‚ady

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Celem jest nadpisanie zmiennej globalnej wartoÅ›ciÄ… wiÄ™kszÄ… niÅ¼ 4869, aby uzyskaÄ‡ flagÄ™, a PIE nie jest wÅ‚Ä…czone.
* MoÅ¼liwe jest generowanie fragmentÃ³w o dowolnych rozmiarach i wystÄ™puje przepeÅ‚nienie sterty o poÅ¼Ä…danym rozmiarze.
* Atak rozpoczyna siÄ™ od utworzenia 3 fragmentÃ³w: fragmentu0 do naduÅ¼ycia przepeÅ‚nienia, fragmentu1 do przepeÅ‚nienia i fragmentu2, aby gÃ³rny fragment nie konsolidowaÅ‚ poprzednich.
* NastÄ™pnie fragment1 jest zwalniany, a fragment0 jest przepeÅ‚niany, aby wskaÅºnik `bk` fragmentu1 wskazywaÅ‚ na: `bk = magic - 0x10`
* NastÄ™pnie alokowany jest fragment3 o tym samym rozmiarze co fragment1, co spowoduje atak na nieuporzÄ…dkowany blok i zmodyfikuje wartoÅ›Ä‡ zmiennej globalnej, umoÅ¼liwiajÄ…c uzyskanie flagi.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Funkcja scalania jest podatna, poniewaÅ¼ jeÅ›li oba przekazane indeksy sÄ… takie same, to zrealokuje na nim i zwolni go, ale zwrÃ³ci wskaÅºnik do tego zwolnionego obszaru, ktÃ³ry moÅ¼na wykorzystaÄ‡.
* Dlatego **tworzone sÄ… 2 fragmenty**: **fragment0**, ktÃ³ry zostanie scalony sam ze sobÄ…, i fragment1, aby zapobiec konsolidacji z gÃ³rnym fragmentem. NastÄ™pnie funkcja scalania jest wywoÅ‚ywana z fragmentem0 dwa razy, co spowoduje uÅ¼ycie po zwolnieniu.
* NastÄ™pnie wywoÅ‚ywana jest funkcja **`view`** z indeksem 2 (ktÃ³ry jest indeksem fragmentu uÅ¼ytego po zwolnieniu), co spowoduje **wyciek adresu libc**.
* PoniewaÅ¼ binarny ma zabezpieczenia, aby alokowaÄ‡ tylko rozmiary wiÄ™ksze niÅ¼ **`global_max_fast`**, wiÄ™c nie uÅ¼ywany jest fastbin, atak na nieuporzÄ…dkowany blok zostanie uÅ¼yty do nadpisania zmiennej globalnej `global_max_fast`.
* NastÄ™pnie moÅ¼liwe jest wywoÅ‚anie funkcji edycji z indeksem 2 (wskaÅºnik uÅ¼yty po zwolnieniu) i nadpisanie wskaÅºnika `bk`, aby wskazywaÅ‚ na `p64(global_max_fast-0x10)`. NastÄ™pnie tworzenie nowego fragmentu uÅ¼yje wczeÅ›niej skompromitowanego adresu zwolnienia (0x20) i **spowoduje atak na nieuporzÄ…dkowany blok**, nadpisujÄ…c `global_max_fast` duÅ¼Ä… wartoÅ›ciÄ…, co teraz pozwala tworzyÄ‡ fragmenty w fastbinach.
* Teraz wykonywany jest **atak na fastbin**:
* Po pierwsze odkryto, Å¼e moÅ¼liwe jest pracowanie z szybkimi **fragmentami o rozmiarze 200** w lokalizacji **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gefâ¤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gefâ¤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* JeÅ›li uda nam siÄ™ uzyskaÄ‡ szybki blok o rozmiarze 0x200 w tej lokalizacji, bÄ™dzie moÅ¼liwe nadpisanie wskaÅºnika funkcji, ktÃ³ry zostanie wykonany
* W tym celu tworzony jest nowy blok o rozmiarze `0xfc` i funkcja scalajÄ…ca jest wywoÅ‚ywana z tym wskaÅºnikiem dwukrotnie, w ten sposÃ³b uzyskujemy wskaÅºnik do zwolnionego bloku o rozmiarze `0xfc*2 = 0x1f8` w szybkim bloku.
* NastÄ™pnie wywoÅ‚ywana jest funkcja edycji w tym bloku, aby zmodyfikowaÄ‡ adres **`fd`** tego szybkiego bloku tak, aby wskazywaÅ‚ na poprzedniÄ… funkcjÄ™ **`__free_hook`**.
* NastÄ™pnie tworzony jest blok o rozmiarze `0x1f8` w celu odzyskania z szybkiego bloku poprzedniego nieuÅ¼ytecznego bloku, wiÄ™c tworzony jest kolejny blok o rozmiarze `0x1f8`, aby uzyskaÄ‡ blok szybkiego bloku w **`__free_hook`**, ktÃ³ry zostaje nadpisany adresem funkcji **`system`**.
* I wreszcie blok zawierajÄ…cy ciÄ…g znakÃ³w `/bin/sh\x00` jest zwalniany, wywoÅ‚ujÄ…c funkcjÄ™ usuwania, co powoduje wywoÅ‚anie funkcji **`__free_hook`**, ktÃ³ra wskazuje na system z `/bin/sh\x00` jako parametrem.

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF** SprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
