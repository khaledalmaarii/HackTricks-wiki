# Ataque al Bin No Ordenado

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Informaci√≥n B√°sica

Para obtener m√°s informaci√≥n sobre qu√© es un bin no ordenado, consulta esta p√°gina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Las listas no ordenadas pueden escribir la direcci√≥n en `unsorted_chunks (av)` en la direcci√≥n `bk` del chunk. Por lo tanto, si un atacante puede **modificar la direcci√≥n del puntero bk** en un chunk dentro del bin no ordenado, podr√≠a ser capaz de **escribir esa direcci√≥n en una direcci√≥n arbitraria** que podr√≠a ser √∫til para filtrar direcciones de libc o evitar alguna defensa.

Por lo tanto, b√°sicamente, este ataque permite **sobrescribir alguna direcci√≥n arbitraria con un n√∫mero grande** (una direcci√≥n que podr√≠a ser una direcci√≥n de heap o de libc) como alguna direcci√≥n de stack que podr√≠a ser filtrada o alguna restricci√≥n como la variable global **`global_max_fast`** para permitir crear bins r√°pidos con tama√±os m√°s grandes (y pasar de un ataque al bin no ordenado a un ataque al bin r√°pido).

{% hint style="success" %}
Al observar el ejemplo proporcionado en [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) y usando 0x4000 y 0x5000 en lugar de 0x400 y 0x500 como tama√±os de chunk (para evitar tcaches) es posible ver que **actualmente** se desencadena el error **`malloc(): unsorted double linked list corrupted`**.

Por lo tanto, este ataque al bin no ordenado ahora (entre otras comprobaciones) tambi√©n requiere poder arreglar la lista doble enlazada para que se salte `victim->bck->fd == victim` o no `victim->fd == av (arena)`. Lo que significa que la direcci√≥n donde queremos escribir debe tener la direcci√≥n del chunk falso en su posici√≥n `fd` y que el `fd` del chunk falso apunta a la arena.
{% endhint %}

{% hint style="danger" %}
Ten en cuenta que este ataque corrompe el bin no ordenado (por lo tanto, tambi√©n el peque√±o y el grande). Por lo tanto, ahora solo podemos **utilizar asignaciones del bin r√°pido** (un programa m√°s complejo podr√≠a hacer otras asignaciones y fallar), y para desencadenar esto debemos **asignar el mismo tama√±o o el programa fallar√°**.

Ten en cuenta que hacer **`global_max_fast`** podr√≠a ayudar en este caso confiando en que el bin r√°pido podr√° encargarse de todas las dem√°s asignaciones hasta que se complete el exploit.
{% endhint %}

El c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) lo explica muy bien, aunque si modificas las asignaciones de memoria para asignar memoria lo suficientemente grande para que no termine en un tcache, ver√°s que aparece el error mencionado anteriormente que evita esta t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Referencias y Otros ejemplos

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* El objetivo es sobrescribir una variable global con un valor mayor a 4869 para poder obtener la bandera y sin que PIE est√© habilitado.
* Es posible generar chunks de tama√±os arbitrarios y hay un desbordamiento de heap con el tama√±o deseado.
* El ataque comienza creando 3 chunks: chunk0 para abusar del desbordamiento, chunk1 para ser desbordado y chunk2 para que el chunk superior no consolide los anteriores.
* Luego, se libera chunk1 y se desborda chunk0 para que el puntero `bk` de chunk1 apunte a: `bk = magic - 0x10`
* Despu√©s, se asigna chunk3 con el mismo tama√±o que chunk1, lo que desencadenar√° el ataque al bin no ordenado y modificar√° el valor de la variable global, permitiendo obtener la bandera.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La funci√≥n de fusi√≥n es vulnerable porque si ambos √≠ndices pasados son iguales, se realocar√° en √©l y luego se liberar√°, pero devolviendo un puntero a esa regi√≥n liberada que se puede utilizar.
* Por lo tanto, se crean **2 chunks**: **chunk0** que se fusionar√° consigo mismo y chunk1 para evitar la consolidaci√≥n con el chunk superior. Luego, se llama a la **funci√≥n de fusi√≥n con chunk0** dos veces, lo que causar√° un uso despu√©s de liberar.
* Luego, se llama a la funci√≥n **`view`** con el √≠ndice 2 (que es el √≠ndice del chunk de uso despu√©s de liberar), lo que **filtrar√° una direcci√≥n de libc**.
* Como el binario tiene protecciones para solo asignar tama√±os mayores que **`global_max_fast`** para que no se use un fastbin, se utilizar√° un ataque al bin no ordenado para sobrescribir la variable global `global_max_fast`.
* Luego, es posible llamar a la funci√≥n edit con el √≠ndice 2 (el puntero de uso despu√©s de liberar) y sobrescribir el puntero `bk` para que apunte a `p64(global_max_fast-0x10)`. Luego, al crear un nuevo chunk, se usar√° la direcci√≥n de liberaci√≥n comprometida anteriormente (0x20) y se **desencadenar√° el ataque al bin no ordenado** sobrescribiendo el `global_max_fast` con un valor muy grande, permitiendo ahora crear chunks en bins r√°pidos.
* Ahora se realiza un **ataque al fast bin**:
* En primer lugar, se descubre que es posible trabajar con **chunks r√°pidos de tama√±o 200** en la ubicaci√≥n de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Si logramos obtener un chunk r√°pido de tama√±o 0x200 en esta ubicaci√≥n, ser√° posible sobrescribir un puntero de funci√≥n que se ejecutar√°.
* Para esto, se crea un nuevo chunk de tama√±o `0xfc` y se llama a la funci√≥n de fusi√≥n con ese puntero dos veces, de esta manera obtenemos un puntero a un chunk liberado de tama√±o `0xfc*2 = 0x1f8` en el fast bin.
* Luego, se llama a la funci√≥n edit en este chunk para modificar la direcci√≥n **`fd`** de este fast bin para que apunte a la funci√≥n **`__free_hook`** anterior.
* Entonces, se crea un chunk con tama√±o `0x1f8` para recuperar del fast bin el chunk in√∫til anterior, luego se crea otro chunk de tama√±o `0x1f8` para obtener un chunk del fast bin en el **`__free_hook`** que es sobrescrito con la direcci√≥n de la funci√≥n **`system`**.
* Y finalmente se libera un chunk que contiene la cadena `/bin/sh\x00` llamando a la funci√≥n de eliminaci√≥n, desencadenando la funci√≥n **`__free_hook`** que apunta a system con `/bin/sh\x00` como par√°metro.
