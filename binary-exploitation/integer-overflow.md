# Prekoracenje celih brojeva

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

U srcu **prekoracenja celih brojeva** je ograni캜enje koje name캖u **veli캜ine** podataka u programiranju ra캜unara i **interpretacija** podataka.

Na primer, **8-bitni neozna캜eni ceo broj** mo쬰 predstavljati vrednosti od **0 do 255**. Ako poku코ate da sa캜uvate vrednost 256 u 8-bitnom neozna캜enom celom broju, ona 캖e se preklopiti na 0 zbog ograni캜enja njegove skladi코ne sposobnosti. Sli캜no tome, za **16-bitni neozna캜eni ceo broj**, koji mo쬰 dr쬬ti vrednosti od **0 do 65.535**, dodavanje 1 na 65.535 캖e preklopiti vrednost nazad na 0.

Osim toga, **8-bitni ozna캜eni ceo broj** mo쬰 predstavljati vrednosti od **-128 do 127**. To je zato 코to se jedan bit koristi za predstavljanje znaka (pozitivno ili negativno), ostavljaju캖i 7 bitova za predstavljanje veli캜ine. Najnegativniji broj je predstavljen kao **-128** (binarno `10000000`), a najpozitivniji broj je **127** (binarno `01111111`).

### Maksimalne vrednosti

Za potencijalne **web ranjivosti** veoma je zanimljivo znati maksimalne podr쬬ne vrednosti:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}

Integer overflow occurs when an arithmetic operation results in a value that exceeds the maximum size that the data type can hold. This can lead to unexpected behavior in the program, such as wrapping around to a minimum value or causing a buffer overflow.

To prevent integer overflow, always check the result of arithmetic operations to ensure that it does not exceed the maximum value that the data type can hold. Use data types that can accommodate the range of values you expect in your program.

In C, you can use the `INT_MAX` constant from the `<limits.h>` header file to determine the maximum value that an `int` can hold. Similarly, you can use `SIZE_MAX` from `<stdint.h>` to determine the maximum value that a `size_t` can hold.

Be cautious when performing arithmetic operations in C, especially when dealing with user input or dynamically calculated values, to avoid integer overflow vulnerabilities. 

```c
#include <stdio.h>
#include <limits.h>
#include <stdint.h>

int main() {
    int a = INT_MAX;
    size_t b = SIZE_MAX;

    if (a + 1 < a) {
        printf("Integer overflow occurred!\n");
    }

    if (b + 1 < b) {
        printf("Integer overflow occurred!\n");
    }

    return 0;
}
```

In the example above, we check for integer overflow by adding 1 to the maximum values of `int` and `size_t` and comparing them with the original values. If the result is less than the original value, an integer overflow has occurred.
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Primeri

### 캛isti prekora캜enje

Od코tampani rezultat 캖e biti 0 jer smo prekora캜ili karakter:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Pretvaranje potpisanog u nepotpisani tip

Razmotrite situaciju u kojoj se potpisani ceo broj 캜ita iz korisni캜kog unosa, a zatim koristi u kontekstu koji ga tretira kao nepotpisani ceo broj, bez odgovaraju캖e validacije:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
U ovom primeru, ako korisnik unese negativan broj, bi캖e tuma캜en kao veliki neozna캜eni broj zbog na캜ina na koji se tuma캜e binarne vrednosti, 코to potencijalno mo쬰 dovesti do neo캜ekivanog pona코anja.

### Ostali Primeri

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Koristi se samo 1B za 캜uvanje veli캜ine lozinke, pa je mogu캖e prekora캜iti je i naterati je da misli da je du쬴ne 4 dok je zapravo 260 kako bi se zaobi코la provera du쬴ne
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
*   Dati par brojeva i koriste캖i z3 prona캖i novi broj koji pomno쬰n sa prvom vredno코캖u daje drugu vrednost:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Koristi se samo 1B za 캜uvanje veli캜ine lozinke, pa je mogu캖e prekora캜iti je i naterati je da misli da je du쬴ne 4 dok je zapravo 260 kako bi se zaobi코la provera du쬴ne i prepisala slede캖a lokalna promenljiva na steku i zaobi코le obe za코tite

## ARM64

Ovo **se ne menja u ARM64** kao 코to mo쬰te videti u [**ovom blog postu**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
