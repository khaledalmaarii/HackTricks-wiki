# Bins ve Bellek Tahsisleri

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'ler gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## Temel Bilgiler

ParÃ§alarÄ±n nasÄ±l depolandÄ±ÄŸÄ±ndaki verimliliÄŸi artÄ±rmak iÃ§in her parÃ§a sadece bir baÄŸlÄ± listede deÄŸil, birkaÃ§ tÃ¼rde depolanÄ±r. Bunlar "bins"lerdir ve 5 tÃ¼r bin vardÄ±r: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) kÃ¼Ã§Ã¼k bins, 63 bÃ¼yÃ¼k bins, 1 sÄ±ralanmamÄ±ÅŸ bin, 10 hÄ±zlÄ± bins ve her iÅŸ parÃ§acÄ±ÄŸÄ± iÃ§in 64 tcache bin'i bulunmaktadÄ±r.

Her sÄ±ralanmamÄ±ÅŸ, kÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k binin baÅŸlangÄ±Ã§ adresi aynÄ± dizinin iÃ§indedir. Ä°ndeks 0 kullanÄ±lmamÄ±ÅŸtÄ±r, 1 sÄ±ralanmamÄ±ÅŸ bin, 2-64 arasÄ± kÃ¼Ã§Ã¼k binler ve 65-127 arasÄ± bÃ¼yÃ¼k binlerdir.

### Tcache (Ä°ÅŸ ParÃ§acÄ±ÄŸÄ± Ã–nbelleÄŸi) Bins

Ä°ÅŸ parÃ§acÄ±klarÄ± kendi belleÄŸe sahip olmaya Ã§alÄ±ÅŸsa da (bkz. [Arenalar](bins-and-memory-allocations.md#arenas) ve [Alt-bellekler](bins-and-memory-allocations.md#subheaps)), birÃ§ok iÅŸ parÃ§acÄ±ÄŸÄ±na sahip bir iÅŸlem (Ã¶rneÄŸin bir web sunucusu) **belleÄŸi diÄŸer iÅŸ parÃ§acÄ±klarÄ±yla paylaÅŸabilir**. Bu durumda, ana Ã§Ã¶zÃ¼m **kilitlerin** kullanÄ±lmasÄ±dÄ±r, bu da iÅŸ parÃ§acÄ±klarÄ±nÄ± **Ã¶nemli Ã¶lÃ§Ã¼de yavaÅŸlatabilir**.

Bu nedenle, bir tcache, parÃ§alarÄ± birleÅŸtirmeyen **tek yÃ¶nlÃ¼ baÄŸlÄ± listedir** ve her iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n **64 tek yÃ¶nlÃ¼ tcache bin'i** bulunmaktadÄ±r. Her bir bin, [64 bit sistemlerde 24 ile 1032B ve 32 bit sistemlerde 12 ile 516B arasÄ±nda](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315) aynÄ± boyutta en fazla [7 parÃ§aya](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) sahip olabilir.

Bir iÅŸ parÃ§acÄ±ÄŸÄ± bir parÃ§ayÄ± serbest bÄ±raktÄ±ÄŸÄ±nda, eÄŸer tcache'de tahsis edilecek kadar bÃ¼yÃ¼k deÄŸilse ve ilgili tcache bin **dolu deÄŸilse** (zaten 7 parÃ§a), **oraya tahsis edilecektir**. Tcache'e gidemezse, genel olarak serbest bÄ±rakma iÅŸlemini gerÃ§ekleÅŸtirebilmek iÃ§in bellek kilidinin aÃ§Ä±lmasÄ±nÄ± beklemelidir.

Bir **parÃ§a tahsis edildiÄŸinde**, eÄŸer **Tcache'de ihtiyaÃ§ duyulan boyutta boÅŸ bir parÃ§a varsa onu kullanÄ±r**, yoksa genel bins iÃ§inde bir tane bulabilmek veya yeni bir tane oluÅŸturabilmek iÃ§in bellek kilidinin aÃ§Ä±lmasÄ±nÄ± beklemelidir.\
Bu durumda bir optimizasyon da vardÄ±r, bu durumda bellek kilidi aÃ§Ä±kken, iÅŸ parÃ§acÄ±ÄŸÄ± **istenen boyutta heap parÃ§alarÄ±yla (7) Tcache'ini dolduracaktÄ±r**, bÃ¶ylece daha fazla ihtiyaÃ§ duyarsa onlarÄ± Tcache'de bulacaktÄ±r.

<details>

<summary>Bir tcache parÃ§a Ã¶rneÄŸi ekle</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
free(chunk);
return 0;
}
```
Derleyin ve ana iÅŸlevden ret komutunda bir kesme noktasÄ± ile hata ayÄ±klamayÄ± yapÄ±n. Sonra gef ile kullanÄ±mda olan tcache binini gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=1] â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
```
#### Tcache YapÄ±larÄ± ve Fonksiyonlar

AÅŸaÄŸÄ±daki kodda **maksimum kovalar** ve **her indeks baÅŸÄ±na parÃ§alar**, Ã§ift serbest bÄ±rakmalarÄ± Ã¶nlemek iÃ§in oluÅŸturulan **`tcache_entry`** yapÄ±sÄ± ve her bir iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n kovanÄ±n her indeksine ait adresleri depolamak iÃ§in kullandÄ±ÄŸÄ± **`tcache_perthread_struct`** yapÄ±sÄ± gÃ¶rÃ¼lebilir.

</details>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c

/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */
# define TCACHE_MAX_BINS		64
# define MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)

/* Only used to pre-fill the tunables.  */
# define tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)

/* When "x" is from chunksize().  */
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
/* When "x" is a user-provided size.  */
# define usize2tidx(x) csize2tidx (request2size (x))

/* With rounding and alignment, the bins are...
idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
idx 1   bytes 25..40 or 13..20
idx 2   bytes 41..56 or 21..28
etc.  */

/* This is another arbitrary limit, which tunables can change.  Each
tcache bin will hold at most this number of chunks.  */
# define TCACHE_FILL_COUNT 7

/* Maximum chunks in tcache bins for tunables.  This value must fit the range
of tcache->counts[] entries, else they may overflow.  */
# define MAX_TCACHE_COUNT UINT16_MAX

[...]

typedef struct tcache_entry
{
struct tcache_entry *next;
/* This field exists to detect double frees.  */
uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
per-thread cache (hence "tcache_perthread_struct").  Keeping
overall size low is mildly important.  Note that COUNTS and ENTRIES
are redundant (we could have just counted the linked list each
time), this is for performance reasons.  */
typedef struct tcache_perthread_struct
{
uint16_t counts[TCACHE_MAX_BINS];
tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
</details>

`__tcache_init` iÅŸlevi, `tcache_perthread_struct` nesnesi iÃ§in alan oluÅŸturan ve ayÄ±ran iÅŸlevdir.

<details>

<summary>tcache_init kodu</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3241C1-L3274C2

static void
tcache_init(void)
{
mstate ar_ptr;
void *victim = 0;
const size_t bytes = sizeof (tcache_perthread_struct);

if (tcache_shutting_down)
return;

arena_get (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
if (!victim && ar_ptr != NULL)
{
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}


if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);

/* In a low memory situation, we may not be able to allocate memory
- in which case, we just keep trying later.  However, we
typically do this very early, so either there is sufficient
memory, or there isn't enough memory to do non-trivial
allocations anyway.  */
if (victim)
{
tcache = (tcache_perthread_struct *) victim;
memset (tcache, 0, sizeof (tcache_perthread_struct));
}

}
```
</details>

#### Tcache Ä°ndeksleri

Tcache, **her bir indeksin ilk parÃ§asÄ±na iÅŸaret eden baÅŸlangÄ±Ã§ iÅŸaretÃ§ilerine ve her indeks iÃ§in parÃ§a miktarÄ±na baÄŸlÄ± olarak Ã§eÅŸitli bÃ¶lÃ¼mlere sahiptir ve bu bilgiler bir parÃ§anÄ±n iÃ§inde bulunur**. Bu, bu bilgileri iÃ§eren parÃ§ayÄ± (genellikle ilk parÃ§ayÄ±) bulmak, tÃ¼m tcache baÅŸlangÄ±Ã§ noktalarÄ±nÄ± ve Tcache parÃ§a miktarÄ±nÄ± bulmayÄ± mÃ¼mkÃ¼n kÄ±lar.

### HÄ±zlÄ± Bins

HÄ±zlÄ± bÃ¶lÃ¼mler, **kÃ¼Ã§Ã¼k parÃ§alar iÃ§in bellek tahsisini hÄ±zlandÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r** ve son zamanlarda serbest bÄ±rakÄ±lan parÃ§alarÄ± hÄ±zlÄ± eriÅŸimli bir yapÄ±da tutarak Ã§alÄ±ÅŸÄ±r. Bu bÃ¶lÃ¼mler, Son Giren Ä°lk Ã‡Ä±kar (LIFO) yaklaÅŸÄ±mÄ±nÄ± kullanÄ±r, yani **en son serbest bÄ±rakÄ±lan parÃ§a, yeni bir tahsis isteÄŸi olduÄŸunda ilk olarak yeniden kullanÄ±lÄ±r**. Bu davranÄ±ÅŸ hÄ±z iÃ§in avantajlÄ±dÄ±r, Ã§Ã¼nkÃ¼ bir yÄ±ÄŸÄ±nÄ±n Ã¼stÃ¼nden (LIFO) ekleme ve Ã§Ä±karma yapmak, bir kuyruktan (FIFO) ekleme ve Ã§Ä±karmaya gÃ¶re daha hÄ±zlÄ±dÄ±r.

AyrÄ±ca, **hÄ±zlÄ± bÃ¶lÃ¼mler tek yÃ¶nlÃ¼ baÄŸlÄ± listeleri kullanÄ±r**, Ã§ift yÃ¶nlÃ¼ deÄŸil, bu da hÄ±zÄ± daha da artÄ±rÄ±r. HÄ±zlÄ± bÃ¶lÃ¼mlerde parÃ§alar komÅŸularÄ±yla birleÅŸtirilmediÄŸi iÃ§in, ortadan kaldÄ±rma izni veren karmaÅŸÄ±k bir yapÄ±ya ihtiyaÃ§ yoktur. Tek yÃ¶nlÃ¼ bir liste, bu iÅŸlemler iÃ§in daha basit ve daha hÄ±zlÄ±dÄ±r.

Temelde burada olan ÅŸey, baÅŸlÄ±k (kontrol edilecek ilk parÃ§aya iÅŸaret eden iÅŸaretÃ§i) her zaman o boyuttaki en son serbest bÄ±rakÄ±lan parÃ§aya iÅŸaret eder. DolayÄ±sÄ±yla:

* Bu boyutta yeni bir parÃ§a tahsis edildiÄŸinde, baÅŸlÄ±k kullanÄ±lacak bir boÅŸ parÃ§aya iÅŸaret eder. Bu boÅŸ parÃ§a, kullanÄ±lacak bir sonraki parÃ§aya iÅŸaret ettiÄŸi iÃ§in, bu adres baÅŸlÄ±kta saklanÄ±r, bÃ¶ylece bir sonraki tahsis nereden uygun bir parÃ§a alacaÄŸÄ±nÄ± bilir
* Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, boÅŸ parÃ§a, mevcut uygun parÃ§anÄ±n adresini kaydeder ve bu yeni serbest bÄ±rakÄ±lan parÃ§anÄ±n adresi baÅŸlÄ±ÄŸa konur

BaÄŸlÄ± liste maksimum boyutu `0x80` ve bir `0x20` boyutundaki parÃ§a `0` indekste olacak ÅŸekilde dÃ¼zenlenir.

{% hint style="danger" %}
HÄ±zlÄ± bÃ¶lÃ¼mlerdeki parÃ§alar uygun olarak ayarlanmadÄ±ÄŸÄ±ndan, etraflarÄ±ndaki diÄŸer serbest parÃ§alarla birleÅŸtirilebilme yeteneÄŸi yerine bir sÃ¼re hÄ±zlÄ± bÃ¶lÃ¼m parÃ§alarÄ± olarak tutulurlar.
{% endhint %}
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Fastbins

An array of lists holding recently freed small chunks.  Fastbins
are not doubly linked.  It is faster to single-link them, and
since chunks are never removed from the middles of these lists,
double linking is not necessary. Also, unlike regular bins, they
are not even processed in FIFO order (they use faster LIFO) since
ordering doesn't much matter in the transient contexts in which
fastbins are normally used.

Chunks in fastbins keep their inuse bit set, so they cannot
be consolidated with other free chunks. malloc_consolidate
releases all chunks in fastbins and consolidates them with
other free chunks.
*/

typedef struct malloc_chunk *mfastbinptr;
#define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz) \
((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)


/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)

#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)
```
<detaylar>

<Ã¶zet> HÄ±zlÄ± bin parÃ§a Ã¶rneÄŸi ekle </Ã¶zet>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[8];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 8; i++) {
chunks[i] = malloc(24);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
Not allokasyon ve serbest bÄ±rakma iÅŸlemlerini aynÄ± boyutta 8 parÃ§a iÃ§in nasÄ±l yaptÄ±ÄŸÄ±mÄ±za dikkat edin, bÃ¶ylece tcache'i doldurSiz de `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile derleyin ve hata ayÄ±klama yapÄ±n. Sonra `gef` ile tcache bin'in dolu olduÄŸunu ve bir parÃ§anÄ±n hÄ±zlÄ± binde olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=7] â†  Chunk(addr=0xaaaaaaac1770, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1750, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1730, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1710, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16f0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16d0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20]  â†  Chunk(addr=0xaaaaaaac1790, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
Fastbins[idx=1, size=0x30] 0x00
```
</details>

### SÄ±ralanmamÄ±ÅŸ kova

SÄ±ralanmamÄ±ÅŸ kova, bellek tahsisini hÄ±zlandÄ±rmak iÃ§in kullanÄ±lan bir **Ã¶nbellek**tir. Ä°ÅŸte nasÄ±l Ã§alÄ±ÅŸÄ±r: Bir program bir parÃ§ayÄ± serbest bÄ±raktÄ±ÄŸÄ±nda ve bu parÃ§a bir tcache veya hÄ±zlÄ± kova iÃ§inde tahsis edilemiyorsa ve Ã¼st parÃ§ayla Ã§akÄ±ÅŸmÄ±yorsa, bellek yÃ¶neticisi hemen onu belirli bir kÃ¼Ã§Ã¼k veya bÃ¼yÃ¼k kovaya koymaz. Bunun yerine, Ã¶nce **yanÄ±ndaki diÄŸer boÅŸ parÃ§alarla birleÅŸtirmeye** Ã§alÄ±ÅŸarak daha bÃ¼yÃ¼k bir boÅŸ bellek bloÄŸu oluÅŸturur. Daha sonra, bu yeni parÃ§ayÄ± "sÄ±ralanmamÄ±ÅŸ kova" olarak adlandÄ±rÄ±lan genel bir kovaya yerleÅŸtirir.

Bir program **bellek istediÄŸinde**, bellek yÃ¶neticisi **sÄ±ralanmamÄ±ÅŸ kovayÄ± kontrol eder** ve yeterli boyutta bir parÃ§a bulunup bulunmadÄ±ÄŸÄ±nÄ± kontrol eder. Bir tane bulursa, hemen kullanÄ±r. SÄ±ralanmamÄ±ÅŸ kovada uygun bir parÃ§a bulamazsa, bu listedeki tÃ¼m parÃ§alarÄ± boyutlarÄ±na baÄŸlÄ± olarak kÃ¼Ã§Ã¼k veya bÃ¼yÃ¼k kovalarÄ±na taÅŸÄ±r.

Dikkat edin, daha bÃ¼yÃ¼k bir parÃ§a ikiye bÃ¶lÃ¼nÃ¼rse ve geriye kalan kÄ±sÄ±m MINSIZE'dan bÃ¼yÃ¼kse, tekrar sÄ±ralanmamÄ±ÅŸ kovaya yerleÅŸtirilecektir.

Bu nedenle, sÄ±ralanmamÄ±ÅŸ kova, son zamanlarda serbest bÄ±rakÄ±lan belleÄŸi hÄ±zlÄ± bir ÅŸekilde yeniden kullanarak bellek tahsisini hÄ±zlandÄ±rmak ve zaman alÄ±cÄ± aramalarÄ± ve birleÅŸtirmeleri azaltmak iÃ§in bir yÃ¶ntemdir.

{% hint style="danger" %}
FarklÄ± kategorilerden parÃ§alar olsalar bile, mevcut bir parÃ§a baÅŸka bir mevcut parÃ§ayla Ã§akÄ±ÅŸÄ±yorsa (baÅŸlangÄ±Ã§ta farklÄ± kovalara ait olsalar bile), birleÅŸtirileceklerdir.
{% endhint %}

<details>

<summary>Bir sÄ±ralanmamÄ±ÅŸ parÃ§a Ã¶rneÄŸi ekleyin</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[9];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
Not allokasyon ve serbest bÄ±rakma iÅŸlemlerini 9 aynÄ± boyutta parÃ§a iÃ§in nasÄ±l yaptÄ±ÄŸÄ±mÄ±za dikkat edin, bÃ¶ylece **tcache'i doldururlar** ve sekizincisi **fastbin iÃ§in Ã§ok bÃ¼yÃ¼k olduÄŸu iÃ§in** sÄ±ralanmamÄ±ÅŸ binde depolanÄ±r ve dokuzuncusu serbest bÄ±rakÄ±lmaz, bu yÃ¼zden dokuzuncu ve sekizinci **Ã¼st parÃ§a ile birleÅŸtirilmez**.

Bunu derleyin ve `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile hata ayÄ±klamayÄ± yapÄ±n. Sonra `gef` ile tcache bininin dolu olduÄŸunu ve bir parÃ§anÄ±n sÄ±ralanmamÄ±ÅŸ binde olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] unsorted_bins[0]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in unsorted bin.
```
</details>

### KÃ¼Ã§Ã¼k Bins

KÃ¼Ã§Ã¼k binalar bÃ¼yÃ¼k binalardan daha hÄ±zlÄ±dÄ±r ancak hÄ±zlÄ± binalardan daha yavaÅŸtÄ±r.

62'nin her bir kutusu aynÄ± boyutta **parÃ§alara** sahip olacaktÄ±r: 16, 24, ... (32 bitlerde maksimum 504 bayt ve 64 bitlerde 1024). Bu, bir boÅŸluÄŸun tahsis edilmesi gereken binin bulunmasÄ±nda, bu listelerdeki giriÅŸlerin eklenmesi ve Ã§Ä±karÄ±lmasÄ±nda hÄ±z saÄŸlar.

KÃ¼Ã§Ã¼k binin boyutu, binin indeksine gÃ¶re nasÄ±l hesaplandÄ±ÄŸÄ± ÅŸÃ¶yledir:

* En kÃ¼Ã§Ã¼k boyut: 2\*4\*indeks (Ã¶rneÄŸin, indeks 5 -> 40)
* En bÃ¼yÃ¼k boyut: 2\*8\*indeks (Ã¶rneÄŸin, indeks 5 -> 80)
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)

#define in_smallbin_range(sz)  \
((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)

#define smallbin_index(sz) \
((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
+ SMALLBIN_CORRECTION)
```
KÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k kutular arasÄ±nda seÃ§im yapmak iÃ§in iÅŸlev:
```c
#define bin_index(sz) \
((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
```
<detaylar>

<Ã¶zet>KÃ¼Ã§Ã¼k bir parÃ§a Ã¶rneÄŸi ekle</Ã¶zet>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[10];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

chunks[9] = malloc(0x110);

return 0;
}
```
Not allokasyon ve serbest bÄ±rakma iÅŸlemlerini 9 aynÄ± boyutta parÃ§a iÃ§in nasÄ±l yaptÄ±ÄŸÄ±mÄ±za dikkat edin, bÃ¶ylece **tcache'i doldururlar** ve sekizincisi **fastbin iÃ§in Ã§ok bÃ¼yÃ¼k olduÄŸu iÃ§in** sÄ±ralanmamÄ±ÅŸ binde depolanÄ±r ve dokuzuncusu serbest bÄ±rakÄ±lmaz, bu yÃ¼zden dokuzuncu ve sekizinci **Ã¼st parÃ§a ile birleÅŸtirilmez**. Daha sonra 0x110 boyutunda daha bÃ¼yÃ¼k bir parÃ§a tahsis ederiz, bu da **sÄ±ralanmamÄ±ÅŸ bindeki parÃ§anÄ±n kÃ¼Ã§Ã¼k bine gitmesine neden olur**.

Bunu derleyin ve `main` fonksiyonundaki `ret` opcode'unda bir kesme noktasÄ± ile hata ayÄ±klamayÄ± baÅŸlatÄ±n. Sonra `gef` ile tcache bininin dolu olduÄŸunu ve bir parÃ§anÄ±n kÃ¼Ã§Ã¼k binde olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] small_bins[16]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 small non-empty bins.
```
### BÃ¼yÃ¼k kovalar

KÃ¼Ã§Ã¼k kovalarÄ±n aksine, her **bÃ¼yÃ¼k kova bir aralÄ±ÄŸÄ± yÃ¶netir**. Bu daha esnek bir yapÄ±ya sahiptir, Ã§eÅŸitli boyutlarÄ± **ayrÄ± bir kova oluÅŸturmadan** barÄ±ndÄ±rabilmesine olanak tanÄ±r.

Bir bellek tahsis edici iÃ§inde bÃ¼yÃ¼k kovalar, kÃ¼Ã§Ã¼k kovalarÄ±n bittiÄŸi yerden baÅŸlar. BÃ¼yÃ¼k kovalar iÃ§in aralÄ±klar giderek bÃ¼yÃ¼r, yani ilk kova 512 ile 576 bayt arasÄ±ndaki parÃ§alarÄ± kapsayabilirken, bir sonraki kova 576 ile 640 bayt arasÄ±ndakileri kapsar. Bu desen devam eder ve en bÃ¼yÃ¼k kova 1MB'nin Ã¼zerindeki tÃ¼m parÃ§alarÄ± iÃ§erir.

BÃ¼yÃ¼k kovalar, bir tahsis iÃ§in **en iyi uyumu bulmak iÃ§in deÄŸiÅŸen parÃ§a boyutlarÄ±nÄ±n listesini sÄ±ralamak ve aramak zorunda olduklarÄ±ndan kÃ¼Ã§Ã¼k kovalara gÃ¶re daha yavaÅŸ Ã§alÄ±ÅŸÄ±rlar**. Bir parÃ§a bÃ¼yÃ¼k bir kovaya eklendiÄŸinde sÄ±ralanmalÄ± ve bellek tahsis edildiÄŸinde sistem doÄŸru parÃ§ayÄ± bulmalÄ±dÄ±r. Bu ekstra iÅŸ onlarÄ± **daha yavaÅŸ** yapar, ancak bÃ¼yÃ¼k tahsisler kÃ¼Ã§Ã¼k olanlardan daha az yaygÄ±n olduÄŸundan, bu kabul edilebilir bir takastÄ±r.

Åunlar vardÄ±r:

* 64B aralÄ±ÄŸÄ±nda 32 kova (kÃ¼Ã§Ã¼k kovalarla Ã§akÄ±ÅŸÄ±r)
* 512B aralÄ±ÄŸÄ±nda 16 kova (kÃ¼Ã§Ã¼k kovalarla Ã§akÄ±ÅŸÄ±r)
* 4096B aralÄ±ÄŸÄ±nda 8 kova (kÄ±smen kÃ¼Ã§Ã¼k kovalarla Ã§akÄ±ÅŸÄ±r)
* 32768B aralÄ±ÄŸÄ±nda 4 kova
* 262144B aralÄ±ÄŸÄ±nda 2 kova
* Geri kalan boyutlar iÃ§in 1 kova

<details>

<summary>BÃ¼yÃ¼k kova boyutlarÄ± kodu</summary>
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

#define largebin_index_32(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 38) ?  56 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index_32_big(sz)                                            \
(((((unsigned long) (sz)) >> 6) <= 45) ?  49 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index(sz) \
(SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
: MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
: largebin_index_32 (sz))
```
</details>

<details>

<summary>BÃ¼yÃ¼k bir parÃ§a Ã¶rneÄŸi ekle</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[2];

chunks[0] = malloc(0x1500);
chunks[1] = malloc(0x1500);
free(chunks[0]);
chunks[0] = malloc(0x2000);

return 0;
}
```
2 bÃ¼yÃ¼k tahsisat yapÄ±lÄ±r, ardÄ±ndan biri serbest bÄ±rakÄ±lÄ±r (bu, sÄ±rasÄ±z kutuya yerleÅŸtirilir) ve daha bÃ¼yÃ¼k bir tahsisat yapÄ±lÄ±r (serbest bÄ±rakÄ±lanÄ± sÄ±rasÄ±z kutudan bÃ¼yÃ¼k kutuya taÅŸÄ±r).

Bunu derleyin ve `main` fonksiyonundaki `ret` iÅŸlem kodunda bir kesme noktasÄ± ile hata ayÄ±klamayÄ± yapÄ±n. ArdÄ±ndan `gef` ile tcache kutusunun dolu olduÄŸunu ve bir parÃ§anÄ±n bÃ¼yÃ¼k kutuda olduÄŸunu gÃ¶rebilirsiniz:
```bash
gefâ¤  heap bin
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
All tcachebins are empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in 0 small non-empty bins.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Large Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] large_bins[100]: fw=0xaaaaaaac1290, bk=0xaaaaaaac1290
â†’   Chunk(addr=0xaaaaaaac12a0, size=0x1510, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 large non-empty bins.
```
</details>

### En Ãœst ParÃ§a
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Top

The top-most available chunk (i.e., the one bordering the end of
available memory) is treated specially. It is never included in
any bin, is used only if no other chunk is available, and is
released back to the system if it is very large (see
M_TRIM_THRESHOLD).  Because top initially
points to its own bin with initial zero size, thus forcing
extension on the first malloc request, we avoid having any special
code in malloc to check whether it even exists yet. But we still
need to do so when getting memory from system, so we make
initial_top treat the bin as a legal but unusable chunk during the
interval between initialization and the first call to
sysmalloc. (This is somewhat delicate, since it relies on
the 2 preceding words to be zero during this interval as well.)
*/

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks (M))
```
Temelde, bu ÅŸu anda mevcut olan heap'i iÃ§eren bir parÃ§adÄ±r. Bir malloc iÅŸlemi gerÃ§ekleÅŸtirildiÄŸinde, kullanÄ±lacak boÅŸ bir parÃ§a yoksa, bu Ã¼st parÃ§a gerekli alanÄ± vermek iÃ§in boyutunu azaltacaktÄ±r. Top ParÃ§a'nÄ±n iÅŸaretÃ§isi `malloc_state` yapÄ±sÄ±nda saklanÄ±r.

AyrÄ±ca, baÅŸlangÄ±Ã§ta, sÄ±rasÄ±z parÃ§ayÄ± Ã¼st parÃ§a olarak kullanmak mÃ¼mkÃ¼ndÃ¼r.

<details>

<summary>Ãœst ParÃ§a Ã¶rneÄŸini gÃ¶zlemleyin</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
return 0;
}
```
Derleyip hata ayÄ±kladÄ±ktan sonra `main`'in `ret` iÅŸlem kodundaki kesme noktasÄ±yla hata ayÄ±kladÄ±m ve malloc'un `0xaaaaaaac12a0` adresini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ gÃ¶rdÃ¼m ve bunlar parÃ§alar:
```bash
gefâ¤  heap chunks
Chunk(addr=0xaaaaaaac1010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac1010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12a0     41 41 41 41 41 41 41 00 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac12c0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12c0     41 64 64 72 65 73 73 20 6f 66 20 74 68 65 20 63    Address of the c]
Chunk(addr=0xaaaaaaac16d0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac16d0     41 41 41 41 41 41 41 0a 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac1ae0, size=0x20530, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  top chunk
```
Top chunk'Ä±n `0xaaaaaaac1ae0` adresinde olduÄŸu gÃ¶rÃ¼lebilir. Bu, son tahsis edilen parÃ§anÄ±n `0xaaaaaaac12a0` adresinde ve `0x410` boyutunda olduÄŸu iÃ§in ÅŸaÅŸÄ±rtÄ±cÄ± deÄŸil ve `0xaaaaaaac12a0 + 0x410 = 0xaaaaaaac1ae0` olur.\
AyrÄ±ca, Top chunk'Ä±n boyutunu chunk baÅŸlÄ±ÄŸÄ±nda gÃ¶rmek de mÃ¼mkÃ¼ndÃ¼r:
```bash
gefâ¤  x/8wx 0xaaaaaaac1ae0 - 16
0xaaaaaaac1ad0:	0x00000000	0x00000000	0x00020531	0x00000000
0xaaaaaaac1ae0:	0x00000000	0x00000000	0x00000000	0x00000000
```
</details>

### Son Kalan ParÃ§a

`malloc` kullanÄ±ldÄ±ÄŸÄ±nda ve bir parÃ§a bÃ¶lÃ¼ndÃ¼ÄŸÃ¼nde (Ã¶rneÄŸin sÄ±ralanmamÄ±ÅŸ bin veya Ã¼st parÃ§adan), bÃ¶lÃ¼nmÃ¼ÅŸ parÃ§anÄ±n geri kalanÄ±ndan oluÅŸturulan parÃ§aya Son Kalan ParÃ§a denir ve iÅŸaretÃ§isi `malloc_state` yapÄ±sÄ±nda saklanÄ±r.

## Tahsis AkÄ±ÅŸÄ±

Åuna gÃ¶z atÄ±n:

{% content-ref url="heap-memory-functions/malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](heap-memory-functions/malloc-and-sysmalloc.md)
{% endcontent-ref %}

## Serbest BÄ±rakma AkÄ±ÅŸÄ±

Åuna gÃ¶z atÄ±n:

{% content-ref url="heap-memory-functions/free.md" %}
[free.md](heap-memory-functions/free.md)
{% endcontent-ref %}

## YÄ±ÄŸÄ±n FonksiyonlarÄ± GÃ¼venlik Kontrolleri

YÄ±ÄŸÄ±n iÃ§inde sÄ±kÃ§a kullanÄ±lan fonksiyonlar tarafÄ±ndan gerÃ§ekleÅŸtirilen gÃ¼venlik kontrollerini kontrol edin:

{% content-ref url="heap-memory-functions/heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-memory-functions/heap-functions-security-checks.md)
{% endcontent-ref %}

## Referanslar

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahraman seviyesine Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **ğŸ’¬ [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katÄ±lÄ±n veya** bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'Ä± takip edin.
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>
