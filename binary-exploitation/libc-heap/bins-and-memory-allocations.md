# Bins & Alokacje PamiÄ™ci

{% hint style="success" %}
Dowiedz siÄ™ i Ä‡wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz siÄ™ i Ä‡wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
{% endhint %}

## Podstawowe Informacje

Aby poprawiÄ‡ efektywnoÅ›Ä‡ przechowywania kawaÅ‚kÃ³w, kaÅ¼dy kawaÅ‚ek nie jest przechowywany tylko w jednym zwiÄ…zku, ale istnieje kilka rodzajÃ³w. SÄ… to zbiory, a istnieje 5 rodzajÃ³w zbiorÃ³w: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) maÅ‚ych zbiorÃ³w, 63 duÅ¼ych zbiorÃ³w, 1 nieuporzÄ…dkowany zbiÃ³r, 10 szybkich zbiorÃ³w i 64 tcache bins na wÄ…tek.

PoczÄ…tkowy adres do kaÅ¼dego nieuporzÄ…dkowanego, maÅ‚ego i duÅ¼ego zbioru znajduje siÄ™ w tym samym tablicy. Indeks 0 jest nieuÅ¼ywany, 1 to zbiÃ³r nieuporzÄ…dkowany, zbiory 2-64 to maÅ‚e zbiory, a zbiory 65-127 to duÅ¼e zbiory.

### Zbiory Tcache (Bufor na WÄ…tek)

Mimo Å¼e wÄ…tki starajÄ… siÄ™ mieÄ‡ wÅ‚asny sterta (patrz [Areny](bins-and-memory-allocations.md#arenas) i [Podsterty](bins-and-memory-allocations.md#subheaps)), istnieje moÅ¼liwoÅ›Ä‡, Å¼e proces z wieloma wÄ…tkami (np. serwer internetowy) **bÄ™dzie dzieliÅ‚ stertÄ™ z innymi wÄ…tkami**. W takim przypadku gÅ‚Ã³wnym rozwiÄ…zaniem jest uÅ¼ycie **blokad**, ktÃ³re mogÄ… **znaczÄ…co spowolniÄ‡ wÄ…tki**.

Dlatego tcache jest podobny do szybkiego zbioru na wÄ…tek w taki sposÃ³b, Å¼e jest to **jednokierunkowa lista**, ktÃ³ra nie Å‚Ä…czy kawaÅ‚kÃ³w. KaÅ¼dy wÄ…tek ma **64 jednokierunkowe tcache bins**. KaÅ¼dy zbiÃ³r moÅ¼e zawieraÄ‡ maksymalnie [7 kawaÅ‚kÃ³w tego samego rozmiaru](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) o rozmiarze [24 do 1032B na systemach 64-bitowych i 12 do 516B na systemach 32-bitowych](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

Gdy wÄ…tek zwalnia kawaÅ‚ek, jeÅ›li nie jest zbyt duÅ¼y, aby byÄ‡ przydzielony do tcache, a odpowiedni zbiÃ³r tcache **nie jest peÅ‚ny** (juÅ¼ 7 kawaÅ‚kÃ³w), **zostanie tam przydzielony**. JeÅ›li nie moÅ¼e trafiÄ‡ do tcache, bÄ™dzie musiaÅ‚ poczekaÄ‡ na blokadÄ™ sterty, aby mÃ³c wykonaÄ‡ operacjÄ™ zwolnienia globalnie.

Gdy **kawaÅ‚ek jest przydzielany**, jeÅ›li istnieje wolny kawaÅ‚ek potrzebnego rozmiaru w **Tcache, zostanie on uÅ¼yty**, jeÅ›li nie, bÄ™dzie musiaÅ‚ poczekaÄ‡ na blokadÄ™ sterty, aby znaleÅºÄ‡ go w globalnych zbiorach lub utworzyÄ‡ nowy.\
Istnieje takÅ¼e optymalizacja, w tym przypadku, podczas posiadania blokady sterty, wÄ…tek **wypeÅ‚ni swoje Tcache kawaÅ‚kami sterty (7) o Å¼Ä…danym rozmiarze**, wiÄ™c w przypadku potrzeby wiÄ™cej, znajdzie je w Tcache.

<details>

<summary>PrzykÅ‚ad dodania kawaÅ‚ka do tcache</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
free(chunk);
return 0;
}
```
Skompiluj to i debuguj z punktem przerwania w opcode ret z funkcji main. NastÄ™pnie za pomocÄ… gef moÅ¼esz zobaczyÄ‡ uÅ¼ywany tcache bin:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=1] â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
```
#### Struktury i funkcje Tcache

W poniÅ¼szym kodzie moÅ¼na zobaczyÄ‡ **maksymalne pojemniki** i **kawaÅ‚ki na indeks**, strukturÄ™ **`tcache_entry`** stworzonÄ… w celu unikniÄ™cia podwÃ³jnych zwolnieÅ„ oraz **`tcache_perthread_struct`**, strukturÄ™, ktÃ³rÄ… kaÅ¼dy wÄ…tek uÅ¼ywa do przechowywania adresÃ³w do kaÅ¼dego indeksu pojemnika.
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c

/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */
# define TCACHE_MAX_BINS		64
# define MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)

/* Only used to pre-fill the tunables.  */
# define tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)

/* When "x" is from chunksize().  */
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
/* When "x" is a user-provided size.  */
# define usize2tidx(x) csize2tidx (request2size (x))

/* With rounding and alignment, the bins are...
idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
idx 1   bytes 25..40 or 13..20
idx 2   bytes 41..56 or 21..28
etc.  */

/* This is another arbitrary limit, which tunables can change.  Each
tcache bin will hold at most this number of chunks.  */
# define TCACHE_FILL_COUNT 7

/* Maximum chunks in tcache bins for tunables.  This value must fit the range
of tcache->counts[] entries, else they may overflow.  */
# define MAX_TCACHE_COUNT UINT16_MAX

[...]

typedef struct tcache_entry
{
struct tcache_entry *next;
/* This field exists to detect double frees.  */
uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
per-thread cache (hence "tcache_perthread_struct").  Keeping
overall size low is mildly important.  Note that COUNTS and ENTRIES
are redundant (we could have just counted the linked list each
time), this is for performance reasons.  */
typedef struct tcache_perthread_struct
{
uint16_t counts[TCACHE_MAX_BINS];
tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
</details>

Funkcja `__tcache_init` to funkcja, ktÃ³ra tworzy i alokuje miejsce dla obiektu `tcache_perthread_struct`

<details>

<summary>kod tcache_init</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3241C1-L3274C2

static void
tcache_init(void)
{
mstate ar_ptr;
void *victim = 0;
const size_t bytes = sizeof (tcache_perthread_struct);

if (tcache_shutting_down)
return;

arena_get (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
if (!victim && ar_ptr != NULL)
{
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}


if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);

/* In a low memory situation, we may not be able to allocate memory
- in which case, we just keep trying later.  However, we
typically do this very early, so either there is sufficient
memory, or there isn't enough memory to do non-trivial
allocations anyway.  */
if (victim)
{
tcache = (tcache_perthread_struct *) victim;
memset (tcache, 0, sizeof (tcache_perthread_struct));
}

}
```
</details>

#### Indeksy Tcache

Tcache ma kilka kubeÅ‚kÃ³w w zaleÅ¼noÅ›ci od rozmiaru, a poczÄ…tkowe wskaÅºniki do **pierwszego fragmentu kaÅ¼dego indeksu oraz iloÅ›Ä‡ fragmentÃ³w na indeks znajdujÄ… siÄ™ wewnÄ…trz fragmentu**. Oznacza to, Å¼e zlokalizowanie fragmentu z tÄ… informacjÄ… (zazwyczaj pierwszego) pozwala znaleÅºÄ‡ wszystkie poczÄ…tkowe punkty tcache i iloÅ›Ä‡ fragmentÃ³w Tcache.

### Szybkie kubeÅ‚ki

Szybkie kubeÅ‚ki sÄ… zaprojektowane, aby **przyspieszyÄ‡ alokacjÄ™ pamiÄ™ci dla maÅ‚ych fragmentÃ³w**, trzymajÄ…c niedawno zwolnione fragmenty w strukturze szybkiego dostÄ™pu. Te kubeÅ‚ki korzystajÄ… z podejÅ›cia Last-In, First-Out (LIFO), co oznacza, Å¼e **najbardziej niedawno zwolniony fragment jest pierwszy**, ktÃ³ry bÄ™dzie ponownie uÅ¼ywany, gdy pojawi siÄ™ nowe Å¼Ä…danie alokacji. To zachowanie jest korzystne dla szybkoÅ›ci, poniewaÅ¼ szybciej jest wstawiaÄ‡ i usuwaÄ‡ z gÃ³ry stosu (LIFO) w porÃ³wnaniu do kolejki (FIFO).

Dodatkowo, **szybkie kubeÅ‚ki uÅ¼ywajÄ… list jednokierunkowych**, a nie dwukierunkowych, co dodatkowo poprawia szybkoÅ›Ä‡. PoniewaÅ¼ fragmenty w szybkich kubeÅ‚kach nie sÄ… Å‚Ä…czone z sÄ…siadujÄ…cymi, nie ma potrzeby skomplikowanej struktury, ktÃ³ra pozwala na usuwanie z Å›rodka. Lista jednokierunkowa jest prostsza i szybsza dla tych operacji.

W zasadzie, to co siÄ™ tutaj dzieje, to Å¼e nagÅ‚Ã³wek (wskaÅºnik do pierwszego fragmentu do sprawdzenia) zawsze wskazuje na najnowszy zwolniony fragment tego rozmiaru. WiÄ™c:

* Gdy alokowany jest nowy fragment tego rozmiaru, nagÅ‚Ã³wek wskazuje na wolny fragment do uÅ¼ycia. PoniewaÅ¼ ten wolny fragment wskazuje na nastÄ™pny do uÅ¼ycia, ten adres jest przechowywany w nagÅ‚Ã³wku, aby nastÄ™pna alokacja wiedziaÅ‚a, gdzie znaleÅºÄ‡ dostÄ™pny fragment
* Gdy fragment jest zwalniany, wolny fragment zapisze adres do aktualnie dostÄ™pnego fragmentu, a adres tego nowo zwolnionego fragmentu zostanie umieszczony w nagÅ‚Ã³wku

Maksymalny rozmiar listy jednokierunkowej to `0x80`, a sÄ… one zorganizowane tak, Å¼e fragment o rozmiarze `0x20` bÄ™dzie w indeksie `0`, fragment o rozmiarze `0x30` bÄ™dzie w indeksie `1`...

{% hint style="danger" %}
Fragmenty w szybkich kubeÅ‚kach nie sÄ… ustawione jako dostÄ™pne, wiÄ™c sÄ… trzymane jako fragmenty szybkich kubeÅ‚kÃ³w przez jakiÅ› czas zamiast mÃ³c Å‚Ä…czyÄ‡ siÄ™ z innymi wolnymi fragmentami otaczajÄ…cymi je.
{% endhint %}
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Fastbins

An array of lists holding recently freed small chunks.  Fastbins
are not doubly linked.  It is faster to single-link them, and
since chunks are never removed from the middles of these lists,
double linking is not necessary. Also, unlike regular bins, they
are not even processed in FIFO order (they use faster LIFO) since
ordering doesn't much matter in the transient contexts in which
fastbins are normally used.

Chunks in fastbins keep their inuse bit set, so they cannot
be consolidated with other free chunks. malloc_consolidate
releases all chunks in fastbins and consolidates them with
other free chunks.
*/

typedef struct malloc_chunk *mfastbinptr;
#define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz) \
((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)


/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)

#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)
```
<details>

<summary>Dodaj przykÅ‚ad kawaÅ‚ka fastbin</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[8];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 8; i++) {
chunks[i] = malloc(24);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
ZauwaÅ¼, jak alokujemy i zwalniamy 8 fragmentÃ³w tego samego rozmiaru, aby wypeÅ‚niÄ‡ tcache, a Ã³smy jest przechowywany w szybkim fragmencie.

Skompiluj to i debuguj z punktem przerwania w operacji `ret` z funkcji `main`. NastÄ™pnie za pomocÄ… `gef` moÅ¼esz zobaczyÄ‡, Å¼e pojemnik tcache jest peÅ‚ny, a jeden fragment znajduje siÄ™ w szybkim pojemniku:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=0, size=0x20, count=7] â†  Chunk(addr=0xaaaaaaac1770, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1750, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1730, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1710, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16f0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac16d0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20]  â†  Chunk(addr=0xaaaaaaac1790, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
Fastbins[idx=1, size=0x30] 0x00
```
</details>

### Nieposortowany blok

Nieposortowany blok to **pamiÄ™Ä‡ podrÄ™czna** uÅ¼ywana przez menedÅ¼era sterty do przyspieszenia alokacji pamiÄ™ci. Oto jak to dziaÅ‚a: Gdy program zwalnia kawaÅ‚ek pamiÄ™ci, i jeÅ›li ten kawaÅ‚ek nie moÅ¼e byÄ‡ zaalokowany w tcache lub fast bin i nie koliduje z kawaÅ‚kiem najwyÅ¼szej sterty, menedÅ¼er sterty nie umieszcza go od razu w okreÅ›lonym maÅ‚ym lub duÅ¼ym pojemniku. Zamiast tego najpierw prÃ³buje **poÅ‚Ä…czyÄ‡ go z sÄ…siednimi wolnymi kawaÅ‚kami**, aby utworzyÄ‡ wiÄ™kszy blok wolnej pamiÄ™ci. NastÄ™pnie umieszcza ten nowy kawaÅ‚ek w ogÃ³lnym pojemniku o nazwie "nieposortowany blok".

Gdy program **prosi o pamiÄ™Ä‡**, menedÅ¼er sterty **sprawdza nieposortowany blok**, aby zobaczyÄ‡, czy jest tam kawaÅ‚ek wystarczajÄ…cej wielkoÅ›ci. JeÅ›li znajdzie taki, od razu go uÅ¼ywa. JeÅ›li nie znajdzie odpowiedniego kawaÅ‚ka w nieposortowanym bloku, przenosi wszystkie kawaÅ‚ki z tej listy do odpowiadajÄ…cych im pojemnikÃ³w, maÅ‚ych lub duÅ¼ych, w zaleÅ¼noÅ›ci od ich wielkoÅ›ci.

NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e jeÅ›li wiÄ™kszy kawaÅ‚ek jest podzielony na 2 poÅ‚owy i reszta jest wiÄ™ksza niÅ¼ MINSIZE, zostanie on ponownie umieszczony w nieposortowanym bloku.

Tak wiÄ™c nieposortowany blok jest sposobem na przyspieszenie alokacji pamiÄ™ci poprzez szybkie ponowne wykorzystanie niedawno zwolnionej pamiÄ™ci i zmniejszenie potrzeby czasochÅ‚onnych wyszukiwaÅ„ i Å‚Ä…czeÅ„.

{% hint style="danger" %}
NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e nawet jeÅ›li kawaÅ‚ki naleÅ¼Ä… do rÃ³Å¼nych kategorii, jeÅ›li dostÄ™pny kawaÅ‚ek koliduje z innym dostÄ™pnym kawaÅ‚kiem (nawet jeÅ›li poczÄ…tkowo naleÅ¼Ä… do rÃ³Å¼nych pojemnikÃ³w), zostanÄ… one poÅ‚Ä…czone.
{% endhint %}

<details>

<summary>Dodaj przykÅ‚ad nieposortowanego kawaÅ‚ka</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[9];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

return 0;
}
```
ZauwaÅ¼, jak alokujemy i zwalniamy 9 blokÃ³w tego samego rozmiaru, aby **wypeÅ‚niÄ‡ tcache**, a Ã³smy jest przechowywany w nieuporzÄ…dkowanym bloku, poniewaÅ¼ jest **za duÅ¼y dla fastbin**, a dziewiÄ…ty nie jest zwolniony, wiÄ™c dziewiÄ…ty i Ã³smy **nie sÄ… scalane z gÅ‚Ã³wnym blokiem**.

Skompiluj to i debuguj z punktem przerwania w operacji `ret` z funkcji `main`. NastÄ™pnie za pomocÄ… `gef` moÅ¼esz zobaczyÄ‡, Å¼e blok tcache jest peÅ‚ny, a jeden blok znajduje siÄ™ w nieuporzÄ…dkowanym bloku:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] unsorted_bins[0]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in unsorted bin.
```
</details>

### MaÅ‚e pojemniki

MaÅ‚e pojemniki sÄ… szybsze niÅ¼ duÅ¼e pojemniki, ale wolniejsze niÅ¼ szybkie pojemniki.

KaÅ¼dy z 62 pojemnikÃ³w bÄ™dzie zawieraÅ‚ **kawaÅ‚ki tej samej wielkoÅ›ci**: 16, 24, ... (z maksymalnÄ… wielkoÅ›ciÄ… 504 bajtÃ³w w 32 bitach i 1024 w 64 bitach). Pomaga to w szybkoÅ›ci znajdowania pojemnika, w ktÃ³rym powinno byÄ‡ zaalokowane miejsce oraz w wstawianiu i usuwaniu wpisÃ³w na tych listach.

Tak jest obliczana wielkoÅ›Ä‡ maÅ‚ego pojemnika zgodnie z indeksem pojemnika:

* Najmniejsza wielkoÅ›Ä‡: 2\*4\*indeks (np. indeks 5 -> 40)
* NajwiÄ™ksza wielkoÅ›Ä‡: 2\*8\*indeks (np. indeks 5 -> 80)
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)

#define in_smallbin_range(sz)  \
((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)

#define smallbin_index(sz) \
((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
+ SMALLBIN_CORRECTION)
```
Funkcja do wyboru miÄ™dzy maÅ‚ymi a duÅ¼ymi kubeÅ‚kami:
```c
#define bin_index(sz) \
((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
```
<szczegÃ³Å‚y>

<summary>Dodaj przykÅ‚ad maÅ‚ego kawaÅ‚ka</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[10];
int i;

// Loop to allocate memory 8 times
for (i = 0; i < 9; i++) {
chunks[i] = malloc(0x100);
if (chunks[i] == NULL) { // Check if malloc failed
fprintf(stderr, "Memory allocation failed at iteration %d\n", i);
return 1;
}
printf("Address of chunk %d: %p\n", i, (void *)chunks[i]);
}

// Loop to free the allocated memory
for (i = 0; i < 8; i++) {
free(chunks[i]);
}

chunks[9] = malloc(0x110);

return 0;
}
```
ZauwaÅ¼, jak alokujemy i zwalniamy 9 blokÃ³w tego samego rozmiaru, aby **wypeÅ‚niÄ‡ tcache**, a Ã³smy jest przechowywany w nieuporzÄ…dkowanym bloku, poniewaÅ¼ jest **za duÅ¼y dla fastbin**, a dziewiÄ…ty nie jest zwolniony, wiÄ™c dziewiÄ…ty i Ã³smy **nie sÄ… scalane z gÅ‚Ã³wnym blokiem**. NastÄ™pnie alokujemy wiÄ™kszy blok o rozmiarze 0x110, co powoduje, Å¼e **blok w nieuporzÄ…dkowanym bloku przechodzi do maÅ‚ego bloku**.

Skompiluj to i debuguj z punktem przerwania w operacji `ret` z funkcji `main`. NastÄ™pnie za pomocÄ… `gef` moÅ¼esz zobaczyÄ‡, Å¼e blok tcache jest peÅ‚ny, a jeden blok znajduje siÄ™ w maÅ‚ym bloku:
```bash
gefâ¤  heap bins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tcachebins[idx=15, size=0x110, count=7] â†  Chunk(addr=0xaaaaaaac1d10, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1c00, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac1af0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac19e0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac18d0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac17c0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  Chunk(addr=0xaaaaaaac12a0, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] small_bins[16]: fw=0xaaaaaaac1e10, bk=0xaaaaaaac1e10
â†’   Chunk(addr=0xaaaaaaac1e20, size=0x110, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 small non-empty bins.
```
</details>

### DuÅ¼e pojemniki

W przeciwieÅ„stwie do maÅ‚ych pojemnikÃ³w, ktÃ³re zarzÄ…dzajÄ… kawaÅ‚kami o staÅ‚ych rozmiarach, **kaÅ¼dy duÅ¼y pojemnik obsÅ‚uguje zakres rozmiarÃ³w kawaÅ‚kÃ³w**. Jest to bardziej elastyczne, pozwalajÄ…c systemowi pomieÅ›ciÄ‡ **rÃ³Å¼ne rozmiary** bez koniecznoÅ›ci posiadania osobnego pojemnika dla kaÅ¼dego rozmiaru.

W alokatorze pamiÄ™ci duÅ¼e pojemniki zaczynajÄ… siÄ™ tam, gdzie koÅ„czÄ… siÄ™ maÅ‚e pojemniki. Zakresy dla duÅ¼ych pojemnikÃ³w rosnÄ… stopniowo, co oznacza, Å¼e pierwszy pojemnik moÅ¼e obejmowaÄ‡ kawaÅ‚ki od 512 do 576 bajtÃ³w, podczas gdy nastÄ™pny obejmuje 576 do 640 bajtÃ³w. Ten wzorzec siÄ™ kontynuuje, a najwiÄ™kszy pojemnik zawiera wszystkie kawaÅ‚ki powyÅ¼ej 1 MB.

DuÅ¼e pojemniki sÄ… wolniejsze w obsÅ‚udze w porÃ³wnaniu z maÅ‚ymi pojemnikami, poniewaÅ¼ muszÄ… **sortowaÄ‡ i przeszukiwaÄ‡ listÄ™ rÃ³Å¼nych rozmiarÃ³w kawaÅ‚kÃ³w, aby znaleÅºÄ‡ najlepsze dopasowanie** dla alokacji. Gdy kawaÅ‚ek jest wstawiany do duÅ¼ego pojemnika, musi byÄ‡ posortowany, a podczas alokacji pamiÄ™ci system musi znaleÅºÄ‡ odpowiedni kawaÅ‚ek. Dodatkowa praca sprawia, Å¼e sÄ… **wolniejsze**, ale poniewaÅ¼ duÅ¼e alokacje sÄ… mniej powszechne niÅ¼ maÅ‚e, jest to akceptowalny kompromis.

IstniejÄ…:

* 32 pojemniki o zakresie 64B (kolidujÄ… z maÅ‚ymi pojemnikami)
* 16 pojemnikÃ³w o zakresie 512B (kolidujÄ… z maÅ‚ymi pojemnikami)
* 8 pojemnikÃ³w o zakresie 4096B (czÄ™Å›ciowo kolidujÄ… z maÅ‚ymi pojemnikami)
* 4 pojemniki o zakresie 32768B
* 2 pojemniki o zakresie 262144B
* 1 pojemnik dla pozostaÅ‚ych rozmiarÃ³w

<details>

<summary>Kod rozmiarÃ³w duÅ¼ych pojemnikÃ³w</summary>
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

#define largebin_index_32(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 38) ?  56 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index_32_big(sz)                                            \
(((((unsigned long) (sz)) >> 6) <= 45) ?  49 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                \
(((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
126)

#define largebin_index(sz) \
(SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
: MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
: largebin_index_32 (sz))
```
</details>

<details>

<summary>Dodaj przykÅ‚ad duÅ¼ej porcji</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunks[2];

chunks[0] = malloc(0x1500);
chunks[1] = malloc(0x1500);
free(chunks[0]);
chunks[0] = malloc(0x2000);

return 0;
}
```
2 duÅ¼e alokacje sÄ… wykonywane, nastÄ™pnie jedna jest zwalniana (umieszczajÄ…c jÄ… w nieuporzÄ…dkowanym pojemniku) i dokonywana jest wiÄ™ksza alokacja (przenoszÄ…c zwolnionÄ… do pojemnika nieuporzÄ…dkowanego do pojemnika duÅ¼ego).

Skompiluj to i debuguj z punktem przerwania w operacji `ret` z funkcji `main`. NastÄ™pnie za pomocÄ… `gef` moÅ¼esz zobaczyÄ‡, Å¼e pojemnik tcache jest peÅ‚ny, a jeden fragment jest w pojemniku duÅ¼ym:
```bash
gefâ¤  heap bin
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tcachebins for thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
All tcachebins are empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Fastbins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in unsorted bin.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Small Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] Found 0 chunks in 0 small non-empty bins.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Large Bins for arena at 0xfffff7f90b00 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[+] large_bins[100]: fw=0xaaaaaaac1290, bk=0xaaaaaaac1290
â†’   Chunk(addr=0xaaaaaaac12a0, size=0x1510, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in 1 large non-empty bins.
```
</details>

### GÃ³rny KawaÅ‚ek
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1711

/*
Top

The top-most available chunk (i.e., the one bordering the end of
available memory) is treated specially. It is never included in
any bin, is used only if no other chunk is available, and is
released back to the system if it is very large (see
M_TRIM_THRESHOLD).  Because top initially
points to its own bin with initial zero size, thus forcing
extension on the first malloc request, we avoid having any special
code in malloc to check whether it even exists yet. But we still
need to do so when getting memory from system, so we make
initial_top treat the bin as a legal but unusable chunk during the
interval between initialization and the first call to
sysmalloc. (This is somewhat delicate, since it relies on
the 2 preceding words to be zero during this interval as well.)
*/

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks (M))
```
Podstawowo, to kawaÅ‚ek zawiera caÅ‚Ä… obecnie dostÄ™pnÄ… stertÄ™. Gdy wykonywane jest malloc, jeÅ›li nie ma dostÄ™pnego wolnego kawaÅ‚ka do uÅ¼ycia, ten kawaÅ‚ek wierzchni bÄ™dzie zmniejszaÅ‚ swojÄ… wielkoÅ›Ä‡, zapewniajÄ…c niezbÄ™dnÄ… przestrzeÅ„.\
WskaÅºnik do kawaÅ‚ka wierzchniego jest przechowywany w strukturze `malloc_state`.

Co wiÄ™cej, na poczÄ…tku moÅ¼liwe jest uÅ¼ycie kawaÅ‚ka niesortowanego jako kawaÅ‚ka wierzchniego.

<details>

<summary>Zobacz przykÅ‚ad kawaÅ‚ka wierzchniego</summary>
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
char *chunk;
chunk = malloc(24);
printf("Address of the chunk: %p\n", (void *)chunk);
gets(chunk);
return 0;
}
```
Po skompilowaniu i debugowaniu z punktem przerwania w operacji `ret` w `main`, zauwaÅ¼yÅ‚em, Å¼e funkcja malloc zwrÃ³ciÅ‚a adres `0xaaaaaaac12a0`, a oto kawaÅ‚ki:
```bash
gefâ¤  heap chunks
Chunk(addr=0xaaaaaaac1010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac1010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0xaaaaaaac12a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12a0     41 41 41 41 41 41 41 00 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac12c0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac12c0     41 64 64 72 65 73 73 20 6f 66 20 74 68 65 20 63    Address of the c]
Chunk(addr=0xaaaaaaac16d0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[0x0000aaaaaaac16d0     41 41 41 41 41 41 41 0a 00 00 00 00 00 00 00 00    AAAAAAA.........]
Chunk(addr=0xaaaaaaac1ae0, size=0x20530, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  â†  top chunk
```
Gdzie moÅ¼na zobaczyÄ‡, Å¼e najwyÅ¼szy kawaÅ‚ek znajduje siÄ™ pod adresem `0xaaaaaaac1ae0`. To Å¼adna niespodzianka, poniewaÅ¼ ostatni przydzielony kawaÅ‚ek byÅ‚ pod adresem `0xaaaaaaac12a0` o wielkoÅ›ci `0x410` i `0xaaaaaaac12a0 + 0x410 = 0xaaaaaaac1ae0`.\
MoÅ¼na rÃ³wnieÅ¼ zobaczyÄ‡ dÅ‚ugoÅ›Ä‡ najwyÅ¼szego kawaÅ‚ka na jego nagÅ‚Ã³wku kawaÅ‚ka:
```bash
gefâ¤  x/8wx 0xaaaaaaac1ae0 - 16
0xaaaaaaac1ad0:	0x00000000	0x00000000	0x00020531	0x00000000
0xaaaaaaac1ae0:	0x00000000	0x00000000	0x00000000	0x00000000
```
</details>

### Ostatni Resztek

Kiedy uÅ¼ywane jest malloc i kawaÅ‚ek jest podzielony (na przykÅ‚ad z nieuporzÄ…dkowanego bloku lub z kawaÅ‚ka gÃ³rnego), kawaÅ‚ek stworzony z reszty podzielonego kawaÅ‚ka nazywany jest Ostatnim Resztkiem, a jego wskaÅºnik jest przechowywany w strukturze `malloc_state`.

## PrzepÅ‚yw Alokacji

SprawdÅº:

{% content-ref url="heap-memory-functions/malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](heap-memory-functions/malloc-and-sysmalloc.md)
{% endcontent-ref %}

## PrzepÅ‚yw Zwolnienia

SprawdÅº:

{% content-ref url="heap-memory-functions/free.md" %}
[free.md](heap-memory-functions/free.md)
{% endcontent-ref %}

## Sprawdzenia BezpieczeÅ„stwa Funkcji Stosowanych w Stosie

SprawdÅº sprawdzenia bezpieczeÅ„stwa wykonywane przez czÄ™sto uÅ¼ywane funkcje w stosie w:

{% content-ref url="heap-memory-functions/heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-memory-functions/heap-functions-security-checks.md)
{% endcontent-ref %}

## Referencje

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/)

{% hint style="success" %}
Naucz siÄ™ i Ä‡wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naucz siÄ™ i Ä‡wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w na githubie.

</details>
{% endhint %}
