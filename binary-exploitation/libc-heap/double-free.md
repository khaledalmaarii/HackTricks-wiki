# Doppia Liberazione

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di Base

Se liberi un blocco di memoria pi√π di una volta, pu√≤ compromettere i dati dell'allocatore e aprire la porta agli attacchi. Ecco come avviene: quando liberi un blocco di memoria, esso ritorna in una lista di chunk liberi (ad es. il "fast bin"). Se liberi lo stesso blocco due volte di seguito, l'allocatore rileva ci√≤ e genera un errore. Ma se **liberi un altro chunk nel mezzo, il controllo di doppia liberazione viene eluso**, causando corruzione.

Ora, quando richiedi nuova memoria (usando `malloc`), l'allocatore potrebbe darti un **blocco che √® stato liberato due volte**. Ci√≤ pu√≤ portare a due puntatori diversi che puntano alla stessa posizione di memoria. Se un attaccante controlla uno di quei puntatori, pu√≤ modificare i contenuti di quella memoria, causando problemi di sicurezza o addirittura consentendo l'esecuzione di codice.

Esempio:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
In questo esempio, dopo aver riempito il tcache con diversi chunk liberati (7), il codice **libera il chunk `h`, poi il chunk `i`, e poi di nuovo `h`, causando una doppia liberazione** (nota anche come duplicazione di Fast Bin). Questo apre la possibilit√† di ricevere sovrapposizioni di indirizzi di memoria durante la riallocazione, il che significa che due o pi√π puntatori possono puntare alla stessa posizione di memoria. Manipolare i dati attraverso un puntatore pu√≤ quindi influenzare l'altro, creando un rischio di sicurezza critico e potenziale per l'exploit.

Eseguendolo, nota come **`i1` e `i2` hanno lo stesso indirizzo**:

<pre><code>Assegnazioni iniziali:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Dopo le riallocazioni:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Esempi

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Possiamo allocare solo chunk di dimensioni Fast-Bin tranne per la dimensione `0x70`, che impedisce la sovrascrittura usuale di `__malloc_hook`.
* Invece, utilizziamo gli indirizzi PIE che iniziano con `0x56` come target per Fast Bin dup (1/2 possibilit√†).
* Un luogo in cui gli indirizzi PIE sono memorizzati √® in `main_arena`, che si trova all'interno di Glibc e vicino a `__malloc_hook`.
* Miriamo a un offset specifico di `main_arena` per allocare un chunk l√¨ e continuare ad allocare chunk fino a raggiungere `__malloc_hook` per ottenere l'esecuzione del codice.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Utilizzando i bin Tcache e un overflow di byte nullo, possiamo ottenere una situazione di doppia liberazione:
* Allocare tre chunk di dimensione `0x110` (`A`, `B`, `C`)
* Liberare `B`
* Liberare `A` e allocare di nuovo per utilizzare l'overflow di byte nullo
* Ora il campo di dimensione di `B` √® `0x100`, invece di `0x111`, quindi possiamo liberarlo di nuovo
* Abbiamo un bin Tcache di dimensione `0x110` e uno di dimensione `0x100` che puntano allo stesso indirizzo. Quindi abbiamo una doppia liberazione.
* Sfruttiamo la doppia liberazione utilizzando il [Veleno del Tcache](tcache-bin-attack.md)

## Riferimenti

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
