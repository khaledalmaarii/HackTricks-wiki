# Διπλή Απελευθέρωση

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Βασικές Πληροφορίες

Αν απελευθερώσετε ένα μπλοκ μνήμης περισσότερες από μία φορές, μπορεί να διαταράξει τα δεδομένα του αλγορίθμου κατανομής και να ανοίξει την πόρτα σε επιθέσεις. Να πώς συμβαίνει: όταν απελευθερώνετε ένα μπλοκ μνήμης, επιστρέφει σε μια λίστα ελεύθερων κομματιών (π.χ. το "fast bin"). Αν απελευθερώσετε το ίδιο μπλοκ δύο φορές στη σειρά, ο αλγόριθμος κατανομής το ανιχνεύει αυτό και ρίχνει ένα σφάλμα. Αλλά αν **απελευθερώσετε ένα άλλο κομμάτι ενδιάμεσα, ο έλεγχος διπλής απελευθέρωσης παρακάμπτεται**, προκαλώντας διαφθορά.

Τώρα, όταν ζητάτε νέα μνήμη (χρησιμοποιώντας `malloc`), ο αλγόριθμος κατανομής μπορεί να σας δώσει ένα **μπλοκ που έχει απελευθερωθεί δύο φορές**. Αυτό μπορεί να οδηγήσει σε δύο διαφορετικούς δείκτες που δείχνουν στην ίδια τοποθεσία μνήμης. Αν ένας επιτιθέμενος ελέγχει έναν από αυτούς τους δείκτες, μπορεί να αλλάξει το περιεχόμενο αυτής της μνήμης, κάτι που μπορεί να προκαλέσει προβλήματα ασφαλείας ή ακόμη και να τους επιτρέψει να εκτελέσουν κώδικα.

Παράδειγμα:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i2);

return 0;
}
```
Σε αυτό το παράδειγμα, μετά την πλήρωση του tcache με αρκετά ελευθερωμένα chunks (7), ο κώδικας **ελευθερώνει το chunk `h`, στη συνέχεια το chunk `i`, και μετά ξανά το `h`, προκαλώντας μια διπλή ελευθέρωση** (γνωστή και ως Fast Bin dup). Αυτό ανοίγει τη δυνατότητα λήψης επικαλυπτόμενων διευθύνσεων μνήμης κατά την επανακατανομή, πράγμα που σημαίνει ότι δύο ή περισσότερες δείκτες μπορούν να δείχνουν στην ίδια διεύθυνση μνήμης. Η χειραγώγηση δεδομένων μέσω ενός δείκτη μπορεί στη συνέχεια να επηρεάσει τον άλλο, δημιουργώντας έναν κρίσιμο κίνδυνο ασφαλείας και πιθανότητα εκμετάλλευσης.

Εκτελώντας το, σημειώστε πώς **`i1` και `i2` πήραν την ίδια διεύθυνση**:

<pre><code>Αρχικές κατανομές:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Μετά τις επανακατανομές:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Παραδείγματα

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Μπορούμε να κατανεμηθούμε μόνο chunks μεγέθους Fast-Bin εκτός από το μέγεθος `0x70`, το οποίο αποτρέπει την συνήθη επικάλυψη του `__malloc_hook`.
* Αντίθετα, χρησιμοποιούμε διευθύνσεις PIE που ξεκινούν με `0x56` ως στόχο για Fast Bin dup (1/2 πιθανότητα).
* Ένα μέρος όπου αποθηκεύονται οι διευθύνσεις PIE είναι στο `main_arena`, το οποίο βρίσκεται μέσα στο Glibc και κοντά στο `__malloc_hook`.
* Στοχεύουμε σε μια συγκεκριμένη μετατόπιση του `main_arena` για να κατανεμηθεί ένα chunk εκεί και συνεχίζουμε να κατανεμηθούμε chunks μέχρι να φτάσουμε στο `__malloc_hook` για να αποκτήσουμε εκτέλεση κώδικα.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Χρησιμοποιώντας Tcache bins και μια υπερχείλιση null-byte, μπορούμε να επιτύχουμε μια κατάσταση διπλής ελευθέρωσης:
* Κατανεμούμε τρία chunks μεγέθους `0x110` (`A`, `B`, `C`)
* Ελευθερώνουμε το `B`
* Ελευθερώνουμε το `A` και κατανεμούμε ξανά για να χρησιμοποιήσουμε την υπερχείλιση null-byte
* Τώρα το πεδίο μεγέθους του `B` είναι `0x100`, αντί για `0x111`, οπότε μπορούμε να το ελευθερώσουμε ξανά
* Έχουμε ένα Tcache-bin μεγέθους `0x110` και ένα μεγέθους `0x100` που δείχνουν στην ίδια διεύθυνση. Έτσι έχουμε μια διπλή ελευθέρωση.
* Εκμεταλλευόμαστε τη διπλή ελευθέρωση χρησιμοποιώντας [Tcache poisoning](tcache-bin-attack.md)

## Αναφορές

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
