# ダブルフリー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)を**フォロー**する
* **ハッキングトリックを共有するために、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出する

</details>

## 基本情報

メモリブロックを複数回解放すると、割り当て器のデータが狂い、攻撃の可能性が生じます。こうなる理由は次のとおりです：メモリブロックを解放すると、それは空きチャンクのリスト（例：「fast bin」）に戻ります。同じブロックを2回連続で解放すると、割り当て器はこれを検出してエラーをスローします。しかし、**別のチャンクを解放すると、ダブルフリーチェックがバイパス**され、破損が発生します。

今、新しいメモリを要求すると（`malloc`を使用）、割り当て器は**2回解放されたブロック**を提供する可能性があります。これにより、異なる2つのポインタが同じメモリ位置を指すことがあります。攻撃者がそのうちの1つのポインタを制御している場合、そのメモリの内容を変更でき、セキュリティの問題を引き起こしたり、コードの実行を許可したりする可能性があります。

例：
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
この例では、tcacheを複数の解放されたチャンク（7つ）で埋めた後、コードは**チャンク `h`、次にチャンク `i`、そして再び `h`**を解放し、ダブルフリー（またはFast Bin dupとしても知られる）を引き起こします。これにより、再割り当て時に重複するメモリアドレスを受け取る可能性が開かれ、つまり2つ以上のポインタが同じメモリ位置を指すことができます。1つのポインタを介してデータを操作することで、他方に影響を与えることができ、重大なセキュリティリスクと潜在的な悪用の可能性が生じます。

実行すると、**`i1`と`i2`が同じアドレスを取得したことに注意**してください：

<pre><code>初期割り当て：
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
再割り当て後：
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## 例

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* サイズ`0x70`以外のFast Binサイズのチャンクしか割り当てることができません。通常の`__malloc_hook`の上書きを防ぎます。
* 代わりに、Fast Bin dupのターゲットとして`0x56`で始まるPIEアドレスを使用します（1/2の確率）。
* PIEアドレスが格納されている場所の1つは、`main_arena`内にあり、Glibc内部にあり、`__malloc_hook`の近くにあります。
* 特定の`main_arena`のオフセットをターゲットにして、そこにチャンクを割り当て、`__malloc_hook`に到達するまでチャンクを継続的に割り当てます。これにより、コードの実行が可能になります。
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Tcache binsとヌルバイトオーバーフローを使用して、ダブルフリーの状況を達成できます：
* サイズ`0x110`の3つのチャンク（`A`、`B`、`C`）を割り当てます
* `B`を解放します
* `A`を解放して再度割り当て、ヌルバイトオーバーフローを使用します
* これで`B`のサイズフィールドが`0x111`ではなく`0x100`になるため、再度解放できます
* サイズが`0x110`のTcache-binとサイズが`0x100`のTcache-binが同じアドレスを指すようになります。したがって、ダブルフリーが発生します。
* [Tcache poisoning](tcache-bin-attack.md)を使用してダブルフリーを活用します。

## 参考文献

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つけます
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**および**HackTricks Cloud**のGitHubリポジトリにPRを提出して、**ハッキングトリックを共有**してください。

</details>
