# Double Free

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Ako oslobodite blok memorije viÅ¡e od jednom, to moÅ¾e poremetiti podatke alokatora i otvoriti vrata napadima. Evo kako se to deÅ¡ava: kada oslobodite blok memorije, on se vraÄ‡a u listu slobodnih delova (npr. "brzi bin"). Ako oslobodite isti blok dva puta zaredom, alokator to detektuje i javlja greÅ¡ku. Ali ako **oslobodite drugi deo izmeÄ‘u, provera duplog oslobaÄ‘anja se zaobilazi**, Å¡to uzrokuje korupciju.

Sada, kada zatraÅ¾ite novu memoriju (koristeÄ‡i `malloc`), alokator vam moÅ¾e dati **blok koji je osloboÄ‘en dva puta**. To moÅ¾e dovesti do dva razliÄita pokazivaÄa koji upuÄ‡uju na istu lokaciju u memoriji. Ako napadaÄ kontroliÅ¡e jedan od tih pokazivaÄa, moÅ¾e promeniti sadrÅ¾aj te memorije, Å¡to moÅ¾e izazvati sigurnosne probleme ili Äak omoguÄ‡iti izvrÅ¡avanje koda.

Example:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i2);

return 0;
}
```
U ovom primeru, nakon Å¡to se tcache napuni sa nekoliko osloboÄ‘enih delova (7), kod **oslobaÄ‘a deo `h`, zatim deo `i`, a zatim ponovo `h`, uzrokujuÄ‡i duplo oslobaÄ‘anje** (poznato i kao Fast Bin dup). Ovo otvara moguÄ‡nost dobijanja preklapajuÄ‡ih memorijskih adresa prilikom ponovnog alociranja, Å¡to znaÄi da dva ili viÅ¡e pokazivaÄa mogu ukazivati na istu memorijsku lokaciju. Manipulacija podacima kroz jedan pokazivaÄ moÅ¾e zatim uticati na drugi, stvarajuÄ‡i kritiÄan bezbednosni rizik i potencijal za eksploataciju.

IzvrÅ¡avajuÄ‡i to, obratite paÅ¾nju na to kako **`i1` i `i2` imaju istu adresu**:

<pre><code>PoÄetne alokacije:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Nakon ponovnih alokacija:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Primeri

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* MoÅ¾emo alocirati samo delove veliÄine Fast-Bin osim za veliÄinu `0x70`, Å¡to spreÄava uobiÄajeno prepisivanje `__malloc_hook`.
* Umesto toga, koristimo PIE adrese koje poÄinju sa `0x56` kao cilj za Fast Bin dup (1/2 Å¡ansa).
* Jedno mesto gde se Äuvaju PIE adrese je u `main_arena`, koja se nalazi unutar Glibc i blizu `__malloc_hook`.
* Ciljamo specifiÄan ofset `main_arena` da bismo alocirali deo tamo i nastavljamo sa alokacijom delova dok ne doÄ‘emo do `__malloc_hook` da bismo dobili izvrÅ¡enje koda.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* KoristeÄ‡i Tcache kante i prelivanje null-bajta, moÅ¾emo postiÄ‡i situaciju duplog oslobaÄ‘anja:
* Alociramo tri dela veliÄine `0x110` (`A`, `B`, `C`)
* OslobaÄ‘amo `B`
* OslobaÄ‘amo `A` i ponovo alociramo da bismo iskoristili prelivanje null-bajta
* Sada je veliÄina `B`-ovog polja `0x100`, umesto `0x111`, tako da ga moÅ¾emo ponovo osloboditi
* Imamo jednu Tcache-kantu veliÄine `0x110` i jednu veliÄine `0x100` koje ukazuju na istu adresu. Tako da imamo duplo oslobaÄ‘anje.
* IskoriÅ¡Ä‡avamo duplo oslobaÄ‘anje koristeÄ‡i [Tcache poisoning](tcache-bin-attack.md)

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
