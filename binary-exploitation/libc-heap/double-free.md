# Dvostruko OslobaÄ‘anje

{% hint style="success" %}
NauÄite i veÅ¾bajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Obuka AWS Crveni Tim StruÄnjak (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
NauÄite i veÅ¾bajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Obuka GCP Crveni Tim StruÄnjak (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne Informacije

Ako oslobodite blok memorije viÅ¡e puta, moÅ¾ete poremetiti podatke alokatora i otvoriti vrata napadima. Evo kako se to deÅ¡ava: kada oslobodite blok memorije, on se vraÄ‡a u listu slobodnih blokova (npr. "brzi bin"). Ako oslobodite isti blok dva puta zaredom, alokator detektuje to i prijavljuje greÅ¡ku. MeÄ‘utim, ako **oslobodite joÅ¡ jedan blok izmeÄ‘u, provera dvostrukog oslobaÄ‘anja se zaobilazi**, Å¡to uzrokuje korupciju.

Sada, kada zatraÅ¾ite novu memoriju (koristeÄ‡i `malloc`), alokator vam moÅ¾e dati **blok koji je osloboÄ‘en dva puta**. To moÅ¾e dovesti do toga da dva razliÄita pokazivaÄa pokazuju na istu lokaciju memorije. Ako napadaÄ kontroliÅ¡e jedan od tih pokazivaÄa, moÅ¾e promeniti sadrÅ¾aj te memorije, Å¡to moÅ¾e izazvati sigurnosne probleme ili im Äak omoguÄ‡iti izvrÅ¡avanje koda.

Primer:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
U ovom primeru, nakon Å¡to se tcache popuni sa nekoliko osloboÄ‘enih blokova (7), kod **oslobaÄ‘a blok `h`, zatim blok `i`, a zatim ponovo `h`, uzrokujuÄ‡i dvostruko osloboÄ‘avanje** (poznato i kao duplikat brzog bin-a). Ovo otvara moguÄ‡nost dobijanja preklapajuÄ‡ih memorijskih adresa prilikom ponovnog dodeljivanja, Å¡to znaÄi da dva ili viÅ¡e pokazivaÄa mogu pokazivati na istu memorijsku lokaciju. Manipulisanje podacima putem jednog pokazivaÄa moÅ¾e zatim uticati na drugi, stvarajuÄ‡i kritiÄan sigurnosni rizik i potencijal za eksploataciju.

IzvrÅ¡avajuÄ‡i to, primetite kako su **`i1` i `i2` dobili istu adresu**:

<pre><code>PoÄetne alokacije:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Nakon ponovnih dodela:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Primeri

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* MoÅ¾emo alocirati samo blokove veliÄine Fast-Bin, osim za veliÄinu `0x70`, Å¡to spreÄava uobiÄajeno prepisivanje `__malloc_hook`.
* Umesto toga, koristimo PIE adrese koje poÄinju sa `0x56` kao cilj za Fast Bin dup (1/2 Å¡anse).
* Jedno mesto gde se Äuvaju PIE adrese je u `main_arena`, koja je unutar Glibc-a i blizu `__malloc_hook`.
* Ciljamo odreÄ‘eno odstupanje `main_arena` da alociramo blok tamo i nastavimo sa alociranjem blokova dok ne stignemo do `__malloc_hook` kako bismo dobili izvrÅ¡enje koda.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* KoristeÄ‡i Tcache binove i prelivanje nulama, moÅ¾emo postiÄ‡i situaciju dvostrukog osloboÄ‘avanja:
* Alociramo tri bloka veliÄine `0x110` (`A`, `B`, `C`)
* OslobaÄ‘amo `B`
* OslobaÄ‘amo `A` i ponovo alociramo da bismo koristili prelivanje nulama
* Sada je veliÄina polja `B` `0x100`, umesto `0x111`, tako da ga moÅ¾emo ponovo osloboditi
* Imamo jedan Tcache-bin veliÄine `0x110` i jedan veliÄine `0x100` koji pokazuju na istu adresu. Dakle, imamo dvostruko osloboÄ‘avanje.
* IskoriÅ¡Ä‡avamo dvostruko osloboÄ‘avanje koristeÄ‡i [Tcache trovanje](tcache-bin-attack.md)

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
NauÄite i veÅ¾bajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
NauÄite i veÅ¾bajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
