# Doble Liberaci贸n

{% hint style="success" %}
Aprende y practica Hacking en AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* 隆Consulta los [**planes de suscripci贸n**](https://github.com/sponsors/carlospolop)!
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informaci贸n B谩sica

Si liberas un bloque de memoria m谩s de una vez, puede alterar los datos del asignador y abrir la puerta a ataques. As铆 es como sucede: cuando liberas un bloque de memoria, vuelve a una lista de fragmentos libres (por ejemplo, el "fast bin"). Si liberas el mismo bloque dos veces seguidas, el asignador detecta esto y arroja un error. Pero si **liberas otro fragmento en medio, se omite la verificaci贸n de doble liberaci贸n**, causando corrupci贸n.

Ahora, cuando solicitas nueva memoria (usando `malloc`), el asignador podr铆a darte un **bloque que ha sido liberado dos veces**. Esto puede llevar a que dos punteros diferentes apunten a la misma ubicaci贸n de memoria. Si un atacante controla uno de esos punteros, puede cambiar el contenido de esa memoria, lo que puede causar problemas de seguridad o incluso permitirles ejecutar c贸digo.

Ejemplo:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
En este ejemplo, despu茅s de llenar la tcache con varios fragmentos liberados (7), el c贸digo **libera el fragmento `h`, luego el fragmento `i`, y luego `h` nuevamente, causando una doble liberaci贸n** (tambi茅n conocida como duplicaci贸n de Fast Bin). Esto abre la posibilidad de recibir direcciones de memoria superpuestas al realojar, lo que significa que dos o m谩s punteros pueden apuntar a la misma ubicaci贸n de memoria. Manipular datos a trav茅s de un puntero puede afectar al otro, creando un riesgo de seguridad cr铆tico y potencial para la explotaci贸n.

Al ejecutarlo, observe c贸mo **`i1` e `i2` obtienen la misma direcci贸n**:

<pre><code>Asignaciones iniciales:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Despu茅s de las realocaciones:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Ejemplos

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Solo podemos asignar fragmentos del tama帽o de Fast Bin, excepto para el tama帽o `0x70`, lo que evita la sobrescritura habitual de `__malloc_hook`.
* En su lugar, usamos direcciones PIE que comienzan con `0x56` como objetivo para Fast Bin dup (1/2 de probabilidad).
* Un lugar donde se almacenan las direcciones PIE es en `main_arena`, que est谩 dentro de Glibc y cerca de `__malloc_hook`.
* Apuntamos a un desplazamiento espec铆fico de `main_arena` para asignar un fragmento all铆 y continuar asignando fragmentos hasta llegar a `__malloc_hook` para lograr la ejecuci贸n de c贸digo.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Usando contenedores Tcache y un desbordamiento de byte nulo, podemos lograr una situaci贸n de doble liberaci贸n:
* Asignamos tres fragmentos de tama帽o `0x110` (`A`, `B`, `C`).
* Liberamos `B`.
* Liberamos `A` y asignamos nuevamente para usar el desbordamiento de byte nulo.
* Ahora el campo de tama帽o de `B` es `0x100`, en lugar de `0x111`, por lo que podemos liberarlo nuevamente.
* Tenemos un contenedor Tcache de tama帽o `0x110` y uno de tama帽o `0x100` que apuntan a la misma direcci贸n. As铆 que tenemos una doble liberaci贸n.
* Aprovechamos la doble liberaci贸n utilizando [Envenenamiento de Tcache](tcache-bin-attack.md)

## Referencias

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* 隆Consulta los [**planes de suscripci贸n**](https://github.com/sponsors/carlospolop)!
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
