# Double Free

{% hint style="success" %}
Impara e pratica l'hacking su AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
{% endhint %}

## Informazioni di Base

Se liberi un blocco di memoria pi√π di una volta, puoi compromettere i dati dell'allocatore e aprire la porta agli attacchi. Ecco come avviene: quando liberi un blocco di memoria, esso ritorna in una lista di chunk liberi (ad esempio il "fast bin"). Se liberi lo stesso blocco due volte di seguito, l'allocatore rileva ci√≤ e genera un errore. Ma se **liberi un altro chunk nel mezzo, il controllo di double-free viene eluso**, causando corruzione.

Ora, quando richiedi nuova memoria (usando `malloc`), l'allocatore potrebbe darti un **blocco che √® stato liberato due volte**. Ci√≤ pu√≤ portare a due puntatori diversi che puntano alla stessa posizione di memoria. Se un attaccante controlla uno di quei puntatori, pu√≤ modificare il contenuto di quella memoria, causando problemi di sicurezza o addirittura consentendo l'esecuzione di codice.

Esempio:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
In questo esempio, dopo aver riempito il tcache con diversi chunk liberati (7), il codice **libera il chunk `h`, poi il chunk `i`, e poi di nuovo `h`, causando una doppia liberazione** (nota anche come duplicazione di Fast Bin). Questo apre la possibilit√† di ricevere sovrapposizioni di indirizzi di memoria durante la riallocazione, il che significa che due o pi√π puntatori possono puntare alla stessa posizione di memoria. Manipolare i dati attraverso un puntatore pu√≤ quindi influenzare l'altro, creando un rischio di sicurezza critico e potenziale per l'exploit.

Eseguendolo, nota come **`i1` e `i2` hanno lo stesso indirizzo**:

<pre><code>Assegnazioni iniziali:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Dopo le riallocazioni:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Esempi

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Possiamo allocare solo chunk di dimensioni Fast-Bin tranne per la dimensione `0x70`, che impedisce la sovrascrittura usuale di `__malloc_hook`.
* Invece, utilizziamo indirizzi PIE che iniziano con `0x56` come target per Fast Bin dup (1/2 possibilit√†).
* Un luogo in cui gli indirizzi PIE sono memorizzati √® in `main_arena`, che si trova all'interno di Glibc e vicino a `__malloc_hook`.
* Miriamo a un offset specifico di `main_arena` per allocare un chunk l√¨ e continuare ad allocare chunk fino a raggiungere `__malloc_hook` per ottenere l'esecuzione del codice.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Utilizzando i bin Tcache e un overflow di byte nullo, possiamo ottenere una situazione di doppia liberazione:
* Allocare tre chunk di dimensione `0x110` (`A`, `B`, `C`)
* Liberare `B`
* Liberare `A` e allocare di nuovo per utilizzare l'overflow di byte nullo
* Ora il campo di dimensione di `B` √® `0x100`, invece di `0x111`, quindi possiamo liberarlo di nuovo
* Abbiamo un bin Tcache di dimensione `0x110` e uno di dimensione `0x100` che puntano allo stesso indirizzo. Quindi abbiamo una doppia liberazione.
* Sfruttiamo la doppia liberazione utilizzando il [Veleno del Tcache](tcache-bin-attack.md)

## Riferimenti

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
