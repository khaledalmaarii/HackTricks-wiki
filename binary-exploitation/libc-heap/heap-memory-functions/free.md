# Î”Ï‰ÏÎµÎ¬Î½

{% hint style="success" %}
ÎœÎ¬Î¸ÎµÏ„Îµ & ÎµÎ¾Î±ÏƒÎºÎ·Î¸ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ Hacking Ï„Î¿Ï… AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Î•ÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ· HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
ÎœÎ¬Î¸ÎµÏ„Îµ & ÎµÎ¾Î±ÏƒÎºÎ·Î¸ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ Hacking Ï„Î¿Ï… GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Î•ÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ· HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Î¥Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¾Ï„Îµ Ï„Î¿ HackTricks</summary>

* Î•Î»Î­Î³Î¾Ï„Îµ Ï„Î± [**ÏƒÏ‡Î­Î´Î¹Î± ÏƒÏ…Î½Î´ÏÎ¿Î¼Î®Ï‚**](https://github.com/sponsors/carlospolop)!
* **Î•Î³Î³ÏÎ±Ï†ÎµÎ¯Ï„Îµ** ğŸ’¬ ÏƒÏ„Î·Î½ [**Î¿Î¼Î¬Î´Î± Discord**](https://discord.gg/hRep4RUj7f) Î® ÏƒÏ„Î·Î½ [**Î¿Î¼Î¬Î´Î± telegram**](https://t.me/peass) Î® **Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÏ„Îµ** Î¼Î±Ï‚ ÏƒÏ„Î¿ **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **ÎšÎ¿Î¹Î½Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ ÎºÏŒÎ»Ï€Î± Ï‡Î¬ÎºÎµÏ Ï…Ï€Î¿Î²Î¬Î»Î»Î¿Î½Ï„Î±Ï‚ PRs ÏƒÏ„Î±** [**HackTricks**](https://github.com/carlospolop/hacktricks) ÎºÎ±Î¹ [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Î±Ï€Î¿Î¸ÎµÏ„Î®ÏÎ¹Î± Ï„Î¿Ï… GitHub.

</details>
{% endhint %}

## Î”Ï‰ÏÎµÎ¬Î½ Î ÎµÏÎ¯Î»Î·ÏˆÎ· Î Î±ÏÎ±Î³Î³ÎµÎ»Î¯Î±Ï‚ <a href="#libc_free" id="libc_free"></a>

(Î”ÎµÎ½ ÎµÎ¾Î·Î³Î¿ÏÎ½Ï„Î±Î¹ ÎµÎ»Î­Î³Ï‡Î¿Î¹ ÏƒÎµ Î±Ï…Ï„Î®Î½ Ï„Î·Î½ Ï€ÎµÏÎ¯Î»Î·ÏˆÎ· ÎºÎ±Î¹ Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚ Î­Ï‡Î¿Ï…Î½ Ï€Î±ÏÎ±Î»ÎµÎ¹Ï†Î¸ÎµÎ¯ Î³Î¹Î± ÏƒÏ…Î½Ï„Î¿Î¼Î¯Î±)

1. Î‘Î½ Î· Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ· ÎµÎ¯Î½Î±Î¹ null, Î¼Î·Î½ ÎºÎ¬Î½ÎµÏ„Îµ Ï„Î¯Ï€Î¿Ï„Î±
2. Î‘Î½ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î®Ï„Î±Î½ Î´Î¹Î±Î¼Î¿ÏÏ†Ï‰Î¼Î­Î½Î¿ Î¼Îµ Ï‡ÏÎ®ÏƒÎ· mmap, Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏÏƒÏ„Îµ Ï„Î¿ ÎºÎ±Î¹ Ï„ÎµÎ»ÎµÎ¹ÏÏƒÏ„Îµ
3. ÎšÎ±Î»Î­ÏƒÏ„Îµ `_int_free`:
1. Î‘Î½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒ, Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÏƒÏ„Î·Î½ tcache
2. Î‘Î½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒ, Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÏƒÏ„Î¿ fast bin
3. ÎšÎ±Î»Î­ÏƒÏ„Îµ Ï„Î¿ `_int_free_merge_chunk` Î³Î¹Î± Î½Î± ÏƒÏ…Î³Ï‡Ï‰Î½ÎµÏÏƒÎµÏ„Îµ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î±ÏÎ±Î¯Ï„Î·Ï„Î¿ ÎºÎ±Î¹ Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¿ ÏƒÏ„Î· Î»Î¯ÏƒÏ„Î± Ï„Ï‰Î½ Î¼Î· Ï„Î±Î¾Î¹Î½Î¿Î¼Î·Î¼Î­Î½Ï‰Î½

## \_\_libc\_free <a href="#libc_free" id="libc_free"></a>

Î¤Î¿ `Free` ÎºÎ±Î»ÎµÎ¯ Ï„Î¿ `__libc_free`.

* Î‘Î½ Î· Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ· Ï€Î¿Ï… Ï€ÎµÏÎ½Î¬Ï„Î±Î¹ ÎµÎ¯Î½Î±Î¹ Null (0), Î¼Î·Î½ ÎºÎ¬Î½ÎµÏ„Îµ Ï„Î¯Ï€Î¿Ï„Î±.
* Î•Î»Î­Î³Î¾Ï„Îµ Ï„Î¿ ÎµÏ„Î¹ÎºÎ­Ï„Î± Î´ÎµÎ¯ÎºÏ„Î·
* Î‘Î½ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÎµÎ¯Î½Î±Î¹ `mmaped`, Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏÏƒÏ„Îµ Ï„Î¿ ÎºÎ±Î¹ Ï„Î­Î»Î¿Ï‚
* Î‘Î½ ÏŒÏ‡Î¹, Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¿ Ï‡ÏÏÎ¼Î± ÎºÎ±Î¹ ÎºÎ±Î»Î­ÏƒÏ„Îµ Ï„Î¿ `_int_free` Ï€Î¬Î½Ï‰ Ï„Î¿Ï…

<details>

<summary>ÎšÏÎ´Î¹ÎºÎ±Ï‚ __lib_free</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## \_int\_free <a href="#int_free" id="int_free"></a>

### \_int\_free Î­Î½Î±ÏÎ¾Î· <a href="#int_free" id="int_free"></a>

ÎÎµÎºÎ¹Î½Î¬ Î¼Îµ Î¼ÎµÏÎ¹ÎºÎ¿ÏÏ‚ ÎµÎ»Î­Î³Ï‡Î¿Ï…Ï‚ Î³Î¹Î± Î½Î± Î²ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯:

* ÏŒÏ„Î¹ Î¿ **Î´ÎµÎ¯ÎºÏ„Î·Ï‚** ÎµÎ¯Î½Î±Î¹ **ÎµÏ…Î¸Ï…Î³ÏÎ±Î¼Î¼Î¹ÏƒÎ¼Î­Î½Î¿Ï‚,** Î±Î»Î»Î¹ÏÏ‚ ÎµÎºÎºÎ¹Î½ÎµÎ¯Ï„Î±Î¹ ÏƒÏ†Î¬Î»Î¼Î± `free(): Î¼Î· Î­Î³ÎºÏ…ÏÎ¿Ï‚ Î´ÎµÎ¯ÎºÏ„Î·Ï‚`
* ÏŒÏ„Î¹ Ï„Î¿ **Î¼Î­Î³ÎµÎ¸Î¿Ï‚** Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î¼Î¹ÎºÏÏŒÏ„ÎµÏÎ¿ Î±Ï€ÏŒ Ï„Î¿ ÎµÎ»Î¬Ï‡Î¹ÏƒÏ„Î¿ ÎºÎ±Î¹ ÏŒÏ„Î¹ Ï„Î¿ **Î¼Î­Î³ÎµÎ¸Î¿Ï‚** ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ **ÎµÏ…Î¸Ï…Î³ÏÎ±Î¼Î¼Î¹ÏƒÎ¼Î­Î½Î¿** Î® ÎµÎºÎºÎ¹Î½ÎµÎ¯Ï„Î±Î¹ ÏƒÏ†Î¬Î»Î¼Î±: `free(): Î¼Î· Î­Î³ÎºÏ…ÏÎ¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚`

<details>

<summary>_int_free Î­Î½Î±ÏÎ¾Î·</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### \_int\_free tcache <a href="#int_free" id="int_free"></a>

Î‘ÏÏ‡Î¹ÎºÎ¬ Î¸Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÎµÎ¹ Î½Î± Î´ÎµÏƒÎ¼ÎµÏÏƒÎµÎ¹ Î±Ï…Ï„ÏŒ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î¼Î½Î®Î¼Î·Ï‚ ÏƒÏ„Î¿ ÏƒÏ‡ÎµÏ„Î¹ÎºÏŒ tcache. Î©ÏƒÏ„ÏŒÏƒÎ¿, Ï€ÏÎ±Î³Î¼Î±Ï„Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿Î¹ Î­Î»ÎµÎ³Ï‡Î¿Î¹ Ï€ÏÎ¹Î½. Î˜Î± ÎµÏ€Î±Î½Î±Î»Î¬Î²ÎµÎ¹ ÏŒÎ»Î± Ï„Î± ÎºÎ¿Î¼Î¼Î¬Ï„Î¹Î± Ï„Î¿Ï… tcache ÏƒÏ„Î¿Î½ Î¯Î´Î¹Î¿ Î´ÎµÎ¯ÎºÏ„Î· Î¼Îµ Ï„Î¿ Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏ‰Î¼Î­Î½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÎºÎ±Î¹:

* Î‘Î½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ®ÏƒÎµÎ¹Ï‚ Î±Ï€ÏŒ `mp_.tcache_count`: `free(): too many chunks detected in tcache`
* Î‘Î½ Î· ÎºÎ±Ï„Î±Ï‡ÏÏÎ·ÏƒÎ· Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎµÏ…Î¸Ï…Î³ÏÎ±Î¼Î¼Î¹ÏƒÎ¼Î­Î½Î·: `free(): unaligned chunk detected in tcache 2`
* Î‘Î½ Ï„Î¿ Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏ‰Î¼Î­Î½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î­Ï‡ÎµÎ¹ Î®Î´Î· Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏ‰Î¸ÎµÎ¯ ÎºÎ±Î¹ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï‰Ï‚ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÏƒÏ„Î¿ tcache: `free(): double free detected in tcache 2`

Î‘Î½ ÏŒÎ»Î± Ï€Î¬Î½Îµ ÎºÎ±Î»Î¬, Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Ï€ÏÎ¿ÏƒÏ„Î¯Î¸ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ tcache ÎºÎ±Î¹ Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹.
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### \_int\_free Î³ÏÎ®Î³Î¿ÏÎ¿Ï‚ ÎºÎ¬Î´Î¿Ï‚ <a href="#int_free" id="int_free"></a>

ÎÎµÎºÎ¹Î½Î®ÏƒÏ„Îµ ÎµÎ»Î­Î³Ï‡Î¿Î½Ï„Î±Ï‚ Î±Î½ Ï„Î¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ ÎºÎ±Ï„Î¬Î»Î»Î·Î»Î¿ Î³Î¹Î± Ï„Î¿Î½ Î³ÏÎ®Î³Î¿ÏÎ¿ ÎºÎ¬Î´Î¿ ÎºÎ±Î¹ ÎµÎ»Î­Î³Î¾Ï„Îµ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒÎ½ Î½Î± Ï„Î¿ Ï„Î¿Ï€Î¿Î¸ÎµÏ„Î®ÏƒÎµÏ„Îµ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÎºÎ¿ÏÏ…Ï†Î®Ï‚.

Î£Ï„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¿ Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏ‰Î¼Î­Î½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÏƒÏ„Î·Î½ ÎºÎ¿ÏÏ…Ï†Î® Ï„Î¿Ï… Î³ÏÎ®Î³Î¿ÏÎ¿Ï… ÎºÎ¬Î´Î¿Ï… ÎµÎ½Ï Ï€ÏÎ±Î³Î¼Î±Ï„Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿Ï…Ï‚ ÎµÎ»Î­Î³Ï‡Î¿Ï…Ï‚:

* Î•Î¬Î½ Ï„Î¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚ Ï„Î¿Ï… ÎºÎ¿Î¼Î¼Î±Ï„Î¹Î¿Ï ÎµÎ¯Î½Î±Î¹ Î¼Î· Î­Î³ÎºÏ…ÏÎ¿ (Ï€Î¿Î»Ï Î¼ÎµÎ³Î¬Î»Î¿ Î® Î¼Î¹ÎºÏÏŒ) ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ: `free(): invalid next size (fast)`
* Î•Î¬Î½ Ï„Î¿ Ï€ÏÎ¿ÏƒÏ„Î¹Î¸Î­Î¼ÎµÎ½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î®Ï„Î±Î½ Î®Î´Î· ÏƒÏ„Î·Î½ ÎºÎ¿ÏÏ…Ï†Î® Ï„Î¿Ï… Î³ÏÎ®Î³Î¿ÏÎ¿Ï… ÎºÎ¬Î´Î¿Ï…: `double free or corruption (fasttop)`
* Î•Î¬Î½ Ï„Î¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚ Ï„Î¿Ï… ÎºÎ¿Î¼Î¼Î±Ï„Î¹Î¿Ï ÏƒÏ„Î·Î½ ÎºÎ¿ÏÏ…Ï†Î® Î­Ï‡ÎµÎ¹ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏŒ Î¼Î­Î³ÎµÎ¸Î¿Ï‚ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Ï€Î¿Ï… Ï€ÏÎ¿ÏƒÎ¸Î­Ï„Î¿Ï…Î¼Îµ: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
### Î¤ÎµÎ»Î¹ÎºÏŒÏ‚ _int_free <a href="#int_free" id="int_free"></a>

Î‘Î½ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î´ÎµÎ½ ÎµÎ¯Ï‡Îµ Î±ÎºÏŒÎ¼Î± ÎµÎºÏ‡Ï‰ÏÎ·Î¸ÎµÎ¯ ÏƒÎµ ÎºÎ¬Ï€Î¿Î¹Î¿ bin, ÎºÎ±Î»Î­ÏƒÏ„Îµ Ï„Î·Î½ `_int_free_merge_chunk`
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## \_int\_free\_merge\_chunk

Î‘Ï…Ï„Î® Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î¸Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÎµÎ¹ Î½Î± ÏƒÏ…Î³Ï‡Ï‰Î½ÎµÏÏƒÎµÎ¹ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ P Î¼Îµ Î¼Î­Î³ÎµÎ¸Î¿Ï‚ SIZE bytes Î¼Îµ Ï„Î¿Ï…Ï‚ Î³ÎµÎ¯Ï„Î¿Î½Î­Ï‚ Ï„Î¿Ï…. Î˜Î± Ï„Î¿Ï€Î¿Î¸ÎµÏ„Î®ÏƒÎµÎ¹ Ï„Î¿ Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± ÏƒÏ„Î· Î»Î¯ÏƒÏ„Î± unsorted bin.

ÎšÎ¬Ï€Î¿Î¹Î¿Î¹ Î­Î»ÎµÎ³Ï‡Î¿Î¹ Ï€ÏÎ±Î³Î¼Î±Ï„Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹:

* Î‘Î½ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ ÎºÎ¿ÏÏ…Ï†Î±Î¯Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹: `double free or corruption (top)`
* Î‘Î½ Ï„Î¿ ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Î­Î¾Ï‰ Î±Ï€ÏŒ Ï„Î± ÏŒÏÎ¹Î± Ï„Î·Ï‚ Î±ÏÎ­Î½Î±Ï‚: `double free or corruption (out)`
* Î‘Î½ Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÏƒÎ·Î¼Î±ÏƒÎ¹Î¿Î´Î¿Ï„Î·Î¼Î­Î½Î¿ Ï‰Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¼Î­Î½Î¿ (ÏƒÏ„Î¿ `prev_inuse` Î±Ï€ÏŒ Ï„Î¿ ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹): `double free or corruption (!prev)`
* Î‘Î½ Ï„Î¿ ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î­Ï‡ÎµÎ¹ Ï€Î¿Î»Ï Î¼Î¹ÎºÏÏŒ Î® Ï€Î¿Î»Ï Î¼ÎµÎ³Î¬Î»Î¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚: `free(): invalid next size (normal)`
* Î‘Î½ Ï„Î¿ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÏƒÎµ Ï‡ÏÎ®ÏƒÎ·, Î¸Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÎµÎ¹ Î½Î± ÏƒÏ…Î³Ï‡Ï‰Î½ÎµÏÏƒÎµÎ¹. Î‘Î»Î»Î¬, Î±Î½ Ï„Î¿ prev\_size Î´Î¹Î±Ï†Î­ÏÎµÎ¹ Î±Ï€ÏŒ Ï„Î¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚ Ï€Î¿Ï… Ï…Ï€Î¿Î´ÎµÎ¹ÎºÎ½ÏÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

{% hint style="success" %}
ÎœÎ¬Î¸ÎµÏ„Îµ & ÎµÎ¾Î±ÏƒÎºÎ·Î¸ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ Hacking Ï„Î¿Ï… AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Î•ÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ· HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
ÎœÎ¬Î¸ÎµÏ„Îµ & ÎµÎ¾Î±ÏƒÎºÎ·Î¸ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ Hacking Ï„Î¿Ï… GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Î•ÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ· HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Î¥Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¾Ï„Îµ Ï„Î¿ HackTricks</summary>

* Î•Î»Î­Î³Î¾Ï„Îµ Ï„Î± [**ÏƒÏ‡Î­Î´Î¹Î± ÏƒÏ…Î½Î´ÏÎ¿Î¼Î®Ï‚**](https://github.com/sponsors/carlospolop)!
* **Î•Î³Î³ÏÎ±Ï†ÎµÎ¯Ï„Îµ** ğŸ’¬ ÏƒÏ„Î·Î½ [**Î¿Î¼Î¬Î´Î± Discord**](https://discord.gg/hRep4RUj7f) Î® ÏƒÏ„Î·Î½ [**Î¿Î¼Î¬Î´Î± telegram**](https://t.me/peass) Î® **Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÏ„Îµ** Î¼Î±Ï‚ ÏƒÏ„Î¿ **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **ÎœÎ¿Î¹ÏÎ±ÏƒÏ„ÎµÎ¯Ï„Îµ ÎºÏŒÎ»Ï€Î± hacking Ï…Ï€Î¿Î²Î¬Î»Î»Î¿Î½Ï„Î±Ï‚ PRs ÏƒÏ„Î±** [**HackTricks**](https://github.com/carlospolop/hacktricks) ÎºÎ±Î¹ [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Î±Ï€Î¿Î¸ÎµÏ„Î®ÏÎ¹Î± ÏƒÏ„Î¿ GitHub.

</details>
{% endhint %}
