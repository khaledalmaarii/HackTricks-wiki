# рдлреНрд░реА

<details>

<summary><strong>рдЬрд╛рдиреЗрдВ AWS рд╣реИрдХрд┐рдВрдЧ рдХреЛ рд╢реВрдиреНрдп рд╕реЗ рд╣реАрд░реЛ рддрдХ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> рдХреЗ рд╕рд╛рде!</strong></summary>

HackTricks рдХрд╛ рд╕рдорд░реНрдерди рдХрд░рдиреЗ рдХреЗ рдЕрдиреНрдп рддрд░реАрдХреЗ:

* рдЕрдЧрд░ рдЖрдк рдЕрдкрдиреА **рдХрдВрдкрдиреА рдХрд╛ рд╡рд┐рдЬреНрдЮрд╛рдкрди HackTricks рдореЗрдВ рджреЗрдЦрдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ** рдпрд╛ **HackTricks рдХреЛ PDF рдореЗрдВ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ** рддреЛ [**рд╕рдмреНрд╕рдХреНрд░рд┐рдкреНрд╢рди рдкреНрд▓рд╛рдиреНрд╕ рджреЗрдЦреЗрдВ**](https://github.com/sponsors/carlospolop)!
* [**рдЖрдзрд┐рдХрд╛рд░рд┐рдХ PEASS рдФрд░ HackTricks рд╕реНрд╡реИрдЧ**](https://peass.creator-spring.com) рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ
* рд╣рдорд╛рд░реЗ рд╡рд┐рд╢реЗрд╖ [**NFTs**](https://opensea.io/collection/the-peass-family) рдХрд▓реЗрдХреНрд╢рди, [**The PEASS Family**](https://opensea.io/collection/the-peass-family) рдЦреЛрдЬреЗрдВ
* **рд╢рд╛рдорд┐рд▓ рд╣реЛрдВ** ЁЯТм [**рдбрд┐рд╕реНрдХреЙрд░реНрдб рд╕рдореВрд╣**](https://discord.gg/hRep4RUj7f) рдпрд╛ [**рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рд╕рдореВрд╣**](https://t.me/peass) рдФрд░ **рд╣рдореЗрдВ** **рдЯреНрд╡рд┐рдЯрд░** ЁЯРж [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** рдкрд░ рдлреЙрд▓реЛ** рдХрд░реЗрдВред
* **рд╣реИрдХрд┐рдВрдЧ рдЯреНрд░рд┐рдХреНрд╕ рд╕рд╛рдЭрд╛ рдХрд░реЗрдВ рдФрд░ PRs рд╕рдмрдорд┐рдЯ рдХрд░рдХреЗ** [**HackTricks**](https://github.com/carlospolop/hacktricks) рдФрд░ [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos рдореЗрдВред

</details>

## рдлреНрд░реА рдСрд░реНрдбрд░ рд╕рд╛рд░рд╛рдВрд╢ <a href="#libc_free" id="libc_free"></a>

(рдЗрд╕ рд╕рд╛рд░рд╛рдВрд╢ рдореЗрдВ рдХреЛрдИ рдЬрд╛рдВрдЪ рдирд╣реАрдВ рдХреА рдЧрдИ рд╣реИ рдФрд░ рдХреБрдЫ рдорд╛рдорд▓реЗ рд╕рдВрдХреНрд╖реЗрдк рдХреЗ рд▓рд┐рдП рдЫреЛрдбрд╝ рджрд┐рдП рдЧрдП рд╣реИрдВ)

1. рдпрджрд┐ рдкрддрд╛ рд╢реВрдиреНрдп рд╣реИ рддреЛ рдХреБрдЫ рди рдХрд░реЗрдВ
2. рдпрджрд┐ рдЪрдВрдХ mmaped рдерд╛, рддреЛ рдЙрд╕реЗ mummap рдХрд░реЗрдВ рдФрд░ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ
3. `_int_free` рдХреЛ рдХреЙрд▓ рдХрд░реЗрдВ:
1. рдпрджрд┐ рд╕рдВрднрд╡ рд╣реЛ, рдЪрдВрдХ рдХреЛ tcache рдореЗрдВ рдЬреЛрдбрд╝реЗрдВ
2. рдпрджрд┐ рд╕рдВрднрд╡ рд╣реЛ, рдЪрдВрдХ рдХреЛ рдлрд╛рд╕реНрдЯ рдмрд┐рди рдореЗрдВ рдЬреЛрдбрд╝реЗрдВ
3. рдЪрдВрдХ рдХреЛ рд╕рдВрдпреЛрдЬрд┐рдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП `_int_free_merge_chunk` рдХреЛ рдХреЙрд▓ рдХрд░реЗрдВ рдпрджрд┐ рдЖрд╡рд╢реНрдпрдХ рд╣реЛ рдФрд░ рдЗрд╕реЗ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рд╕реВрдЪреА рдореЗрдВ рдЬреЛрдбрд╝реЗрдВ

## \_\_libc\_free <a href="#libc_free" id="libc_free"></a>

`Free` `__libc_free` рдХреЛ рдХреЙрд▓ рдХрд░рддрд╛ рд╣реИред

* рдпрджрд┐ рдкрд╛рд░рд┐рдд рдкрддрд╛ рд╢реВрдиреНрдп (0) рд╣реИ рддреЛ рдХреБрдЫ рди рдХрд░реЗрдВред
* рдкреЙрдЗрдВрдЯрд░ рдЯреИрдЧ рдХреА рдЬрд╛рдВрдЪ рдХрд░реЗрдВ
* рдпрджрд┐ рдЪрдВрдХ `mmaped` рд╣реИ, рддреЛ рдЙрд╕реЗ `mummap` рдХрд░реЗрдВ рдФрд░ рдЙрд╕рдХрд╛ рд╕рдорд╛рдкрди рдХрд░реЗрдВ
* рдЕрдЧрд░ рдирд╣реАрдВ, рд░рдВрдЧ рдЬреЛрдбрд╝реЗрдВ рдФрд░ рдЙрд╕ рдкрд░ `_int_free` рдХреЙрд▓ рдХрд░реЗрдВ

<details>

<summary>__lib_free рдХреЛрдб</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## \_int\_free <a href="#int_free" id="int_free"></a>

### \_int\_free рдкреНрд░рд╛рд░рдВрдн <a href="#int_free" id="int_free"></a>

рдпрд╣ рдХреБрдЫ рдЬрд╛рдВрдЪреЛрдВ рдХреЗ рд╕рд╛рде рд╢реБрд░реВ рд╣реЛрддрд╛ рд╣реИ рдЬреЛ рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░рддреЗ рд╣реИрдВ:

* **рдкреЙрдЗрдВрдЯрд░** **рдПрд▓рд╛рдЗрди** рд╣реИ, рдпрд╛ рддреНрд░реБрдЯрд┐ рдХреЛ рдЯреНрд░рд┐рдЧрд░ рдХрд░рддрд╛ рд╣реИ `free(): invalid pointer`
* **рд╕рд╛рдЗрдЬ** рдиреНрдпреВрдирддрдо рд╕реЗ рдХрдо рдирд╣реАрдВ рд╣реИ рдФрд░ рдЙрд╕рдХрд╛ **рд╕рд╛рдЗрдЬ** рднреА **рдПрд▓рд╛рдЗрди** рд╣реИ, рдпрд╛ рддреНрд░рд┐рдЧрд░ рддреНрд░реБрдЯрд┐: `free(): invalid size`

<details>

<summary>_int_free рдкреНрд░рд╛рд░рдВрдн</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### \_int\_free tcache <a href="#int_free" id="int_free"></a>

рдпрд╣ рдкрд╣рд▓реЗ рд╕рдВрдмрдВрдзрд┐рдд tcache рдореЗрдВ рдЗрд╕ рдЪрдВрдХ рдХреЛ рдЖрд╡рдВрдЯрд┐рдд рдХрд░рдиреЗ рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдЧрд╛ред рд╣рд╛рд▓рд╛рдВрдХрд┐, рдХреБрдЫ рдЬрд╛рдВрдЪреЗрдВ рдкрд╣рд▓реЗ рд╣реА рдХреА рдЬрд╛рддреА рд╣реИрдВред рдпрд╣ рдЙрд╕реА рдЗрдВрдбреЗрдХреНрд╕ рдореЗрдВ tcache рдХреЗ рд╕рднреА рдЪрдВрдХреНрд╕ рдХреЗ рдорд╛рдзреНрдпрдо рд╕реЗ рд▓реВрдк рдХрд░реЗрдЧрд╛ рдЬреИрд╕рд╛ рдХрд┐ рдореБрдХреНрдд рдЪрдВрдХ рд╣реИ рдФрд░:

* рдпрджрд┐ `mp_.tcache_count` рд╕реЗ рдЕрдзрд┐рдХ рдкреНрд░рд╡рд┐рд╖реНрдЯрд┐рдпрд╛рдБ рд╣реИрдВ: `free(): too many chunks detected in tcache`
* рдпрджрд┐ рдкреНрд░рд╡рд┐рд╖реНрдЯрд┐ рд╕рдВрд░реЗрдЦрд┐рдд рдирд╣реАрдВ рд╣реИ: `free(): unaligned chunk detected in tcache 2`
* рдпрджрд┐ рдореБрдХреНрдд рдЪрдВрдХ рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдореБрдХреНрдд рдХрд┐рдпрд╛ рдЧрдпрд╛ рдерд╛ рдФрд░ tcache рдореЗрдВ рдЪрдВрдХ рдХреЗ рд░реВрдк рдореЗрдВ рдореМрдЬреВрдж рд╣реИ: `free(): double free detected in tcache 2`

рдпрджрд┐ рд╕рдм рдХреБрдЫ рдареАрдХ рдЪрд▓рддрд╛ рд╣реИ, рддреЛ рдЪрдВрдХ рдХреЛ tcache рдореЗрдВ рдЬреЛрдбрд╝ рджрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИ рдФрд░ рдлрд╝рдВрдХреНрд╢рди рд╡рд╛рдкрд╕ рд▓реМрдЯрддрд╛ рд╣реИред

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### \_int\_free рдлрд╛рд╕реНрдЯ рдмрд┐рди <a href="#int_free" id="int_free"></a>

рд╢реБрд░реВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдпрд╣ рдЬрд╛рдВрдЪреЗрдВ рдХрд┐ рдЖрдХрд╛рд░ рдлрд╛рд╕реНрдЯ рдмрд┐рди рдХреЗ рд▓рд┐рдП рдЙрдкрдпреБрдХреНрдд рд╣реИ рдФрд░ рдпрд╣ рдЬрд╛рдВрдЪреЗрдВ рдХрд┐ рдпрд╣ рд╢реАрд░реНрд╖ рдЪрдВрдХ рдХреЗ рдкрд╛рд╕ рд╕реЗрдЯ рдХрд░рдирд╛ рд╕рдВрднрд╡ рд╣реИред

рдлрд┐рд░, рдХреБрдЫ рдЬрд╛рдВрдЪреЗрдВ рдХрд░рддреЗ рд╣реБрдП рдлрд╛рд╕реНрдЯ рдмрд┐рди рдХреЗ рд╢реАрд░реНрд╖ рдкрд░ рдореБрдХреНрдд рдЪрдВрдХ рдЬреЛрдбрд╝реЗрдВ:

* рдпрджрд┐ рдЪрдВрдХ рдХрд╛ рдЖрдХрд╛рд░ рдЕрд╡реИрдз рд╣реИ (рдмрд╣реБрдд рдмрдбрд╝рд╛ рдпрд╛ рдЫреЛрдЯрд╛) рддреЛ рдЯреНрд░рд┐рдЧрд░ рдХрд░реЗрдВ: `free(): invalid next size (fast)`
* рдпрджрд┐ рдЬреЛрдбрд╝реЗ рдЧрдП рдЪрдВрдХ рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдлрд╛рд╕реНрдЯ рдмрд┐рди рдХреЗ рд╢реАрд░реНрд╖ рдкрд░ рдерд╛: `double free or corruption (fasttop)`
* рдпрджрд┐ рд╢реАрд░реНрд╖ рдкрд░ рдЪрдВрдХ рдХрд╛ рдЖрдХрд╛рд░ рдЬреЛрдбрд╝реЗ рдЧрдП рдЪрдВрдХ рдХреЗ рдЖрдХрд╛рд░ рд╕реЗ рднрд┐рдиреНрди рд╣реИ: `invalid fastbin entry (free)`

<details>

<summary>_int_free рдлрд╛рд╕реНрдЯ рдмрд┐рди</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
### \_int\_free рд╕рдорд╛рдкреНрддрд┐ <a href="#int_free" id="int_free"></a>

рдпрджрд┐ рдЪрдВрдХ рдЕрдм рддрдХ рдХрд┐рд╕реА рднреА рдмрд┐рди рдкрд░ рдЖрд╡рдВрдЯрд┐рдд рдирд╣реАрдВ рд╣реБрдЖ рдерд╛, рддреЛ `_int_free_merge_chunk` рдХреЛ рдХреЙрд▓ рдХрд░реЗрдВ
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## \_int\_free\_merge\_chunk

рдпрд╣ рдлрд╝рдВрдХреНрд╢рди рдЪрдВрдХ P рдХреЛ SIZE рдмрд╛рдЗрдЯ рдХреЗ рд╕рд╛рде рдЙрд╕рдХреЗ рдкрдбрд╝реЛрд╕рд┐рдпреЛрдВ рдХреЗ рд╕рд╛рде рдорд░реНрдЬ рдХрд░рдиреЗ рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдЧрд╛ред рдкрд░рд┐рдгрд╛рдореА рдЪрдВрдХ рдХреЛ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рд╕реВрдЪреА рдкрд░ рдбрд╛рд▓реЗрдВред

рдХреБрдЫ рдЬрд╛рдВрдЪреЗрдВ рдХреА рдЬрд╛рддреА рд╣реИрдВ:

* рдпрджрд┐ рдЪрдВрдХ рдЯреЙрдк рдЪрдВрдХ рд╣реИ: `double free or corruption (top)`
* рдпрджрд┐ рдЕрдЧрд▓рд╛ рдЪрдВрдХ рдПрд░реАрдирд╛ рдХреА рд╕реАрдорд╛рдУрдВ рдХреЗ рдмрд╛рд╣рд░ рд╣реИ: `double free or corruption (out)`
* рдпрджрд┐ рдЪрдВрдХ рдХреЛ рдЙрдкрдпреЛрдЧ рдХреЗ рд░реВрдк рдореЗрдВ рдЪрд┐рд╣реНрдирд┐рдд рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИ (рдЕрдЧрд▓реЗ рдЪрдВрдХ рд╕реЗ `prev_inuse` рдореЗрдВ): `double free or corruption (!prev)`
* рдпрджрд┐ рдЕрдЧрд▓рд╛ рдЪрдВрдХ рдХрд╛ рдЖрдХрд╛рд░ рдмрд╣реБрдд рдХрдо рд╣реИ рдпрд╛ рдмрд╣реБрдд рдмрдбрд╝рд╛ рд╣реИ: `free(): invalid next size (normal)`
* рдпрджрд┐ рдкрд┐рдЫрд▓рд╛ рдЪрдВрдХ рдЙрдкрдпреЛрдЧ рдореЗрдВ рдирд╣реАрдВ рд╣реИ, рддреЛ рдпрд╣ рд╕рдореЗрдХрд┐рдд рдХрд░рдиреЗ рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдЧрд╛ред рд▓реЗрдХрд┐рди, рдпрджрд┐ рдкрд┐рдЫрд▓реЗ рдЪрдВрдХ рдореЗрдВ рджрд┐рдЦрд╛рдП рдЧрдП рдЖрдХрд╛рд░ рд╕реЗ рдкрд┐рдЫрд▓реЗ рдЪрдВрдХ рдореЗрдВ рджрд┐рдЦрд╛рдП рдЧрдП рдЖрдХрд╛рд░ рдореЗрдВ рдЕрдВрддрд░ рд╣реИ: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

<details>

<summary><strong>рдЬрд╛рдиреЗрдВ AWS рд╣реИрдХрд┐рдВрдЧ рдХреЛ рд╢реВрдиреНрдп рд╕реЗ рд╣реАрд░реЛ рддрдХ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

рджреВрд╕рд░реЗ рддрд░реАрдХреЗ HackTricks рдХрд╛ рд╕рдорд░реНрдерди рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП:

* рдЕрдЧрд░ рдЖрдк рдЕрдкрдиреА **рдХрдВрдкрдиреА рдХрд╛ рд╡рд┐рдЬреНрдЮрд╛рдкрди HackTricks рдореЗрдВ рджреЗрдЦрдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ** рдпрд╛ **HackTricks рдХреЛ PDF рдореЗрдВ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ** рддреЛ [**рд╕рдмреНрд╕рдХреНрд░рд┐рдкреНрд╢рди рдкреНрд▓рд╛рдиреНрд╕**](https://github.com/sponsors/carlospolop) рджреЗрдЦреЗрдВ!
* [**рдЖрдзрд┐рдХрд╛рд░рд┐рдХ PEASS & HackTricks рд╕реНрд╡реИрдЧ**](https://peass.creator-spring.com) рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ
* рд╣рдорд╛рд░реЗ рд╡рд┐рд╢реЗрд╖ [**NFTs**](https://opensea.io/collection/the-peass-family) рд╕рдВрдЧреНрд░рд╣ **The PEASS Family** рдХреА рдЦреЛрдЬ рдХрд░реЗрдВ
* **рд╢рд╛рдорд┐рд▓ рд╣реЛрдВ** ЁЯТм [**рдбрд┐рд╕реНрдХреЙрд░реНрдб рд╕рдореВрд╣**](https://discord.gg/hRep4RUj7f) рдпрд╛ [**рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рд╕рдореВрд╣**](https://t.me/peass) **рдпрд╛ рд╣рдореЗрдВ** **рдЯреНрд╡рд┐рдЯрд░** ЁЯРж [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** рдкрд░ рдлреЙрд▓реЛ** рдХрд░реЗрдВред
* **рдЕрдкрдиреЗ рд╣реИрдХрд┐рдВрдЧ рдЯреНрд░рд┐рдХреНрд╕ рд╕рд╛рдЭрд╛ рдХрд░реЗрдВ** рджреНрд╡рд╛рд░рд╛ PRs рд╕рдмрдорд┐рдЯ рдХрд░рдХреЗ [**HackTricks**](https://github.com/carlospolop/hacktricks) рдФрд░ [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos рдореЗрдВред

</details>
