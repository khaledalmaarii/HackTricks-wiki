# Sprawdzanie bezpieczestwa funkcji sterty

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) albo **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## unlink

Wicej informacji znajdziesz pod adresem:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

To podsumowanie przeprowadzonych kontroli:

* Sprawd藕, czy wskazany rozmiar fragmentu jest taki sam jak `prev_size` wskazany w nastpnym fragmencie
* Komunikat bdu: `corrupted size vs. prev_size`
* Sprawd藕 r贸wnie偶, czy `P->fd->bk == P` i `P->bk->fw == P`
* Komunikat bdu: `corrupted double-linked list`
* Jeli fragment nie jest may, sprawd藕, czy `P->fd_nextsize->bk_nextsize == P` i `P->bk_nextsize->fd_nextsize == P`
* Komunikat bdu: `corrupted double-linked list (not small)`

## \_int\_malloc

Wicej informacji znajdziesz pod adresem:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Kontrole podczas wyszukiwania w fast bin:**
* Jeli fragment jest 藕le wyr贸wnany:
* Komunikat bdu: `malloc(): unaligned fastbin chunk detected 2`
* Jeli nastpny fragment jest 藕le wyr贸wnany:
* Komunikat bdu: `malloc(): unaligned fastbin chunk detected`
* Jeli zwr贸cony fragment ma nieprawidowy rozmiar z powodu jego indeksu w fast bin:
* Komunikat bdu: `malloc(): memory corruption (fast)`
* Jeli kt贸rykolwiek fragment u偶yty do wypenienia tcache jest 藕le wyr贸wnany:
* Komunikat bdu: `malloc(): unaligned fastbin chunk detected 3`
* **Kontrole podczas wyszukiwania w small bin:**
* Jeli `victim->bk->fd != victim`:
* Komunikat bdu: `malloc(): smallbin double linked list corrupted`
* **Kontrole podczas konsolidacji** wykonywane dla ka偶dego fragmentu fast bin:&#x20;
* Jeli fragment jest 藕le wyr贸wnany, wywoaj:
* Komunikat bdu: `malloc_consolidate(): unaligned fastbin chunk detected`
* Jeli fragment ma inny rozmiar ni偶 powinien z powodu indeksu, w kt贸rym si znajduje:
* Komunikat bdu: `malloc_consolidate(): invalid chunk size`
* Jeli poprzedni fragment nie jest u偶ywany, a poprzedni fragment ma inny rozmiar ni偶 wskazany przez prev\_chunk:
* Komunikat bdu: `corrupted size vs. prev_size in fastbins`
* **Kontrole podczas wyszukiwania w unsorted bin**:
* Jeli rozmiar fragmentu jest dziwny (za may lub za du偶y):&#x20;
* Komunikat bdu: `malloc(): invalid size (unsorted)`
* Jeli rozmiar nastpnego fragmentu jest dziwny (za may lub za du偶y):
* Komunikat bdu: `malloc(): invalid next size (unsorted)`
* Jeli rozmiar poprzedni wskazany przez nastpny fragment r贸偶ni si od rozmiaru fragmentu:
* Komunikat bdu: `malloc(): mismatching next->prev_size (unsorted)`
* Jeli nie `victim->bck->fd == victim` lub nie `victim->fd == av (arena)`:
* Komunikat bdu: `malloc(): unsorted double linked list corrupted`
* Poniewa偶 zawsze sprawdzamy ostatni, jego fd powinien zawsze wskazywa na struktur areny.
* Jeli nastpny fragment nie wskazuje, 偶e poprzedni jest u偶ywany:
* Komunikat bdu: `malloc(): invalid next->prev_inuse (unsorted)`
* Jeli `fwd->bk_nextsize->fd_nextsize != fwd`:
* Komunikat bdu: `malloc(): largebin double linked list corrupted (nextsize)`
* Jeli `fwd->bk->fd != fwd`:
* Komunikat bdu: `malloc(): largebin double linked list corrupted (bk)`
* **Kontrole podczas wyszukiwania w large bin (wedug indeksu):**
* `bck->fd-> bk != bck`:
* Komunikat bdu: `malloc(): corrupted unsorted chunks`
* **Kontrole podczas wyszukiwania w large bin (nastpnie wikszy):**
* `bck->fd-> bk != bck`:
* Komunikat bdu: `malloc(): corrupted unsorted chunks2`
* **Kontrole podczas u偶ycia Top chunk:**
* `chunksize(av->top) > av->system_mem`:
* Komunikat bdu: `malloc(): corrupted top size`

## `tcache_get_n`

* **Kontrole w `tcache_get_n`:**
* Jeli fragment jest 藕le wyr贸wnany:
* Komunikat bdu: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **Kontrole w `tcache_thread_shutdown`:**
* Jeli fragment jest 藕le wyr贸wnany:
* Komunikat bdu: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **Kontrole w `__libc_realloc`:**
* Jeli stary wska藕nik jest 藕le wyr贸wnany lub rozmiar by nieprawidowy:
* Komunikat bdu: `realloc(): invalid pointer`

## `_int_free`

Wicej informacji znajdziesz pod adresem:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Kontrole na pocztku `_int_free`:**
* Wska藕nik jest wyr贸wnany:
* Komunikat bdu: `free(): invalid pointer`
* Rozmiar wikszy ni偶 `MINSIZE` i r贸wnie偶 wyr贸wnany:
* Komunikat bdu: `free(): invalid size`
* **Kontrole w tcache `_int_free`:**
* Jeli jest wicej wpis贸w ni偶 `mp_.tcache_count`:
* Komunikat bdu: `free(): too many chunks detected in tcache`
* Jeli wpis nie jest wyr贸wnany:
* Komunikat bdu: `free(): unaligned chunk detected in tcache 2`
* Jeli zwolniony fragment by ju偶 zwolniony i jest obecny jako fragment w tcache:
* Komunikat bdu: `free(): double free detected in tcache 2`
* **Kontrole w fast bin `_int_free`:**
* Jeli rozmiar fragmentu jest nieprawidowy (za du偶y lub za may), wywoaj:
* Komunikat bdu: `free(): invalid next size (fast)`
* Jeli dodany fragment by ju偶 na szczycie fast bin:
* Komunikat bdu: `double free or corruption (fasttop)`
* Jeli rozmiar fragmentu na szczycie ma inny rozmiar ni偶 dodawany fragment:
* Komunikat bdu: `invalid fastbin entry (free)`
## **`_int_free_merge_chunk`**

* **Sprawdzenia w `_int_free_merge_chunk`:**
* Jeli kawaek jest kawakiem g贸rnym:
* Komunikat bdu: `double free or corruption (top)`
* Jeli nastpny kawaek znajduje si poza granicami areny:
* Komunikat bdu: `double free or corruption (out)`
* Jeli kawaek nie jest oznaczony jako u偶ywany (w prev\_inuse z nastpnego kawaka):
* Komunikat bdu: `double free or corruption (!prev)`
* Jeli nastpny kawaek ma zbyt may lub zbyt du偶y rozmiar:
* Komunikat bdu: `free(): invalid next size (normal)`
* Jeli poprzedni kawaek nie jest u偶ywany, zostanie podjta pr贸ba konsolidacji. Jednak jeli `prev_size` r贸偶ni si od rozmiaru wskazanego w poprzednim kawaku:
* Komunikat bdu: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **Sprawdzenia w `_int_free_create_chunk`:**
* Dodajc kawaek do nieuporzdkowanego kubeka, sprawd藕, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Komunikat bdu: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **Sprawdzenia w `do_check_malloc_state`:**
* Jeli kawaek fast bin jest 藕le wyr贸wnany:
* Komunikat bdu: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **Sprawdzenia w `malloc_consolidate`:**
* Jeli kawaek fast bin jest 藕le wyr贸wnany:
* Komunikat bdu: `malloc_consolidate(): unaligned fastbin chunk detected`
* Jeli nieprawidowy rozmiar kawaka fast bin:
* Komunikat bdu: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **Sprawdzenia w `_int_realloc`:**
* Rozmiar jest zbyt du偶y lub zbyt may:
* Komunikat bdu: `realloc(): invalid old size`
* Rozmiar nastpnego kawaka jest zbyt du偶y lub zbyt may:
* Komunikat bdu: `realloc(): invalid next size`
