# Heap Overflow

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Ein Heap Overflow ist wie ein [**Stack Overflow**](../stack-overflow/), aber im Heap. Grunds√§tzlich bedeutet dies, dass im Heap etwas Platz reserviert wurde, um einige Daten zu speichern und **die gespeicherten Daten gr√∂√üer waren als der reservierte Platz**.

Bei Stack Overflows wissen wir, dass einige Register wie der Instruktionszeiger oder der Stackrahmen vom Stack wiederhergestellt werden und es m√∂glich sein k√∂nnte, dies auszunutzen. Im Falle von Heap Overflows **wird standardm√§√üig keine sensible Information** im Heap-Chunk gespeichert, der √ºberlaufen werden kann. Es k√∂nnte jedoch sensible Informationen oder Zeiger geben, daher h√§ngt die **Kritikalit√§t** dieser Schwachstelle davon ab, **welche Daten √ºberschrieben werden k√∂nnen** und wie ein Angreifer dies ausnutzen k√∂nnte.

{% hint style="success" %}
Um √úberlauf-Offsets zu finden, k√∂nnen Sie dieselben Muster wie bei [**Stack Overflows**](../stack-overflow/#finding-stack-overflows-offsets) verwenden.
{% endhint %}

### Stack Overflows vs. Heap Overflows

Bei Stack Overflows ist die Anordnung und die Daten, die zum Zeitpunkt auftreten, an dem die Schwachstelle ausgel√∂st werden kann, im Stack ziemlich zuverl√§ssig. Dies liegt daran, dass der Stack linear ist, sich immer in kollidierendem Speicher erh√∂ht, an **spezifischen Stellen des Programmablaufs der Stackspeicher normalerweise √§hnliche Daten speichert** und eine spezifische Struktur mit einigen Zeigern am Ende des Stackteils hat, die von jeder Funktion verwendet werden.

Im Falle eines Heap Overflows sind die verwendeten Speicherbereiche jedoch nicht linear, sondern **die allokierten Chunks sind normalerweise an getrennten Speicherpositionen** (nicht nebeneinander) aufgrund von **Bins und Zonen**, die Allokationen nach Gr√∂√üe trennen, und weil **zuvor freigegebener Speicher verwendet wird**, bevor neue Chunks allokiert werden. Es ist **kompliziert zu wissen, welches Objekt mit dem √ºberlaufenden Objekt kollidieren wird**. Daher muss, wenn ein Heap Overflow gefunden wird, ein **zuverl√§ssiger Weg gefunden werden, um das gew√ºnschte Objekt direkt im Speicher neben dem √ºberlaufenden Objekt zu platzieren**.

Eine der Techniken, die daf√ºr verwendet wird, ist **Heap Grooming**, die beispielsweise [**in diesem Beitrag**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) verwendet wird. Im Beitrag wird erkl√§rt, wie im iOS-Kernel, wenn eine Zone keinen Speicher mehr zum Speichern von Speicherchunks hat, sie um eine Kernelseite erweitert wird, und diese Seite in Chunks der erwarteten Gr√∂√üen aufgeteilt wird, die in aufeinanderfolgender Reihenfolge verwendet werden (bis iOS-Version 9.2, dann werden diese Chunks auf eine randomisierte Weise verwendet, um die Ausnutzung dieser Angriffe zu erschweren).

Daher, in dem vorherigen Beitrag, in dem ein Heap Overflow auftritt, m√ºssen mehrere **`kallocs` durch mehrere Threads erzwungen werden, um sicherzustellen, dass alle freien Chunks gef√ºllt sind und dass eine neue Seite erstellt wird**.

Um diese F√ºllung mit Objekten einer bestimmten Gr√∂√üe zu erzwingen, ist die **Out-of-Line-Allokation, die mit einem iOS-Mach-Port verbunden ist**, ein idealer Kandidat. Durch die Gestaltung der Gr√∂√üe der Nachricht ist es m√∂glich, die Gr√∂√üe der `kalloc`-Allokation genau zu spezifizieren, und wenn der entsprechende Mach-Port zerst√∂rt wird, wird die entsprechende Allokation sofort wieder an `kfree` freigegeben.

Dann k√∂nnen einige dieser Platzhalter **freigegeben** werden. Die **`kalloc.4096`-Freiliste gibt Elemente in einer Last-In-First-Out-Reihenfolge frei**, was im Grunde bedeutet, dass wenn einige Platzhalter freigegeben werden und der Exploit versucht, mehrere Opferobjekte zu allozieren, w√§hrend versucht wird, das Objekt, das anf√§llig f√ºr √úberlauf ist, zu allozieren, ist es wahrscheinlich, dass dieses Objekt von einem Opferobjekt gefolgt wird.

### Beispiel libc

[**Auf dieser Seite**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) ist es m√∂glich, eine grundlegende Emulation eines Heap Overflows zu finden, die zeigt, wie durch √úberschreiben des prev-in-use-Bits des n√§chsten Chunks und der Position der prev-Gr√∂√üe ein benutzter Chunk **konsolidiert werden kann** (indem er denkt, er sei unbenutzt) und **dann erneut allokiert** werden kann, wodurch Daten √ºberschrieben werden, die in einem anderen Zeiger verwendet werden.

Ein weiteres Beispiel von [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) zeigt ein sehr einfaches Beispiel eines CTF, bei dem ein **Heap Overflow** missbraucht werden kann, um die Gewinnerfunktion aufzurufen und die Flagge zu erhalten.

Im [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) Beispiel ist es m√∂glich zu sehen, wie durch Ausnutzen eines Puffer√ºberlaufs es m√∂glich ist, **in einem nahegelegenen Chunk eine Adresse zu √ºberschreiben**, an der **beliebige Daten vom Benutzer** geschrieben werden sollen.

### Beispiel ARM64

Auf der Seite [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) finden Sie ein Beispiel f√ºr einen Heap Overflow, bei dem ein Befehl, der ausgef√ºhrt werden soll, im folgenden Chunk vom √ºberlaufenen Chunk gespeichert ist. Daher ist es m√∂glich, den ausgef√ºhrten Befehl zu √§ndern, indem er mit einem einfachen Exploit √ºberschrieben wird, wie z.B.:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
