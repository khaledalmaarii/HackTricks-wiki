# Υπερχείλιση Σωρού

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Η υπερχείλιση σωρού είναι σαν μια [**υπερχείλιση στοίβας**](../stack-overflow/) αλλά στο σωρό. Βασικά σημαίνει ότι κάποιος χώρος είχε διατεθεί στο σωρό για να αποθηκεύσει κάποια δεδομένα και **τα αποθηκευμένα δεδομένα ήταν μεγαλύτερα από τον διατεθείσα χώρο.**

Στις υπερχειλίσεις στοίβας γνωρίζουμε ότι κάποιοι καταχωρητές όπως ο δείκτης εντολών ή το πλαίσιο στοίβας θα αποκατασταθούν από τη στοίβα και θα μπορούσε να είναι δυνατό να εκμεταλλευτεί αυτό κάποιος. Στην περίπτωση των υπερχειλίσεων σωρού, **δεν υπάρχει καμία ευαίσθητη πληροφορία που αποθηκεύεται από προεπιλογή** στο κομμάτι του σωρού που μπορεί να υπερχειλιστεί. Ωστόσο, θα μπορούσε να είναι ευαίσθητες πληροφορίες ή δείκτες, οπότε η **κρισιμότητα** αυτής της ευπάθειας **εξαρτάται** από το **ποια δεδομένα μπορούν να αντικατασταθούν** και πώς μπορεί ένας επιτιθέμενος να εκμεταλλευτεί αυτό.

{% hint style="success" %}
Για να βρείτε τις μετατοπίσεις υπερχείλισης μπορείτε να χρησιμοποιήσετε τα ίδια πρότυπα όπως στις [**υπερχειλίσεις στοίβας**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Υπερχειλίσεις Στοίβας έναντι Υπερχειλίσεων Σωρού

Στις υπερχειλίσεις στοίβας η διάταξη και τα δεδομένα που θα υπάρχουν στη στοίβα τη στιγμή που μπορεί να ενεργοποιηθεί η ευπάθεια είναι αρκετά αξιόπιστα. Αυτό οφείλεται στο γεγονός ότι η στοίβα είναι γραμμική, αυξάνεται πάντα σε συγκρούουσα μνήμη, σε **συγκεκριμένα σημεία της εκτέλεσης του προγράμματος η μνήμη στοίβας αποθηκεύει συνήθως παρόμοιου είδους δεδομένα** και έχει μια συγκεκριμένη δομή με ορισμένους δείκτες στο τέλος του τμήματος στοίβας που χρησιμοποιείται από κάθε συνάρτηση.

Ωστόσο, στην περίπτωση μιας υπερχείλισης σωρού, η χρησιμοποιούμενη μνήμη δεν είναι γραμμική αλλά **οι εκχωρημένες χούνκες είναι συνήθως σε ξεχωρισμένες θέσεις μνήμης** (όχι μία δίπλα στην άλλη) λόγω των **κάδων και ζωνών** που χωρίζουν τις εκχωρήσεις ανά μέγεθος και επειδή **η προηγούμενη ελευθέρωση μνήμης χρησιμοποιείται** πριν από την εκχώρηση νέων χούνκων. Είναι **περίπλοκο να γνωρίζουμε το αντικείμενο που θα συγκρουστεί με το ευάλωτο αντικείμενο** σε μια υπερχείλιση σωρού. Έτσι, όταν βρεθεί μια υπερχείλιση σωρού, είναι απαραίτητο να βρεθεί ένας **αξιόπιστος τρόπος για να το επιθυμητό αντικείμενο να είναι το επόμενο στη μνήμη** από αυτό που μπορεί να υπερχειλιστεί.

Ένας από τους τεχνικές που χρησιμοποιούνται γι' αυτό είναι η **Διαμόρφωση Σωρού** που χρησιμοποιείται για παράδειγμα [**σε αυτή την ανάρτηση**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Στην ανάρτηση εξηγείται πώς όταν στο πυρήνα iOS όταν μια ζώνη εξαντλεί τη μνήμη για να αποθηκεύσει χούνκες μνήμης, την επεκτείνει με μια σελίδα πυρήνα, και αυτή η σελίδα διαιρείται σε χούνκες των αναμενόμενων μεγεθών που θα χρησιμοποιηθούν με τη σειρά (μέχρι την έκδοση iOS 9.2, τότε αυτές οι χούνκες χρησιμοποιούνται με τυχαίο τρόπο για να δυσκολέψει η εκμετάλλευση αυτών των επιθέσεων).

Συνεπώς, στην προηγούμενη ανάρτηση όπου συμβαίνει μια υπερχείλιση σωρού, για να αναγκαστεί το υπερχειλισμένο αντικείμενο να συγκρουστεί με ένα αντικείμενο θύμα, αρκετά **`kallocs` είναι αναγκασμένα από αρκετούς νήματα για να εξασφαλίσουν ότι όλες οι ελεύθερες χούνκες είναι γεμάτες και ότι δημιουργείται μια νέα σελίδα**.

Για να αναγκαστεί αυτή η γέμιση με αντικείμενα συγκεκριμένου μεγέθους, η **εκχωρηση εκτός γραμμής που συσχετίζεται με ένα iOS mach port** είναι ένας ιδανικός υποψήφιος. Με τον σχεδιασμό του μεγέθους του μηνύματος, είναι δυνατό να καθοριστεί ακριβώς το μέγεθος της εκχώρησης `kalloc` και όταν το αντίστοιχο mach port καταστραφεί, η αντίστοιχη εκχώρηση θα απελευθερωθεί αμέσως πίσω στο `kfree`.

Στη συνέχεια, μερικά από αυτά τα αντικείμενα μπορούν να **απελευθερωθούν**. Η λίστα ελεύθερωσης **`kalloc.4096` απελευθερώνει στοιχεία με τη σειρά τελευταίο που μπαίνει πρώτο**, που ουσιαστικά σημαίνει ότι αν κάποια σημεία απελευθερωθούν και η εκμετάλλευση προσπαθήσει να εκχωρήσει αρκετά αντικείμενα θύματα ενώ προσπαθεί να εκχωρήσει το ευάλωτο αντικείμενο υπερχείλισης, είναι πιθανό ότι αυτό το αντικείμενο θα ακολουθηθεί από ένα αντικείμεν
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Άλλα παραδείγματα

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Χρησιμοποιούμε μια ευπάθεια Υπερχείλισης Ακεραίων για να πάρουμε μια Υπερχείλιση Σωρού.
* Χαλάμε δείκτες προς μια συνάρτηση μέσα σε ένα `struct` του κομματιού που έχει υπερχειλιστεί για να ορίσουμε μια συνάρτηση όπως το `system` και να πάρουμε εκτέλεση κώδικα.
