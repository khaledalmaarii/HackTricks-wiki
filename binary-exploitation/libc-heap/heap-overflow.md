# Heap Overflow

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

Um heap overflow √© como um [**stack overflow**](../stack-overflow/), mas no heap. Basicamente significa que algum espa√ßo foi reservado no heap para armazenar alguns dados e **os dados armazenados eram maiores do que o espa√ßo reservado**.

Em stack overflows sabemos que alguns registradores como o ponteiro de instru√ß√£o ou o quadro de pilha ser√£o restaurados da pilha e poderia ser poss√≠vel abusar disso. No caso de heap overflows, **n√£o h√° nenhuma informa√ß√£o sens√≠vel armazenada por padr√£o** no peda√ßo de heap que pode ser sobrecarregado. No entanto, poderia ser informa√ß√µes sens√≠veis ou ponteiros, ent√£o a **criticidade** dessa vulnerabilidade **depende** de **quais dados podem ser sobrescritos** e de como um atacante poderia abusar disso.

{% hint style="success" %}
Para encontrar deslocamentos de overflow, voc√™ pode usar os mesmos padr√µes que em [**stack overflows**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stack Overflows vs Heap Overflows

Em stack overflows, a organiza√ß√£o e os dados que estar√£o presentes na pilha no momento em que a vulnerabilidade pode ser acionada s√£o bastante confi√°veis. Isso ocorre porque a pilha √© linear, sempre aumentando em mem√≥ria colidindo, em **lugares espec√≠ficos da execu√ß√£o do programa a mem√≥ria da pilha geralmente armazena um tipo de dados semelhante** e tem uma estrutura espec√≠fica com alguns ponteiros no final da parte da pilha usada por cada fun√ß√£o.

No entanto, no caso de um heap overflow, a mem√≥ria usada n√£o √© linear, mas **os peda√ßos alocados geralmente est√£o em posi√ß√µes separadas da mem√≥ria** (n√£o um ao lado do outro) por causa de **bins e zones** que separam aloca√ß√µes por tamanho e porque **a mem√≥ria anterior liberada √© usada** antes de alocar novos peda√ßos. √â **complicado saber qual objeto vai colidir com o objeto vulner√°vel** a um heap overflow. Portanto, quando um heap overflow √© encontrado, √© necess√°rio encontrar uma **maneira confi√°vel de fazer com que o objeto desejado esteja pr√≥ximo na mem√≥ria** do objeto que pode ser sobrecarregado.

Uma das t√©cnicas usadas para isso √© o **Heap Grooming**, que √© usado, por exemplo, [**neste post**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). No post √© explicado como no kernel do iOS, quando uma zona fica sem mem√≥ria para armazenar peda√ßos de mem√≥ria, ela √© expandida por uma p√°gina do kernel, e esta p√°gina √© dividida em peda√ßos dos tamanhos esperados que seriam usados em ordem (at√© a vers√£o 9.2 do iOS, ent√£o esses peda√ßos s√£o usados de forma randomizada para dificultar a explora√ß√£o desses ataques).

Portanto, no post anterior onde um heap overflow est√° acontecendo, para for√ßar o objeto sobrecarregado a colidir com uma ordem v√≠tima, v√°rios **`kallocs` s√£o for√ßados por v√°rias threads para tentar garantir que todos os peda√ßos livres sejam preenchidos e que uma nova p√°gina seja criada**.

Para for√ßar esse preenchimento com objetos de um tamanho espec√≠fico, a **aloca√ß√£o fora de linha associada a uma porta mach iOS** √© um candidato ideal. Ao criar o tamanho da mensagem, √© poss√≠vel especificar exatamente o tamanho da aloca√ß√£o `kalloc` e quando a porta mach correspondente √© destru√≠da, a aloca√ß√£o correspondente ser√° imediatamente liberada de volta para `kfree`.

Em seguida, alguns desses espa√ßos reservados podem ser **liberados**. A lista de libera√ß√£o **`kalloc.4096` libera elementos em uma ordem de √∫ltimo a entrar, primeiro a sair**, o que basicamente significa que se alguns espa√ßos reservados forem liberados e o exploit tentar alocar v√°rios objetos v√≠timas enquanto tenta alocar o objeto vulner√°vel ao overflow, √© prov√°vel que este objeto seja seguido por um objeto v√≠tima.

### Exemplo libc

[**Nesta p√°gina**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) √© poss√≠vel encontrar uma emula√ß√£o b√°sica de Heap overflow que mostra como sobrescrever o bit prev in use do pr√≥ximo peda√ßo e a posi√ß√£o do tamanho prev √© poss√≠vel **consolidar um peda√ßo usado** (fazendo com que ele pense que est√° n√£o utilizado) e **ent√£o aloc√°-lo novamente** sendo capaz de sobrescrever dados que est√£o sendo usados em um ponteiro diferente tamb√©m.

Outro exemplo de [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) mostra um exemplo muito b√°sico de um CTF onde um **heap overflow** pode ser abusado para chamar a fun√ß√£o vencedora e **obter a bandeira**.

No [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) exemplo √© poss√≠vel ver como abusar de um estouro de buffer √© poss√≠vel **sobrescrever em um peda√ßo pr√≥ximo um endere√ßo** onde **dados arbitr√°rios do usu√°rio** ser√£o escritos.

### Exemplo ARM64

Na p√°gina [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) voc√™ pode encontrar um exemplo de heap overflow onde um comando que ser√° executado √© armazenado no pr√≥ximo peda√ßo do peda√ßo sobrecarregado. Portanto, √© poss√≠vel modificar o comando executado sobrescrevendo-o com um exploit simples como:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Outros exemplos

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Usamos uma vulnerabilidade de Integer Overflow para obter um Heap Overflow.
* Corrompemos ponteiros para uma fun√ß√£o dentro de uma `struct` do bloco sobrecarregado para definir uma fun√ß√£o como `system` e obter execu√ß√£o de c√≥digo.

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
