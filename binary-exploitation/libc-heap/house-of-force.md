# Casa da For√ßa



<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

### C√≥digo

* Esta t√©cnica foi corrigida ([**aqui**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) e produz este erro: `malloc(): corrupted top size`
* Voc√™ pode testar o [**c√≥digo daqui**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html) se quiser.

### Objetivo

* O objetivo deste ataque √© ser capaz de alocar um chunk em um endere√ßo espec√≠fico.

### Requisitos

* Um overflow que permita sobrescrever o tamanho do cabe√ßalho do top chunk (por exemplo, -1).
* Ser capaz de controlar o tamanho da aloca√ß√£o do heap

### Ataque

Se um atacante deseja alocar um chunk no endere√ßo P para sobrescrever um valor aqui. Ele come√ßa sobrescrevendo o tamanho do top chunk com `-1` (talvez com um overflow). Isso garante que o malloc n√£o usar√° mmap para nenhuma aloca√ß√£o, pois o Top chunk sempre ter√° espa√ßo suficiente.

Em seguida, calcule a dist√¢ncia entre o endere√ßo do top chunk e o espa√ßo-alvo para alocar. Isso ocorre porque um malloc com esse tamanho ser√° realizado para mover o top chunk para essa posi√ß√£o. √â assim que a diferen√ßa/tamanho pode ser facilmente calculada:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Portanto, alocar um tamanho de `target - old_top - 4*sizeof(long)` (os 4 longs s√£o devido aos metadados do chunk superior e do novo chunk quando alocado) mover√° o chunk superior para o endere√ßo que queremos sobrescrever.\
Em seguida, fa√ßa outro malloc para obter um chunk no endere√ßo alvo.

### Refer√™ncias e Outros Exemplos

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* O objetivo deste cen√°rio √© um ret2win onde precisamos modificar o endere√ßo de uma fun√ß√£o que ser√° chamada pelo endere√ßo da fun√ß√£o ret2win
* O bin√°rio tem um overflow que pode ser explorado para modificar o tamanho do top chunk, que √© modificado para -1 ou p64(0xffffffffffffffff)
* Em seguida, √© calculado o endere√ßo do local onde o ponteiro a ser sobrescrito existe, e a diferen√ßa da posi√ß√£o atual do top chunk at√© l√° √© alocada com `malloc`
* Finalmente, um novo chunk √© alocado que conter√° este alvo desejado dentro, que √© sobrescrito pela fun√ß√£o ret2win
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* No `Input your name:`, h√° uma vulnerabilidade inicial que permite vazar um endere√ßo do heap
* Em seguida, nas funcionalidades `Org:` e `Host:`, √© poss√≠vel preencher os 64B do ponteiro `s` quando solicitado pelo **nome da organiza√ß√£o**, que na pilha √© seguido pelo endere√ßo de v2, que √© ent√£o seguido pelo **nome do host** indicado. Como ent√£o, strcpy vai copiar o conte√∫do de s para um chunk de tamanho 64B, √© poss√≠vel **sobrescrever o tamanho do top chunk** com os dados inseridos no **nome do host**.
* Agora que a escrita arbitr√°ria √© poss√≠vel, o GOT do `atoi` foi sobrescrito para o endere√ßo do printf. Ent√£o foi poss√≠vel vazar o endere√ßo de `IO_2_1_stderr` _com_ `%24$p`. E com esse vazamento de libc foi poss√≠vel sobrescrever novamente o GOT do `atoi` com o endere√ßo do `system` e cham√°-lo passando como par√¢metro `/bin/sh`
* Um m√©todo alternativo [proposto neste outro writeup](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), √© sobrescrever `free` com `puts`, e ent√£o adicionar o endere√ßo de `atoi@got`, no ponteiro que ser√° posteriormente liberado para que seja vazado e com esse vazamento sobrescrever novamente `atoi@got` com `system` e cham√°-lo com `/bin/sh`.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Existe um UAF que permite reutilizar um chunk que foi liberado sem limpar o ponteiro. Como existem alguns m√©todos de leitura, √© poss√≠vel vazar um endere√ßo libc escrevendo um ponteiro para a fun√ß√£o free no GOT aqui e depois chamando a fun√ß√£o de leitura.
* Em seguida, House of force foi usado (abusando do UAF) para sobrescrever o tamanho do espa√ßo √† esquerda com um -1, alocar um chunk grande o suficiente para chegar ao hook de free e, em seguida, alocar outro chunk que conter√° o hook de free. Em seguida, escreva no hook o endere√ßo do `system`, escreva em um chunk `"/bin/sh"` e finalmente libere o chunk com esse conte√∫do de string.
