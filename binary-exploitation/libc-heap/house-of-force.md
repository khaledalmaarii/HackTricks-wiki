# 힘의 집

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 AWS 해킹을 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>

## 기본 정보

### 코드

* 이 기법은 ([**여기**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c))에서 패치되었으며 다음 오류를 생성합니다: `malloc(): corrupted top size`
* 테스트하려면 [**여기의 코드**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)를 사용할 수 있습니다.

### 목표

* 이 공격의 목표는 특정 주소에 청크를 할당할 수 있는 것입니다.

### 요구 사항

* 힙 할당의 크기를 제어할 수 있는 오버플로우가 필요합니다.
* 힙 할당의 크기를 제어할 수 있어야 합니다.

### 공격

공격자가 특정 주소 P에 청크를 할당하여 여기에 값을 덮어쓰려면, 먼저 top 청크 크기를 `-1`로 덮어쓰기(오버플로우를 사용할 수도 있음)하여 malloc이 Top 청크를 항상 충분한 공간으로 사용하지 않도록 합니다.

그런 다음, top 청크의 주소와 할당할 대상 공간 사이의 거리를 계산합니다. 이는 해당 크기로 malloc이 수행되어 top 청크가 해당 위치로 이동되도록하기 위함입니다. 차이/크기를 쉽게 계산할 수 있습니다:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
따라서 `target - old_top - 4*sizeof(long)` 크기를 할당하면 (4개의 long은 top 청크의 메타데이터와 새로운 청크가 할당될 때의 메타데이터 때문입니다) top 청크를 덮어쓰고자 하는 주소로 이동시킵니다.\
그런 다음, 데이터의 시작 부분을 포함하는 청크를 얻기 위해 또 다른 malloc을 수행하여 대상 주소를 쓸 위치에 포함하는 청크를 얻습니다.

### 참고 자료 및 다른 예시

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* 이 시나리오의 목표는 호출될 함수의 주소를 ret2win 함수의 주소로 변경해야 하는 ret2win입니다.
* 이진 파일에는 top 청크 크기를 수정할 수 있는 오버플로우가 있으며, 이는 -1 또는 p64(0xffffffffffffffff)로 수정됩니다.
* 그런 다음 덮어쓸 포인터가 존재하는 위치로 주소를 계산하고 현재 top 청크 위치부터 해당 위치까지의 차이가 `malloc`으로 할당됩니다.
* 마지막으로 원하는 대상을 포함하는 새로운 청크가 할당되며, 이 대상은 ret2win 함수에 의해 덮어씌워집니다.
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* `Input your name:`에는 힙에서 주소를 누출할 수 있는 초기 취약점이 있습니다.
* 그런 다음 `Org:` 및 `Host:` 기능에서 **org name**을 요청할 때 `s` 포인터의 64B를 채울 수 있으며, 이는 스택에서 v2의 주소 뒤에 따르는 것이며, 그 후에 지정된 **host name**이 따릅니다. 그 후 strcpy가 s의 내용을 64B 크기의 청크에 복사하게 되므로 **host name**에 입력된 데이터로 **top 청크의 크기를 덮어쓸 수 있습니다**.
* 이제 임의 쓰기가 가능하므로 `atoi`의 GOT가 printf의 주소로 덮어씌워졌습니다. 그런 다음 `%24$p`로 `IO_2_1_stderr`의 주소를 누출할 수 있었으며, 이 libc 누출을 통해 `atoi`의 GOT를 다시 `system`의 주소로 덮어씌워 `/bin/sh`를 매개변수로 전달하여 호출할 수 있었습니다.
* [이 다른 writeup에서 제안된 대체 방법](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud)은 `free`를 `puts`로 덮어쓰고, 나중에 해제될 포인터에 `atoi@got`의 주소를 추가하여 누출하고 이 누출로 다시 `atoi@got`를 `system`으로 덮어씌워 `/bin/sh`로 호출하는 것입니다.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* 포인터를 지우지 않고 해제된 청크를 재사용할 수 있는 UAF가 있습니다. 일부 읽기 방법이 있기 때문에 GOT에 free 함수의 포인터를 쓰고 나중에 read 함수를 호출하여 libc 주소를 누출할 수 있습니다.
* 그런 다음 UAF를 악용하여 (UAF를 남용하여) 남은 공간의 크기를 -1로 덮어쓰고, free 후크에 도달할 수 있는 충분히 큰 청크를 할당한 다음 free 후크를 포함하는 또 다른 청크를 할당합니다. 그런 다음 후크에 `system`의 주소를 쓰고, 청크에 `"/bin/sh"`를 쓰고, 그 문자열 내용을 포함하는 청크를 해제합니다.
