# PrekoraÄenje za jedan bajt

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

ImajuÄ‡i pristup samo prekoraÄenju za jedan bajt, napadaÄu je omoguÄ‡eno da izmeni polje `size` sledeÄ‡eg bloka. Ovo omoguÄ‡ava manipulaciju sa blokovima koji su zapravo osloboÄ‘eni, potencijalno generiÅ¡uÄ‡i blok koji sadrÅ¾i drugi legitimni blok. Eksploatacija je sliÄna [dvostrukom osloboÄ‘avanju](double-free.md) ili preklapanju blokova.

Postoje 2 vrste ranjivosti prekoraÄenja za jedan bajt:

* Proizvoljan bajt: Ova vrsta omoguÄ‡ava prepisivanje tog bajta sa bilo kojom vrednoÅ¡Ä‡u
* Nula bajt (off-by-null): Ova vrsta omoguÄ‡ava prepisivanje tog bajta samo sa 0x00
* ÄŒest primer ove ranjivosti moÅ¾e se videti u sledeÄ‡em kodu gde je ponaÅ¡anje `strlen` i `strcpy` nekonzistentno, Å¡to omoguÄ‡ava postavljanje bajta 0x00 na poÄetku sledeÄ‡eg bloka.
* Ovo se moÅ¾e iskoristiti sa [House of Einherjar](house-of-einherjar.md).
* Ako se koristi Tcache, ovo se moÅ¾e iskoristiti u situaciju [dvostrukog osloboÄ‘avanja](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

MeÄ‘u ostalim proverama, sada kada je komad slobodan, prethodna veliÄina se uporeÄ‘uje sa veliÄinom konfigurisanom u metapodacima komada, ÄineÄ‡i ovaj napad priliÄno sloÅ¾enim od verzije 2.28.

### Primer koda:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ovaj napad viÅ¡e ne funkcioniÅ¡e zbog koriÅ¡Ä‡enja Tcache-ova.
* Å taviÅ¡e, ako pokuÅ¡ate da ga zloupotrebite koristeÄ‡i veÄ‡e komade (tako da Tcache-ovi nisu ukljuÄeni), dobiÄ‡ete greÅ¡ku: `malloc(): invalid next size (unsorted)`

### Cilj

* Da se komad nalazi unutar drugog komada, tako da pisanje pristupa preko tog drugog komada omoguÄ‡ava prepisivanje sadrÅ¾aja sadrÅ¾anog komada

### Zahtevi

* PrekoraÄenje za jedan bajt da se izmeni informacija o metapodacima veliÄine

### OpÅ¡ti napad off-by-one

* Alocirajte tri komada `A`, `B` i `C` (recimo veliÄine 0x20), i joÅ¡ jedan da spreÄi konsolidaciju sa vrÅ¡nim komadom.
* Oslobodite `C` (ubacen u 0x20 Tcache listu slobodnih komada).
* Koristite komad `A` da prekoraÄite na `B`. Zloupotrebite off-by-one da izmenite polje `size` od `B` sa 0x21 na 0x41.
* Sada imamo `B` koji sadrÅ¾i slobodan komad `C`
* Oslobodite `B` i alocirajte 0x40 komad (biÄ‡e ponovo postavljen ovde)
* MoÅ¾emo izmeniti pokazivaÄ `fd` od `C`, koji je i dalje slobodan (Tcache trovanje)

### Off-by-null napad

* RezerviÅ¡ite 3 komada memorije (a, b, c) jedan za drugim. Zatim se oslobaÄ‘a srednji komad. Prvi komad sadrÅ¾i ranjivost prekoraÄenja za jedan bajt i napadaÄ je zloupotrebljava sa 0x00 (ako je prethodni bajt bio 0x10, to bi navelo srednji komad da pokaÅ¾e da je 0x10 manji nego Å¡to zaista jeste).
* Zatim, joÅ¡ 2 manja komada se alociraju u srednjem osloboÄ‘enom komadu (b), meÄ‘utim, poÅ¡to `b + b->size` nikada ne aÅ¾urira c komad jer je pokazana adresa manja nego Å¡to bi trebalo.
* Zatim se b1 i c oslobaÄ‘aju. PoÅ¡to `c - c->prev_size` i dalje pokazuje na b (sada b1), oba se konsoliduju u jedan komad. MeÄ‘utim, b2 je i dalje unutar izmeÄ‘u b1 i c.
* Na kraju, vrÅ¡i se nova alokacija memorije koja Ä‡e zapravo sadrÅ¾ati b2, omoguÄ‡avajuÄ‡i vlasniku nove alokacije da kontroliÅ¡e sadrÅ¾aj b2.

Ova slika savrÅ¡eno objaÅ¡njava napad:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Ostali primeri i reference

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one zbog `strlen` koji uzima u obzir polje `size` sledeÄ‡eg komada.
* Tcache se koristi, pa opÅ¡ti off-by-one napadi funkcioniÅ¡u kako bi se dobio proizvoljni zapis sa Tcache trovanjem.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* MoguÄ‡e je zloupotrebiti off-by-one da bi se procurela adresa iz hipa jer bajt 0x00 na kraju stringa biva prepisan sledeÄ‡im poljem.
* Proizvoljni zapis se dobija zloupotrebom off-by-one zapisa da bi se pokazivaÄ usmerio na drugo mesto gde Ä‡e biti izgraÄ‘ena laÅ¾na struktura sa laÅ¾nim pokazivaÄima. Zatim je moguÄ‡e pratiti pokazivaÄ ove strukture da bi se dobio proizvoljni zapis.
* Adresa libc-a procuri jer ako se hip proÅ¡iri koriÅ¡Ä‡enjem mmap, memorija alocirana pomoÄ‡u mmap ima fiksni odmak od libc-a.
* Na kraju se zloupotrebljava proizvoljni zapis da bi se upisalo na adresu \_\_free\_hook sa jednim gedÅ¾etom.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Postoji NULL off-by-one ranjivost u funkciji `getline` koja Äita linije korisniÄkog unosa. Ova funkcija se koristi za Äitanje "kljuÄa" sadrÅ¾aja, a ne samog sadrÅ¾aja.
* U objaÅ¡njenju se stvara 5 poÄetnih komada:
* komad1 (0x200)
* komad2  (0x50)
* komad5 (0x68)
* komad3 (0x1f8)
* komad4 (0xf0)
* komad odbrane (0x400) da bi se izbegla konsolidacija sa vrÅ¡nim komadom
* Zatim se oslobaÄ‘uju komadi 1, 5 i 3, tako da:
* ```python
[ 0x200 Komad 1 (slobodan) ] [ 0x50 Komad 2 ] [ 0x68 Komad 5 (slobodan) ] [ 0x1f8 Komad 3 (slobodan) ] [ 0xf0 Komad 4 ] [ 0x400 Komad odbrane ]
```
* Zatim se zloupotrebljava komad3 (0x1f8) null off-by-one zapisom prev\_size na `0x4e0`.
* Primetite kako veliÄine poÄetno alociranih komada1, 2, 5 i 3 plus zaglavlja 4 tih komada iznose `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Zatim se oslobaÄ‘uje komad 4, generiÅ¡uÄ‡i komad koji troÅ¡i sve komade do poÄetka:
* ```python
[ 0x4e0 Komad 1-2-5-3 (slobodan) ] [ 0xf0 Komad 4 (korumpiran) ] [ 0x400 Komad odbrane ]
```
* ```python
[ 0x200 Komad 1 (slobodan) ] [ 0x50 Komad 2 ] [ 0x68 Komad 5 (slobodan) ] [ 0x1f8 Komad 3 (slobodan) ] [ 0xf0 Komad 4 ] [ 0x400 Komad odbrane ]
```
* Zatim se alocira `0x200` bajtova popunjavajuÄ‡i originalni komad 1
* I alocira se joÅ¡ 0x200 bajtova i uniÅ¡tava se komad2 i stoga nema curenja i ovo ne funkcioniÅ¡e? MoÅ¾da ovo ne bi trebalo da se uradi
* Zatim se alocira joÅ¡ jedan komad sa 0x58 "a" (prepisujuÄ‡i komad2 i doseÅ¾uÄ‡i komad5) i menja se `fd` brze binarne grupe komada komada5 usmeravajuÄ‡i ga ka `__malloc_hook`
* Zatim se alocira komad od 0x68 tako da je laÅ¾ni brzi binarni komad u `__malloc_hook` sledeÄ‡i brzi binarni komad
* Na kraju, alocira se novi brzi binarni komad od 0x68 i `__malloc_hook` se prepisuje sa adresom `one_gadget`
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repozitorijume.**
