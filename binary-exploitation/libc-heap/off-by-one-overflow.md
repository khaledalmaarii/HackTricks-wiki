# PrzepeÅ‚nienie o jeden

{% hint style="success" %}
Dowiedz siÄ™ i Ä‡wicz hakowanie AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz siÄ™ i Ä‡wicz hakowanie GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
{% endhint %}

## Podstawowe informacje

MajÄ…c dostÄ™p tylko do przepeÅ‚nienia o jeden bajt, atakujÄ…cy moÅ¼e modyfikowaÄ‡ pole `size` z nastÄ™pnego fragmentu. Pozwala to manipulowaÄ‡, ktÃ³re fragmenty sÄ… faktycznie zwalniane, potencjalnie generujÄ…c fragment zawierajÄ…cy inny prawidÅ‚owy fragment. Wykorzystanie jest podobne do [podwÃ³jnego zwalniania pamiÄ™ci](double-free.md) lub nakÅ‚adajÄ…cych siÄ™ fragmentÃ³w.

IstniejÄ… 2 rodzaje podatnoÅ›ci na przepeÅ‚nienie o jeden:

* Dowolny bajt: Ten rodzaj pozwala nadpisaÄ‡ ten bajt dowolnÄ… wartoÅ›ciÄ…
* Bajt zerowy (off-by-null): Ten rodzaj pozwala nadpisaÄ‡ ten bajt tylko wartoÅ›ciÄ… 0x00
* Powszechnym przykÅ‚adem tej podatnoÅ›ci jest poniÅ¼szy kod, w ktÃ³rym zachowanie `strlen` i `strcpy` jest niekonsekwentne, co pozwala ustawiÄ‡ bajt 0x00 na poczÄ…tku nastÄ™pnego fragmentu.
* MoÅ¼na to wykorzystaÄ‡ za pomocÄ… [House of Einherjar](house-of-einherjar.md).
* JeÅ›li uÅ¼ywany jest Tcache, moÅ¼na to wykorzystaÄ‡ do sytuacji [podwÃ³jnego zwalniania pamiÄ™ci](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

WÅ›rÃ³d innych sprawdzeÅ„, teraz za kaÅ¼dym razem, gdy kawaÅ‚ek jest zwalniany, rozmiar poprzedni jest porÃ³wnywany z rozmiarem skonfigurowanym w metadanych kawaÅ‚ka, co sprawia, Å¼e ten atak jest doÅ›Ä‡ skomplikowany od wersji 2.28.

### PrzykÅ‚ad kodu:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ten atak juÅ¼ nie dziaÅ‚a ze wzglÄ™du na uÅ¼ycie Tcaches.
* Ponadto, jeÅ›li sprÃ³bujesz go wykorzystaÄ‡, uÅ¼ywajÄ…c wiÄ™kszych kawaÅ‚kÃ³w (aby tcaches nie byÅ‚y zaangaÅ¼owane), otrzymasz bÅ‚Ä…d: `malloc(): invalid next size (unsorted)`

### Cel

* UmieÅ›Ä‡ kawaÅ‚ek wewnÄ…trz innego kawaÅ‚ka, dziÄ™ki czemu dostÄ™p do zapisu na ten drugi kawaÅ‚ek pozwala nadpisaÄ‡ zawarty w nim kawaÅ‚ek

### Wymagania

* PrzepeÅ‚nienie o jeden, aby zmodyfikowaÄ‡ informacje o metadanych rozmiaru

### OgÃ³lny atak off-by-one

* Zaalokuj trzy kawaÅ‚ki `A`, `B` i `C` (powiedzmy rozmiary 0x20), oraz kolejny, aby zapobiec konsolidacji z kawaÅ‚kiem gÃ³rnym.
* Zwolnij `C` (wstawiony do listy wolnych Tcache 0x20).
* UÅ¼yj kawaÅ‚ka `A`, aby przepeÅ‚niÄ‡ `B`. Wykorzystaj off-by-one, aby zmodyfikowaÄ‡ pole `size` `B` z 0x21 na 0x41.
* Teraz mamy `B` zawierajÄ…cy wolny kawaÅ‚ek `C`
* Zwolnij `B` i zaalokuj kawaÅ‚ek 0x40 (zostanie tu ponownie umieszczony)
* MoÅ¼emy zmodyfikowaÄ‡ wskaÅºnik `fd` z `C`, ktÃ³ry nadal jest wolny (zatrucie Tcache)

### Atak off-by-null

* Rezerwuje siÄ™ 3 kawaÅ‚ki pamiÄ™ci (a, b, c) jeden po drugim. NastÄ™pnie Å›rodkowy jest zwalniany. Pierwszy zawiera podatnoÅ›Ä‡ na przepeÅ‚nienie o jeden, a atakujÄ…cy jÄ… z 0x00 (jeÅ›li poprzedni bajt byÅ‚ 0x10, sprawi, Å¼e Å›rodkowy kawaÅ‚ek wskaÅ¼e, Å¼e jest o 0x10 mniejszy, niÅ¼ naprawdÄ™ jest).
* NastÄ™pnie, w Å›rodku zwolnionego kawaÅ‚ka (b) sÄ… przydzielane 2 mniejsze kawaÅ‚ki, jednakÅ¼e, poniewaÅ¼ `b + b->size` nigdy nie aktualizuje kawaÅ‚ka c, poniewaÅ¼ adres wskazywany jest mniejszy, niÅ¼ powinien.
* NastÄ™pnie, b1 i c sÄ… zwalniane. PoniewaÅ¼ `c - c->prev_size` wciÄ…Å¼ wskazuje na b (teraz b1), oba sÄ… konsolidowane w jeden kawaÅ‚ek. JednakÅ¼e, b2 nadal znajduje siÄ™ wewnÄ…trz pomiÄ™dzy b1 i c.
* W koÅ„cu, wykonywane jest nowe przydziaÅ‚ pamiÄ™ci malloc, odzyskujÄ…c ten obszar pamiÄ™ci, ktÃ³ry faktycznie bÄ™dzie zawieraÅ‚ b2, pozwalajÄ…c wÅ‚aÅ›cicielowi nowego malloc kontrolowaÄ‡ zawartoÅ›Ä‡ b2.

To zdjÄ™cie doskonale wyjaÅ›nia atak:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Inne PrzykÅ‚ady & Referencje

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one z powodu `strlen` uwzglÄ™dniajÄ…cy pole `size` nastÄ™pnego kawaÅ‚ka.
* UÅ¼ywany jest Tcache, wiÄ™c ogÃ³lne ataki off-by-one dziaÅ‚ajÄ…, aby uzyskaÄ‡ arbitralne pisanie zatruciem Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* MoÅ¼liwe jest wykorzystanie off-by-one do wycieku adresu z heap, poniewaÅ¼ bajt 0x00 na koÅ„cu Å‚aÅ„cucha znakÃ³w jest nadpisywany przez nastÄ™pne pole.
* Pisanie arbitralne jest uzyskiwane poprzez wykorzystanie off-by-one write, aby wskaÅºnik wskazywaÅ‚ na inne miejsce, gdzie zostanie zbudowana faÅ‚szywa struktura z faÅ‚szywymi wskaÅºnikami. NastÄ™pnie moÅ¼liwe jest Å›ledzenie wskaÅºnika tej struktury, aby uzyskaÄ‡ arbitralne pisanie.
* Adres libc jest wyciekany, poniewaÅ¼ jeÅ›li sterta jest rozszerzana za pomocÄ… mmap, pamiÄ™Ä‡ przydzielona przez mmap ma staÅ‚y przesuniÄ™cie od libc.
* W koÅ„cu, arbitralne pisanie jest wykorzystywane do zapisania w adresie \_\_free\_hook z jednym gadÅ¼etem.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Istnieje podatnoÅ›Ä‡ NULL off-by-one w funkcji `getline`, ktÃ³ra czyta linie wejÅ›ciowe uÅ¼ytkownika. Ta funkcja sÅ‚uÅ¼y do odczytywania "klucza" zawartoÅ›ci, a nie samej zawartoÅ›ci.
* **UdostÄ™pniaj sztuczki hakowania, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriÃ³w na GitHubie.**
