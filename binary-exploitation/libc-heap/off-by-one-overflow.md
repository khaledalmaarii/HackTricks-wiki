# Off-by-one-√úberlauf

{% hint style="success" %}
Lernen Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys senden.

</details>
{% endhint %}

## Grundlegende Informationen

Wenn ein Angreifer nur auf einen 1B-√úberlauf zugreifen kann, kann er das `size`-Feld des n√§chsten Chunks √§ndern. Dies erm√∂glicht es, welche Chunks tats√§chlich freigegeben werden, zu manipulieren und potenziell einen Chunk zu erzeugen, der einen anderen legitimen Chunk enth√§lt. Die Ausnutzung √§hnelt einem [Doppel-Free](double-free.md) oder √ºberlappenden Chunks.

Es gibt 2 Arten von Off-by-One-Schwachstellen:

* Beliebiges Byte: Diese Art erm√∂glicht das √úberschreiben dieses Bytes mit einem beliebigen Wert.
* Nullbyte (Off-by-Null): Diese Art erm√∂glicht es, dieses Byte nur mit 0x00 zu √ºberschreiben.
* Ein h√§ufiges Beispiel f√ºr diese Schwachstelle ist im folgenden Code zu sehen, in dem das Verhalten von `strlen` und `strcpy` inkonsistent ist, was es erm√∂glicht, ein 0x00-Byte am Anfang des n√§chsten Chunks zu setzen.
* Dies kann mit dem [House of Einherjar](house-of-einherjar.md) ausgenutzt werden.
* Wenn Tcache verwendet wird, kann dies zu einer [Doppel-Freigabe](double-free.md) f√ºhren.

<details>

<summary>Off-by-Null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Unter anderem wird jetzt bei jedem Freigeben eines Chunks die vorherige Gr√∂√üe mit der im Metadaten-Chunk konfigurierten Gr√∂√üe verglichen, was diesen Angriff ab Version 2.28 ziemlich komplex macht.

### Codebeispiel:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Dieser Angriff funktioniert nicht mehr aufgrund der Verwendung von Tcaches.
* Dar√ºber hinaus, wenn Sie versuchen, es mit gr√∂√üeren Chunks zu missbrauchen (damit Tcaches nicht involviert sind), erhalten Sie den Fehler: `malloc(): invalid next size (unsorted)`

### Ziel

* Einen Chunk in einem anderen Chunk enthalten, sodass Schreibzugriff auf diesen zweiten Chunk es erm√∂glicht, den enthaltenen zu √ºberschreiben

### Anforderungen

* Off-by-one-√úberlauf, um die Gr√∂√üenmetadateninformationen zu √§ndern

### Allgemeiner Off-by-One-Angriff

* Reservieren Sie drei Chunks `A`, `B` und `C` (sagen wir Gr√∂√üen 0x20), und einen weiteren, um die Konsolidierung mit dem Top-Chunk zu verhindern.
* Geben Sie `C` frei (eingef√ºgt in die 0x20 Tcache-Freiliste).
* Verwenden Sie Chunk `A`, um auf `B` zu √ºberlaufen. Missbrauchen Sie das Off-by-One, um das `size`-Feld von `B` von 0x21 auf 0x41 zu √§ndern.
* Jetzt haben wir `B`, das den freien Chunk `C` enth√§lt
* Geben Sie `B` frei und allozieren Sie einen 0x40 Chunk (es wird hier wieder platziert)
* Wir k√∂nnen den `fd`-Zeiger von `C` √§ndern, der immer noch frei ist (Tcache-Vergiftung)

### Off-by-Null-Angriff

* 3 Speicherbl√∂cke (a, b, c) werden nacheinander reserviert. Dann wird der mittlere freigegeben. Der erste enth√§lt eine Off-by-One-√úberlaufschwachstelle und der Angreifer missbraucht sie mit einer 0x00 (wenn das vorherige Byte 0x10 war, w√ºrde der mittlere Chunk anzeigen, dass er 0x10 kleiner ist als er wirklich ist).
* Dann werden 2 kleinere Chunks im mittleren freigegebenen Chunk (b) alloziert, jedoch wird `b + b->size` nie den c-Chunk aktualisieren, weil die adressierte Adresse kleiner ist als sie sein sollte.
* Dann werden b1 und c freigegeben. Da `c - c->prev_size` immer noch auf b zeigt (jetzt b1), werden beide in einem Chunk konsolidiert. Allerdings ist b2 immer noch zwischen b1 und c.
* Schlie√ülich wird ein neuer malloc durchgef√ºhrt, der diesen Speicherbereich zur√ºckfordert, der tats√§chlich b2 enthalten wird, was es dem Besitzer des neuen malloc erm√∂glicht, den Inhalt von b2 zu kontrollieren.

Dieses Bild erkl√§rt den Angriff perfekt:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Weitere Beispiele & Referenzen

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one aufgrund von `strlen`, das das `size`-Feld des n√§chsten Chunks ber√ºcksichtigt.
* Tcache wird verwendet, daher funktionieren allgemeine Off-by-One-Angriffe, um eine beliebige Schreibprimitive mit Tcache-Vergiftung zu erhalten.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es ist m√∂glich, ein Off-by-One zu missbrauchen, um eine Adresse aus dem Heap zu leaken, weil das Byte 0x00 am Ende einer Zeichenkette vom n√§chsten Feld √ºberschrieben wird.
* Eine beliebige Schreibweise wird durch den Missbrauch des Off-by-One-Schreibens erlangt, um den Zeiger auf einen anderen Ort zu setzen, an dem eine gef√§lschte Struktur mit gef√§lschten Zeigern erstellt wird. Dann ist es m√∂glich, dem Zeiger dieser Struktur zu folgen, um eine beliebige Schreibweise zu erhalten.
* Die libc-Adresse wird geleakt, weil wenn der Heap mit mmap erweitert wird, der von mmap allozierte Speicher einen festen Offset von libc hat.
* Schlie√ülich wird die beliebige Schreibweise missbraucht, um in die Adresse von \_\_free\_hook mit einem One-Gadget zu schreiben.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Es gibt eine NULL Off-by-One-Schwachstelle in der `getline`-Funktion, die Benutzereingabezeilen liest. Diese Funktion wird verwendet, um den "Schl√ºssel" des Inhalts zu lesen und nicht den Inhalt.
* **Teilen Sie Hacking-Tricks, indem Sie Pull Requests an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositorys senden.**
