# Przepenienie o jeden

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje

Majc dostp tylko do przepenienia o jeden bajt, atakujcy mo偶e zmodyfikowa pole `size` z nastpnego fragmentu. Pozwala to manipulowa, kt贸re fragmenty s faktycznie zwalniane, potencjalnie generujc fragment zawierajcy inny prawidowy fragment. Wykorzystanie jest podobne do [podw贸jnego zwalniania pamici](double-free.md) lub nakadajcych si fragment贸w.

Istniej 2 rodzaje podatnoci na przepenienie o jeden:

* Dowolny bajt: Ten rodzaj pozwala nadpisa ten bajt dowoln wartoci
* Bajt zerowy (off-by-null): Ten rodzaj pozwala nadpisa ten bajt tylko wartoci 0x00
* Przykadem takiej podatnoci mo偶e by poni偶szy kod, w kt贸rym zachowanie funkcji `strlen` i `strcpy` jest niekonsekwentne, co pozwala na ustawienie bajtu 0x00 na pocztku nastpnego fragmentu.
* Mo偶na to wykorzysta za pomoc [House of Einherjar](house-of-einherjar.md).
* Jeli u偶ywany jest Tcache, mo偶na to wykorzysta do sytuacji [podw贸jnego zwalniania pamici](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Wr贸d innych sprawdze, teraz za ka偶dym razem, gdy kawaek jest zwalniany, rozmiar poprzedni jest por贸wnywany z rozmiarem skonfigurowanym w metadanych kawaka, co sprawia, 偶e ten atak jest do skomplikowany od wersji 2.28.

### Przykad kodu:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ten atak ju偶 nie dziaa ze wzgldu na u偶ycie Tcaches.
* Ponadto, jeli spr贸bujesz go wykorzysta, u偶ywajc wikszych kawak贸w (aby tcaches nie byy zaanga偶owane), otrzymasz bd: `malloc(): invalid next size (unsorted)`

### Cel

* Umie kawaek wewntrz innego kawaka, dziki czemu dostp do zapisu na ten drugi kawaek pozwala nadpisa zawarty w nim kawaek

### Wymagania

* Przepenienie o jeden, aby zmodyfikowa informacje o metadanych rozmiaru

### Og贸lny atak off-by-one

* Zaalokuj trzy kawaki `A`, `B` i `C` (powiedzmy rozmiary 0x20), oraz kolejny, aby zapobiec konsolidacji z kawakiem g贸rnym.
* Zwolnij `C` (wstawiony do listy wolnych Tcache 0x20).
* U偶yj kawaka `A`, aby przepeni `B`. Wykorzystaj off-by-one, aby zmodyfikowa pole `size` `B` z 0x21 na 0x41.
* Teraz mamy `B` zawierajcy wolny kawaek `C`
* Zwolnij `B` i zaalokuj kawaek 0x40 (zostanie tu ponownie umieszczony)
* Mo偶emy zmodyfikowa wska藕nik `fd` z `C`, kt贸ry nadal jest wolny (zatrucie Tcache)

### Atak off-by-null

* Rezerwuje si 3 kawaki pamici (a, b, c) jeden po drugim. Nastpnie rodkowy jest zwalniany. Pierwszy zawiera podatno na przepenienie o jeden, a atakujcy j z wykorzystaniem 0x00 (jeli poprzedni bajt by 0x10, sprawi, 偶e rodkowy kawaek wska偶e, 偶e jest o 0x10 mniejszy, ni偶 w rzeczywistoci jest).
* Nastpnie, w rodku zwolnionego kawaka (b) zaalokowano 2 mniejsze kawaki, jednak偶e, poniewa偶 `b + b->size` nigdy nie aktualizuje kawaka c, poniewa偶 adres wskazywany jest mniejszy, ni偶 powinien.
* Nastpnie, b1 i c s zwalniane. Poniewa偶 `c - c->prev_size` wci偶 wskazuje na b (teraz b1), oba s konsolidowane w jeden kawaek. Jednak偶e, b2 nadal znajduje si wewntrz pomidzy b1 i c.
* W kocu, wykonywane jest nowe przydzia pamici malloc, odzyskujc ten obszar pamici, kt贸ry faktycznie bdzie zawiera b2, pozwalajc wacicielowi nowego malloc kontrolowa zawarto b2.

To zdjcie doskonale wyjania atak:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Inne Przykady & Referencje

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one z powodu `strlen` uwzgldniajcego pole `size` nastpnego kawaka.
* U偶ywany jest Tcache, wic og贸lne ataki off-by-one dziaaj, aby uzyska arbitralne pisanie zatruciem Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Mo偶liwe jest wykorzystanie off-by-one do wycieku adresu z heap, poniewa偶 bajt 0x00 na kocu acucha znak贸w jest nadpisywany przez nastpne pole.
* Pisanie arbitralne jest uzyskiwane poprzez nadu偶ycie off-by-one write, aby wska藕nik wskazywa na inne miejsce, gdzie zostanie zbudowana faszywa struktura z faszywymi wska藕nikami. Nastpnie mo偶liwe jest ledzenie wska藕nika tej struktury, aby uzyska arbitralne pisanie.
* Adres libc jest wyciekany, poniewa偶 jeli sterta jest rozszerzana za pomoc mmap, pami zaalokowana przez mmap ma stay przesunicie od libc.
* W kocu, nadu偶ywane jest arbitralne pisanie, aby zapisa w adresie \_\_free\_hook z adresem one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Istnieje podatno NULL off-by-one w funkcji `getline`, kt贸ra czyta linie wejciowe u偶ytkownika. Ta funkcja su偶y do odczytywania "klucza" zawartoci, a nie samej zawartoci.
* W opisie 5 pocztkowych kawak贸w jest tworzonych:
* kawaek1 (0x200)
* kawaek2  (0x50)
* kawaek5 (0x68)
* kawaek3 (0x1f8)
* kawaek4 (0xf0)
* obrona kawaka (0x400) aby unikn konsolidacji z kawakiem g贸rnym
* Nastpnie kawaki 1, 5 i 3 s zwalniane, wic:
* ```python
[ 0x200 Kawaek 1 (wolny) ] [ 0x50 Kawaek 2 ] [ 0x68 Kawaek 5 (wolny) ] [ 0x1f8 Kawaek 3 (wolny) ] [ 0xf0 Kawaek 4 ] [ 0x400 Kawaek obrony ]
```
* Nastpnie nadu偶ywajc kawaka3 (0x1f8) wykorzystuje si null off-by-one, zapisujc prev\_size na `0x4e0`.
* Zauwa偶, jak rozmiary pocztkowo zaalokowanych kawak贸w1, 2, 5 i 3 plus nag贸wki 4 z tych kawak贸w r贸wnaj si `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Nastpnie, kawaek 4 jest zwalniany, generujc kawaek, kt贸ry zu偶ywa wszystkie kawaki a偶 do pocztku:
* ```python
[ 0x4e0 Kawaek 1-2-5-3 (wolny) ] [ 0xf0 Kawaek 4 (zepsuty) ] [ 0x400 Kawaek obrony ]
```
* ```python
[ 0x200 Kawaek 1 (wolny) ] [ 0x50 Kawaek 2 ] [ 0x68 Kawaek 5 (wolny) ] [ 0x1f8 Kawaek 3 (wolny) ] [ 0xf0 Kawaek 4 ] [ 0x400 Kawaek obrony ]
```
* Nastpnie, zaalokowane s `0x200` bajt贸w wypeniajc oryginalny kawaek 1
* I zaalokowane s kolejne 0x200 bajt贸w i kawaek2 jest zniszczony i dlatego nie ma 偶adnego wycieku i to nie dziaa? By mo偶e tego nie powinno si robi
* Nastpnie, zaalokowano inny kawaek z 0x58 "a" (nadpisujc kawaek2 i docierajc do kawaka5) i zmodyfikowano `fd` kawaka fast bin kawaka kawaka5 wskazujc go na `__malloc_hook`
* Nastpnie, zaalokowano kawaek o rozmiarze 0x68, wic faszywy kawaek fast bin w `__malloc_hook` jest nastpnym kawakiem fast bin
* W kocu, zaalokowano nowy kawaek fast bin o rozmiarze 0x68 i `__malloc_hook` jest nadpisany adresem `one_gadget`
* **Udostpnij swoje sztuczki hakerskie, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **na githubie.**
