# Ongeorden Bin Aanval

<details>

<summary><strong>Leer AWS hak vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien jou **maatskappy geadverteer in HackTricks** of **laai HackTricks af in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Basiese Inligting

Vir meer inligting oor wat 'n ongeorden bin is, kyk na hierdie bladsy:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Ongeorden lys kan die adres na `ongesorteerde brokke (av)` skryf in die `bk`-adres van die brokkie. Daarom, as 'n aanvaller die adres van die `bk`-aanwyser in 'n brokkie binne die ongeorden bin kan **verander**, kan hy in staat wees om **daardie adres in 'n willekeurige adres te skryf** wat nuttig kan wees om 'n Glibc-adres te lek of om sekere verdediging te omseil.

Dus, hierdie aanval maak dit basies moontlik om **'n groot getal by 'n willekeurige adres in te stel**. Hierdie groot getal is 'n adres, wat 'n heap-adres of 'n Glibc-adres kan wees. 'n Tipiese teiken is **`global_max_fast`** om groter grootte vinnige binne te skep (en oorgaan van 'n ongeorden bin aanval na 'n vinnige bin aanval).

{% hint style="success" %}
Deur na die voorbeeld te kyk wat verskaf is in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) en 0x4000 en 0x5000 te gebruik in plaas van 0x400 en 0x500 as brokkie groottes (om Tcache te vermy) is dit moontlik om te sien dat **teenwoordig** die fout **`malloc(): ongesorteerde dubbel gekoppelde lys gekorrigeer`** geaktiveer word.

Daarom vereis hierdie ongeorden bin aanval nou (onder andere kontroles) ook dat die dubbel gekoppelde lys reggestel moet word sodat dit omseil word `victim->bk->fd == victim` of nie `victim->fd == av (arena)`, wat beteken dat die adres waar ons wil skryf die adres van die vals brokkie in sy `fd`-posisie moet h√™ en dat die vals brokkie `fd` na die arena verwys.
{% endhint %}

{% hint style="danger" %}
Let daarop dat hierdie aanval die ongeorden bin beskadig (dus klein en groot ook). Dus kan ons nou slegs **toewysings van die vinnige bin gebruik** ( 'n meer komplekse program kan ander toewysings doen en vasloop), en om dit te aktiveer moet ons **dieselfde grootte toewys anders sal die program vasloop.**

Let daarop dat die oorskrywing van **`global_max_fast`** in hierdie geval kan help om te vertrou dat die vinnige bin in staat sal wees om al die ander toewysings te hanteer totdat die uitbuiting voltooi is.
{% endhint %}

Die kode van [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) verduidelik dit baie goed, alhoewel as jy die mallocs wysig om geheue groot genoeg toe te ken sodat dit nie in 'n Tcache eindig nie, kan jy sien dat die voorheen genoemde fout voorkom wat hierdie tegniek voorkom: **`malloc(): ongesorteerde dubbel gekoppelde lys gekorrigeer`**

## Ongeorden Bin Infoleak Aanval

Dit is eintlik 'n baie basiese konsep. Die brokkies in die ongeorden bin gaan aanwysers h√™. Die eerste brokkie in die ongeorden bin sal eintlik die **`fd`** en die **`bk`** skakels h√™ wat **na 'n deel van die hoof-arena (Glibc)** verwys.\
Daarom, as jy **'n brokkie binne 'n ongeorden bin kan plaas en dit lees** (gebruik na vry) of **dit weer kan toeken sonder om ten minste 1 van die aanwysers te oorskryf** om dit dan **te lees**, kan jy 'n **Glibc inligtingslek** h√™.

'n Soortgelyke [**aanval wat in hierdie skryfstuk gebruik is**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), was om 'n 4 brokkie struktuur (A, B, C en D - D is slegs om konsolidasie met die boonste brokkie te voorkom) te misbruik sodat 'n nul byte oorvloei in B gebruik is om C aan te dui dat B ongebruik was. Ook, in B is die `prev_size` data gewysig sodat die grootte in plaas daarvan om die grootte van B was A+B.\
Toe is C vrygestel, en gekonsolideer met A+B (maar B was nog in gebruik). 'n Nuwe brokkie van grootte A is toegeken en toe is die gelekte libc-adresse in B geskryf vanwaar hulle gelekte is.

## Verwysings & Ander voorbeelde

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Die doel is om 'n globale veranderlike met 'n waarde groter as 4869 te oorskryf sodat dit moontlik is om die vlag te kry en PIE is nie geaktiveer nie.
* Dit is moontlik om brokkies van willekeurige groottes te genereer en daar is 'n geheue oorvloei met die gewenste grootte.
* Die aanval begin deur 3 brokkies te skep: brokkie0 om die oorvloei te misbruik, brokkie1 om oorvloei te h√™ en brokkie2 sodat die boonste brokkie nie konsolideer met die voriges nie.
* Dan word brokkie1 vrygestel en brokkie0 word oorvloei sodat die `bk`-aanwyser van brokkie1 na `bk = magic - 0x10` wys
* Dan word brokkie3 toegewys met dieselfde grootte as brokkie1, wat die ongeorden bin aanval sal aktiveer en die waarde van die globale veranderlike sal wysig, wat dit moontlik maak om die vlag te kry.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die saamvoegfunksie is kwesbaar omdat as beide indekse wat oorgedra word dieselfde is, sal dit daarop herallokeer en dit dan vrymaak, maar 'n aanwyser na daardie vrygemaakte gebied teruggee wat gebruik kan word.
* Daarom word **2 brokkies geskep**: **brokkie0** wat met homself saamgevoeg gaan word en brokkie1 om konsolidering met die boonste brokkie te voorkom. Dan word die **saamvoegfunksie twee keer met brokkie0** geroep wat 'n gebruik na vry sal veroorsaak.
* Dan word die **`view`-funksie geroep met indeks 2** (wat die indeks van die gebruik na vry brokkie is), wat 'n libc-adres sal lek.
* Aangesien die bin√™re beskermings het om slegs groottes groter as **`global_max_fast`** toe te ken sodat geen vinnige bin gebruik word nie, gaan 'n ongeorden bin aanval gebruik word om die globale veranderlike `global_max_fast` te oorskryf.
* Dan is dit moontlik om die wysigingsfunksie met indeks 2 (die gebruik na vry aanwyser) te roep en die `bk`-aanwyser te oorskryf om te wys na `p64(global_max_fast-0x10)`. Dan, deur 'n nuwe brokkie te skep, sal die vorige gekompromitteerde vry adres (0x20) gebruik word om die ongeorden bin aanval te **aktiveer** deur die `global_max_fast` te oorskryf met 'n baie groot waarde, wat nou toelaat om brokkies in vinnige bakkies te skep.
* Nou word 'n **vinnige bin aanval** uitgevoer:
* Eerstens word ontdek dat dit moontlik is om te werk met vinnige **brokkies van grootte 200** op die **`__free_hook`-plek:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200**
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* As ons daarin slaag om 'n vinnige stuk van grootte 0x200 op hierdie plek te kry, sal dit moontlik wees om 'n funksie-aanwyser te oorskryf wat uitgevoer sal word
* Hiervoor word 'n nuwe stuk van grootte `0xfc` geskep en die saamgevoegde funksie word twee keer geroep met daardie aanwyser, op hierdie manier verkry ons 'n aanwyser na 'n vrygemaakte stuk van grootte `0xfc*2 = 0x1f8` in die vinnige bin.
* Dan word die wysigingsfunksie in hierdie stuk geroep om die **`fd`**-adres van hierdie vinnige bin te wysig om te wys na die vorige **`__free_hook`**-funksie.
* Dan word 'n stuk met grootte `0x1f8` geskep om uit die vinnige bin die vorige nuttelose stuk te herwin sodat 'n ander stuk met grootte `0x1f8` geskep kan word om 'n vinnige bin-stuk in die **`__free_hook`** te kry wat oorskryf is met die adres van die **`system`**-funksie.
* En uiteindelik word 'n stuk wat die string `/bin/sh\x00` bevat, vrygelaat deur die verwyderingsfunksie te roep, wat die **`__free_hook`**-funksie aktiveer wat na system wys met `/bin/sh\x00` as parameter.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* 'n Ander voorbeeld van die misbruik van 'n 1B-oorvloei om stukke in die ongesorteerde bin te konsolideer en 'n libc-infolek te kry en dan 'n vinnige bin-aanval uit te voer om die malloc-aanwyser met 'n een-gadget-adres te oorskryf
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Ons kan slegs stukke van grootte groter as `0x100` toewys.
* Oorskryf `global_max_fast` deur 'n Ongesorteerde Bin-aanval te gebruik (werk 1/16 keer as gevolg van ASLR, omdat ons 12 bietjies moet wysig, maar ons moet 16 bietjies wysig).
* Vinnige Bin-aanval om die 'n globale reeks stukke te wysig. Dit gee 'n arbitraire lees-/skryf-beginsel, wat dit moontlik maak om die GOT te wysig en sommige funksies te laat wys na `system`.

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
