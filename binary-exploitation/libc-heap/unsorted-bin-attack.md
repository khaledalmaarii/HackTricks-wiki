# Atak na nieposortowany kubeÅ‚ek

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) albo **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Aby uzyskaÄ‡ wiÄ™cej informacji na temat tego, co oznacza kubeÅ‚ek nieposortowany, sprawdÅº tÄ™ stronÄ™:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Nieposortowane listy mogÄ… zapisaÄ‡ adres w `unsorted_chunks (av)` w adresie `bk` fragmentu. Dlatego jeÅ›li atakujÄ…cy moÅ¼e **zmodyfikowaÄ‡ adres wskaÅºnika `bk`** w fragmencie w kubeÅ‚ku nieposortowanym, moÅ¼e **zapisaÄ‡ ten adres w dowolnym adresie**, co moÅ¼e pomÃ³c w wycieku adresÃ³w Glibc lub obejÅ›ciu niektÃ³rych zabezpieczeÅ„.

W zasadzie ten atak pozwala **ustawiÄ‡ duÅ¼Ä… liczbÄ™ pod dowolnym adresem**. Ta duÅ¼a liczba to adres, ktÃ³ry moÅ¼e byÄ‡ adresem sterty lub adresem Glibc. Typowym celem jest **`global_max_fast`**, aby umoÅ¼liwiÄ‡ tworzenie kubeÅ‚kÃ³w fast bin o wiÄ™kszych rozmiarach (i przejÅ›cie od ataku na kubeÅ‚ek nieposortowany do ataku na fast bin).

{% hint style="success" %}
Przyjrzenie siÄ™ przykÅ‚adowi podanemu w [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) i uÅ¼ycie 0x4000 i 0x5000 zamiast 0x400 i 0x500 jako rozmiarÃ³w fragmentÃ³w (aby uniknÄ…Ä‡ Tcache) pozwala zobaczyÄ‡, Å¼e **obecnie** bÅ‚Ä…d **`malloc(): unsorted double linked list corrupted`** jest wywoÅ‚ywany.

Dlatego teraz ten atak na kubeÅ‚ek nieposortowany (oprÃ³cz innych sprawdzeÅ„) wymaga rÃ³wnieÅ¼ naprawienia zduplikowanej listy poÅ‚Ä…czonej, aby to ominÄ…Ä‡ `victim->bk->fd == victim` lub nie `victim->fd == av (arena)`, co oznacza, Å¼e adres, gdzie chcemy zapisaÄ‡, musi mieÄ‡ adres faÅ‚szywego fragmentu w swojej pozycji `fd` i Å¼e faÅ‚szywy fragment `fd` wskazuje na arenÄ™.
{% endhint %}

{% hint style="danger" %}
ZauwaÅ¼, Å¼e ten atak psuje kubeÅ‚ek nieposortowany (a takÅ¼e maÅ‚y i duÅ¼y). Dlatego teraz moÅ¼emy **korzystaÄ‡ tylko z alokacji z kubeÅ‚ka fast bin** (bardziej zÅ‚oÅ¼ony program moÅ¼e wykonywaÄ‡ inne alokacje i siÄ™ zawieszaÄ‡), aby wywoÅ‚aÄ‡ to musimy **zaalokowaÄ‡ ten sam rozmiar, inaczej program siÄ™ zawiesi.**

ZauwaÅ¼, Å¼e nadpisanie **`global_max_fast`** moÅ¼e pomÃ³c w tym przypadku, zakÅ‚adajÄ…c, Å¼e kubeÅ‚ek fast bÄ™dzie w stanie obsÅ‚uÅ¼yÄ‡ wszystkie inne alokacje, aÅ¼ atak zostanie zakoÅ„czony.
{% endhint %}

Kod od [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) dobrze to wyjaÅ›nia, chociaÅ¼ jeÅ›li zmodyfikujesz alokacje pamiÄ™ci, aby alokowaÄ‡ pamiÄ™Ä‡ wystarczajÄ…co duÅ¼Ä…, aby nie trafiÄ‡ do Tcache, zobaczysz, Å¼e wczeÅ›niej wspomniany bÅ‚Ä…d uniemoÅ¼liwia zastosowanie tej techniki: **`malloc(): unsorted double linked list corrupted`**

## Atak na wyciek informacji z kubeÅ‚ka nieposortowanego

To tak naprawdÄ™ bardzo podstawowe pojÄ™cie. Fragmenty w kubeÅ‚ku nieposortowanym bÄ™dÄ… miaÅ‚y wskaÅºniki. Pierwszy fragment w kubeÅ‚ku nieposortowanym bÄ™dzie faktycznie mieÄ‡ **linki `fd` i `bk` wskazujÄ…ce na czÄ™Å›Ä‡ gÅ‚Ã³wnej areny (Glibc)**.\
Dlatego jeÅ›li moÅ¼esz **umieÅ›ciÄ‡ fragment w kubeÅ‚ku nieposortowanym i odczytaÄ‡ go** (uÅ¼yj po zwolnieniu) lub **ponownie go zaalokowaÄ‡ bez nadpisywania co najmniej 1 z wskaÅºnikÃ³w**, aby nastÄ™pnie go **odczytaÄ‡**, moÅ¼esz uzyskaÄ‡ **wyciek informacji z Glibc**.

Podobny [**atak uÅ¼yty w tym opisie**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), polegaÅ‚ na wykorzystaniu struktury 4 fragmentÃ³w (A, B, C i D - D sÅ‚uÅ¼yÅ‚ tylko do zapobieÅ¼enia konsolidacji z gÃ³rnym fragmentem), wiÄ™c przepeÅ‚nienie zerowymi bajtami w B zostaÅ‚o wykorzystane do spowodowania, Å¼e C wskazywaÅ‚o, Å¼e B jest nieuÅ¼ywane. Ponadto w B zmodyfikowano dane `prev_size`, wiÄ™c rozmiar zamiast byÄ‡ rozmiarem B, byÅ‚ A+B.\
NastÄ™pnie C zostaÅ‚o zwolnione i skonsolidowane z A+B (ale B nadal byÅ‚ uÅ¼ywany). Zaalokowano nowy fragment o rozmiarze A, a nastÄ™pnie wyciekÅ‚y adresy Glibc, ktÃ³re zostaÅ‚y zapisane w B, skÄ…d zostaÅ‚y wyciekniÄ™te.

## OdwoÅ‚ania i inne przykÅ‚ady

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Celem jest nadpisanie zmiennej globalnej wartoÅ›ciÄ… wiÄ™kszÄ… niÅ¼ 4869, aby moÅ¼na byÅ‚o uzyskaÄ‡ flagÄ™, a PIE nie jest wÅ‚Ä…czone.
* MoÅ¼liwe jest generowanie fragmentÃ³w o dowolnych rozmiarach i wystÄ™puje przepeÅ‚nienie sterty o poÅ¼Ä…danym rozmiarze.
* Atak rozpoczyna siÄ™ od utworzenia 3 fragmentÃ³w: fragmentu0 do wykorzystania przepeÅ‚nienia, fragmentu1 do przepeÅ‚nienia i fragmentu2, aby gÃ³rny fragment nie konsolidowaÅ‚ poprzednich.
* NastÄ™pnie fragment1 jest zwalniany, a fragment0 jest przepeÅ‚niany, aby wskaÅºnik `bk` fragmentu1 wskazywaÅ‚ na: `bk = magic - 0x10`
* NastÄ™pnie alokowany jest fragment3 o tym samym rozmiarze co fragment1, co spowoduje atak na kubeÅ‚ek nieposortowany i zmodyfikuje wartoÅ›Ä‡ zmiennej globalnej, umoÅ¼liwiajÄ…c uzyskanie flagi.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Funkcja Å‚Ä…czenia jest podatna, poniewaÅ¼ jeÅ›li oba przekazane indeksy sÄ… takie same, to zrealokuje na to i zwolni, ale zwrÃ³ci wskaÅºnik do tego zwolnionego obszaru, ktÃ³ry moÅ¼e byÄ‡ uÅ¼yty.
* Dlatego **tworzone sÄ… 2 fragmenty**: **fragment0**, ktÃ³ry zostanie poÅ‚Ä…czony sam ze sobÄ… i fragment1, aby zapobiec konsolidacji z gÃ³rnym fragmentem. NastÄ™pnie funkcja **merge jest wywoÅ‚ywana z fragmentem0** dwukrotnie, co spowoduje uÅ¼ycie po zwolnieniu.
* NastÄ™pnie wywoÅ‚ywana jest funkcja **`view`** z indeksem 2 (ktÃ³ry jest indeksem fragmentu uÅ¼ytego po zwolnieniu), co spowoduje **wyciek adresu libc**.
* PoniewaÅ¼ binarny ma zabezpieczenia, aby alokowaÄ‡ tylko rozmiary wiÄ™ksze niÅ¼ **`global_max_fast`**, wiÄ™c nie uÅ¼ywany jest fastbin, atak na kubeÅ‚ek nieposortowany zostanie uÅ¼yty do nadpisania zmiennej globalnej `global_max_fast`.
* NastÄ™pnie moÅ¼liwe jest wywoÅ‚anie funkcji edycji z indeksem 2 (wskaÅºnik uÅ¼yty po zwolnieniu) i nadpisanie wskaÅºnika `bk`, aby wskazywaÅ‚ na `p64(global_max_fast-0x10)`. NastÄ™pnie tworzenie nowego fragmentu uÅ¼yje wczeÅ›niej skompromitowanego adresu zwolnienia (0x20) i **spowoduje atak na kubeÅ‚ek nieposortowany**, nadpisujÄ…c `global_max_fast` duÅ¼Ä… wartoÅ›ciÄ…, co teraz pozwala na tworzenie fragmentÃ³w w kubeÅ‚kach fast.
* Teraz wykonywany jest **atak na fast bin**:
* Po pierwsze odkryto, Å¼e moÅ¼liwe jest pracowanie z szybkimi **fragmentami o rozmiarze 200** w lokalizacji **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gefâ¤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gefâ¤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* JeÅ›li uda nam siÄ™ uzyskaÄ‡ szybki kawaÅ‚ek o rozmiarze 0x200 w tej lokalizacji, bÄ™dzie moÅ¼liwe nadpisanie wskaÅºnika funkcji, ktÃ³ry zostanie wykonany
* W tym celu tworzony jest nowy kawaÅ‚ek o rozmiarze `0xfc` i funkcja scalajÄ…ca jest wywoÅ‚ywana z tym wskaÅºnikiem dwukrotnie, w ten sposÃ³b uzyskujemy wskaÅºnik do zwolnionego kawaÅ‚ka o rozmiarze `0xfc*2 = 0x1f8` w szybkim pojemniku.
* NastÄ™pnie funkcja edycji jest wywoÅ‚ywana w tym kawaÅ‚ku, aby zmodyfikowaÄ‡ adres **`fd`** tego szybkiego pojemnika wskazujÄ…cy na poprzedniÄ… funkcjÄ™ **`__free_hook`**.
* NastÄ™pnie tworzony jest kawaÅ‚ek o rozmiarze `0x1f8` w celu pobrania z szybkiego pojemnika poprzedniego nieuÅ¼ytecznego kawaÅ‚ka, wiÄ™c tworzony jest kolejny kawaÅ‚ek o rozmiarze `0x1f8`, aby uzyskaÄ‡ kawaÅ‚ek z szybkiego pojemnika w **`__free_hook`**, ktÃ³ry jest nadpisany adresem funkcji **`system`**.
* I wreszcie zwalniany jest kawaÅ‚ek zawierajÄ…cy ciÄ…g znakÃ³w `/bin/sh\x00`, wywoÅ‚ujÄ…c funkcjÄ™ usuwania, co powoduje wywoÅ‚anie funkcji **`__free_hook`**, ktÃ³ra wskazuje na system z parametrem `/bin/sh\x00`.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Kolejny przykÅ‚ad naduÅ¼ycia przepeÅ‚nienia o 1B w celu skonsolidowania kawaÅ‚kÃ³w w nieuporzÄ…dkowanym pojemniku i uzyskania wycieku informacji o libc, a nastÄ™pnie przeprowadzenia ataku na szybki pojemnik w celu nadpisania haka malloc adresem jednego gadÅ¼etu
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* MoÅ¼emy przydzielaÄ‡ tylko kawaÅ‚ki o rozmiarze wiÄ™kszym niÅ¼ `0x100`.
* Nadpisanie `global_max_fast` za pomocÄ… ataku na nieuporzÄ…dkowany pojemnik (dziaÅ‚a 1/16 razy ze wzglÄ™du na ASLR, poniewaÅ¼ musimy zmodyfikowaÄ‡ 12 bitÃ³w, ale musimy zmodyfikowaÄ‡ 16 bitÃ³w).
* Atak na szybki pojemnik w celu zmodyfikowania globalnej tablicy kawaÅ‚kÃ³w. Zapewnia to arbitralne odczyt/zapis, co pozwala na modyfikacjÄ™ GOT i ustawienie pewnej funkcji na wskazanie `system`.
