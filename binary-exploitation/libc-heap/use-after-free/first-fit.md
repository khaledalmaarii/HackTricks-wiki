# First Fit

{% hint style="success" %}
Lernen Sie & √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
{% endhint %}

## **First Fit**

Wenn Sie im Programm Speicher freigeben, der glibc verwendet, werden verschiedene "Bins" verwendet, um die Speicherbl√∂cke zu verwalten. Hier ist eine vereinfachte Erkl√§rung von zwei h√§ufigen Szenarien: unsorted bins und fastbins.

### Unsorted Bins

Wenn Sie einen Speicherblock freigeben, der kein schneller Block ist, wird er in den unsorted bin verschoben. Dieser Bin fungiert wie eine Liste, in die neue freigegebene Bl√∂cke vorne (dem "Kopf") hinzugef√ºgt werden. Wenn Sie einen neuen Speicherblock anfordern, schaut der Allocator am Ende des unsorted bin (dem "Schwanz"), um einen ausreichend gro√üen Block zu finden. Wenn ein Block aus dem unsorted bin gr√∂√üer ist als das, was Sie ben√∂tigen, wird er aufgeteilt, wobei der vordere Teil zur√ºckgegeben wird und der verbleibende Teil im Bin verbleibt.

Beispiel:

* Sie allozieren 300 Bytes (`a`), dann 250 Bytes (`b`), geben `a` frei und fordern erneut 250 Bytes an (`c`).
* Wenn Sie `a` freigeben, wird es in den unsorted bin verschoben.
* Wenn Sie dann erneut 250 Bytes anfordern, findet der Allocator `a` am Ende und teilt ihn auf, gibt den Teil zur√ºck, der Ihrer Anforderung entspricht, und beh√§lt den Rest im Bin.
* `c` wird auf das vorherige `a` zeigen und mit den `a's` gef√ºllt sein.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins werden f√ºr kleine Speicherbl√∂cke verwendet. Im Gegensatz zu unsortierten Bins f√ºgen Fastbins neue Bl√∂cke am Anfang hinzu, was ein Last-In-First-Out (LIFO)-Verhalten erzeugt. Wenn Sie einen kleinen Speicherblock anfordern, wird der Allocator diesen vom Kopf des Fastbins abrufen.

Beispiel:

* Sie allozieren vier Bl√∂cke von jeweils 20 Bytes (`a`, `b`, `c`, `d`).
* Wenn Sie sie in beliebiger Reihenfolge freigeben, werden die freigegebenen Bl√∂cke am Anfang des Fastbins hinzugef√ºgt.
* Wenn Sie dann einen 20-Byte-Block anfordern, wird der Allocator den zuletzt freigegebenen Block vom Kopf des Fastbins zur√ºckgeben.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Weitere Referenzen & Beispiele

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Erstellen eines Benutzerobjekts, Freigeben, Erstellen eines Objekts, das den freigegebenen Chunk erh√§lt und das Schreiben darauf erm√∂glicht, **√úberschreiben der Position von user->password** aus dem vorherigen. Wiederverwendung des Benutzers, um die Passwortpr√ºfung zu **umgehen**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Das Programm erm√∂glicht das Erstellen von Notizen. Eine Notiz enth√§lt die Notizinformationen in einem malloc(8) (mit einem Zeiger auf eine Funktion, die aufgerufen werden k√∂nnte) und einen Zeiger auf ein weiteres malloc(\<size>) mit dem Inhalt der Notiz.
* Der Angriff w√ºrde darin bestehen, 2 Notizen (note0 und note1) mit gr√∂√üeren malloc-Inhalten als der Notizinfo-Gr√∂√üe zu erstellen und sie dann freizugeben, damit sie in den Fast Bin (oder Tcache) gelangen.
* Erstellen Sie dann eine weitere Notiz (note2) mit einer Inhaltsgr√∂√üe von 8. Der Inhalt wird in note1 sein, da der Chunk wiederverwendet wird, wo wir den Funktionszeiger √§ndern k√∂nnten, um auf die Gewinnfunktion zu zeigen, und dann Use-After-Free die note1 aufrufen, um den neuen Funktionszeiger aufzurufen.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* Es ist m√∂glich, etwas Speicher zuzuweisen, den gew√ºnschten Wert zu schreiben, ihn freizugeben, ihn neu zuzuweisen und da die vorherigen Daten noch vorhanden sind, wird er gem√§√ü der neuen erwarteten Struktur im Chunk behandelt, was es erm√∂glicht, den Wert zu setzen oder die Flagge zu erhalten.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* In diesem Fall muss die Zahl 4 in einem bestimmten Chunk geschrieben werden, der als erster zugewiesen wird (auch nachdem alle zwangsweise freigegeben wurden). Bei jedem neuen zugewiesenen Chunk wird seine Nummer im Arrayindex gespeichert. Dann 4 Chunks (+ der anf√§nglich zugewiesene) zuweisen, der letzte wird 4 enthalten, sie freigeben und die erneute Zuweisung des ersten erzwingen, der den zuletzt freigegebenen Chunk verwenden wird, der den Wert 4 enth√§lt.
