# Prva Fit

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJEM**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Prva Fit**

Kada oslobaÄ‘ate memoriju u programu koristeÄ‡i glibc, razliÄite "bins" se koriste za upravljanje delovima memorije. Evo pojednostavljena objaÅ¡njenja dva uobiÄajena scenarija: nesortirani bins i brzi bins.

### Nesortirani Bins

Kada oslobodite deo memorije koji nije brzi deo, on ide u nesortirani bin. Ovaj bin deluje kao lista gde se novi osloboÄ‘eni delovi dodaju na poÄetak (â€glavuâ€œ). Kada zatraÅ¾ite novi deo memorije, alokator gleda u nesortirani bin sa zadnje strane (â€repâ€œ) da pronaÄ‘e deo koji je dovoljno velik. Ako je deo iz nesortiranog bina veÄ‡i od onoga Å¡to vam je potrebno, on se deli, pri Äemu se prednji deo vraÄ‡a, a preostali deo ostaje u binu.

Primer:

* Alokujete 300 bajtova (`a`), zatim 250 bajtova (`b`), oslobodite `a` i zatim ponovo zatraÅ¾ite 250 bajtova (`c`).
* Kada oslobodite `a`, ide u nesortirani bin.
* Ako zatim ponovo zatraÅ¾ite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraÄ‡ajuÄ‡i deo koji odgovara vaÅ¡em zahtevu i zadrÅ¾avajuÄ‡i ostatak u binu.
* `c` Ä‡e pokazivati na prethodni `a` i biti popunjen sa `a`-ima.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male memorijske blokove. Za razliku od nesortiranih kanti, fastbins dodaju nove blokove na poÄetak, stvarajuÄ‡i last-in-first-out (LIFO) ponaÅ¡anje. Ako zatraÅ¾ite mali blok memorije, alokator Ä‡e uzeti blok sa poÄetka fastbina.

Primer:

* Alokujete Äetiri bloka od po 20 bajtova svaki (`a`, `b`, `c`, `d`).
* Kada ih oslobodite u bilo kom redosledu, osloboÄ‘eni blokovi se dodaju na poÄetak fastbina.
* Ako zatim zatraÅ¾ite blok od 20 bajtova, alokator Ä‡e vratiti najskorije osloboÄ‘eni blok sa poÄetka fastbina.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Ostale reference i primeri

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. KoriÅ¡Ä‡enje nakon oslobaÄ‘anja: Generisanje korisniÄkog objekta, oslobaÄ‘anje istog, generisanje objekta koji dobija osloboÄ‘eni blok i omoguÄ‡ava pisanje u njega, **prepisivanje pozicije korisnikovog->Å¡ifra** iz prethodnog. Ponovno koriÅ¡Ä‡enje korisnika da **zaobiÄ‘e proveru Å¡ifre**
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* Program omoguÄ‡ava kreiranje beleÅ¡ki. BeleÅ¡ka Ä‡e imati informacije o beleÅ¡ci u malloc(8) (sa pokazivaÄem na funkciju koja moÅ¾e biti pozvana) i pokazivaÄ na drugi malloc(\<size>) sa sadrÅ¾ajem beleÅ¡ke.
* Napad bi bio da se kreiraju 2 beleÅ¡ke (beleÅ¡ka0 i beleÅ¡ka1) sa veÄ‡im malloc sadrÅ¾ajem od veliÄine informacija o beleÅ¡ci, a zatim ih oslobode kako bi se naÅ¡le u brzom binu (ili tcache).
* Zatim, kreirajte joÅ¡ jednu beleÅ¡ku (beleÅ¡ka2) sa veliÄinom sadrÅ¾aja 8. SadrÅ¾aj Ä‡e biti u beleÅ¡ci1 jer Ä‡e se blok ponovo koristiti, gde bismo mogli izmeniti pokazivaÄ funkcije da pokazuje na funkciju za pobedu, a zatim koristiti Nakon-OslobaÄ‘anja beleÅ¡ku1 da pozove novi pokazivaÄ funkcije.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* MoguÄ‡e je alocirati neÅ¡to memorije, upisati Å¾eljenu vrednost, osloboditi je, ponovo alocirati i poÅ¡to su prethodni podaci i dalje tu, biÄ‡e tretirani prema novoj oÄekivanoj strukturi u bloku Å¡to omoguÄ‡ava postavljanje vrednosti ili dobijanje zastave.
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* U ovom sluÄaju je potrebno upisati 4 unutar specifiÄnog bloka koji je prvi alociran (Äak i nakon prinudnog oslobaÄ‘anja svih njih). Na svakom novom alociranom bloku Äuva se njegov broj u indeksu niza. Zatim, alocirajte 4 bloka (+ poÄetno alociran), poslednji Ä‡e imati unutar sebe 4, oslobodite ih i prinudno ponovo alocirajte prvi, koji Ä‡e koristiti poslednji osloboÄ‘eni blok koji ima unutar sebe 4.
