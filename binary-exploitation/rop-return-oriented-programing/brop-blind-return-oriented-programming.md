# BROP - KÃ¶rÃ¼klÃ¼ DÃ¶nÃ¼ÅŸ YÃ¶nlÃ¼ Programlama

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong> ile</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklam gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**]'na gÃ¶z atÄ±n (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin**.
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks ve HackTricks Cloud github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n**.

</details>

## Temel Bilgiler

Bu saldÄ±rÄ±nÄ±n amacÄ±, **zararlÄ± bir ikili hakkÄ±nda hiÃ§bir bilgi olmadan bir ROP'u bir tampon taÅŸmasÄ± aracÄ±lÄ±ÄŸÄ±yla kÃ¶tÃ¼ye kullanabilmektir**.\
Bu saldÄ±rÄ± aÅŸaÄŸÄ±daki senaryoya dayanmaktadÄ±r:

* Bir yÄ±ÄŸÄ±n gÃ¼venlik aÃ§Ä±ÄŸÄ± ve nasÄ±l tetikleneceÄŸi hakkÄ±nda bilgi.
* Bir Ã§Ã¶kme sonrasÄ± yeniden baÅŸlatan bir sunucu uygulamasÄ±.

## SaldÄ±rÄ±

### **1. Hassas ofseti bulma** sunucunun bir arÄ±za tespit edilene kadar bir karakter daha gÃ¶nderilmesi

### **2. Canary'yi kaba kuvvetle Ã§Ã¶zme** sÄ±zdÄ±rmak iÃ§in&#x20;

### **3. DepolanmÄ±ÅŸ RBP ve RIP'yi kaba kuvvetle Ã§Ã¶zme** adreslerini sÄ±zdÄ±rmak iÃ§in yÄ±ÄŸÄ±nda

Bu sÃ¼reÃ§ler hakkÄ±nda daha fazla bilgiyi [burada (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) ve [burada (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md) bulabilirsiniz.

### **4. Durak cihazÄ±nÄ± bulma**

Bu cihaz temelde, ROP cihazÄ± tarafÄ±ndan bir ÅŸeyin ilginÃ§ bir ÅŸekilde yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nÃ¼ onaylamaya izin verir Ã§Ã¼nkÃ¼ yÃ¼rÃ¼tme Ã§Ã¶kmemiÅŸtir. Genellikle, bu cihaz genellikle yÃ¼rÃ¼tmenin durmasÄ±na neden olan bir ÅŸey olacaktÄ±r ve belirli bir ROP cihazÄ±nÄ±n yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nÃ¼ doÄŸrulamak iÃ§in ROP cihazlarÄ±nÄ± ararken ROP zincirinin sonunda konumlandÄ±rÄ±lÄ±r.

### **5. BROP cihazÄ±nÄ± bulma**

Bu teknik [**ret2csu**](ret2csu.md) cihazÄ±nÄ± kullanÄ±r. Ve bu, bu cihaza eriÅŸirseniz, **`rsi`** ve **`rdi`**'yi kontrol etmek iÃ§in cihazlar elde edersiniz:

<figure><img src="../../.gitbook/assets/image.png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Bunlar cihazlar olacaktÄ±r:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Bu cihazlarla **bir iÅŸlevin 2 argÃ¼manÄ±nÄ± kontrol etmek mÃ¼mkÃ¼ndÃ¼r**.

AyrÄ±ca, ret2csu cihazÄ±nÄ±n **Ã§ok benzersiz bir imzasÄ±** olduÄŸuna dikkat edin Ã§Ã¼nkÃ¼ yÄ±ÄŸÄ±ndan 6 kaydÄ± Ã§Ä±karacak. Bu nedenle, aÅŸaÄŸÄ±daki gibi bir zincir gÃ¶ndermek mÃ¼mkÃ¼ndÃ¼r:

`'A' * ofset + canary + rbp + ADRES + 0xdead * 6 + DUR`

EÄŸer **DUR yÃ¼rÃ¼tÃ¼lÃ¼rse**, bu temelde yÄ±ÄŸÄ±ndan 6 kaydÄ± Ã§Ä±karan bir adresin kullanÄ±ldÄ±ÄŸÄ± anlamÄ±na gelir. Veya kullanÄ±lan adres aynÄ± zamanda bir DUR adresiydi.

Bu son seÃ§eneÄŸi **kaldÄ±rmak iÃ§in** Ã¶nceki birinin 6 kaydÄ± Ã§Ä±kardÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in aÅŸaÄŸÄ±daki gibi yeni bir zincir yÃ¼rÃ¼tÃ¼lÃ¼r ve DUR cihazÄ±nÄ± yÃ¼rÃ¼tmemesi gerekir:

`'A' * ofset + canary + rbp + ADRES`

ret2csu cihazÄ±nÄ±n adresini bildiÄŸinizde, **`rsi` ve `rdi`'yi kontrol etmek iÃ§in cihazlarÄ±n adresini Ã§Ä±karabilirsiniz**.

### 6. PLT'yi bulma

PLT tablosu, 0x400000'den veya yÄ±ÄŸÄ±n Ã¼zerindeki **sÄ±zdÄ±rÄ±lan RIP adresinden** (eÄŸer **PIE** kullanÄ±lÄ±yorsa) aranabilir. Tablonun **giriÅŸleri** 16B (0x10B) ile ayrÄ±lmÄ±ÅŸtÄ±r ve bir iÅŸlev Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda sunucu Ã§Ã¶kmez, hatta argÃ¼manlar doÄŸru deÄŸilse. AyrÄ±ca, **PLT + 6B'deki bir giriÅŸ adresi de Ã§Ã¶kmÃ¼yor** Ã§Ã¼nkÃ¼ bu ilk kodu yÃ¼rÃ¼tÃ¼len yerdir.

Bu nedenle, PLT tablosunu bulmak iÃ§in aÅŸaÄŸÄ±daki davranÄ±ÅŸlarÄ± kontrol etmek mÃ¼mkÃ¼ndÃ¼r:

* `'A' * ofset + canary + rbp + ADRES + DUR` -> Ã§Ã¶kme olmaz
* `'A' * ofset + canary + rbp + (ADRES + 0x6) + DUR` -> Ã§Ã¶kme olmaz
* `'A' * ofset + canary + rbp + (ADRES + 0x10) + DUR` -> Ã§Ã¶kme olmaz

### 7. strcmp'i bulma

**`strcmp`** iÅŸlevi, karÅŸÄ±laÅŸtÄ±rÄ±lan dize uzunluÄŸunu belirten **`rdx`** kaydÄ±nÄ± ayarlar. **`rdx`**'in **Ã¼Ã§Ã¼ncÃ¼ argÃ¼man** olduÄŸunu ve daha sonra programÄ± sÄ±zdÄ±rmak iÃ§in `write`'Ä± kullanabilmek iÃ§in 0'dan bÃ¼yÃ¼k olmasÄ± gerektiÄŸini unutmayÄ±n.

Åimdi, artÄ±k fonksiyonlarÄ±n ilk 2 argÃ¼manÄ±nÄ± kontrol edebildiÄŸimiz gerÃ§eÄŸini kullanarak, **`strcmp`**'in PLT'deki konumunu bulmak mÃ¼mkÃ¼ndÃ¼r:

* strcmp(\<okunmayan adres>, \<okunmayan adres>) -> Ã§Ã¶kme
* strcmp(\<okunmayan adres>, \<okunan adres>) -> Ã§Ã¶kme
* strcmp(\<okunan adres>, \<okunmayan adres>) -> Ã§Ã¶kme
* strcmp(\<okunan adres>, \<okunan adres>) -> Ã§Ã¶kme olmaz

Bunu kontrol etmek iÃ§in PLT tablosunun her giriÅŸini Ã§aÄŸÄ±rarak veya **PLT yavaÅŸ yolu**'nu kullanarak yapÄ±labilir. Bu temelde, **PLT tablosundaki bir giriÅŸi + 0xb** (ki bu **`dlresolve`**'a Ã§aÄŸrÄ± yapar) Ã§aÄŸÄ±rmak ve yÄ±ÄŸÄ±nda **denetlemek istediÄŸiniz giriÅŸ numarasÄ±** (sÄ±fÄ±rdan baÅŸlayarak) ile tÃ¼m PLT giriÅŸlerini taramak anlamÄ±na gelir:

* strcmp(\<okunmayan adres>, \<okunan adres>) -> Ã§Ã¶kme
* `b'A' * ofset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(GÄ°RÄ°Å) + DUR` -> Ã‡Ã¶kecek
* strcmp(\<okunan adres>, \<okunmayan adres>) -> Ã§Ã¶kme
* `b'A' * ofset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(GÄ°RÄ°Å) + DUR`&#x20;
* strcmp(\<okunan adres>, \<okunan adres>) -> Ã§Ã¶kme olmaz
* `b'A' * ofset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(GÄ°RÄ°Å) + DUR`&#x20;

UnutmayÄ±n ki:

* BROP + 0x7 **`pop RSI; pop R15; ret;`'e iÅŸaret eder**
* BROP + 0x9 **`pop RDI; ret;`'e iÅŸaret eder**
* PLT + 0xb **`dl\_resolve`'a bir Ã§aÄŸrÄ± yapar**.

`strcmp` bulunduÄŸunda, **`rdx`**'i 0'dan bÃ¼yÃ¼k bir deÄŸere ayarlamak mÃ¼mkÃ¼n olacaktÄ±r.

{% hint style="success" %}
Genellikle `rdx` zaten 0'dan bÃ¼yÃ¼k bir deÄŸere sahip olacaktÄ±r, bu nedenle bu adÄ±m gerekli olmayabilir.
{% endhint %}
### 8. Write Veya EÅŸdeÄŸeri Bulma

Son olarak, ikili dosyayÄ± dÄ±ÅŸa aktarmak iÃ§in veri dÄ±ÅŸa aktaran bir araca ihtiyaÃ§ duyulmaktadÄ±r. Ve bu noktada **2 argÃ¼manÄ± kontrol etmek ve `rdx`'i 0'dan bÃ¼yÃ¼k ayarlamak mÃ¼mkÃ¼ndÃ¼r.**

Bunu yapmak iÃ§in kÃ¶tÃ¼ye kullanÄ±labilecek 3 yaygÄ±n fonksiyon bulunmaktadÄ±r:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Ancak, orijinal makale sadece **`write`**'Ä± belirtir, bu yÃ¼zden ondan bahsedelim:

Mevcut sorun, **write fonksiyonunun PLT iÃ§inde nerede olduÄŸunu bilmiyoruz** ve **verileri soketimize gÃ¶ndermek iÃ§in bir fd numarasÄ± bilmiyoruz**.

Ancak, **PLT tablosunun nerede olduÄŸunu biliyoruz** ve davranÄ±ÅŸÄ±na dayanarak write'Ä± bulmak mÃ¼mkÃ¼ndÃ¼r. Ve sunucuyla **birkaÃ§ baÄŸlantÄ± oluÅŸturabiliriz ve yÃ¼ksek bir FD kullanarak** baÄŸlantÄ±larÄ±mÄ±zdan bazÄ±larÄ±yla eÅŸleÅŸmesini umabiliriz.

Bu fonksiyonlarÄ± bulmak iÃ§in davranÄ±ÅŸ imzalarÄ±:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Veri yazdÄ±rÄ±lÄ±yorsa, puts bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Veri yazdÄ±rÄ±lÄ±yorsa, dprintf bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Veri yazdÄ±rÄ±lÄ±yorsa, write bulundu

## Otomatik SÃ¶mÃ¼rÃ¼

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referanslar

* Orijinal makale: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
