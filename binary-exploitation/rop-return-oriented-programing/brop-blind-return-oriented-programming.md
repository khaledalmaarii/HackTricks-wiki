# BROP - Slepa povratno orijentisana programiranje

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Cilj ovog napada je da se **zloupotrebi ROP putem prelivanja bafera bez ikakvih informacija o ranjivom binarnom fajlu**.\
Ovaj napad se zasniva na sledeÄ‡em scenariju:

* Ranjivost steka i poznavanje kako je pokrenuti.
* Server aplikacija koja se ponovo pokreÄ‡e nakon pada.

## Napad

### **1. PronalaÅ¾enje ranjivog ofseta** slanjem joÅ¡ jednog karaktera dok se ne detektuje kvar servera

### **2. Bruteforsiranje kanara** da bi se otkrio

### **3. Bruteforsiranje smeÅ¡tenih RBP i RIP** adresa na steku da bi se otkrile

ViÅ¡e informacija o ovim procesima moÅ¾ete pronaÄ‡i [ovde (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) i [ovde (BF Adrese na Steku)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. PronalaÅ¾enje stop gedÅ¾eta**

Ovaj gedÅ¾et omoguÄ‡ava potvrdu da je neÅ¡to zanimljivo izvrÅ¡eno pomoÄ‡u ROP gedÅ¾eta jer izvrÅ¡enje nije puklo. ObiÄno, ovaj gedÅ¾et Ä‡e biti neÅ¡to Å¡to **zaustavlja izvrÅ¡enje** i biÄ‡e pozicioniran na kraju ROP lanca prilikom traÅ¾enja ROP gedÅ¾eta da bi se potvrdilo da je odreÄ‘eni ROP gedÅ¾et izvrÅ¡en.

### **5. PronalaÅ¾enje BROP gedÅ¾eta**

Ova tehnika koristi [**ret2csu**](ret2csu.md) gedÅ¾et. To je zato Å¡to ako pristupite ovom gedÅ¾etu usred nekih instrukcija, dobijate gedÅ¾ete za kontrolu **`rsi`** i **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Ovo bi bili gedÅ¾eti:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Primetite kako je sa tim gedÅ¾etima moguÄ‡e **kontrolisati 2 argumenta** funkcije koja se poziva.

TakoÄ‘e, primetite da ret2csu gedÅ¾et ima **vrlo jedinstveni potpis** jer Ä‡e skidati 6 registara sa steka. Dakle, slanjem lanca kao:

`'A' * ofset + kanaric + rbp + ADRESA + 0xdead * 6 + STOP`

Ako se **STOP izvrÅ¡i**, to u osnovi znaÄi da je koriÅ¡Ä‡ena **adresa koja skida 6 registara** sa steka. Ili da je koriÅ¡Ä‡ena adresa takoÄ‘e STOP adresa.

Kako bi se **uklonila ova poslednja opcija**, izvrÅ¡ava se novi lanac kao sledeÄ‡i i ne sme izvrÅ¡iti STOP gedÅ¾et da bi se potvrdilo da je prethodni zaista skidao 6 registara:

`'A' * ofset + kanaric + rbp + ADRESA`

ZnajuÄ‡i adresu ret2csu gedÅ¾eta, moguÄ‡e je **zakljuÄiti adresu gedÅ¾eta za kontrolu `rsi` i `rdi`**.

### 6. PronalaÅ¾enje PLT-a

PLT tabela moÅ¾e biti pretraÅ¾ena od 0x400000 ili od **procurele RIP adrese** sa steka (ako se koristi **PIE**). **Unosi** tabele su **razdvojeni sa 16B** (0x10B), i kada se pozove jedna funkcija, server ne pada Äak i ako argumenti nisu ispravni. TakoÄ‘e, provera adrese unosa u **PLT + 6B takoÄ‘e ne pada** jer je to prvi izvrÅ¡eni kod.

Stoga, moguÄ‡e je pronaÄ‡i PLT tabelu proveravajuÄ‡i sledeÄ‡e ponaÅ¡anje:

* `'A' * ofset + kanaric + rbp + ADRESA + STOP` -> nema pada
* `'A' * ofset + kanaric + rbp + (ADRESA + 0x6) + STOP` -> nema pada
* `'A' * ofset + kanaric + rbp + (ADRESA + 0x10) + STOP` -> nema pada

### 7. PronalaÅ¾enje strcmp funkcije

Funkcija **`strcmp`** postavlja registar **`rdx`** na duÅ¾inu uporeÄ‘enog stringa. Imajte na umu da je **`rdx`** treÄ‡i argument i potrebno je da bude **veÄ‡i od 0** kako bi kasnije mogli koristiti `write` da procuremo program.

MoguÄ‡e je pronaÄ‡i lokaciju **`strcmp`** u PLT-u na osnovu njegovog ponaÅ¡anja koristeÄ‡i Äinjenicu da sada moÅ¾emo kontrolisati prva 2 argumenta funkcija:

* strcmp(\<neÄitljiva adresa>, \<neÄitljiva adresa>) -> pad
* strcmp(\<neÄitljiva adresa>, \<Äitljiva adresa>) -> pad
* strcmp(\<Äitljiva adresa>, \<neÄitljiva adresa>) -> pad
* strcmp(\<Äitljiva adresa>, \<Äitljiva adresa>) -> nema pada

MoguÄ‡e je proveriti ovo pozivanjem svakog unosa u PLT tabeli ili koriÅ¡Ä‡enjem **PLT spore putanje** koja se u osnovi sastoji od **pozivanja unosa u PLT tabeli + 0xb** (koji poziva **`dlresolve`**) praÄ‡enog na steku **brojem unosa koji Å¾elimo ispitati** (poÄevÅ¡i od nule) da bi se skenirali svi unosi PLT tabele od prvog:

* strcmp(\<neÄitljiva adresa>, \<Äitljiva adresa>) -> pad
* `b'A' * ofset + kanaric + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(UNOS) + STOP` -> Pada
* strcmp(\<Äitljiva adresa>, \<neÄitljiva adresa>) -> pad
* `b'A' * ofset + kanaric + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(UNOS) + STOP`&#x20;
* strcmp(\<Äitljiva adresa>, \<Äitljiva adresa>) -> nema pada
* `b'A' * ofset + kanaric + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(UNOS) + STOP`&#x20;

Zapamtite da:

* BROP + 0x7 pokazuje na **`pop RSI; pop R15; ret;`**
* BROP + 0x9 pokazuje na **`pop RDI; ret;`**
* PLT + 0xb pokazuje na poziv **dl\_resolve**.

Nakon Å¡to je pronaÄ‘en `strcmp`, moguÄ‡e je postaviti **`rdx`** na vrednost veÄ‡u od 0.

{% hint style="success" %}
Imajte na umu da Ä‡e obiÄno `rdx` veÄ‡ imati vrednost veÄ‡u od 0, tako da ovaj korak moÅ¾da nije potreban.
{% endhint %}
### 8. PronalaÅ¾enje Write ili ekvivalenta

KonaÄno, potreban je ureÄ‘aj koji eksfiltrira podatke kako bi se eksfiltrirao binarni fajl. U ovom trenutku je moguÄ‡e **kontrolisati 2 argumenta i postaviti `rdx` veÄ‡i od 0**.

Postoje 3 uobiÄajene funkcije koje bi mogle biti zloupotrebljene za ovo:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

MeÄ‘utim, originalni rad pominje samo **`write`**, pa Ä‡emo o tome govoriti:

Trenutni problem je Å¡to ne znamo **gde se nalazi funkcija write unutar PLT-a** i ne znamo **broj fd-a na koji treba poslati podatke preko naÅ¡eg soketa**.

MeÄ‘utim, znamo **gde se nalazi PLT tabela** i moguÄ‡e je pronaÄ‡i write na osnovu njegovog **ponaÅ¡anja**. I moÅ¾emo kreirati **viÅ¡e veza** sa serverom i koristiti **visok FD** u nadi da se poklapa sa nekom od naÅ¡ih veza.

Potpisi ponaÅ¡anja za pronalaÅ¾enje ovih funkcija:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ako se podaci ispiÅ¡u, onda je pronaÄ‘en puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ako se podaci ispiÅ¡u, onda je pronaÄ‘en dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ako se podaci ispiÅ¡u, onda je pronaÄ‘en write

## Automatizovana eksploatacija

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Reference

* Originalni rad: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
