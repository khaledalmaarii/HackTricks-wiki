# BROP - Blind Return Oriented Programming

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje

Celem tego ataku jest **wykorzystanie ROP poprzez przepeÅ‚nienie bufora bez Å¼adnych informacji o podatnym binarnym pliku**.\
Ten atak opiera siÄ™ na nastÄ™pujÄ…cym scenariuszu:

* PodatnoÅ›Ä‡ stosu i znajomoÅ›Ä‡ sposobu jej wywoÅ‚ania.
* Aplikacja serwerowa, ktÃ³ra restartuje siÄ™ po awarii.

## Atak

### **1. ZnajdÅº podatny offset** wysyÅ‚ajÄ…c jeden dodatkowy znak, aÅ¼ zostanie wykryta awaria serwera

### **2. Bruteforce canary** aby wyciekÅ‚o go&#x20;

### **3. Bruteforce przechowywane adresy RBP i RIP** na stosie, aby je wyciec

WiÄ™cej informacji na temat tych procesÃ³w moÅ¼na znaleÅºÄ‡ [tutaj (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) oraz [tutaj (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. ZnajdÅº gadÅ¼et stop**

Ten gadÅ¼et pozwala potwierdziÄ‡, Å¼e coÅ› interesujÄ…cego zostaÅ‚o wykonane przez gadÅ¼et ROP, poniewaÅ¼ wykonanie nie spowodowaÅ‚o awarii. Zazwyczaj bÄ™dzie to coÅ›, co **zatrzymuje wykonanie** i znajduje siÄ™ na koÅ„cu Å‚aÅ„cucha ROP podczas poszukiwania gadÅ¼etÃ³w ROP do potwierdzenia, Å¼e okreÅ›lony gadÅ¼et ROP zostaÅ‚ wykonany.

### **5. ZnajdÅº gadÅ¼et BROP**

Ta technika wykorzystuje gadÅ¼et [**ret2csu**](ret2csu.md). Jest to dlatego, Å¼e jeÅ›li uzyskasz dostÄ™p do tego gadÅ¼etu w Å›rodku pewnych instrukcji, otrzymasz gadÅ¼ety do kontrolowania **`rsi`** i **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

SÄ… to gadÅ¼ety:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

ZauwaÅ¼, Å¼e dziÄ™ki tym gadÅ¼etom moÅ¼na **kontrolowaÄ‡ 2 argumenty** funkcji do wywoÅ‚ania.

ZauwaÅ¼ rÃ³wnieÅ¼, Å¼e gadÅ¼et ret2csu ma **bardzo unikalny podpis**, poniewaÅ¼ bÄ™dzie zdejmowaÅ‚ 6 rejestrÃ³w ze stosu. WysyÅ‚ajÄ…c Å‚aÅ„cuch jak:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

JeÅ›li **STOP jest wykonany**, oznacza to, Å¼e zostaÅ‚ uÅ¼yty adres, ktÃ³ry zdejmowaÅ‚ 6 rejestrÃ³w ze stosu. Lub Å¼e uÅ¼yty adres byÅ‚ rÃ³wnieÅ¼ adresem STOP.

Aby **usunÄ…Ä‡ tÄ™ ostatniÄ… opcjÄ™**, wykonuje siÄ™ nowy Å‚aÅ„cuch jak poniÅ¼ej i nie powinien on wykonaÄ‡ gadÅ¼etu STOP, aby potwierdziÄ‡, Å¼e poprzedni zdejmowaÅ‚ 6 rejestrÃ³w:

`'A' * offset + canary + rbp + ADDR`

ZnajÄ…c adres gadÅ¼etu ret2csu, moÅ¼na **wywnioskowaÄ‡ adresy gadÅ¼etÃ³w do kontrolowania `rsi` i `rdi`**.

### 6. ZnajdÅº PLT

TabelÄ™ PLT moÅ¼na przeszukiwaÄ‡ od 0x400000 lub od **wyciekanego adresu RIP** ze stosu (jeÅ›li jest uÅ¼ywany **PIE**). **Wpisy** w tabeli sÄ… **oddzielone o 16B** (0x10B), a gdy wywoÅ‚ywana jest jedna funkcja, serwer nie ulega awarii nawet jeÅ›li argumenty nie sÄ… poprawne. Sprawdzenie adresu wpisu w **PLT + 6B rÃ³wnieÅ¼ nie powoduje awarii**, poniewaÅ¼ jest to pierwszy kod wykonany.

Dlatego moÅ¼liwe jest znalezienie tabeli PLT, sprawdzajÄ…c nastÄ™pujÄ…ce zachowania:

* `'A' * offset + canary + rbp + ADDR + STOP` -> brak awarii
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> brak awarii
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> brak awarii

### 7. ZnajdÅº strcmp

Funkcja **`strcmp`** ustawia rejestr **`rdx`** na dÅ‚ugoÅ›Ä‡ porÃ³wnywanego Å‚aÅ„cucha. ZauwaÅ¼, Å¼e **`rdx`** jest **trzecim argumentem** i musi byÄ‡ **wiÄ™kszy niÅ¼ 0**, aby pÃ³Åºniej moÅ¼na byÅ‚o uÅ¼yÄ‡ `write` do wycieku programu.

MoÅ¼liwe jest znalezienie lokalizacji **`strcmp`** w PLT na podstawie jego zachowania, wykorzystujÄ…c fakt, Å¼e teraz moÅ¼emy kontrolowaÄ‡ 2 pierwsze argumenty funkcji:

* strcmp(\<nieodczytywalny adres>, \<nieodczytywalny adres>) -> awaria
* strcmp(\<nieodczytywalny adres>, \<odczytywalny adres>) -> awaria
* strcmp(\<odczytywalny adres>, \<nieodczytywalny adres>) -> awaria
* strcmp(\<odczytywalny adres>, \<odczytywalny adres>) -> brak awarii

MoÅ¼na to sprawdziÄ‡, wywoÅ‚ujÄ…c kaÅ¼dy wpis w tabeli PLT lub korzystajÄ…c z **wolnej Å›cieÅ¼ki PLT**, ktÃ³ra polega w zasadzie na **wywoÅ‚aniu wpisu w tabeli PLT + 0xb** (ktÃ³re wywoÅ‚uje **`dlresolve`**) a nastÄ™pnie na stosie **numer wpisu, ktÃ³ry chcemy sprawdziÄ‡** (zaczynajÄ…c od zera), aby przeskanowaÄ‡ wszystkie wpisy PLT od pierwszego:

* strcmp(\<nieodczytywalny adres>, \<odczytywalny adres>) -> awaria
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Spowoduje awariÄ™
* strcmp(\<odczytywalny adres>, \<nieodczytywalny adres>) -> awaria
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;
* strcmp(\<odczytywalny adres>, \<odczytywalny adres>) -> brak awarii
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;

PamiÄ™taj, Å¼e:

* BROP + 0x7 wskazuje na **`pop RSI; pop R15; ret;`**
* BROP + 0x9 wskazuje na **`pop RDI; ret;`**
* PLT + 0xb wskazuje na wywoÅ‚anie **dl\_resolve**.

Znalezienie `strcmp` umoÅ¼liwia ustawienie **`rdx`** na wartoÅ›Ä‡ wiÄ™kszÄ… niÅ¼ 0.

{% hint style="success" %}
Zazwyczaj `rdx` bÄ™dzie juÅ¼ zawieraÅ‚ wartoÅ›Ä‡ wiÄ™kszÄ… niÅ¼ 0, wiÄ™c ten krok moÅ¼e nie byÄ‡ konieczny.
{% endhint %}
### 8. Znajdowanie funkcji Write lub jej odpowiednika

W koÅ„cu potrzebny jest gadÅ¼et, ktÃ³ry eksfiltruje dane w celu wyeksportowania binarnego pliku. W tym momencie moÅ¼liwe jest **kontrolowanie 2 argumentÃ³w i ustawienie `rdx` wiÄ™kszego niÅ¼ 0**.

IstniejÄ… 3 wspÃ³lne funkcje, ktÃ³re mogÄ… byÄ‡ wykorzystane do tego celu:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

JednakÅ¼e, oryginalny dokument wspomina tylko o funkcji **`write`**, wiÄ™c skupmy siÄ™ na niej:

Aktualny problem polega na tym, Å¼e nie znamy **poÅ‚oÅ¼enia funkcji write w PLT** i nie znamy **numeru fd, aby wysÅ‚aÄ‡ dane do naszego gniazda**.

Mimo to, znamy **poÅ‚oÅ¼enie tabeli PLT** i moÅ¼liwe jest znalezienie funkcji write na podstawie jej **zachowania**. MoÅ¼emy utworzyÄ‡ **kilka poÅ‚Ä…czeÅ„** z serwerem i uÅ¼yÄ‡ **wysokiego FD**, majÄ…c nadziejÄ™, Å¼e pasuje do jednego z naszych poÅ‚Ä…czeÅ„.

Sygnatury zachowania do znalezienia tych funkcji:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> JeÅ›li dane sÄ… drukowane, to znaleziono funkcjÄ™ puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> JeÅ›li dane sÄ… drukowane, to znaleziono funkcjÄ™ dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> JeÅ›li dane sÄ… drukowane, to znaleziono funkcjÄ™ write

## Automatyzacja Eksploatacji

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referencje

* Oryginalny dokument: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
