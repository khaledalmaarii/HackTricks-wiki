# Desbordamiento de pila

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipo Rojo de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## ¬øQu√© es un desbordamiento de pila?

Un **desbordamiento de pila** es una vulnerabilidad que ocurre cuando un programa escribe m√°s datos en la pila de los que se le asignan para contener. Estos datos adicionales **sobrescribir√°n el espacio de memoria adyacente**, lo que provocar√° la corrupci√≥n de datos v√°lidos, la interrupci√≥n del flujo de control y potencialmente la ejecuci√≥n de c√≥digo malicioso. Este problema suele surgir debido al uso de funciones inseguras que no realizan comprobaciones de l√≠mites en la entrada.

El principal problema de esta sobrescritura es que el **puntero de instrucci√≥n guardado (EIP/RIP)** y el **puntero de base guardado (EBP/RBP)** para volver a la funci√≥n anterior se **almacenan en la pila**. Por lo tanto, un atacante podr√° sobrescribir esos valores y **controlar el flujo de ejecuci√≥n del programa**.

La vulnerabilidad suele surgir porque una funci√≥n **copia dentro de la pila m√°s bytes de los asignados para ella**, pudiendo sobrescribir otras partes de la pila.

Algunas funciones comunes vulnerables a esto son: **`strcpy`, `strcat`, `sprintf`, `gets`**... Adem√°s, funciones como **`fgets`**, **`read` & `memcpy`** que toman un **argumento de longitud**, podr√≠an utilizarse de manera vulnerable si la longitud especificada es mayor que la asignada.

Por ejemplo, las siguientes funciones podr√≠an ser vulnerables:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Encontrar desplazamientos de desbordamiento de pila

La forma m√°s com√∫n de encontrar desbordamientos de pila es proporcionar una entrada muy grande de `A`s (por ejemplo, `python3 -c 'print("A"*1000)'`) y esperar un `Segmentation Fault` que indique que se intent√≥ acceder a la **direcci√≥n `0x41414141`**.

Adem√°s, una vez que se haya encontrado que hay una vulnerabilidad de desbordamiento de pila, ser√° necesario encontrar el desplazamiento hasta que sea posible **sobrescribir la direcci√≥n de retorno**, para esto generalmente se utiliza una **secuencia de De Bruijn**. Que para un alfabeto dado de tama√±o _k_ y subsecuencias de longitud _n_ es una **secuencia c√≠clica en la que cada subsecuencia posible de longitud _n_** aparece exactamente una vez como una subsecuencia contigua.

De esta manera, en lugar de tener que averiguar manualmente qu√© desplazamiento se necesita para controlar el EIP, es posible usar una de estas secuencias como relleno y luego encontrar el desplazamiento de los bytes que terminaron sobrescribi√©ndola.

Es posible utilizar **pwntools** para esto:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
o **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Explotando Desbordamientos de Pila

Durante un desbordamiento (suponiendo que el tama√±o del desbordamiento es lo suficientemente grande) podr√°s **sobrescribir** valores de variables locales dentro de la pila hasta alcanzar el **EBP/RBP y EIP/RIP guardados (o incluso m√°s)**.\
La forma m√°s com√∫n de abusar de este tipo de vulnerabilidad es **modificando la direcci√≥n de retorno** para que cuando la funci√≥n termine, el **flujo de control sea redirigido a donde el usuario lo especifique** en este puntero.

Sin embargo, en otros escenarios tal vez solo **sobrescribir algunos valores de variables en la pila** sea suficiente para la explotaci√≥n (como en desaf√≠os CTF f√°ciles).

### Ret2win

En este tipo de desaf√≠os CTF, hay una **funci√≥n** **dentro** del binario que **nunca es llamada** y que **necesitas llamar para ganar**. Para estos desaf√≠os solo necesitas encontrar el **offset para sobrescribir la direcci√≥n de retorno** y **encontrar la direcci√≥n de la funci√≥n** a llamar (generalmente [**ASLR**](../common-binary-protections-and-bypasses/aslr/) estar√≠a deshabilitado) para que cuando la funci√≥n vulnerable retorne, se llame a la funci√≥n oculta:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Shellcode en la Pila

En este escenario, el atacante podr√≠a colocar un shellcode en la pila y abusar del EIP/RIP controlado para saltar al shellcode y ejecutar c√≥digo arbitrario:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### T√©cnicas ROP y Ret2...

Esta t√©cnica es el marco fundamental para evadir la protecci√≥n principal de la t√©cnica anterior: **No ejecuci√≥n en la pila (NX)**. Y permite realizar varias otras t√©cnicas (ret2lib, ret2syscall...) que terminar√°n ejecutando comandos arbitrarios abusando de las instrucciones existentes en el binario:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Desbordamientos de Mont√≥n

Un desbordamiento no siempre ocurrir√° en la pila, tambi√©n podr√≠a ocurrir en el **mont√≥n**, por ejemplo:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Tipos de protecciones

Existen varias protecciones que intentan prevenir la explotaci√≥n de vulnerabilidades, cons√∫ltalas en:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
