# Stack Overflow

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Co to jest Stack Overflow

**Stack overflow** to luka, kt贸ra wystpuje, gdy program zapisuje wicej danych na stosie, ni偶 jest przydzielone do przechowywania. Te nadmiarowe dane **nadpisz ssiedni przestrze pamici**, prowadzc do uszkodzenia wa偶nych danych, zak贸cenia przepywu sterowania i potencjalnie do wykonania zoliwego kodu. Problem ten czsto pojawia si z powodu u偶ycia niebezpiecznych funkcji, kt贸re nie wykonuj sprawdzania granic na wejciu.

G贸wnym problemem tego nadpisania jest to, 偶e **zapisany wska藕nik instrukcji (EIP/RIP)** oraz **zapisany wska藕nik bazowy (EBP/RBP)** do powrotu do poprzedniej funkcji s **przechowywane na stosie**. Dlatego atakujcy bdzie w stanie nadpisa je i **kontrolowa przepyw wykonania programu**.

Luka ta zazwyczaj pojawia si, poniewa偶 funkcja **kopiuje na stos wicej bajt贸w ni偶 ilo przydzielona dla niej**, co pozwala na nadpisanie innych czci stosu.

Niekt贸re powszechne funkcje podatne na to to: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ponadto funkcje takie jak **`fgets`**, **`read` & `memcpy`**, kt贸re przyjmuj **argument dugoci**, mog by u偶ywane w spos贸b podatny, jeli okrelona dugo jest wiksza ni偶 przydzielona.

Na przykad, nastpujce funkcje mog by podatne:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Znajdowanie offset贸w przepenienia stosu

Najczstszym sposobem na znalezienie przepenie stosu jest podanie bardzo du偶ego wejcia z `A`s (np. `python3 -c 'print("A"*1000)'`) i oczekiwanie na `Segmentation Fault`, co wskazuje, 偶e **adres `0x41414141` pr贸bowa by dostpny**.

Ponadto, gdy ju偶 znajdziesz, 偶e istnieje luka w przepenieniu stosu, bdziesz musia znale藕 offset, a偶 bdzie mo偶liwe **nadpisanie adresu powrotu**, do tego zazwyczaj u偶ywa si **sekwencji De Bruijn.** Kt贸ra dla danego alfabetu o rozmiarze _k_ i podsekwencjach o dugoci _n_ jest **cykliczn sekwencj, w kt贸rej ka偶da mo偶liwa podsekwencja o dugoci \_n**\_\*\* wystpuje dokadnie raz\*\* jako kontiguujca podsekwencja.

W ten spos贸b, zamiast rcznie ustala, jaki offset jest potrzebny do kontrolowania EIP, mo偶na u偶y jako wypenienia jednej z tych sekwencji, a nastpnie znale藕 offset bajt贸w, kt贸re zakoczyy nadpisanie.

Mo偶na u偶y **pwntools** do tego:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
lub **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Wykorzystywanie przepenie stosu

Podczas przepenienia (zakadajc, 偶e rozmiar przepenienia jest wystarczajco du偶y) bdziesz w stanie **nadpisa** wartoci lokalnych zmiennych w stosie, a偶 do osignicia zapisanych **EBP/RBP i EIP/RIP (lub nawet wicej)**.\
Najczstszym sposobem nadu偶ywania tego typu podatnoci jest **modyfikacja adresu powrotu**, aby po zakoczeniu funkcji **przepyw kontroli zosta przekierowany tam, gdzie u偶ytkownik wskaza** w tym wska藕niku.

Jednak w innych scenariuszach mo偶e wystarczy po prostu **nadpisanie niekt贸rych wartoci zmiennych w stosie** do wykorzystania (jak w atwych wyzwaniach CTF).

### Ret2win

W tego typu wyzwaniach CTF, istnieje **funkcja** **wewntrz** binarnego pliku, kt贸ra **nigdy nie jest wywoywana** i kt贸r **musisz wywoa, aby wygra**. W tych wyzwaniach musisz tylko znale藕 **offset do nadpisania adresu powrotu** i **znale藕 adres funkcji**, kt贸r chcesz wywoa (zwykle [**ASLR**](../common-binary-protections-and-bypasses/aslr/) bdzie wyczony), aby po powrocie z funkcji podatnej, ukryta funkcja zostaa wywoana:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Shellcode na stosie

W tym scenariuszu atakujcy m贸gby umieci shellcode w stosie i nadu偶y kontrolowanego EIP/RIP, aby skoczy do shellcode i wykona dowolny kod:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### Techniki ROP i Ret2...

Ta technika jest podstawowym frameworkiem do obejcia g贸wnej ochrony poprzedniej techniki: **Brak wykonywalnego stosu (NX)**. Umo偶liwia to wykonanie kilku innych technik (ret2lib, ret2syscall...), kt贸re zakocz si wykonaniem dowolnych polece poprzez nadu偶ycie istniejcych instrukcji w binarnym pliku:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Przepenienia sterty

Przepenienie nie zawsze bdzie miao miejsce w stosie, mo偶e r贸wnie偶 wystpi w **stercie**, na przykad:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Rodzaje ochrony

Istnieje kilka zabezpiecze pr贸bujcych zapobiec wykorzystaniu podatnoci, sprawd藕 je w:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si trikami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}
