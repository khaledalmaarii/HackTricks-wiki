# Niezainicjowane zmienne

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakowania, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Podstawowym pomysem tutaj jest zrozumienie, co dzieje si z **niezainicjowanymi zmiennymi, poniewa偶 bd one miay warto, kt贸ra bya ju偶 przypisana do pamici.** Przykad:

* **Funkcja 1: `initializeVariable`**: Deklarujemy zmienn `x` i przypisujemy jej warto, powiedzmy `0x1234`. Ta czynno jest podobna do zarezerwowania miejsca w pamici i umieszczenia w nim okrelonej wartoci.
* **Funkcja 2: `useUninitializedVariable`**: Tutaj deklarujemy inn zmienn `y`, ale nie przypisujemy jej 偶adnej wartoci. W jzyku C niezainicjowane zmienne nie s automatycznie ustawiane na zero. Zamiast tego zachowuj warto, kt贸ra bya ostatnio przechowywana pod ich adresem pamici.

Gdy uruchamiamy te dwie funkcje **sekwencyjnie**:

1. W `initializeVariable`, `x` otrzymuje warto (`0x1234`), kt贸ra zajmuje okrelony adres pamici.
2. W `useUninitializedVariable`, `y` jest deklarowane, ale nie otrzymuje wartoci, wic zajmuje miejsce w pamici bezporednio po `x`. Ze wzgldu na brak inicjalizacji `y`, koczy si "dziedziczeniem" wartoci z tego samego miejsca w pamici u偶ywanego przez `x`, poniewa偶 jest to ostatnia warto, kt贸ra tam bya.

To zachowanie ilustruje kluczowe pojcie w programowaniu niskopoziomowym: **Zarzdzanie pamici jest kluczowe**, a niezainicjowane zmienne mog prowadzi do nieprzewidywalnego zachowania lub podatnoci na zagro偶enia bezpieczestwa, poniewa偶 mog nieumylnie przechowywa wra偶liwe dane pozostawione w pamici.

Niezainicjowane zmienne stosu mog stwarza kilka zagro偶e dla bezpieczestwa, takich jak:

* **Ujawnienie danych**: Wra偶liwe informacje, takie jak hasa, klucze szyfrowania lub dane osobowe, mog by ujawnione, jeli przechowywane s w niezainicjowanych zmiennych, umo偶liwiajc potencjalnie atakujcym odczytanie tych danych.
* **Ujawnienie informacji**: Zawarto niezainicjowanych zmiennych mo偶e ujawni szczeg贸y dotyczce ukadu pamici programu lub operacji wewntrznych, pomagajc atakujcym w opracowywaniu ukierunkowanych exploit贸w.
* **Awarie i niestabilno**: Operacje zwizane z niezainicjowanymi zmiennymi mog prowadzi do niezdefiniowanego zachowania, co mo偶e skutkowa awariami programu lub nieprzewidywalnymi wynikami.
* **Wykonywanie arbitralnego kodu**: W okrelonych scenariuszach atakujcy mog wykorzysta te podatnoci, aby zmieni przebieg wykonania programu, umo偶liwiajc im wykonanie arbitralnego kodu, kt贸ry mo偶e obejmowa zagro偶enia zwizane z wykonaniem kodu zdalnego. 

### Przykad
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Jak to dziaa:

* **Funkcja `initializeAndPrint`**: Ta funkcja deklaruje zmienn cakowit `initializedVar`, przypisuje jej warto `100`, a nastpnie drukuje zar贸wno adres pamici, jak i warto zmiennej. Ten krok jest prosty i pokazuje, jak zachowuje si zmienna zainicjowana.
* **Funkcja `demonstrateUninitializedVar`**: W tej funkcji deklarujemy zmienn cakowit `uninitializedVar` bez inicjalizacji. Gdy pr贸bujemy wydrukowa jej warto, wynik mo偶e pokaza losow liczb. Ta liczba reprezentuje dane, kt贸re wczeniej znajdoway si pod tym adresem pamici. W zale偶noci od rodowiska i kompilatora, rzeczywisty wynik mo偶e si r贸偶ni, a czasami, dla bezpieczestwa, niekt贸re kompilatory mog automatycznie inicjowa zmienne na zero, chocia偶 nie nale偶y polega na tym.
* **Funkcja `main`**: Funkcja `main` wywouje obie powy偶sze funkcje sekwencyjnie, demonstrujc r贸偶nic midzy zmienn zainicjowan i niezainicjowan.

## Przykad ARM64

To nie zmienia si w ARM64, poniewa偶 zmienne lokalne s r贸wnie偶 zarzdzane na stosie, mo偶esz [**sprawdzi ten przykad**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/), gdzie to jest pokazane.
