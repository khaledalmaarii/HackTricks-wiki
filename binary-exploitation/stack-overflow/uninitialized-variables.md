# BaÅŸlatÄ±lmamÄ±ÅŸ DeÄŸiÅŸkenler

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile AWS hacklemeyi sÄ±fÄ±rdan ileri seviyeye Ã¶ÄŸrenin!</summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **ğŸ’¬ [**Discord grubumuza**](https://discord.gg/hRep4RUj7f) katÄ±lÄ±n veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da takip edin.
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'lar gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## Temel Bilgiler

Buradaki temel fikir, **baÅŸlatÄ±lmamÄ±ÅŸ deÄŸiÅŸkenlerin belleÄŸe atanan deÄŸeri alacaklarÄ±nÄ± anlamaktÄ±r.** Ã–rnek:

* **Fonksiyon 1: `initializeVariable`**: Bir deÄŸiÅŸken `x` bildiriyoruz ve ona bir deÄŸer atÄ±yoruz, diyelim ki `0x1234`. Bu eylem, bellekte bir yer ayÄ±rmak ve belirli bir deÄŸeri koymak gibidir.
* **Fonksiyon 2: `useUninitializedVariable`**: Burada, baÅŸka bir deÄŸiÅŸken `y` bildiriyoruz ancak ona herhangi bir deÄŸer atamÄ±yoruz. C'de baÅŸlatÄ±lmamÄ±ÅŸ deÄŸiÅŸkenler otomatik olarak sÄ±fÄ±ra ayarlanmaz. Bunun yerine, bellek konumlarÄ±ndaki son depolanan deÄŸeri korurlar.

Bu iki fonksiyonu **ardÄ±ÅŸÄ±k olarak** Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda:

1. `initializeVariable` iÃ§inde, `x` bir deÄŸer atandÄ± (`0x1234`), bu belirli bir bellek adresini iÅŸgal eder.
2. `useUninitializedVariable` iÃ§inde, `y` bildirilir ancak bir deÄŸer atamasÄ± yapÄ±lmaz, bu nedenle `x`'in hemen ardÄ±ndan bellek yeri alÄ±r. `y`'yi baÅŸlatmadÄ±ÄŸÄ±mÄ±zdan, `x` tarafÄ±ndan kullanÄ±lan aynÄ± bellek konumundan deÄŸeri "miras" alÄ±r, Ã§Ã¼nkÃ¼ orada en son olan deÄŸer odur.

Bu davranÄ±ÅŸ, dÃ¼ÅŸÃ¼k seviyeli programlamada Ã¶nemli bir kavramÄ± gÃ¶sterir: **Bellek yÃ¶netimi Ã¶nemlidir** ve baÅŸlatÄ±lmamÄ±ÅŸ deÄŸiÅŸkenler, hassas verileri yanlÄ±ÅŸlÄ±kla bellekte bÄ±rakabileceÄŸinden, Ã¶ngÃ¶rÃ¼lemeyen davranÄ±ÅŸlara veya gÃ¼venlik aÃ§Ä±klarÄ±na yol aÃ§abilir.

BaÅŸlatÄ±lmamÄ±ÅŸ yÄ±ÄŸÄ±n deÄŸiÅŸkenleri Ã§eÅŸitli gÃ¼venlik riskleri oluÅŸturabilir:

* **Veri SÄ±zÄ±ntÄ±sÄ±**: Hassas bilgiler, ÅŸifreler, ÅŸifreleme anahtarlarÄ± veya kiÅŸisel detaylar gibi, baÅŸlatÄ±lmamÄ±ÅŸ deÄŸiÅŸkenlerde saklanÄ±yorsa, saldÄ±rganlarÄ±n bu verileri potansiyel olarak okumasÄ±na izin vererek aÃ§Ä±ÄŸa Ã§Ä±kabilir.
* **Bilgi AÃ§Ä±klamasÄ±**: BaÅŸlatÄ±lmamÄ±ÅŸ deÄŸiÅŸkenlerin iÃ§eriÄŸi, programÄ±n bellek dÃ¼zeni veya iÃ§ iÅŸleyiÅŸi hakkÄ±nda detaylarÄ± ortaya Ã§Ä±karabilir, bu da saldÄ±rganlarÄ±n hedefe yÃ¶nelik saldÄ±rÄ±lar geliÅŸtirmelerine yardÄ±mcÄ± olabilir.
* **Ã‡Ã¶kmeler ve KararsÄ±zlÄ±k**: BaÅŸlatÄ±lmamÄ±ÅŸ deÄŸiÅŸkenleri iÃ§eren iÅŸlemler tanÄ±msÄ±z davranÄ±ÅŸlara neden olabilir, program Ã§Ã¶kmelerine veya Ã¶ngÃ¶rÃ¼lemeyen sonuÃ§lara yol aÃ§abilir.
* **Keyfi Kod YÃ¼rÃ¼tme**: Belirli senaryolarda, saldÄ±rganlar bu aÃ§Ä±klarÄ± kullanarak programÄ±n yÃ¼rÃ¼tme akÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirebilir ve onlara keyfi kod yÃ¼rÃ¼tme, uzaktan kod yÃ¼rÃ¼tme tehditlerini iÃ§erebilecek ÅŸekilde programÄ± deÄŸiÅŸtirme imkanÄ± verebilir.

### Ã–rnek
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### NasÄ±l Ã‡alÄ±ÅŸÄ±r:

* **`initializeAndPrint` Fonksiyonu**: Bu fonksiyon bir tamsayÄ± deÄŸiÅŸkeni olan `initializedVar`'Ä± bildirir, deÄŸer olarak `100` atar ve ardÄ±ndan deÄŸiÅŸkenin bellek adresini ve deÄŸerini yazdÄ±rÄ±r. Bu adÄ±m aÃ§Ä±ktÄ±r ve baÅŸlatÄ±lmÄ±ÅŸ bir deÄŸiÅŸkenin nasÄ±l davrandÄ±ÄŸÄ±nÄ± gÃ¶sterir.
* **`demonstrateUninitializedVar` Fonksiyonu**: Bu fonksiyonda, baÅŸlatÄ±lmamÄ±ÅŸ bir tamsayÄ± deÄŸiÅŸkeni olan `uninitializedVar`'Ä± bildiriyoruz. DeÄŸiÅŸkenin deÄŸerini yazdÄ±rmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zda, Ã§Ä±ktÄ± rastgele bir sayÄ± gÃ¶sterebilir. Bu sayÄ±, Ã¶nceki bellek konumunda bulunan veriyi temsil eder. Ortama ve derleyiciye baÄŸlÄ± olarak, gerÃ§ek Ã§Ä±ktÄ± deÄŸiÅŸebilir ve bazen gÃ¼venlik iÃ§in bazÄ± derleyiciler deÄŸiÅŸkenleri otomatik olarak sÄ±fÄ±rlayabilir, ancak buna gÃ¼venilmemelidir.
* **`main` Fonksiyonu**: `main` fonksiyonu yukarÄ±daki iki fonksiyonu sÄ±rayla Ã§aÄŸÄ±rarak baÅŸlatÄ±lmÄ±ÅŸ bir deÄŸiÅŸken ile baÅŸlatÄ±lmamÄ±ÅŸ bir deÄŸiÅŸken arasÄ±ndaki farkÄ± gÃ¶sterir.

## ARM64 Ã–rneÄŸi

Bu, ARM64'te hiÃ§ deÄŸiÅŸmez Ã§Ã¼nkÃ¼ yerel deÄŸiÅŸkenler de yÄ±ÄŸÄ±nda yÃ¶netilir, [**bu Ã¶rneÄŸi kontrol edebilirsiniz**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) burada bu gÃ¶sterilmiÅŸtir.
