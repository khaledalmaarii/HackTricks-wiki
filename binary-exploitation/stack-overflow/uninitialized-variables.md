# Vari√°veis n√£o Inicializadas

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

A ideia central aqui √© entender o que acontece com **vari√°veis n√£o inicializadas, pois elas ter√£o o valor que j√° estava na mem√≥ria atribu√≠da a elas.** Exemplo:

* **Fun√ß√£o 1: `initializeVariable`**: Declaramos uma vari√°vel `x` e atribu√≠mos a ela um valor, digamos `0x1234`. Essa a√ß√£o √© semelhante a reservar um local na mem√≥ria e colocar um valor espec√≠fico nele.
* **Fun√ß√£o 2: `useUninitializedVariable`**: Aqui, declaramos outra vari√°vel `y`, mas n√£o atribu√≠mos nenhum valor a ela. Em C, vari√°veis n√£o inicializadas n√£o s√£o automaticamente definidas como zero. Em vez disso, elas mant√™m o valor que foi armazenado por √∫ltimo em sua localiza√ß√£o de mem√≥ria.

Quando executamos essas duas fun√ß√µes **sequencialmente**:

1. Em `initializeVariable`, `x` √© atribu√≠do um valor (`0x1234`), que ocupa um endere√ßo de mem√≥ria espec√≠fico.
2. Em `useUninitializedVariable`, `y` √© declarado, mas n√£o √© atribu√≠do um valor, ent√£o ele ocupa o local de mem√≥ria logo ap√≥s `x`. Devido √† n√£o inicializa√ß√£o de `y`, ele acaba "herdando" o valor da mesma localiza√ß√£o de mem√≥ria usada por `x`, porque esse foi o √∫ltimo valor que estava l√°.

Esse comportamento ilustra um conceito-chave na programa√ß√£o de baixo n√≠vel: **A gest√£o de mem√≥ria √© crucial**, e vari√°veis n√£o inicializadas podem levar a comportamentos imprevis√≠veis ou vulnerabilidades de seguran√ßa, pois podem inadvertidamente conter dados sens√≠veis deixados na mem√≥ria.

Vari√°veis de pilha n√£o inicializadas podem representar v√°rios riscos de seguran√ßa, como:

* **Vazamento de Dados**: Informa√ß√µes sens√≠veis, como senhas, chaves de criptografia ou detalhes pessoais, podem ser expostos se armazenados em vari√°veis n√£o inicializadas, permitindo que os atacantes potencialmente leiam esses dados.
* **Divulga√ß√£o de Informa√ß√µes**: O conte√∫do de vari√°veis n√£o inicializadas pode revelar detalhes sobre o layout de mem√≥ria do programa ou opera√ß√µes internas, auxiliando os atacantes no desenvolvimento de exploits direcionados.
* **Falhas e Instabilidade**: Opera√ß√µes envolvendo vari√°veis n√£o inicializadas podem resultar em comportamento indefinido, levando a falhas no programa ou resultados imprevis√≠veis.
* **Execu√ß√£o de C√≥digo Arbitr√°rio**: Em cen√°rios espec√≠ficos, os atacantes poderiam explorar essas vulnerabilidades para alterar o fluxo de execu√ß√£o do programa, permitindo que executem c√≥digo arbitr√°rio, que pode incluir amea√ßas de execu√ß√£o de c√≥digo remoto.

### Exemplo
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Como Isso Funciona:

* **Fun√ß√£o `initializeAndPrint`**: Esta fun√ß√£o declara uma vari√°vel inteira `initializedVar`, atribui a ela o valor `100` e, em seguida, imprime tanto o endere√ßo de mem√≥ria quanto o valor da vari√°vel. Este passo √© direto e mostra como uma vari√°vel inicializada se comporta.
* **Fun√ß√£o `demonstrateUninitializedVar`**: Nesta fun√ß√£o, declaramos uma vari√°vel inteira `uninitializedVar` sem inicializ√°-la. Quando tentamos imprimir seu valor, a sa√≠da pode mostrar um n√∫mero aleat√≥rio. Este n√∫mero representa qualquer dado que estava previamente naquela localiza√ß√£o de mem√≥ria. Dependendo do ambiente e do compilador, a sa√≠da real pode variar e, √†s vezes, por seguran√ßa, alguns compiladores podem inicializar automaticamente vari√°veis para zero, embora isso n√£o deva ser confi√°vel.
* **Fun√ß√£o `main`**: A fun√ß√£o `main` chama ambas as fun√ß√µes acima em sequ√™ncia, demonstrando o contraste entre uma vari√°vel inicializada e uma n√£o inicializada.

## Exemplo ARM64

Isso n√£o muda em nada no ARM64, pois as vari√°veis locais tamb√©m s√£o gerenciadas na pilha, voc√™ pode [**verificar este exemplo**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) onde isso √© mostrado.
