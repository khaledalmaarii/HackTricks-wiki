# Neinicijalizovane promenljive

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Osnovna ideja ovde je razumeti 코ta se de코ava sa **neinicijalizovanim promenljivima jer 캖e imati vrednost koja je ve캖 bila u dodeljenoj memoriji njima.** Primer:

* **Funkcija 1: `initializeVariable`**: Deklarisali smo promenljivu `x` i dodelili joj vrednost, recimo `0x1234`. Ova akcija je sli캜na rezervisanju mesta u memoriji i postavljanju odre캠ene vrednosti u nju.
* **Funkcija 2: `useUninitializedVariable`**: Ovde deklari코emo drugu promenljivu `y` ali joj ne dodeljujemo nikakvu vrednost. U programskom jeziku C, neinicijalizovane promenljive se ne postavljaju automatski na nulu. Umesto toga, zadr쬬vaju vrednost koja je poslednja bila sa캜uvana na njihovoj memorijskoj lokaciji.

Kada pokrenemo ove dve funkcije **sekvencijalno**:

1. U `initializeVariable`, `x` je dodeljena vrednost (`0x1234`), koja zauzima odre캠enu memorijsku adresu.
2. U `useUninitializedVariable`, `y` je deklarisana ali joj nije dodeljena vrednost, pa zauzima memorijsko mesto odmah posle `x`. Zbog nedostatka inicijalizacije `y`, zavr코ava "nasle캠uju캖i" vrednost sa iste memorijske lokacije koju koristi `x`, jer je to poslednja vrednost koja je bila tamo.

Ovo pona코anje ilustruje klju캜ni koncept u programiranju na niskom nivou: **Upravljanje memorijom je klju캜no**, a neinicijalizovane promenljive mogu dovesti do nepredvidivog pona코anja ili sigurnosnih ranjivosti, jer mogu nenamerno dr쬬ti osetljive podatke ostavljene u memoriji.

Neinicijalizovane promenljive na steku mogu predstavljati nekoliko sigurnosnih rizika kao 코to su:

* **Curenje podataka**: Osetljive informacije poput lozinki, klju캜eva za 코ifrovanje ili li캜nih detalja mogu biti izlo쬰ne ako se 캜uvaju u neinicijalizovanim promenljivima, omogu캖avaju캖i napada캜ima da potencijalno pro캜itaju ove podatke.
* **Otkrivanje informacija**: Sadr쬬j neinicijalizovanih promenljivih mo쬰 otkriti detalje o memorijskoj strukturi programa ili internim operacijama, poma쬿캖i napada캜ima u razvoju ciljanih eksploatacija.
* **Padovi i nestabilnost**: Operacije koje uklju캜uju neinicijalizovane promenljive mogu rezultirati nedefinisanim pona코anjem, 코to dovodi do ru코enja programa ili nepredvidivih ishoda.
* **Izvr코avanje proizvoljnog koda**: U odre캠enim scenarijima, napada캜i bi mogli iskoristiti ove ranjivosti da promene tok izvr코avanja programa, omogu캖avaju캖i im da izvr코e proizvoljan kod, 코to mo쬰 uklju캜ivati pretnje izvr코avanjem udaljenog koda.

### Primer
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Kako ovo funkcioni코e:

* **Funkcija `initializeAndPrint`**: Ova funkcija deklari코e celobrojnu promenljivu `initializedVar`, dodeljuje joj vrednost `100`, a zatim 코tampa kako memorijsku adresu tako i vrednost promenljive. Ovaj korak je jednostavan i pokazuje kako se pona코a inicijalizovana promenljiva.
* **Funkcija `demonstrateUninitializedVar`**: U ovoj funkciji deklari코emo celobrojnu promenljivu `uninitializedVar` bez inicijalizacije. Kada poku코amo da 코tampamo njenu vrednost, izlaz mo쬰 pokazati nasumi캜an broj. Taj broj predstavlja bilo koje podatke koji su prethodno bili na toj memorijskoj lokaciji. Zavisno od okru쬰nja i kompajlera, stvarni izlaz mo쬰 varirati, a ponekad, radi bezbednosti, neki kompajleri automatski mogu inicijalizovati promenljive na nulu, iako se na to ne bi trebalo oslanjati.
* **Funkcija `main`**: Funkcija `main` poziva obe prethodne funkcije jednu za drugom, demonstriraju캖i kontrast izme캠u inicijalizovane i neinicijalizovane promenljive.

## Primer za ARM64

Ovo se u potpunosti ne menja u ARM64 jer se lokalne promenljive tako캠e upravljaju na steku, mo쬰te [**proveriti ovaj primer**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) gde je to prikazano.
