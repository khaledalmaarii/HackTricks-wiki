# Osnove Android aplikacija

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Android Sigurnosni Model

**Postoje dva sloja:**

* **OS**, koji drÅ¾i instalirane aplikacije izolovane jednu od druge.
* **Sama aplikacija**, koja omoguÄ‡ava developerima da **izloÅ¾e odreÄ‘ene funkcionalnosti** i konfiguriÅ¡u sposobnosti aplikacije.

### UID Separacija

**Svaka aplikacija je dodeljena specifiÄan User ID**. Ovo se radi prilikom instalacije aplikacije tako da **aplikacija moÅ¾e da interaguje samo sa fajlovima koje poseduje njen User ID ili deljenim** fajlovima. Zbog toga, samo aplikacija, odreÄ‘eni delovi OS-a i root korisnik mogu pristupiti podacima aplikacija.

### Deljenje UID-a

**Dve aplikacije mogu biti konfigurisane da koriste isti UID**. Ovo moÅ¾e biti korisno za deljenje informacija, ali ako je jedna od njih kompromitovana, podaci obe aplikacije Ä‡e biti kompromitovani. Zato se ovo ponaÅ¡anje **ne preporuÄuje**.\
**Da bi delile isti UID, aplikacije moraju definisati istu vrednost `android:sharedUserId` u njihovim manifestima.**

### Izolacija

**Android aplikacioni pesak** omoguÄ‡ava pokretanje **svake aplikacije** kao **zaseban proces pod zasebnim User ID-om**. Svaki proces ima svoju virtuelnu maÅ¡inu, tako da kod aplikacije radi izolovano od drugih aplikacija.\
Od Android 5.0(L) **SELinux** je primenjen. U osnovi, SELinux odbija sve interakcije procesa i zatim kreira politike da **dozvoli samo oÄekivane interakcije izmeÄ‘u njih**.

### Dozvole

Kada instalirate **aplikaciju i ona traÅ¾i dozvole**, aplikacija traÅ¾i dozvole konfigurisane u **`uses-permission`** elementima u **AndroidManifest.xml** fajlu. **Uses-permission** element oznaÄava ime traÅ¾ene dozvole unutar **name** **atributa**. TakoÄ‘e ima **maxSdkVersion** atribut koji zaustavlja traÅ¾enje dozvola na verzijama viÅ¡im od navedene.\
Imajte na umu da android aplikacije ne moraju traÅ¾iti sve dozvole na poÄetku, mogu takoÄ‘e **traÅ¾iti dozvole dinamiÄki** ali sve dozvole moraju biti **deklarisane** u **manifestu**.

Kada aplikacija izlaÅ¾e funkcionalnost, moÅ¾e ograniÄiti **pristup samo aplikacijama koje imaju odreÄ‘enu dozvolu**.\
Element dozvole ima tri atributa:

* **Ime** dozvole
* Atribut **permission-group**, koji omoguÄ‡ava grupisanje povezanih dozvola.
* **Nivo zaÅ¡tite** koji oznaÄava kako su dozvole dodeljene. Postoje Äetiri tipa:
* **Normalno**: Koristi se kada nema **poznatih pretnji** aplikaciji. Korisniku nije potrebno da je **odobri**.
* **Opasno**: OznaÄava da dozvola daje traÅ¾enoj aplikaciji neki **poviÅ¡en pristup**. **Korisnici su zamoljeni da ih odobre**.
* **Potpis**: Samo **aplikacije potpisane istim sertifikatom kao i ona** koja izvozi komponentu mogu dobiti dozvolu. Ovo je najjaÄi tip zaÅ¡tite.
* **PotpisIliSistem**: Samo **aplikacije potpisane istim sertifikatom kao i ona** koja izvozi komponentu ili **aplikacije koje se izvrÅ¡avaju sa sistemskim nivoom pristupa** mogu dobiti dozvole

## Preinstalirane Aplikacije

Ove aplikacije se obiÄno nalaze u direktorijumima **`/system/app`** ili **`/system/priv-app`** i neke od njih su **optimizovane** (moÅ¾da neÄ‡ete ni pronaÄ‡i `classes.dex` fajl). Ove aplikacije vredi proveriti jer su nekad **pokrenute sa previÅ¡e dozvola** (kao root).

* One isporuÄene sa **AOSP** (Android OpenSource Project) **ROM-om**
* Dodate od strane proizvoÄ‘aÄa ureÄ‘aja
* Dodate od strane provajdera **mobilnog telefona** (ako je kupljen od njih)

## Rootovanje

Da biste dobili root pristup fiziÄkom Android ureÄ‘aju obiÄno morate **iskoristiti** 1 ili 2 **ranjivosti** koje obiÄno budu **specifiÄne** za **ureÄ‘aj** i **verziju**.\
Kada eksploatacija uspe, obiÄno se Linux `su` binarni fajl kopira na lokaciju navedenu u korisnikovoj PATH env promenljivoj kao Å¡to je `/system/xbin`.

Kada je su binarni fajl konfigurisan, druga Android aplikacija se koristi za interakciju sa `su` binarnim fajlom i **obradu zahteva za root pristup** kao Å¡to su **Superuser** i **SuperSU** (dostupne u Google Play prodavnici).

{% hint style="danger" %}
Imajte na umu da je proces rootovanja veoma opasan i moÅ¾e ozbiljno oÅ¡tetiti ureÄ‘aj
{% endhint %}

### ROM-ovi

MoguÄ‡e je **zameniti OS instaliranjem prilagoÄ‘enog firmware-a**. To omoguÄ‡ava proÅ¡irenje upotrebljivosti starog ureÄ‘aja, zaobilazak softverskih ograniÄenja ili pristup najnovijem Android kodu.\
**OmniROM** i **LineageOS** su dva od najpopularnija firmware-a za koriÅ¡Ä‡enje.

Imajte na umu da **nije uvek potrebno rootovati ureÄ‘aj** da biste instalirali prilagoÄ‘eni firmware. **Neki proizvoÄ‘aÄi dozvoljavaju** otkljuÄavanje njihovih bootloader-a na dobro dokumentovan i siguran naÄin.

### Posledice

Kada je ureÄ‘aj rootovan, bilo koja aplikacija moÅ¾e zatraÅ¾iti pristup kao root. Ako zlonamerna aplikacija to dobije, moÅ¾e imati pristup skoro svemu i moÄ‡i Ä‡e da oÅ¡teti telefon.

## Osnove Android Aplikacija <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Format Android aplikacija se naziva _APK format fajla_. U osnovi je to **ZIP fajl** (preimenovanjem ekstenzije fajla u .zip, sadrÅ¾aj moÅ¾e biti izvaÄ‘en i pregledan).
- SadrÅ¾aj APK-a (Nije iscrpan)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: sadrÅ¾i prekompilirane resurse, poput binarnog XML-a.
- res/xml/files\_paths.xml
- META-INF/
- Ovde se nalazi Sertifikat!
- **classes.dex**
- SadrÅ¾i Dalvik bajtkod, predstavlja kompilirani Java (ili Kotlin) kod koji aplikacija izvrÅ¡ava po podrazumevanim postavkama.
- lib/
- SadrÅ¾i nativne biblioteke, razdvojene po arhitekturi CPU-a u poddirektorijumima.
- `armeabi`: kod za procesore na bazi ARM-a
- `armeabi-v7a`: kod za ARMv7 i novije procesore
- `x86`: kod za X86 procesore
- `mips`: kod samo za MIPS procesore
- assets/
- ÄŒuva razliÄite fajlove potrebne aplikaciji, potencijalno ukljuÄujuÄ‡i dodatne nativne biblioteke ili DEX fajlove, ponekad koriÅ¡Ä‡ene od strane autora malvera za prikrivanje dodatnog koda.
- res/
- SadrÅ¾i resurse koji nisu kompilovani u resources.arsc
### **Dalvik & Smali**

U Android razvoju, **Java ili Kotlin** se koriste za kreiranje aplikacija. Umesto koriÅ¡Ä‡enja JVM-a kao u desktop aplikacijama, Android kompajlira ovaj kod u **Dalvik Executable (DEX) bytecode**. Ranije je Dalvik virtuelna maÅ¡ina obraÄ‘ivala ovaj bytecode, ali sada, Android Runtime (ART) preuzima kontrolu u novijim verzijama Androida.

Za obrnuti inÅ¾enjering, **Smali** postaje kljuÄan. To je ljudima Äitljiva verzija DEX bytecode-a, delujuÄ‡i kao jezik asemblaÅ¾a prevodeÄ‡i izvorni kod u bytecode instrukcije. Smali i baksmali se odnose na alate za asembliranje i disasembliranje u ovom kontekstu.

## Intents

Intents su osnovno sredstvo komunikacije izmeÄ‘u komponenti Android aplikacija ili sa drugim aplikacijama. Ovi objekti poruka takoÄ‘e mogu prenositi podatke izmeÄ‘u aplikacija ili komponenti, sliÄno kao Å¡to se GET/POST zahtevi koriste u HTTP komunikacijama.

Dakle, Intent je u osnovi **poruka koja se prenosi izmeÄ‘u komponenti**. Intents **mogu biti usmereni** ka odreÄ‘enim komponentama ili aplikacijama, **ili mogu biti poslati bez odreÄ‘enog primaoca**.\
Da bude jednostavno, Intent se moÅ¾e koristiti:

* Za pokretanje Activity-ja, obiÄno otvaranje korisniÄkog interfejsa za aplikaciju
* Kao emitovanja za obaveÅ¡tavanje sistema i aplikacija o promenama
* Za pokretanje, zaustavljanje i komunikaciju sa pozadinskom uslugom
* Za pristup podacima putem ContentProvidera
* Kao povratni poziv za rukovanje dogaÄ‘ajima

Ako su ranjivi, **Intents mogu biti koriÅ¡Ä‡eni za izvoÄ‘enje razliÄitih napada**.

### Intent-Filter

**Intent Filteri** definiÅ¡u **kako aktivnost, usluga ili Broadcast Receiver mogu interagovati sa razliÄitim tipovima Intents-a**. U osnovi, opisuju sposobnosti ovih komponenti, kao Å¡to su koje akcije mogu izvrÅ¡iti ili vrste emitovanja koje mogu obraditi. Glavno mesto za deklarisanje ovih filtera je unutar **AndroidManifest.xml datoteke**, iako je kodiranje za Broadcast Receivere takoÄ‘e opcija.

Intent Filteri se sastoje od kategorija, akcija i filtera podataka, sa moguÄ‡noÅ¡Ä‡u ukljuÄivanja dodatnih metapodataka. Ova postavka omoguÄ‡ava komponentama da obrade specifiÄne Intents-e koji se podudaraju sa deklarisanim kriterijumima.

KljuÄni aspekt Android komponenti (aktivnosti/usluga/content providera/broadcast receivera) je njihova vidljivost ili **javni status**. Komponenta se smatra javnom i moÅ¾e interagovati sa drugim aplikacijama ako je **`exported`** sa vrednoÅ¡Ä‡u **`true`** ili ako je za nju deklarisan Intent Filter u manifestu. MeÄ‘utim, postoji naÄin za razvojnike da eksplicitno zadrÅ¾e ove komponente privatnim, osiguravajuÄ‡i da ne interaguju sa drugim aplikacijama nenamerno. To se postiÅ¾e postavljanjem atributa **`exported`** na **`false`** u njihovim definicijama manifesta.

Osim toga, razvojnici imaju opciju da dodatno obezbede pristup ovim komponentama zahtevanjem odreÄ‘enih dozvola. **`permission`** atribut moÅ¾e biti postavljen da bi se naloÅ¾ilo da samo aplikacije sa odreÄ‘enom dozvolom mogu pristupiti komponenti, dodajuÄ‡i dodatni sloj sigurnosti i kontrole nad tim ko moÅ¾e interagovati sa njom.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implicitni Intenti

Intenti se programski kreiraju koriÅ¡Ä‡enjem konstruktora Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Akcija** prethodno deklarisane namere je **ACTION\_SEND** i **Dodatno** je mailto **Uri** (Dodatno je dodatna informacija koju namera oÄekuje).

Ova namera treba da bude deklarisana unutar manifesta kao u sledeÄ‡em primeru:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Intent-filter treba da se podudara sa **akcijom**, **podacima** i **kategorijom** da bi primio poruku.

Proces "ReÅ¡avanja namere" odreÄ‘uje koja aplikacija treba da primi svaku poruku. Ovaj proces uzima u obzir **atribut prioriteta**, koji se moÅ¾e postaviti u deklaraciji **intent-filtera**, i **onaj sa veÄ‡im prioritetom Ä‡e biti izabran**. Ovaj prioritet moÅ¾e biti postavljen izmeÄ‘u -1000 i 1000, a aplikacije mogu koristiti vrednost `SYSTEM_HIGH_PRIORITY`. Ako doÄ‘e do **sukoba**, pojavljuje se prozor "izbora" kako bi **korisnik odluÄio**.

### Eksplicitne namere

Eksplicitna namera navodi ime klase koju cilja:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
U drugim aplikacijama, kako biste pristupili prethodno deklarisanoj nameri, moÅ¾ete koristiti:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Ovi dozvoljavaju drugim aplikacijama da **preduzmu radnje u ime vaÅ¡e aplikacije**, koristeÄ‡i identitet i dozvole vaÅ¡e aplikacije. Konstruisanje Pending Intenta treba **specificirati nameru i radnju koju treba izvrÅ¡iti**. Ako **deklarisana namera nije eksplicitna** (ne deklariÅ¡e koja namera moÅ¾e da je pozove), **zlonamerna aplikacija moÅ¾e izvrÅ¡iti deklarisane radnje** u ime aplikacije Å¾rtve. Å taviÅ¡e, **ako radnja nije specificirana**, zlonamerna aplikacija Ä‡e moÄ‡i da izvrÅ¡i **bilo koju radnju u ime Å¾rtve**.

### Broadcast Intents

Za razliku od prethodnih namera, koje prima samo jedna aplikacija, broadcast namerama **mogu pristupiti viÅ¡e aplikacija**. MeÄ‘utim, od API verzije 14, **moguÄ‡e je specificirati aplikaciju koja treba da primi** poruku koriÅ¡Ä‡enjem Intent.setPackage.

Alternativno, takoÄ‘e je moguÄ‡e **specificirati dozvolu prilikom slanja broadcasta**. Aplikacija primaoc Ä‡e morati da ima tu dozvolu.

Postoje **dva tipa** Broadcasta: **Normalni** (asinhroni) i **PoreÄ‘ani** (sinhroni). **Redosled** se zasniva na **konfigurisanoj prioritetu unutar primaoca** elementa. **Svaka aplikacija moÅ¾e obraditi, proslediti ili odbaciti Broadcast.**

MoguÄ‡e je **poslati** broadcast koristeÄ‡i funkciju `sendBroadcast(intent, receiverPermission)` iz klase `Context`.\
TakoÄ‘e moÅ¾ete koristiti funkciju **`sendBroadcast`** iz **`LocalBroadCastManager`** koji osigurava da **poruka nikada ne napusti aplikaciju**. KoriÅ¡Ä‡enjem ovoga Äak neÄ‡ete morati ni da izvezete komponentu primaoca.

### Ljepljivi Broadcasti

Ovaj tip Broadcasta **moÅ¾e biti pristupan dugo nakon Å¡to su poslati**.\
Ovi su zastareli od API nivoa 21 i preporuÄuje se **da se ne koriste**.\
**Dozvoljavaju bilo kojoj aplikaciji da prisluÅ¡kuje podatke, ali i da ih modifikuje.**

Ako pronaÄ‘ete funkcije koje sadrÅ¾e reÄ "ljepljivi" poput **`sendStickyBroadcast`** ili **`sendStickyBroadcastAsUser`**, **proverite uticaj i pokuÅ¡ajte da ih uklonite**.

## Duboke veze / URL Å¡eme

U Android aplikacijama, **duboke veze** se koriste za pokretanje radnje (Intent) direktno putem URL-a. To se postiÅ¾e deklarisanjem specifiÄne **URL Å¡eme** unutar aktivnosti. Kada Android ureÄ‘aj pokuÅ¡a da **pristupi URL-u sa ovom Å¡emom**, pokreÄ‡e se odreÄ‘ena aktivnost unutar aplikacije.

Å ema se mora deklarisati u datoteci **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Å ema iz prethodnog primera je `exampleapp://` (obratite paÅ¾nju i na **`kategoriju BROWSABLE`**)

Zatim, u polju podataka, moÅ¾ete specificirati **host** i **putanju**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Da biste pristupili sa veba, moguÄ‡e je postaviti link kao:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Da biste pronaÅ¡li **kÃ´d koji Ä‡e se izvrÅ¡iti u aplikaciji**, idite na aktivnost pozvanu pomoÄ‡u dubinskog linka i potraÅ¾ite funkciju **`onNewIntent`**.

Saznajte kako [pozvati dubinske linkove bez koriÅ¡Ä‡enja HTML stranica](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** dizajniran je za olakÅ¡avanje komunikacije izmeÄ‘u klijenta i servisa u Android aplikacijama putem **meÄ‘uprocesne komunikacije** (IPC). BuduÄ‡i da direktno pristupanje memoriji drugog procesa nije dozvoljeno na Androidu, AIDL pojednostavljuje proces marshalling objekata u format koji razume operativni sistem, olakÅ¡avajuÄ‡i komunikaciju izmeÄ‘u razliÄitih procesa.

### KljuÄni koncepti

- **Povezani servisi**: Ovi servisi koriste AIDL za IPC, omoguÄ‡avajuÄ‡i aktivnostima ili komponentama da se poveÅ¾u sa servisom, Å¡alju zahteve i primaju odgovore. Metoda `onBind` u klasi servisa je kljuÄna za pokretanje interakcije, oznaÄavajuÄ‡i je kao vaÅ¾no podruÄje za pregled sigurnosti u potrazi za ranjivostima.

- **Messenger**: FunkcioniÅ¡uÄ‡i kao povezani servis, Messenger olakÅ¡ava IPC sa fokusom na obradi podataka putem metode `onBind`. VaÅ¾no je paÅ¾ljivo pregledati ovu metodu radi bilo kakvog nebezbednog rukovanja podacima ili izvrÅ¡avanja osetljivih funkcija.

- **Binder**: Iako je direktna upotreba klase Binder manje uobiÄajena zbog apstrakcije AIDL-a, korisno je razumeti da Binder deluje kao drajver na nivou jezgra koji olakÅ¡ava prenos podataka izmeÄ‘u memorijskih prostora razliÄitih procesa. Za dalje razumevanje, dostupan je resurs na [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponente

Ove ukljuÄuju: **Aktivnosti, Servise, Prijemnike emitovanja i Provajdere.**

### Aktivnost pokretaÄa i druge aktivnosti

U Android aplikacijama, **aktivnosti** su poput ekrana koji prikazuju razliÄite delove korisniÄkog interfejsa aplikacije. Aplikacija moÅ¾e imati mnogo aktivnosti, prikazujuÄ‡i svaka jedan jedinstveni ekran korisniku.

**Aktivnost pokretaÄa** je glavni ulaz u aplikaciju, pokreÄ‡e se kada dodirnete ikonu aplikacije. Definisana je u manifest fajlu aplikacije sa specifiÄnim MAIN i LAUNCHER intentima:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nisu sve aplikacije potrebne aktivnosti pokretaÄa, posebno one bez korisniÄkog interfejsa, poput pozadinskih usluga.

Aktivnosti mogu biti dostupne drugim aplikacijama ili procesima oznaÄavanjem kao "izloÅ¾ene" u manifestu. Ovo podeÅ¡avanje omoguÄ‡ava drugim aplikacijama da pokrenu ovu aktivnost:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
MeÄ‘utim, pristupanje aktivnosti iz druge aplikacije nije uvek sigurnosni rizik. Briga se javlja ako se osetljivi podaci dele nepravilno, Å¡to moÅ¾e dovesti do curenja informacija.

Å½ivotni ciklus aktivnosti **poÄinje sa onCreate metodom**, postavljanjem korisniÄkog interfejsa i pripremom aktivnosti za interakciju sa korisnikom.

### Podklasa aplikacije

U Android razvoju, aplikacija ima opciju da kreira **podklasu** klase [Application](https://developer.android.com/reference/android/app/Application), iako to nije obavezno. Kada je takva podklasa definisana, postaje prva klasa koja se instancira unutar aplikacije. Metoda **`attachBaseContext`**, ako je implementirana u ovoj podklasi, izvrÅ¡ava se pre metode **`onCreate`**. Ova postavka omoguÄ‡ava ranu inicijalizaciju pre nego Å¡to se ostatak aplikacije pokrene.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Servisi

[Servisi](https://developer.android.com/guide/components/services) su **pozadinski operativci** sposobni da izvrÅ¡avaju zadatke bez korisniÄkog interfejsa. Ovi zadaci mogu nastaviti da se izvrÅ¡avaju Äak i kada korisnici preÄ‘u na druge aplikacije, Å¡to Äini servise kljuÄnim za **dugotrajne operacije**.

Servisi su veoma fleksibilni; mogu biti pokrenuti na razliÄite naÄine, pri Äemu su **Intents** primarni metod za njihovo pokretanje kao ulazna taÄka aplikacije. Kada se servis pokrene koriÅ¡Ä‡enjem metode `startService`, njegova metoda `onStart` se aktivira i nastavlja sa radom sve dok se eksplicitno ne pozove metoda `stopService`. Alternativno, ako je uloga servisa uslovljena aktivnom klijentskom konekcijom, koristi se metoda `bindService` za povezivanje klijenta sa servisom, angaÅ¾ujuÄ‡i metodu `onBind` za prenos podataka.

Interesantna primena servisa ukljuÄuje reprodukciju pozadinske muzike ili preuzimanje mreÅ¾nih podataka bez ometanja interakcije korisnika sa aplikacijom. Osim toga, servisi mogu biti dostupni drugim procesima na istom ureÄ‘aju putem **izvoza**. Ovo nije podrazumevano ponaÅ¡anje i zahteva eksplicitnu konfiguraciju u Android Manifest fajlu:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** deluju kao sluÅ¡aoci u sistemu poruka, omoguÄ‡avajuÄ‡i viÅ¡e aplikacija da odgovore na iste poruke iz sistema. Aplikacija moÅ¾e **registrovati prijemnik** na **dva osnovna naÄina**: putem **Manifesta** aplikacije ili **dinamiÄki** unutar koda aplikacije putem API-ja **`registerReceiver`**. U Manifestu, emitovanja se filtriraju sa dozvolama, dok dinamiÄki registrovani prijemnici takoÄ‘e mogu specificirati dozvole prilikom registracije.

**Filteri namere** su kljuÄni u oba metoda registracije, odreÄ‘ujuÄ‡i koje emitovanja pokreÄ‡u prijemnik. Kada se poÅ¡alje odgovarajuÄ‡e emitovanje, poziva se metoda **`onReceive`** prijemnika, omoguÄ‡avajuÄ‡i aplikaciji da reaguje u skladu, kao Å¡to je prilagoÄ‘avanje ponaÅ¡anja u odgovoru na upozorenje o niskom nivou baterije.

Emitovanja mogu biti ili **asinhrona**, dostiÅ¾uÄ‡i sve prijemnike bez redosleda, ili **sinhrona**, gde prijemnici dobijaju emitovanje na osnovu postavljenih prioriteta. MeÄ‘utim, vaÅ¾no je napomenuti potencijalni sigurnosni rizik, jer bilo koja aplikacija moÅ¾e sebe prioritetizovati da presretne emitovanje.

Da biste razumeli funkcionalnost prijemnika, potraÅ¾ite metodu **`onReceive`** unutar njegove klase. Kod ove metode moÅ¾e manipulisati primljenom namerom, istiÄuÄ‡i potrebu za validacijom podataka od strane prijemnika, posebno u **PoreÄ‘anim Emitovanjima**, koja mogu modifikovati ili odbaciti nameru.

### Provajder SadrÅ¾aja

**Provajderi sadrÅ¾aja** su kljuÄni za **deljenje strukturiranih podataka** izmeÄ‘u aplikacija, naglaÅ¡avajuÄ‡i vaÅ¾nost implementiranja **dozvola** kako bi se osigurala sigurnost podataka. Oni omoguÄ‡avaju aplikacijama pristup podacima iz razliÄitih izvora, ukljuÄujuÄ‡i baze podataka, fajl sisteme ili veb. SpecifiÄne dozvole, poput **`readPermission`** i **`writePermission`**, su kljuÄne za kontrolu pristupa. Dodatno, privremeni pristup moÅ¾e biti odobren putem podeÅ¡avanja **`grantUriPermission`** u manifestu aplikacije, koristeÄ‡i atribute poput `path`, `pathPrefix` i `pathPattern` za detaljnu kontrolu pristupa.

Validacija unosa je od suÅ¡tinskog znaÄaja kako bi se spreÄile ranjivosti, poput SQL ubacivanja. Provajderi sadrÅ¾aja podrÅ¾avaju osnovne operacije: `insert()`, `update()`, `delete()` i `query()`, olakÅ¡avajuÄ‡i manipulaciju podacima i deljenje meÄ‘u aplikacijama.

**FileProvider**, specijalizovani Provajder SadrÅ¾aja, fokusira se na sigurno deljenje fajlova. Definisan je u manifestu aplikacije sa specifiÄnim atributima za kontrolu pristupa fasciklama, oznaÄenim sa `android:exported` i `android:resource` koji pokazuju konfiguracije fascikli. PreporuÄuje se oprez prilikom deljenja direktorijuma kako bi se izbeglo sluÄajno izlaganje osetljivih podataka.

Primer deklaracije manifesta za FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
I primer za specificiranje deljenih fascikli u `filepaths.xml` datoteci:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Za dodatne informacije pogledajte:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews su kao **mini web pregledaÄi** unutar Android aplikacija, koji prikazuju sadrÅ¾aj ili sa weba ili iz lokalnih datoteka. Oni se suoÄavaju sa sliÄnim rizicima kao i obiÄni pregledaÄi, ali postoji naÄin da se **smanje ovi rizici** kroz specifiÄna **podeÅ¡avanja**.

Android nudi dva glavna tipa WebView-a:

- **WebViewClient** je odliÄan za osnovni HTML ali ne podrÅ¾ava JavaScript alert funkciju, Å¡to utiÄe na to kako se XSS napadi mogu testirati.
- **WebChromeClient** se ponaÅ¡a viÅ¡e kao potpuno iskustvo pregledaÄa Chrome.

KljuÄna stvar je da WebView pregledaÄi **ne dele kolaÄiÄ‡e** sa glavnim pregledaÄem ureÄ‘aja.

Za uÄitavanje sadrÅ¾aja, dostupne su metode poput ````loadUrl````, ````loadData````, i ````loadDataWithBaseURL````. VaÅ¾no je osigurati da su ovi URL-ovi ili datoteke **sigurne za koriÅ¡Ä‡enje**. Sigurnosna podeÅ¡avanja mogu se upravljati putem klase ````WebSettings````. Na primer, onemoguÄ‡avanje JavaScript-a sa ````setJavaScriptEnabled(false)```` moÅ¾e spreÄiti XSS napade.

JavaScript "Bridge" omoguÄ‡ava Java objektima da interaguju sa JavaScript-om, zahtevajuÄ‡i da se metode obeleÅ¾e sa ````@JavascriptInterface```` radi sigurnosti od Android verzije 4.2 nadalje.

Dozvoljavanje pristupa sadrÅ¾aju (````setAllowContentAccess(true)````) omoguÄ‡ava WebViews da pristupe Content Providers-u, Å¡to moÅ¾e biti riziÄno osim ako se URL-ovi sadrÅ¾aja ne provere kao sigurni.

Za kontrolu pristupa datotekama:
- OnemoguÄ‡avanje pristupa datotekama (````setAllowFileAccess(false)````) ograniÄava pristup fajl sistemu, sa izuzecima za odreÄ‘ene resurse, osiguravajuÄ‡i da se koriste samo za neosetljiv sadrÅ¾aj.

## Ostale komponente aplikacije i upravljanje mobilnim ureÄ‘ajima

### **Digitalno potpisivanje aplikacija**

- **Digitalno potpisivanje** je obavezno za Android aplikacije, osiguravajuÄ‡i da su **autentiÄno autorizovane** pre instalacije. Ovaj proces koristi sertifikat za identifikaciju aplikacije i mora biti verifikovan od strane upravljaÄa paketa ureÄ‘aja prilikom instalacije. Aplikacije mogu biti **samopotpisane ili sertifikovane od strane spoljnog CA**, Å¡titeÄ‡i od neovlaÅ¡Ä‡enog pristupa i osiguravajuÄ‡i da aplikacija ostane nepromenjena tokom isporuke na ureÄ‘aj.

### **Provera aplikacija za unapreÄ‘enu sigurnost**

- PoÄevÅ¡i od **Android 4.2**, funkcija nazvana **Provera aplikacija** omoguÄ‡ava korisnicima da provere sigurnost aplikacija pre instalacije. Ovaj **proces provere** moÅ¾e upozoriti korisnike na potencijalno Å¡tetne aplikacije, ili Äak spreÄiti instalaciju posebno zlonamernih, unapreÄ‘ujuÄ‡i sigurnost korisnika.

### **Upravljanje mobilnim ureÄ‘ajima (MDM)**

- **MDM reÅ¡enja** pruÅ¾aju **nadzor i sigurnost** za mobilne ureÄ‘aje putem **Device Administration API**-ja. Zahtevaju instalaciju Android aplikacije radi efikasnog upravljanja i osiguranja mobilnih ureÄ‘aja. KljuÄne funkcije ukljuÄuju **nametanje pravila za lozinke**, **obaveznu enkripciju skladiÅ¡ta**, i **dozvolu za daljinsko brisanje podataka**, osiguravajuÄ‡i sveobuhvatnu kontrolu i sigurnost nad mobilnim ureÄ‘ajima.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
