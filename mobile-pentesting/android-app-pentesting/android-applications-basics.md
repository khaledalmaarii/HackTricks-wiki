# Podstawy aplikacji Android

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Znajduj podatnoci, kt贸re maj najwiksze znaczenie, aby m贸c je szybko naprawi. Intruder ledzi powierzchni ataku, wykonuje proaktywne skanowanie zagro偶e, znajduje problemy we wszystkich technologiach, od interfejs贸w API po aplikacje internetowe i systemy chmurowe. [**Wypr贸buj go za darmo**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) ju偶 dzi.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Model bezpieczestwa Androida

**Istniej dwie warstwy:**

* **System operacyjny**, kt贸ry izoluje zainstalowane aplikacje od siebie nawzajem.
* **Sama aplikacja**, kt贸ra umo偶liwia programistom **udostpnianie okrelonych funkcji** i konfiguracj mo偶liwoci aplikacji.

### Separacja UID

**Ka偶dej aplikacji przypisywane jest okrelone ID u偶ytkownika**. Dzieje si to podczas instalacji aplikacji, dziki czemu aplikacja mo偶e interakcjonowa tylko z plikami nale偶cymi do jej ID u偶ytkownika lub plikami udostpnionymi. Dlatego tylko sama aplikacja, niekt贸re komponenty systemu operacyjnego i u偶ytkownik root maj dostp do danych aplikacji.

### Wsp贸dzielenie UID

**Dwie aplikacje mog by skonfigurowane do korzystania z tego samego UID**. Mo偶e to by przydatne do wsp贸dzielenia informacji, ale jeli jedna z nich zostanie skompromitowana, dane obu aplikacji zostan naruszone. Dlatego zachowanie to jest **odradzane**.\
**Aby wsp贸dzieli to samo UID, aplikacje musz zdefiniowa ten sam atrybut `android:sharedUserId` w swoich manifestach.**

### Izolacja

**Piaskownica aplikacji Android** pozwala uruchamia **ka偶d aplikacj** jako **oddzielny proces pod oddzielnym identyfikatorem u偶ytkownika**. Ka偶dy proces ma swoj wasn maszyn wirtualn, wic kod aplikacji dziaa w izolacji od innych aplikacji.\
Od wersji Androida 5.0(L) jest stosowany **SELinux**. W skr贸cie, SELinux odrzuca wszystkie interakcje midzy procesami, a nastpnie tworzy polityki, kt贸re **pozwalaj tylko na oczekiwane interakcje midzy nimi**.

### Uprawnienia

Podczas instalacji **aplikacji i 偶dania uprawnie**, aplikacja prosi o uprawnienia skonfigurowane w elementach **`uses-permission`** w pliku **AndroidManifest.xml**. Element **uses-permission** wskazuje nazw 偶danego uprawnienia w atrybucie **name**. Ma r贸wnie偶 atrybut **maxSdkVersion**, kt贸ry przestaje prosi o uprawnienia w wersjach wy偶szych ni偶 okrelona.\
Nale偶y zauwa偶y, 偶e aplikacje Android nie musz prosi o wszystkie uprawnienia na pocztku, mog r贸wnie偶 **dynamicznie prosi o uprawnienia**, ale wszystkie uprawnienia musz by **zadeklarowane** w manifecie.

Gdy aplikacja udostpnia funkcjonalno, mo偶e ograniczy **dostp tylko do aplikacji posiadajcych okrelone uprawnienie**.\
Element uprawnienia ma trzy atrybuty:

* **Nazwa** uprawnienia
* Atrybut **permission-group**, kt贸ry umo偶liwia grupowanie powizanych uprawnie.
* **Poziom ochrony**, kt贸ry wskazuje, jak uprawnienia s udzielane. Istniej cztery typy:
* **Normalne**: U偶ywane, gdy nie ma **znanych zagro偶e** dla aplikacji. U偶ytkownik **nie musi go zatwierdza**.
* **Niebezpieczne**: Wskazuje, 偶e uprawnienie udziela 偶dajcej aplikacji pewnego **podwy偶szonego dostpu**. **U偶ytkownicy s proszeni o zatwierdzenie**.
* **Podpis**: Tylko **aplikacje podpisane tym samym certyfikatem co eksportujcy komponent** mog otrzyma uprawnienie. To jest najmocniejszy typ ochrony.
* **Podpis lub system**: Tylko **aplikacje podpisane tym samym certyfikatem co eksportujcy komponent lub aplikacje dziaajce z dostpem na poziomie systemu** mog otrzyma uprawnienia.

## Wstpnie zainstalowane aplikacje

Te aplikacje zazwyczaj znajduj si w katalogach **`/system/app`** lub **`/system/priv-app`**, a niekt贸re z nich s **zoptymalizowane** (mo偶liwe, 偶e nie znajdziesz nawet pliku `classes.dex`). Warto sprawdzi te aplikacje, poniewa偶 czasami dziaaj zbyt wieloma uprawnieniami (jako root).

* Te dostarczone z **ROM-em** (Android OpenSource Project) **AOSP**
* Dodane przez **producenta** urzdzenia
* Dodane przez **dostawc** telefonu kom贸rkowego (jeli zakupione od nich)

## Rootowanie

Aby uzyska dostp do roota na fizycznym urzdzeniu z systemem Android, zazwyczaj musisz **wykorzysta** 1 lub 2 **podatnoci**, kt贸re zwykle s **specyficzne** dla **urzdzenia** i **wersji**.\
Po udanym wykorzystaniu podatnoci, zazwyczaj binarny `su` systemu Linux jest kopiowany do lokalizacji okrelonej w zmiennej rodowiskowej PATH u偶ytkownika, na przykad `/system/xbin`.

Po skonfigurowaniu binarnego su, inn aplikacj Android mo偶na u偶y do komunikacji z binarnym `su` i **przetwarzania 偶da dostpu do roota**, takich jak **Superuser** i **SuperSU** (dostpne w sklepie Google Play).

{% hint style="danger" %}
Nale偶y pamita, 偶e proces rootowania jest bardzo niebezpieczny i mo偶e powa偶nie uszkodzi urzdzenie
{% endhint %}

### ROM-y

Mo偶liwe jest **zastpienie systemu operacyjnego, instalujc niestandardowe oprogramowanie**. Dziki temu mo偶na rozszerzy funkcjonalno starego urzdzenia, omin ograniczenia oprogramowania lub uzyska dostp do najnowszego kodu Androida.\
**OmniROM** i **LineageOS** to dwie z najpopularniejszych niestandardowych wersji oprogramowania.

Nale偶y zauwa偶y, 偶e **nie zawsze jest konieczne zrootowanie urzdzenia**, aby zainstalowa niestandardowe oprogramowanie.
### **Dalvik & Smali**

W rozwoju Androida do tworzenia aplikacji u偶ywa si **Javy lub Kotlinu**. Zamiast u偶ywa JVM jak w aplikacjach na komputery stacjonarne, Android kompiluje ten kod do **bajtkodu Dalvik Executable (DEX)**. Wczeniej, maszyna wirtualna Dalvik obsugiwaa ten bajtkod, ale teraz w nowszych wersjach Androida przejmuje to Android Runtime (ART).

W przypadku in偶ynierii wstecznej, kluczowe staje si **Smali**. Jest to czytelna dla czowieka wersja bajtkodu DEX, dziaajca jak jzyk asemblera, tumaczca kod 藕r贸dowy na instrukcje bajtkodu. Smali i baksmali odnosz si do narzdzi monta偶u i demonta偶u w tym kontekcie.


***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Znajd藕 najwa偶niejsze podatnoci, aby szybko je naprawi. Intruder ledzi powierzchni ataku, wykonuje skanowanie zagro偶e proaktywnych, znajduje problemy w caym stosie technologicznym, od interfejs贸w API po aplikacje internetowe i systemy chmurowe. [**Wypr贸buj go za darmo**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) ju偶 dzi.

***

## Intents

Intents s podstawowym rodkiem komunikacji midzy komponentami aplikacji Android lub innymi aplikacjami. Obiekty tych wiadomoci mog r贸wnie偶 przenosi dane midzy aplikacjami lub komponentami, podobnie jak w przypadku 偶da GET/POST w komunikacji HTTP.

Wic Intents to w zasadzie **wiadomo przekazywana midzy komponentami**. Intents **mog by skierowane** do konkretnych komponent贸w lub aplikacji, **lub mog by wysyane bez okrelonego odbiorcy**.\
W skr贸cie, Intent mo偶e by u偶ywany:

* Do uruchamiania Activity, zwykle otwierania interfejsu u偶ytkownika dla aplikacji
* Jako transmisje, informujce system i aplikacje o zmianach
* Do uruchamiania, zatrzymywania i komunikacji z usug w tle
* Do uzyskiwania dostpu do danych za porednictwem dostawc贸w treci
* Jako wywoania zwrotne do obsugi zdarze

Jeli s podatne, **Intents mog by wykorzystane do przeprowadzenia r贸偶nych atak贸w**.

### Intent-Filter

**Intent Filters** definiuj **spos贸b interakcji midzy aktywnoci, usug lub odbiornikiem transmisji a r贸偶nymi typami Intents**. W zasadzie opisuj one mo偶liwoci tych komponent贸w, takie jak jakie dziaania mog wykonywa lub jakie rodzaje transmisji mog przetwarza. G贸wnym miejscem deklaracji tych filtr贸w jest plik **AndroidManifest.xml**, cho dla odbiornik贸w transmisji mo偶liwe jest r贸wnie偶 ich kodowanie.

Intent Filters skadaj si z kategorii, dziaa i filtr贸w danych, z mo偶liwoci dodania dodatkowych metadanych. Taka konfiguracja pozwala komponentom obsugiwa konkretne Intents, kt贸re pasuj do zadeklarowanych kryteri贸w.

Krytycznym aspektem komponent贸w Androida (aktywnoci/usug/dostawc贸w treci/odbiorc贸w transmisji) jest ich widoczno lub **status publiczny**. Komponent jest uwa偶any za publiczny i mo偶e wsp贸pracowa z innymi aplikacjami, jeli jest **`eksportowany`** z wartoci **`true`** lub jeli dla niego w manifestu jest zadeklarowany Intent Filter. Jednak deweloperzy maj mo偶liwo utrzymania tych komponent贸w w trybie prywatnym, aby zapewni, 偶e nie bd one niezamierzenie wsp贸pracowa z innymi aplikacjami. Mo偶na to osign, ustawiajc atrybut **`eksportowany`** na **`false`** w definicjach manifestu.

Ponadto, deweloperzy maj mo偶liwo dodatkowego zabezpieczenia dostpu do tych komponent贸w, wymagajc okrelonych uprawnie. Atrybut **`permission`** mo偶e by ustawiony, aby wymusi, 偶e tylko aplikacje z wyznaczonym uprawnieniem mog uzyska dostp do komponentu, dodajc dodatkow warstw bezpieczestwa i kontroli nad tym, kto mo偶e z nim wsp贸pracowa.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implicite Intencje

Intencje s tworzone programowo za pomoc konstruktora Intencji:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Akcja** wczeniej zadeklarowanego zamiaru to **ACTION\_SEND**, a **Extra** to mailto **Uri** (Extra to dodatkowe informacje, kt贸rych oczekuje zamiar).

Ten zamiar powinien by zadeklarowany w manifestu, jak w poni偶szym przykadzie:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Intent-filter musi pasowa do **akcji**, **danych** i **kategorii**, aby otrzyma wiadomo.

Proces "rozwizywania intencji" okrela, kt贸ra aplikacja powinna otrzyma ka偶d wiadomo. Proces ten uwzgldnia atrybut **priorytetu**, kt贸ry mo偶e by ustawiony w deklaracji **intent-filter**, a **wybrana zostanie ta z wy偶szym priorytetem**. Priorytet ten mo偶e by ustawiony w zakresie od -1000 do 1000, a aplikacje mog u偶ywa wartoci `SYSTEM_HIGH_PRIORITY`. Jeli pojawi si **konflikt**, pojawia si okno "wyboru", w kt贸rym **u偶ytkownik mo偶e zdecydowa**.

### Jawne intencje

Jawna intencja okrela nazw klasy, do kt贸rej jest skierowana:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
W innych aplikacjach, aby uzyska dostp do wczeniej zadeklarowanego intencji, mo偶na u偶y:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Oczekujce Intenty

Pozwalaj innym aplikacjom **wykonywa dziaania w imieniu Twojej aplikacji**, korzystajc z to偶samoci i uprawnie Twojej aplikacji. Konstruujc Oczekujcy Intent, nale偶y **okreli intencj i dziaanie do wykonania**. Jeli **zadeklarowana intencja nie jest jawna** (nie okrela, kt贸ra intencja mo偶e j wywoa), **zoliwa aplikacja mo偶e wykona zadeklarowane dziaanie** w imieniu aplikacji ofiary. Ponadto, **jeli nie jest okrelone 偶adne dziaanie**, zoliwa aplikacja bdzie moga wykona **dowolne dziaanie w imieniu ofiary**.

### Intenty Rozgoszeniowe

W przeciwiestwie do poprzednich intencji, kt贸re s odbierane tylko przez jedn aplikacj, intencje rozgoszeniowe **mog by odbierane przez wiele aplikacji**. Jednak od wersji API 14, **mo偶na okreli aplikacj, kt贸ra powinna otrzyma** wiadomo, u偶ywajc Intent.set Package.

Alternatywnie, przy wysyaniu rozgoszenia mo偶na **okreli uprawnienie**. Aplikacja odbiorcza bdzie musiaa posiada to uprawnienie.

Istniej **dwa rodzaje** rozgosze: **Normalne** (asynchroniczne) i **Uporzdkowane** (synchroniczne). **Kolejno** jest oparta na **ustawionym priorytecie wewntrz elementu odbiorcy**. **Ka偶da aplikacja mo偶e przetwarza, przekazywa lub odrzuca rozgoszenie**.

Mo偶na **wysa** rozgoszenie, u偶ywajc funkcji `sendBroadcast(intent, receiverPermission)` z klasy `Context`.\
Mo偶na r贸wnie偶 u偶y funkcji **`sendBroadcast`** z **`LocalBroadCastManager`**, kt贸ra zapewnia, 偶e **wiadomo nigdy nie opuci aplikacji**. Dziki temu nie bdzie nawet konieczne eksportowanie komponentu odbiorcy.

### Trwae Rozgoszenia

Ten rodzaj rozgosze **mo偶na uzyska dostp do nich dugo po ich wysaniu**.\
Zostay one oznaczone jako przestarzae w poziomie API 21 i **nie zaleca si ich u偶ywania**.\
**Pozwalaj dowolnej aplikacji na podsuchanie danych, ale tak偶e na ich modyfikacj**.

Jeli znajdziesz funkcje zawierajce sowo "sticky", takie jak **`sendStickyBroadcast`** lub **`sendStickyBroadcastAsUser`**, **sprawd藕 ich wpyw i spr贸buj je usun**.

## Gbokie linki / Schematy URL

W aplikacjach Android, **gbokie linki** s u偶ywane do inicjowania dziaania (Intencji) bezporednio za pomoc adresu URL. Dokonuje si tego poprzez zadeklarowanie okrelonego **schematu URL** wewntrz aktywnoci. Gdy urzdzenie z systemem Android pr贸buje **uzyska dostp do adresu URL z tym schematem**, uruchamiana jest okrelona aktywno w ramach aplikacji.

Schemat musi by zadeklarowany w pliku **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Schemat z poprzedniego przykadu to `exampleapp://` (zwr贸 uwag r贸wnie偶 na **`kategorie BROWSABLE`**)

Nastpnie, w polu danych, mo偶esz okreli **host** i **cie偶k**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Aby uzyska do niego dostp z przegldarki internetowej, mo偶na ustawi link w ten spos贸b:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Aby znale藕 **kod, kt贸ry zostanie wykonany w aplikacji**, przejd藕 do aktywnoci wywoanej przez deep link i wyszukaj funkcj **`onNewIntent`**.

Dowiedz si, jak [wywoywa deep linki bez u偶ycia stron HTML](./#wykorzystywanie-schemat贸w-deep-link贸w).

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** zosta zaprojektowany w celu uatwienia komunikacji midzy klientem a usug w aplikacjach Android za pomoc **komunikacji midzyprocesowej** (IPC). Poniewa偶 bezporedni dostp do pamici innego procesu nie jest dozwolony w systemie Android, AIDL upraszcza ten proces, serializujc obiekty do formatu zrozumiaego dla systemu operacyjnego, uatwiajc tym samym komunikacj midzy r贸偶nymi procesami.

### Kluczowe pojcia

- **Bound Services**: Usugi te wykorzystuj AIDL do IPC, umo偶liwiajc aktywnociom lub komponentom powizanie si z usug, skadanie 偶da i otrzymywanie odpowiedzi. Metoda `onBind` w klasie usugi jest kluczowa dla inicjowania interakcji, dlatego stanowi wa偶ne miejsce do przegldu pod ktem podatnoci na zagro偶enia.

- **Messenger**: Dziaajc jako powizana usuga, Messenger uatwia IPC, skupiajc si na przetwarzaniu danych za pomoc metody `onBind`. Wa偶ne jest dokadne sprawdzenie tej metody pod ktem niebezpiecznego przetwarzania danych lub wykonywania funkcji zawierajcych poufne informacje.

- **Binder**: Chocia偶 bezporednie u偶ycie klasy Binder jest mniej powszechne ze wzgldu na abstrakcj AIDL, warto zrozumie, 偶e Binder dziaa jako sterownik na poziomie jdra, uatwiajc transfer danych midzy przestrzeniami pamici r贸偶nych proces贸w. Dla lepszego zrozumienia dostpny jest materia na stronie [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponenty

Obejmuj one: **Aktywnoci, Usugi, Odbiorniki nadawcze i Dostawcy.**

### Aktywno uruchamiajca i inne aktywnoci

W aplikacjach Android **aktywnoci** s jak ekrany, prezentujce r贸偶ne czci interfejsu u偶ytkownika aplikacji. Aplikacja mo偶e mie wiele aktywnoci, z kt贸rych ka偶da prezentuje unikalny ekran u偶ytkownikowi.

**Aktywno uruchamiajca** jest g贸wnym wejciem do aplikacji, uruchamianym po naciniciu ikony aplikacji. Jest ona zdefiniowana w pliku manifestu aplikacji za pomoc konkretnych intencji MAIN i LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nie wszystkie aplikacje potrzebuj aktywnoci uruchamiajcej, zwaszcza te bez interfejsu u偶ytkownika, takie jak usugi w tle.

Aktywnoci mog by udostpniane innym aplikacjom lub procesom poprzez oznaczenie ich jako "eksportowane" w pliku manifestu. Ta opcja umo偶liwia innym aplikacjom uruchamianie tej aktywnoci:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Jednak dostp do aktywnoci z innej aplikacji nie zawsze stanowi ryzyko dla bezpieczestwa. Obawy pojawiaj si, jeli poufne dane s udostpniane nieprawidowo, co mo偶e prowadzi do wycieku informacji.

Cykl 偶ycia aktywnoci **rozpoczyna si od metody onCreate**, kt贸ra ustawia interfejs u偶ytkownika i przygotowuje aktywno do interakcji z u偶ytkownikiem.

### Podklasa aplikacji

W przypadku tworzenia aplikacji na Androida, istnieje opcja utworzenia **podklasy** klasy [Application](https://developer.android.com/reference/android/app/Application), cho nie jest to obowizkowe. Gdy taka podklasa jest zdefiniowana, staje si pierwsz klas, kt贸ra zostaje zainicjowana w ramach aplikacji. Metoda **`attachBaseContext`**, jeli jest zaimplementowana w tej podklasie, jest wykonywana przed metod **`onCreate`**. Taka konfiguracja umo偶liwia wczesn inicjalizacj przed rozpoczciem reszty aplikacji.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Usugi

[Usugi](https://developer.android.com/guide/components/services) to **operacje w tle**, kt贸re mog wykonywa zadania bez interfejsu u偶ytkownika. Te zadania mog dziaa nawet wtedy, gdy u偶ytkownicy przeczaj si na inne aplikacje, co czyni usugi niezbdnymi do **dugotrwaych operacji**.

Usugi s wszechstronne; mog by uruchamiane na r贸偶ne sposoby, przy czym **Intenty** s g贸wn metod uruchamiania ich jako punktu wejcia aplikacji. Po uruchomieniu usugi za pomoc metody `startService`, jej metoda `onStart` rozpoczyna dziaanie i dziaa a偶 do wywoania jawnego metody `stopService`. Alternatywnie, jeli rola usugi zale偶y od aktywnego poczenia klienta, u偶ywana jest metoda `bindService` do powizania klienta z usug, co anga偶uje metod `onBind` do przekazywania danych.

Interesujcym zastosowaniem usug jest odtwarzanie muzyki w tle lub pobieranie danych z sieci bez utrudniania interakcji u偶ytkownika z aplikacj. Ponadto, usugi mog by udostpniane innym procesom na tym samym urzdzeniu poprzez **eksportowanie**. Nie jest to zachowanie domylne i wymaga jawnie skonfigurowania w pliku Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Odbiorniki transmisji

**Odbiorniki transmisji** dziaaj jako suchacze w systemie wiadomoci, pozwalajc wielu aplikacjom reagowa na te same wiadomoci od systemu. Aplikacja mo偶e **zarejestrowa odbiornik** na **dwa g贸wne sposoby**: poprzez **Manifest** aplikacji lub **dynamicznie** w kodzie aplikacji za pomoc interfejsu API **`registerReceiver`**. W przypadku Manifestu, transmisje s filtrowane z uprawnieniami, podczas gdy odbiorniki zarejestrowane dynamicznie mog r贸wnie偶 okreli uprawnienia podczas rejestracji.

**Filtry intencji** s kluczowe w obu metodach rejestracji, okrelajc, kt贸re transmisje wywouj odbiornik. Po wysaniu pasujcej transmisji, wywoywana jest metoda **`onReceive`** odbiornika, umo偶liwiajc aplikacji reakcj w odpowiedni spos贸b, na przykad dostosowanie zachowania w odpowiedzi na alert o niskim poziomie baterii.

Transmisje mog by **asynchroniczne**, docierajc do wszystkich odbiornik贸w bez kolejnoci, lub **synchroniczne**, gdzie odbiorniki otrzymuj transmisj na podstawie ustawionych priorytet贸w. Wa偶ne jest jednak zauwa偶enie potencjalnego ryzyka bezpieczestwa, poniewa偶 dowolna aplikacja mo偶e nada sobie priorytet w celu przechwycenia transmisji.

Aby zrozumie funkcjonalno odbiornika, nale偶y szuka metody **`onReceive`** wewntrz jego klasy. Kod tej metody mo偶e manipulowa otrzyman intencj, co podkrela konieczno walidacji danych przez odbiorniki, zwaszcza w przypadku **uporzdkowanych transmisji**, kt贸re mog modyfikowa lub odrzuca intencj.

### Dostawca treci

**Dostawcy treci** s niezbdni do **udostpniania strukturalnych danych** midzy aplikacjami, co podkrela znaczenie implementacji **uprawnie** w celu zapewnienia bezpieczestwa danych. Pozwalaj aplikacjom uzyskiwa dostp do danych z r贸偶nych 藕r贸de, w tym baz danych, system贸w plik贸w lub sieci. Okrelone uprawnienia, takie jak **`readPermission`** i **`writePermission`**, s kluczowe dla kontroli dostpu. Dodatkowo, tymczasowy dostp mo偶na udzieli za pomoc ustawie **`grantUriPermission`** w manifecie aplikacji, wykorzystujc atrybuty takie jak `path`, `pathPrefix` i `pathPattern` do szczeg贸owej kontroli dostpu.

Walidacja danych wejciowych jest niezwykle wa偶na w celu zapobiegania podatnociom, takim jak wstrzyknicie SQL. Dostawcy treci obsuguj podstawowe operacje: `insert()`, `update()`, `delete()` i `query()`, uatwiajce manipulacj danymi i ich udostpnianie midzy aplikacjami.

**FileProvider**, specjalizowany dostawca treci, skupia si na bezpiecznym udostpnianiu plik贸w. Jest on zdefiniowany w manifecie aplikacji za pomoc okrelonych atrybut贸w do kontrolowania dostpu do folder贸w, oznaczonych przez `android:exported` i `android:resource`, wskazujcych na konfiguracje folder贸w. Nale偶y zachowa ostro偶no podczas udostpniania katalog贸w, aby unikn nieumylnego ujawnienia poufnych danych.

Przykadowe zadeklarowanie FileProvidera w manifecie:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
I przykad okrelenia udostpnionych folder贸w w `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Aby uzyska dalsze informacje, sprawd藕:
- [Android Developers: Dostawcy treci](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews s jak **mini przegldarki internetowe** wewntrz aplikacji Android, pobierajce tre zar贸wno z sieci, jak i z lokalnych plik贸w. Stoj przed podobnymi zagro偶eniami jak zwyke przegldarki, ale istniej sposoby na **zmniejszenie tych zagro偶e** poprzez odpowiednie **ustawienia**.

Android oferuje dwa g贸wne typy WebView:

- **WebViewClient** jest idealny do podstawowego HTML, ale nie obsuguje funkcji alert JavaScript, co wpywa na testowanie atak贸w XSS.
- **WebChromeClient** dziaa bardziej jak pene dowiadczenie przegldarki Chrome.

Kluczowym punktem jest to, 偶e przegldarki WebView **nie dziel si plikami cookie** z g贸wn przegldark urzdzenia.

Do adowania treci dostpne s metody takie jak ````loadUrl````, ````loadData````, i ````loadDataWithBaseURL````. Wa偶ne jest, aby upewni si, 偶e te adresy URL lub pliki s **bezpieczne do u偶ycia**. Ustawienia zwizane z bezpieczestwem mo偶na zarzdza za pomoc klasy ````WebSettings````. Na przykad, wyczenie JavaScript za pomoc ````setJavaScriptEnabled(false)```` mo偶e zapobiec atakom XSS.

JavaScript "Bridge" umo偶liwia interakcj obiekt贸w Java z JavaScript, wymagajc, aby metody byy oznaczone jako ````@JavascriptInterface```` dla bezpieczestwa od wersji Android 4.2 wzwy偶.

Zezwalanie na dostp do treci (````setAllowContentAccess(true)````) pozwala WebView na dostp do dostawc贸w treci, co mo偶e stanowi ryzyko, chyba 偶e adresy URL treci s zweryfikowane jako bezpieczne.

Aby kontrolowa dostp do plik贸w:
- Wyczenie dostpu do plik贸w (````setAllowFileAccess(false)````) ogranicza dostp do systemu plik贸w, z wyjtkami dla okrelonych zasob贸w, zapewniajc, 偶e s one u偶ywane tylko do treci niewra偶liwych.

## Inne skadniki aplikacji i zarzdzanie urzdzeniami mobilnymi

### **Cyfrowe podpisywanie aplikacji**

- **Cyfrowe podpisywanie** jest niezbdne dla aplikacji Android, zapewniajc, 偶e s **autentycznie autoryzowane** przed instalacj. Proces ten wykorzystuje certyfikat do identyfikacji aplikacji i musi zosta zweryfikowany przez mened偶era pakiet贸w urzdzenia podczas instalacji. Aplikacje mog by **podpisane przez siebie same lub certyfikowane przez zewntrznego CA**, chronic przed nieautoryzowanym dostpem i zapewniajc, 偶e aplikacja pozostaje nietknita podczas dostarczania na urzdzenie.

### **Weryfikacja aplikacji dla zwikszonego bezpieczestwa**

- Poczwszy od **Androida 4.2**, funkcja o nazwie **Weryfikuj aplikacje** pozwala u偶ytkownikom sprawdzi bezpieczestwo aplikacji przed ich instalacj. Ten **proces weryfikacji** mo偶e ostrzega u偶ytkownik贸w przed potencjalnie szkodliwymi aplikacjami lub nawet uniemo偶liwia instalacj szczeg贸lnie zoliwych, zwikszajc bezpieczestwo u偶ytkownika.

### **Zarzdzanie urzdzeniami mobilnymi (MDM)**

- **Rozwizania MDM** zapewniaj **nadz贸r i bezpieczestwo** dla urzdze mobilnych za pomoc **interfejsu API administracji urzdzeniem**. Wymagaj one instalacji aplikacji Android do skutecznego zarzdzania i zabezpieczania urzdze mobilnych. Kluczowe funkcje obejmuj **narzucanie polityk dotyczcych hase**, **wymuszanie szyfrowania pamici** i **zezwolenie na zdalne kasowanie danych**, zapewniajc kompleksow kontrol i bezpieczestwo urzdze mobilnych.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Znajd藕 najwa偶niejsze podatnoci, aby m贸c je szybko naprawi. Intruder ledzi powierzchni ataku, wykonuje proaktywne skanowanie zagro偶e, znajduje problemy w caym stosie technologicznym, od interfejs贸w API po aplikacje internetowe i systemy chmurowe. [**Wypr贸buj go za darmo**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) ju偶 dzi.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytori贸w GitHub.**

</details>
