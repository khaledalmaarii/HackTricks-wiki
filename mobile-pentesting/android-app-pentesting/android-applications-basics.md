# Fundamentos de Aplica√ß√µes Android

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-nos no** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

## Modelo de Seguran√ßa Android

**Existem duas camadas:**

* O **SO**, que mant√©m as aplica√ß√µes instaladas isoladas umas das outras.
* A **aplica√ß√£o em si**, que permite que os desenvolvedores **exponham certas funcionalidades** e configurem as capacidades da aplica√ß√£o.

### Separa√ß√£o de UID

**Cada aplica√ß√£o √© atribu√≠da a um ID de Usu√°rio espec√≠fico**. Isso √© feito durante a instala√ß√£o do app para que **o app s√≥ possa interagir com arquivos pertencentes ao seu ID de Usu√°rio ou arquivos compartilhados**. Portanto, apenas o pr√≥prio app, certos componentes do SO e o usu√°rio root podem acessar os dados do app.

### Compartilhamento de UID

**Duas aplica√ß√µes podem ser configuradas para usar o mesmo UID**. Isso pode ser √∫til para compartilhar informa√ß√µes, mas se uma delas for comprometida, os dados de ambas as aplica√ß√µes ser√£o comprometidos. √â por isso que esse comportamento √© **desencorajado**.\
**Para compartilhar o mesmo UID, as aplica√ß√µes devem definir o mesmo valor `android:sharedUserId` em seus manifests.**

### Sandbox

O **Sandbox de Aplica√ß√µes Android** permite executar **cada aplica√ß√£o** como um **processo separado sob um ID de usu√°rio separado**. Cada processo tem sua pr√≥pria m√°quina virtual, ent√£o o c√≥digo de um app √© executado em isolamento de outros apps.\
A partir do Android 5.0(L), o **SELinux** √© aplicado. Basicamente, o SELinux negou todas as intera√ß√µes de processos e, em seguida, criou pol√≠ticas para **permitir apenas as intera√ß√µes esperadas entre eles**.

### Permiss√µes

Quando voc√™ instala um **app e ele pede permiss√µes**, o app est√° solicitando as permiss√µes configuradas nos elementos **`uses-permission`** no arquivo **AndroidManifest.xml**. O elemento **uses-permission** indica o nome da permiss√£o solicitada dentro do **atributo name**. Ele tamb√©m possui o atributo **maxSdkVersion** que para de solicitar permiss√µes em vers√µes superiores √† especificada.\
Note que as aplica√ß√µes android n√£o precisam pedir todas as permiss√µes no in√≠cio, elas tamb√©m podem **pedir permiss√µes dinamicamente**, mas todas as permiss√µes devem ser **declaradas** no **manifesto**.

Quando um app exp√µe funcionalidade, ele pode limitar o **acesso apenas a apps que tenham uma permiss√£o espec√≠fica**.\
Um elemento de permiss√£o tem tr√™s atributos:

* O **nome** da permiss√£o
* O atributo **permission-group**, que permite agrupar permiss√µes relacionadas.
* O **n√≠vel de prote√ß√£o** que indica como as permiss√µes s√£o concedidas. Existem quatro tipos:
* **Normal**: Usado quando n√£o h√° **amea√ßas conhecidas** ao app. O usu√°rio **n√£o √© obrigado a aprov√°-lo**.
* **Dangerous**: Indica que a permiss√£o concede √† aplica√ß√£o solicitante algum **acesso elevado**. **Os usu√°rios s√£o solicitados a aprov√°-las**.
* **Signature**: Apenas **apps assinados pelo mesmo certificado que o que** exporta o componente podem receber permiss√£o. Este √© o tipo mais forte de prote√ß√£o.
* **SignatureOrSystem**: Apenas **apps assinados pelo mesmo certificado que o que** exporta o componente ou **apps executando com acesso a n√≠vel de sistema** podem receber permiss√µes.

## Aplica√ß√µes Pr√©-Instaladas

Esses apps geralmente s√£o encontrados nos diret√≥rios **`/system/app`** ou **`/system/priv-app`** e alguns deles s√£o **otimizados** (voc√™ pode nem encontrar o arquivo `classes.dex`). Essas aplica√ß√µes valem a pena serem verificadas porque √†s vezes est√£o **executando com muitas permiss√µes** (como root).

* As que v√™m com o **AOSP** (Android OpenSource Project) **ROM**
* Adicionadas pelo **fabricante** do dispositivo
* Adicionadas pelo **provedor de telefonia** (se compradas deles)

## Rooting

Para obter acesso root em um dispositivo android f√≠sico, voc√™ geralmente precisa **explorar** 1 ou 2 **vulnerabilidades** que costumam ser **espec√≠ficas** para o **dispositivo** e **vers√£o**.\
Uma vez que a explora√ß√£o tenha funcionado, geralmente o bin√°rio Linux `su` √© copiado para um local especificado na vari√°vel de ambiente PATH do usu√°rio, como `/system/xbin`.

Uma vez que o bin√°rio su est√° configurado, outro app Android √© usado para interagir com o bin√°rio `su` e **processar solicita√ß√µes de acesso root** como **Superuser** e **SuperSU** (dispon√≠vel na Google Play store).

{% hint style="danger" %}
Note que o processo de rooting √© muito perigoso e pode danificar severamente o dispositivo.
{% endhint %}

### ROMs

√â poss√≠vel **substituir o SO instalando um firmware personalizado**. Fazendo isso, √© poss√≠vel estender a utilidade de um dispositivo antigo, contornar restri√ß√µes de software ou ganhar acesso ao c√≥digo Android mais recente.\
**OmniROM** e **LineageOS** s√£o dois dos firmwares mais populares para usar.

Note que **nem sempre √© necess√°rio fazer root no dispositivo** para instalar um firmware personalizado. **Alguns fabricantes permitem** o desbloqueio de seus bootloaders de maneira bem documentada e segura.

### Implica√ß√µes

Uma vez que um dispositivo √© rootado, qualquer app pode solicitar acesso como root. Se um aplicativo malicioso obtiver isso, ele ter√° acesso a quase tudo e poder√° danificar o telefone.

## Fundamentos de Aplica√ß√µes Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- O formato das aplica√ß√µes Android √© referido como _formato de arquivo APK_. √â essencialmente um **arquivo ZIP** (renomeando a extens√£o do arquivo para .zip, o conte√∫do pode ser extra√≠do e visualizado).
- Conte√∫dos do APK (N√£o exaustivo)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: cont√©m recursos pr√©-compilados, como XML bin√°rio.
- res/xml/files\_paths.xml
- META-INF/
- √â aqui que o Certificado est√° localizado!
- **classes.dex**
- Cont√©m bytecode Dalvik, representando o c√≥digo Java (ou Kotlin) compilado que a aplica√ß√£o executa por padr√£o.
- lib/
- Abriga bibliotecas nativas, segregadas por arquitetura de CPU em subdiret√≥rios.
- `armeabi`: c√≥digo para processadores baseados em ARM
- `armeabi-v7a`: c√≥digo para processadores ARMv7 e superiores
- `x86`: c√≥digo para processadores X86
- `mips`: c√≥digo apenas para processadores MIPS
- assets/
- Armazena arquivos diversos necess√°rios pelo app, potencialmente incluindo bibliotecas nativas adicionais ou arquivos DEX, √†s vezes usados por autores de malware para ocultar c√≥digo adicional.
- res/
- Cont√©m recursos que n√£o s√£o compilados em resources.arsc

### **Dalvik & Smali**

No desenvolvimento Android, **Java ou Kotlin** √© usado para criar apps. Em vez de usar a JVM como em apps de desktop, o Android compila esse c√≥digo em **bytecode Execut√°vel Dalvik (DEX)**. Anteriormente, a m√°quina virtual Dalvik lidava com esse bytecode, mas agora, o Android Runtime (ART) assume em vers√µes mais novas do Android.

Para engenharia reversa, **Smali** se torna crucial. √â a vers√£o leg√≠vel por humanos do bytecode DEX, atuando como uma linguagem de montagem ao traduzir c√≥digo-fonte em instru√ß√µes de bytecode. Smali e baksmali referem-se √†s ferramentas de montagem e desmontagem nesse contexto.

## Intents

Intents s√£o o principal meio pelo qual os apps Android se comunicam entre seus componentes ou com outros apps. Esses objetos de mensagem tamb√©m podem transportar dados entre apps ou componentes, semelhante a como as requisi√ß√µes GET/POST s√£o usadas em comunica√ß√µes HTTP.

Assim, um Intent √© basicamente uma **mensagem que √© passada entre componentes**. Intents **podem ser direcionados** a componentes ou apps espec√≠ficos, **ou podem ser enviados sem um destinat√°rio espec√≠fico**.\
Para ser simples, o Intent pode ser usado:

* Para iniciar uma Activity, tipicamente abrindo uma interface de usu√°rio para um app
* Como transmiss√µes para informar o sistema e apps sobre mudan√ßas
* Para iniciar, parar e comunicar-se com um servi√ßo em segundo plano
* Para acessar dados via ContentProviders
* Como callbacks para lidar com eventos

Se vulner√°veis, **Intents podem ser usados para realizar uma variedade de ataques**.

### Filtro de Intent

**Filtros de Intent** definem **como uma atividade, servi√ßo ou Broadcast Receiver pode interagir com diferentes tipos de Intents**. Essencialmente, eles descrevem as capacidades desses componentes, como quais a√ß√µes podem realizar ou os tipos de transmiss√µes que podem processar. O principal lugar para declarar esses filtros √© dentro do **arquivo AndroidManifest.xml**, embora para Broadcast Receivers, codific√°-los tamb√©m seja uma op√ß√£o.

Filtros de Intent s√£o compostos por categorias, a√ß√µes e filtros de dados, com a possibilidade de incluir metadados adicionais. Essa configura√ß√£o permite que componentes lidem com Intents espec√≠ficos que correspondem aos crit√©rios declarados.

Um aspecto cr√≠tico dos componentes Android (atividades/servi√ßos/provedores de conte√∫do/receptores de transmiss√£o) √© sua visibilidade ou **status p√∫blico**. Um componente √© considerado p√∫blico e pode interagir com outros apps se for **`exported`** com um valor de **`true`** ou se um Filtro de Intent for declarado para ele no manifesto. No entanto, h√° uma maneira para os desenvolvedores manterem esses componentes privados, garantindo que n√£o interajam com outros apps involuntariamente. Isso √© alcan√ßado definindo o atributo **`exported`** como **`false`** em suas defini√ß√µes de manifesto.

Al√©m disso, os desenvolvedores t√™m a op√ß√£o de proteger ainda mais o acesso a esses componentes exigindo permiss√µes espec√≠ficas. O atributo **`permission`** pode ser definido para impor que apenas apps com a permiss√£o designada possam acessar o componente, adicionando uma camada extra de seguran√ßa e controle sobre quem pode interagir com ele.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Inten√ß√µes Impl√≠citas

Inten√ß√µes s√£o criadas programaticamente usando um construtor de Inten√ß√£o:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
A **A√ß√£o** da inten√ß√£o declarada anteriormente √© **ACTION\_SEND** e o **Extra** √© um mailto **Uri** (o Extra √© a informa√ß√£o adicional que a inten√ß√£o est√° esperando).

Esta inten√ß√£o deve ser declarada dentro do manifesto como no seguinte exemplo:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Um intent-filter precisa corresponder √† **a√ß√£o**, **dados** e **categoria** para receber uma mensagem.

O processo de "resolu√ß√£o de Intent" determina qual aplicativo deve receber cada mensagem. Este processo considera o **atributo de prioridade**, que pode ser definido na **declara√ß√£o do intent-filter**, e **aquele com a prioridade mais alta ser√° selecionado**. Essa prioridade pode ser definida entre -1000 e 1000 e os aplicativos podem usar o valor `SYSTEM_HIGH_PRIORITY`. Se um **conflito** surgir, uma janela "chooser" aparece para que o **usu√°rio possa decidir**.

### Intents Expl√≠citos

Um intent expl√≠cito especifica o nome da classe que est√° direcionando:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Em outros aplicativos, para acessar a inten√ß√£o previamente declarada, voc√™ pode usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Esses permitem que outros aplicativos **realizem a√ß√µes em nome do seu aplicativo**, usando a identidade e permiss√µes do seu app. Ao construir um Pending Intent, deve-se **especificar um intent e a a√ß√£o a ser realizada**. Se o **intent declarado n√£o for Expl√≠cito** (n√£o declarar qual intent pode cham√°-lo), um **aplicativo malicioso poderia realizar a a√ß√£o declarada** em nome do aplicativo v√≠tima. Al√©m disso, **se uma a√ß√£o n√£o for especificada**, o aplicativo malicioso poder√° fazer **qualquer a√ß√£o em nome da v√≠tima**.

### Broadcast Intents

Ao contr√°rio dos intents anteriores, que s√£o recebidos apenas por um app, os broadcast intents **podem ser recebidos por m√∫ltiplos apps**. No entanto, a partir da vers√£o da API 14, √© **poss√≠vel especificar o app que deve receber** a mensagem usando Intent.setPackage.

Alternativamente, tamb√©m √© poss√≠vel **especificar uma permiss√£o ao enviar o broadcast**. O app receptor precisar√° ter essa permiss√£o.

Existem **dois tipos** de Broadcasts: **Normal** (ass√≠ncrono) e **Ordenado** (s√≠ncrono). A **ordem** √© baseada na **prioridade configurada dentro do elemento receptor**. **Cada app pode processar, retransmitir ou descartar o Broadcast.**

√â poss√≠vel **enviar** um **broadcast** usando a fun√ß√£o `sendBroadcast(intent, receiverPermission)` da classe `Context`.\
Voc√™ tamb√©m pode usar a fun√ß√£o **`sendBroadcast`** do **`LocalBroadCastManager`** que garante que a **mensagem nunca saia do app**. Usando isso, voc√™ n√£o precisar√° nem exportar um componente receptor.

### Sticky Broadcasts

Esse tipo de Broadcasts **pode ser acessado muito tempo depois de serem enviados**.\
Esses foram descontinuados no n√≠vel da API 21 e √© recomendado **n√£o us√°-los**.\
**Eles permitem que qualquer aplicativo capture os dados, mas tamb√©m os modifique.**

Se voc√™ encontrar fun√ß√µes contendo a palavra "sticky" como **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **verifique o impacto e tente remov√™-las**.

## Deep links / URL schemes

Em aplicativos Android, **deep links** s√£o usados para iniciar uma a√ß√£o (Intent) diretamente atrav√©s de uma URL. Isso √© feito declarando um **URL scheme** espec√≠fico dentro de uma atividade. Quando um dispositivo Android tenta **acessar uma URL com esse esquema**, a atividade especificada dentro do aplicativo √© iniciada.

O esquema deve ser declarado no arquivo **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
O esquema do exemplo anterior √© `exampleapp://` (note tamb√©m a **`categoria BROWSABLE`**)

Ent√£o, no campo de dados, voc√™ pode especificar o **host** e **path**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Para acess√°-lo pela web, √© poss√≠vel definir um link como:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Para encontrar o **c√≥digo que ser√° executado no App**, v√° para a atividade chamada pelo deeplink e procure a fun√ß√£o **`onNewIntent`**.

Aprenda a [chamar deep links sem usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Linguagem de Defini√ß√£o de Interface Android

A **Linguagem de Defini√ß√£o de Interface Android (AIDL)** √© projetada para facilitar a comunica√ß√£o entre cliente e servi√ßo em aplicativos Android por meio de **comunica√ß√£o entre processos** (IPC). Como o acesso √† mem√≥ria de outro processo diretamente n√£o √© permitido no Android, o AIDL simplifica o processo ao marshalling de objetos em um formato compreendido pelo sistema operacional, facilitando assim a comunica√ß√£o entre diferentes processos.

### Conceitos Chave

- **Servi√ßos Vinculados**: Esses servi√ßos utilizam AIDL para IPC, permitindo que atividades ou componentes se vinculem a um servi√ßo, fa√ßam solicita√ß√µes e recebam respostas. O m√©todo `onBind` na classe do servi√ßo √© cr√≠tico para iniciar a intera√ß√£o, marcando-o como uma √°rea vital para revis√£o de seguran√ßa em busca de vulnerabilidades.

- **Messenger**: Operando como um servi√ßo vinculado, o Messenger facilita a IPC com foco no processamento de dados atrav√©s do m√©todo `onBind`. √â essencial inspecionar este m√©todo de perto para qualquer manipula√ß√£o de dados insegura ou execu√ß√£o de fun√ß√µes sens√≠veis.

- **Binder**: Embora o uso direto da classe Binder seja menos comum devido √† abstra√ß√£o do AIDL, √© ben√©fico entender que o Binder atua como um driver de n√≠vel de kernel facilitando a transfer√™ncia de dados entre os espa√ßos de mem√≥ria de diferentes processos. Para uma compreens√£o mais aprofundada, um recurso est√° dispon√≠vel em [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Componentes

Estes incluem: **Atividades, Servi√ßos, Receptores de Broadcast e Provedores.**

### Atividade de Lan√ßamento e outras atividades

Em aplicativos Android, **atividades** s√£o como telas, mostrando diferentes partes da interface do usu√°rio do aplicativo. Um aplicativo pode ter muitas atividades, cada uma apresentando uma tela √∫nica para o usu√°rio.

A **atividade de lan√ßamento** √© o principal portal para um aplicativo, lan√ßada quando voc√™ toca no √≠cone do aplicativo. Ela √© definida no arquivo de manifesto do aplicativo com intents espec√≠ficas MAIN e LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nem todos os aplicativos precisam de uma atividade de inicializa√ß√£o, especialmente aqueles sem uma interface de usu√°rio, como servi√ßos em segundo plano.

As atividades podem ser disponibilizadas para outros aplicativos ou processos marcando-as como "exported" no manifesto. Essa configura√ß√£o permite que outros aplicativos iniciem essa atividade:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
No entanto, acessar uma atividade de outro aplicativo nem sempre √© um risco de seguran√ßa. A preocupa√ß√£o surge se dados sens√≠veis estiverem sendo compartilhados de forma inadequada, o que pode levar a vazamentos de informa√ß√µes.

O ciclo de vida de uma atividade **come√ßa com o m√©todo onCreate**, configurando a interface do usu√°rio e preparando a atividade para intera√ß√£o com o usu√°rio.

### Subclasse de Aplicativo

No desenvolvimento Android, um aplicativo tem a op√ß√£o de criar uma **subclasse** da classe [Application](https://developer.android.com/reference/android/app/Application), embora n√£o seja obrigat√≥rio. Quando tal subclasse √© definida, ela se torna a primeira classe a ser instanciada dentro do aplicativo. O m√©todo **`attachBaseContext`**, se implementado nesta subclasse, √© executado antes do m√©todo **`onCreate`**. Essa configura√ß√£o permite uma inicializa√ß√£o antecipada antes que o restante da aplica√ß√£o comece.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Services

[Services](https://developer.android.com/guide/components/services) s√£o **operativos em segundo plano** capazes de executar tarefas sem uma interface de usu√°rio. Essas tarefas podem continuar em execu√ß√£o mesmo quando os usu√°rios mudam para diferentes aplicativos, tornando os servi√ßos cruciais para **opera√ß√µes de longa dura√ß√£o**.

Os servi√ßos s√£o vers√°teis; podem ser iniciados de v√°rias maneiras, sendo **Intents** o m√©todo principal para lan√ß√°-los como ponto de entrada de um aplicativo. Uma vez que um servi√ßo √© iniciado usando o m√©todo `startService`, seu m√©todo `onStart` entra em a√ß√£o e continua em execu√ß√£o at√© que o m√©todo `stopService` seja chamado explicitamente. Alternativamente, se o papel de um servi√ßo depender de uma conex√£o de cliente ativa, o m√©todo `bindService` √© usado para vincular o cliente ao servi√ßo, ativando o m√©todo `onBind` para a passagem de dados.

Uma aplica√ß√£o interessante de servi√ßos inclui a reprodu√ß√£o de m√∫sica em segundo plano ou a busca de dados de rede sem prejudicar a intera√ß√£o do usu√°rio com um aplicativo. Al√©m disso, os servi√ßos podem ser tornados acess√≠veis a outros processos no mesmo dispositivo atrav√©s da **exporta√ß√£o**. Este n√£o √© o comportamento padr√£o e requer configura√ß√£o expl√≠cita no arquivo Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** atuam como ouvintes em um sistema de mensagens, permitindo que m√∫ltiplos aplicativos respondam √†s mesmas mensagens do sistema. Um aplicativo pode **registrar um receptor** de **duas maneiras principais**: atrav√©s do **Manifest** do aplicativo ou **dinamicamente** dentro do c√≥digo do aplicativo via a API **`registerReceiver`**. No Manifest, as transmiss√µes s√£o filtradas com permiss√µes, enquanto os receptores registrados dinamicamente tamb√©m podem especificar permiss√µes no momento do registro.

**Filtros de Intent** s√£o cruciais em ambos os m√©todos de registro, determinando quais transmiss√µes acionam o receptor. Uma vez que uma transmiss√£o correspondente √© enviada, o m√©todo **`onReceive`** do receptor √© invocado, permitindo que o aplicativo reaja de acordo, como ajustando o comportamento em resposta a um alerta de bateria baixa.

As transmiss√µes podem ser **ass√≠ncronas**, alcan√ßando todos os receptores sem ordem, ou **s√≠ncronas**, onde os receptores recebem a transmiss√£o com base em prioridades definidas. No entanto, √© importante notar o potencial risco de seguran√ßa, j√° que qualquer aplicativo pode priorizar a si mesmo para interceptar uma transmiss√£o.

Para entender a funcionalidade de um receptor, procure o m√©todo **`onReceive`** dentro de sua classe. O c√≥digo desse m√©todo pode manipular o Intent recebido, destacando a necessidade de valida√ß√£o de dados pelos receptores, especialmente em **Ordered Broadcasts**, que podem modificar ou descartar o Intent.

### Content Provider

**Content Providers** s√£o essenciais para **compartilhar dados estruturados** entre aplicativos, enfatizando a import√¢ncia de implementar **permiss√µes** para garantir a seguran√ßa dos dados. Eles permitem que aplicativos acessem dados de v√°rias fontes, incluindo bancos de dados, sistemas de arquivos ou a web. Permiss√µes espec√≠ficas, como **`readPermission`** e **`writePermission`**, s√£o cruciais para controlar o acesso. Al√©m disso, o acesso tempor√°rio pode ser concedido atrav√©s das configura√ß√µes **`grantUriPermission`** no manifest do aplicativo, aproveitando atributos como `path`, `pathPrefix` e `pathPattern` para controle de acesso detalhado.

A valida√ß√£o de entrada √© fundamental para prevenir vulnerabilidades, como inje√ß√£o de SQL. Content Providers suportam opera√ß√µes b√°sicas: `insert()`, `update()`, `delete()` e `query()`, facilitando a manipula√ß√£o e compartilhamento de dados entre aplicativos.

**FileProvider**, um Content Provider especializado, foca em compartilhar arquivos de forma segura. Ele √© definido no manifest do aplicativo com atributos espec√≠ficos para controlar o acesso a pastas, denotados por `android:exported` e `android:resource` apontando para configura√ß√µes de pastas. Cuidado √© aconselhado ao compartilhar diret√≥rios para evitar expor dados sens√≠veis inadvertidamente.

Exemplo de declara√ß√£o de manifest para FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
E um exemplo de especifica√ß√£o de pastas compartilhadas em `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Para mais informa√ß√µes, consulte:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews s√£o como **mini navegadores web** dentro de aplicativos Android, puxando conte√∫do da web ou de arquivos locais. Eles enfrentam riscos semelhantes aos navegadores regulares, mas existem maneiras de **reduzir esses riscos** por meio de **configura√ß√µes** espec√≠ficas.

O Android oferece dois tipos principais de WebView:

- **WebViewClient** √© √≥timo para HTML b√°sico, mas n√£o suporta a fun√ß√£o de alerta JavaScript, afetando como os ataques XSS podem ser testados.
- **WebChromeClient** atua mais como a experi√™ncia completa do navegador Chrome.

Um ponto chave √© que os navegadores WebView **n√£o compartilham cookies** com o navegador principal do dispositivo.

Para carregar conte√∫do, m√©todos como ````loadUrl````, ````loadData````, e ````loadDataWithBaseURL```` est√£o dispon√≠veis. √â crucial garantir que essas URLs ou arquivos sejam **seguros para uso**. As configura√ß√µes de seguran√ßa podem ser gerenciadas atrav√©s da classe ````WebSettings````. Por exemplo, desabilitar JavaScript com ````setJavaScriptEnabled(false)```` pode prevenir ataques XSS.

O "Bridge" JavaScript permite que objetos Java interajam com JavaScript, exigindo que os m√©todos sejam marcados com ````@JavascriptInterface```` para seguran√ßa a partir do Android 4.2.

Permitir acesso ao conte√∫do (````setAllowContentAccess(true)````) permite que WebViews acessem Content Providers, o que pode ser um risco, a menos que as URLs de conte√∫do sejam verificadas como seguras.

Para controlar o acesso a arquivos:
- Desabilitar o acesso a arquivos (````setAllowFileAccess(false)````) limita o acesso ao sistema de arquivos, com exce√ß√µes para certos ativos, garantindo que sejam usados apenas para conte√∫do n√£o sens√≠vel.

## Outros Componentes de Aplicativos e Gerenciamento de Dispositivos M√≥veis

### **Assinatura Digital de Aplicativos**

- **A assinatura digital** √© obrigat√≥ria para aplicativos Android, garantindo que sejam **autenticamente criados** antes da instala√ß√£o. Este processo utiliza um certificado para identifica√ß√£o do aplicativo e deve ser verificado pelo gerenciador de pacotes do dispositivo durante a instala√ß√£o. Os aplicativos podem ser **autoassinados ou certificados por uma CA externa**, protegendo contra acesso n√£o autorizado e garantindo que o aplicativo permane√ßa inalterado durante sua entrega ao dispositivo.

### **Verifica√ß√£o de Aplicativos para Seguran√ßa Aprimorada**

- A partir do **Android 4.2**, um recurso chamado **Verificar Aplicativos** permite que os usu√°rios verifiquem a seguran√ßa dos aplicativos antes da instala√ß√£o. Este **processo de verifica√ß√£o** pode alertar os usu√°rios sobre aplicativos potencialmente prejudiciais ou at√© mesmo impedir a instala√ß√£o de aplicativos particularmente maliciosos, aprimorando a seguran√ßa do usu√°rio.

### **Gerenciamento de Dispositivos M√≥veis (MDM)**

- **Solu√ß√µes MDM** fornecem **supervis√£o e seguran√ßa** para dispositivos m√≥veis atrav√©s da **API de Administra√ß√£o de Dispositivos**. Elas necessitam da instala√ß√£o de um aplicativo Android para gerenciar e proteger dispositivos m√≥veis de forma eficaz. As fun√ß√µes principais incluem **imposi√ß√£o de pol√≠ticas de senha**, **exig√™ncia de criptografia de armazenamento**, e **permiss√£o para limpeza remota de dados**, garantindo controle e seguran√ßa abrangentes sobre dispositivos m√≥veis.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporte o HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
