# Bases des applications Android

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos GitHub.

</details>
{% endhint %}

## Mod√®le de s√©curit√© Android

**Il y a deux couches :**

* Le **syst√®me d'exploitation**, qui maintient les applications install√©es isol√©es les unes des autres.
* L'**application elle-m√™me**, qui permet aux d√©veloppeurs de **d√©voiler certaines fonctionnalit√©s** et configure les capacit√©s de l'application.

### S√©paration UID

**Chaque application se voit attribuer un identifiant utilisateur sp√©cifique**. Cela se fait lors de l'installation de l'application afin que **l'application ne puisse interagir qu'avec les fichiers appartenant √† son identifiant utilisateur ou les fichiers partag√©s**. Par cons√©quent, seule l'application elle-m√™me, certains composants du syst√®me d'exploitation et l'utilisateur root peuvent acc√©der aux donn√©es de l'application.

### Partage UID

**Deux applications peuvent √™tre configur√©es pour utiliser le m√™me UID**. Cela peut √™tre utile pour partager des informations, mais si l'une d'elles est compromise, les donn√©es des deux applications seront compromises. C'est pourquoi ce comportement est **d√©conseill√©**.\
**Pour partager le m√™me UID, les applications doivent d√©finir la m√™me valeur `android:sharedUserId` dans leurs manifestes.**

### Sandboxing

Le **sandboxing des applications Android** permet d'ex√©cuter **chaque application** comme un **processus s√©par√© sous un identifiant utilisateur distinct**. Chaque processus a sa propre machine virtuelle, donc le code d'une application s'ex√©cute en isolation des autres applications.\
Depuis Android 5.0(L), **SELinux** est appliqu√©. En gros, SELinux a refus√© toutes les interactions entre processus et a ensuite cr√©√© des politiques pour **permettre uniquement les interactions attendues entre eux**.

### Permissions

Lorsque vous installez une **application et qu'elle demande des permissions**, l'application demande les permissions configur√©es dans les √©l√©ments **`uses-permission`** du fichier **AndroidManifest.xml**. L'√©l√©ment **uses-permission** indique le nom de la permission demand√©e dans l'**attribut name**. Il a √©galement l'attribut **maxSdkVersion** qui arr√™te la demande de permissions sur les versions sup√©rieures √† celle sp√©cifi√©e.\
Notez que les applications Android n'ont pas besoin de demander toutes les permissions au d√©but, elles peuvent √©galement **demander des permissions dynamiquement**, mais toutes les permissions doivent √™tre **d√©clar√©es** dans le **manifest**.

Lorsqu'une application expose une fonctionnalit√©, elle peut limiter **l'acc√®s uniquement aux applications ayant une permission sp√©cifi√©e**.\
Un √©l√©ment de permission a trois attributs :

* Le **nom** de la permission
* L'attribut **permission-group**, qui permet de regrouper des permissions connexes.
* Le **niveau de protection** qui indique comment les permissions sont accord√©es. Il existe quatre types :
* **Normal** : Utilis√© lorsqu'il n'y a **aucune menace connue** pour l'application. L'utilisateur **n'est pas tenu de l'approuver**.
* **Dangerous** : Indique que la permission accorde √† l'application demandeuse un **acc√®s √©lev√©**. **Les utilisateurs sont invit√©s √† les approuver**.
* **Signature** : Seules les **applications sign√©es par le m√™me certificat que celui** exportant le composant peuvent se voir accorder la permission. C'est le type de protection le plus fort.
* **SignatureOrSystem** : Seules les **applications sign√©es par le m√™me certificat que celui** exportant le composant ou **les applications fonctionnant avec un acc√®s au niveau syst√®me** peuvent se voir accorder des permissions.

## Applications pr√©install√©es

Ces applications se trouvent g√©n√©ralement dans les r√©pertoires **`/system/app`** ou **`/system/priv-app`** et certaines d'entre elles sont **optimis√©es** (vous ne trouverez peut-√™tre m√™me pas le fichier `classes.dex`). Ces applications valent la peine d'√™tre v√©rifi√©es car parfois elles **fonctionnent avec trop de permissions** (en tant que root).

* Celles fournies avec le **ROM AOSP** (Android OpenSource Project)
* Ajout√©es par le **fabricant de l'appareil**
* Ajout√©es par le **fournisseur de t√©l√©phonie mobile** (si achet√©es chez eux)

## Rooting

Pour obtenir un acc√®s root sur un appareil Android physique, vous devez g√©n√©ralement **exploiter** 1 ou 2 **vuln√©rabilit√©s** qui sont souvent **sp√©cifiques** √† l'**appareil** et √† la **version**.\
Une fois l'exploitation r√©ussie, le binaire Linux `su` est g√©n√©ralement copi√© dans un emplacement sp√©cifi√© dans la variable d'environnement PATH de l'utilisateur comme `/system/xbin`.

Une fois le binaire su configur√©, une autre application Android est utilis√©e pour interagir avec le binaire `su` et **traiter les demandes d'acc√®s root** comme **Superuser** et **SuperSU** (disponible sur le Google Play Store).

{% hint style="danger" %}
Notez que le processus de rooting est tr√®s dangereux et peut endommager gravement l'appareil.
{% endhint %}

### ROMs

Il est possible de **remplacer le syst√®me d'exploitation en installant un firmware personnalis√©**. Ce faisant, il est possible d'√©tendre l'utilit√© d'un ancien appareil, de contourner les restrictions logicielles ou d'acc√©der au dernier code Android.\
**OmniROM** et **LineageOS** sont deux des firmwares les plus populaires √† utiliser.

Notez que **ce n'est pas toujours n√©cessaire de rooter l'appareil** pour installer un firmware personnalis√©. **Certains fabricants permettent** le d√©verrouillage de leurs bootloaders de mani√®re bien document√©e et s√©curis√©e.

### Implications

Une fois un appareil root√©, n'importe quelle application pourrait demander un acc√®s en tant que root. Si une application malveillante obtient cet acc√®s, elle pourra acc√©der √† presque tout et pourra endommager le t√©l√©phone.

## Fondamentaux des applications Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Le format des applications Android est appel√© _format de fichier APK_. C'est essentiellement un **fichier ZIP** (en renommant l'extension de fichier en .zip, le contenu peut √™tre extrait et visualis√©).
- Contenu de l'APK (non exhaustif)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc : contient des ressources pr√©compil√©es, comme du XML binaire.
- res/xml/files\_paths.xml
- META-INF/
- C'est ici que se trouve le certificat !
- **classes.dex**
- Contient du bytecode Dalvik, repr√©sentant le code Java (ou Kotlin) compil√© que l'application ex√©cute par d√©faut.
- lib/
- Contient des biblioth√®ques natives, s√©par√©es par architecture CPU dans des sous-r√©pertoires.
- `armeabi` : code pour processeurs bas√©s sur ARM
- `armeabi-v7a` : code pour processeurs ARMv7 et sup√©rieurs
- `x86` : code pour processeurs X86
- `mips` : code uniquement pour processeurs MIPS
- assets/
- Stocke des fichiers divers n√©cessaires √† l'application, pouvant inclure des biblioth√®ques natives suppl√©mentaires ou des fichiers DEX, parfois utilis√©s par des auteurs de logiciels malveillants pour dissimuler du code suppl√©mentaire.
- res/
- Contient des ressources qui ne sont pas compil√©es dans resources.arsc

### **Dalvik & Smali**

Dans le d√©veloppement Android, **Java ou Kotlin** est utilis√© pour cr√©er des applications. Au lieu d'utiliser la JVM comme dans les applications de bureau, Android compile ce code en **bytecode Dalvik (DEX)**. Auparavant, la machine virtuelle Dalvik g√©rait ce bytecode, mais maintenant, l'Android Runtime (ART) prend le relais dans les versions Android plus r√©centes.

Pour l'ing√©nierie inverse, **Smali** devient crucial. C'est la version lisible par l'homme du bytecode DEX, agissant comme un langage d'assemblage en traduisant le code source en instructions de bytecode. Smali et baksmali font r√©f√©rence aux outils d'assemblage et de d√©sassemblage dans ce contexte.

## Intents

Les intents sont le principal moyen par lequel les applications Android communiquent entre leurs composants ou avec d'autres applications. Ces objets de message peuvent √©galement transporter des donn√©es entre des applications ou des composants, similaire √† la fa√ßon dont les requ√™tes GET/POST sont utilis√©es dans les communications HTTP.

Ainsi, un Intent est essentiellement un **message qui est pass√© entre des composants**. Les Intents **peuvent √™tre dirig√©s** vers des composants ou des applications sp√©cifiques, **ou peuvent √™tre envoy√©s sans destinataire sp√©cifique**.\
Pour simplifier, un Intent peut √™tre utilis√© :

* Pour d√©marrer une activit√©, ouvrant g√©n√©ralement une interface utilisateur pour une application
* Comme des diffusions pour informer le syst√®me et les applications des changements
* Pour d√©marrer, arr√™ter et communiquer avec un service en arri√®re-plan
* Pour acc√©der aux donn√©es via des ContentProviders
* Comme des rappels pour g√©rer des √©v√©nements

S'ils sont vuln√©rables, **les Intents peuvent √™tre utilis√©s pour effectuer une vari√©t√© d'attaques**.

### Intent-Filter

**Les filtres d'intent** d√©finissent **comment une activit√©, un service ou un r√©cepteur de diffusion peut interagir avec diff√©rents types d'intents**. Essentiellement, ils d√©crivent les capacit√©s de ces composants, telles que les actions qu'ils peuvent effectuer ou les types de diffusions qu'ils peuvent traiter. L'endroit principal pour d√©clarer ces filtres est dans le **fichier AndroidManifest.xml**, bien que pour les r√©cepteurs de diffusion, les coder soit √©galement une option.

Les filtres d'intent sont compos√©s de cat√©gories, d'actions et de filtres de donn√©es, avec la possibilit√© d'inclure des m√©tadonn√©es suppl√©mentaires. Cette configuration permet aux composants de g√©rer des Intents sp√©cifiques qui correspondent aux crit√®res d√©clar√©s.

Un aspect critique des composants Android (activit√©s/services/content providers/r√©cepteurs de diffusion) est leur visibilit√© ou **statut public**. Un composant est consid√©r√© comme public et peut interagir avec d'autres applications s'il est **`exported`** avec une valeur de **`true`** ou si un filtre d'intent est d√©clar√© pour lui dans le manifest. Cependant, il existe un moyen pour les d√©veloppeurs de garder explicitement ces composants priv√©s, garantissant qu'ils n'interagissent pas avec d'autres applications de mani√®re non intentionnelle. Cela se fait en d√©finissant l'attribut **`exported`** sur **`false`** dans leurs d√©finitions de manifest.

De plus, les d√©veloppeurs ont la possibilit√© de s√©curiser davantage l'acc√®s √† ces composants en exigeant des permissions sp√©cifiques. L'attribut **`permission`** peut √™tre d√©fini pour imposer que seules les applications ayant la permission d√©sign√©e puissent acc√©der au composant, ajoutant une couche suppl√©mentaire de s√©curit√© et de contr√¥le sur qui peut interagir avec lui.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Intents implicites

Les intents sont cr√©√©s programatiquement en utilisant un constructeur Intent :
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
L'**Action** de l'intention pr√©c√©demment d√©clar√©e est **ACTION\_SEND** et l'**Extra** est un mailto **Uri** (l'Extra est l'information suppl√©mentaire que l'intention attend).

Cette intention doit √™tre d√©clar√©e dans le manifeste comme dans l'exemple suivant :
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter doit correspondre √† l'**action**, **donn√©es** et **cat√©gorie** pour recevoir un message.

Le processus de "r√©solution d'intent" d√©termine quelle application doit recevoir chaque message. Ce processus prend en compte l'**attribut de priorit√©**, qui peut √™tre d√©fini dans la **d√©claration d'intent-filter**, et **celui avec la priorit√© la plus √©lev√©e sera s√©lectionn√©**. Cette priorit√© peut √™tre d√©finie entre -1000 et 1000 et les applications peuvent utiliser la valeur `SYSTEM_HIGH_PRIORITY`. Si un **conflit** survient, une fen√™tre "choisir" appara√Æt afin que **l'utilisateur puisse d√©cider**.

### Intents explicites

Un intent explicite sp√©cifie le nom de la classe qu'il cible :
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Dans d'autres applications, afin d'acc√©der √† l'intention pr√©c√©demment d√©clar√©e, vous pouvez utiliser :
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Ces derniers permettent √† d'autres applications de **prendre des actions au nom de votre application**, en utilisant l'identit√© et les autorisations de votre application. Pour construire un Pending Intent, il faut **sp√©cifier un intent et l'action √† effectuer**. Si l'**intent d√©clar√© n'est pas explicite** (ne d√©clare pas quel intent peut l'appeler), une **application malveillante pourrait effectuer l'action d√©clar√©e** au nom de l'application victime. De plus, **si une action n'est pas sp√©cifi√©e**, l'application malveillante pourra effectuer **n'importe quelle action au nom de la victime**.

### Broadcast Intents

Contrairement aux intents pr√©c√©dents, qui ne sont re√ßus que par une seule application, les intents de diffusion **peuvent √™tre re√ßus par plusieurs applications**. Cependant, √† partir de la version API 14, il est **possible de sp√©cifier l'application qui doit recevoir** le message en utilisant Intent.setPackage.

Il est √©galement possible de **sp√©cifier une autorisation lors de l'envoi de la diffusion**. L'application r√©ceptrice devra avoir cette autorisation.

Il existe **deux types** de diffusions : **Normale** (asynchrone) et **Ordonn√©e** (synchronis√©e). L'**ordre** est bas√© sur la **priorit√© configur√©e dans l'√©l√©ment r√©cepteur**. **Chaque application peut traiter, relayer ou ignorer la diffusion.**

Il est possible de **envoyer** une **diffusion** en utilisant la fonction `sendBroadcast(intent, receiverPermission)` de la classe `Context`.\
Vous pouvez √©galement utiliser la fonction **`sendBroadcast`** de **`LocalBroadCastManager`** qui garantit que le **message ne quitte jamais l'application**. Avec cela, vous n'aurez m√™me pas besoin d'exporter un composant r√©cepteur.

### Sticky Broadcasts

Ce type de diffusions **peut √™tre accessible longtemps apr√®s leur envoi**.\
Celles-ci ont √©t√© d√©pr√©ci√©es au niveau API 21 et il est recommand√© de **ne pas les utiliser**.\
**Elles permettent √† n'importe quelle application de renifler les donn√©es, mais aussi de les modifier.**

Si vous trouvez des fonctions contenant le mot "sticky" comme **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **v√©rifiez l'impact et essayez de les supprimer**.

## Deep links / URL schemes

Dans les applications Android, les **deep links** sont utilis√©s pour initier une action (Intent) directement via une URL. Cela se fait en d√©clarant un **sch√©ma d'URL** sp√©cifique dans une activit√©. Lorsqu'un appareil Android essaie d'**acc√©der √† une URL avec ce sch√©ma**, l'activit√© sp√©cifi√©e dans l'application est lanc√©e.

Le sch√©ma doit √™tre d√©clar√© dans le fichier **`AndroidManifest.xml`** :
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Le sch√©ma de l'exemple pr√©c√©dent est `exampleapp://` (notez √©galement le **`category BROWSABLE`**)

Ensuite, dans le champ de donn√©es, vous pouvez sp√©cifier le **host** et le **path** :
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Pour y acc√©der depuis le web, il est possible de d√©finir un lien comme :
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Pour trouver le **code qui sera ex√©cut√© dans l'App**, allez √† l'activit√© appel√©e par le deeplink et recherchez la fonction **`onNewIntent`**.

Apprenez √† [appeler des deep links sans utiliser de pages HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Le **Android Interface Definition Language (AIDL)** est con√ßu pour faciliter la communication entre le client et le service dans les applications Android via **interprocess communication** (IPC). √âtant donn√© qu'il n'est pas permis d'acc√©der directement √† la m√©moire d'un autre processus sur Android, AIDL simplifie le processus en marshalling des objets dans un format compris par le syst√®me d'exploitation, facilitant ainsi la communication entre diff√©rents processus.

### Concepts Cl√©s

- **Services Li√©s** : Ces services utilisent AIDL pour IPC, permettant aux activit√©s ou composants de se lier √† un service, de faire des demandes et de recevoir des r√©ponses. La m√©thode `onBind` dans la classe du service est essentielle pour initier l'interaction, marquant ainsi un domaine vital pour l'examen de la s√©curit√© √† la recherche de vuln√©rabilit√©s.

- **Messenger** : Fonctionnant comme un service li√©, Messenger facilite l'IPC en se concentrant sur le traitement des donn√©es via la m√©thode `onBind`. Il est essentiel d'examiner cette m√©thode de pr√®s pour toute manipulation de donn√©es non s√©curis√©e ou ex√©cution de fonctions sensibles.

- **Binder** : Bien que l'utilisation directe de la classe Binder soit moins courante en raison de l'abstraction d'AIDL, il est utile de comprendre que Binder agit comme un pilote au niveau du noyau facilitant le transfert de donn√©es entre les espaces m√©moire de diff√©rents processus. Pour une compr√©hension plus approfondie, une ressource est disponible √† [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Composants

Cela inclut : **Activit√©s, Services, R√©cepteurs de Diffusion et Fournisseurs.**

### Activit√© de Lancement et autres activit√©s

Dans les applications Android, les **activit√©s** sont comme des √©crans, montrant diff√©rentes parties de l'interface utilisateur de l'application. Une application peut avoir de nombreuses activit√©s, chacune pr√©sentant un √©cran unique √† l'utilisateur.

L'**activit√© de lancement** est la principale porte d'entr√©e d'une application, lanc√©e lorsque vous appuyez sur l'ic√¥ne de l'application. Elle est d√©finie dans le fichier manifeste de l'application avec des intents sp√©cifiques MAIN et LAUNCHER :
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Toutes les applications n'ont pas besoin d'une activit√© de lancement, en particulier celles sans interface utilisateur, comme les services en arri√®re-plan.

Les activit√©s peuvent √™tre rendues disponibles √† d'autres applications ou processus en les marquant comme "export√©es" dans le manifeste. Ce param√®tre permet √† d'autres applications de d√©marrer cette activit√© :
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Cependant, acc√©der √† une activit√© d'une autre application n'est pas toujours un risque de s√©curit√©. Le probl√®me survient si des donn√©es sensibles sont partag√©es de mani√®re inappropri√©e, ce qui pourrait entra√Æner des fuites d'informations.

Le cycle de vie d'une activit√© **commence avec la m√©thode onCreate**, configurant l'interface utilisateur et pr√©parant l'activit√© pour l'interaction avec l'utilisateur.

### Sous-classe d'application

Dans le d√©veloppement Android, une application a la possibilit√© de cr√©er une **sous-classe** de la classe [Application](https://developer.android.com/reference/android/app/Application), bien que ce ne soit pas obligatoire. Lorsqu'une telle sous-classe est d√©finie, elle devient la premi√®re classe √† √™tre instanci√©e dans l'application. La m√©thode **`attachBaseContext`**, si elle est impl√©ment√©e dans cette sous-classe, est ex√©cut√©e avant la m√©thode **`onCreate`**. Cette configuration permet une initialisation pr√©coce avant que le reste de l'application ne d√©marre.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Services

[Services](https://developer.android.com/guide/components/services) sont des **op√©rateurs en arri√®re-plan** capables d'ex√©cuter des t√¢ches sans interface utilisateur. Ces t√¢ches peuvent continuer √† s'ex√©cuter m√™me lorsque les utilisateurs passent √† d'autres applications, ce qui rend les services cruciaux pour des **op√©rations de longue dur√©e**.

Les services sont polyvalents ; ils peuvent √™tre initi√©s de diff√©rentes mani√®res, les **Intents** √©tant la m√©thode principale pour les lancer en tant que point d'entr√©e d'une application. Une fois qu'un service est d√©marr√© en utilisant la m√©thode `startService`, sa m√©thode `onStart` entre en action et continue de s'ex√©cuter jusqu'√† ce que la m√©thode `stopService` soit explicitement appel√©e. Alternativement, si le r√¥le d'un service d√©pend d'une connexion client active, la m√©thode `bindService` est utilis√©e pour lier le client au service, engageant la m√©thode `onBind` pour le passage de donn√©es.

Une application int√©ressante des services inclut la lecture de musique en arri√®re-plan ou la r√©cup√©ration de donn√©es r√©seau sans entraver l'interaction de l'utilisateur avec une application. De plus, les services peuvent √™tre rendus accessibles √† d'autres processus sur le m√™me appareil par le biais de **l'exportation**. Ce n'est pas le comportement par d√©faut et n√©cessite une configuration explicite dans le fichier Android Manifest :
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Les r√©cepteurs de diffusion** agissent comme des √©couteurs dans un syst√®me de messagerie, permettant √† plusieurs applications de r√©pondre aux m√™mes messages du syst√®me. Une application peut **enregistrer un r√©cepteur** de **deux mani√®res principales** : via le **Manifest** de l'application ou **dynamiquement** dans le code de l'application via l'API **`registerReceiver`**. Dans le Manifest, les diffusions sont filtr√©es avec des permissions, tandis que les r√©cepteurs enregistr√©s dynamiquement peuvent √©galement sp√©cifier des permissions lors de l'enregistrement.

Les **filtres d'intention** sont cruciaux dans les deux m√©thodes d'enregistrement, d√©terminant quelles diffusions d√©clenchent le r√©cepteur. Une fois qu'une diffusion correspondante est envoy√©e, la m√©thode **`onReceive`** du r√©cepteur est invoqu√©e, permettant √† l'application de r√©agir en cons√©quence, comme ajuster le comportement en r√©ponse √† une alerte de batterie faible.

Les diffusions peuvent √™tre **asynchrones**, atteignant tous les r√©cepteurs sans ordre, ou **synchrones**, o√π les r√©cepteurs re√ßoivent la diffusion en fonction des priorit√©s d√©finies. Cependant, il est important de noter le risque de s√©curit√© potentiel, car toute application peut se prioriser pour intercepter une diffusion.

Pour comprendre la fonctionnalit√© d'un r√©cepteur, recherchez la m√©thode **`onReceive`** dans sa classe. Le code de cette m√©thode peut manipuler l'Intent re√ßu, soulignant la n√©cessit√© de validation des donn√©es par les r√©cepteurs, en particulier dans les **Diffusions Ordonn√©es**, qui peuvent modifier ou supprimer l'Intent.

### Content Provider

**Les Fournisseurs de Contenu** sont essentiels pour **partager des donn√©es structur√©es** entre les applications, soulignant l'importance de la mise en ≈ìuvre de **permissions** pour garantir la s√©curit√© des donn√©es. Ils permettent aux applications d'acc√©der √† des donn√©es provenant de diverses sources, y compris des bases de donn√©es, des syst√®mes de fichiers ou le web. Des permissions sp√©cifiques, comme **`readPermission`** et **`writePermission`**, sont cruciales pour contr√¥ler l'acc√®s. De plus, un acc√®s temporaire peut √™tre accord√© via les param√®tres **`grantUriPermission`** dans le manifest de l'application, en utilisant des attributs tels que `path`, `pathPrefix` et `pathPattern` pour un contr√¥le d'acc√®s d√©taill√©.

La validation des entr√©es est primordiale pour pr√©venir les vuln√©rabilit√©s, telles que l'injection SQL. Les Fournisseurs de Contenu prennent en charge les op√©rations de base : `insert()`, `update()`, `delete()`, et `query()`, facilitant la manipulation et le partage de donn√©es entre les applications.

**FileProvider**, un Fournisseur de Contenu sp√©cialis√©, se concentre sur le partage s√©curis√© de fichiers. Il est d√©fini dans le manifest de l'application avec des attributs sp√©cifiques pour contr√¥ler l'acc√®s aux dossiers, d√©sign√©s par `android:exported` et `android:resource` pointant vers les configurations de dossier. Une prudence est conseill√©e lors du partage de r√©pertoires pour √©viter d'exposer involontairement des donn√©es sensibles.

Exemple de d√©claration de manifest pour FileProvider :
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Et un exemple de sp√©cification des dossiers partag√©s dans `filepaths.xml` :
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Pour plus d'informations, consultez :
- [Android Developers : Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers : FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

Les WebViews sont comme des **mini navigateurs web** √† l'int√©rieur des applications Android, tirant du contenu soit du web, soit de fichiers locaux. Ils font face √† des risques similaires √† ceux des navigateurs r√©guliers, mais il existe des moyens de **r√©duire ces risques** gr√¢ce √† des **param√®tres** sp√©cifiques.

Android propose deux types principaux de WebView :

- **WebViewClient** est excellent pour le HTML de base mais ne prend pas en charge la fonction d'alerte JavaScript, ce qui affecte la mani√®re dont les attaques XSS peuvent √™tre test√©es.
- **WebChromeClient** agit davantage comme l'exp√©rience compl√®te du navigateur Chrome.

Un point cl√© est que les navigateurs WebView ne **partagent pas les cookies** avec le navigateur principal de l'appareil.

Pour charger du contenu, des m√©thodes telles que ````loadUrl````, ````loadData````, et ````loadDataWithBaseURL```` sont disponibles. Il est crucial de s'assurer que ces URL ou fichiers sont **s√ªrs √† utiliser**. Les param√®tres de s√©curit√© peuvent √™tre g√©r√©s via la classe ````WebSettings````. Par exemple, d√©sactiver JavaScript avec ````setJavaScriptEnabled(false)```` peut pr√©venir les attaques XSS.

Le "Bridge" JavaScript permet aux objets Java d'interagir avec JavaScript, n√©cessitant que les m√©thodes soient marqu√©es avec ````@JavascriptInterface```` pour la s√©curit√© √† partir d'Android 4.2.

Autoriser l'acc√®s au contenu (````setAllowContentAccess(true)````) permet aux WebViews d'acc√©der aux Content Providers, ce qui pourrait √™tre un risque √† moins que les URL de contenu ne soient v√©rifi√©es comme s√©curis√©es.

Pour contr√¥ler l'acc√®s aux fichiers :
- D√©sactiver l'acc√®s aux fichiers (````setAllowFileAccess(false)````) limite l'acc√®s au syst√®me de fichiers, avec des exceptions pour certains actifs, garantissant qu'ils ne sont utilis√©s que pour du contenu non sensible.

## Autres composants d'application et gestion des appareils mobiles

### **Signature num√©rique des applications**

- La **signature num√©rique** est indispensable pour les applications Android, garantissant qu'elles sont **authentiquement cr√©√©es** avant l'installation. Ce processus utilise un certificat pour l'identification de l'application et doit √™tre v√©rifi√© par le gestionnaire de paquets de l'appareil lors de l'installation. Les applications peuvent √™tre **auto-sign√©es ou certifi√©es par une CA externe**, prot√©geant contre l'acc√®s non autoris√© et garantissant que l'application reste intacte lors de sa livraison √† l'appareil.

### **V√©rification des applications pour une s√©curit√© renforc√©e**

- √Ä partir d'**Android 4.2**, une fonctionnalit√© appel√©e **V√©rifier les applications** permet aux utilisateurs de faire v√©rifier les applications pour leur s√©curit√© avant l'installation. Ce **processus de v√©rification** peut avertir les utilisateurs contre des applications potentiellement nuisibles, ou m√™me emp√™cher l'installation de celles particuli√®rement malveillantes, renfor√ßant la s√©curit√© des utilisateurs.

### **Gestion des appareils mobiles (MDM)**

- Les **solutions MDM** fournissent une **surveillance et une s√©curit√©** pour les appareils mobiles via l'**API d'administration des appareils**. Elles n√©cessitent l'installation d'une application Android pour g√©rer et s√©curiser efficacement les appareils mobiles. Les fonctions cl√©s incluent **l'application de politiques de mot de passe**, **l'obligation de chiffrement de stockage**, et **la possibilit√© d'effacer des donn√©es √† distance**, garantissant un contr√¥le et une s√©curit√© complets sur les appareils mobiles.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team AWS (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Formation Expert Red Team GCP (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
