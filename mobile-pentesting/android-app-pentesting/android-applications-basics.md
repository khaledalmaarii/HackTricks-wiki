# Android UygulamalarÄ± Temelleri

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **Bize katÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **Twitter'da** **bizi takip edin** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}

## Android GÃ¼venlik Modeli

**Ä°ki katman vardÄ±r:**

* **OS**, kurulu uygulamalarÄ± birbirinden izole tutar.
* **uygulamanÄ±n kendisi**, geliÅŸtiricilerin **belirli iÅŸlevleri aÃ§Ä±ÄŸa Ã§Ä±karmasÄ±na** ve uygulama yeteneklerini yapÄ±landÄ±rmasÄ±na olanak tanÄ±r.

### UID AyrÄ±mÄ±

**Her uygulamaya belirli bir KullanÄ±cÄ± KimliÄŸi atanÄ±r**. Bu, uygulamanÄ±n yÃ¼klenmesi sÄ±rasÄ±nda yapÄ±lÄ±r, bÃ¶ylece **uygulama yalnÄ±zca kendi KullanÄ±cÄ± KimliÄŸine ait dosyalarla veya paylaÅŸÄ±lan** dosyalarla etkileÅŸimde bulunabilir. Bu nedenle, yalnÄ±zca uygulamanÄ±n kendisi, OS'nin belirli bileÅŸenleri ve root kullanÄ±cÄ±sÄ± uygulama verilerine eriÅŸebilir.

### UID PaylaÅŸÄ±mÄ±

**Ä°ki uygulama aynÄ± UID'yi kullanacak ÅŸekilde yapÄ±landÄ±rÄ±labilir**. Bu, bilgi paylaÅŸmak iÃ§in yararlÄ± olabilir, ancak bunlardan biri tehlikeye girerse, her iki uygulamanÄ±n verileri de tehlikeye girecektir. Bu nedenle bu davranÄ±ÅŸ **tavsiye edilmez**.\
**AynÄ± UID'yi paylaÅŸmak iÃ§in, uygulamalar manifestolarÄ±nda aynÄ± `android:sharedUserId` deÄŸerini tanÄ±mlamalÄ±dÄ±r.**

### Sandbox

**Android Uygulama Sandbox'Ä±**, **her uygulamanÄ±n** **ayrÄ± bir kullanÄ±cÄ± kimliÄŸi altÄ±nda ayrÄ± bir iÅŸlem olarak Ã§alÄ±ÅŸmasÄ±na** olanak tanÄ±r. Her iÅŸlem kendi sanal makinesine sahiptir, bu nedenle bir uygulamanÄ±n kodu diÄŸer uygulamalardan izole bir ÅŸekilde Ã§alÄ±ÅŸÄ±r.\
Android 5.0(L) itibarÄ±yla **SELinux** uygulanmaktadÄ±r. Temelde, SELinux tÃ¼m iÅŸlem etkileÅŸimlerini reddetti ve ardÄ±ndan **aralarÄ±ndaki beklenen etkileÅŸimleri yalnÄ±zca izin vermek iÃ§in politikalar oluÅŸturdu**.

### Ä°zinler

Bir **uygulama yÃ¼klediÄŸinizde ve izinler istediÄŸinde**, uygulama **AndroidManifest.xml** dosyasÄ±ndaki **`uses-permission`** Ã¶ÄŸelerinde yapÄ±landÄ±rÄ±lan izinleri istemektedir. **uses-permission** Ã¶ÄŸesi, istenen iznin adÄ±nÄ± **name** **Ã¶zniteliÄŸi iÃ§inde belirtir.** AyrÄ±ca, belirtilen sÃ¼rÃ¼mden daha yÃ¼ksek sÃ¼rÃ¼mlerde izin istemeyi durduran **maxSdkVersion** Ã¶zniteliÄŸine de sahiptir.\
Android uygulamalarÄ±nÄ±n baÅŸlangÄ±Ã§ta tÃ¼m izinleri istemesi gerekmediÄŸini, dinamik olarak da **izin isteyebileceÄŸini** unutmayÄ±n, ancak tÃ¼m izinler **manifestoda** **belirtilmelidir.**

Bir uygulama iÅŸlevsellik aÃ§Ä±ÄŸa Ã§Ä±kardÄ±ÄŸÄ±nda, **yalnÄ±zca belirli bir izne sahip uygulamalara eriÅŸimi sÄ±nÄ±rlayabilir**.\
Bir izin Ã¶ÄŸesinin Ã¼Ã§ Ã¶zniteliÄŸi vardÄ±r:

* Ä°znin **adÄ±**
* Ä°zin grubu **Ã¶zniteliÄŸi**, ilgili izinleri gruplamak iÃ§in kullanÄ±lÄ±r.
* Ä°zinlerin nasÄ±l verildiÄŸini belirten **koruma seviyesi**. DÃ¶rt tÃ¼r vardÄ±r:
* **Normal**: Uygulama iÃ§in **bilinen tehditler yoksa** kullanÄ±lÄ±r. KullanÄ±cÄ±nÄ±n **onaylamasÄ± gerekmez**.
* **Tehlikeli**: Ä°znin, istek yapan uygulamaya bazÄ± **yÃ¼kseltilmiÅŸ eriÅŸim** saÄŸladÄ±ÄŸÄ±nÄ± belirtir. **KullanÄ±cÄ±lardan onay istenir**.
* **Ä°mza**: YalnÄ±zca **bileÅŸeni dÄ±ÅŸa aktaranla aynÄ± sertifika ile imzalanmÄ±ÅŸ uygulamalar** izin alabilir. Bu, en gÃ¼Ã§lÃ¼ koruma tÃ¼rÃ¼dÃ¼r.
* **Ä°mza veya Sistem**: YalnÄ±zca **bileÅŸeni dÄ±ÅŸa aktaranla aynÄ± sertifika ile imzalanmÄ±ÅŸ uygulamalar veya **sistem dÃ¼zeyinde eriÅŸimle Ã§alÄ±ÅŸan uygulamalar** izin alabilir.

## Ã–nceden YÃ¼klenmiÅŸ Uygulamalar

Bu uygulamalar genellikle **`/system/app`** veya **`/system/priv-app`** dizinlerinde bulunur ve bazÄ±larÄ± **optimize edilmiÅŸtir** (belki de `classes.dex` dosyasÄ±nÄ± bile bulamazsÄ±nÄ±z). Bu uygulamalar, bazen **Ã§ok fazla izinle Ã§alÄ±ÅŸtÄ±klarÄ±** iÃ§in kontrol edilmeye deÄŸerdir (root olarak).

* **AOSP** (Android AÃ§Ä±k Kaynak Projesi) **ROM** ile birlikte gelenler
* Cihaz **Ã¼reticisi** tarafÄ±ndan eklenenler
* HÃ¼cresel **telefon saÄŸlayÄ±cÄ±sÄ±** tarafÄ±ndan eklenenler (eÄŸer onlardan satÄ±n alÄ±ndÄ±ysa)

## Rootlama

Bir fiziksel android cihazda root eriÅŸimi elde etmek iÃ§in genellikle **1 veya 2 gÃ¼venlik aÃ§Ä±ÄŸÄ±nÄ±** **istismar etmeniz** gerekir; bu genellikle **cihaz** ve **sÃ¼rÃ¼m** iÃ§in **Ã¶zgÃ¼dÃ¼r**.\
Ä°stismar Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda, genellikle Linux `su` ikili dosyasÄ±, kullanÄ±cÄ±nÄ±n PATH ortam deÄŸiÅŸkeninde belirtilen bir konuma kopyalanÄ±r, Ã¶rneÄŸin `/system/xbin`.

Su ikili dosyasÄ± yapÄ±landÄ±rÄ±ldÄ±ktan sonra, `su` ikili dosyasÄ± ile etkileÅŸimde bulunmak ve **root eriÅŸim taleplerini iÅŸlemek iÃ§in** baÅŸka bir Android uygulamasÄ± kullanÄ±lÄ±r, Ã¶rneÄŸin **Superuser** ve **SuperSU** (Google Play maÄŸazasÄ±nda mevcuttur).

{% hint style="danger" %}
Rootlama iÅŸleminin Ã§ok tehlikeli olduÄŸunu ve cihazÄ± ciddi ÅŸekilde zarar verebileceÄŸini unutmayÄ±n.
{% endhint %}

### ROM'lar

**Ã–zel bir yazÄ±lÄ±m yÃ¼kleyerek iÅŸletim sistemini deÄŸiÅŸtirmek mÃ¼mkÃ¼ndÃ¼r**. Bunu yaparak, eski bir cihazÄ±n kullanÄ±mÄ±nÄ± uzatmak, yazÄ±lÄ±m kÄ±sÄ±tlamalarÄ±nÄ± aÅŸmak veya en son Android koduna eriÅŸmek mÃ¼mkÃ¼ndÃ¼r.\
**OmniROM** ve **LineageOS**, kullanÄ±lacak en popÃ¼ler yazÄ±lÄ±mlardan ikisidir.

**CihazÄ± rootlamanÄ±n her zaman gerekli olmadÄ±ÄŸÄ±nÄ±** unutmayÄ±n; **bazÄ± Ã¼reticiler**, bootloader'larÄ±nÄ±n iyi belgelenmiÅŸ ve gÃ¼venli bir ÅŸekilde kilidini aÃ§Ä±lmasÄ±na izin verir.

### SonuÃ§lar

Bir cihaz rootlandÄ±ÄŸÄ±nda, herhangi bir uygulama root olarak eriÅŸim talep edebilir. KÃ¶tÃ¼ niyetli bir uygulama bunu elde ederse, neredeyse her ÅŸeye eriÅŸimi olacak ve telefonu zarar verebilecektir.

## Android Uygulama Temelleri <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Android uygulamalarÄ±nÄ±n formatÄ± _APK dosya formatÄ±_ olarak adlandÄ±rÄ±lÄ±r. Temelde bir **ZIP dosyasÄ±dÄ±r** (dosya uzantÄ±sÄ±nÄ± .zip olarak deÄŸiÅŸtirerek, iÃ§erikler Ã§Ä±karÄ±labilir ve gÃ¶rÃ¼ntÃ¼lenebilir).
- APK Ä°Ã§erikleri (kapsamlÄ± deÄŸil)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: ikili XML gibi Ã¶nceden derlenmiÅŸ kaynaklarÄ± iÃ§erir.
- res/xml/files\_paths.xml
- META-INF/
- SertifikanÄ±n bulunduÄŸu yer burasÄ±dÄ±r!
- **classes.dex**
- UygulamanÄ±n varsayÄ±lan olarak Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ± derlenmiÅŸ Java (veya Kotlin) kodunu temsil eden Dalvik bytecode iÃ§erir.
- lib/
- CPU mimarisine gÃ¶re alt dizinlerde ayrÄ±lmÄ±ÅŸ yerel kÃ¼tÃ¼phaneleri barÄ±ndÄ±rÄ±r.
- `armeabi`: ARM tabanlÄ± iÅŸlemciler iÃ§in kod
- `armeabi-v7a`: ARMv7 ve daha yÃ¼ksek tabanlÄ± iÅŸlemciler iÃ§in kod
- `x86`: X86 iÅŸlemciler iÃ§in kod
- `mips`: yalnÄ±zca MIPS iÅŸlemcileri iÃ§in kod
- assets/
- UygulamanÄ±n ihtiyaÃ§ duyduÄŸu Ã§eÅŸitli dosyalarÄ± depolar, potansiyel olarak ek yerel kÃ¼tÃ¼phaneler veya DEX dosyalarÄ± iÃ§erebilir; bazen kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±m yazarlarÄ± tarafÄ±ndan ek kodu gizlemek iÃ§in kullanÄ±lÄ±r.
- res/
- resources.arsc iÃ§ine derlenmemiÅŸ kaynaklarÄ± iÃ§erir.

### **Dalvik & Smali**

Android geliÅŸtirmede, **Java veya Kotlin** uygulama oluÅŸturmak iÃ§in kullanÄ±lÄ±r. MasaÃ¼stÃ¼ uygulamalarÄ±ndaki gibi JVM kullanmak yerine, Android bu kodu **Dalvik Executable (DEX) bytecode**'a derler. Daha Ã¶nce, Dalvik sanal makinesi bu bytecode'u yÃ¶netiyordu, ancak ÅŸimdi, daha yeni Android sÃ¼rÃ¼mlerinde Android Runtime (ART) devralÄ±yor.

Tersine mÃ¼hendislik iÃ§in, **Smali** kritik hale gelir. DEX bytecode'un insan tarafÄ±ndan okunabilir versiyonudur ve kaynak kodunu bytecode talimatlarÄ±na Ã§evirerek montaj dili gibi Ã§alÄ±ÅŸÄ±r. Smali ve baksmali, bu baÄŸlamda montaj ve ayrÄ±ÅŸtÄ±rma araÃ§larÄ±nÄ± ifade eder.

## Niyetler

Niyetler, Android uygulamalarÄ±nÄ±n bileÅŸenleri arasÄ±nda veya diÄŸer uygulamalarla iletiÅŸim kurmanÄ±n birincil yoludur. Bu mesaj nesneleri, uygulamalar veya bileÅŸenler arasÄ±nda veri taÅŸÄ±yabilir; HTTP iletiÅŸimlerinde GET/POST isteklerinin nasÄ±l kullanÄ±ldÄ±ÄŸÄ±na benzer.

Yani bir Niyet, temelde **bileÅŸenler arasÄ±nda iletilen bir mesajdÄ±r**. Niyetler **belirli bileÅŸenlere veya uygulamalara yÃ¶nlendirilebilir** veya **belirli bir alÄ±cÄ± olmadan gÃ¶nderilebilir**.\
BasitÃ§e, Niyet ÅŸu amaÃ§larla kullanÄ±labilir:

* Bir Aktivite baÅŸlatmak, genellikle bir uygulama iÃ§in bir kullanÄ±cÄ± arayÃ¼zÃ¼ aÃ§mak
* Sistemi ve uygulamalarÄ± deÄŸiÅŸiklikler hakkÄ±nda bilgilendirmek iÃ§in yayÄ±nlar olarak
* Arka planda bir hizmeti baÅŸlatmak, durdurmak ve onunla iletiÅŸim kurmak
* ContentProviders aracÄ±lÄ±ÄŸÄ±yla verilere eriÅŸmek
* OlaylarÄ± iÅŸlemek iÃ§in geri Ã§aÄŸÄ±rmalar olarak

EÄŸer savunmasÄ±zsa, **Niyetler Ã§eÅŸitli saldÄ±rÄ±lar gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±labilir**.

### Niyet-Filtre

**Niyet Filtreleri**, **bir aktivite, hizmet veya YayÄ±n AlÄ±cÄ±sÄ±nÄ±n farklÄ± tÃ¼rdeki Niyetlerle nasÄ±l etkileÅŸimde bulunabileceÄŸini tanÄ±mlar**. Temelde, bu bileÅŸenlerin hangi eylemleri gerÃ§ekleÅŸtirebileceÄŸi veya hangi tÃ¼r yayÄ±nlarÄ± iÅŸleyebileceÄŸi gibi yeteneklerini tanÄ±mlar. Bu filtreleri beyan etmenin birincil yeri **AndroidManifest.xml dosyasÄ±dÄ±r**, ancak YayÄ±n AlÄ±cÄ±larÄ± iÃ§in kodlamak da bir seÃ§enektir.

Niyet Filtreleri, kategoriler, eylemler ve veri filtrelerinden oluÅŸur ve ek meta verilerin dahil edilmesi mÃ¼mkÃ¼ndÃ¼r. Bu yapÄ±, bileÅŸenlerin beyan edilen kriterlere uyan belirli Niyetleri iÅŸleyebilmesini saÄŸlar.

Android bileÅŸenlerinin (aktivite/hizmet/iÃ§erik saÄŸlayÄ±cÄ±larÄ±/yayÄ±n alÄ±cÄ±larÄ±) kritik bir yÃ¶nÃ¼, gÃ¶rÃ¼nÃ¼rlÃ¼kleri veya **kamusal durumlarÄ±dÄ±r**. Bir bileÅŸen, **`exported`** deÄŸeri **`true`** olarak ayarlandÄ±ÄŸÄ±nda kamuya aÃ§Ä±k kabul edilir ve diÄŸer uygulamalarla etkileÅŸimde bulunabilir. Ancak, geliÅŸtiricilerin bu bileÅŸenleri Ã¶zel tutmak iÃ§in aÃ§Ä±kÃ§a ayarlama imkanÄ± vardÄ±r; bu, **`exported`** Ã¶zniteliÄŸini **`false`** olarak ayarlayarak saÄŸlanÄ±r.

AyrÄ±ca, geliÅŸtiricilerin bu bileÅŸenlere eriÅŸimi daha da gÃ¼vence altÄ±na almak iÃ§in belirli izinler talep etme seÃ§eneÄŸi vardÄ±r. **`permission`** Ã¶zniteliÄŸi, yalnÄ±zca belirlenen izne sahip uygulamalarÄ±n bileÅŸene eriÅŸebilmesini saÄŸlamak iÃ§in ayarlanabilir ve bu, kimlerin etkileÅŸimde bulunabileceÄŸi Ã¼zerinde ek bir gÃ¼venlik ve kontrol katmanÄ± ekler.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Ä°kincil Niyetler

Niyetler, bir Niyet yapÄ±cÄ±sÄ± kullanÄ±larak programatik olarak oluÅŸturulur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
The **Action** of the previously declared intent is **ACTION\_SEND** and the **Extra** is a mailto **Uri** (the Extra if the extra information the intent is expecting).

Bu intent, aÅŸaÄŸÄ±daki Ã¶rnekte olduÄŸu gibi manifest iÃ§inde tanÄ±mlanmalÄ±dÄ±r:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Bir intent-filter'Ä±n bir mesajÄ± alabilmesi iÃ§in **action**, **data** ve **category** ile eÅŸleÅŸmesi gerekir.

"Intent Ã§Ã¶zÃ¼mleme" sÃ¼reci, her mesajÄ±n hangi uygulama tarafÄ±ndan alÄ±nacaÄŸÄ±nÄ± belirler. Bu sÃ¼reÃ§, i**ntent-filter bildirimi**nde ayarlanabilen **Ã¶ncelik niteliÄŸini** dikkate alÄ±r ve **daha yÃ¼ksek Ã¶nceliÄŸe sahip olan seÃ§ilecektir**. Bu Ã¶ncelik -1000 ile 1000 arasÄ±nda ayarlanabilir ve uygulamalar `SYSTEM_HIGH_PRIORITY` deÄŸerini kullanabilir. EÄŸer bir **Ã§atÄ±ÅŸma** ortaya Ã§Ä±karsa, **kullanÄ±cÄ±nÄ±n karar verebilmesi iÃ§in** bir "seÃ§ici" Penceresi gÃ¶rÃ¼nÃ¼r.

### AÃ§Ä±k Intents

AÃ§Ä±k bir intent, hedef aldÄ±ÄŸÄ± sÄ±nÄ±f adÄ±nÄ± belirtir:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
DiÄŸer uygulamalarda daha Ã¶nce tanÄ±mlanan intent'e eriÅŸmek iÃ§in ÅŸunu kullanabilirsiniz:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Bunlar diÄŸer uygulamalarÄ±n **uygulamanÄ±z adÄ±na eylemler gerÃ§ekleÅŸtirmesine** izin verir, uygulamanÄ±zÄ±n kimliÄŸini ve izinlerini kullanarak. Bir Pending Intent oluÅŸtururken **bir intent ve gerÃ§ekleÅŸtirilecek eylem belirtilmelidir**. EÄŸer **belirtilen intent AÃ§Ä±k deÄŸilse** (hangi intent'in bunu Ã§aÄŸÄ±rabileceÄŸini belirtmiyorsa) **kÃ¶tÃ¼ niyetli bir uygulama, belirtilen eylemi** maÄŸdur uygulama adÄ±na gerÃ§ekleÅŸtirebilir. DahasÄ±, **bir eylem belirtilmemiÅŸse**, kÃ¶tÃ¼ niyetli uygulama **maÄŸdur adÄ±na herhangi bir eylem gerÃ§ekleÅŸtirebilir**.

### Broadcast Intents

Ã–nceki intent'lerin aksine, yalnÄ±zca bir uygulama tarafÄ±ndan alÄ±nan, broadcast intent'ler **birden fazla uygulama tarafÄ±ndan alÄ±nabilir**. Ancak, API sÃ¼rÃ¼m 14'ten itibaren, mesajÄ± almasÄ± gereken uygulamayÄ± belirtmek **mÃ¼mkÃ¼ndÃ¼r** Intent.setPackage kullanarak.

Alternatif olarak, **yayÄ±n gÃ¶nderirken bir izin belirtmek de mÃ¼mkÃ¼ndÃ¼r**. AlÄ±cÄ± uygulamanÄ±n bu izne sahip olmasÄ± gerekecektir.

**Ä°ki tÃ¼r** YayÄ±n vardÄ±r: **Normal** (asenkron) ve **SÄ±ralÄ±** (senkron). **SÄ±ra**, **alÄ±cÄ±** Ã¶ÄŸesindeki **yapÄ±landÄ±rÄ±lmÄ±ÅŸ Ã¶nceliÄŸe** dayanÄ±r. **Her uygulama YayÄ±nÄ± iÅŸleyebilir, iletebilir veya dÃ¼ÅŸÃ¼rebilir.**

`Context` sÄ±nÄ±fÄ±ndan `sendBroadcast(intent, receiverPermission)` fonksiyonunu kullanarak **bir yayÄ±n gÃ¶ndermek** mÃ¼mkÃ¼ndÃ¼r.\
AyrÄ±ca, **`LocalBroadCastManager`**'dan **`sendBroadcast`** fonksiyonunu kullanarak **mesajÄ±n uygulamadan asla Ã§Ä±kmamasÄ±nÄ±** saÄŸlayabilirsiniz. Bunu kullanarak bir alÄ±cÄ± bileÅŸenini dÄ±ÅŸa aktarmanÄ±za gerek kalmaz.

### Sticky Broadcasts

Bu tÃ¼r YayÄ±nlar **gÃ¶nderildikten uzun sÃ¼re sonra eriÅŸilebilir**.\
Bunlar API seviyesi 21'de kullanÄ±mdan kaldÄ±rÄ±ldÄ± ve **kullanÄ±lmamalarÄ± Ã¶nerilir**.\
**Herhangi bir uygulamanÄ±n verileri dinlemesine, aynÄ± zamanda bunlarÄ± deÄŸiÅŸtirmesine izin verir.**

"sticky" kelimesini iÃ§eren fonksiyonlar bulursanÄ±z, Ã¶rneÄŸin **`sendStickyBroadcast`** veya **`sendStickyBroadcastAsUser`**, **etkisini kontrol edin ve kaldÄ±rmaya Ã§alÄ±ÅŸÄ±n**.

## Deep links / URL schemes

Android uygulamalarÄ±nda, **deep links** bir eylemi (Intent) doÄŸrudan bir URL aracÄ±lÄ±ÄŸÄ±yla baÅŸlatmak iÃ§in kullanÄ±lÄ±r. Bu, bir aktivite iÃ§inde belirli bir **URL ÅŸemasÄ±** tanÄ±mlanarak yapÄ±lÄ±r. Bir Android cihazÄ± bu ÅŸemaya sahip bir **URL'ye eriÅŸmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda**, uygulama iÃ§indeki belirtilen aktivite baÅŸlatÄ±lÄ±r.

Åema, **`AndroidManifest.xml`** dosyasÄ±nda belirtilmelidir:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Ã–nceki Ã¶rnekteki ÅŸema `exampleapp://` (aynÄ± zamanda **`category BROWSABLE`**'Ä± da not edin)

ArdÄ±ndan, veri alanÄ±nda **host** ve **path** belirtebilirsiniz:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web'den eriÅŸmek iÃ§in ÅŸu ÅŸekilde bir baÄŸlantÄ± ayarlamak mÃ¼mkÃ¼ndÃ¼r:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**Uygulamada Ã§alÄ±ÅŸtÄ±rÄ±lacak kodu bulmak iÃ§in**, deeplink ile Ã§aÄŸrÄ±lan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayÄ±n.

HTML sayfalarÄ± kullanmadan [derin baÄŸlantÄ±larÄ± nasÄ±l Ã§aÄŸÄ±racaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin](./#exploiting-schemes-deep-links).

## AIDL - Android ArayÃ¼z TanÄ±m Dili

**Android ArayÃ¼z TanÄ±m Dili (AIDL)**, Android uygulamalarÄ±nda **iÅŸlem arasÄ± iletiÅŸim** (IPC) yoluyla istemci ve hizmet arasÄ±ndaki iletiÅŸimi kolaylaÅŸtÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r. Android'de baÅŸka bir iÅŸlemin belleÄŸine doÄŸrudan eriÅŸim izni verilmediÄŸinden, AIDL, nesneleri iÅŸletim sistemi tarafÄ±ndan anlaÅŸÄ±lan bir formata marÅŸal ederek sÃ¼reci basitleÅŸtirir ve farklÄ± iÅŸlemler arasÄ±nda iletiÅŸimi kolaylaÅŸtÄ±rÄ±r.

### Temel Kavramlar

- **BaÄŸlÄ± Hizmetler**: Bu hizmetler, IPC iÃ§in AIDL kullanarak, aktivitelerin veya bileÅŸenlerin bir hizmete baÄŸlanmasÄ±nÄ±, isteklerde bulunmasÄ±nÄ± ve yanÄ±t almasÄ±nÄ± saÄŸlar. Hizmetin sÄ±nÄ±fÄ±ndaki `onBind` metodu, etkileÅŸimi baÅŸlatmak iÃ§in kritik Ã¶neme sahiptir ve gÃ¼venlik incelemesi iÃ§in zafiyet arayÄ±ÅŸÄ±nda Ã¶nemli bir alan olarak iÅŸaretlenmelidir.

- **Messenger**: BaÄŸlÄ± bir hizmet olarak Ã§alÄ±ÅŸan Messenger, `onBind` metodunu kullanarak veri iÅŸleme odaklÄ± IPC'yi kolaylaÅŸtÄ±rÄ±r. Bu metodun, gÃ¼vensiz veri iÅŸleme veya hassas fonksiyonlarÄ±n yÃ¼rÃ¼tÃ¼lmesi aÃ§Ä±sÄ±ndan dikkatlice incelenmesi Ã¶nemlidir.

- **Binder**: Binder sÄ±nÄ±fÄ±nÄ±n doÄŸrudan kullanÄ±mÄ±, AIDL'nin soyutlamasÄ± nedeniyle daha az yaygÄ±ndÄ±r, ancak Binder'Ä±n farklÄ± iÅŸlemlerin bellek alanlarÄ± arasÄ±nda veri transferini kolaylaÅŸtÄ±ran bir Ã§ekirdek dÃ¼zeyinde sÃ¼rÃ¼cÃ¼ olduÄŸunu anlamak faydalÄ±dÄ±r. Daha fazla bilgi iÃ§in [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) adresine baÅŸvurabilirsiniz.

## BileÅŸenler

Bunlar: **Aktiviteler, Hizmetler, YayÄ±n AlÄ±cÄ±larÄ± ve SaÄŸlayÄ±cÄ±lar.**

### BaÅŸlatÄ±cÄ± Aktivite ve diÄŸer aktiviteler

Android uygulamalarÄ±nda, **aktiviteler** ekranlar gibidir ve uygulamanÄ±n kullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼n farklÄ± bÃ¶lÃ¼mlerini gÃ¶sterir. Bir uygulama birÃ§ok aktiviteye sahip olabilir, her biri kullanÄ±cÄ±ya benzersiz bir ekran sunar.

**BaÅŸlatÄ±cÄ± aktivite**, bir uygulamanÄ±n ana kapÄ±sÄ±dÄ±r ve uygulamanÄ±n simgesine dokunduÄŸunuzda baÅŸlatÄ±lÄ±r. UygulamanÄ±n manifest dosyasÄ±nda belirli MAIN ve LAUNCHER intentleri ile tanÄ±mlanmÄ±ÅŸtÄ±r:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
TÃ¼m uygulamalarÄ±n bir baÅŸlatÄ±cÄ± aktiviteye ihtiyacÄ± yoktur, Ã¶zellikle kullanÄ±cÄ± arayÃ¼zÃ¼ olmayanlar, arka plan hizmetleri gibi.

Aktiviteler, manifestoda "exported" olarak iÅŸaretlenerek diÄŸer uygulamalara veya sÃ¼reÃ§lere sunulabilir. Bu ayar, diÄŸer uygulamalarÄ±n bu aktiviteyi baÅŸlatmasÄ±na izin verir:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ancak, baÅŸka bir uygulamadan bir aktiviteye eriÅŸmek her zaman bir gÃ¼venlik riski deÄŸildir. Hassas verilerin yanlÄ±ÅŸ bir ÅŸekilde paylaÅŸÄ±lmasÄ± durumunda endiÅŸe ortaya Ã§Ä±kar, bu da bilgi sÄ±zÄ±ntÄ±larÄ±na yol aÃ§abilir.

Bir aktivitenin yaÅŸam dÃ¶ngÃ¼sÃ¼ **onCreate yÃ¶ntemi ile baÅŸlar**, UI'yÄ± kurar ve aktiviteyi kullanÄ±cÄ± ile etkileÅŸim iÃ§in hazÄ±rlar.

### Uygulama Alt SÄ±nÄ±fÄ±

Android geliÅŸtirmede, bir uygulama **[Application](https://developer.android.com/reference/android/app/Application)** sÄ±nÄ±fÄ±nÄ±n bir alt sÄ±nÄ±fÄ±nÄ± oluÅŸturma seÃ§eneÄŸine sahiptir, ancak bu zorunlu deÄŸildir. BÃ¶yle bir alt sÄ±nÄ±f tanÄ±mlandÄ±ÄŸÄ±nda, uygulama iÃ§inde oluÅŸturulan ilk sÄ±nÄ±f olur. Bu alt sÄ±nÄ±fta uygulanmÄ±ÅŸsa, **`attachBaseContext`** yÃ¶ntemi **`onCreate`** yÃ¶nteminden Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu kurulum, uygulamanÄ±n geri kalan kÄ±smÄ± baÅŸlamadan Ã¶nce erken baÅŸlatma saÄŸlar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Services

[Services](https://developer.android.com/guide/components/services) **arka plan operatifleri** olarak, kullanÄ±cÄ± arayÃ¼zÃ¼ olmadan gÃ¶revleri yerine getirebilen yapÄ±lardÄ±r. Bu gÃ¶revler, kullanÄ±cÄ±lar farklÄ± uygulamalara geÃ§se bile Ã§alÄ±ÅŸmaya devam edebilir, bu da servisleri **uzun sÃ¼reli iÅŸlemler** iÃ§in kritik hale getirir.

Servisler Ã§ok yÃ¶nlÃ¼dÃ¼r; Ã§eÅŸitli ÅŸekillerde baÅŸlatÄ±labilirler, **Intents** bunlarÄ± bir uygulamanÄ±n giriÅŸ noktasÄ± olarak baÅŸlatmanÄ±n birincil yÃ¶ntemidir. Bir servis `startService` yÃ¶ntemi kullanÄ±larak baÅŸlatÄ±ldÄ±ÄŸÄ±nda, `onStart` yÃ¶ntemi devreye girer ve `stopService` yÃ¶ntemi aÃ§Ä±kÃ§a Ã§aÄŸrÄ±lana kadar Ã§alÄ±ÅŸmaya devam eder. Alternatif olarak, bir servisin rolÃ¼ aktif bir istemci baÄŸlantÄ±sÄ±na baÄŸlÄ±ysa, istemciyi servise baÄŸlamak iÃ§in `bindService` yÃ¶ntemi kullanÄ±lÄ±r ve veri geÃ§iÅŸi iÃ§in `onBind` yÃ¶ntemi devreye girer.

Servislerin ilginÃ§ bir uygulamasÄ±, arka planda mÃ¼zik Ã§alma veya kullanÄ±cÄ±larÄ±n bir uygulama ile etkileÅŸimini engellemeden aÄŸ verisi alma gibi iÅŸlemlerdir. AyrÄ±ca, servisler **dÄ±ÅŸa aktarma** yoluyla aynÄ± cihazdaki diÄŸer sÃ¼reÃ§lere eriÅŸilebilir hale getirilebilir. Bu varsayÄ±lan bir davranÄ±ÅŸ deÄŸildir ve Android Manifest dosyasÄ±nda aÃ§Ä±k bir yapÄ±landÄ±rma gerektirir:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** mesajlaÅŸma sisteminde dinleyici olarak iÅŸlev gÃ¶rÃ¼r ve birden fazla uygulamanÄ±n sistemden gelen aynÄ± mesajlara yanÄ±t vermesine olanak tanÄ±r. Bir uygulama **iki ana yolla** **bir alÄ±cÄ± kaydedebilir**: uygulamanÄ±n **Manifest** dosyasÄ± aracÄ±lÄ±ÄŸÄ±yla veya uygulamanÄ±n kodu iÃ§inde **dinamik olarak** **`registerReceiver`** API'si ile. Manifest'te, yayÄ±nlar izinlerle filtrelenirken, dinamik olarak kaydedilen alÄ±cÄ±lar kaydedilme sÄ±rasÄ±nda izinleri de belirtebilir.

**Intent filtreleri**, her iki kayÄ±t yÃ¶nteminde de kritik Ã¶neme sahiptir ve hangi yayÄ±nlarÄ±n alÄ±cÄ±yÄ± tetikleyeceÄŸini belirler. EÅŸleÅŸen bir yayÄ±n gÃ¶nderildiÄŸinde, alÄ±cÄ±nÄ±n **`onReceive`** metodu Ã§aÄŸrÄ±lÄ±r ve uygulamanÄ±n buna gÃ¶re tepki vermesini saÄŸlar; Ã¶rneÄŸin, dÃ¼ÅŸÃ¼k pil uyarÄ±sÄ±na yanÄ±t olarak davranÄ±ÅŸÄ±nÄ± ayarlamak gibi.

YayÄ±nlar **asenkron** olabilir, tÃ¼m alÄ±cÄ±lara sÄ±rasÄ±z ulaÅŸÄ±r veya **senkron** olabilir, burada alÄ±cÄ±lar belirlenen Ã¶nceliklere gÃ¶re yayÄ±nÄ± alÄ±r. Ancak, herhangi bir uygulamanÄ±n kendisini Ã¶nceliklendirebileceÄŸi ve bir yayÄ±nÄ± kesebileceÄŸi potansiyel gÃ¼venlik riskini not etmek Ã¶nemlidir.

Bir alÄ±cÄ±nÄ±n iÅŸlevselliÄŸini anlamak iÃ§in, sÄ±nÄ±fÄ± iÃ§inde **`onReceive`** metodunu arayÄ±n. Bu metodun kodu, alÄ±nan Intent'i manipÃ¼le edebilir ve alÄ±cÄ±larÄ±n veri doÄŸrulama ihtiyacÄ±nÄ± vurgular, Ã¶zellikle **SÄ±ralÄ± YayÄ±nlar**'da, bu Intent'i deÄŸiÅŸtirebilir veya atlayabilir.

### Content Provider

**Content Providers**, uygulamalar arasÄ±nda **yapÄ±landÄ±rÄ±lmÄ±ÅŸ verilerin paylaÅŸÄ±mÄ±** iÃ§in gereklidir ve veri gÃ¼venliÄŸini saÄŸlamak iÃ§in **izinlerin** uygulanmasÄ±nÄ±n Ã¶nemini vurgular. Uygulamalara veritabanlarÄ±, dosya sistemleri veya web gibi Ã§eÅŸitli kaynaklardan verilere eriÅŸim saÄŸlar. **`readPermission`** ve **`writePermission`** gibi belirli izinler, eriÅŸimi kontrol etmek iÃ§in kritik Ã¶neme sahiptir. AyrÄ±ca, uygulamanÄ±n manifestinde **`grantUriPermission`** ayarlarÄ± aracÄ±lÄ±ÄŸÄ±yla geÃ§ici eriÅŸim saÄŸlanabilir ve `path`, `pathPrefix` ve `pathPattern` gibi nitelikler kullanÄ±larak ayrÄ±ntÄ±lÄ± eriÅŸim kontrolÃ¼ yapÄ±labilir.

Girdi doÄŸrulamasÄ±, SQL enjeksiyonu gibi gÃ¼venlik aÃ§Ä±klarÄ±nÄ± Ã¶nlemek iÃ§in son derece Ã¶nemlidir. Content Providers, veri manipÃ¼lasyonu ve uygulamalar arasÄ±nda paylaÅŸÄ±mÄ± kolaylaÅŸtÄ±ran temel iÅŸlemleri destekler: `insert()`, `update()`, `delete()`, ve `query()`.

**FileProvider**, dosyalarÄ± gÃ¼venli bir ÅŸekilde paylaÅŸmaya odaklanan Ã¶zel bir Content Provider'dÄ±r. EriÅŸimi kontrol etmek iÃ§in belirli niteliklerle uygulamanÄ±n manifestinde tanÄ±mlanÄ±r ve klasÃ¶r yapÄ±landÄ±rmalarÄ±nÄ± gÃ¶steren `android:exported` ve `android:resource` ile belirtilir. DuyarlÄ± verilerin yanlÄ±ÅŸlÄ±kla ifÅŸa edilmesini Ã¶nlemek iÃ§in dizinleri paylaÅŸÄ±rken dikkatli olunmalÄ±dÄ±r.

FileProvider iÃ§in Ã¶rnek manifest bildirimi:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ve `filepaths.xml` dosyasÄ±nda paylaÅŸÄ±lan klasÃ¶rleri belirtmenin bir Ã¶rneÄŸi:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
For further information check:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews, Android uygulamalarÄ± iÃ§inde **mini web tarayÄ±cÄ±larÄ±** gibidir, iÃ§erikleri ya webden ya da yerel dosyalardan Ã§eker. Normal tarayÄ±cÄ±larla benzer risklerle karÅŸÄ±laÅŸÄ±rlar, ancak belirli **ayarlar** ile bu **riskleri azaltmanÄ±n** yollarÄ± vardÄ±r.

Android, iki ana WebView tÃ¼rÃ¼ sunar:

- **WebViewClient**, temel HTML iÃ§in harikadÄ±r ancak JavaScript uyarÄ± fonksiyonunu desteklemez, bu da XSS saldÄ±rÄ±larÄ±nÄ±n nasÄ±l test edileceÄŸini etkiler.
- **WebChromeClient**, tam Chrome tarayÄ±cÄ± deneyimine daha Ã§ok benzer.

Ã–nemli bir nokta, WebView tarayÄ±cÄ±larÄ±nÄ±n cihazÄ±n ana tarayÄ±cÄ±sÄ±yla **Ã§erez paylaÅŸmamasÄ±dÄ±r**.

Ä°Ã§erik yÃ¼klemek iÃ§in ````loadUrl````, ````loadData````, ve ````loadDataWithBaseURL```` gibi yÃ¶ntemler mevcuttur. Bu URL'lerin veya dosyalarÄ±n **kullanÄ±m iÃ§in gÃ¼venli** olduÄŸundan emin olmak kritik Ã¶neme sahiptir. GÃ¼venlik ayarlarÄ±, ````WebSettings```` sÄ±nÄ±fÄ± aracÄ±lÄ±ÄŸÄ±yla yÃ¶netilebilir. Ã–rneÄŸin, JavaScript'i ````setJavaScriptEnabled(false)```` ile devre dÄ±ÅŸÄ± bÄ±rakmak, XSS saldÄ±rÄ±larÄ±nÄ± Ã¶nleyebilir.

JavaScript "Bridge", Java nesnelerinin JavaScript ile etkileÅŸimde bulunmasÄ±na olanak tanÄ±r ve Android 4.2'den itibaren gÃ¼venlik iÃ§in yÃ¶ntemlerin ````@JavascriptInterface```` ile iÅŸaretlenmesi gerekir.

Ä°Ã§erik eriÅŸimine izin vermek (````setAllowContentAccess(true)````), WebView'larÄ±n Ä°Ã§erik SaÄŸlayÄ±cÄ±larÄ±na ulaÅŸmasÄ±na olanak tanÄ±r, bu da iÃ§erik URL'leri gÃ¼venli olarak doÄŸrulanmadÄ±kÃ§a bir risk oluÅŸturabilir.

Dosya eriÅŸimini kontrol etmek iÃ§in:
- Dosya eriÅŸimini devre dÄ±ÅŸÄ± bÄ±rakmak (````setAllowFileAccess(false)````), dosya sistemine eriÅŸimi sÄ±nÄ±rlar, belirli varlÄ±klar iÃ§in istisnalarla, bunlarÄ±n yalnÄ±zca hassas olmayan iÃ§erikler iÃ§in kullanÄ±lmasÄ±nÄ± saÄŸlar.

## Other App Components and Mobile Device Management

### **Digital Signing of Applications**

- **Dijital imza**, Android uygulamalarÄ± iÃ§in zorunludur, uygulamalarÄ±n yÃ¼klemeden Ã¶nce **gerÃ§ekten yazÄ±ldÄ±ÄŸÄ±** garantisini saÄŸlar. Bu sÃ¼reÃ§, uygulama kimliÄŸi iÃ§in bir sertifika kullanÄ±r ve yÃ¼kleme sÄ±rasÄ±nda cihazÄ±n paket yÃ¶neticisi tarafÄ±ndan doÄŸrulanmalÄ±dÄ±r. Uygulamalar **kendinden imzalÄ± veya harici bir CA tarafÄ±ndan sertifikalandÄ±rÄ±lmÄ±ÅŸ** olabilir, yetkisiz eriÅŸime karÅŸÄ± koruma saÄŸlar ve uygulamanÄ±n cihaza teslimatÄ± sÄ±rasÄ±nda deÄŸiÅŸtirilmediÄŸini garanti eder.

### **App Verification for Enhanced Security**

- **Android 4.2**'den itibaren, **UygulamalarÄ± DoÄŸrula** adlÄ± bir Ã¶zellik, kullanÄ±cÄ±larÄ±n yÃ¼klemeden Ã¶nce uygulamalarÄ±n gÃ¼venliÄŸini kontrol etmelerine olanak tanÄ±r. Bu **doÄŸrulama sÃ¼reci**, kullanÄ±cÄ±larÄ± potansiyel olarak zararlÄ± uygulamalar hakkÄ±nda uyarabilir veya Ã¶zellikle kÃ¶tÃ¼ niyetli olanlarÄ±n yÃ¼klenmesini engelleyebilir, kullanÄ±cÄ± gÃ¼venliÄŸini artÄ±rÄ±r.

### **Mobile Device Management (MDM)**

- **MDM Ã§Ã¶zÃ¼mleri**, **Cihaz YÃ¶netimi API'si** aracÄ±lÄ±ÄŸÄ±yla mobil cihazlar iÃ§in **denetim ve gÃ¼venlik** saÄŸlar. Mobil cihazlarÄ± etkili bir ÅŸekilde yÃ¶netmek ve gÃ¼vence altÄ±na almak iÃ§in bir Android uygulamasÄ±nÄ±n yÃ¼klenmesini gerektirir. Ana iÅŸlevler arasÄ±nda **ÅŸifre politikalarÄ±nÄ± uygulamak**, **depolama ÅŸifrelemesini zorunlu kÄ±lmak** ve **uzaktan veri silme izni vermek** bulunur, bu da mobil cihazlar Ã¼zerinde kapsamlÄ± kontrol ve gÃ¼venlik saÄŸlar.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks EÄŸitim AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks EÄŸitim GCP KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **Bize katÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **bizi** **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}
