# Android UygulamalarÄ± Temelleri

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramanla Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* Åirketinizi HackTricks'te **reklam vermek** veya HackTricks'i **PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi paylaÅŸarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na **katkÄ±da bulunun**.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En Ã¶nemli gÃ¼venlik aÃ§Ä±klarÄ±nÄ± bulun ve daha hÄ±zlÄ± dÃ¼zeltebilin. Intruder saldÄ±rÄ± yÃ¼zeyinizi takip eder, proaktif tehdit taramalarÄ± yapar, API'lerden web uygulamalarÄ±na ve bulut sistemlerine kadar tÃ¼m teknoloji yÄ±ÄŸÄ±nÄ±nÄ±zda sorunlarÄ± bulur. [**Ãœcretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugÃ¼n.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Android GÃ¼venlik Modeli

**Ä°ki katman vardÄ±r:**

* **Ä°ÅŸletim Sistemi (OS)**, yÃ¼klÃ¼ uygulamalarÄ± birbirinden izole tutar.
* **Uygulama kendisi**, geliÅŸtiricilere belirli iÅŸlevleri **aÃ§Ä±ÄŸa Ã§Ä±karma** ve uygulama yeteneklerini yapÄ±landÄ±rma imkanÄ± saÄŸlar.

### UID AyrÄ±mÄ±

**Her uygulamaya belirli bir KullanÄ±cÄ± KimliÄŸi (UID) atanÄ±r**. Bu, uygulamanÄ±n yalnÄ±zca kendi UID'sine ait veya paylaÅŸÄ±lan dosyalara eriÅŸebilmesi iÃ§in uygulama yÃ¼klenirken yapÄ±lÄ±r. Bu nedenle, yalnÄ±zca uygulama kendisi, OS'nin belirli bileÅŸenleri ve kÃ¶k kullanÄ±cÄ± uygulamanÄ±n verilerine eriÅŸebilir.

### UID PaylaÅŸÄ±mÄ±

**Ä°ki uygulama aynÄ± UID'yi kullanacak ÅŸekilde yapÄ±landÄ±rÄ±labilir**. Bu bilgi paylaÅŸÄ±mÄ± iÃ§in faydalÄ± olabilir, ancak bunlardan biri tehlikeye dÃ¼ÅŸerse her iki uygulamanÄ±n verileri de tehlikeye dÃ¼ÅŸer. Bu nedenle bu davranÄ±ÅŸ **Ã¶nerilmez**.\
**AynÄ± UID'yi paylaÅŸmak iÃ§in uygulamalarÄ±n manifest dosyalarÄ±nda aynÄ± `android:sharedUserId` deÄŸerini tanÄ±mlamalarÄ± gerekir.**

### Kum SandÄ±ÄŸÄ±

**Android Uygulama Kum SandÄ±ÄŸÄ±**, **her uygulamayÄ±** ayrÄ± bir sÃ¼reÃ§ olarak Ã§alÄ±ÅŸtÄ±rmak iÃ§in **ayrÄ± bir kullanÄ±cÄ± kimliÄŸi altÄ±nda** Ã§alÄ±ÅŸmasÄ±na izin verir. Her sÃ¼recin kendi sanal makinesi vardÄ±r, bu nedenle bir uygulamanÄ±n kodu diÄŸer uygulamalardan izole bir ÅŸekilde Ã§alÄ±ÅŸÄ±r.\
Android 5.0(L)'den itibaren **SELinux** uygulanÄ±r. Temel olarak, SELinux tÃ¼m sÃ¼reÃ§ etkileÅŸimlerini reddeder ve ardÄ±ndan bunlar arasÄ±nda **yalnÄ±zca beklenen etkileÅŸimlere izin veren politikalar oluÅŸturur**.

### Ä°zinler

Bir uygulama **yÃ¼klendiÄŸinde ve izinler istendiÄŸinde**, uygulama **AndroidManifest.xml** dosyasÄ±ndaki **`uses-permission`** Ã¶ÄŸelerinde yapÄ±landÄ±rÄ±lan izinleri istemektedir. **uses-permission** Ã¶ÄŸesi, istenen iznin adÄ±nÄ± **name** **Ã¶zniteliÄŸi** iÃ§inde belirtir. AyrÄ±ca, izinlerin belirtilenden daha yÃ¼ksek sÃ¼rÃ¼mlerde istenmesini durduran **maxSdkVersion** Ã¶zniteliÄŸi vardÄ±r.\
Android uygulamalarÄ±nÄ±n baÅŸlangÄ±Ã§ta tÃ¼m izinleri istemeleri gerekmez, aynÄ± zamanda **izinleri dinamik olarak isteyebilirler** ancak tÃ¼m izinlerin **manifestoda bildirilmesi** gerekir.

Bir uygulama iÅŸlevselliÄŸi aÃ§Ä±ÄŸa Ã§Ä±kardÄ±ÄŸÄ±nda, **eriÅŸimi yalnÄ±zca belirli bir izne sahip uygulamalara sÄ±nÄ±rlayabilir**.\
Bir izin Ã¶ÄŸesinin Ã¼Ã§ Ã¶zelliÄŸi vardÄ±r:

* Ä°zinin **adÄ±**
* Ä°zin grubunu gruplama izni veren **permission-group** Ã¶zniteliÄŸi.
* Ä°zinlerin nasÄ±l verildiÄŸini belirten **protection-level**. DÃ¶rt tÃ¼r vardÄ±r:
* **Normal**: Uygulama iÃ§in **bilinen tehditler yoksa** kullanÄ±lÄ±r. KullanÄ±cÄ±nÄ±n **onaylamasÄ± gerekmez**.
* **Tehlikeli**: Ä°zin, isteyen uygulamaya bazÄ± **yÃ¼ksek eriÅŸimler** saÄŸlar. **KullanÄ±cÄ±larÄ±n onayÄ±nÄ± isteyebilir**.
* **Signature**: YalnÄ±zca bileÅŸeni dÄ±ÅŸa aktaran sertifika ile aynÄ± sertifikaya sahip **uygulamalara izin verilir**. Bu en gÃ¼Ã§lÃ¼ koruma tÃ¼rÃ¼dÃ¼r.
* **SignatureOrSystem**: YalnÄ±zca bileÅŸeni dÄ±ÅŸa aktaran sertifika ile aynÄ± sertifikaya sahip **uygulamalar veya sistem dÃ¼zeyinde eriÅŸimle Ã§alÄ±ÅŸan uygulamalar** izin alabilir.

## Ã–nceden YÃ¼klenmiÅŸ Uygulamalar

Bu uygulamalar genellikle **`/system/app`** veya **`/system/priv-app`** dizinlerinde bulunur ve bazÄ±larÄ± **optimize edilmiÅŸtir** (`classes.dex` dosyasÄ±nÄ± bile bulamayabilirsiniz). Bu uygulamalar, bazen **root** olarak Ã§alÄ±ÅŸtÄ±klarÄ± iÃ§in **Ã§ok fazla izinle** Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±klarÄ±nda kontrol edilmeye deÄŸerdir.

* Android AÃ§Ä±k Kaynak Projesi (AOSP) ROM ile birlikte **gÃ¶nderilenler**
* Cihaz **Ã¼reticisi** tarafÄ±ndan eklenenler
* Cep **telefonu saÄŸlayÄ±cÄ±sÄ±** tarafÄ±ndan eklenenler (onlardan satÄ±n alÄ±ndÄ±ysa)

## Rootlama

Fiziksel bir Android cihazda kÃ¶k eriÅŸimi elde etmek iÃ§in genellikle **cihaza Ã¶zgÃ¼** olan 1 veya 2 **zafiyeti sÃ¶mÃ¼rmek** gerekmektedir.\
SÃ¶mÃ¼rÃ¼ iÅŸlemi baÅŸarÄ±lÄ± olduÄŸunda, genellikle Linux `su` ikili dosyasÄ±, kullanÄ±cÄ±nÄ±n PATH ortam deÄŸiÅŸkeninde belirtilen bir konuma (`/system/xbin` gibi) kopyalanÄ±r.

su ikili dosyasÄ± yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ±nda, baÅŸka bir Android uygulamasÄ± `su` ikili dosyasÄ±yla etkileÅŸim kurmak ve **kÃ¶k eriÅŸimi taleplerini iÅŸlemek** iÃ§in kullanÄ±lÄ±r, Ã¶rneÄŸin **Superuser** ve **SuperSU** (Google Play Store'da mevcuttur).

{% hint style="danger" %}
Rootlama iÅŸlemi Ã§ok tehlikelidir ve cihaza ciddi zarar verebilir.
{% endhint %}

### ROM'lar

Ã–zel bir firmware yÃ¼kleyerek OS'yi **deÄŸiÅŸtirmek mÃ¼mkÃ¼ndÃ¼r**. Bunu yaparak eski bir cihazÄ±n kullanÄ±ÅŸlÄ±lÄ±ÄŸÄ±nÄ± artÄ±rabilir, yazÄ±lÄ±m kÄ±sÄ±tlamalarÄ±nÄ± aÅŸabilir veya en son Android koduna eriÅŸim elde
### **Dalvik ve Smali**

Android uygulama geliÅŸtirmede, uygulamalar oluÅŸturmak iÃ§in **Java veya Kotlin** kullanÄ±lÄ±r. MasaÃ¼stÃ¼ uygulamalarda JVM kullanmak yerine, Android bu kodu **Dalvik YÃ¼rÃ¼tÃ¼lebilir (DEX) bytecode**'a derler. Daha Ã¶nce, Dalvik sanal makinesi bu bytecode'u iÅŸlerken, ÅŸimdi daha yeni Android sÃ¼rÃ¼mlerinde Android Runtime (ART) devralÄ±r.

Tersine mÃ¼hendislik iÃ§in, **Smali** Ã¶nemli hale gelir. Bu, DEX bytecode'unun insan tarafÄ±ndan okunabilir versiyonudur ve kaynak kodunu bytecode talimatlarÄ±na Ã§evirerek bir montaj dili gibi hareket eder. Smali ve baksmali, bu baÄŸlamda montaj ve montajdan Ã§Ä±karma araÃ§larÄ±nÄ± ifade eder.

***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En Ã¶nemli gÃ¼venlik aÃ§Ä±klarÄ±nÄ± bulun, bÃ¶ylece daha hÄ±zlÄ± dÃ¼zeltebilirsiniz. Intruder saldÄ±rÄ± yÃ¼zeyinizi takip eder, proaktif tehdit taramalarÄ± yapar, API'lerden web uygulamalarÄ±na ve bulut sistemlerine kadar tÃ¼m teknoloji yÄ±ÄŸÄ±nÄ±nÄ±zda sorunlarÄ± bulur. [**Ãœcretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugÃ¼n.

***

## Ä°stekler (Intents)

Ä°stekler, Android uygulamalarÄ±nÄ±n bileÅŸenleri arasÄ±nda veya diÄŸer uygulamalarla iletiÅŸim kurmanÄ±n temel yollarÄ±dÄ±r. Bu mesaj nesneleri, HTTP iletiÅŸimindeki GET/POST isteklerinin nasÄ±l kullanÄ±ldÄ±ÄŸÄ± gibi, veri taÅŸÄ±yabilirler.

Yani bir Ä°stek, temel olarak bileÅŸenler arasÄ±nda geÃ§irilen bir **mesajdÄ±r**. Ä°stekler, belirli bileÅŸenlere veya uygulamalara **yÃ¶nlendirilebilir** veya belirli bir alÄ±cÄ± olmadan gÃ¶nderilebilir.\
BasitÃ§e sÃ¶ylemek gerekirse, Ä°stek ÅŸunlar iÃ§in kullanÄ±labilir:

* Bir etkinliÄŸi baÅŸlatmak iÃ§in, genellikle bir uygulama iÃ§in bir kullanÄ±cÄ± arayÃ¼zÃ¼ aÃ§mak iÃ§in
* Sistem ve uygulamalara deÄŸiÅŸiklikleri bildirmek iÃ§in yayÄ±nlar olarak
* Bir arka plan hizmetini baÅŸlatmak, durdurmak ve iletiÅŸim kurmak iÃ§in
* ContentProvider'lar aracÄ±lÄ±ÄŸÄ±yla veriye eriÅŸmek iÃ§in
* OlaylarÄ± iÅŸlemek iÃ§in geri Ã§aÄŸÄ±rmalar olarak

EÄŸer gÃ¼venlik aÃ§Ä±ÄŸÄ± varsa, **Ä°stekler Ã§eÅŸitli saldÄ±rÄ±larÄ± gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±labilir**.

### Ä°stek-Filtresi (Intent-Filter)

**Ä°stek Filtreleri**, bir etkinlik, hizmet veya YayÄ±n AlÄ±cÄ±sÄ±nÄ±n farklÄ± tÃ¼rdeki Ä°steklerle nasÄ±l etkileÅŸimde bulunabileceÄŸini tanÄ±mlar. Temel olarak, bu bileÅŸenlerin ne tÃ¼r eylemler gerÃ§ekleÅŸtirebileceÄŸi veya hangi tÃ¼r yayÄ±nlarÄ± iÅŸleyebileceÄŸi gibi yeteneklerini aÃ§Ä±klarlar. Bu filtreleri bildirmenin temel yeri, **AndroidManifest.xml** dosyasÄ±dÄ±r, ancak YayÄ±n AlÄ±cÄ±larÄ± iÃ§in bunlarÄ± kodlamak da bir seÃ§enektir.

Ä°stek Filtreleri, kategoriler, eylemler ve veri filtreleri olmak Ã¼zere, ek meta verileri iÃ§ermek de mÃ¼mkÃ¼ndÃ¼r. Bu yapÄ±, bileÅŸenlerin belirtilen kriterlere uyan belirli Ä°stekleri iÅŸlemesine olanak tanÄ±r.

Android bileÅŸenlerinin (etkinlikler/hizmetler/content provider'lar/yayÄ±n alÄ±cÄ±larÄ±) Ã¶nemli bir yÃ¶nÃ¼, gÃ¶rÃ¼nÃ¼rlÃ¼kleri veya **genel durumlarÄ±**'dÄ±r. Bir bileÅŸen, **`exported`** deÄŸeri **`true`** olarak ayarlanmÄ±ÅŸsa veya manifestte bir Ä°stek Filtresi bildirilmiÅŸse, diÄŸer uygulamalarla etkileÅŸimde bulunabilir ve genel olarak kabul edilir. Bununla birlikte, geliÅŸtiricilerin bu bileÅŸenleri aÃ§Ä±kÃ§a Ã¶zel tutmalarÄ± ve diÄŸer uygulamalarla istemeden etkileÅŸime girmemelerini saÄŸlamalarÄ± bir yol vardÄ±r. Bu, manifest tanÄ±mlarÄ±nda **`exported`** Ã¶zniteliÄŸini **`false`** olarak ayarlayarak elde edilir.

AyrÄ±ca, geliÅŸtiriciler bu bileÅŸenlere eriÅŸimi daha da gÃ¼vence altÄ±na almak iÃ§in belirli izinleri gerektirebilirler. **`permission`** Ã¶zniteliÄŸi, yalnÄ±zca belirli izne sahip uygulamalarÄ±n bileÅŸene eriÅŸebileceÄŸini zorlamak iÃ§in ayarlanabilir, bÃ¶ylece kiminle etkileÅŸimde bulunabileceÄŸiniz konusunda ek bir gÃ¼venlik ve kontrol katmanÄ± eklenir.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Ä°ma Eylemleri

Eylemler, bir Intent yapÄ±cÄ±sÄ± kullanÄ±larak programatik olarak oluÅŸturulur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Ã–nceden belirtilen niyetin **EYLEM\_GÃ–NDER** olduÄŸu ve **Ekstra**'nÄ±n bir mailto **Uri** olduÄŸu (Ekstra, niyetin beklediÄŸi ek bilgidir).

Bu niyet, aÅŸaÄŸÄ±daki Ã¶rnekte olduÄŸu gibi manifest iÃ§inde belirtilmelidir:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Bir intent-filter, bir mesaj almak iÃ§in **eylem**, **veri** ve **kategori** ile eÅŸleÅŸmelidir.

"Intent Ã§Ã¶zÃ¼mleme" sÃ¼reci, her mesajÄ±n hangi uygulamanÄ±n almasÄ± gerektiÄŸini belirler. Bu sÃ¼reÃ§, **Ã¶ncelik Ã¶zniteliÄŸini** dikkate alÄ±r, bu Ã¶znitelik **intent-filter bildiriminde** ayarlanabilir ve **daha yÃ¼ksek Ã¶nceliÄŸe sahip olan seÃ§ilir**. Bu Ã¶ncelik -1000 ile 1000 arasÄ±nda ayarlanabilir ve uygulamalar `SYSTEM_HIGH_PRIORITY` deÄŸerini kullanabilir. Bir **Ã§akÄ±ÅŸma** oluÅŸursa, kullanÄ±cÄ±nÄ±n karar verebilmesi iÃ§in bir "seÃ§ici" penceresi gÃ¶rÃ¼ntÃ¼lenir.

### AÃ§Ä±k Ä°ntentler

AÃ§Ä±k bir intent, hedeflediÄŸi sÄ±nÄ±f adÄ±nÄ± belirtir:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
DiÄŸer uygulamalarda Ã¶nceden belirtilen intent'e eriÅŸmek iÃ§in ÅŸunu kullanabilirsiniz:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Bekleyen Ä°stekler

Bu, diÄŸer uygulamalarÄ±n, uygulamanÄ±zÄ±n kimliÄŸi ve izinleri kullanarak **uygulamanÄ±z adÄ±na iÅŸlemler yapmasÄ±na olanak tanÄ±r**. Bekleyen bir istek oluÅŸtururken, bir niyet ve gerÃ§ekleÅŸtirilecek eylem belirtilmelidir. **Belirtilen niyet aÃ§Ä±kÃ§a belirtilmezse** (hangi niyetin Ã§aÄŸrÄ±labileceÄŸini belirtmez), **kÃ¶tÃ¼ niyetli bir uygulama, kurban uygulama adÄ±na belirtilen eylemi gerÃ§ekleÅŸtirebilir**. DahasÄ±, **bir eylem belirtilmezse**, kÃ¶tÃ¼ niyetli uygulama, kurban adÄ±na **herhangi bir eylem yapabilir**.

### YayÄ±n Ä°stekleri

Ã–nceki isteklerin aksine, yayÄ±n istekleri **birden fazla uygulama tarafÄ±ndan alÄ±nabilir**. Ancak, API sÃ¼rÃ¼mÃ¼ 14'ten itibaren, mesajÄ±n almasÄ± gereken uygulamayÄ± belirtmek iÃ§in Intent.setPackage kullanmak mÃ¼mkÃ¼ndÃ¼r.

Alternatif olarak, yayÄ±nÄ± gÃ¶nderirken **bir izin belirtmek de mÃ¼mkÃ¼ndÃ¼r**. AlÄ±cÄ± uygulamanÄ±n bu izne sahip olmasÄ± gerekecektir.

YayÄ±nlarÄ±n **iki tÃ¼rÃ¼** vardÄ±r: **Normal** (asenkron) ve **SÄ±ralÄ±** (senkron). **SÄ±ralama**, alÄ±cÄ± Ã¶ÄŸe iÃ§inde yapÄ±landÄ±rÄ±lan Ã¶nceliÄŸe dayanÄ±r. **Her uygulama yayÄ±nÄ± iÅŸleyebilir, iletebilir veya bÄ±rakabilir**.

`Context` sÄ±nÄ±fÄ±ndan `sendBroadcast(intent, receiverPermission)` iÅŸlevini kullanarak bir yayÄ±n gÃ¶ndermek mÃ¼mkÃ¼ndÃ¼r.\
AyrÄ±ca, **`LocalBroadCastManager`**'dan **`sendBroadcast`** iÅŸlevini kullanarak **mesajÄ±n uygulamadan Ã§Ä±kmamasÄ±nÄ±** saÄŸlayabilirsiniz. Bunu kullanarak bir alÄ±cÄ± bileÅŸenini dÄ±ÅŸa aktarmanÄ±za gerek kalmaz.

### YapÄ±ÅŸkan YayÄ±nlar

Bu tÃ¼r yayÄ±nlara, gÃ¶nderildikten sonra **uzun bir sÃ¼re eriÅŸilebilir**.\
Bunlar API seviyesi 21'de kullanÄ±mdan kaldÄ±rÄ±ldÄ± ve **kullanÄ±lmamalarÄ± Ã¶nerilir**.\
**Herhangi bir uygulamanÄ±n verileri izlemesine ve deÄŸiÅŸtirmesine izin verirler**.

EÄŸer "sticky" kelimesini iÃ§eren **`sendStickyBroadcast`** veya **`sendStickyBroadcastAsUser`** gibi iÅŸlevler bulursanÄ±z, **etkisini kontrol edin ve bunlarÄ± kaldÄ±rmaya Ã§alÄ±ÅŸÄ±n**.

## Derin baÄŸlantÄ±lar / URL ÅŸemalarÄ±

Android uygulamalarÄ±nda, **derin baÄŸlantÄ±lar**, bir URL aracÄ±lÄ±ÄŸÄ±yla doÄŸrudan bir eylemi (Niyet) baÅŸlatmak iÃ§in kullanÄ±lÄ±r. Bu, bir etkinlik iÃ§inde belirli bir **URL ÅŸemasÄ±nÄ±n** bildirilmesiyle yapÄ±lÄ±r. Bir Android cihazÄ±, bu ÅŸemayla bir URL'ye **eriÅŸmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda**, uygulama iÃ§inde belirtilen etkinlik baÅŸlatÄ±lÄ±r.

Åema, **`AndroidManifest.xml`** dosyasÄ±nda bildirilmelidir:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Ã–nceki Ã¶rnekteki ÅŸema `exampleapp://` (ayrÄ±ca **`category BROWSABLE`**'Ä± da dikkate alÄ±n)

ArdÄ±ndan, veri alanÄ±nda **host** ve **path** belirtebilirsiniz:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web Ã¼zerinden eriÅŸmek iÃ§in ÅŸu ÅŸekilde bir baÄŸlantÄ± kurmak mÃ¼mkÃ¼ndÃ¼r:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**Kodun uygulamada Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± kodu** bulmak iÃ§in, deeplink tarafÄ±ndan Ã§aÄŸrÄ±lan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayÄ±n.

[HTML sayfalarÄ± kullanmadan derin baÄŸlantÄ±larÄ± Ã§aÄŸÄ±rma](./#exploiting-schemes-deep-links) hakkÄ±nda bilgi edinin.

## AIDL - Android ArayÃ¼z TanÄ±m Dili

**Android ArayÃ¼z TanÄ±m Dili (AIDL)**, Android uygulamalarÄ±nda **sÃ¼reÃ§ler arasÄ± iletiÅŸimi** (IPC) kolaylaÅŸtÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r. Android'de baÅŸka bir sÃ¼recin belleÄŸine doÄŸrudan eriÅŸim izin verilmediÄŸi iÃ§in, AIDL iÅŸlemi kolaylaÅŸtÄ±rarak nesneleri iÅŸletim sistemi tarafÄ±ndan anlaÅŸÄ±lan bir formata dÃ¶nÃ¼ÅŸtÃ¼rerek farklÄ± sÃ¼reÃ§ler arasÄ±nda iletiÅŸimi kolaylaÅŸtÄ±rÄ±r.

### Temel Kavramlar

- **BaÄŸlÄ± Servisler**: Bu servisler, IPC iÃ§in AIDL'yi kullanÄ±r ve etkinliklerin veya bileÅŸenlerin bir servise baÄŸlanmasÄ±nÄ±, istek yapmasÄ±nÄ± ve yanÄ±t almasÄ±nÄ± saÄŸlar. Servisin sÄ±nÄ±fÄ±ndaki `onBind` yÃ¶ntemi etkileÅŸimi baÅŸlatmak iÃ§in Ã¶nemlidir ve gÃ¼venlik aÃ§Ä±ÄŸÄ± arayÄ±ÅŸÄ±nda kritik bir alan olarak iÅŸaretlenir.

- **Messenger**: BaÄŸlÄ± bir servis olarak Ã§alÄ±ÅŸan Messenger, verilerin `onBind` yÃ¶ntemi aracÄ±lÄ±ÄŸÄ±yla iÅŸlenmesine odaklanan IPC'yi kolaylaÅŸtÄ±rÄ±r. Bu yÃ¶ntemi gÃ¼vensiz veri iÅŸleme veya hassas iÅŸlevlerin yÃ¼rÃ¼tÃ¼lmesi aÃ§Ä±sÄ±ndan yakÄ±ndan incelemek Ã¶nemlidir.

- **Binder**: AIDL'nin soyutlamasÄ± nedeniyle Binder sÄ±nÄ±fÄ±nÄ±n doÄŸrudan kullanÄ±mÄ± daha az yaygÄ±n olsa da, Binder'Ä±n farklÄ± sÃ¼reÃ§lerin bellek alanlarÄ± arasÄ±nda veri transferini kolaylaÅŸtÄ±ran bir Ã§ekirdek seviye sÃ¼rÃ¼cÃ¼ olarak hareket ettiÄŸini anlamak faydalÄ±dÄ±r. Daha fazla anlayÄ±ÅŸ iÃ§in bir kaynak [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) adresinde bulunmaktadÄ±r.

## BileÅŸenler

Bunlar ÅŸunlarÄ± iÃ§erir: **Etkinlikler, Servisler, YayÄ±n AlÄ±cÄ±lar ve SaÄŸlayÄ±cÄ±lar.**

### BaÅŸlatÄ±cÄ± Etkinlik ve diÄŸer etkinlikler

Android uygulamalarÄ±nda, **etkinlikler** ekranlara benzer ve uygulamanÄ±n kullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼n farklÄ± bÃ¶lÃ¼mlerini gÃ¶sterir. Bir uygulama birÃ§ok etkinliÄŸe sahip olabilir, her biri kullanÄ±cÄ±ya benzersiz bir ekran sunar.

**BaÅŸlatÄ±cÄ± etkinlik**, uygulamanÄ±n simgesine dokunduÄŸunuzda baÅŸlatÄ±lan uygulamanÄ±n ana giriÅŸ noktasÄ±dÄ±r. Belirli MAIN ve LAUNCHER niyetleriyle uygulamanÄ±n manifest dosyasÄ±nda tanÄ±mlanÄ±r.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
# Android UygulamalarÄ± Temelleri

BazÄ± uygulamalarÄ±n, Ã¶zellikle arka plan hizmetleri gibi kullanÄ±cÄ± arayÃ¼zÃ¼ olmayanlarÄ±nÄ±n bir baÅŸlatÄ±cÄ± etkinliÄŸe ihtiyacÄ± yoktur.

Etkinlikler, manifest dosyasÄ±nda "exported" olarak iÅŸaretlenerek diÄŸer uygulamalar veya iÅŸlemler tarafÄ±ndan kullanÄ±labilir hale getirilebilir. Bu ayar, diÄŸer uygulamalarÄ±n bu etkinliÄŸi baÅŸlatmasÄ±na izin verir:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ancak, baÅŸka bir uygulamadan bir etkinliÄŸe eriÅŸmek her zaman bir gÃ¼venlik riski oluÅŸturmaz. EndiÅŸe, hassas verilerin yanlÄ±ÅŸ ÅŸekilde paylaÅŸÄ±lmasÄ± durumunda ortaya Ã§Ä±kar, bu da bilgi sÄ±zÄ±ntÄ±larÄ±na yol aÃ§abilir.

Bir etkinliÄŸin yaÅŸam dÃ¶ngÃ¼sÃ¼, **onCreate yÃ¶ntemiyle baÅŸlar**, UI'yi ayarlar ve etkinliÄŸi kullanÄ±cÄ±yla etkileÅŸime hazÄ±rlar.

### Uygulama Alt SÄ±nÄ±fÄ±

Android geliÅŸtirmede, bir uygulamanÄ±n [Application](https://developer.android.com/reference/android/app/Application) sÄ±nÄ±fÄ±nÄ±n bir **alt sÄ±nÄ±fÄ±nÄ±** oluÅŸturma seÃ§eneÄŸi vardÄ±r, ancak zorunlu deÄŸildir. BÃ¶yle bir alt sÄ±nÄ±f tanÄ±mlandÄ±ÄŸÄ±nda, uygulama iÃ§inde Ã¶ncelikle bu sÄ±nÄ±f Ã¶rneklendirilir. Bu alt sÄ±nÄ±fta **`attachBaseContext`** yÃ¶ntemi uygulanmÄ±ÅŸsa, **`onCreate`** yÃ¶nteminden Ã¶nce bu yÃ¶ntem Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu yapÄ±, uygulamanÄ±n geri kalanÄ±nÄ±n baÅŸlamadan Ã¶nce erken baÅŸlatma iÃ§in olanak saÄŸlar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Hizmetler

[Hizmetler](https://developer.android.com/guide/components/services), kullanÄ±cÄ± arayÃ¼zÃ¼ olmadan gÃ¶revleri gerÃ§ekleÅŸtirebilen **arka planda Ã§alÄ±ÅŸan iÅŸlemlerdir**. Bu gÃ¶revler, kullanÄ±cÄ±larÄ±n farklÄ± uygulamalara geÃ§se bile devam edebilir, bu nedenle hizmetler **uzun sÃ¼reli iÅŸlemler** iÃ§in Ã¶nemlidir.

Hizmetler Ã§ok yÃ¶nlÃ¼dÃ¼r; Ã§eÅŸitli ÅŸekillerde baÅŸlatÄ±labilirler ve bunlarÄ± baÅŸlatmanÄ±n temel yÃ¶ntemi **Intentler**dir. Bir hizmet, `startService` yÃ¶ntemi kullanÄ±larak baÅŸlatÄ±ldÄ±ÄŸÄ±nda, `onStart` yÃ¶ntemi devreye girer ve `stopService` yÃ¶ntemi aÃ§Ä±kÃ§a Ã§aÄŸrÄ±lana kadar Ã§alÄ±ÅŸmaya devam eder. Alternatif olarak, bir hizmetin rolÃ¼, etkin bir istemci baÄŸlantÄ±sÄ±na baÄŸlÄ±ysa, istemciyi hizmete baÄŸlamak iÃ§in `bindService` yÃ¶ntemi kullanÄ±lÄ±r ve veri geÃ§iÅŸi iÃ§in `onBind` yÃ¶ntemi devreye girer.

Hizmetlerin ilginÃ§ bir uygulamasÄ±, kullanÄ±cÄ±nÄ±n bir uygulayla etkileÅŸimini engellemeden arka planda mÃ¼zik Ã§alma veya aÄŸ verisi almadÄ±r. AyrÄ±ca, hizmetler aynÄ± cihazdaki diÄŸer iÅŸlemler tarafÄ±ndan eriÅŸilebilir hale getirilebilir. Bu, varsayÄ±lan davranÄ±ÅŸ deÄŸildir ve Android Manifest dosyasÄ±nda aÃ§Ä±kÃ§a yapÄ±landÄ±rma gerektirir:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### YayÄ±n AlÄ±cÄ±larÄ±

**YayÄ±n alÄ±cÄ±larÄ±**, bir mesajlaÅŸma sisteminde dinleyici olarak hareket eder ve sistemden gelen aynÄ± mesajlara birden fazla uygulamanÄ±n yanÄ±t vermesine olanak tanÄ±r. Bir uygulama, alÄ±cÄ±yÄ± **iki temel yol** ile **kaydedebilir**: uygulamanÄ±n **Manifest** dosyasÄ± aracÄ±lÄ±ÄŸÄ±yla veya uygulamanÄ±n kodu iÃ§inde **dinamik olarak** **`registerReceiver`** API'si ile. Manifest dosyasÄ±nda yayÄ±nlar izinlerle filtrelenirken, dinamik olarak kaydedilen alÄ±cÄ±lar kayÄ±t sÄ±rasÄ±nda izinleri belirtebilir.

**Intent filtreleri**, kayÄ±t yÃ¶ntemlerinde de Ã¶nemli bir rol oynar ve alÄ±cÄ±nÄ±n hangi yayÄ±nlarÄ± tetikleyeceÄŸini belirler. EÅŸleÅŸen bir yayÄ±n gÃ¶nderildiÄŸinde, alÄ±cÄ±nÄ±n **`onReceive`** yÃ¶ntemi Ã§aÄŸrÄ±lÄ±r ve uygulamanÄ±n buna uygun ÅŸekilde tepki vermesini saÄŸlar, Ã¶rneÄŸin dÃ¼ÅŸÃ¼k pil uyarÄ±sÄ±na yanÄ±t olarak davranÄ±ÅŸÄ± ayarlamak gibi.

YayÄ±nlar ya **asenkron** olarak, sÄ±rasÄ±z bir ÅŸekilde tÃ¼m alÄ±cÄ±lara ulaÅŸÄ±r ya da **senkron** olarak, alÄ±cÄ±lar belirlenen Ã¶nceliklere gÃ¶re yayÄ±nÄ± alÄ±r. Ancak, herhangi bir uygulama yayÄ±nÄ± ele geÃ§irmek iÃ§in kendisini Ã¶nceliklendirebileceÄŸinden, potansiyel bir gÃ¼venlik riski olduÄŸunu unutmamak Ã¶nemlidir.

Bir alÄ±cÄ±nÄ±n iÅŸlevselliÄŸini anlamak iÃ§in, sÄ±nÄ±f iÃ§indeki **`onReceive`** yÃ¶ntemine bakÄ±n. Bu yÃ¶ntemin kodu alÄ±nan Intent'i deÄŸiÅŸtirebilir, bu nedenle alÄ±cÄ±lar tarafÄ±ndan veri doÄŸrulamasÄ±nÄ±n yapÄ±lmasÄ± gereklidir, Ã¶zellikle Intent'i deÄŸiÅŸtirebilen veya atabilen **SÄ±ralÄ± YayÄ±nlar** iÃ§in.

### Ä°Ã§erik SaÄŸlayÄ±cÄ±

**Ä°Ã§erik SaÄŸlayÄ±cÄ±larÄ±**, yapÄ±landÄ±rÄ±lmÄ±ÅŸ verilerin uygulamalar arasÄ±nda paylaÅŸÄ±lmasÄ± iÃ§in Ã¶nemlidir ve veri gÃ¼venliÄŸini saÄŸlamak iÃ§in **izinlerin** uygulanmasÄ±nÄ±n Ã¶nemini vurgular. Ä°Ã§erik SaÄŸlayÄ±cÄ±larÄ±, veritabanlarÄ±, dosya sistemleri veya web gibi Ã§eÅŸitli kaynaklardan veriye eriÅŸimi saÄŸlar. **`readPermission`** ve **`writePermission`** gibi belirli izinler, eriÅŸimi kontrol etmek iÃ§in Ã¶nemlidir. AyrÄ±ca, geÃ§ici eriÅŸim, ayrÄ±ntÄ±lÄ± eriÅŸim kontrolÃ¼ iÃ§in uygulamanÄ±n manifestindeki **`grantUriPermission`** ayarlarÄ± aracÄ±lÄ±ÄŸÄ±yla saÄŸlanabilir ve `path`, `pathPrefix` ve `pathPattern` gibi Ã¶zniteliklerden yararlanÄ±r.

GÃ¼venlik aÃ§Ä±klarÄ±nÄ± Ã¶nlemek iÃ§in giriÅŸ doÄŸrulamasÄ± son derece Ã¶nemlidir, Ã¶rneÄŸin SQL enjeksiyonu gibi. Ä°Ã§erik SaÄŸlayÄ±cÄ±larÄ±, `insert()`, `update()`, `delete()` ve `query()` gibi temel iÅŸlemleri destekler ve veri manipÃ¼lasyonunu ve uygulamalar arasÄ±nda paylaÅŸÄ±mÄ± kolaylaÅŸtÄ±rÄ±r.

**FileProvider**, dosyalarÄ±n gÃ¼venli bir ÅŸekilde paylaÅŸÄ±lmasÄ±na odaklanan Ã¶zel bir Ä°Ã§erik SaÄŸlayÄ±cÄ±dÄ±r. KlasÃ¶rlere eriÅŸimi kontrol etmek iÃ§in belirli Ã¶zniteliklerle uygulamanÄ±n manifestinde tanÄ±mlanÄ±r ve `android:exported` ve `android:resource` ile klasÃ¶r yapÄ±landÄ±rmalarÄ±na iÅŸaret eder. Hassas verilerin yanlÄ±ÅŸlÄ±kla ortaya Ã§Ä±kmasÄ±nÄ± Ã¶nlemek iÃ§in dikkatli olunmalÄ±dÄ±r.

FileProvider iÃ§in Ã¶rnek manifest bildirimi:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ve `filepaths.xml` dosyasÄ±nda paylaÅŸÄ±lan klasÃ¶rleri belirtme Ã¶rneÄŸi:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Daha fazla bilgi iÃ§in ÅŸu kaynaklara bakabilirsiniz:
- [Android GeliÅŸtiriciler: Ä°Ã§erik SaÄŸlayÄ±cÄ±lar](https://developer.android.com/guide/topics/providers/content-providers)
- [Android GeliÅŸtiriciler: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews, Android uygulamalarÄ±nÄ±n iÃ§indeki **mini web tarayÄ±cÄ±lar** gibidir ve iÃ§eriÄŸi webden veya yerel dosyalardan alÄ±r. Bunlar, normal tarayÄ±cÄ±lar gibi benzer risklerle karÅŸÄ±laÅŸÄ±r, ancak belirli **ayarlar** aracÄ±lÄ±ÄŸÄ±yla bu riskleri **azaltmanÄ±n yollarÄ±** vardÄ±r.

Android, iki ana WebView tÃ¼rÃ¼ sunar:

- **WebViewClient**, temel HTML iÃ§in harikadÄ±r, ancak JavaScript uyarÄ± iÅŸlevini desteklemez, bu da XSS saldÄ±rÄ±larÄ±nÄ±n nasÄ±l test edileceÄŸini etkiler.
- **WebChromeClient**, tam Chrome tarayÄ±cÄ± deneyimine daha Ã§ok benzer.

Bir nokta ÅŸudur ki, WebView tarayÄ±cÄ±larÄ±, cihazÄ±n ana tarayÄ±cÄ±sÄ±yla **Ã§erez paylaÅŸmaz**.

Ä°Ã§erik yÃ¼kleme iÃ§in ````loadUrl````, ````loadData````, ve ````loadDataWithBaseURL```` gibi yÃ¶ntemler kullanÄ±labilir. Bu URL'lerin veya dosyalarÄ±n **gÃ¼venli** olduÄŸundan emin olmak Ã¶nemlidir. GÃ¼venlik ayarlarÄ±, ````WebSettings```` sÄ±nÄ±fÄ± aracÄ±lÄ±ÄŸÄ±yla yÃ¶netilebilir. Ã–rneÄŸin, ````setJavaScriptEnabled(false)```` ile JavaScript devre dÄ±ÅŸÄ± bÄ±rakÄ±larak XSS saldÄ±rÄ±larÄ± Ã¶nlenir.

Java nesnelerinin JavaScript ile etkileÅŸimde bulunmasÄ±nÄ± saÄŸlayan JavaScript "Bridge", Android 4.2'den itibaren gÃ¼venlik iÃ§in yÃ¶ntemlerin ````@JavascriptInterface```` ile iÅŸaretlenmesini gerektirir.

Ä°Ã§eriÄŸe eriÅŸime izin vermek (````setAllowContentAccess(true)````), WebViews'in Ä°Ã§erik SaÄŸlayÄ±cÄ±lara eriÅŸmesine olanak tanÄ±r, ancak iÃ§erik URL'leri gÃ¼venli olarak doÄŸrulanmadÄ±kÃ§a bir risk oluÅŸturabilir.

Dosya eriÅŸimini kontrol etmek iÃ§in:
- Dosya eriÅŸimini devre dÄ±ÅŸÄ± bÄ±rakmak (````setAllowFileAccess(false)````), dosya sistemi eriÅŸimini sÄ±nÄ±rlar ve belirli varlÄ±klar iÃ§in istisnalar yapar, bÃ¶ylece bunlar yalnÄ±zca hassas olmayan iÃ§erik iÃ§in kullanÄ±lÄ±r.

## DiÄŸer Uygulama BileÅŸenleri ve Mobil Cihaz YÃ¶netimi

### **UygulamalarÄ±n Dijital Ä°mzalanmasÄ±**

- Android uygulamalarÄ± iÃ§in **dijital imzalama**, kurulumdan Ã¶nce bunlarÄ±n **gerÃ§ekten yetkilendirilmiÅŸ** olduÄŸunu saÄŸlar. Bu sÃ¼reÃ§, uygulama kimliÄŸi iÃ§in bir sertifika kullanÄ±r ve kurulum sÄ±rasÄ±nda cihazÄ±n paket yÃ¶neticisi tarafÄ±ndan doÄŸrulanmalÄ±dÄ±r. Uygulamalar, yetkisiz eriÅŸime karÅŸÄ± koruma saÄŸlayan ve uygulamanÄ±n teslimatÄ± sÄ±rasÄ±nda deÄŸiÅŸtirilmeden kalmasÄ±nÄ± saÄŸlayan **kendini imzalayan veya harici bir CA tarafÄ±ndan onaylanmÄ±ÅŸ** olabilir.

### **GeliÅŸmiÅŸ GÃ¼venlik iÃ§in Uygulama DoÄŸrulama**

- **Android 4.2**'den itibaren, **Uygulama DoÄŸrulama** adlÄ± bir Ã¶zellik, kullanÄ±cÄ±larÄ±n uygulamalarÄ± kurmadan Ã¶nce gÃ¼venlik aÃ§Ä±sÄ±ndan kontrol etmelerine olanak tanÄ±r. Bu **doÄŸrulama sÃ¼reci**, kullanÄ±cÄ±larÄ± potansiyel olarak zararlÄ± uygulamalar konusunda uyarabilir veya Ã¶zellikle kÃ¶tÃ¼ niyetli olanlarÄ±n kurulumunu engelleyebilir, kullanÄ±cÄ± gÃ¼venliÄŸini artÄ±rÄ±r.

### **Mobil Cihaz YÃ¶netimi (MDM)**

- **MDM Ã§Ã¶zÃ¼mleri**, Mobil Cihaz YÃ¶netimi API'si aracÄ±lÄ±ÄŸÄ±yla mobil cihazlar iÃ§in **denetim ve gÃ¼venlik** saÄŸlar. Mobil cihazlarÄ± etkili bir ÅŸekilde yÃ¶netmek ve gÃ¼vence altÄ±na almak iÃ§in bir Android uygulamasÄ±nÄ±n kurulumunu gerektirirler. Ana iÅŸlevler arasÄ±nda **parola politikalarÄ±nÄ±n zorunlu kÄ±lÄ±nmasÄ±**, **depolama ÅŸifrelemesinin zorunlu kÄ±lÄ±nmasÄ±** ve **uzaktan veri silme izni** gibi Ã¶zellikler bulunur, bÃ¶ylece mobil cihazlar Ã¼zerinde kapsamlÄ± kontrol ve gÃ¼venlik saÄŸlanÄ±r.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En Ã¶nemli gÃ¼venlik aÃ§Ä±klarÄ±nÄ± bulun, bÃ¶ylece daha hÄ±zlÄ± dÃ¼zeltebilirsiniz. Intruder saldÄ±rÄ± yÃ¼zeyinizi takip eder, proaktif tehdit taramalarÄ± yapar, API'lerden web uygulamalarÄ±na ve bulut sistemlerine kadar tÃ¼m teknoloji yÄ±ÄŸÄ±nÄ±nÄ±zda sorunlarÄ± bulur. [**Ãœcretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugÃ¼n.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek veya HackTricks'i PDF olarak indirmek isterseniz** [**ABONELÄ°K PLANLARI'na**](https://github.com/sponsors/carlospolop) gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**'Ä± takip edin**.
* **Hacking hilelerinizi HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n**.

</details>
