# Osnovi Android Aplikacija

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¡ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Android Bezbednosni Model

**Postoje dva sloja:**

* **OS**, koji drÅ¾i instalirane aplikacije izolovane jedna od druge.
* **sama aplikacija**, koja omoguÄ‡ava programerima da **izloÅ¾e odreÄ‘ene funkcionalnosti** i konfiguriÅ¡u moguÄ‡nosti aplikacije.

### UID Razdvajanje

**Svakoj aplikaciji se dodeljuje specifiÄni User ID**. Ovo se deÅ¡ava tokom instalacije aplikacije tako da **aplikacija moÅ¾e da komunicira samo sa datotekama koje pripadaju njenom User ID-u ili deljenim** datotekama. Stoga, samo sama aplikacija, odreÄ‘eni delovi OS-a i root korisnik mogu pristupiti podacima aplikacije.

### UID Deljenje

**Dve aplikacije mogu biti konfigurisane da koriste isti UID**. Ovo moÅ¾e biti korisno za deljenje informacija, ali ako je jedna od njih kompromitovana, podaci obe aplikacije Ä‡e biti kompromitovani. Zato se ovo ponaÅ¡anje **ne preporuÄuje**.\
**Da bi delile isti UID, aplikacije moraju definisati istu `android:sharedUserId` vrednost u svojim manifestima.**

### Sandboxing

**Android Application Sandbox** omoguÄ‡ava da se **svaka aplikacija** pokreÄ‡e kao **poseban proces pod posebnim korisniÄkim ID-om**. Svaki proces ima svoju virtuelnu maÅ¡inu, tako da se kod aplikacije izvrÅ¡ava u izolaciji od drugih aplikacija.\
Od Android 5.0(L) **SELinux** se primenjuje. U suÅ¡tini, SELinux je odbio sve interakcije procesa i zatim stvorio politike da **dozvoli samo oÄekivane interakcije izmeÄ‘u njih**.

### Dozvole

Kada instalirate **aplikaciju i ona traÅ¾i dozvole**, aplikacija traÅ¾i dozvole konfigurisane u **`uses-permission`** elementima u **AndroidManifest.xml** datoteci. **uses-permission** element oznaÄava naziv traÅ¾ene dozvole unutar **name** **atributa.** TakoÄ‘e ima **maxSdkVersion** atribut koji prestaje da traÅ¾i dozvole na verzijama viÅ¡im od one koja je navedena.\
Napomena da android aplikacije ne moraju traÅ¾iti sve dozvole na poÄetku, mogu takoÄ‘e **traÅ¾iti dozvole dinamiÄki**, ali sve dozvole moraju biti **deklarisane** u **manifestu.**

Kada aplikacija izlaÅ¾e funkcionalnost, moÅ¾e ograniÄiti **pristup samo aplikacijama koje imaju odreÄ‘enu dozvolu**.\
Element dozvole ima tri atributa:

* **ime** dozvole
* **permission-group** atribut, koji omoguÄ‡ava grupisanje povezanih dozvola.
* **protection-level** koji oznaÄava kako se dozvole dodeljuju. Postoje Äetiri vrste:
* **Normal**: Koristi se kada nema **poznatih pretnji** za aplikaciju. Korisnik **nije obavezan da je odobri**.
* **Dangerous**: Ukazuje da dozvola dodeljuje traÅ¾eÄ‡oj aplikaciji neku **poviÅ¡enu pristupnost**. **Korisnici se traÅ¾e da ih odobre**.
* **Signature**: Samo **aplikacije potpisane istim sertifikatom kao onaj** koji izvozi komponentu mogu dobiti dozvolu. Ovo je najjaÄi tip zaÅ¡tite.
* **SignatureOrSystem**: Samo **aplikacije potpisane istim sertifikatom kao onaj** koji izvozi komponentu ili **aplikacije koje rade sa pristupom na sistemskom nivou** mogu dobiti dozvole.

## Preinstalirane Aplikacije

Ove aplikacije se obiÄno nalaze u **`/system/app`** ili **`/system/priv-app`** direktorijumima i neke od njih su **optimizovane** (moÅ¾da Äak neÄ‡ete pronaÄ‡i `classes.dex` datoteku). Ove aplikacije vredi proveriti jer ponekad **rade sa previÅ¡e dozvola** (kao root).

* One koje dolaze sa **AOSP** (Android OpenSource Project) **ROM-om**
* Dodate od strane **proizvoÄ‘aÄa** ureÄ‘aja
* Dodate od strane **provajdera** mobilnih telefona (ako su kupljene od njih)

## Rootovanje

Da biste dobili root pristup na fiziÄkom android ureÄ‘aju, obiÄno morate **iskoristiti** 1 ili 2 **ranjivosti** koje su obiÄno **specifiÄne** za **ureÄ‘aj** i **verziju**.\
Kada je eksploatacija uspela, obiÄno se Linux `su` binarni fajl kopira na lokaciju koja je navedena u korisniÄkoj PATH env varijabli kao Å¡to je `/system/xbin`.

Kada je su binarni fajl konfiguran, koristi se druga Android aplikacija za interakciju sa `su` binarnim fajlom i **obraÄ‘ivanje zahteva za root pristup** kao Å¡to su **Superuser** i **SuperSU** (dostupni u Google Play prodavnici).

{% hint style="danger" %}
Napomena da je proces rootovanja veoma opasan i moÅ¾e ozbiljno oÅ¡tetiti ureÄ‘aj.
{% endhint %}

### ROM-ovi

MoguÄ‡e je **zameniti OS instaliranjem prilagoÄ‘enog firmvera**. Na ovaj naÄin je moguÄ‡e produÅ¾iti korisnost starog ureÄ‘aja, zaobiÄ‡i softverska ograniÄenja ili dobiti pristup najnovijem Android kodu.\
**OmniROM** i **LineageOS** su dva od najpopularnijih firmvera za koriÅ¡Ä‡enje.

Napomena da **nije uvek potrebno rootovati ureÄ‘aj** da bi se instalirao prilagoÄ‘eni firmver. **Neki proizvoÄ‘aÄi dozvoljavaju** otkljuÄavanje svojih bootloader-a na dobro dokumentovan i siguran naÄin.

### Implkacije

Kada je ureÄ‘aj rootovan, svaka aplikacija moÅ¾e zatraÅ¾iti pristup kao root. Ako zlonamerna aplikacija dobije taj pristup, moÅ¾e imati pristup gotovo svemu i moÄ‡i Ä‡e da oÅ¡teti telefon.

## Osnovni principi Android Aplikacija <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Format Android aplikacija se naziva _APK format datoteke_. U suÅ¡tini, to je **ZIP datoteka** (preimenovanjem ekstenzije datoteke u .zip, sadrÅ¾aj se moÅ¾e ekstrahovati i pregledati).
- SadrÅ¾aj APK-a (nije iscrpan)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: sadrÅ¾i prekompilirane resurse, poput binarnog XML-a.
- res/xml/files\_paths.xml
- META-INF/
- Ovde se nalazi sertifikat!
- **classes.dex**
- SadrÅ¾i Dalvik bajtkod, koji predstavlja kompajlirani Java (ili Kotlin) kod koji aplikacija izvrÅ¡ava po defaultu.
- lib/
- SadrÅ¾i nativne biblioteke, razdvojene po CPU arhitekturi u poddirektorijumima.
- `armeabi`: kod za ARM procesore
- `armeabi-v7a`: kod za ARMv7 i viÅ¡e procesore
- `x86`: kod za X86 procesore
- `mips`: kod samo za MIPS procesore
- assets/
- ÄŒuva razne datoteke potrebne aplikaciji, potencijalno ukljuÄujuÄ‡i dodatne nativne biblioteke ili DEX datoteke, ponekad koriÅ¡Ä‡ene od strane autora malvera za prikrivanje dodatnog koda.
- res/
- SadrÅ¾i resurse koji nisu kompajlirani u resources.arsc

### **Dalvik & Smali**

U Android razvoju, **Java ili Kotlin** se koriste za kreiranje aplikacija. Umesto koriÅ¡Ä‡enja JVM-a kao u desktop aplikacijama, Android kompajlira ovaj kod u **Dalvik Executable (DEX) bajtkod**. Ranije je Dalvik virtuelna maÅ¡ina upravljala ovim bajtkodom, ali sada, Android Runtime (ART) preuzima u novijim verzijama Androida.

Za obrnuto inÅ¾enjerstvo, **Smali** postaje kljuÄan. To je ljudski Äitljiva verzija DEX bajtkoda, koja deluje kao asembler prevodeÄ‡i izvorni kod u bajtkod instrukcije. Smali i baksmali se odnose na alate za asembler i disassembler u ovom kontekstu.

## Intenti

Intenti su primarni naÄin na koji Android aplikacije komuniciraju izmeÄ‘u svojih komponenti ili sa drugim aplikacijama. Ovi objekti poruka takoÄ‘e mogu nositi podatke izmeÄ‘u aplikacija ili komponenti, sliÄno kako se koriste GET/POST zahtevi u HTTP komunikaciji.

Dakle, Intent je u suÅ¡tini **poruka koja se prenosi izmeÄ‘u komponenti**. Intenti **mogu biti usmereni** ka specifiÄnim komponentama ili aplikacijama, **ili se mogu slati bez specifiÄnog primaoca**.\
Jednostavno reÄeno, Intent se moÅ¾e koristiti:

* Da pokrene Aktivnost, obiÄno otvarajuÄ‡i korisniÄki interfejs za aplikaciju
* Kao emitovanja da obavesti sistem i aplikacije o promenama
* Da pokrene, zaustavi i komunicira sa pozadinskom uslugom
* Da pristupi podacima putem ContentProviders
* Kao povratni pozivi za obradu dogaÄ‘aja

Ako su ranjivi, **Intenti se mogu koristiti za izvoÄ‘enje raznih napada**.

### Intent-Filter

**Intent Filteri** definiÅ¡u **kako aktivnost, usluga ili Broadcast Receiver mogu interagovati sa razliÄitim tipovima Intent-a**. U suÅ¡tini, oni opisuju moguÄ‡nosti ovih komponenti, kao Å¡to su koje akcije mogu izvrÅ¡iti ili koje vrste emitovanja mogu obraditi. Primarno mesto za deklarisanje ovih filtera je unutar **AndroidManifest.xml datoteke**, iako je za Broadcast Receivere kodiranje takoÄ‘e opcija.

Intent Filteri se sastoje od kategorija, akcija i filtera podataka, sa moguÄ‡noÅ¡Ä‡u ukljuÄivanja dodatnih metapodataka. Ova postavka omoguÄ‡ava komponentama da obrade specifiÄne Intente koji se poklapaju sa deklarisanim kriterijumima.

KritiÄan aspekt Android komponenti (aktivnosti/usluge/provideri sadrÅ¾aja/broadcast receiveri) je njihova vidljivost ili **javnost**. Komponenta se smatra javnom i moÅ¾e interagovati sa drugim aplikacijama ako je **`exported`** sa vrednoÅ¡Ä‡u **`true`** ili ako je za nju deklarisan Intent Filter u manifestu. MeÄ‘utim, postoji naÄin za programere da eksplicitno zadrÅ¾e ove komponente privatnim, osiguravajuÄ‡i da ne interaguju sa drugim aplikacijama nenamerno. Ovo se postiÅ¾e postavljanjem **`exported`** atributa na **`false`** u njihovim manifest definicijama.

Pored toga, programeri imaju opciju da dodatno osiguraju pristup ovim komponentama zahtevajuÄ‡i specifiÄne dozvole. **`permission`** atribut moÅ¾e biti postavljen da osigura da samo aplikacije sa dodeljenom dozvolom mogu pristupiti komponenti, dodajuÄ‡i dodatni sloj sigurnosti i kontrole nad tim ko moÅ¾e da interaguje sa njom.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implicit Intents

Intenti se programatski kreiraju koristeÄ‡i Intent konstruktor:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
The **Action** of the previously declared intent is **ACTION\_SEND** and the **Extra** is a mailto **Uri** (the Extra if the extra information the intent is expecting).

Ova namera treba da bude deklarisana unutar manifest-a kao u sledeÄ‡em primeru:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
An intent-filter treba da odgovara **akciji**, **podacima** i **kategoriji** da bi primio poruku.

Proces "rezolucije intencija" odreÄ‘uje koja aplikacija treba da primi svaku poruku. Ovaj proces uzima u obzir **atribut prioriteta**, koji moÅ¾e biti postavljen u **deklaraciji intent-filter-a**, i **ona sa viÅ¡im prioritetom Ä‡e biti odabrana**. Ovaj prioritet moÅ¾e biti postavljen izmeÄ‘u -1000 i 1000, a aplikacije mogu koristiti `SYSTEM_HIGH_PRIORITY` vrednost. Ako doÄ‘e do **konflikta**, pojavljuje se "chooser" prozor kako bi **korisnik mogao da odluÄi**.

### Eksplicitne Intencije

Eksplicitna intencija specificira naziv klase koju cilja:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
U drugim aplikacijama, da biste pristupili prethodno deklarisanom nameru, moÅ¾ete koristiti:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Ovi omoguÄ‡avaju drugim aplikacijama da **preduzimaju akcije u ime vaÅ¡e aplikacije**, koristeÄ‡i identitet i dozvole vaÅ¡e aplikacije. Prilikom konstruisanja Pending Intent-a, treba **navesti intent i akciju koja se izvrÅ¡ava**. Ako **deklarisani intent nije Eksplicitan** (ne navodi koji intent moÅ¾e da ga pozove), **maliciozna aplikacija bi mogla da izvrÅ¡i deklarisanu akciju** u ime Å¾rtvinske aplikacije. Å taviÅ¡e, **ako akcija nije navedena**, maliciozna aplikacija Ä‡e moÄ‡i da izvrÅ¡i **bilo koju akciju u ime Å¾rtve**.

### Broadcast Intents

Za razliku od prethodnih intent-a, koji se primaju samo od jedne aplikacije, broadcast intent-i **mogu biti primljeni od viÅ¡e aplikacija**. MeÄ‘utim, od API verzije 14, **moguÄ‡e je odrediti aplikaciju koja treba da primi** poruku koristeÄ‡i Intent.setPackage.

Alternativno, takoÄ‘e je moguÄ‡e **navesti dozvolu prilikom slanja broadcast-a**. Aplikacija primaoc Ä‡e morati da ima tu dozvolu.

Postoje **dva tipa** Broadcast-a: **Normalni** (asinkroni) i **PoruÄeni** (sinhroni). **Redosled** se zasniva na **konfigurisanoj prioritetu unutar elementa primaoca**. **Svaka aplikacija moÅ¾e obraditi, preneti ili odbaciti Broadcast.**

MoguÄ‡e je **poslati** **broadcast** koristeÄ‡i funkciju `sendBroadcast(intent, receiverPermission)` iz klase `Context`.\
TakoÄ‘e moÅ¾ete koristiti funkciju **`sendBroadcast`** iz **`LocalBroadCastManager`** koja osigurava da **poruka nikada ne napusti aplikaciju**. KoristeÄ‡i ovo, neÄ‡ete ni morati da izvozite komponentu primaoca.

### Sticky Broadcasts

Ova vrsta Broadcast-a **moÅ¾e se pristupiti dugo nakon Å¡to su poslati**.\
Oni su obeleÅ¾eni kao zastareli u API nivou 21 i preporuÄuje se da se **ne koriste**.\
**Oni omoguÄ‡avaju bilo kojoj aplikaciji da prisluÅ¡kuje podatke, ali i da ih modifikuje.**

Ako pronaÄ‘ete funkcije koje sadrÅ¾e reÄ "sticky" kao Å¡to su **`sendStickyBroadcast`** ili **`sendStickyBroadcastAsUser`**, **proverite uticaj i pokuÅ¡ajte da ih uklonite**.

## Deep links / URL schemes

U Android aplikacijama, **deep links** se koriste za pokretanje akcije (Intent) direktno putem URL-a. To se postiÅ¾e deklarisanjem specifiÄnog **URL shema** unutar aktivnosti. Kada Android ureÄ‘aj pokuÅ¡a da **pristupi URL-u sa ovom shemom**, odreÄ‘ena aktivnost unutar aplikacije se pokreÄ‡e.

Shema mora biti deklarisana u **`AndroidManifest.xml`** datoteci:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Å ema iz prethodnog primera je `exampleapp://` (obratite paÅ¾nju i na **`category BROWSABLE`**)

Zatim, u polju podataka, moÅ¾ete navesti **host** i **path**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Da biste mu pristupili putem veba, moguÄ‡e je postaviti link kao:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Da biste pronaÅ¡li **kod koji Ä‡e biti izvrÅ¡en u aplikaciji**, idite na aktivnost koju poziva deeplink i potraÅ¾ite funkciju **`onNewIntent`**.

Saznajte kako da [pozovete deep linkove bez koriÅ¡Ä‡enja HTML stranica](./#exploiting-schemes-deep-links).

## AIDL - Android Interfejs Definicija Jezika

**Android Interfejs Definicija Jezika (AIDL)** je dizajniran za olakÅ¡avanje komunikacije izmeÄ‘u klijenta i servisa u Android aplikacijama putem **interprocesne komunikacije** (IPC). PoÅ¡to direktan pristup memoriji drugog procesa nije dozvoljen na Androidu, AIDL pojednostavljuje proces marÅ¡alizovanjem objekata u format koji operativni sistem razume, Äime olakÅ¡ava komunikaciju izmeÄ‘u razliÄitih procesa.

### KljuÄni Koncepti

- **Povezani Servisi**: Ove usluge koriste AIDL za IPC, omoguÄ‡avajuÄ‡i aktivnostima ili komponentama da se poveÅ¾u sa servisom, Å¡alju zahteve i primaju odgovore. Metoda `onBind` u klasi servisa je kljuÄna za zapoÄinjanje interakcije, oznaÄavajuÄ‡i je kao vitalno podruÄje za bezbednosnu reviziju u potrazi za ranjivostima.

- **Messenger**: Kao povezani servis, Messenger olakÅ¡ava IPC sa fokusom na obradu podataka putem metode `onBind`. Bitno je paÅ¾ljivo pregledati ovu metodu zbog bilo kakvog nesigurnog rukovanja podacima ili izvrÅ¡avanja osetljivih funkcija.

- **Binder**: Iako je direktna upotreba klase Binder manje uobiÄajena zbog AIDL-ove apstrakcije, korisno je razumeti da Binder deluje kao drajver na nivou jezgra koji olakÅ¡ava prenos podataka izmeÄ‘u memorijskih prostora razliÄitih procesa. Za dalju pomoÄ‡, resurs je dostupan na [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponente

Ove ukljuÄuju: **Aktivnosti, Servise, Broadcast Receiver-e i Provajdere.**

### Aktivnost PokretaÄa i druge aktivnosti

U Android aplikacijama, **aktivnosti** su poput ekrana, prikazujuÄ‡i razliÄite delove korisniÄkog interfejsa aplikacije. Aplikacija moÅ¾e imati mnogo aktivnosti, od kojih svaka predstavlja jedinstveni ekran za korisnika.

**Aktivnost pokretaÄa** je glavni ulaz u aplikaciju, pokreÄ‡e se kada dodirnete ikonu aplikacije. Definisana je u manifest fajlu aplikacije sa specifiÄnim MAIN i LAUNCHER intencijama:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
ĞĞµÑ›Ğµ ÑĞ²Ğµ Ğ°Ğ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ˜Ğµ Ñ‚Ñ€ĞµĞ±Ğ°Ñ‚Ğ¸ Ğ»Ğ°Ğ½Ñ‡ĞµÑ€ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚, Ğ¿Ğ¾ÑĞµĞ±Ğ½Ğ¾ Ğ¾Ğ½Ğµ Ğ±ĞµĞ· ĞºĞ¾Ñ€Ğ¸ÑĞ½Ğ¸Ñ‡ĞºĞ¾Ğ³ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµÑ˜ÑĞ°, ĞºĞ°Ğ¾ ÑˆÑ‚Ğ¾ ÑÑƒ Ğ¿Ğ¾Ğ·Ğ°Ğ´Ğ¸Ğ½ÑĞºĞµ ÑƒÑĞ»ÑƒĞ³Ğµ.

ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¼Ğ¾Ğ³Ñƒ Ğ±Ğ¸Ñ‚Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ Ğ°Ğ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ˜Ğ°Ğ¼Ğ° Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ñ†ĞµÑĞ¸Ğ¼Ğ° Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°Ğ²Ğ°ÑšĞµĞ¼ ĞºĞ°Ğ¾ "Ğ¸Ğ·Ğ²Ğ¾Ğ·Ğ½Ğµ" Ñƒ Ğ¼Ğ°Ğ½Ğ¸Ñ„ĞµÑÑ‚Ñƒ. ĞĞ²Ğ° Ğ¿Ğ¾Ğ´ĞµÑˆĞ°Ğ²Ğ°ÑšĞ° Ğ¾Ğ¼Ğ¾Ğ³ÑƒÑ›Ğ°Ğ²Ğ°Ñ˜Ñƒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ Ğ°Ğ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ˜Ğ°Ğ¼Ğ° Ğ´Ğ° Ğ¿Ğ¾ĞºÑ€ĞµĞ½Ñƒ Ğ¾Ğ²Ñƒ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
MeÄ‘utim, pristupanje aktivnosti iz druge aplikacije nije uvek bezbednosni rizik. Briga se javlja ako se osetljivi podaci dele nepravilno, Å¡to moÅ¾e dovesti do curenja informacija.

Å½ivotni ciklus aktivnosti **poÄinje sa onCreate metodom**, postavljajuÄ‡i UI i pripremajuÄ‡i aktivnost za interakciju sa korisnikom.

### Podklasa Aplikacije

U Android razvoju, aplikacija ima opciju da kreira **podklasu** [Application](https://developer.android.com/reference/android/app/Application) klase, iako to nije obavezno. Kada je takva podklasa definisana, ona postaje prva klasa koja se instancira unutar aplikacije. **`attachBaseContext`** metoda, ako je implementirana u ovoj podklasi, izvrÅ¡ava se pre **`onCreate`** metode. Ova postavka omoguÄ‡ava ranu inicijalizaciju pre nego Å¡to ostatak aplikacije poÄne.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Services

[Services](https://developer.android.com/guide/components/services) su **pozadinski operativci** sposobni za izvrÅ¡avanje zadataka bez korisniÄkog interfejsa. Ovi zadaci mogu nastaviti da se izvrÅ¡avaju Äak i kada korisnici preÄ‘u na razliÄite aplikacije, Å¡to Äini servise kljuÄnim za **dugotrajne operacije**.

Servisi su svestrani; mogu se pokrenuti na razliÄite naÄine, pri Äemu su **Intents** primarna metoda za njihovo pokretanje kao ulaznu taÄku aplikacije. Kada se servis pokrene koristeÄ‡i metodu `startService`, njegova metoda `onStart` poÄinje da se izvrÅ¡ava i nastavlja da radi dok se eksplicitno ne pozove metoda `stopService`. Alternativno, ako je uloga servisa zavisna od aktivne klijentske veze, koristi se metoda `bindService` za povezivanje klijenta sa servisom, angaÅ¾ujuÄ‡i metodu `onBind` za prenos podataka.

Zanimljiva primena servisa ukljuÄuje reprodukciju muzike u pozadini ili preuzimanje mreÅ¾nih podataka bez ometanja interakcije korisnika sa aplikacijom. Å taviÅ¡e, servisi se mogu uÄiniti dostupnim drugim procesima na istom ureÄ‘aju putem **izvoza**. Ovo nije podrazumevano ponaÅ¡anje i zahteva eksplicitnu konfiguraciju u Android Manifest datoteci:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** deluju kao sluÅ¡atelji u sistemu poruka, omoguÄ‡avajuÄ‡i viÅ¡e aplikacija da reaguju na iste poruke iz sistema. Aplikacija moÅ¾e **registrovati prijemnik** na **dva osnovna naÄina**: kroz **Manifest** aplikacije ili **dinamiÄki** unutar koda aplikacije putem **`registerReceiver`** API-ja. U Manifestu, emitovanja se filtriraju sa dozvolama, dok dinamiÄki registrovani prijemnici takoÄ‘e mogu specificirati dozvole prilikom registracije.

**Intent filteri** su kljuÄni u obe metode registracije, odreÄ‘ujuÄ‡i koja emitovanja aktiviraju prijemnik. Kada se poÅ¡alje odgovarajuÄ‡e emitovanje, poziva se **`onReceive`** metoda prijemnika, omoguÄ‡avajuÄ‡i aplikaciji da reaguje u skladu sa tim, kao Å¡to je prilagoÄ‘avanje ponaÅ¡anja u odgovoru na upozorenje o niskoj bateriji.

Emitovanja mogu biti **asinhrona**, dostiÅ¾uÄ‡i sve prijemnike bez reda, ili **sinhrona**, gde prijemnici dobijaju emitovanje na osnovu postavljenih prioriteta. MeÄ‘utim, vaÅ¾no je napomenuti potencijalni bezbednosni rizik, jer svaka aplikacija moÅ¾e dati prioritet sebi da presretne emitovanje.

Da biste razumeli funkcionalnost prijemnika, potraÅ¾ite **`onReceive`** metodu unutar njegove klase. Kod ove metode moÅ¾e manipulisati primljenim Intentom, naglaÅ¡avajuÄ‡i potrebu za validacijom podataka od strane prijemnika, posebno u **Ordered Broadcasts**, koji mogu modifikovati ili odbaciti Intent.

### Content Provider

**Content Providers** su kljuÄni za **deljenje strukturiranih podataka** izmeÄ‘u aplikacija, naglaÅ¡avajuÄ‡i vaÅ¾nost implementacije **dozvola** za obezbeÄ‘ivanje bezbednosti podataka. Oni omoguÄ‡avaju aplikacijama da pristupaju podacima iz razliÄitih izvora, ukljuÄujuÄ‡i baze podataka, datoteÄne sisteme ili web. SpecifiÄne dozvole, kao Å¡to su **`readPermission`** i **`writePermission`**, su kljuÄne za kontrolu pristupa. Pored toga, privremeni pristup moÅ¾e biti odobren putem **`grantUriPermission`** podeÅ¡avanja u manifestu aplikacije, koristeÄ‡i atribute kao Å¡to su `path`, `pathPrefix` i `pathPattern` za detaljnu kontrolu pristupa.

Validacija unosa je od suÅ¡tinskog znaÄaja za spreÄavanje ranjivosti, kao Å¡to je SQL injekcija. Content Providers podrÅ¾avaju osnovne operacije: `insert()`, `update()`, `delete()`, i `query()`, olakÅ¡avajuÄ‡i manipulaciju i deljenje podataka meÄ‘u aplikacijama.

**FileProvider**, specijalizovani Content Provider, fokusira se na sigurno deljenje datoteka. Definisan je u manifestu aplikacije sa specifiÄnim atributima za kontrolu pristupa folderima, oznaÄenim sa `android:exported` i `android:resource` koji ukazuju na konfiguracije foldera. PreporuÄuje se oprez prilikom deljenja direktorijuma kako bi se izbeglo nenamerno izlaganje osetljivih podataka.

Primer deklaracije manifesta za FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
I primer specifikovanja deljenih foldera u `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
For further information check:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews su kao **mini web pregledaÄi** unutar Android aplikacija, koji preuzimaju sadrÅ¾aj ili sa interneta ili iz lokalnih datoteka. SuoÄen su sa sliÄnim rizicima kao obiÄni pregledaÄi, ali postoje naÄini da se **smanje ovi rizici** kroz specifiÄne **postavke**.

Android nudi dva glavna tipa WebView:

- **WebViewClient** je odliÄan za osnovni HTML, ali ne podrÅ¾ava JavaScript alert funkciju, Å¡to utiÄe na to kako se XSS napadi mogu testirati.
- **WebChromeClient** deluje viÅ¡e kao potpuno iskustvo Chrome pregledaÄa.

KljuÄna taÄka je da WebView pregledaÄi **ne dele kolaÄiÄ‡e** sa glavnim pregledaÄem ureÄ‘aja.

Za uÄitavanje sadrÅ¾aja, dostupne su metode kao Å¡to su ````loadUrl````, ````loadData````, i ````loadDataWithBaseURL````. KljuÄno je osigurati da su ovi URL-ovi ili datoteke **sigurni za koriÅ¡Ä‡enje**. Bezbednosne postavke mogu se upravljati putem ````WebSettings```` klase. Na primer, onemoguÄ‡avanje JavaScripta sa ````setJavaScriptEnabled(false)```` moÅ¾e spreÄiti XSS napade.

JavaScript "Bridge" omoguÄ‡ava Java objektima da komuniciraju sa JavaScript-om, zahtevajuÄ‡i da metode budu oznaÄene sa ````@JavascriptInterface```` radi bezbednosti od Android 4.2 nadalje.

Dozvoljavanje pristupa sadrÅ¾aju (````setAllowContentAccess(true)````) omoguÄ‡ava WebViews pristup Content Providers, Å¡to moÅ¾e predstavljati rizik osim ako su URL-ovi sadrÅ¾aja verifikovani kao sigurni.

Da biste kontrolisali pristup datotekama:
- OnemoguÄ‡avanje pristupa datotekama (````setAllowFileAccess(false)````) ograniÄava pristup datoteÄnom sistemu, sa izuzecima za odreÄ‘ene resurse, osiguravajuÄ‡i da se koriste samo za nesenzitivni sadrÅ¾aj.

## Other App Components and Mobile Device Management

### **Digital Signing of Applications**

- **Digitalno potpisivanje** je obavezno za Android aplikacije, osiguravajuÄ‡i da su **autentiÄno napisane** pre instalacije. Ovaj proces koristi sertifikat za identifikaciju aplikacije i mora biti verifikovan od strane menadÅ¾era paketa ureÄ‘aja prilikom instalacije. Aplikacije mogu biti **samo-potpisane ili sertifikovane od strane eksternog CA**, Å¡titeÄ‡i od neovlaÅ¡Ä‡enog pristupa i osiguravajuÄ‡i da aplikacija ostane neizmenjena tokom isporuke na ureÄ‘aj.

### **App Verification for Enhanced Security**

- PoÄevÅ¡i od **Android 4.2**, funkcija pod nazivom **Verifikacija aplikacija** omoguÄ‡ava korisnicima da provere aplikacije za bezbednost pre instalacije. Ovaj **proces verifikacije** moÅ¾e upozoriti korisnike na potencijalno Å¡tetne aplikacije, ili Äak spreÄiti instalaciju posebno zlonamernih, poboljÅ¡avajuÄ‡i bezbednost korisnika.

### **Mobile Device Management (MDM)**

- **MDM reÅ¡enja** pruÅ¾aju **nadzor i bezbednost** za mobilne ureÄ‘aje putem **Device Administration API**. Oni zahtevaju instalaciju Android aplikacije za efikasno upravljanje i obezbeÄ‘ivanje mobilnih ureÄ‘aja. KljuÄne funkcije ukljuÄuju **sprovoÄ‘enje politika lozinki**, **obavezno Å¡ifrovanje skladiÅ¡ta**, i **dozvoljavanje daljinskog brisanja podataka**, osiguravajuÄ‡i sveobuhvatan nadzor i bezbednost nad mobilnim ureÄ‘ajima.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
