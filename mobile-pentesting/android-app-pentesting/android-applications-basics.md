# Osnove Android aplikacija

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

PronaÄ‘ite najvaÅ¾nije ranjivosti kako biste ih brÅ¾e popravili. Intruder prati vaÅ¡u povrÅ¡inu napada, pokreÄ‡e proaktivne pretrage pretnji, pronalazi probleme u celom vaÅ¡em tehnoloÅ¡kom skupu, od API-ja do veb aplikacija i sistemima u oblaku. [**Isprobajte ga besplatno**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) danas.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Android Security Model

**Postoje dva sloja:**

* **Operativni sistem (OS)**, koji drÅ¾i instalirane aplikacije izolovane jednu od druge.
* **Sama aplikacija**, koja omoguÄ‡ava programerima da **izloÅ¾e odreÄ‘ene funkcionalnosti** i konfiguriÅ¡u moguÄ‡nosti aplikacije.

### Odvajanje UID-a

**Svaka aplikacija ima dodeljen specifiÄan User ID**. To se radi prilikom instalacije aplikacije kako bi aplikacija mogla da komunicira samo sa datotekama koje su u vlasniÅ¡tvu njenog User ID-a ili deljenim datotekama. Samim tim, samo aplikacija, odreÄ‘eni delovi operativnog sistema i korisnik sa root privilegijama mogu pristupiti podacima aplikacije.

### Deljenje UID-a

**Dve aplikacije mogu biti konfigurisane da koriste isti UID**. Ovo moÅ¾e biti korisno za deljenje informacija, ali ako je jedna od njih kompromitovana, podaci obe aplikacije Ä‡e biti kompromitovani. Zbog toga se ovo ponaÅ¡anje **odvraÄ‡a**.\
**Da bi delile isti UID, aplikacije moraju definisati istu vrednost `android:sharedUserId` u svojim manifestima.**

### Izolacija

**Android Application Sandbox** omoguÄ‡ava pokretanje **svake aplikacije** kao **posebnog procesa pod posebnim User ID-om**. Svaki proces ima svoju virtuelnu maÅ¡inu, tako da kod aplikacije radi izolovano od drugih aplikacija.\
Od Androida 5.0(L) **SELinux** je primenjen. U osnovi, SELinux odbija sve interakcije izmeÄ‘u procesa, a zatim kreira politike koje **dopuÅ¡taju samo oÄekivane interakcije izmeÄ‘u njih**.

### Dozvole

Kada instalirate **aplikaciju i ona zatraÅ¾i dozvole**, aplikacija traÅ¾i dozvole konfigurisane u elementima **`uses-permission`** u fajlu **AndroidManifest.xml**. Element **uses-permission** oznaÄava ime traÅ¾ene dozvole unutar atributa **name**. TakoÄ‘e ima atribut **maxSdkVersion** koji zaustavlja traÅ¾enje dozvola na verzijama viÅ¡im od navedene.\
Imajte na umu da android aplikacije ne moraju traÅ¾iti sve dozvole odmah, mogu **dinamiÄki traÅ¾iti dozvole**, ali sve dozvole moraju biti **deklarisane** u manifestu.

Kada aplikacija izlaÅ¾e funkcionalnost, moÅ¾e ograniÄiti **pristup samo aplikacijama koje imaju odreÄ‘enu dozvolu**.\
Element dozvole ima tri atributa:

* **name** dozvole
* atribut **permission-group**, koji omoguÄ‡ava grupisanje srodnih dozvola.
* **protection-level** koji oznaÄava kako se dozvole dodeljuju. Postoje Äetiri vrste:
* **Normal**: Koristi se kada nema **poznatih pretnji** aplikaciji. Korisniku **nije potrebno odobrenje**.
* **Opasno**: OznaÄava da dozvola daje traÅ¾enoj aplikaciji **poviÅ¡en pristup**. **Korisnici su zamoljeni da ih odobre**.
* **Potpis**: Samo **aplikacije potpisane istim sertifikatom kao i ona** koja izvozi komponentu mogu dobiti dozvolu. Ovo je najjaÄi tip zaÅ¡tite.
* **PotpisIliSistem**: Samo **aplikacije potpisane istim sertifikatom kao i ona** koja izvozi komponentu ili **aplikacije koje se izvrÅ¡avaju sa sistemskim pristupom** mogu dobiti dozvole.

## Preinstalirane aplikacije

Ove aplikacije se obiÄno nalaze u direktorijumima **`/system/app`** ili **`/system/priv-app`** i neke od njih su **optimizovane** (moÅ¾da Äak neÄ‡ete pronaÄ‡i `classes.dex` fajl). Ove aplikacije vredi proveriti jer su nekada **pokrenute sa previÅ¡e dozvola** (kao root).

* One koje dolaze sa **AOSP** (Android OpenSource Project) **ROM-om**
* Dodate od strane **proizvoÄ‘aÄa ureÄ‘aja**
* Dodate od strane **provajdera mobilne telefonije** (ako ste ih kupili od njih)

## Rootovanje

Da biste dobili root pristup fiziÄkom Android ureÄ‘aju, obiÄno morate **iskoristiti** 1 ili 2 **ranjivosti** koje su obiÄno **specifiÄne** za **ureÄ‘aj** i **verziju**.\
Kada iskoriÅ¡Ä‡avanje uspe, obiÄno se Linux `su` binarni fajl kopira na lokaciju koja je navedena u PATH env promenljivoj korisnika, kao Å¡to je `/system/xbin`.

Kada je su binarni fajl konfigurisan, druga Android aplikacija se koristi za interakciju sa `su` binarnim fajlom i **obradu zahteva za root pristup** kao Å¡to su **Superuser** i **SuperSU** (dostupne u Google Play prodavnici).

{% hint style="danger" %}
Imajte na umu da je proces rootovanja veoma opasan i moÅ¾e ozbiljno oÅ¡tetiti ureÄ‘aj.
{% endhint %}

### ROM-ovi

MoguÄ‡e je **zameniti operativni sistem instaliranjem prilagoÄ‘enog firmvera**. Time je moguÄ‡e proÅ¡iriti upotrebljivost starog ureÄ‘aja, zaobiÄ‡i softverska ograniÄenja ili dobiti pristup najnovijem Android kodu.\
**OmniROM** i **LineageOS** su dva od najpopularnijih firmvera koje moÅ¾ete koristiti.

Imajte na umu da **nije uvek potrebno rootovati ureÄ‘aj** da biste instalirali prilagoÄ‘eni firmver. **Neki proizvoÄ‘aÄi dozvoljavaju** otkljuÄavanje nj
### **Dalvik i Smali**

U Android razvoju, koristi se **Java ili Kotlin** za kreiranje aplikacija. Umesto koriÅ¡Ä‡enja JVM-a kao u desktop aplikacijama, Android kompajlira ovaj kod u **Dalvik izvrÅ¡ni (DEX) bajtkod**. Ranije je Dalvik virtuelna maÅ¡ina obraÄ‘ivala ovaj bajtkod, ali sada Android Runtime (ART) preuzima tu ulogu u novijim verzijama Androida.

Za obrnuti inÅ¾enjering, kljuÄan je **Smali**. To je Äitljiva verzija DEX bajtkoda koja deluje kao asemblerski jezik prevodeÄ‡i izvorni kod u instrukcije bajtkoda. Smali i baksmali se odnose na alate za asembliranje i rasklapanje u ovom kontekstu.


***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

PronaÄ‘ite najvaÅ¾nije ranjivosti kako biste ih brÅ¾e popravili. Intruder prati vaÅ¡u povrÅ¡inu napada, pokreÄ‡e proaktivne pretnje, pronalazi probleme u celom vaÅ¡em tehnoloÅ¡kom skupu, od API-ja do veb aplikacija i sistemima u oblaku. [**Isprobajte besplatno**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) danas.

***

## Intents

Intents su osnovni naÄin komunikacije izmeÄ‘u komponenti Android aplikacija ili sa drugim aplikacijama. Ovi objekti poruka takoÄ‘e mogu prenositi podatke izmeÄ‘u aplikacija ili komponenti, sliÄno kao Å¡to se GET/POST zahtevi koriste u HTTP komunikaciji.

Dakle, Intent je u osnovi **poruka koja se prenosi izmeÄ‘u komponenti**. Intenti **mogu biti usmereni** ka odreÄ‘enim komponentama ili aplikacijama, **ili mogu biti poslati bez odreÄ‘enog primaoca**.\
Da bismo bili jednostavni, Intent se moÅ¾e koristiti:

* Za pokretanje aktivnosti, obiÄno otvaranje korisniÄkog interfejsa za aplikaciju
* Kao emitovanje da obavesti sistem i aplikacije o promenama
* Za pokretanje, zaustavljanje i komunikaciju sa pozadinskom uslugom
* Za pristup podacima putem ContentProvidera
* Kao povratni poziv za obradu dogaÄ‘aja

Ako su ranjivi, **Intenti se mogu koristiti za izvoÄ‘enje razliÄitih napada**.

### Intent-Filter

**Intent Filteri** definiÅ¡u **kako aktivnost, usluga ili prijemnik emitovanja mogu da komuniciraju sa razliÄitim vrstama Intenta**. U osnovi, opisuju moguÄ‡nosti ovih komponenti, kao Å¡to su koje akcije mogu izvrÅ¡iti ili vrste emitovanja koje mogu obraditi. Glavno mesto za deklarisanje ovih filtera je unutar **AndroidManifest.xml fajla**, iako je kodiranje za prijemnike emitovanja takoÄ‘e opcija.

Intent Filteri se sastoje od kategorija, akcija i filtera podataka, sa moguÄ‡noÅ¡Ä‡u ukljuÄivanja dodatnih metapodataka. Ova postavka omoguÄ‡ava komponentama da obrade odreÄ‘ene Intente koji se podudaraju sa deklarisanim kriterijumima.

KljuÄni aspekt Android komponenti (aktivnosti/usluga/content providera/prijemnika emitovanja) je njihova vidljivost ili **javni status**. Komponenta se smatra javnom i moÅ¾e da komunicira sa drugim aplikacijama ako je **`exported`** sa vrednoÅ¡Ä‡u **`true`** ili ako je za nju deklarisan Intent Filter u manifestu. MeÄ‘utim, programeri imaju naÄin da eksplicitno zadrÅ¾e ove komponente privatnim, kako bi se osiguralo da ne komuniciraju sa drugim aplikacijama nenamerno. To se postiÅ¾e postavljanjem atributa **`exported`** na **`false`** u njihovim definicijama manifesta.

Osim toga, programeri imaju moguÄ‡nost da dodatno obezbede pristup ovim komponentama zahtevanjem odreÄ‘enih dozvola. Atribut **`permission`** moÅ¾e biti postavljen da bi se obezbedilo da samo aplikacije sa odreÄ‘enom dozvolom mogu pristupiti komponenti, dodajuÄ‡i dodatni sloj sigurnosti i kontrole nad tim ko moÅ¾e da komunicira sa njom.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implicitni nameni

Namerama se programski kreiraju koristeÄ‡i konstruktor Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Akcija** prethodno deklarisane namere je **ACTION\_SEND**, a **Dodatno** je mailto **Uri** (Dodatno je dodatne informacije koje namera oÄekuje).

Ova namera treba da bude deklarisana u manifestu kao u sledeÄ‡em primeru:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Jedan intent-filter mora se podudarati sa **akcijom**, **podacima** i **kategorijom** kako bi primio poruku.

Proces "RazreÅ¡enje namere" odreÄ‘uje koja aplikacija treba da primi svaku poruku. Ovaj proces uzima u obzir **prioritetni atribut**, koji se moÅ¾e postaviti u deklaraciji **intent-filtera**, i **selektuje onu sa veÄ‡im prioritetom**. Ovaj prioritet moÅ¾e biti postavljen izmeÄ‘u -1000 i 1000, a aplikacije mogu koristiti vrednost `SYSTEM_HIGH_PRIORITY`. U sluÄaju **sukoba**, pojavljuje se prozor "izbora" kako bi **korisnik odluÄio**.

### Eksplicitne namere

Eksplicitna namera specificira ime klase koju cilja:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
U drugim aplikacijama, kako biste pristupili prethodno deklarisanoj nameri, moÅ¾ete koristiti:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Ove dozvoljavaju drugim aplikacijama da **preduzmu radnje u ime vaÅ¡e aplikacije**, koristeÄ‡i identitet i dozvole vaÅ¡e aplikacije. Prilikom konstrukcije Pending Intenta, treba **navesti nameru i radnju koju treba izvrÅ¡iti**. Ako **deklarisana namera nije eksplicitna** (ne navodi koja namera moÅ¾e da je pozove), **zlonamerna aplikacija moÅ¾e izvrÅ¡iti deklarisanu radnju** u ime aplikacije Å¾rtve. Osim toga, **ako radnja nije navedena**, zlonamerna aplikacija Ä‡e moÄ‡i da izvrÅ¡i **bilo koju radnju u ime Å¾rtve**.

### Broadcast Intents

Za razliku od prethodnih namera, koje prima samo jedna aplikacija, broadcast namera **moÅ¾e biti primljena od strane viÅ¡e aplikacija**. MeÄ‘utim, od verzije API 14, moguÄ‡e je **navesti aplikaciju koja treba da primi** poruku koristeÄ‡i Intent.setPackage.

Alternativno, moguÄ‡e je **navesti dozvolu prilikom slanja broadcasta**. Aplikacija koja prima broadcast mora imati tu dozvolu.

Postoje **dva tipa** broadcasta: **Normalni** (asinhroni) i **Poredani** (sinhroni). **Redosled** se zasniva na **konfigurisanoj prioritetu unutar elementa koji prima**. **Svaka aplikacija moÅ¾e obraditi, proslediti ili odbaciti broadcast**.

MoguÄ‡e je **poslati** broadcast koristeÄ‡i funkciju `sendBroadcast(intent, receiverPermission)` iz klase `Context`.\
TakoÄ‘e se moÅ¾e koristiti funkcija **`sendBroadcast`** iz **`LocalBroadCastManager`** koja osigurava da **poruka ne napusti aplikaciju**. KoriÅ¡Ä‡enjem ove funkcije Äak nije potrebno izvoziti komponentu koja prima broadcast.

### Lepkavi (Sticky) Broadcasti

Ova vrsta broadcasta **moÅ¾e se pristupiti dugo vremena nakon Å¡to su poslati**.\
Ovi broadcasti su zastareli od API nivoa 21 i **nije preporuÄljivo koristiti ih**.\
**Dozvoljavaju svakoj aplikaciji da prisluÅ¡kuje podatke, ali i da ih menja**.

Ako pronaÄ‘ete funkcije koje sadrÅ¾e reÄ "sticky" kao Å¡to su **`sendStickyBroadcast`** ili **`sendStickyBroadcastAsUser`**, **proverite uticaj i pokuÅ¡ajte da ih uklonite**.

## Duboke veze / URL Å¡eme

U Android aplikacijama, **duboke veze** se koriste za pokretanje akcije (Intent) direktno putem URL-a. To se postiÅ¾e deklarisanjem specifiÄne **URL Å¡eme** unutar aktivnosti. Kada Android ureÄ‘aj pokuÅ¡a **pristupiti URL-u sa ovom Å¡emom**, pokreÄ‡e se odgovarajuÄ‡a aktivnost unutar aplikacije.

Å ema se mora deklarisati u datoteci **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Å ema iz prethodnog primera je `exampleapp://` (takoÄ‘e obratite paÅ¾nju na **`category BROWSABLE`**)

Zatim, u polju podataka, moÅ¾ete navesti **host** i **putanju**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Da biste mu pristupili putem veba, moguÄ‡e je postaviti link kao:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Da biste pronaÅ¡li **kod koji Ä‡e se izvrÅ¡iti u aplikaciji**, idite na aktivnost koju poziva dubinska veza i potraÅ¾ite funkciju **`onNewIntent`**.

Saznajte kako [pozvati dubinske veze bez koriÅ¡Ä‡enja HTML stranica](./#exploiting-schemes-deep-links).

## AIDL - Android jezik definicije interfejsa

**Android jezik definicije interfejsa (AIDL)** je dizajniran za olakÅ¡avanje komunikacije izmeÄ‘u klijenta i servisa u Android aplikacijama putem **interprocesne komunikacije** (IPC). BuduÄ‡i da direktni pristup memoriji druge procesa nije dozvoljen na Androidu, AIDL pojednostavljuje proces marshalinga objekata u format koji razume operativni sistem, olakÅ¡avajuÄ‡i komunikaciju izmeÄ‘u razliÄitih procesa.

### KljuÄni koncepti

- **Bound servisi**: Ovi servisi koriste AIDL za IPC, omoguÄ‡avajuÄ‡i aktivnostima ili komponentama da se poveÅ¾u sa servisom, Å¡alju zahteve i primaju odgovore. Metoda `onBind` u klasi servisa je kljuÄna za pokretanje interakcije, Å¡to je vaÅ¾no podruÄje za pregled bezbednosti u potrazi za ranjivostima.

- **Messenger**: Kao vezani servis, Messenger olakÅ¡ava IPC sa fokusom na obradi podataka putem metode `onBind`. VaÅ¾no je paÅ¾ljivo pregledati ovu metodu radi otkrivanja nebezbednog rukovanja podacima ili izvrÅ¡avanja osetljivih funkcija.

- **Binder**: Iako je direktna upotreba klase Binder manje uobiÄajena zbog apstrakcije AIDL-a, korisno je razumeti da Binder deluje kao drajver na nivou jezgra koji olakÅ¡ava prenos podataka izmeÄ‘u memorijskih prostora razliÄitih procesa. Za dalje razumevanje, dostupan je resurs na adresi [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponente

To ukljuÄuje: **Aktivnosti, Servise, Prijemnike emitovanja i Provajdere.**

### PokretaÄka aktivnost i druge aktivnosti

U Android aplikacijama, **aktivnosti** su kao ekrani koji prikazuju razliÄite delove korisniÄkog interfejsa aplikacije. Aplikacija moÅ¾e imati mnogo aktivnosti, prikazujuÄ‡i svaka jedinstveni ekran korisniku.

**PokretaÄka aktivnost** je glavni ulaz u aplikaciju, pokreÄ‡e se kada dodirnete ikonu aplikacije. Definisana je u manifest fajlu aplikacije sa specifiÄnim MAIN i LAUNCHER namerama:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nisu sve aplikacije potrebne za pokretanje aktivnosti, posebno one bez korisniÄkog interfejsa, poput pozadinskih usluga.

Aktivnosti mogu biti dostupne drugim aplikacijama ili procesima oznaÄavanjem kao "izloÅ¾ene" u manifestu. Ovo podeÅ¡avanje omoguÄ‡ava drugim aplikacijama da pokrenu ovu aktivnost:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
MeÄ‘utim, pristupanje aktivnosti iz druge aplikacije nije uvijek sigurnosni rizik. Briga se javlja ako se osjetljivi podaci dijele na nepravilan naÄin, Å¡to moÅ¾e dovesti do curenja informacija.

Å½ivotni ciklus aktivnosti **poÄinje s onCreate metodom**, postavljanjem korisniÄkog suÄelja i pripremom aktivnosti za interakciju s korisnikom.

### Podklasa aplikacije

U Android razvoju, aplikacija ima moguÄ‡nost stvaranja **podklase** klase [Application](https://developer.android.com/reference/android/app/Application), iako to nije obavezno. Kada je takva podklasa definirana, postaje prva klasa koja se instancira unutar aplikacije. Metoda **`attachBaseContext`**, ako je implementirana u ovoj podklasi, izvrÅ¡ava se prije metode **`onCreate`**. Ova postavka omoguÄ‡ava ranu inicijalizaciju prije nego Å¡to ostatak aplikacije zapoÄne.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Usluge

[Usluge](https://developer.android.com/guide/components/services) su **pozadinski operativci** sposobni da izvrÅ¡avaju zadatke bez korisniÄkog interfejsa. Ovi zadaci mogu nastaviti da se izvrÅ¡avaju Äak i kada korisnici prelaze na druge aplikacije, Å¡to Äini usluge kljuÄnim za **dugotrajne operacije**.

Usluge su veoma fleksibilne; mogu se pokrenuti na razliÄite naÄine, pri Äemu su **Intents** primarni naÄin za njihovo pokretanje kao ulaznu taÄku aplikacije. Kada se usluga pokrene koristeÄ‡i `startService` metod, njen `onStart` metod se aktivira i nastavlja sa izvrÅ¡avanjem sve dok se eksplicitno ne pozove `stopService` metod. Alternativno, ako je uloga usluge uslovljena aktivnom konekcijom sa klijentom, koristi se `bindService` metod za povezivanje klijenta sa uslugom, pri Äemu se koristi `onBind` metod za prenos podataka.

Interesantna primena usluga ukljuÄuje reprodukciju pozadinske muzike ili preuzimanje mreÅ¾nih podataka bez ometanja interakcije korisnika sa aplikacijom. Osim toga, usluge mogu biti dostupne drugim procesima na istom ureÄ‘aju putem **izvoza**. Ovo nije podrazumevano ponaÅ¡anje i zahteva eksplicitnu konfiguraciju u Android Manifest fajlu:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast prijemnici

**Broadcast prijemnici** deluju kao sluÅ¡aoci u sistemima za razmenu poruka, omoguÄ‡avajuÄ‡i viÅ¡e aplikacija da odgovore na iste poruke od sistema. Aplikacija moÅ¾e **registrovati prijemnik** na **dva osnovna naÄina**: putem **Manifesta** aplikacije ili **dinamiÄki** unutar koda aplikacije putem **`registerReceiver`** API-ja. U Manifestu, emitovanja se filtriraju sa dozvolama, dok dinamiÄki registrovani prijemnici takoÄ‘e mogu specificirati dozvole prilikom registracije.

**Intent filteri** su kljuÄni u oba naÄina registracije, odreÄ‘ujuÄ‡i koja emitovanja pokreÄ‡u prijemnik. Kada se Å¡alje odgovarajuÄ‡e emitovanje, poziva se metoda **`onReceive`** prijemnika, omoguÄ‡avajuÄ‡i aplikaciji da reaguje adekvatno, kao Å¡to je prilagoÄ‘avanje ponaÅ¡anja u odgovoru na upozorenje o niskom nivou baterije.

Emitovanja mogu biti ili **asinhrona**, doseÅ¾uÄ‡i sve prijemnike bez redosleda, ili **sinkrona**, gde prijemnici dobijaju emitovanje na osnovu postavljenih prioriteta. MeÄ‘utim, vaÅ¾no je napomenuti potencijalni sigurnosni rizik, jer svaka aplikacija moÅ¾e sebe prioritetizovati kako bi presrela emitovanje.

Da biste razumeli funkcionalnost prijemnika, potraÅ¾ite metodu **`onReceive`** unutar njegove klase. Kod ove metode moÅ¾e manipulisati primljenim Intentom, Å¡to istiÄe potrebu za validacijom podataka od strane prijemnika, posebno kod **uredjenih emitovanja**, koja mogu izmeniti ili odbaciti Intent.

### Provajder sadrÅ¾aja

**Provajderi sadrÅ¾aja** su kljuÄni za **deljenje strukturiranih podataka** izmeÄ‘u aplikacija, naglaÅ¡avajuÄ‡i vaÅ¾nost implementiranja **dozvola** kako bi se osigurala sigurnost podataka. Oni omoguÄ‡avaju aplikacijama pristup podacima iz razliÄitih izvora, ukljuÄujuÄ‡i baze podataka, fajl sisteme ili veb. SpecifiÄne dozvole, poput **`readPermission`** i **`writePermission`**, su kljuÄne za kontrolu pristupa. Dodatno, privremeni pristup moÅ¾e biti odobren putem podeÅ¡avanja **`grantUriPermission`** u manifestu aplikacije, koristeÄ‡i atribute kao Å¡to su `path`, `pathPrefix` i `pathPattern` za detaljnu kontrolu pristupa.

Validacija unosa je od suÅ¡tinskog znaÄaja kako bi se spreÄile ranjivosti, poput SQL ubacivanja. Provajderi sadrÅ¾aja podrÅ¾avaju osnovne operacije: `insert()`, `update()`, `delete()` i `query()`, olakÅ¡avajuÄ‡i manipulaciju podacima i deljenje meÄ‘u aplikacijama.

**FileProvider**, specijalizovani Provajder sadrÅ¾aja, fokusira se na sigurno deljenje fajlova. DefiniÅ¡e se u manifestu aplikacije sa specifiÄnim atributima za kontrolu pristupa fasciklama, oznaÄenim sa `android:exported` i `android:resource` koji pokazuju na konfiguracije fascikli. Oprez se preporuÄuje prilikom deljenja direktorijuma kako bi se izbeglo sluÄajno otkrivanje osetljivih podataka.

Primer deklaracije manifesta za FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
I primer za specificiranje deljenih foldera u `filepaths.xml` datoteci:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Za dodatne informacije pogledajte:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews su kao **mini web pregledaÄi** unutar Android aplikacija, koji prikazuju sadrÅ¾aj sa weba ili lokalnih datoteka. Oni se suoÄavaju sa sliÄnim rizicima kao i obiÄni pregledaÄi, ali postoje naÄini da se **smanje ovi rizici** putem odreÄ‘enih **postavki**.

Android nudi dva glavna tipa WebView-a:

- **WebViewClient** je odliÄan za osnovni HTML, ali ne podrÅ¾ava JavaScript alert funkciju, Å¡to utiÄe na testiranje XSS napada.
- **WebChromeClient** se ponaÅ¡a viÅ¡e kao puna Chrome pregledaÄka iskustvo.

KljuÄna stvar je da WebView pregledaÄi **ne dele kolaÄiÄ‡e** sa glavnim pregledaÄem ureÄ‘aja.

Za uÄitavanje sadrÅ¾aja dostupne su metode poput ````loadUrl````, ````loadData````, i ````loadDataWithBaseURL````. VaÅ¾no je osigurati da su ovi URL-ovi ili datoteke **sigurne za upotrebu**. Postavke sigurnosti mogu se upravljati putem klase ````WebSettings````. Na primer, onemoguÄ‡avanje JavaScript-a sa ````setJavaScriptEnabled(false)```` moÅ¾e spreÄiti XSS napade.

JavaScript "Bridge" omoguÄ‡ava Java objektima da komuniciraju sa JavaScript-om, zahtevajuÄ‡i da se metode obeleÅ¾e sa ````@JavascriptInterface```` radi sigurnosti od Android verzije 4.2 nadalje.

Dozvoljavanje pristupa sadrÅ¾aju (````setAllowContentAccess(true)````) omoguÄ‡ava WebViews da pristupe Content Providerima, Å¡to moÅ¾e predstavljati rizik osim ako se URL-ovi sadrÅ¾aja ne verifikuju kao sigurni.

Da biste kontrolisali pristup datotekama:
- OnemoguÄ‡avanje pristupa datotekama (````setAllowFileAccess(false)````) ograniÄava pristup datoteÄnom sistemu, sa izuzecima za odreÄ‘ene resurse, osiguravajuÄ‡i da se koriste samo za neosetljiv sadrÅ¾aj.

## Ostale komponente aplikacija i upravljanje mobilnim ureÄ‘ajima

### **Digitalno potpisivanje aplikacija**

- **Digitalno potpisivanje** je neophodno za Android aplikacije, osiguravajuÄ‡i da su **autentiÄno autorisane** pre instalacije. Ovaj proces koristi sertifikat za identifikaciju aplikacije i mora biti verifikovan od strane upravljaÄa paketa ureÄ‘aja prilikom instalacije. Aplikacije mogu biti **samopotpisane ili sertifikovane od strane eksternog CA**, Äime se Å¡tite od neovlaÅ¡Ä‡enog pristupa i osigurava da aplikacija ostane nepromenjena tokom isporuke na ureÄ‘aj.

### **Provera aplikacija za poboljÅ¡anu sigurnost**

- PoÄevÅ¡i od **Android 4.2**, funkcija nazvana **Provera aplikacija** omoguÄ‡ava korisnicima da provere sigurnost aplikacija pre instalacije. Ovaj **proces provere** moÅ¾e upozoriti korisnike na potencijalno Å¡tetne aplikacije ili Äak spreÄiti instalaciju posebno zlonamernih aplikacija, poboljÅ¡avajuÄ‡i sigurnost korisnika.

### **Upravljanje mobilnim ureÄ‘ajima (MDM)**

- **MDM reÅ¡enja** pruÅ¾aju nadzor i sigurnost za mobilne ureÄ‘aje putem **Device Administration API-ja**. Ona zahtevaju instalaciju Android aplikacije radi efikasnog upravljanja i osiguranja mobilnih ureÄ‘aja. KljuÄne funkcije ukljuÄuju **nametanje politika lozinki**, **obavezno Å¡ifrovanje skladiÅ¡ta** i **dozvolu za daljinsko brisanje podataka**, obezbeÄ‘ujuÄ‡i sveobuhvatnu kontrolu i sigurnost nad mobilnim ureÄ‘ajima.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

PronaÄ‘ite najvaÅ¾nije ranjivosti kako biste ih brÅ¾e popravili. Intruder prati vaÅ¡u povrÅ¡inu napada, pokreÄ‡e proaktivno skeniranje pretnji, pronalazi probleme u celom vaÅ¡em tehnoloÅ¡kom sklopu, od API-ja do veb aplikacija i sistemima u oblaku. [**Isprobajte besplatno**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) danas.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju oglaÅ¡enu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
