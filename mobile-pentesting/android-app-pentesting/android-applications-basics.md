# Android-Anwendungsgrundlagen

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## Android-Sicherheitsmodell

**Es gibt zwei Ebenen:**

* Das **Betriebssystem**, das installierte Anwendungen voneinander isoliert.
* Die **Anwendung selbst**, die es Entwicklern erm√∂glicht, **bestimmte Funktionen freizugeben** und die Anwendungsf√§higkeiten zu konfigurieren.

### UID-Trennung

**Jede Anwendung erh√§lt eine spezifische Benutzer-ID**. Dies geschieht w√§hrend der Installation der App, sodass **die App nur mit Dateien interagieren kann, die ihrer Benutzer-ID geh√∂ren oder freigegebene** Dateien sind. Daher k√∂nnen nur die App selbst, bestimmte Komponenten des Betriebssystems und der Root-Benutzer auf die Anwendungsdaten zugreifen.

### UID-Sharing

**Zwei Anwendungen k√∂nnen so konfiguriert werden, dass sie dieselbe UID verwenden**. Dies kann n√ºtzlich sein, um Informationen zu teilen, aber wenn eine von ihnen kompromittiert wird, sind die Daten beider Anwendungen gef√§hrdet. Aus diesem Grund wird dieses Verhalten **abgeraten**.\
**Um dieselbe UID zu teilen, m√ºssen Anwendungen denselben `android:sharedUserId`-Wert in ihren Manifests definieren.**

### Sandboxing

Der **Android-Anwendungssandbox** erm√∂glicht es, **jede Anwendung** als **separaten Prozess unter einer separaten Benutzer-ID** auszuf√ºhren. Jeder Prozess hat seine eigene virtuelle Maschine, sodass der Code einer App isoliert von anderen Apps ausgef√ºhrt wird.\
Seit Android 5.0(L) wird **SELinux** durchgesetzt. Grunds√§tzlich verweigerte SELinux alle Prozessinteraktionen und erstellte dann Richtlinien, um **nur die erwarteten Interaktionen zwischen ihnen zuzulassen**.

### Berechtigungen

Wenn Sie eine **App installieren und sie nach Berechtigungen fragt**, fragt die App nach den Berechtigungen, die in den **`uses-permission`**-Elementen in der **AndroidManifest.xml**-Datei konfiguriert sind. Das **uses-permission**-Element gibt den Namen der angeforderten Berechtigung im **name**-Attribut an. Es hat auch das **maxSdkVersion**-Attribut, das das Anfordern von Berechtigungen in Versionen √ºber der angegebenen stoppt.\
Beachten Sie, dass Android-Anwendungen nicht alle Berechtigungen zu Beginn anfordern m√ºssen; sie k√∂nnen auch **dynamisch nach Berechtigungen fragen**, aber alle Berechtigungen m√ºssen im **Manifest** **deklarieren**.

Wenn eine App Funktionen freigibt, kann sie den **Zugriff nur auf Apps beschr√§nken, die √ºber eine bestimmte Berechtigung verf√ºgen**.\
Ein Berechtigungselement hat drei Attribute:

* Der **Name** der Berechtigung
* Das **permission-group**-Attribut, das das Gruppieren verwandter Berechtigungen erm√∂glicht.
* Das **protection-level**, das angibt, wie die Berechtigungen gew√§hrt werden. Es gibt vier Typen:
* **Normal**: Wird verwendet, wenn es **keine bekannten Bedrohungen** f√ºr die App gibt. Der Benutzer muss **es nicht genehmigen**.
* **Dangerous**: Gibt an, dass die Berechtigung der anfordernden Anwendung einen **erh√∂hten Zugriff** gew√§hrt. **Benutzer werden gebeten, sie zu genehmigen**.
* **Signature**: Nur **Apps, die mit demselben Zertifikat wie das, das die Komponente exportiert, signiert sind**, k√∂nnen die Berechtigung erhalten. Dies ist die st√§rkste Art des Schutzes.
* **SignatureOrSystem**: Nur **Apps, die mit demselben Zertifikat wie das, das die Komponente exportiert, signiert sind, oder **Apps, die mit Systemzugriff ausgef√ºhrt werden**, k√∂nnen Berechtigungen erhalten.

## Vorinstallierte Anwendungen

Diese Apps befinden sich normalerweise in den **`/system/app`** oder **`/system/priv-app`** Verzeichnissen, und einige von ihnen sind **optimiert** (Sie finden m√∂glicherweise nicht einmal die `classes.dex`-Datei). Diese Anwendungen sind es wert, √ºberpr√ºft zu werden, da sie manchmal **mit zu vielen Berechtigungen** (als Root) ausgef√ºhrt werden.

* Die mit dem **AOSP** (Android OpenSource Project) **ROM** gelieferten
* Vom Ger√§tehersteller hinzugef√ºgt
* Vom Mobilfunkanbieter hinzugef√ºgt (wenn sie von ihnen gekauft wurden)

## Rooting

Um Root-Zugriff auf ein physisches Android-Ger√§t zu erhalten, m√ºssen Sie in der Regel 1 oder 2 **Schwachstellen** **ausnutzen**, die normalerweise **spezifisch** f√ºr das **Ger√§t** und die **Version** sind.\
Sobald der Exploit funktioniert hat, wird normalerweise die Linux `su`-Bin√§rdatei an einem Ort kopiert, der in der PATH-Umgebungsvariablen des Benutzers angegeben ist, wie z.B. `/system/xbin`.

Sobald die su-Bin√§rdatei konfiguriert ist, wird eine andere Android-App verwendet, um mit der `su`-Bin√§rdatei zu interagieren und **Anfragen f√ºr Root-Zugriff** wie **Superuser** und **SuperSU** (verf√ºgbar im Google Play Store) zu verarbeiten.

{% hint style="danger" %}
Beachten Sie, dass der Rooting-Prozess sehr gef√§hrlich ist und das Ger√§t schwer besch√§digen kann.
{% endhint %}

### ROMs

Es ist m√∂glich, das **Betriebssystem durch die Installation einer benutzerdefinierten Firmware zu ersetzen**. Dadurch ist es m√∂glich, die N√ºtzlichkeit eines alten Ger√§ts zu erweitern, Softwarebeschr√§nkungen zu umgehen oder Zugriff auf den neuesten Android-Code zu erhalten.\
**OmniROM** und **LineageOS** sind zwei der beliebtesten Firmwares.

Beachten Sie, dass **es nicht immer notwendig ist, das Ger√§t zu rooten**, um eine benutzerdefinierte Firmware zu installieren. **Einige Hersteller erlauben** das Entsperren ihrer Bootloader auf eine gut dokumentierte und sichere Weise.

### Auswirkungen

Sobald ein Ger√§t gerootet ist, kann jede App Zugriff als Root anfordern. Wenn eine b√∂sartige Anwendung dies erh√§lt, hat sie Zugriff auf fast alles und kann das Telefon besch√§digen.

## Grundlagen der Android-Anwendung <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Das Format von Android-Anwendungen wird als _APK-Dateiformat_ bezeichnet. Es ist im Wesentlichen eine **ZIP-Datei** (durch Umbenennen der Dateierweiterung in .zip k√∂nnen die Inhalte extrahiert und angezeigt werden).
- APK-Inhalte (nicht ersch√∂pfend)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: enth√§lt vorkompilierte Ressourcen, wie bin√§res XML.
- res/xml/files\_paths.xml
- META-INF/
- Hier befindet sich das Zertifikat!
- **classes.dex**
- Enth√§lt Dalvik-Bytecode, der den kompilierten Java- (oder Kotlin-)Code darstellt, den die Anwendung standardm√§√üig ausf√ºhrt.
- lib/
- Beherbergt native Bibliotheken, die nach CPU-Architektur in Unterverzeichnissen segregiert sind.
- `armeabi`: Code f√ºr ARM-basierte Prozessoren
- `armeabi-v7a`: Code f√ºr ARMv7 und h√∂her basierte Prozessoren
- `x86`: Code f√ºr X86-Prozessoren
- `mips`: Code nur f√ºr MIPS-Prozessoren
- assets/
- Speichert verschiedene Dateien, die von der App ben√∂tigt werden, m√∂glicherweise einschlie√ülich zus√§tzlicher nativer Bibliotheken oder DEX-Dateien, die manchmal von Malware-Autoren verwendet werden, um zus√§tzlichen Code zu verbergen.
- res/
- Enth√§lt Ressourcen, die nicht in resources.arsc kompiliert sind.

### **Dalvik & Smali**

In der Android-Entwicklung wird **Java oder Kotlin** zur Erstellung von Apps verwendet. Anstelle der Verwendung der JVM wie bei Desktop-Apps kompiliert Android diesen Code in **Dalvik Executable (DEX) Bytecode**. Fr√ºher verwaltete die Dalvik-VM diesen Bytecode, aber jetzt √ºbernimmt die Android Runtime (ART) in neueren Android-Versionen.

F√ºr die R√ºckentwicklung wird **Smali** entscheidend. Es ist die menschenlesbare Version von DEX-Bytecode und fungiert wie eine Assemblersprache, indem es Quellcode in Bytecode-Anweisungen √ºbersetzt. Smali und baksmali beziehen sich in diesem Kontext auf die Assemblierungs- und Disassemblierungswerkzeuge.

## Intents

Intents sind das prim√§re Mittel, durch das Android-Apps zwischen ihren Komponenten oder mit anderen Apps kommunizieren. Diese Nachrichtenobjekte k√∂nnen auch Daten zwischen Apps oder Komponenten √ºbertragen, √§hnlich wie GET/POST-Anfragen in HTTP-Kommunikationen verwendet werden.

Ein Intent ist also im Grunde eine **Nachricht, die zwischen Komponenten √ºbergeben wird**. Intents **k√∂nnen an** bestimmte Komponenten oder Apps gerichtet werden, **oder ohne einen bestimmten Empf√§nger gesendet werden**.\
Einfach gesagt, kann ein Intent verwendet werden:

* Um eine Aktivit√§t zu starten, typischerweise um eine Benutzeroberfl√§che f√ºr eine App zu √∂ffnen
* Als Broadcasts, um das System und Apps √ºber √Ñnderungen zu informieren
* Um einen Hintergrunddienst zu starten, zu stoppen und mit ihm zu kommunizieren
* Um auf Daten √ºber ContentProviders zuzugreifen
* Als R√ºckrufe zur Behandlung von Ereignissen

Wenn sie anf√§llig sind, **k√∂nnen Intents verwendet werden, um eine Vielzahl von Angriffen durchzuf√ºhren**.

### Intent-Filter

**Intent-Filter** definieren, **wie eine Aktivit√§t, ein Dienst oder ein Broadcast-Empf√§nger mit verschiedenen Arten von Intents interagieren kann**. Im Wesentlichen beschreiben sie die F√§higkeiten dieser Komponenten, wie z.B. welche Aktionen sie ausf√ºhren k√∂nnen oder welche Arten von Broadcasts sie verarbeiten k√∂nnen. Der prim√§re Ort, um diese Filter zu deklarieren, ist innerhalb der **AndroidManifest.xml-Datei**, obwohl es auch eine Option ist, sie f√ºr Broadcast-Empf√§nger zu codieren.

Intent-Filter bestehen aus Kategorien, Aktionen und Datenfiltern, mit der M√∂glichkeit, zus√§tzliche Metadaten einzuschlie√üen. Diese Konfiguration erm√∂glicht es Komponenten, spezifische Intents zu verarbeiten, die den deklarierten Kriterien entsprechen.

Ein kritischer Aspekt von Android-Komponenten (Aktivit√§ten/Dienste/Inhaltsanbieter/Broadcast-Empf√§nger) ist ihre Sichtbarkeit oder **√∂ffentlicher Status**. Eine Komponente wird als √∂ffentlich angesehen und kann mit anderen Apps interagieren, wenn sie **`exported`** mit einem Wert von **`true`** oder wenn ein Intent-Filter f√ºr sie im Manifest deklariert ist. Es gibt jedoch eine M√∂glichkeit f√ºr Entwickler, diese Komponenten ausdr√ºcklich privat zu halten, um sicherzustellen, dass sie nicht unbeabsichtigt mit anderen Apps interagieren. Dies wird erreicht, indem das **`exported`**-Attribut in ihren Manifestdefinitionen auf **`false`** gesetzt wird.

Dar√ºber hinaus haben Entwickler die M√∂glichkeit, den Zugriff auf diese Komponenten weiter abzusichern, indem sie spezifische Berechtigungen verlangen. Das **`permission`**-Attribut kann so eingestellt werden, dass nur Apps mit der vorgesehenen Berechtigung auf die Komponente zugreifen k√∂nnen, was eine zus√§tzliche Sicherheitsebene und Kontrolle dar√ºber hinzuf√ºgt, wer mit ihr interagieren kann.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implizite Intents

Intents werden programmgesteuert mit einem Intent-Konstruktor erstellt:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Die **Action** des zuvor deklarierten Intents ist **ACTION\_SEND** und das **Extra** ist ein mailto **Uri** (das Extra ist die zus√§tzliche Information, die der Intent erwartet).

Dieser Intent sollte im Manifest wie im folgenden Beispiel deklariert werden:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Ein intent-filter muss die **Aktion**, **Daten** und **Kategorie** √ºbereinstimmen, um eine Nachricht zu empfangen.

Der Prozess der "Intent-Aufl√∂sung" bestimmt, welche App jede Nachricht empfangen soll. Dieser Prozess ber√ºcksichtigt das **Priorit√§tsattribut**, das in der **intent-filter-Deklaration** festgelegt werden kann, und **diejenige mit der h√∂heren Priorit√§t wird ausgew√§hlt**. Diese Priorit√§t kann zwischen -1000 und 1000 festgelegt werden, und Anwendungen k√∂nnen den Wert `SYSTEM_HIGH_PRIORITY` verwenden. Wenn ein **Konflikt** auftritt, erscheint ein "Chooser"-Fenster, damit der **Benutzer entscheiden kann**.

### Explizite Intents

Ein expliziter Intent gibt den Klassennamen an, den er anvisiert:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
In anderen Anwendungen, um auf das zuvor deklarierte Intent zuzugreifen, k√∂nnen Sie Folgendes verwenden:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Diese erm√∂glichen es anderen Anwendungen, **Aktionen im Namen Ihrer Anwendung auszuf√ºhren**, unter Verwendung der Identit√§t und Berechtigungen Ihrer App. Beim Erstellen eines Pending Intent sollte **ein Intent und die auszuf√ºhrende Aktion angegeben werden**. Wenn der **deklarierte Intent nicht explizit** ist (nicht angibt, welcher Intent ihn aufrufen kann), k√∂nnte eine **b√∂sartige Anwendung die deklarierte Aktion** im Namen der Opfer-App ausf√ºhren. Dar√ºber hinaus, **wenn keine Aktion angegeben ist**, kann die b√∂sartige App **jede Aktion im Namen des Opfers** durchf√ºhren.

### Broadcast Intents

Im Gegensatz zu den vorherigen Intents, die nur von einer App empfangen werden, **k√∂nnen Broadcast Intents von mehreren Apps empfangen werden**. Ab API-Version 14 ist es jedoch **m√∂glich, die App anzugeben, die die Nachricht empfangen soll**, indem man Intent.setPackage verwendet.

Alternativ ist es auch m√∂glich, **eine Berechtigung beim Senden des Broadcasts anzugeben**. Die empfangende App muss diese Berechtigung haben.

Es gibt **zwei Arten** von Broadcasts: **Normal** (asynchron) und **Ordered** (synchron). Die **Reihenfolge** basiert auf der **konfigurierten Priorit√§t innerhalb des Empf√§ngerelements**. **Jede App kann den Broadcast verarbeiten, weiterleiten oder verwerfen.**

Es ist m√∂glich, einen **Broadcast** mit der Funktion `sendBroadcast(intent, receiverPermission)` aus der `Context`-Klasse zu **senden**.\
Sie k√∂nnten auch die Funktion **`sendBroadcast`** von **`LocalBroadCastManager`** verwenden, die sicherstellt, dass die **Nachricht die App niemals verl√§sst**. Damit m√ºssen Sie nicht einmal eine Empfangskomponente exportieren.

### Sticky Broadcasts

Diese Art von Broadcasts **kann lange nach dem Senden abgerufen werden**.\
Diese wurden in API-Stufe 21 als veraltet erkl√§rt und es wird empfohlen, **sie nicht zu verwenden**.\
**Sie erm√∂glichen es jeder Anwendung, die Daten abzuh√∂ren, aber auch sie zu √§ndern.**

Wenn Sie Funktionen finden, die das Wort "sticky" enthalten, wie **`sendStickyBroadcast`** oder **`sendStickyBroadcastAsUser`**, **pr√ºfen Sie die Auswirkungen und versuchen Sie, sie zu entfernen**.

## Deep links / URL schemes

In Android-Anwendungen werden **Deep Links** verwendet, um eine Aktion (Intent) direkt √ºber eine URL zu initiieren. Dies geschieht durch die Deklaration eines spezifischen **URL-Schemas** innerhalb einer Aktivit√§t. Wenn ein Android-Ger√§t versucht, **auf eine URL mit diesem Schema zuzugreifen**, wird die angegebene Aktivit√§t innerhalb der Anwendung gestartet.

Das Schema muss in der **`AndroidManifest.xml`**-Datei deklariert werden:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Das Schema aus dem vorherigen Beispiel ist `exampleapp://` (beachten Sie auch die **`category BROWSABLE`**)

Dann k√∂nnen Sie im Datenfeld den **host** und den **path** angeben:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Um von einer Webseite darauf zuzugreifen, ist es m√∂glich, einen Link wie folgt zu setzen:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Um den **Code zu finden, der in der App ausgef√ºhrt wird**, gehen Sie zur Aktivit√§t, die durch den Deeplink aufgerufen wird, und suchen Sie die Funktion **`onNewIntent`**.

Erfahren Sie, wie Sie [Deep Links ohne Verwendung von HTML-Seiten aufrufen](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Die **Android Interface Definition Language (AIDL)** wurde entwickelt, um die Kommunikation zwischen Client und Dienst in Android-Anwendungen durch **interprozessuale Kommunikation** (IPC) zu erleichtern. Da der direkte Zugriff auf den Speicher eines anderen Prozesses auf Android nicht erlaubt ist, vereinfacht AIDL den Prozess, indem Objekte in ein vom Betriebssystem verstandenes Format umgewandelt werden, wodurch die Kommunikation zwischen verschiedenen Prozessen erleichtert wird.

### Schl√ºsselkonzepte

- **Gebundene Dienste**: Diese Dienste nutzen AIDL f√ºr IPC, wodurch Aktivit√§ten oder Komponenten an einen Dienst binden, Anfragen stellen und Antworten erhalten k√∂nnen. Die Methode `onBind` in der Dienstklasse ist entscheidend f√ºr den Beginn der Interaktion und stellt einen wichtigen Bereich f√ºr die Sicherheits√ºberpr√ºfung auf Schwachstellen dar.

- **Messenger**: Als gebundener Dienst erm√∂glicht der Messenger IPC mit einem Fokus auf die Verarbeitung von Daten durch die Methode `onBind`. Es ist wichtig, diese Methode genau auf unsichere Datenverarbeitung oder die Ausf√ºhrung sensibler Funktionen zu √ºberpr√ºfen.

- **Binder**: Obwohl die direkte Verwendung der Binder-Klasse aufgrund der Abstraktion durch AIDL weniger verbreitet ist, ist es vorteilhaft zu verstehen, dass der Binder als Kernel-Treiber fungiert, der den Datentransfer zwischen den Speicherbereichen verschiedener Prozesse erleichtert. F√ºr ein besseres Verst√§ndnis steht eine Ressource zur Verf√ºgung unter [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponenten

Diese umfassen: **Aktivit√§ten, Dienste, Broadcast-Empf√§nger und Anbieter.**

### Launcher-Aktivit√§t und andere Aktivit√§ten

In Android-Apps sind **Aktivit√§ten** wie Bildschirme, die verschiedene Teile der Benutzeroberfl√§che der App anzeigen. Eine App kann viele Aktivit√§ten haben, von denen jede einen einzigartigen Bildschirm f√ºr den Benutzer pr√§sentiert.

Die **Launcher-Aktivit√§t** ist das Haupttor zu einer App, das gestartet wird, wenn Sie auf das App-Symbol tippen. Sie ist in der Manifestdatei der App mit spezifischen MAIN- und LAUNCHER-Intents definiert:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nicht alle Apps ben√∂tigen eine Launcher-Aktivit√§t, insbesondere solche ohne Benutzeroberfl√§che, wie Hintergrunddienste.

Aktivit√§ten k√∂nnen anderen Apps oder Prozessen zur Verf√ºgung gestellt werden, indem sie im Manifest als "exportiert" markiert werden. Diese Einstellung erm√∂glicht es anderen Apps, diese Aktivit√§t zu starten:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Jedoch ist der Zugriff auf eine Aktivit√§t von einer anderen App nicht immer ein Sicherheitsrisiko. Die Bedenken entstehen, wenn sensible Daten unsachgem√§√ü geteilt werden, was zu Informationslecks f√ºhren k√∂nnte.

Der Lebenszyklus einer Aktivit√§t **beginnt mit der onCreate-Methode**, die die Benutzeroberfl√§che einrichtet und die Aktivit√§t auf die Interaktion mit dem Benutzer vorbereitet.

### Anwendungssubklasse

In der Android-Entwicklung hat eine App die M√∂glichkeit, eine **Subklasse** der [Application](https://developer.android.com/reference/android/app/Application)-Klasse zu erstellen, obwohl dies nicht obligatorisch ist. Wenn eine solche Subklasse definiert ist, wird sie die erste Klasse, die innerhalb der App instanziiert wird. Die **`attachBaseContext`**-Methode, wenn sie in dieser Subklasse implementiert ist, wird vor der **`onCreate`**-Methode ausgef√ºhrt. Diese Einrichtung erm√∂glicht eine fr√ºhe Initialisierung, bevor der Rest der Anwendung startet.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Dienste

[Dienste](https://developer.android.com/guide/components/services) sind **Hintergrundoperationen**, die in der Lage sind, Aufgaben ohne Benutzeroberfl√§che auszuf√ºhren. Diese Aufgaben k√∂nnen weiterhin ausgef√ºhrt werden, selbst wenn Benutzer zu anderen Anwendungen wechseln, was Dienste entscheidend f√ºr **langandauernde Operationen** macht.

Dienste sind vielseitig; sie k√∂nnen auf verschiedene Weise gestartet werden, wobei **Intents** die prim√§re Methode zum Starten als Einstiegspunkt einer Anwendung sind. Sobald ein Dienst mit der Methode `startService` gestartet wird, wird die Methode `onStart` aktiviert und l√§uft weiter, bis die Methode `stopService` ausdr√ºcklich aufgerufen wird. Alternativ, wenn die Rolle eines Dienstes von einer aktiven Clientverbindung abh√§ngt, wird die Methode `bindService` verwendet, um den Client mit dem Dienst zu verbinden, wobei die Methode `onBind` f√ºr den Datenaustausch aktiviert wird.

Eine interessante Anwendung von Diensten umfasst die Wiedergabe von Hintergrundmusik oder das Abrufen von Netzwerkdaten, ohne die Interaktion des Benutzers mit einer App zu behindern. Dar√ºber hinaus k√∂nnen Dienste f√ºr andere Prozesse auf demselben Ger√§t durch **Exportieren** zug√§nglich gemacht werden. Dies ist nicht das Standardverhalten und erfordert eine explizite Konfiguration in der Android Manifest-Datei:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** fungieren als Listener in einem Messaging-System und erm√∂glichen es mehreren Anwendungen, auf dieselben Nachrichten des Systems zu reagieren. Eine App kann **einen Empf√§nger registrieren** auf **zwei Hauptarten**: √ºber das **Manifest** der App oder **dynamisch** im Code der App √ºber die **`registerReceiver`** API. Im Manifest werden Broadcasts mit Berechtigungen gefiltert, w√§hrend dynamisch registrierte Empf√§nger auch Berechtigungen bei der Registrierung angeben k√∂nnen.

**Intent-Filter** sind entscheidend in beiden Registrierungsarten, da sie bestimmen, welche Broadcasts den Empf√§nger ausl√∂sen. Sobald ein passender Broadcast gesendet wird, wird die Methode **`onReceive`** des Empf√§ngers aufgerufen, was der App erm√∂glicht, entsprechend zu reagieren, z. B. das Verhalten als Reaktion auf eine Warnung bei niedrigem Batteriestand anzupassen.

Broadcasts k√∂nnen entweder **asynchron** sein, wobei alle Empf√§nger ohne Reihenfolge erreicht werden, oder **synchron**, wobei Empf√§nger den Broadcast basierend auf festgelegten Priorit√§ten erhalten. Es ist jedoch wichtig, das potenzielle Sicherheitsrisiko zu beachten, da jede App sich selbst priorisieren kann, um einen Broadcast abzufangen.

Um die Funktionalit√§t eines Empf√§ngers zu verstehen, suchen Sie nach der Methode **`onReceive`** innerhalb seiner Klasse. Der Code dieser Methode kann das empfangene Intent manipulieren, was die Notwendigkeit der Datenvalidierung durch Empf√§nger hervorhebt, insbesondere bei **geordneten Broadcasts**, die das Intent modifizieren oder verwerfen k√∂nnen.

### Content Provider

**Content Providers** sind entscheidend f√ºr das **Teilen strukturierter Daten** zwischen Apps und betonen die Bedeutung der Implementierung von **Berechtigungen**, um die Datensicherheit zu gew√§hrleisten. Sie erm√∂glichen es Apps, auf Daten aus verschiedenen Quellen zuzugreifen, einschlie√ülich Datenbanken, Dateisystemen oder dem Web. Spezifische Berechtigungen wie **`readPermission`** und **`writePermission`** sind entscheidend f√ºr die Kontrolle des Zugriffs. Dar√ºber hinaus kann tempor√§rer Zugriff √ºber **`grantUriPermission`**-Einstellungen im Manifest der App gew√§hrt werden, wobei Attribute wie `path`, `pathPrefix` und `pathPattern` f√ºr eine detaillierte Zugriffskontrolle genutzt werden.

Die Eingangsvalidierung ist von gr√∂√üter Bedeutung, um Schwachstellen wie SQL-Injection zu verhindern. Content Providers unterst√ºtzen grundlegende Operationen: `insert()`, `update()`, `delete()` und `query()`, die die Datenmanipulation und das Teilen zwischen Anwendungen erleichtern.

**FileProvider**, ein spezialisierter Content Provider, konzentriert sich auf das sichere Teilen von Dateien. Er wird im Manifest der App mit spezifischen Attributen definiert, um den Zugriff auf Ordner zu steuern, die durch `android:exported` und `android:resource` auf Ordnerkonfigurationen verweisen. Vorsicht ist geboten, wenn Verzeichnisse geteilt werden, um zu vermeiden, dass sensible Daten unbeabsichtigt offengelegt werden.

Beispiel f√ºr die Manifestdeklaration f√ºr FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Und ein Beispiel f√ºr die Angabe von freigegebenen Ordnern in `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
F√ºr weitere Informationen siehe:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews sind wie **Mini-Webbrowser** in Android-Apps, die Inhalte entweder aus dem Web oder von lokalen Dateien abrufen. Sie sind √§hnlichen Risiken wie regul√§re Browser ausgesetzt, jedoch gibt es M√∂glichkeiten, diese **Risiken zu reduzieren** durch spezifische **Einstellungen**.

Android bietet zwei Haupttypen von WebView:

- **WebViewClient** ist gro√üartig f√ºr grundlegendes HTML, unterst√ºtzt jedoch nicht die JavaScript-Alert-Funktion, was die Testm√∂glichkeiten f√ºr XSS-Angriffe beeinflusst.
- **WebChromeClient** bietet mehr das volle Chrome-Browser-Erlebnis.

Ein wichtiger Punkt ist, dass WebView-Browser **keine Cookies** mit dem Hauptbrowser des Ger√§ts teilen.

Zum Laden von Inhalten stehen Methoden wie ````loadUrl````, ````loadData````, und ````loadDataWithBaseURL```` zur Verf√ºgung. Es ist entscheidend sicherzustellen, dass diese URLs oder Dateien **sicher zu verwenden** sind. Sicherheitseinstellungen k√∂nnen √ºber die ````WebSettings````-Klasse verwaltet werden. Beispielsweise kann das Deaktivieren von JavaScript mit ````setJavaScriptEnabled(false)```` XSS-Angriffe verhindern.

Die JavaScript "Bridge" erm√∂glicht es Java-Objekten, mit JavaScript zu interagieren, wobei Methoden ab Android 4.2 mit ````@JavascriptInterface```` f√ºr die Sicherheit gekennzeichnet werden m√ºssen.

Das Zulassen des Zugriffs auf Inhalte (````setAllowContentAccess(true)````) erm√∂glicht es WebViews, auf Content Providers zuzugreifen, was ein Risiko darstellen k√∂nnte, es sei denn, die Inhalts-URLs werden als sicher verifiziert.

Um den Dateizugriff zu steuern:
- Das Deaktivieren des Dateizugriffs (````setAllowFileAccess(false)````) beschr√§nkt den Zugriff auf das Dateisystem, mit Ausnahmen f√ºr bestimmte Assets, um sicherzustellen, dass sie nur f√ºr nicht sensible Inhalte verwendet werden.

## Andere App-Komponenten und Mobile Device Management

### **Digitale Signatur von Anwendungen**

- **Digitale Signaturen** sind ein Muss f√ºr Android-Apps, um sicherzustellen, dass sie **authentisch erstellt** wurden, bevor sie installiert werden. Dieser Prozess verwendet ein Zertifikat zur Identifizierung der App und muss vom Paketmanager des Ger√§ts bei der Installation verifiziert werden. Apps k√∂nnen **selbstsigniert oder von einer externen CA zertifiziert** sein, um unbefugten Zugriff zu verhindern und sicherzustellen, dass die App w√§hrend der Lieferung an das Ger√§t unver√§ndert bleibt.

### **App-Verifizierung f√ºr erh√∂hte Sicherheit**

- Ab **Android 4.2** erm√∂glicht eine Funktion namens **Apps √ºberpr√ºfen**, dass Benutzer Apps vor der Installation auf Sicherheit √ºberpr√ºfen lassen. Dieser **Verifizierungsprozess** kann Benutzer vor potenziell sch√§dlichen Apps warnen oder sogar die Installation besonders b√∂sartiger Apps verhindern, was die Sicherheit der Benutzer erh√∂ht.

### **Mobile Device Management (MDM)**

- **MDM-L√∂sungen** bieten **√úberwachung und Sicherheit** f√ºr mobile Ger√§te durch die **Device Administration API**. Sie erfordern die Installation einer Android-App, um mobile Ger√§te effektiv zu verwalten und zu sichern. Zu den Hauptfunktionen geh√∂ren **Durchsetzung von Passwort-Richtlinien**, **Vorgabe von Speicher-Verschl√ºsselung** und **Erlauben von Remote-Datenl√∂schung**, um umfassende Kontrolle und Sicherheit √ºber mobile Ger√§te zu gew√§hrleisten.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
