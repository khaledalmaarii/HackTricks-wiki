# Podstawy aplikacji na Androida

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si trikami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w na GitHubie.

</details>
{% endhint %}

## Model bezpieczestwa Androida

**Istniej dwie warstwy:**

* **OS**, kt贸ry utrzymuje zainstalowane aplikacje w izolacji od siebie.
* **sama aplikacja**, kt贸ra pozwala deweloperom **ujawnia okrelone funkcjonalnoci** i konfigurowa mo偶liwoci aplikacji.

### Separacja UID

**Ka偶dej aplikacji przypisany jest okrelony identyfikator u偶ytkownika (User ID)**. Dzieje si to podczas instalacji aplikacji, aby **aplikacja moga interagowa tylko z plikami nale偶cymi do jej identyfikatora u偶ytkownika lub plikami wsp贸dzielonymi**. Dlatego tylko sama aplikacja, niekt贸re komponenty systemu operacyjnego i u偶ytkownik root mog uzyska dostp do danych aplikacji.

### Wsp贸dzielenie UID

**Dwie aplikacje mog by skonfigurowane do u偶ywania tego samego UID**. Mo偶e to by przydatne do dzielenia si informacjami, ale jeli jedna z nich zostanie skompromitowana, dane obu aplikacji bd skompromitowane. Dlatego takie zachowanie jest **odradzane**.\
**Aby wsp贸dzieli ten sam UID, aplikacje musz zdefiniowa t sam warto `android:sharedUserId` w swoich manifestach.**

### Sandbox

**Sandbox aplikacji Android** pozwala na uruchamianie **ka偶dej aplikacji** jako **osobnego procesu pod osobnym identyfikatorem u偶ytkownika**. Ka偶dy proces ma swoj wasn maszyn wirtualn, wic kod aplikacji dziaa w izolacji od innych aplikacji.\
Od Androida 5.0(L) **SELinux** jest egzekwowany. Zasadniczo, SELinux odmawia wszelkich interakcji proces贸w, a nastpnie tworzy polityki, aby **zezwoli tylko na oczekiwane interakcje midzy nimi**.

### Uprawnienia

Kiedy instalujesz **aplikacj i prosi o uprawnienia**, aplikacja prosi o uprawnienia skonfigurowane w elementach **`uses-permission`** w pliku **AndroidManifest.xml**. Element **uses-permission** wskazuje nazw 偶danego uprawnienia w **atrybucie name**. Ma r贸wnie偶 atrybut **maxSdkVersion**, kt贸ry przestaje prosi o uprawnienia w wersjach wy偶szych ni偶 ta okrelona.\
Zauwa偶, 偶e aplikacje na Androida nie musz prosi o wszystkie uprawnienia na pocztku, mog r贸wnie偶 **prosi o uprawnienia dynamicznie**, ale wszystkie uprawnienia musz by **zadeklarowane** w **manifecie**.

Kiedy aplikacja ujawnia funkcjonalno, mo偶e ograniczy **dostp tylko do aplikacji, kt贸re maj okrelone uprawnienie**.\
Element uprawnienia ma trzy atrybuty:

* **nazwa** uprawnienia
* atrybut **permission-group**, kt贸ry pozwala na grupowanie powizanych uprawnie.
* **poziom ochrony**, kt贸ry wskazuje, jak przyznawane s uprawnienia. Istniej cztery typy:
* **Normalne**: U偶ywane, gdy **nie ma znanych zagro偶e** dla aplikacji. U偶ytkownik **nie musi ich zatwierdza**.
* **Niebezpieczne**: Wskazuje, 偶e uprawnienie przyznaje 偶dajcej aplikacji pewien **podwy偶szony dostp**. **U偶ytkownicy s proszeni o ich zatwierdzenie**.
* **Podpis**: Tylko **aplikacje podpisane tym samym certyfikatem, co ten** eksportujcy komponent, mog otrzyma uprawnienie. To najsilniejszy typ ochrony.
* **SignatureOrSystem**: Tylko **aplikacje podpisane tym samym certyfikatem, co ten** eksportujcy komponent lub **aplikacje dziaajce z dostpem na poziomie systemu** mog otrzyma uprawnienia.

## Aplikacje wstpnie zainstalowane

Te aplikacje zazwyczaj znajduj si w katalogach **`/system/app`** lub **`/system/priv-app`** i niekt贸re z nich s **optymalizowane** (mo偶esz nawet nie znale藕 pliku `classes.dex`). Te aplikacje warto sprawdzi, poniewa偶 czasami dziaaj **zbyt wieloma uprawnieniami** (jako root).

* Te dostarczane z **AOSP** (Android OpenSource Project) **ROM**
* Dodane przez producenta **urzdzenia**
* Dodane przez dostawc **telefonu kom贸rkowego** (jeli zakupione od nich)

## Rootowanie

Aby uzyska dostp root do fizycznego urzdzenia z Androidem, zazwyczaj musisz **wykorzysta** 1 lub 2 **luki** kt贸re zazwyczaj s **specyficzne** dla **urzdzenia** i **wersji**.\
Gdy exploit zadziaa, zazwyczaj binarny plik Linux `su` jest kopiowany do lokalizacji okrelonej w zmiennej rodowiskowej PATH u偶ytkownika, takiej jak `/system/xbin`.

Gdy binarny plik su jest skonfigurowany, u偶ywana jest inna aplikacja Android do interakcji z binarnym plikiem `su` i **przetwarzania 偶da dostpu root**, takich jak **Superuser** i **SuperSU** (dostpne w sklepie Google Play).

{% hint style="danger" %}
Zauwa偶, 偶e proces rootowania jest bardzo niebezpieczny i mo偶e powa偶nie uszkodzi urzdzenie.
{% endhint %}

### ROM-y

Mo偶liwe jest **zastpienie systemu operacyjnego instalujc niestandardowe oprogramowanie**. Dziki temu mo偶na wydu偶y u偶yteczno starego urzdzenia, obej ograniczenia oprogramowania lub uzyska dostp do najnowszego kodu Androida.\
**OmniROM** i **LineageOS** to dwa z najpopularniejszych oprogramowa do u偶ycia.

Zauwa偶, 偶e **nie zawsze jest konieczne rootowanie urzdzenia**, aby zainstalowa niestandardowe oprogramowanie. **Niekt贸rzy producenci pozwalaj** na odblokowanie swoich bootloader贸w w dobrze udokumentowany i bezpieczny spos贸b.

### Implikacje

Gdy urzdzenie jest zrootowane, ka偶da aplikacja mo偶e 偶da dostpu jako root. Jeli zoliwa aplikacja go uzyska, bdzie miaa dostp do prawie wszystkiego i bdzie moga uszkodzi telefon.

## Podstawy aplikacji na Androida <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Format aplikacji na Androida okrelany jest jako _format pliku APK_. Jest to zasadniczo **plik ZIP** (zmieniajc rozszerzenie pliku na .zip, zawarto mo偶na wyodrbni i przeglda).
- Zawarto APK (nie wyczerpujca)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: zawiera skompilowane zasoby, takie jak binarny XML.
- res/xml/files\_paths.xml
- META-INF/
- Tutaj znajduje si certyfikat!
- **classes.dex**
- Zawiera bajtkod Dalvik, reprezentujcy skompilowany kod Java (lub Kotlin), kt贸ry aplikacja wykonuje domylnie.
- lib/
- Zawiera biblioteki natywne, segregowane wedug architektury CPU w podkatalogach.
- `armeabi`: kod dla procesor贸w opartych na ARM
- `armeabi-v7a`: kod dla procesor贸w ARMv7 i wy偶szych
- `x86`: kod dla procesor贸w X86
- `mips`: kod tylko dla procesor贸w MIPS
- assets/
- Przechowuje r贸偶ne pliki potrzebne aplikacji, potencjalnie w tym dodatkowe biblioteki natywne lub pliki DEX, czasami u偶ywane przez autor贸w zoliwego oprogramowania do ukrywania dodatkowego kodu.
- res/
- Zawiera zasoby, kt贸re nie s skompilowane w resources.arsc

### **Dalvik i Smali**

W rozwoju Androida, **Java lub Kotlin** jest u偶ywane do tworzenia aplikacji. Zamiast u偶ywa JVM jak w aplikacjach desktopowych, Android kompiluje ten kod do **bajtkodu Dalvik Executable (DEX)**. Wczeniej, maszyna wirtualna Dalvik obsugiwaa ten bajtkod, ale teraz, w nowszych wersjach Androida, przejmuje go Android Runtime (ART).

W in偶ynierii odwrotnej, **Smali** staje si kluczowy. To czytelna dla czowieka wersja bajtkodu DEX, dziaajca jak jzyk asemblera, tumaczc kod 藕r贸dowy na instrukcje bajtkodu. Smali i baksmali odnosz si do narzdzi asemblera i deasemblacji w tym kontekcie.

## Intencje

Intencje s podstawowym sposobem, w jaki aplikacje Android komunikuj si midzy swoimi komponentami lub z innymi aplikacjami. Te obiekty wiadomoci mog r贸wnie偶 przenosi dane midzy aplikacjami lub komponentami, podobnie jak 偶dania GET/POST s u偶ywane w komunikacji HTTP.

Intencja to zasadniczo **wiadomo, kt贸ra jest przekazywana midzy komponentami**. Intencje **mog by kierowane** do konkretnych komponent贸w lub aplikacji, **lub mog by wysyane bez konkretnego odbiorcy**.\
Aby uproci, intencja mo偶e by u偶ywana:

* Do uruchamiania aktywnoci, zazwyczaj otwierajc interfejs u偶ytkownika dla aplikacji
* Jako transmisje, aby informowa system i aplikacje o zmianach
* Do uruchamiania, zatrzymywania i komunikowania si z usug w tle
* Do uzyskiwania dostpu do danych za porednictwem ContentProviders
* Jako wywoania zwrotne do obsugi zdarze

Jeli s podatne, **intencje mog by u偶ywane do przeprowadzania r贸偶nych atak贸w**.

### Filtr intencji

**Filtry intencji** definiuj **jak aktywno, usuga lub odbiornik transmisji mog interagowa z r贸偶nymi typami intencji**. Zasadniczo opisuj one mo偶liwoci tych komponent贸w, takie jak jakie akcje mog wykonywa lub jakie rodzaje transmisji mog przetwarza. G贸wnym miejscem do deklarowania tych filtr贸w jest plik **AndroidManifest.xml**, chocia偶 dla odbiornik贸w transmisji, kodowanie ich r贸wnie偶 jest opcj.

Filtry intencji skadaj si z kategorii, akcji i filtr贸w danych, z mo偶liwoci dodania dodatkowych metadanych. Ta konfiguracja pozwala komponentom obsugiwa konkretne intencje, kt贸re pasuj do zadeklarowanych kryteri贸w.

Krytycznym aspektem komponent贸w Androida (aktywnoci/usugi/dostawcy treci/odbiorniki transmisji) jest ich widoczno lub **status publiczny**. Komponent jest uwa偶any za publiczny i mo偶e interagowa z innymi aplikacjami, jeli jest **`exported`** z wartoci **`true`** lub jeli dla niego w manifecie zadeklarowano filtr intencji. Istnieje jednak spos贸b, aby deweloperzy wyra藕nie zachowali te komponenty prywatne, zapewniajc, 偶e nie bd interagowa z innymi aplikacjami niezamierzenie. Osiga si to poprzez ustawienie atrybutu **`exported`** na **`false`** w ich definicjach manifestu.

Ponadto, deweloperzy maj mo偶liwo dalszego zabezpieczenia dostpu do tych komponent贸w, wymagajc okrelonych uprawnie. Atrybut **`permission`** mo偶e by ustawiony, aby wymusi, 偶e tylko aplikacje z wyznaczonym uprawnieniem mog uzyska dostp do komponentu, dodajc dodatkow warstw bezpieczestwa i kontroli nad tym, kto mo偶e z nim interagowa.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implicit Intents

Intencje s programowo tworzone za pomoc konstruktora Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
The **Action** of the previously declared intent is **ACTION\_SEND** and the **Extra** is a mailto **Uri** (the Extra if the extra information the intent is expecting).

Ten zamiar powinien by zadeklarowany w manifecie, jak w nastpujcym przykadzie:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
An intent-filter musi pasowa do **akcji**, **danych** i **kategorii**, aby odebra wiadomo.

Proces "rozwizywania intencji" okrela, kt贸ra aplikacja powinna odebra ka偶d wiadomo. Proces ten uwzgldnia **atrybut priorytetu**, kt贸ry mo偶na ustawi w **deklaracji intent-filter**, a **ten z wy偶szym priorytetem zostanie wybrany**. Ten priorytet mo偶na ustawi w zakresie od -1000 do 1000, a aplikacje mog u偶ywa wartoci `SYSTEM_HIGH_PRIORITY`. Jeli wystpi **konflikt**, pojawia si okno "wyboru", aby **u偶ytkownik m贸g zdecydowa**.

### Explicit Intents

Eksplicytna intencja okrela nazw klasy, kt贸r celuje:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
W innych aplikacjach, aby uzyska dostp do wczeniej zadeklarowanego intencji, mo偶esz u偶y:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Te pozwalaj innym aplikacjom **podejmowa dziaania w imieniu twojej aplikacji**, u偶ywajc to偶samoci i uprawnie twojej aplikacji. Konstruujc Pending Intent, nale偶y **okreli intencj i akcj do wykonania**. Jeli **zadeklarowana intencja nie jest wyra藕na** (nie okrela, kt贸ra intencja mo偶e j wywoa), **zoliwa aplikacja mogaby wykona zadeklarowan akcj** w imieniu aplikacji ofiary. Co wicej, **jeli akcja nie jest okrelona**, zoliwa aplikacja bdzie moga wykona **dowoln akcj w imieniu ofiary**.

### Broadcast Intents

W przeciwiestwie do poprzednich intencji, kt贸re s odbierane tylko przez jedn aplikacj, intencje rozgoszeniowe **mog by odbierane przez wiele aplikacji**. Jednak od wersji API 14, **mo偶liwe jest okrelenie aplikacji, kt贸ra powinna otrzyma** wiadomo, u偶ywajc Intent.setPackage.

Alternatywnie, mo偶liwe jest r贸wnie偶 **okrelenie uprawnienia podczas wysyania rozgoszenia**. Aplikacja odbierajca bdzie musiaa mie to uprawnienie.

Istniej **dwa typy** rozgosze: **Normalne** (asynchroniczne) i **Zam贸wione** (synchronizowane). **Kolejno** opiera si na **skonfigurowanym priorytecie w elemencie odbiorcy**. **Ka偶da aplikacja mo偶e przetwarza, przekazywa lub odrzuca rozgoszenie.**

Mo偶liwe jest **wysanie** **rozgoszenia** za pomoc funkcji `sendBroadcast(intent, receiverPermission)` z klasy `Context`.\
Mo偶esz r贸wnie偶 u偶y funkcji **`sendBroadcast`** z **`LocalBroadCastManager`**, kt贸ra zapewnia, 偶e **wiadomo nigdy nie opuszcza aplikacji**. U偶ywajc tego, nie bdziesz nawet musia eksportowa komponentu odbiorcy.

### Sticky Broadcasts

Ten rodzaj rozgosze **mo偶e by dostpny dugo po ich wysaniu**.\
Zostay one wycofane w poziomie API 21 i zaleca si **nie u偶ywa ich**.\
**Pozwalaj ka偶dej aplikacji na podsuchiwanie danych, ale tak偶e na ich modyfikacj.**

Jeli znajdziesz funkcje zawierajce sowo "sticky", takie jak **`sendStickyBroadcast`** lub **`sendStickyBroadcastAsUser`**, **sprawd藕 wpyw i spr贸buj je usun**.

## Deep links / URL schemes

W aplikacjach Android, **deep links** s u偶ywane do inicjowania akcji (Intent) bezporednio przez URL. Dzieje si to poprzez zadeklarowanie konkretnego **schematu URL** w obrbie aktywnoci. Gdy urzdzenie z Androidem pr贸buje **uzyska dostp do URL z tym schematem**, okrelona aktywno w aplikacji jest uruchamiana.

Schemat musi by zadeklarowany w pliku **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Schemat z poprzedniego przykadu to `exampleapp://` (zauwa偶 r贸wnie偶 **`category BROWSABLE`**)

Nastpnie, w polu danych, mo偶esz okreli **host** i **path**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Aby uzyska do niego dostp z sieci, mo偶na ustawi link jak:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Aby znale藕 **kod, kt贸ry bdzie wykonywany w aplikacji**, przejd藕 do aktywnoci wywoywanej przez deeplink i poszukaj funkcji **`onNewIntent`**.

Dowiedz si, jak [wywoywa deep linki bez u偶ycia stron HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** jest zaprojektowany w celu uatwienia komunikacji midzy klientem a usug w aplikacjach Android poprzez **komunikacj midzyprocesow** (IPC). Poniewa偶 bezporedni dostp do pamici innego procesu nie jest dozwolony w Androidzie, AIDL upraszcza ten proces, marshalling obiekt贸w do formatu zrozumiaego dla systemu operacyjnego, co uatwia komunikacj midzy r贸偶nymi procesami.

### Kluczowe pojcia

- **Usugi powizane**: Te usugi wykorzystuj AIDL do IPC, umo偶liwiajc aktywnociom lub komponentom powizanie z usug, skadanie 偶da i otrzymywanie odpowiedzi. Metoda `onBind` w klasie usugi jest kluczowa dla inicjowania interakcji, co czyni j istotnym obszarem do przegldu bezpieczestwa w poszukiwaniu luk.

- **Messenger**: Dziaajc jako usuga powizana, Messenger uatwia IPC z naciskiem na przetwarzanie danych poprzez metod `onBind`. Wa偶ne jest, aby dokadnie sprawdzi t metod pod ktem niebezpiecznego przetwarzania danych lub wykonywania wra偶liwych funkcji.

- **Binder**: Chocia偶 bezporednie u偶ycie klasy Binder jest mniej powszechne z powodu abstrakcji AIDL, warto zrozumie, 偶e Binder dziaa jako sterownik na poziomie jdra, uatwiajc transfer danych midzy przestrzeniami pamici r贸偶nych proces贸w. Dla dalszego zrozumienia dostpny jest zas贸b pod adresem [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponenty

Nale偶 do nich: **Aktywnoci, Usugi, Odbiorniki Rozgoszeniowe i Dostawcy.**

### Aktywno uruchamiajca i inne aktywnoci

W aplikacjach Android **aktywnoci** s jak ekrany, pokazujce r贸偶ne czci interfejsu u偶ytkownika aplikacji. Aplikacja mo偶e mie wiele aktywnoci, z kt贸rych ka偶da prezentuje unikalny ekran dla u偶ytkownika.

**Aktywno uruchamiajca** jest g贸wnym wejciem do aplikacji, uruchamianym po naciniciu ikony aplikacji. Jest zdefiniowana w pliku manifestu aplikacji z okrelonymi intencjami MAIN i LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nie wszystkie aplikacje potrzebuj aktywnoci uruchamiajcej, szczeg贸lnie te bez interfejsu u偶ytkownika, takie jak usugi w tle.

Aktywnoci mog by udostpniane innym aplikacjom lub procesom, oznaczajc je jako "exported" w manifecie. To ustawienie pozwala innym aplikacjom na uruchomienie tej aktywnoci:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Jednak dostp do aktywnoci z innej aplikacji nie zawsze stanowi ryzyko bezpieczestwa. Obawy pojawiaj si, jeli wra偶liwe dane s udostpniane niewaciwie, co mo偶e prowadzi do wyciek贸w informacji.

Cykl 偶ycia aktywnoci **zaczyna si od metody onCreate**, kt贸ra ustawia interfejs u偶ytkownika i przygotowuje aktywno do interakcji z u偶ytkownikiem.

### Podklasa Aplikacji

W rozwoju Androida aplikacja ma mo偶liwo stworzenia **podklasy** klasy [Application](https://developer.android.com/reference/android/app/Application), chocia偶 nie jest to obowizkowe. Gdy taka podklasa jest zdefiniowana, staje si pierwsz klas, kt贸ra jest instancjonowana w aplikacji. Metoda **`attachBaseContext`**, jeli jest zaimplementowana w tej podklasie, jest wykonywana przed metod **`onCreate`**. Ta konfiguracja pozwala na wczesn inicjalizacj przed rozpoczciem reszty aplikacji.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Usugi

[Usugi](https://developer.android.com/guide/components/services) to **operacje w tle**, kt贸re mog wykonywa zadania bez interfejsu u偶ytkownika. Te zadania mog kontynuowa dziaanie nawet wtedy, gdy u偶ytkownicy przeczaj si na r贸偶ne aplikacje, co sprawia, 偶e usugi s kluczowe dla **dugoterminowych operacji**.

Usugi s wszechstronne; mog by inicjowane na r贸偶ne sposoby, przy czym **Intents** s g贸wn metod ich uruchamiania jako punktu wejcia aplikacji. Gdy usuga jest uruchamiana za pomoc metody `startService`, jej metoda `onStart` zaczyna dziaa i dziaa a偶 do momentu, gdy metoda `stopService` zostanie wywoana. Alternatywnie, jeli rola usugi zale偶y od aktywnego poczenia z klientem, u偶ywana jest metoda `bindService` do powizania klienta z usug, anga偶ujc metod `onBind` do przesyania danych.

Ciekawym zastosowaniem usug jest odtwarzanie muzyki w tle lub pobieranie danych z sieci bez zak贸cania interakcji u偶ytkownika z aplikacj. Ponadto, usugi mog by udostpniane innym procesom na tym samym urzdzeniu poprzez **eksportowanie**. Nie jest to domylne zachowanie i wymaga wyra藕nej konfiguracji w pliku manifestu Androida:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

**Broadcast receivers** dziaaj jako suchacze w systemie wiadomoci, umo偶liwiajc wielu aplikacjom reagowanie na te same wiadomoci z systemu. Aplikacja mo偶e **zarejestrowa odbiornik** na **dwa g贸wne sposoby**: poprzez **Manifest** aplikacji lub **dynamicznie** w kodzie aplikacji za pomoc API **`registerReceiver`**. W Manifecie, transmisje s filtrowane za pomoc uprawnie, podczas gdy dynamicznie zarejestrowane odbiorniki mog r贸wnie偶 okrela uprawnienia podczas rejestracji.

**Filtry intencji** s kluczowe w obu metodach rejestracji, okrelajc, kt贸re transmisje uruchamiaj odbiornik. Gdy odpowiednia transmisja zostanie wysana, metoda **`onReceive`** odbiornika jest wywoywana, co umo偶liwia aplikacji odpowiedni reakcj, na przykad dostosowanie zachowania w odpowiedzi na alert o niskim poziomie baterii.

Transmisje mog by **asynchroniczne**, docierajc do wszystkich odbiornik贸w bez kolejnoci, lub **synchronizowane**, gdzie odbiorniki otrzymuj transmisj na podstawie ustalonych priorytet贸w. Wa偶ne jest jednak, aby zauwa偶y potencjalne ryzyko bezpieczestwa, poniewa偶 ka偶da aplikacja mo偶e nada sobie priorytet, aby przechwyci transmisj.

Aby zrozumie funkcjonalno odbiornika, nale偶y poszuka metody **`onReceive`** w jego klasie. Kod tej metody mo偶e manipulowa otrzyman Intencj, co podkrela potrzeb walidacji danych przez odbiorniki, szczeg贸lnie w **Ordered Broadcasts**, kt贸re mog modyfikowa lub odrzuca Intencj.

### Content Provider

**Content Providers** s niezbdne do **dzielenia si danymi strukturalnymi** midzy aplikacjami, podkrelajc znaczenie wdra偶ania **uprawnie** w celu zapewnienia bezpieczestwa danych. Umo偶liwiaj aplikacjom dostp do danych z r贸偶nych 藕r贸de, w tym baz danych, system贸w plik贸w lub internetu. Specyficzne uprawnienia, takie jak **`readPermission`** i **`writePermission`**, s kluczowe dla kontrolowania dostpu. Dodatkowo, tymczasowy dostp mo偶e by przyznany za pomoc ustawie **`grantUriPermission`** w manifecie aplikacji, wykorzystujc atrybuty takie jak `path`, `pathPrefix` i `pathPattern` do szczeg贸owej kontroli dostpu.

Walidacja danych jest kluczowa, aby zapobiec lukom w zabezpieczeniach, takim jak SQL injection. Content Providers wspieraj podstawowe operacje: `insert()`, `update()`, `delete()`, i `query()`, uatwiajc manipulacj danymi i ich udostpnianie midzy aplikacjami.

**FileProvider**, wyspecjalizowany Content Provider, koncentruje si na bezpiecznym udostpnianiu plik贸w. Jest definiowany w manifecie aplikacji z okrelonymi atrybutami do kontrolowania dostpu do folder贸w, oznaczonymi przez `android:exported` i `android:resource` wskazujcymi na konfiguracje folder贸w. Nale偶y zachowa ostro偶no przy udostpnianiu katalog贸w, aby unikn przypadkowego ujawnienia wra偶liwych danych.

Przykad deklaracji manifestu dla FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
I przykad okrelania folder贸w wsp贸dzielonych w `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
For further information check:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews s jak **mini przegldarki internetowe** wewntrz aplikacji Android, pobierajce treci z sieci lub z lokalnych plik贸w. Staj w obliczu podobnych ryzyk jak zwyke przegldarki, jednak istniej sposoby na **zmniejszenie tych ryzyk** poprzez konkretne **ustawienia**.

Android oferuje dwa g贸wne typy WebView:

- **WebViewClient** jest wietny do podstawowego HTML, ale nie obsuguje funkcji alert JavaScript, co wpywa na to, jak mo偶na testowa ataki XSS.
- **WebChromeClient** dziaa bardziej jak pene dowiadczenie przegldarki Chrome.

Kluczowym punktem jest to, 偶e przegldarki WebView **nie dziel si ciasteczkami** z g贸wn przegldark urzdzenia.

Do adowania treci dostpne s metody takie jak ````loadUrl````, ````loadData````, i ````loadDataWithBaseURL````. Wa偶ne jest, aby upewni si, 偶e te adresy URL lub pliki s **bezpieczne do u偶ycia**. Ustawienia bezpieczestwa mo偶na zarzdza za pomoc klasy ````WebSettings````. Na przykad, wyczenie JavaScript za pomoc ````setJavaScriptEnabled(false)```` mo偶e zapobiec atakom XSS.

JavaScript "Bridge" pozwala obiektom Java na interakcj z JavaScript, wymagajc, aby metody byy oznaczone jako ````@JavascriptInterface```` dla bezpieczestwa od Androida 4.2 wzwy偶.

Zezwolenie na dostp do treci (````setAllowContentAccess(true)````) pozwala WebView na dostp do Content Providers, co mo偶e stanowi ryzyko, chyba 偶e adresy URL treci s zweryfikowane jako bezpieczne.

Aby kontrolowa dostp do plik贸w:
- Wyczenie dostpu do plik贸w (````setAllowFileAccess(false)````) ogranicza dostp do systemu plik贸w, z wyjtkami dla niekt贸rych zasob贸w, zapewniajc, 偶e s one u偶ywane tylko do treci niewra偶liwych.

## Other App Components and Mobile Device Management

### **Digital Signing of Applications**

- **Podpis cyfrowy** jest koniecznoci dla aplikacji Android, zapewniajc, 偶e s **autentycznie napisane** przed instalacj. Proces ten wykorzystuje certyfikat do identyfikacji aplikacji i musi by zweryfikowany przez mened偶era pakiet贸w urzdzenia podczas instalacji. Aplikacje mog by **samopodpisane lub certyfikowane przez zewntrzne CA**, chronic przed nieautoryzowanym dostpem i zapewniajc, 偶e aplikacja pozostaje nienaruszona podczas dostarczania do urzdzenia.

### **App Verification for Enhanced Security**

- Poczwszy od **Androida 4.2**, funkcja zwana **Weryfikacja aplikacji** pozwala u偶ytkownikom na sprawdzenie aplikacji pod ktem bezpieczestwa przed instalacj. Ten **proces weryfikacji** mo偶e ostrzega u偶ytkownik贸w przed potencjalnie szkodliwymi aplikacjami lub nawet zapobiega instalacji szczeg贸lnie zoliwych, zwikszajc bezpieczestwo u偶ytkownik贸w.

### **Mobile Device Management (MDM)**

- **Rozwizania MDM** zapewniaj **nadz贸r i bezpieczestwo** dla urzdze mobilnych poprzez **API administracji urzdzeniami**. Wymagaj one zainstalowania aplikacji Android, aby skutecznie zarzdza i zabezpiecza urzdzenia mobilne. Kluczowe funkcje obejmuj **egzekwowanie polityk hase**, **wymuszanie szyfrowania pamici** oraz **zezwalanie na zdalne usuwanie danych**, zapewniajc kompleksow kontrol i bezpieczestwo nad urzdzeniami mobilnymi.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si trikami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}
