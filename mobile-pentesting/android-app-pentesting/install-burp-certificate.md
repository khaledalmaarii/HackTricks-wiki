# Instalacja certyfikatu Burp

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytori贸w GitHub.**

</details>

## Na maszynie wirtualnej

Po pierwsze, musisz pobra certyfikat Der z Burp. Mo偶esz to zrobi w _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../.gitbook/assets/image (367).png>)

**Eksportuj certyfikat w formacie Der** i przekszta go w form, kt贸r **Android** bdzie w stanie **zrozumie**. Zauwa偶, 偶e **aby skonfigurowa certyfikat burp na maszynie Android w AVD**, musisz **uruchomi** t maszyn **z opcj** **`-writable-system`**.\
Na przykad, mo偶esz uruchomi j tak:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Nastpnie, aby **skonfigurowa certyfikat Burp**, wykonaj nastpujce kroki:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Po zakoczeniu **ponownego uruchamiania urzdzenia** certyfikat Burp bdzie u偶ywany przez nie!

## U偶ywanie Magisc

Jeli **zrootowae swoje urzdzenie za pomoc Magisc** (mo偶e to by emulator) i **nie mo偶esz** wykona poprzednich **krok贸w** w celu zainstalowania certyfikatu Burp, poniewa偶 **system plik贸w jest tylko do odczytu** i nie mo偶na go zamontowa jako zapisywalny, istnieje inny spos贸b.

Jak wyjaniono w [**tym filmie**](https://www.youtube.com/watch?v=qQicUW0svB8), musisz:

1. **Zainstalowa certyfikat CA**: Po prostu **przecignij i upu** certyfikat Burp w formacie DER, **zmieniajc rozszerzenie** na `.crt` na urzdzeniu mobilnym, aby by przechowywany w folderze Pobrane, a nastpnie przejd藕 do `Zainstaluj certyfikat` -> `Certyfikat CA`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* Sprawd藕, czy certyfikat zosta poprawnie zapisany, przechodzc do `Zaufane powiadczenia` -> `U呕YTKOWNIK`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Uczy go zaufanym przez system**: Pobierz modu Magisc [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (plik .zip), **przecignij i upu go** na telefonie, przejd藕 do aplikacji **Magics** na telefonie, do sekcji **`Moduy`**, kliknij **`Zainstaluj z pamici`**, wybierz modu `.zip` i po zainstalowaniu **ponownie uruchom** telefon:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Po ponownym uruchomieniu przejd藕 do `Zaufane powiadczenia` -> `SYSTEM` i sprawd藕, czy certyfikat Postswigger jest tam

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Po Androidzie 14

W najnowszej wersji Androida 14 zaobserwowano znaczc zmian w obsudze certyfikat贸w autoryzujcych (CA) zaufanych przez system. Wczeniej te certyfikaty byy przechowywane w **`/system/etc/security/cacerts/`**, dostpne i modyfikowalne przez u偶ytkownik贸w posiadajcych uprawnienia root, co umo偶liwiao natychmiastowe zastosowanie ich w caym systemie. Jednak w przypadku Androida 14 lokalizacja przechowywania zostaa przeniesiona do **`/apex/com.android.conscrypt/cacerts`**, katalogu w cie偶ce **`/apex`**, kt贸ry jest niezmienialny z natury.

Pr贸by ponownego zamontowania cie偶ki **APEX cacerts** jako zapisywalnej kocz si niepowodzeniem, poniewa偶 system nie zezwala na takie operacje. Nawet pr贸by odmontowania lub nao偶enia na katalog tymczasowego systemu plik贸w (tmpfs) nie omijaj niezmiennoci; aplikacje nadal maj dostp do oryginalnych danych certyfikat贸w bez wzgldu na zmiany na poziomie systemu plik贸w. Ta odporno wynika z konfiguracji montowania **`/apex`** z propagacj PRIVATE, zapewniajc, 偶e wszelkie modyfikacje w katalogu **`/apex`** nie wpywaj na inne procesy.

Inicjalizacja Androida polega na uruchomieniu procesu `init`, kt贸ry przy uruchamianiu systemu operacyjnego inicjuje r贸wnie偶 proces Zygote. Proces ten jest odpowiedzialny za uruchamianie proces贸w aplikacji w nowej przestrzeni nazw montowania, kt贸ra obejmuje prywatne montowanie **`/apex`**, izolujc tym samym zmiany w tym katalogu od innych proces贸w.

Mimo to istnieje obejcie dla tych, kt贸rzy musz modyfikowa certyfikaty CA zaufane przez system w katalogu **`/apex`**. Polega to na rcznym ponownym zamontowaniu **`/apex`**, aby usun propagacj PRIVATE i umo偶liwi zapisywanie. Proces ten obejmuje skopiowanie zawartoci **`/apex/com.android.conscrypt`** do innego miejsca, odmontowanie katalogu **`/apex/com.android.conscrypt`** w celu usunicia ograniczenia tylko do odczytu, a nastpnie przywr贸cenie zawartoci do jej pierwotnego miejsca w **`/apex`**. Ten spos贸b wymaga szybkiego dziaania, aby unikn awarii systemu. Aby zapewni zastosowanie tych zmian w caym systemie, zaleca si ponowne uruchomienie `system_server`, co skutkuje ponownym uruchomieniem wszystkich aplikacji i przywr贸ceniem systemu do sp贸jnego stanu.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Montowanie katalogu za pomoc NSEnter

1. **Konfiguracja zapisywalnego katalogu**: Na pocztku, ustanawiany jest zapisywalny katalog poprzez zamontowanie `tmpfs` nad istniejcym katalogiem certyfikat贸w systemowych nie-APEX. Mo偶na to osign za pomoc nastpujcej komendy:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Przygotowanie certyfikat贸w CA**: Po skonfigurowaniu katalogu z mo偶liwoci zapisu, nale偶y skopiowa do niego zamierzone certyfikaty CA. Mo偶e to wymaga skopiowania domylnych certyfikat贸w z `/apex/com.android.conscrypt/cacerts/`. Wa偶ne jest odpowiednie dostosowanie uprawnie i etykiet SELinux tych certyfikat贸w.

3. **Bind Mounting dla Zygote**: Korzystajc z `nsenter`, wchodzimy do przestrzeni nazw montowania Zygote. Zygote, bdcy procesem odpowiedzialnym za uruchamianie aplikacji Androida, wymaga tego kroku, aby zapewni, 偶e wszystkie aplikacje uruchomione od tego momentu bd korzysta z nowo skonfigurowanych certyfikat贸w CA. U偶ywane polecenie to:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
To zapewnia, 偶e ka偶da nowa uruchomiona aplikacja bdzie przestrzega zaktualizowanego ustawienia certyfikat贸w CA.

4. **Zastosowanie zmian do dziaajcych aplikacji**: Aby zastosowa zmiany do ju偶 uruchomionych aplikacji, ponownie u偶ywamy `nsenter`, aby wej do przestrzeni nazw ka偶dej aplikacji indywidualnie i wykona podobne zamontowanie. Wymagane polecenie to:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternatywne podejcie - mikkie ponowne uruchomienie**: Alternatywna metoda polega na wykonaniu bind mount na procesie `init` (PID 1), a nastpnie na mikkim ponownym uruchomieniu systemu operacyjnego za pomoc polece `stop && start`. To podejcie propaguje zmiany we wszystkich przestrzeniach nazw, eliminujc konieczno indywidualnego adresowania ka偶dej uruchomionej aplikacji. Jednak ta metoda jest zazwyczaj mniej preferowana ze wzgldu na niedogodno ponownego uruchamiania systemu.

## Referencje
* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
