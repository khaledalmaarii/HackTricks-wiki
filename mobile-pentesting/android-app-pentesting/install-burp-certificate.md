# Burp-Zertifikat installieren

<details>

<summary>Lernen Sie das Hacken von AWS von Grund auf mit <a href="https://training.hacktricks.xyz/courses/arte">htARTE (HackTricks AWS Red Team Expert)</a>!</summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

- Wenn Sie Ihr Unternehmen in HackTricks bewerben m√∂chten oder HackTricks als PDF herunterladen m√∂chten, √ºberpr√ºfen Sie die [ABONNEMENTPL√ÑNE](https://github.com/sponsors/carlospolop)!
- Holen Sie sich das offizielle PEASS & HackTricks-Merchandise
- Entdecken Sie die PEASS-Familie, unsere Sammlung exklusiver NFTs
- Treten Sie der Discord-Gruppe oder der Telegram-Gruppe bei oder folgen Sie uns auf Twitter
- Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die HackTricks- und HackTricks Cloud-GitHub-Repositories senden

</details>

## In einer virtuellen Maschine

Zun√§chst m√ºssen Sie das Der-Zertifikat von Burp herunterladen. Dies k√∂nnen Sie in _**Proxy**_ --> _**Optionen**_ --> _**CA-Zertifikat importieren/exportieren**_ tun.

![](<../../.gitbook/assets/image (367).png>)

**Exportieren Sie das Zertifikat im Der-Format** und wandeln Sie es in eine Form um, die **Android** verstehen kann. Beachten Sie, dass Sie **zum Konfigurieren des Burp-Zertifikats auf der Android-Maschine in AVD** diese Maschine **mit der Option `-writable-system`** ausf√ºhren m√ºssen.\
Sie k√∂nnen es zum Beispiel so ausf√ºhren:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Dann, um das Zertifikat von Burp zu konfigurieren, tun Sie Folgendes:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Sobald die **Maschine neu gestartet** ist, wird das Burp-Zertifikat von ihr verwendet!

## Mit Magisc

Wenn Sie Ihr Ger√§t mit Magisc **gerootet** haben (vielleicht ein Emulator) und Sie den vorherigen **Schritten** zum Installieren des Burp-Zertifikats nicht folgen k√∂nnen, weil das **Dateisystem schreibgesch√ºtzt** ist und Sie es nicht beschreibbar umh√§ngen k√∂nnen, gibt es einen anderen Weg.

Wie in [**diesem Video**](https://www.youtube.com/watch?v=qQicUW0svB8) erkl√§rt, m√ºssen Sie Folgendes tun:

1. **Installieren Sie ein CA-Zertifikat**: Ziehen Sie einfach das DER-Burp-Zertifikat **mit √Ñnderung der Erweiterung** in `.crt` auf das Mobilger√§t, damit es im Download-Ordner gespeichert wird, und gehen Sie zu `Installieren Sie ein Zertifikat` -> `CA-Zertifikat`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* √úberpr√ºfen Sie, ob das Zertifikat korrekt gespeichert wurde, indem Sie zu `Vertrauensw√ºrdige Anmeldeinformationen` -> `BENUTZER` gehen

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Machen Sie es systemweit vertrauensw√ºrdig**: Laden Sie das Magisc-Modul [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (eine .zip-Datei) herunter, **ziehen Sie es** auf das Telefon, gehen Sie zur **Magics-App** auf dem Telefon zum Abschnitt **`Module`**, klicken Sie auf **`Von Speicher installieren`**, w√§hlen Sie das `.zip`-Modul aus und starten Sie das Telefon nach der Installation **neu**:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Nach dem Neustart gehen Sie zu `Vertrauensw√ºrdige Anmeldeinformationen` -> `SYSTEM` und √ºberpr√ºfen Sie, ob das Postswigger-Zertifikat vorhanden ist

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Nach Android 14

In der neuesten Version von Android 14 wurde eine bedeutende √Ñnderung im Umgang mit systemweit vertrauensw√ºrdigen Zertifizierungsstellen (CA) beobachtet. Zuvor waren diese Zertifikate in **`/system/etc/security/cacerts/`** gespeichert und von Benutzern mit Root-Rechten zug√§nglich und √§nderbar, was eine sofortige Anwendung im gesamten System erm√∂glichte. Mit Android 14 wurde der Speicherort jedoch in **`/apex/com.android.conscrypt/cacerts`** verschoben, ein Verzeichnis im Pfad **`/apex`**, das von Natur aus unver√§nderlich ist.

Versuche, den **APEX cacerts-Pfad** als beschreibbar zu mounten, scheitern, da das System solche Operationen nicht zul√§sst. Selbst Versuche, das Verzeichnis mit einem tempor√§ren Dateisystem (tmpfs) zu entmounten oder zu √ºberlagern, umgehen nicht die Unver√§nderlichkeit; Anwendungen greifen weiterhin auf die urspr√ºnglichen Zertifikatsdaten zu, unabh√§ngig von √Ñnderungen auf Dateisystemebene. Diese Widerstandsf√§higkeit beruht darauf, dass das **`/apex`**-Mount mit PRIVATE-Propagation konfiguriert ist, sodass √Ñnderungen innerhalb des **`/apex`**-Verzeichnisses keine Auswirkungen auf andere Prozesse haben.

Die Initialisierung von Android umfasst den `init`-Prozess, der beim Starten des Betriebssystems auch den Zygote-Prozess startet. Dieser Prozess ist daf√ºr verantwortlich, Anwendungsprozesse mit einem neuen Mount-Namespace zu starten, der ein privates **`/apex`**-Mount enth√§lt und somit √Ñnderungen in diesem Verzeichnis von anderen Prozessen isoliert.

Dennoch gibt es eine L√∂sung f√ºr diejenigen, die die systemweit vertrauensw√ºrdigen CA-Zertifikate im **`/apex`**-Verzeichnis √§ndern m√ºssen. Dies beinhaltet das manuelle Umh√§ngen von **`/apex`**, um die PRIVATE-Propagation zu entfernen und es beschreibbar zu machen. Der Prozess umfasst das Kopieren des Inhalts von **`/apex/com.android.conscrypt`** an einen anderen Ort, das Entmounten des Verzeichnisses **`/apex/com.android.conscrypt`**, um die schreibgesch√ºtzte Einschr√§nkung zu beseitigen, und das Wiederherstellen des Inhalts an ihren urspr√ºnglichen Speicherort innerhalb von **`/apex`**. Dieser Ansatz erfordert schnelles Handeln, um Systemabst√ºrze zu vermeiden. Um die systemweite Anwendung dieser √Ñnderungen sicherzustellen, wird empfohlen, den `system_server` neu zu starten, der alle Anwendungen effektiv neu startet und das System in einen konsistenten Zustand versetzt.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-Mounting durch NSEnter

1. **Einrichten eines beschreibbaren Verzeichnisses**: Zun√§chst wird ein beschreibbares Verzeichnis eingerichtet, indem ein `tmpfs` √ºber das vorhandene nicht-APEX-Systemzertifikatverzeichnis gemountet wird. Dies wird mit dem folgenden Befehl erreicht:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Vorbereitung der CA-Zertifikate**: Nachdem das beschreibbare Verzeichnis eingerichtet wurde, sollten die CA-Zertifikate, die verwendet werden sollen, in dieses Verzeichnis kopiert werden. Dies kann das Kopieren der Standardzertifikate von `/apex/com.android.conscrypt/cacerts/` beinhalten. Es ist wichtig, die Berechtigungen und SELinux-Labels dieser Zertifikate entsprechend anzupassen.

3. **Bind-Mounting f√ºr Zygote**: Mit Hilfe von `nsenter` betritt man den Mount-Namespace von Zygote. Zygote ist der Prozess, der f√ºr das Starten von Android-Anwendungen verantwortlich ist, und dieser Schritt ist erforderlich, um sicherzustellen, dass alle anschlie√üend gestarteten Anwendungen die neu konfigurierten CA-Zertifikate verwenden. Der verwendete Befehl lautet:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Dies stellt sicher, dass jede neue gestartete App der aktualisierten CA-Zertifikatskonfiguration folgt.

4. **Anwenden von √Ñnderungen auf laufende Apps**: Um die √Ñnderungen auf bereits laufende Anwendungen anzuwenden, wird erneut `nsenter` verwendet, um den Namespace jeder App einzeln zu betreten und einen √§hnlichen Bind-Mount durchzuf√ºhren. Der erforderliche Befehl lautet:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternative Ansatz - Soft Reboot**: Eine alternative Methode besteht darin, das Bind-Mount auf den `init`-Prozess (PID 1) durchzuf√ºhren, gefolgt von einem Soft-Reboot des Betriebssystems mit den Befehlen `stop && start`. Mit diesem Ansatz werden die √Ñnderungen in allen Namespaces propagiert, sodass es nicht erforderlich ist, jede laufende App einzeln anzusprechen. Diese Methode wird jedoch im Allgemeinen weniger bevorzugt, da ein Neustart umst√§ndlich ist.

## Referenzen
* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<details>

<summary><strong>Lernen Sie das Hacken von AWS von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
