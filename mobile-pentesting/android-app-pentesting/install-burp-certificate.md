# Instalirajte Burp Sertifikat

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Na Virtuelnoj MaÅ¡ini

Prvo Å¡to treba da uradite je da preuzmete Der sertifikat sa Burp-a. To moÅ¾ete uraditi u _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../.gitbook/assets/image (367).png>)

**Izvezite sertifikat u Der formatu** i hajde da **transformiÅ¡emo** to u oblik koji **Android** moÅ¾e da **razume.** Imajte na umu da **da biste konfigurisali burp sertifikat na Android maÅ¡ini u AVD-u** morate **pokrenuti** ovu maÅ¡inu **sa** **`-writable-system`** opcijom.\
Na primer, moÅ¾ete je pokrenuti ovako:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Zatim, da **konfiguriÅ¡ete burp sertifikat uradite**:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Kada **maÅ¡ina zavrÅ¡i sa ponovnim pokretanjem**, Burp sertifikat Ä‡e biti u upotrebi!

## KoriÅ¡Ä‡enje Magisc

Ako ste **rootovali svoj ureÄ‘aj sa Magisc** (moÅ¾da emulator), i ne moÅ¾ete da pratite prethodne **korake** za instalaciju Burp certifikata jer je **fajl sistem samo za Äitanje** i ne moÅ¾ete ga ponovo montirati kao zapisiv, postoji drugi naÄin.

ObjaÅ¡njeno u [**ovom videu**](https://www.youtube.com/watch?v=qQicUW0svB8) potrebno je da:

1. **Instalirate CA sertifikat**: Samo **prevucite i ispustite** DER Burp sertifikat **menjajuÄ‡i ekstenziju** u `.crt` na mobilnom ureÄ‘aju tako da bude smeÅ¡ten u Downloads folder i idite na `Instaliraj sertifikat` -> `CA sertifikat`

<figure><img src="../../.gitbook/assets/image (53).png" alt="" width="164"><figcaption></figcaption></figure>

* Proverite da li je sertifikat ispravno smeÅ¡ten odlaskom na `Poverljivi podaci` -> `KORISNIK`

<figure><img src="../../.gitbook/assets/image (54).png" alt="" width="334"><figcaption></figcaption></figure>

2. **UÄinite ga sistemski poverljivim**: Preuzmite Magisc modul [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (zip fajl), **prevucite i ispustite ga** na telefon, idite na **Magics aplikaciju** na telefonu u **`Module`** sekciju, kliknite na **`Instaliraj iz skladiÅ¡ta`**, izaberite `.zip` modul i nakon instalacije **ponovo pokrenite** telefon:

<figure><img src="../../.gitbook/assets/image (55).png" alt="" width="345"><figcaption></figcaption></figure>

* Nakon ponovnog pokretanja, idite na `Poverljivi podaci` -> `SISTEM` i proverite da li je Postswigger sertifikat tu

<figure><img src="../../.gitbook/assets/image (56).png" alt="" width="314"><figcaption></figcaption></figure>

## Post Android 14

U najnovijem izdanju Android 14, primeÄ‡en je znaÄajan pomak u upravljanju sistemski poverljivim sertifikatima sertifikacione vlasti (CA). Prethodno su ovi sertifikati bili smeÅ¡teni u **`/system/etc/security/cacerts/`**, dostupni i modifikovani od strane korisnika sa root privilegijama, Å¡to je omoguÄ‡avalo trenutnu primenu Å¡irom sistema. MeÄ‘utim, sa Android 14, lokacija skladiÅ¡tenja je premestena u **`/apex/com.android.conscrypt/cacerts`**, direktorijum unutar **`/apex`** putanje, koji je po prirodi nepromenljiv.

PokuÅ¡aji ponovnog montiranja **APEX cacerts putanje** kao zapisive se susreÄ‡u sa neuspehom, jer sistem ne dozvoljava takve operacije. ÄŒak ni pokuÅ¡aji da se direktorijum odmontira ili preklopi sa privremenim fajl sistemom (tmpfs) ne zaobilaze nepromenljivost; aplikacije nastavljaju da pristupaju originalnim podacima sertifikata bez obzira na promene na nivou fajl sistema. Ova otpornost je rezultat toga Å¡to je **`/apex`** montiranje konfigurisano sa PRIVATE propagacijom, osiguravajuÄ‡i da bilo kakve izmene unutar **`/apex`** direktorijuma ne utiÄu na druge procese.

Inicijalizacija Android-a ukljuÄuje `init` proces, koji, prilikom pokretanja operativnog sistema, takoÄ‘e pokreÄ‡e Zygote proces. Ovaj proces je odgovoran za pokretanje aplikacionih procesa sa novim montiranim imenskim prostorom koji ukljuÄuje privatno **`/apex`** montiranje, Äime se izoluje promene u ovom direktorijumu od drugih procesa.

Ipak, postoji reÅ¡enje za one koji trebaju da modifikuju sistemski poverljive CA sertifikate unutar **`/apex`** direktorijuma. Ovo ukljuÄuje ruÄno ponovo montiranje **`/apex`** kako bi se uklonila PRIVATE propagacija, Äime se omoguÄ‡ava zapisivanje. Proces ukljuÄuje kopiranje sadrÅ¾aja **`/apex/com.android.conscrypt`** na drugo mesto, odmontiranje **`/apex/com.android.conscrypt`** direktorijuma kako bi se eliminisala ograniÄenja samo za Äitanje, a zatim vraÄ‡anje sadrÅ¾aja na njihovu originalnu lokaciju unutar **`/apex`**. Ovaj pristup zahteva brzu akciju kako bi se izbegli padovi sistema. Da bi se osigurala sistemska primena ovih izmena, preporuÄuje se ponovo pokretanje `system_server`, Å¡to efikasno ponovo pokreÄ‡e sve aplikacije i dovodi sistem u dosledno stanje.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting through NSEnter

1. **Postavljanje pisivog direktorijuma**: U poÄetku, pisivi direktorijum se uspostavlja montiranjem `tmpfs` preko postojeÄ‡eg direktorijuma sa sistemskim sertifikatima koji nije APEX. Ovo se postiÅ¾e sledeÄ‡om komandom:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Priprema CA sertifikata**: Nakon postavljanja zapisive direktorijuma, CA sertifikate koje nameravate da koristite treba kopirati u ovaj direktorijum. To moÅ¾e ukljuÄivati kopiranje podrazumevanih sertifikata iz `/apex/com.android.conscrypt/cacerts/`. VaÅ¾no je prilagoditi dozvole i SELinux oznake ovih sertifikata u skladu s tim.  
3. **Bind Mounting za Zygote**: KoriÅ¡Ä‡enjem `nsenter`, ulazi se u Zygote-ov mount namespace. Zygote, kao proces odgovoran za pokretanje Android aplikacija, zahteva ovaj korak kako bi se osiguralo da sve aplikacije pokrenute od sada koriste novo konfigurisane CA sertifikate. Komanda koja se koristi je:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Ovo osigurava da Ä‡e svaka nova aplikacija koja se pokrene poÅ¡tovati aÅ¾uriranu postavku CA sertifikata.

4. **Primena promena na aktivnim aplikacijama**: Da bi se promene primenile na veÄ‡ pokrenutim aplikacijama, `nsenter` se ponovo koristi da uÄ‘e u namespace svake aplikacije pojedinaÄno i izvrÅ¡i sliÄan bind mount. Neophodna komanda je:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternativni pristup - Soft reboot**: Alternativna metoda ukljuÄuje izvoÄ‘enje bind mount-a na `init` procesu (PID 1) nakon Äega sledi soft reboot operativnog sistema sa `stop && start` komandama. Ovaj pristup bi propagirao promene kroz sve namespace-ove, izbegavajuÄ‡i potrebu da se pojedinaÄno obraÄ‘uje svaka aplikacija koja se izvrÅ¡ava. MeÄ‘utim, ova metoda se generalno manje preferira zbog neprijatnosti reboot-a.

## Reference

* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
