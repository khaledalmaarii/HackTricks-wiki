# Instaliranje Burp sertifikata

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}


## Na virtuelnoj ma코ini

Prvo morate preuzeti Der sertifikat sa Burp-a. To mo쬰te uraditi u _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../.gitbook/assets/image (367).png>)

**Izvezite sertifikat u Der formatu** i pretvorite ga u oblik koji 캖e **Android** mo캖i **da razume.** Imajte na umu da **kako biste konfigurisali Burp sertifikat na Android ma코ini u AVD-u** morate **pokrenuti** ovu ma코inu **sa** opcijom **`-writable-system`**.\
Na primer, mo쬰te je pokrenuti ovako:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Zatim, da **konfiguri코ete burpov sertifikat uradite slede캖e**:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Kada se **ma코ina zavr코i sa ponovnim pokretanjem**, sertifikat Burp 캖e biti u upotrebi!

## Kori코캖enje Magiska

Ako ste **rutirali ure캠aj pomo캖u Magiska** (mo쬯a emulator), i ne mo쬰te pratiti prethodne **korake** za instalaciju Burp sertifikata jer je **datote캜ni sistem samo za 캜itanje** i ne mo쬰te ga ponovo montirati kao zapisiv, postoji drugi na캜in.

Obja코njeno u [**ovom videu**](https://www.youtube.com/watch?v=qQicUW0svB8) trebate:

1. **Instalirati CA sertifikat**: Samo **prevucite i otpustite** DER Burp sertifikat **menjaju캖i ekstenziju** u `.crt` na mobilnom ure캠aju tako da bude sme코ten u fascikli za preuzimanje i idite na `Instaliraj sertifikat` -> `CA sertifikat`

<figure><img src="../../.gitbook/assets/image (50).png" alt="" width="164"><figcaption></figcaption></figure>

* Proverite da li je sertifikat pravilno sme코ten odlaskom na `Poverljivi podaci` -> `KORISNIK`

<figure><img src="../../.gitbook/assets/image (51).png" alt="" width="334"><figcaption></figcaption></figure>

2. **U캜inite ga poverljivim za sistem**: Preuzmite Magisk modul [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (`.zip` datoteka), **prevucite i otpustite** je na telefon, idite na **Magisk aplikaciju** na telefonu u odeljku **`Moduli`**, kliknite na **`Instaliraj sa skladi코ta`**, izaberite `.zip` modul i jednom kada se instalira, **ponovo pokrenite** telefon:

<figure><img src="../../.gitbook/assets/image (52).png" alt="" width="345"><figcaption></figcaption></figure>

* Nakon ponovnog pokretanja, idite na `Poverljivi podaci` -> `SISTEM` i proverite da li je Postswigger sertifikat tamo

<figure><img src="../../.gitbook/assets/image (53).png" alt="" width="314"><figcaption></figcaption></figure>

## Nakon Android 14

U najnovijem Android 14 izdanju, prime캖en je zna캜ajan pomak u rukovanju sertifikatima za poverljive sertifikacione autoritete (CA). Ranije su ovi sertifikati bili sme코teni u **`/system/etc/security/cacerts/`**, pristupa캜ni i modifikovani od strane korisnika sa administratorskim privilegijama, 코to je omogu캖avalo trenutnu primenu 코irom sistema. Me캠utim, sa Androidom 14, lokacija skladi코tenja je preme코tena u **`/apex/com.android.conscrypt/cacerts`**, direktorijum unutar putanje **`/apex`**, koji je po prirodi nepromenljiv.

Poku코aji ponovnog montiranja **APEX cacerts putanje** kao zapisive nailaze na neuspeh, jer sistem ne dozvoljava takve operacije. 캛ak i poku코aji demontiranja ili preklapanja direktorijuma privremenim fajl sistemom (tmpfs) ne zaobilaze nepromenljivost; aplikacije i dalje pristupaju originalnim podacima sertifikata bez obzira na promene na nivou fajl sistema. Ova otpornost je rezultat konfiguracije montiranja **`/apex`** sa PRIVATNOM propagacijom, osiguravaju캖i da bilo kakve modifikacije unutar direktorijuma **`/apex`** ne uti캜u na druge procese.

Inicijalizacija Androida uklju캜uje proces `init`, koji, prilikom pokretanja operativnog sistema, tako캠e pokre캖e proces Zygote. Ovaj proces je odgovoran za pokretanje procesa aplikacija sa novim monta쬹im prostorom koji uklju캜uje privatno montiranje **`/apex`**, 캜ime se izoluju promene u ovom direktorijumu od drugih procesa.

Ipak, postoji na캜in za one koji trebaju da modifikuju sertifikate za poverljive CA sertifikate unutar direktorijuma **`/apex`**. To uklju캜uje ru캜no ponovno montiranje **`/apex`** kako bi se uklonila PRIVATNA propagacija, 캜ime se 캜ini zapisivim. Proces uklju캜uje kopiranje sadr쬬ja **`/apex/com.android.conscrypt`** na drugu lokaciju, demontiranje direktorijuma **`/apex/com.android.conscrypt`** kako bi se eliminisalo ograni캜enje samo za 캜itanje, a zatim vra캖anje sadr쬬ja na originalnu lokaciju unutar **`/apex`**. Ovaj pristup zahteva brzu akciju kako bi se izbegli padovi sistema. Da bi se osigurala sistemsko-코iroka primena ovih promena, preporu캜uje se ponovno pokretanje `system_server`, 코to efikasno ponovo pokre캖e sve aplikacije i dovodi sistem u konzistentno stanje.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-montiranje putem NSEnter-a

1. **Postavljanje direktorijuma za pisanje**: Prvo se uspostavlja direktorijum za pisanje montiranjem `tmpfs` preko postoje캖eg direktorijuma za sistemske sertifikate koji nisu APEX. Ovo se posti쬰 slede캖om komandom:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Priprema CA sertifikata**: Nakon pode코avanja upisivog direktorijuma, CA sertifikati koje nameravate koristiti treba da budu kopirani u ovaj direktorijum. To mo쬰 uklju캜ivati kopiranje podrazumevanih sertifikata iz `/apex/com.android.conscrypt/cacerts/`. Bitno je prilagoditi dozvole i SELinux oznake ovih sertifikata prema potrebi.
3. **Bind montiranje za Zygote**: Kori코캖enjem `nsenter`, ulazi se u Zygote-ov mount namespace. Zygote, kao proces odgovoran za pokretanje Android aplikacija, zahteva ovaj korak kako bi se osiguralo da sve aplikacije pokrenute nakon toga koriste novo konfigurisane CA sertifikate. Komanda koja se koristi je:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Ovo osigurava da 캖e svaka nova aplikacija koja se pokrene po코tovati a쬿rirani CA sertifikat setup.

4. **Primenjivanje promena na pokrenute aplikacije**: Da biste primenili promene na ve캖 pokrenute aplikacije, ponovo se koristi `nsenter` da biste pojedina캜no u코li u namespace svake aplikacije i izvr코ili sli캜an bind mount. Neophodna komanda je:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternativni pristup - Soft Reboot**: Alternativna metoda uklju캜uje izvo캠enje bind mounta na `init` procesu (PID 1), pra캖eno soft restartovanjem operativnog sistema pomo캖u `stop && start` komandi. Ovaj pristup bi pro코irio promene preko svih namespace-ova, izbegavaju캖i potrebu da se pojedina캜no adresiraju svaka pokrenuta aplikacija. Me캠utim, ovaj metod je generalno manje preferiran zbog neugodnosti restartovanja.

## Reference

* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od po캜etnika do stru캜njaka sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite **zvani캜ni PEASS & HackTricks swag** na [**ovoj stranici**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
