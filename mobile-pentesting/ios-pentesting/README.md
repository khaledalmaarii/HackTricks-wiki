# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las **herramientas comunitarias m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
{% endhint %}

## iOS Basics

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testing Environment

En esta p√°gina puedes encontrar informaci√≥n sobre el **simulador de iOS**, **emuladores** y **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Initial Analysis

### Basic iOS Testing Operations

Durante la prueba **se van a sugerir varias operaciones** (conectar al dispositivo, leer/escribir/subir/bajar archivos, usar algunas herramientas...). Por lo tanto, si no sabes c√≥mo realizar alguna de estas acciones, por favor, **comienza a leer la p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para los siguientes pasos **la aplicaci√≥n debe estar instalada** en el dispositivo y ya debe haber obtenido el **archivo IPA** de la aplicaci√≥n.\
Lee la p√°gina [Basic iOS Testing Operations](basic-ios-testing-operations.md) para aprender c√≥mo hacer esto.
{% endhint %}

### Basic Static Analysis

Se recomienda usar la herramienta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar un An√°lisis Est√°tico autom√°tico al archivo IPA.

Identificaci√≥n de **protecciones presentes en el binario**:

*   **PIE (Position Independent Executable)**: Cuando est√° habilitado, la aplicaci√≥n se carga en una direcci√≥n de memoria aleatoria cada vez que se inicia, lo que dificulta predecir su direcci√≥n de memoria inicial.

```bash
otool -hv <app-binary> | grep PIE   # Debe incluir la bandera PIE
```
*   **Stack Canaries**: Para validar la integridad de la pila, se coloca un valor de ‚Äòcanario‚Äô en la pila antes de llamar a una funci√≥n y se valida nuevamente una vez que la funci√≥n termina.

```bash
otool -I -v <app-binary> | grep stack_chk   # Debe incluir los s√≠mbolos: stack_chk_guard y stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Para prevenir fallos comunes de corrupci√≥n de memoria

```bash
otool -I -v <app-binary> | grep objc_release   # Debe incluir el s√≠mbolo _objc_release
```
*   **Binary Encriptado**: El binario debe estar encriptado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # El cryptid debe ser 1
```

**Identificaci√≥n de Funciones Sensibles/Inseguras**

*   **Algoritmos de Hashing D√©biles**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# En linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Funciones Aleatorias Inseguras**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# En linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Funci√≥n ‚ÄòMalloc‚Äô Insegura**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# En linux
grep -iER "_malloc"
```
*   **Funciones Inseguras y Vulnerables**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# En linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Basic Dynamic Analysis

Revisa el an√°lisis din√°mico que realiza [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Necesitar√°s navegar a trav√©s de las diferentes vistas e interactuar con ellas, pero estar√° enganchando varias clases al hacer otras cosas y preparar√° un informe una vez que hayas terminado.

### Listing Installed Apps

Utiliza el comando `frida-ps -Uai` para determinar el **identificador de paquete** de las aplicaciones instaladas:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumeraci√≥n B√°sica y Hooking

Aprende a **enumerar los componentes de la aplicaci√≥n** y c√≥mo **hookear m√©todos y clases** con objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estructura de IPA

La estructura de un **archivo IPA** es esencialmente la de un **paquete comprimido**. Al renombrar su extensi√≥n a `.zip`, se puede **descomprimir** para revelar su contenido. Dentro de esta estructura, un **Bundle** representa una aplicaci√≥n completamente empaquetada lista para la instalaci√≥n. Dentro, encontrar√°s un directorio llamado `<NAME>.app`, que encapsula los recursos de la aplicaci√≥n.

* **`Info.plist`**: Este archivo contiene detalles de configuraci√≥n espec√≠ficos de la aplicaci√≥n.
* **`_CodeSignature/`**: Este directorio incluye un archivo plist que contiene una firma, asegurando la integridad de todos los archivos en el bundle.
* **`Assets.car`**: Un archivo comprimido que almacena archivos de recursos como √≠conos.
* **`Frameworks/`**: Esta carpeta alberga las bibliotecas nativas de la aplicaci√≥n, que pueden estar en forma de archivos `.dylib` o `.framework`.
* **`PlugIns/`**: Esto puede incluir extensiones a la aplicaci√≥n, conocidas como archivos `.appex`, aunque no siempre est√°n presentes. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Se utiliza para guardar los datos permanentes de tu aplicaci√≥n para uso offline, para almacenar datos temporales en cach√© y para agregar funcionalidad de deshacer a tu aplicaci√≥n en un solo dispositivo. Para sincronizar datos en m√∫ltiples dispositivos en una sola cuenta de iCloud, Core Data refleja autom√°ticamente tu esquema a un contenedor de CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): El archivo `PkgInfo` es una forma alternativa de especificar los c√≥digos de tipo y creador de tu aplicaci√≥n o bundle.
* **en.lproj, fr.proj, Base.lproj**: Son los paquetes de idioma que contienen recursos para esos idiomas espec√≠ficos, y un recurso predeterminado en caso de que un idioma no est√© soportado.
* **Seguridad**: El directorio `_CodeSignature/` juega un papel cr√≠tico en la seguridad de la aplicaci√≥n al verificar la integridad de todos los archivos empaquetados a trav√©s de firmas digitales.
* **Gesti√≥n de Activos**: El archivo `Assets.car` utiliza compresi√≥n para gestionar de manera eficiente los activos gr√°ficos, crucial para optimizar el rendimiento de la aplicaci√≥n y reducir su tama√±o total.
* **Frameworks y PlugIns**: Estos directorios subrayan la modularidad de las aplicaciones iOS, permitiendo a los desarrolladores incluir bibliotecas de c√≥digo reutilizables (`Frameworks/`) y extender la funcionalidad de la aplicaci√≥n (`PlugIns/`).
* **Localizaci√≥n**: La estructura soporta m√∫ltiples idiomas, facilitando el alcance global de la aplicaci√≥n al incluir recursos para paquetes de idiomas espec√≠ficos.

**Info.plist**

El **Info.plist** sirve como una piedra angular para las aplicaciones iOS, encapsulando datos de configuraci√≥n clave en forma de **pares clave-valor**. Este archivo es un requisito no solo para aplicaciones, sino tambi√©n para extensiones de aplicaciones y frameworks empaquetados dentro. Est√° estructurado en formato XML o binario y contiene informaci√≥n cr√≠tica que abarca desde permisos de la aplicaci√≥n hasta configuraciones de seguridad. Para una exploraci√≥n detallada de las claves disponibles, se puede consultar la [**Documentaci√≥n para Desarrolladores de Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Para aquellos que buscan trabajar con este archivo en un formato m√°s accesible, la conversi√≥n a XML se puede lograr f√°cilmente mediante el uso de `plutil` en macOS (disponible de forma nativa en versiones 10.2 y posteriores) o `plistutil` en Linux. Los comandos para la conversi√≥n son los siguientes:

* **Para macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Para Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Entre la mir√≠ada de informaci√≥n que el archivo **Info.plist** puede revelar, las entradas notables incluyen cadenas de permisos de la aplicaci√≥n (`UsageDescription`), esquemas de URL personalizados (`CFBundleURLTypes`), y configuraciones para la seguridad del transporte de aplicaciones (`NSAppTransportSecurity`). Estas entradas, junto con otras como tipos de documentos personalizados exportados/importados (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), pueden ser localizadas f√°cilmente inspeccionando el archivo o empleando un simple comando `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Rutas de Datos**

En el entorno de iOS, los directorios est√°n designados espec√≠ficamente para **aplicaciones del sistema** y **aplicaciones instaladas por el usuario**. Las aplicaciones del sistema residen en el directorio `/Applications`, mientras que las aplicaciones instaladas por el usuario se colocan en `/var/mobile/containers/Data/Application/`. Estas aplicaciones se asignan un identificador √∫nico conocido como **UUID de 128 bits**, lo que hace que la tarea de localizar manualmente la carpeta de una aplicaci√≥n sea un desaf√≠o debido a la aleatoriedad de los nombres de los directorios.

{% hint style="warning" %}
Como las aplicaciones en iOS deben estar en un entorno aislado, cada aplicaci√≥n tambi√©n tendr√° una carpeta dentro de **`$HOME/Library/Containers`** con el **`CFBundleIdentifier`** de la aplicaci√≥n como nombre de la carpeta.

Sin embargo, ambas carpetas (carpetas de datos y de contenedores) tienen el archivo **`.com.apple.mobile_container_manager.metadata.plist`** que vincula ambos archivos en la clave `MCMetadataIdentifier`).
{% endhint %}

Para facilitar el descubrimiento del directorio de instalaci√≥n de una aplicaci√≥n instalada por el usuario, la **herramienta objection** proporciona un comando √∫til, `env`. Este comando revela informaci√≥n detallada del directorio para la aplicaci√≥n en cuesti√≥n. A continuaci√≥n se muestra un ejemplo de c√≥mo usar este comando:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativamente, el nombre de la aplicaci√≥n se puede buscar dentro de `/private/var/containers` utilizando el comando `find`:
```bash
find /private/var/containers -name "Progname*"
```
Los comandos como `ps` y `lsof` tambi√©n se pueden utilizar para identificar el proceso de la aplicaci√≥n y listar los archivos abiertos, respectivamente, proporcionando informaci√≥n sobre las rutas de directorio activas de la aplicaci√≥n:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Directorio del paquete:**

* **AppName.app**
* Este es el Paquete de Aplicaci√≥n como se vio antes en el IPA, contiene datos esenciales de la aplicaci√≥n, contenido est√°tico as√≠ como el binario compilado de la aplicaci√≥n.
* Este directorio es visible para los usuarios, pero **los usuarios no pueden escribir en √©l**.
* El contenido en este directorio **no se respalda**.
* Los contenidos de esta carpeta se utilizan para **validar la firma del c√≥digo**.

**Directorio de datos:**

* **Documents/**
* Contiene todos los datos generados por el usuario. El usuario final de la aplicaci√≥n inicia la creaci√≥n de estos datos.
* Visible para los usuarios y **los usuarios pueden escribir en √©l**.
* El contenido en este directorio **se respalda**.
* La aplicaci√≥n puede deshabilitar rutas configurando `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contiene todos los **archivos que no son espec√≠ficos del usuario**, como **cach√©s**, **preferencias**, **cookies** y archivos de configuraci√≥n de lista de propiedades (plist).
* Las aplicaciones de iOS suelen usar los subdirectorios `Application Support` y `Caches`, pero la aplicaci√≥n puede crear subdirectorios personalizados.
* **Library/Caches/**
* Contiene **archivos en cach√© semi-persistentes.**
* Invisible para los usuarios y **los usuarios no pueden escribir en √©l**.
* El contenido en este directorio **no se respalda**.
* El sistema operativo puede eliminar autom√°ticamente los archivos de este directorio cuando la aplicaci√≥n no est√° en ejecuci√≥n y el espacio de almacenamiento es bajo.
* **Library/Application Support/**
* Contiene **archivos** **persistentes** necesarios para ejecutar la aplicaci√≥n.
* **Invisible** **para** **los** **usuarios** y los usuarios no pueden escribir en √©l.
* El contenido en este directorio **se respalda**.
* La aplicaci√≥n puede deshabilitar rutas configurando `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Se utiliza para almacenar propiedades que pueden **persistir incluso despu√©s de que se reinicie una aplicaci√≥n**.
* La informaci√≥n se guarda, sin cifrar, dentro del sandbox de la aplicaci√≥n en un archivo plist llamado \[BUNDLE\_ID].plist.
* Todos los pares clave/valor almacenados usando `NSUserDefaults` se pueden encontrar en este archivo.
* **tmp/**
* Utiliza este directorio para escribir **archivos temporales** que no necesitan persistir entre lanzamientos de la aplicaci√≥n.
* Contiene archivos en cach√© no persistentes.
* **Invisible** para los usuarios.
* El contenido en este directorio no se respalda.
* El sistema operativo puede eliminar autom√°ticamente los archivos de este directorio cuando la aplicaci√≥n no est√° en ejecuci√≥n y el espacio de almacenamiento es bajo.

Veamos m√°s de cerca el Paquete de Aplicaci√≥n de iGoat-Swift (.app) dentro del directorio del Paquete (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Dentro de la carpeta `<application-name>.app` encontrar√°s un archivo binario llamado `<application-name>`. Este es el archivo que ser√° **ejecutado**. Puedes realizar una inspecci√≥n b√°sica del binario con la herramienta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verifica si la aplicaci√≥n est√° encriptada**

Mira si hay alguna salida para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desensamblando el binario**

Desensamblar la secci√≥n de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir el **segmento de Objective-C** de la aplicaci√≥n de muestra se puede usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obtener un c√≥digo Objective-C m√°s compacto, puedes usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Sin embargo, las mejores opciones para desensamblar el binario son: [**Hopper**](https://www.hopperapp.com/download.html?) y [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las **herramientas comunitarias m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Almacenamiento de Datos

Para aprender sobre c√≥mo iOS almacena datos en el dispositivo, lee esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Los siguientes lugares para almacenar informaci√≥n deben ser revisados **justo despu√©s de instalar la aplicaci√≥n**, **despu√©s de verificar todas las funcionalidades** de la aplicaci√≥n e incluso despu√©s de **cerrar sesi√≥n de un usuario y entrar en uno diferente**.\
El objetivo es encontrar **informaci√≥n sensible no protegida** de la aplicaci√≥n (contrase√±as, tokens), del usuario actual y de usuarios que han iniciado sesi√≥n anteriormente.
{% endhint %}

### Plist

Los archivos **plist** son archivos XML estructurados que **contienen pares clave-valor**. Es una forma de almacenar datos persistentes, por lo que a veces puedes encontrar **informaci√≥n sensible en estos archivos**. Se recomienda revisar estos archivos despu√©s de instalar la aplicaci√≥n y despu√©s de usarla intensivamente para ver si se escriben nuevos datos.

La forma m√°s com√∫n de persistir datos en archivos plist es a trav√©s del uso de **NSUserDefaults**. Este archivo plist se guarda dentro del sandbox de la aplicaci√≥n en **`Library/Preferences/<appBundleID>.plist`**

La clase [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) proporciona una interfaz program√°tica para interactuar con el sistema predeterminado. El sistema predeterminado permite que una aplicaci√≥n personalice su comportamiento de acuerdo con las **preferencias del usuario**. Los datos guardados por `NSUserDefaults` pueden ser vistos en el paquete de la aplicaci√≥n. Esta clase almacena **datos** en un **archivo plist**, pero est√° destinada a ser utilizada con peque√±as cantidades de datos.

Estos datos no pueden ser accedidos directamente a trav√©s de una computadora de confianza, pero pueden ser accedidos realizando una **copia de seguridad**.

Puedes **volcar** la informaci√≥n guardada usando **`NSUserDefaults`** utilizando `ios nsuserdefaults get` de objection.

Para encontrar todos los plist utilizados por la aplicaci√≥n, puedes acceder a `/private/var/mobile/Containers/Data/Application/{APPID}` y ejecutar:
```bash
find ./ -name "*.plist"
```
Para convertir archivos de formato **XML o binario (bplist)** a XML, hay varios m√©todos disponibles seg√∫n su sistema operativo:

**Para usuarios de macOS:** Utilice el comando `plutil`. Es una herramienta integrada en macOS (10.2+), dise√±ada para este prop√≥sito:
```bash
$ plutil -convert xml1 Info.plist
```
**Para usuarios de Linux:** Instala `libplist-utils` primero, luego usa `plistutil` para convertir tu archivo:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Dentro de una sesi√≥n de Objection:** Para analizar aplicaciones m√≥viles, un comando espec√≠fico te permite convertir archivos plist directamente:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) es un marco para gestionar la capa de modelo de objetos en tu aplicaci√≥n. [Core Data puede usar SQLite como su almacenamiento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), pero el marco en s√≠ no es una base de datos.\
CoreData no cifra sus datos por defecto. Sin embargo, se puede agregar una capa de cifrado adicional a CoreData. Consulta el [GitHub Repo](https://github.com/project-imas/encrypted-core-data) para m√°s detalles.

Puedes encontrar la informaci√≥n de SQLite Core Data de una aplicaci√≥n en la ruta `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si puedes abrir el SQLite y acceder a informaci√≥n sensible, entonces encontraste una mala configuraci√≥n.**

{% code title="Code from iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) es un almac√©n de clave/valor construido sobre SQLite.\
Como las bases de datos Yap son bases de datos sqlite, puedes encontrarlas utilizando el comando propuesto en la secci√≥n anterior.

### Otras Bases de Datos SQLite

Es com√∫n que las aplicaciones creen su propia base de datos sqlite. Pueden estar **almacenando** **datos** **sensibles** en ellas y dej√°ndolos sin cifrar. Por lo tanto, siempre es interesante revisar cada base de datos dentro del directorio de las aplicaciones. Por lo tanto, ve al directorio de la aplicaci√≥n donde se guardan los datos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Los desarrolladores pueden **almacenar y sincronizar datos** dentro de una **base de datos NoSQL alojada en la nube** a trav√©s de Firebase Real-Time Databases. Almacenados en formato JSON, los datos se sincronizan con todos los clientes conectados en tiempo real.

Puedes encontrar c√≥mo verificar bases de datos de Firebase mal configuradas aqu√≠:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) y [Realm Swift](https://realm.io/docs/swift/latest/) ofrecen una alternativa poderosa para el almacenamiento de datos, no proporcionada por Apple. Por defecto, **almacenan datos sin cifrar**, con cifrado disponible a trav√©s de una configuraci√≥n espec√≠fica.

Las bases de datos se encuentran en: `/private/var/mobile/Containers/Data/Application/{APPID}`. Para explorar estos archivos, se pueden utilizar comandos como:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Para ver estos archivos de base de datos, se recomienda la herramienta [**Realm Studio**](https://github.com/realm/realm-studio).

Para implementar la encriptaci√≥n dentro de una base de datos Realm, se puede usar el siguiente fragmento de c√≥digo:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de datos de Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) se describe como un motor de base de datos **liviano** y **embebido** que sigue el enfoque **orientado a documentos** (NoSQL). Dise√±ado para ser nativo de **iOS** y **macOS**, ofrece la capacidad de sincronizar datos sin problemas.

Para identificar posibles bases de datos de Couchbase en un dispositivo, se debe inspeccionar el siguiente directorio:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS almacena las cookies de las aplicaciones en **`Library/Cookies/cookies.binarycookies`** dentro de la carpeta de cada aplicaci√≥n. Sin embargo, los desarrolladores a veces deciden guardarlas en el **keychain** ya que el mencionado **archivo de cookies puede ser accedido en copias de seguridad**.

Para inspeccionar el archivo de cookies, puedes usar [**este script de python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) o usar **`ios cookies get`** de objection.\
**Tambi√©n puedes usar objection para** convertir estos archivos a un formato JSON e inspeccionar los datos.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Por defecto, NSURLSession almacena datos, como **solicitudes y respuestas HTTP en la base de datos Cache.db**. Esta base de datos puede contener **datos sensibles**, si se han almacenado en cach√© tokens, nombres de usuario u otra informaci√≥n sensible. Para encontrar la informaci√≥n en cach√©, abre el directorio de datos de la aplicaci√≥n (`/var/mobile/Containers/Data/Application/<UUID>`) y ve a `/Library/Caches/<Bundle Identifier>`. La **cach√© de WebKit tambi√©n se almacena en el archivo Cache.db**. **Objection** puede abrir e interactuar con la base de datos con el comando `sqlite connect Cache.db`, ya que es una **base de datos SQLite normal**.

Se **recomienda deshabilitar el almacenamiento en cach√© de estos datos**, ya que puede contener informaci√≥n sensible en la solicitud o respuesta. La siguiente lista muestra diferentes formas de lograr esto:

1. Se recomienda eliminar las respuestas en cach√© despu√©s de cerrar sesi√≥n. Esto se puede hacer con el m√©todo proporcionado por Apple llamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Puedes llamar a este m√©todo de la siguiente manera:

`URLCache.shared.removeAllCachedResponses()`

Este m√©todo eliminar√° todas las solicitudes y respuestas en cach√© del archivo Cache.db.
2. Si no necesitas aprovechar las cookies, se recomienda simplemente usar la propiedad de configuraci√≥n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, que deshabilitar√° el guardado de cookies y cach√©s.

[Documentaci√≥n de Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Un objeto de configuraci√≥n de sesi√≥n ef√≠mera es similar a una configuraci√≥n de sesi√≥n predeterminada (ver predeterminado), excepto que el objeto de sesi√≥n correspondiente no almacena cach√©s, almacenes de credenciales ni ning√∫n dato relacionado con la sesi√≥n en el disco. En su lugar, los datos relacionados con la sesi√≥n se almacenan en RAM. La √∫nica vez que una sesi√≥n ef√≠mera escribe datos en el disco es cuando le indicas que escriba el contenido de una URL en un archivo.`
3. La cach√© tambi√©n se puede deshabilitar configurando la pol√≠tica de cach√© a [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Esto deshabilitar√° el almacenamiento de cach√© de cualquier manera, ya sea en memoria o en disco.

### Snapshots

Cada vez que presionas el bot√≥n de inicio, iOS **toma una instant√°nea de la pantalla actual** para poder hacer la transici√≥n a la aplicaci√≥n de una manera mucho m√°s fluida. Sin embargo, si hay **datos sensibles** presentes en la pantalla actual, se **guardar√°n** en la **imagen** (que **persiste** **a trav√©s de** **reinicios**). Estas son las instant√°neas a las que tambi√©n puedes acceder tocando dos veces la pantalla de inicio para cambiar entre aplicaciones.

A menos que el iPhone est√© jailbroken, el **atacante** necesita tener **acceso** al **dispositivo** **desbloqueado** para ver estas capturas de pantalla. Por defecto, la √∫ltima instant√°nea se almacena en el sandbox de la aplicaci√≥n en la carpeta `Library/Caches/Snapshots/` o `Library/SplashBoard/Snapshots` (los ordenadores de confianza no pueden acceder al sistema de archivos desde iOS 7.0).

Una forma de prevenir este mal comportamiento es poner una pantalla en blanco o eliminar los datos sensibles antes de tomar la instant√°nea utilizando la funci√≥n `ApplicationDidEnterBackground()`.

El siguiente es un m√©todo de remediaci√≥n de ejemplo que establecer√° una captura de pantalla predeterminada.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objetivo-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Esto establece la imagen de fondo a `overlayImage.png` cada vez que la aplicaci√≥n se env√≠a al fondo. Previene filtraciones de datos sensibles porque `overlayImage.png` siempre sobrescribir√° la vista actual.

### Keychain

Para acceder y gestionar el llavero de iOS, hay herramientas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) disponibles, adecuadas para dispositivos con jailbreak. Adem√°s, [**Objection**](https://github.com/sensepost/objection) proporciona el comando `ios keychain dump` para prop√≥sitos similares.

#### **Almacenamiento de Credenciales**

La clase **NSURLCredential** es ideal para guardar informaci√≥n sensible directamente en el llavero, evitando la necesidad de NSUserDefaults u otros envoltorios. Para almacenar credenciales despu√©s del inicio de sesi√≥n, se utiliza el siguiente c√≥digo Swift:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Para extraer estas credenciales almacenadas, se utiliza el comando de Objection `ios nsurlcredentialstorage dump`.

## **Teclados Personalizados y Cach√© de Teclado**

Con iOS 8.0 en adelante, los usuarios pueden instalar extensiones de teclado personalizadas, que son gestionables en **Configuraci√≥n > General > Teclado > Teclados**. Aunque estos teclados ofrecen funcionalidad extendida, representan un riesgo de registro de pulsaciones y transmisi√≥n de datos a servidores externos, aunque se notifica a los usuarios sobre los teclados que requieren acceso a la red. Las aplicaciones pueden, y deben, restringir el uso de teclados personalizados para la entrada de informaci√≥n sensible.

**Recomendaciones de Seguridad:**

* Se aconseja deshabilitar teclados de terceros para mejorar la seguridad.
* Tenga en cuenta las funciones de autocorrecci√≥n y autocompletado del teclado predeterminado de iOS, que podr√≠an almacenar informaci√≥n sensible en archivos de cach√© ubicados en `Library/Keyboard/{locale}-dynamic-text.dat` o `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Estos archivos de cach√© deben ser revisados regularmente en busca de datos sensibles. Se recomienda restablecer el diccionario del teclado a trav√©s de **Configuraci√≥n > General > Restablecer > Restablecer Diccionario del Teclado** para borrar datos en cach√©.
* Interceptar el tr√°fico de red puede revelar si un teclado personalizado est√° transmitiendo pulsaciones de teclas de forma remota.

### **Prevenci√≥n de Cach√© en Campos de Texto**

El [protocolo UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) ofrece propiedades para gestionar la autocorrecci√≥n y la entrada de texto segura, esenciales para prevenir el almacenamiento en cach√© de informaci√≥n sensible. Por ejemplo, deshabilitar la autocorrecci√≥n y habilitar la entrada de texto segura se puede lograr con:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Adem√°s, los desarrolladores deben asegurarse de que los campos de texto, especialmente aquellos para ingresar informaci√≥n sensible como contrase√±as y PINs, desactiven la cach√© configurando `autocorrectionType` en `UITextAutocorrectionTypeNo` y `secureTextEntry` en `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Registros**

Depurar c√≥digo a menudo implica el uso de **registro**. Hay un riesgo involucrado ya que **los registros pueden contener informaci√≥n sensible**. Anteriormente, en iOS 6 y versiones anteriores, los registros eran accesibles para todas las aplicaciones, lo que planteaba un riesgo de filtraci√≥n de datos sensibles. **Ahora, las aplicaciones est√°n restringidas a acceder solo a sus propios registros**.

A pesar de estas restricciones, un **atacante con acceso f√≠sico** a un dispositivo desbloqueado a√∫n puede explotar esto conectando el dispositivo a una computadora y **leyendo los registros**. Es importante notar que los registros permanecen en el disco incluso despu√©s de la desinstalaci√≥n de la aplicaci√≥n.

Para mitigar riesgos, se aconseja **interactuar a fondo con la aplicaci√≥n**, explorando todas sus funcionalidades e inputs para asegurar que no se est√© registrando inadvertidamente informaci√≥n sensible.

Al revisar el c√≥digo fuente de la aplicaci√≥n en busca de posibles filtraciones, busca tanto **declaraciones de registro** **predefinidas** como **personalizadas** utilizando palabras clave como `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` para funciones integradas, y cualquier menci√≥n de `Logging` o `Logfile` para implementaciones personalizadas.

### **Monitoreo de Registros del Sistema**

Las aplicaciones registran varias piezas de informaci√≥n que pueden ser sensibles. Para monitorear estos registros, herramientas y comandos como:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
son √∫tiles. Adem√°s, **Xcode** proporciona una forma de recopilar registros de consola:

1. Abre Xcode.
2. Conecta el dispositivo iOS.
3. Navega a **Ventana** -> **Dispositivos y Simuladores**.
4. Selecciona tu dispositivo.
5. Activa el problema que est√°s investigando.
6. Usa el bot√≥n **Abrir Consola** para ver los registros en una nueva ventana.

Para un registro m√°s avanzado, conectarse al shell del dispositivo y usar **socat** puede proporcionar monitoreo de registros en tiempo real:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Seguido de comandos para observar actividades de registro, lo que puede ser invaluable para diagnosticar problemas o identificar posibles filtraciones de datos en los registros.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Copias de seguridad

Las **funciones de copia de seguridad autom√°tica** est√°n integradas en iOS, facilitando la creaci√≥n de copias de datos del dispositivo a trav√©s de iTunes (hasta macOS Catalina), Finder (desde macOS Catalina en adelante) o iCloud. Estas copias de seguridad abarcan casi todos los datos del dispositivo, excluyendo elementos altamente sensibles como los detalles de Apple Pay y las configuraciones de Touch ID.

### Riesgos de seguridad

La inclusi√≥n de **aplicaciones instaladas y sus datos** en las copias de seguridad plantea el problema de la posible **filtraci√≥n de datos** y el riesgo de que **las modificaciones en la copia de seguridad puedan alterar la funcionalidad de la aplicaci√≥n**. Se aconseja **no almacenar informaci√≥n sensible en texto plano** dentro del directorio de cualquier aplicaci√≥n o sus subdirectorios para mitigar estos riesgos.

### Exclusi√≥n de archivos de las copias de seguridad

Los archivos en `Documents/` y `Library/Application Support/` se respaldan por defecto. Los desarrolladores pueden excluir archivos o directorios espec√≠ficos de las copias de seguridad utilizando `NSURL setResourceValue:forKey:error:` con la clave `NSURLIsExcludedFromBackupKey`. Esta pr√°ctica es crucial para proteger datos sensibles de ser incluidos en las copias de seguridad.

### Pruebas de vulnerabilidades

Para evaluar la seguridad de la copia de seguridad de una aplicaci√≥n, comienza por **crear una copia de seguridad** usando Finder, luego local√≠zala utilizando la gu√≠a de [la documentaci√≥n oficial de Apple](https://support.apple.com/en-us/HT204215). Analiza la copia de seguridad en busca de datos sensibles o configuraciones que podr√≠an ser alteradas para afectar el comportamiento de la aplicaci√≥n.

Se puede buscar informaci√≥n sensible utilizando herramientas de l√≠nea de comandos o aplicaciones como [iMazing](https://imazing.com). Para copias de seguridad encriptadas, se puede confirmar la presencia de encriptaci√≥n verificando la clave "IsEncrypted" en el archivo "Manifest.plist" en la ra√≠z de la copia de seguridad.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Para tratar con copias de seguridad encriptadas, los scripts de Python disponibles en [el repositorio de GitHub de DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), como **backup\_tool.py** y **backup\_passwd.py**, pueden ser √∫tiles, aunque potencialmente requiriendo ajustes para la compatibilidad con las √∫ltimas versiones de iTunes/Finder. La herramienta [**iOSbackup**](https://pypi.org/project/iOSbackup/) es otra opci√≥n para acceder a archivos dentro de copias de seguridad protegidas por contrase√±a.

### Modificando el Comportamiento de la Aplicaci√≥n

Un ejemplo de alterar el comportamiento de la aplicaci√≥n a trav√©s de modificaciones en la copia de seguridad se demuestra en la [aplicaci√≥n de billetera bitcoin Bither](https://github.com/bither/bither-ios), donde el PIN de bloqueo de la interfaz de usuario se almacena dentro de `net.bither.plist` bajo la clave **pin\_code**. Eliminar esta clave del plist y restaurar la copia de seguridad elimina el requisito del PIN, proporcionando acceso sin restricciones.

## Resumen sobre Pruebas de Memoria para Datos Sensibles

Al tratar con informaci√≥n sensible almacenada en la memoria de una aplicaci√≥n, es crucial limitar el tiempo de exposici√≥n de estos datos. Hay dos enfoques principales para investigar el contenido de la memoria: **crear un volcado de memoria** y **analizar la memoria en tiempo real**. Ambos m√©todos tienen sus desaf√≠os, incluyendo la posibilidad de perder datos cr√≠ticos durante el proceso de volcado o an√°lisis.

## **Recuperando y Analizando un Volcado de Memoria**

Para dispositivos con jailbreak y sin jailbreak, herramientas como [objection](https://github.com/sensepost/objection) y [Fridump](https://github.com/Nightbringer21/fridump) permiten el volcado de la memoria del proceso de una aplicaci√≥n. Una vez volcado, analizar estos datos requiere varias herramientas, dependiendo de la naturaleza de la informaci√≥n que est√°s buscando.

Para extraer cadenas de un volcado de memoria, se pueden usar comandos como `strings` o `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Para un an√°lisis m√°s detallado, incluyendo la b√∫squeda de tipos de datos o patrones espec√≠ficos, **radare2** ofrece amplias capacidades de b√∫squeda:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **An√°lisis de Memoria en Tiempo de Ejecuci√≥n**

**r2frida** proporciona una alternativa poderosa para inspeccionar la memoria de una aplicaci√≥n en tiempo real, sin necesidad de un volcado de memoria. Esta herramienta permite la ejecuci√≥n de comandos de b√∫squeda directamente en la memoria de la aplicaci√≥n en ejecuci√≥n:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Criptograf√≠a Rota

### Procesos de Gesti√≥n de Claves Deficientes

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los encriptan con una clave codificada/predictible en el c√≥digo. Esto no deber√≠a hacerse, ya que alg√∫n proceso de reversi√≥n podr√≠a permitir a los atacantes extraer la informaci√≥n confidencial.

### Uso de Algoritmos Inseguros y/o Obsoletos

Los desarrolladores no deber√≠an usar **algoritmos obsoletos** para realizar **verificaciones** de **autorizaci√≥n**, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se utilizan **hashes** para almacenar contrase√±as, por ejemplo, se deber√≠an usar **hashes** resistentes a **fuerza bruta** con sal.

### Verificaci√≥n

Las principales verificaciones a realizar son encontrar si puedes encontrar **contrase√±as**/secretos **codificados** en el c√≥digo, o si son **predecibles**, y si el c√≥digo est√° utilizando alg√∫n tipo de algoritmos de **criptograf√≠a** **d√©bil**.

Es interesante saber que puedes **monitorear** algunas **bibliotecas** **crypto** autom√°ticamente usando **objection** con:
```swift
ios monitor crypt
```
Para **m√°s informaci√≥n** sobre las APIs y bibliotecas criptogr√°ficas de iOS, accede a [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autenticaci√≥n Local

La **autenticaci√≥n local** juega un papel crucial, especialmente cuando se trata de salvaguardar el acceso en un punto final remoto a trav√©s de m√©todos criptogr√°ficos. La esencia aqu√≠ es que sin una implementaci√≥n adecuada, los mecanismos de autenticaci√≥n local pueden ser eludidos.

El [**framework de Autenticaci√≥n Local**](https://developer.apple.com/documentation/localauthentication) de Apple y el [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) proporcionan APIs robustas para que los desarrolladores faciliten di√°logos de autenticaci√≥n de usuarios y manejen datos secretos de manera segura, respectivamente. El Secure Enclave asegura la identificaci√≥n por huella digital para Touch ID, mientras que Face ID se basa en el reconocimiento facial sin comprometer los datos biom√©tricos.

Para integrar Touch ID/Face ID, los desarrolladores tienen dos opciones de API:

* **`LocalAuthentication.framework`** para autenticaci√≥n de usuario de alto nivel sin acceso a datos biom√©tricos.
* **`Security.framework`** para acceso a servicios de keychain de bajo nivel, asegurando datos secretos con autenticaci√≥n biom√©trica. Varios [wrappers de c√≥digo abierto](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) hacen que el acceso al keychain sea m√°s simple.

{% hint style="danger" %}
Sin embargo, tanto `LocalAuthentication.framework` como `Security.framework` presentan vulnerabilidades, ya que principalmente devuelven valores booleanos sin transmitir datos para procesos de autenticaci√≥n, lo que los hace susceptibles a eludir (consulta [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementando Autenticaci√≥n Local

Para solicitar a los usuarios la autenticaci√≥n, los desarrolladores deben utilizar el m√©todo **`evaluatePolicy`** dentro de la clase **`LAContext`**, eligiendo entre:

* **`deviceOwnerAuthentication`**: Solicita Touch ID o el c√≥digo de acceso del dispositivo, fallando si ninguno est√° habilitado.
* **`deviceOwnerAuthenticationWithBiometrics`**: Solicita exclusivamente Touch ID.

Una autenticaci√≥n exitosa se indica mediante un valor de retorno booleano de **`evaluatePolicy`**, destacando una posible falla de seguridad.

### Autenticaci√≥n Local usando Keychain

Implementar **autenticaci√≥n local** en aplicaciones iOS implica el uso de **APIs de keychain** para almacenar de manera segura datos secretos como tokens de autenticaci√≥n. Este proceso asegura que los datos solo puedan ser accedidos por el usuario, utilizando su c√≥digo de acceso del dispositivo o autenticaci√≥n biom√©trica como Touch ID.

El keychain ofrece la capacidad de establecer elementos con el atributo `SecAccessControl`, que restringe el acceso al elemento hasta que el usuario se autentique con √©xito a trav√©s de Touch ID o el c√≥digo de acceso del dispositivo. Esta caracter√≠stica es crucial para mejorar la seguridad.

A continuaci√≥n se presentan ejemplos de c√≥digo en Swift y Objective-C que demuestran c√≥mo guardar y recuperar una cadena del keychain, aprovechando estas caracter√≠sticas de seguridad. Los ejemplos muestran espec√≠ficamente c√≥mo configurar el control de acceso para requerir autenticaci√≥n de Touch ID y asegurar que los datos sean accesibles solo en el dispositivo en el que se configuraron, bajo la condici√≥n de que se haya configurado un c√≥digo de acceso del dispositivo.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Ahora podemos solicitar el elemento guardado del llavero. Los servicios de llavero presentar√°n el di√°logo de autenticaci√≥n al usuario y devolver√°n datos o nil dependiendo de si se proporcion√≥ una huella digital adecuada o no.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detecci√≥n

El uso de frameworks en una aplicaci√≥n tambi√©n se puede detectar analizando la lista de bibliotecas din√°micas compartidas del binario de la aplicaci√≥n. Esto se puede hacer utilizando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Si se utiliza `LocalAuthentication.framework` en una aplicaci√≥n, la salida contendr√° ambas l√≠neas siguientes (recuerde que `LocalAuthentication.framework` utiliza `Security.framework` en segundo plano):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si se utiliza `Security.framework`, solo se mostrar√° el segundo.

### Bypass del Marco de Autenticaci√≥n Local

#### **Objection**

A trav√©s del **Objection Biometrics Bypass**, ubicado en [esta p√°gina de GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), se dispone de una t√©cnica para superar el mecanismo de **LocalAuthentication**. El n√∫cleo de este enfoque implica aprovechar **Frida** para manipular la funci√≥n `evaluatePolicy`, asegurando que siempre produzca un resultado `True`, independientemente del √©xito real de la autenticaci√≥n. Esto es particularmente √∫til para eludir procesos de autenticaci√≥n biom√©trica defectuosos.

Para activar este bypass, se emplea el siguiente comando:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Este comando inicia una secuencia donde Objection registra una tarea que altera efectivamente el resultado de la verificaci√≥n `evaluatePolicy` a `True`.

#### Frida

Un ejemplo de un uso de **`evaluatePolicy`** de la aplicaci√≥n [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para lograr el **bypass** de la Autenticaci√≥n Local, se escribe un script de Frida. Este script apunta a la verificaci√≥n de **evaluatePolicy**, interceptando su callback para asegurar que devuelva **success=1**. Al alterar el comportamiento del callback, la verificaci√≥n de autenticaci√≥n se elude efectivamente.

El script a continuaci√≥n se inyecta para modificar el resultado del m√©todo **evaluatePolicy**. Cambia el resultado del callback para indicar siempre √©xito.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Para inyectar el script de Frida y eludir la autenticaci√≥n biom√©trica, se utiliza el siguiente comando:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposici√≥n de Funcionalidades Sensibles a Trav√©s de IPC

### Controladores de URI Personalizados / Deeplinks / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Enlaces Universales

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartici√≥n UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensiones de Aplicaciones

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializaci√≥n y Codificaci√≥n

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunicaci√≥n de Red

Es importante verificar que no se est√© realizando ninguna comunicaci√≥n **sin cifrado** y tambi√©n que la aplicaci√≥n est√© **validando correctamente el certificado TLS** del servidor.\
Para verificar este tipo de problemas, puedes usar un proxy como **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verificaci√≥n de Nombre de Host

Un problema com√∫n al validar el certificado TLS es verificar que el certificado fue firmado por una **CA** **confiable**, pero **no verificar** si **el nombre de host** del certificado es el nombre de host que se est√° accediendo.\
Para verificar este problema usando Burp, despu√©s de confiar en la CA de Burp en el iPhone, puedes **crear un nuevo certificado con Burp para un nombre de host diferente** y usarlo. Si la aplicaci√≥n sigue funcionando, entonces, algo es vulnerable.

### Fijaci√≥n de Certificados

Si una aplicaci√≥n est√° utilizando correctamente la Fijaci√≥n de SSL, entonces la aplicaci√≥n solo funcionar√° si el certificado es el que se espera. Al probar una aplicaci√≥n, **esto podr√≠a ser un problema ya que Burp servir√° su propio certificado.**\
Para eludir esta protecci√≥n en un dispositivo con jailbreak, puedes instalar la aplicaci√≥n [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) o instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Tambi√©n puedes usar **objection's** `ios sslpinning disable`

## Miscel√°nea

* En **`/System/Library`** puedes encontrar los frameworks instalados en el tel√©fono utilizados por aplicaciones del sistema.
* Las aplicaciones instaladas por el usuario desde la App Store se encuentran dentro de **`/User/Applications`**.
* Y el **`/User/Library`** contiene datos guardados por las aplicaciones a nivel de usuario.
* Puedes acceder a **`/User/Library/Notes/notes.sqlite`** para leer las notas guardadas dentro de la aplicaci√≥n.
* Dentro de la carpeta de una aplicaci√≥n instalada (**`/User/Applications/<APP ID>/`**) puedes encontrar algunos archivos interesantes:
* **`iTunesArtwork`**: El √≠cono utilizado por la aplicaci√≥n.
* **`iTunesMetadata.plist`**: Informaci√≥n de la aplicaci√≥n utilizada en la App Store.
* **`/Library/*`**: Contiene las preferencias y cach√©. En **`/Library/Cache/Snapshots/*`** puedes encontrar la instant√°nea realizada a la aplicaci√≥n antes de enviarla al fondo.

### Hot Patching/Actualizaci√≥n Forzada

Los desarrolladores pueden **parchear todas las instalaciones de su aplicaci√≥n instant√°neamente** sin tener que volver a enviar la aplicaci√≥n a la App Store y esperar a que sea aprobada.\
Para este prop√≥sito, generalmente se utiliza [**JSPatch**](https://github.com/bang590/JSPatch)**.** Pero tambi√©n hay otras opciones como [Siren](https://github.com/ArtSabintsev/Siren) y [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este es un mecanismo peligroso que podr√≠a ser abusado por SDKs de terceros maliciosos, por lo tanto, se recomienda verificar qu√© m√©todo se utiliza para la actualizaci√≥n autom√°tica (si lo hay) y probarlo.** Podr√≠as intentar descargar una versi√≥n anterior de la aplicaci√≥n para este prop√≥sito.

### Terceros

Un desaf√≠o significativo con los **SDKs de terceros** es la **falta de control granular** sobre sus funcionalidades. Los desarrolladores se enfrentan a una elecci√≥n: integrar el SDK y aceptar todas sus caracter√≠sticas, incluidas las posibles vulnerabilidades de seguridad y preocupaciones de privacidad, o renunciar a sus beneficios por completo. A menudo, los desarrolladores no pueden parchear vulnerabilidades dentro de estos SDKs por s√≠ mismos. Adem√°s, a medida que los SDKs ganan confianza dentro de la comunidad, algunos pueden comenzar a contener malware.

Los servicios proporcionados por los SDKs de terceros pueden incluir seguimiento del comportamiento del usuario, exhibici√≥n de anuncios o mejoras en la experiencia del usuario. Sin embargo, esto introduce un riesgo, ya que los desarrolladores pueden no ser completamente conscientes del c√≥digo ejecutado por estas bibliotecas, lo que lleva a posibles riesgos de privacidad y seguridad. Es crucial limitar la informaci√≥n compartida con servicios de terceros a lo que es necesario y asegurarse de que no se exponga informaci√≥n sensible.

La implementaci√≥n de servicios de terceros generalmente viene en dos formas: una biblioteca independiente o un SDK completo. Para proteger la privacidad del usuario, cualquier dato compartido con estos servicios debe ser **anonimizado** para evitar la divulgaci√≥n de Informaci√≥n Personal Identificable (PII).

Para identificar las bibliotecas que utiliza una aplicaci√≥n, se puede emplear el comando **`otool`**. Esta herramienta debe ejecutarse contra la aplicaci√≥n y cada biblioteca compartida que utiliza para descubrir bibliotecas adicionales.
```bash
otool -L <application_path>
```
## **Referencias y M√°s Recursos**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de IOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Versi√≥n de Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Versi√≥n de Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) para construir y **automatizar flujos de trabajo** f√°cilmente impulsados por las **herramientas comunitarias m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}
{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**repositorios de HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
</details>
{% endhint %}
