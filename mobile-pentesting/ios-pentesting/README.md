# iOS Pentesting

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Utilisez [**Trickest**](https://trickest.io/) pour cr√©er et automatiser facilement des workflows aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## iOS Pentesting

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre entreprise annonc√©e dans HackTricks ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Bases d'iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Environnement de test

Sur cette page, vous pouvez trouver des informations sur le **simulateur iOS**, les **√©mulateurs** et le **jailbreaking** :

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Analyse initiale

### Op√©rations de test iOS de base

Au cours du test, **plusieurs op√©rations seront sugg√©r√©es** (connexion √† l'appareil, lecture/√©criture/t√©l√©chargement/t√©l√©versement de fichiers, utilisation de certains outils...). Par cons√©quent, si vous ne savez pas comment effectuer l'une de ces actions, **commencez par lire la page** :

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Pour les √©tapes suivantes, **l'application doit √™tre install√©e** sur l'appareil et vous devez d√©j√† avoir obtenu le **fichier IPA** de l'application.\
Lisez la page [Op√©rations de test iOS de base](basic-ios-testing-operations.md) pour apprendre comment faire cela.
{% endhint %}

### Analyse statique de base

Il est recommand√© d'utiliser l'outil [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) pour effectuer une analyse statique automatique du fichier IPA.

Identification des **protections pr√©sentes dans le binaire** :

*   **PIE (Position Independent Executable)** : Lorsqu'elle est activ√©e, l'application se charge dans une adresse m√©moire al√©atoire √† chaque lancement, ce qui rend plus difficile la pr√©diction de son adresse m√©moire initiale.

    ```
    otool -hv <app-binary> | grep PIE   # Il devrait inclure le drapeau PIE
    ```
*   **Canaries de pile** : Pour valider l'int√©grit√© de la pile, une valeur de ¬´ canary ¬ª est plac√©e sur la pile avant d'appeler une fonction et est valid√©e √† nouveau une fois que la fonction se termine.

    ```
    otool -I -v <app-binary> | grep stack_chk   # Il devrait inclure les symboles : stack_chk_guard et stack_chk_fail
    ```
*   **ARC (Automatic Reference Counting)** : Pour √©viter les erreurs courantes de corruption de m√©moire

    ```
    otool -I -v <app-binary> | grep objc_release   # Il devrait inclure le symbole _objc_release 
    ```
*   **Binaire chiffr√©** : Le binaire doit √™tre chiffr√©

    ```
    otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Le cryptid doit √™tre 1
    ```

**Identification des fonctions sensibles / non s√©curis√©es**

*   **Algorithmes de hachage faibles**

    ```
    # Sur l'appareil iOS
    otool -Iv <app> | grep -w "_CC_MD5"
    otool -Iv <app> | grep -w "_CC_SHA1"

    # Sur linux
    grep -iER "_CC_MD5"
    grep -iER "_CC_SHA1"
    ```
*   **Fonctions al√©atoires non s√©curis√©es**

    ```
    # Sur l'appareil iOS
    otool -Iv <app> | grep -w "_random"
    otool -Iv <app> | grep -w "_srand"
    otool -Iv <app> | grep -w "_rand"

    # Sur linux
    grep -iER "_random"
    grep -iER "_srand"
    grep -iER "_rand"
    ```
*   **Fonction ¬´ Malloc ¬ª non s√©curis√©e**

    ```
    # Sur l'appareil iOS
    otool -Iv <app> | grep -w "_malloc"

    # Sur linux
    grep -iER "_malloc"
    ```
*   **Fonctions non s√©curis√©es et vuln√©rables**

    ```
    # Sur l'appareil iOS
    otool -Iv <app> | grep -w "_gets"
    otool -Iv <app> | grep -w "_memcpy"
    otool -Iv <app> | grep -w "_strncpy"
    otool -Iv <app> | grep -w "_strlen"
    otool -Iv <app> | grep -w "_vsnprintf"
    otool -Iv <app> | grep -w "_sscanf"
    otool -Iv <app> | grep -w "_strtok"
    otool -Iv <app> | grep -w "_alloca"
    otool -Iv <app> | grep -w "_sprintf"
    otool -Iv <app> | grep -w "_printf"
    otool -Iv <app> | grep -w "_vsprintf"

    # Sur linux
    grep -R "_gets"
    grep -iER "_memcpy"
    grep -iER "_strncpy"
    grep -iER "_strlen"
    grep -iER "_vsnprintf"
    grep -iER "_sscanf"
    grep -iER "_strtok"
    grep -iER "_alloca"
    grep -iER "_sprintf"
    grep -iER "_printf"
    grep -iER "_vsprintf"
    ```

### Analyse dynamique de base

Consultez l'analyse dynamique que [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) effectue. Vous devrez naviguer √† travers les diff√©rentes vues et interagir avec elles, mais il accrochera plusieurs classes en faisant d'autres choses et pr√©parera un rapport une fois que vous aurez termin√©.

### Liste des applications install√©es

Lorsque vous ciblez des applications install√©es sur l'appareil, vous devez d'abord d√©terminer le bon identifiant de bundle de l'application que vous souhaitez analyser. Vous pouvez utiliser `frida-ps -Uai` pour obtenir toutes les applications (`-a`) actuellement install√©es (`-i`) sur l'appareil USB connect√© (`-U`) :
```bash
$ frida-ps -Uai
 PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
   -  App Store            com.apple.AppStore
   -  Apple Store          com.apple.store.Jolly
   -  Calculator           com.apple.calculator
   -  Camera               com.apple.camera
   -  iGoat-Swift          OWASP.iGoat-Swift
```
### √ânum√©ration de base et Hooking

Apprenez √† **√©num√©rer les composants de l'application** et comment facilement **hooker les m√©thodes et les classes** avec objection :

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Structure IPA

Les fichiers `.ipa` sont des **paquets zipp√©s**, vous pouvez donc changer l'extension en `.zip` et les **d√©compresser**. Une application **compl√®te** pr√™te √† √™tre install√©e est commun√©ment appel√©e un **Bundle**.\
Apr√®s les avoir d√©compress√©s, vous devriez voir `<NOM>.app`, une archive zipp√©e qui contient le reste des ressources.

* `Info.plist` : Un fichier qui contient certaines des configurations sp√©cifiques de l'application.
* `_CodeSignature/` contient un fichier plist avec une signature sur tous les fichiers du bundle.
* `Assets.car` : Une autre archive zipp√©e qui contient des ressources (ic√¥nes).
* `Frameworks/` contient les biblioth√®ques natives de l'application sous forme de fichiers .dylib ou .framework.
* `PlugIns/` peut contenir des extensions d'application sous forme de fichiers .appex (non pr√©sent dans l'exemple).
* [`Core Data`](https://developer.apple.com/documentation/coredata) : Il est utilis√© pour enregistrer les donn√©es permanentes de votre application pour une utilisation hors ligne, pour mettre en cache les donn√©es temporaires et pour ajouter des fonctionnalit√©s d'annulation √† votre application sur un seul appareil. Pour synchroniser les donn√©es sur plusieurs appareils dans un seul compte iCloud, Core Data refl√®te automatiquement votre sch√©ma dans un conteneur CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html) : Le fichier `PkgInfo` est une fa√ßon alternative de sp√©cifier les codes de type et de cr√©ateur de votre application ou bundle.
* **en.lproj, fr.proj, Base.lproj** : Sont les packs de langues qui contiennent des ressources pour ces langues sp√©cifiques, et une ressource par d√©faut au cas o√π une langue n'est pas prise en charge.

Il existe plusieurs fa√ßons de d√©finir l'interface utilisateur dans une application iOS : les fichiers _storyboard_, _nib_ ou _xib_.

**Info.plist**

La liste de propri√©t√©s d'informations ou `Info.plist` est la principale source d'informations pour une application iOS. Il s'agit d'un fichier structur√© contenant des paires de **cl√©-valeur** d√©crivant des informations de configuration essentielles sur l'application. En fait, tous les ex√©cutables regroup√©s (extensions d'application, frameworks et applications) sont **cens√©s avoir** un fichier `Info.plist`. Vous pouvez trouver toutes les cl√©s possibles dans la [**documentation du d√©veloppeur Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Le fichier peut √™tre format√© en **XML ou binaire (bplist)**. Vous pouvez le **convertir en format XML** avec une seule commande :

*   Sur macOS avec `plutil`, qui est un outil qui vient nativement avec macOS 10.2 et les versions sup√©rieures (aucune documentation en ligne officielle n'est actuellement disponible) :

    ```bash
    $ plutil -convert xml1 Info.plist
    ```
*   Sur Linux :

    ```bash
    $ apt install libplist-utils
    $ plistutil -i Info.plist -o Info_xml.plist
    ```

Voici une liste non exhaustive de certaines informations et des mots-cl√©s correspondants que vous pouvez facilement rechercher dans le fichier `Info.plist` en inspectant simplement le fichier ou en utilisant `grep -i <mot-cl√©> Info.plist` :

* Cha√Ænes de but des autorisations de l'application : `UsageDescription`
* Sch√©mas d'URL personnalis√©s : `CFBundleURLTypes`
* Types de documents personnalis√©s export√©s/import√©s : `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configuration de la s√©curit√© du transport de l'application (ATS) : `NSAppTransportSecurity`

Veuillez vous r√©f√©rer aux chapitres mentionn√©s pour en savoir plus sur la fa√ßon de tester chacun de ces points.

**Chemins de donn√©es**

Sur iOS, les **applications syst√®me peuvent √™tre trouv√©es dans le r√©pertoire `/Applications`** tandis que les applications **install√©es par l'utilisateur** sont disponibles sous **`/private/var/containers/`**. Cependant, trouver le bon dossier en naviguant simplement dans le syst√®me de fichiers n'est pas une t√¢che facile car **chaque application re√ßoit un UUID (Universal Unique Identifier) de 128 bits al√©atoire** attribu√© pour ses noms de r√©pertoire.

Afin d'obtenir facilement les informations de r√©pertoire d'installation pour les applications install√©es par l'utilisateur, vous pouvez utiliser la commande **`env`** d'objection qui vous montrera √©galement toutes les informations de r√©pertoire de l'application :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Comme vous pouvez le voir, les applications ont deux emplacements principaux :

* Le **r√©pertoire Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* Le **r√©pertoire Data** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Ces dossiers contiennent des informations qui doivent √™tre examin√©es de pr√®s lors des √©valuations de s√©curit√© des applications (par exemple lors de l'analyse des donn√©es stock√©es pour des donn√©es sensibles).

**R√©pertoire Bundle :**

* **AppName.app**
  * Il s'agit du Bundle de l'application tel que vu pr√©c√©demment dans l'IPA, il contient les donn√©es essentielles de l'application, le contenu statique ainsi que le binaire compil√© de l'application.
  * Ce r√©pertoire est visible pour les utilisateurs, mais **les utilisateurs ne peuvent pas y √©crire**.
  * Le contenu de ce r√©pertoire n'est **pas sauvegard√©**.
  * Le contenu de ce dossier est utilis√© pour **valider la signature du code**.

**R√©pertoire Data :**

* **Documents/**
  * Contient toutes les donn√©es g√©n√©r√©es par l'utilisateur. L'utilisateur final de l'application initie la cr√©ation de ces donn√©es.
  * Visible pour les utilisateurs et **les utilisateurs peuvent y √©crire**.
  * Le contenu de ce r√©pertoire est **sauvegard√©**.
  * L'application peut d√©sactiver les chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/**
  * Contient tous les **fichiers qui ne sont pas sp√©cifiques √† l'utilisateur**, tels que les **caches**, les **pr√©f√©rences**, les **cookies** et les fichiers de configuration plist (property list).
  * Les applications iOS utilisent g√©n√©ralement les sous-r√©pertoires `Application Support` et `Caches`, mais l'application peut cr√©er des sous-r√©pertoires personnalis√©s.
* **Library/Caches/**
  * Contient des fichiers **mis en cache semi-persistants**.
  * Invisible pour les utilisateurs et **les utilisateurs ne peuvent pas y √©crire**.
  * Le contenu de ce r√©pertoire n'est **pas sauvegard√©**.
  * Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application ne fonctionne pas et que l'espace de stockage est limit√©.
* **Library/Application Support/**
  * Contient des **fichiers persistants** n√©cessaires au fonctionnement de l'application.
  * **Invisible** **pour** **les utilisateurs** et les utilisateurs ne peuvent pas y √©crire.
  * Le contenu de ce r√©pertoire est **sauvegard√©**.
  * L'application peut d√©sactiver les chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
  * Utilis√© pour stocker des propri√©t√©s qui peuvent **persister m√™me apr√®s le red√©marrage d'une application**.
  * Les informations sont enregistr√©es, non chiffr√©es, √† l'int√©rieur du bac √† sable de l'application dans un fichier plist appel√© \[BUNDLE\_ID].plist.
  * Toutes les paires cl√©/valeur stock√©es √† l'aide de `NSUserDefaults` peuvent √™tre trouv√©es dans ce fichier.
* **tmp/**
  * Utilisez ce r√©pertoire pour √©crire des fichiers **temporaires** qui n'ont pas besoin de persister entre les lancements de l'application.
  * Contient des fichiers mis en cache non persistants.
  * **Invisible** pour les utilisateurs.
  * Le contenu de ce r√©pertoire n'est pas sauvegard√©.
  * Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application ne fonctionne pas et que l'espace de stockage est limit√©.

Examinons de plus pr√®s le r√©pertoire Bundle (.app) de l'application iGoat-Swift dans le r√©pertoire Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Inversion binaire

√Ä l'int√©rieur du dossier `<nom-de-l'application>.app`, vous trouverez un fichier binaire appel√© `<nom-de-l'application>`. C'est le fichier qui sera **ex√©cut√©**. Vous pouvez effectuer une inspection de base du binaire avec l'outil **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
      magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
    /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
    /usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
    /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
    @rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**V√©rifier si l'application est chiffr√©e**

V√©rifiez s'il y a une sortie pour :
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**D√©sassemblage du binaire**

D√©sassemblez la section de texte :
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Pour afficher le segment **Objective-C** de l'application d'exemple, on peut utiliser :
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
    isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
    superclass 0x0 _OBJC_CLASS_$_NSObject
    cache      0x0 __objc_empty_cache
    vtable     0x0
    data       0x1003de748
        flags          0x80
        instanceStart  8
```
Pour obtenir un code Objective-C plus compact, vous pouvez utiliser [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
    double _field1;
    double _field2;
};

struct CGRect {
    struct CGPoint _field1;
    struct CGSize _field2;
};

struct CGSize {
    double _field1;
    double _field2;
};
```
Cependant, les meilleures options pour d√©sassembler le binaire sont : [**Hopper**](https://www.hopperapp.com/download.html?) et [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

Utilisez [**Trickest**](https://trickest.io/) pour construire facilement et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Stockage de donn√©es

Pour en savoir plus sur la fa√ßon dont iOS stocke les donn√©es sur l'appareil, consultez cette page :

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Les emplacements suivants pour stocker des informations doivent √™tre v√©rifi√©s **juste apr√®s l'installation de l'application**, **apr√®s avoir v√©rifi√© toutes les fonctionnalit√©s** de l'application et m√™me apr√®s **s'√™tre d√©connect√© d'un utilisateur et s'√™tre connect√© √† un autre**.\
Le but est de trouver des informations **sensibles non prot√©g√©es** de l'application (mots de passe, jetons), de l'utilisateur actuel et des utilisateurs pr√©c√©demment connect√©s.
{% endhint %}

### Plist

Les fichiers **plist** sont des fichiers XML structur√©s qui **contiennent des paires cl√©-valeur**. C'est une fa√ßon de stocker des donn√©es persistantes, donc parfois vous pouvez trouver des **informations sensibles dans ces fichiers**. Il est recommand√© de v√©rifier ces fichiers apr√®s l'installation de l'application et apr√®s l'avoir utilis√©e intensivement pour voir si de nouvelles donn√©es sont √©crites.

La fa√ßon la plus courante de persister les donn√©es dans les fichiers plist est par l'utilisation de **NSUserDefaults**. Ce fichier plist est enregistr√© √† l'int√©rieur du bac √† sable de l'application dans **`Library/Preferences/<appBundleID>.plist`**

La classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fournit une interface programmatique pour interagir avec le syst√®me par d√©faut. Le syst√®me par d√©faut permet √† une application de personnaliser son comportement en fonction des **pr√©f√©rences de l'utilisateur**. Les donn√©es enregistr√©es par `NSUserDefaults` peuvent √™tre consult√©es dans le bundle de l'application. Cette classe stocke des **donn√©es** dans un **fichier plist**, mais elle est destin√©e √† √™tre utilis√©e avec de petites quantit√©s de donn√©es.

Ces donn√©es ne peuvent plus √™tre directement accessibles via un ordinateur de confiance, mais peuvent √™tre accessibles en effectuant une **sauvegarde**.

Vous pouvez **extraire** les informations enregistr√©es en utilisant **`NSUserDefaults`** en utilisant la commande `ios nsuserdefaults get` d'objection.

Pour trouver tous les fichiers plist utilis√©s par l'application, vous pouvez acc√©der √† `/private/var/mobile/Containers/Data/Application/{APPID}` et ex√©cuter :
```bash
find ./ -name "*.plist"
```
Le fichier peut √™tre format√© en **XML ou en binaire (bplist)**. Vous pouvez le **convertir en format XML** avec une commande simple :

*   Sur macOS avec `plutil`, qui est un outil qui vient nativement avec macOS 10.2 et les versions sup√©rieures (aucune documentation en ligne officielle n'est actuellement disponible) :

    ```bash
    $ plutil -convert xml1 Info.plist
    ```
*   Sur Linux :

    ```bash
    $ apt install libplist-utils
    $ plistutil -i Info.plist -o Info_xml.plist
    ```
*   Sur une session d'objection :

    ```bash
    ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
    ```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) est un framework pour g√©rer la couche mod√®le des objets dans votre application. [Core Data peut utiliser SQLite comme stockage persistant](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mais le framework lui-m√™me n'est pas une base de donn√©es.\
CoreData n'encrypte pas ses donn√©es par d√©faut. Cependant, une couche de chiffrement suppl√©mentaire peut √™tre ajout√©e √† CoreData. Voir le [GitHub Repo](https://github.com/project-imas/encrypted-core-data) pour plus de d√©tails.

Vous pouvez trouver les informations SQLite Core Data d'une application dans le chemin `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si vous pouvez ouvrir le SQLite et acc√©der √† des informations sensibles, alors vous avez trouv√© une mauvaise configuration.**

{% code title="Code from iGoat" %}
```objectivec
-(void)storeDetails {
    AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

    NSManagedObjectContext *context =[appDelegate managedObjectContext];

    User *user = [self fetchUser];
    if (user) {
        return;
    }
    user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
                                                  inManagedObjectContext:context];
    user.email = CoreDataEmail;
    user.password = CoreDataPassword;
    NSError *error;
    if (![context save:&error]) {
        NSLog(@"Error in saving data: %@", [error localizedDescription]);

    }else{
        NSLog(@"data stored in core data");
    }
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) est un magasin de cl√©s/valeurs construit sur SQLite.\
Comme les bases de donn√©es Yap sont des bases de donn√©es SQLite, vous pouvez les trouver en utilisant la commande propos√©e dans la section pr√©c√©dente.

### Autres bases de donn√©es SQLite

Il est courant que les applications cr√©ent leur propre base de donn√©es SQLite. Elles peuvent y stocker des donn√©es sensibles et les laisser non chiffr√©es. Il est donc toujours int√©ressant de v√©rifier chaque base de donn√©es dans le r√©pertoire des applications. Allez donc dans le r√©pertoire de l'application o√π les donn√©es sont enregistr√©es (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de donn√©es en temps r√©el Firebase

Les d√©veloppeurs d'applications peuvent l'utiliser pour **stocker et synchroniser des donn√©es avec une base de donn√©es h√©berg√©e dans le cloud NoSQL**. Les donn√©es sont stock√©es sous forme de JSON et sont synchronis√©es en temps r√©el avec chaque client connect√© et restent √©galement disponibles m√™me lorsque l'application est hors ligne.

Vous pouvez trouver comment v√©rifier les bases de donn√©es Firebase mal configur√©es ici:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de donn√©es Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) et [Realm Swift](https://realm.io/docs/swift/latest/) ne sont pas fournis par Apple, mais ils m√©ritent d'√™tre mentionn√©s. Ils **stockent tout en clair, sauf si la configuration a activ√© le chiffrement**.

Vous pouvez trouver ces bases de donn√©es dans `/private/var/mobile/Containers/Data/Application/{APPID}`
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Vous pouvez utiliser l'outil [**Realm Studio**](https://github.com/realm/realm-studio) pour ouvrir ces fichiers de base de donn√©es.

L'exemple suivant d√©montre comment utiliser le chiffrement avec une base de donn√©es Realm:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
  let realm = try Realm(configuration: config)
  // Use the Realm as normal
} catch let error as NSError {
  // If the encryption key is wrong, `error` will say that it's an invalid database
  fatalError("Error opening realm: \(error)")
}
```
### Bases de donn√©es Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) est un moteur de base de donn√©es l√©ger, int√©gr√© et orient√© document (NoSQL) qui peut √™tre synchronis√©. Il est compil√© nativement pour iOS et macOS.

V√©rifiez la pr√©sence √©ventuelle de bases de donn√©es couchbase dans `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

iOS stocke les cookies des applications dans le fichier **`Library/Cookies/cookies.binarycookies`** √† l'int√©rieur du dossier de chaque application. Cependant, les d√©veloppeurs d√©cident parfois de les enregistrer dans le **keychain** car le fichier de cookies mentionn√© peut √™tre accessible dans les sauvegardes.

Pour inspecter le fichier de cookies, vous pouvez utiliser [**ce script python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou utiliser la commande **`ios cookies get`** d'objection.\
**Vous pouvez √©galement utiliser objection pour** convertir ces fichiers en format JSON et inspecter les donn√©es.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
    {
        "domain": "highaltitudehacks.com",
        "expiresDate": "2051-09-15 07:46:43 +0000",
        "isHTTPOnly": "false",
        "isSecure": "false",
        "name": "username",
        "path": "/",
        "value": "admin123",
        "version": "0"
    }
]
```
### Cache

Par d√©faut, NSURLSession stocke les donn√©es, telles que les requ√™tes et les r√©ponses HTTP, dans la base de donn√©es Cache.db. Cette base de donn√©es peut contenir des donn√©es sensibles, telles que des jetons, des noms d'utilisateur ou toute autre information sensible qui a √©t√© mise en cache. Pour trouver les informations mises en cache, ouvrez le r√©pertoire de donn√©es de l'application (`/var/mobile/Containers/Data/Application/<UUID>`) et acc√©dez √† `/Library/Caches/<Bundle Identifier>`. Le cache WebKit est √©galement stock√© dans le fichier Cache.db. Objection peut ouvrir et interagir avec la base de donn√©es avec la commande `sqlite connect Cache.db`, car il s'agit d'une base de donn√©es SQLite normale.

Il est recommand√© de d√©sactiver la mise en cache de ces donn√©es, car elles peuvent contenir des informations sensibles dans la requ√™te ou la r√©ponse. La liste ci-dessous montre diff√©rentes fa√ßons d'y parvenir :

1. Il est recommand√© de supprimer les r√©ponses mises en cache apr√®s la d√©connexion. Cela peut √™tre fait avec la m√©thode fournie par Apple appel√©e [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Vous pouvez appeler cette m√©thode comme suit :

    `URLCache.shared.removeAllCachedResponses()`

    Cette m√©thode supprimera toutes les requ√™tes et r√©ponses mises en cache du fichier Cache.db.
2. Si vous n'avez pas besoin d'utiliser l'avantage des cookies, il serait recommand√© d'utiliser simplement la propri√©t√© de configuration [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, qui d√©sactivera l'enregistrement des cookies et des caches.

    [Documentation Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) :

    `Un objet de configuration de session √©ph√©m√®re est similaire √† une configuration de session par d√©faut (voir default), √† l'exception que l'objet de session correspondant ne stocke pas de caches, de magasins de cr√©dits ou de donn√©es li√©es √† la session sur le disque. Au lieu de cela, les donn√©es li√©es √† la session sont stock√©es dans la RAM. La seule fois o√π une session √©ph√©m√®re √©crit des donn√©es sur le disque est lorsque vous lui demandez d'√©crire le contenu d'une URL dans un fichier.`
3. Le cache peut √©galement √™tre d√©sactiv√© en d√©finissant la politique de cache sur [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Cela d√©sactivera le stockage du cache de quelque mani√®re que ce soit, que ce soit en m√©moire ou sur disque.

### Snapshots

Chaque fois que vous appuyez sur le bouton d'accueil, iOS prend une capture d'√©cran de l'√©cran actuel pour pouvoir effectuer la transition vers l'application de mani√®re beaucoup plus fluide. Cependant, si des donn√©es sensibles sont pr√©sentes √† l'√©cran, elles seront enregistr√©es dans l'image (qui persiste m√™me apr√®s le red√©marrage). Ce sont les instantan√©s auxquels vous pouvez √©galement acc√©der en double-cliquant sur l'√©cran d'accueil pour passer d'une application √† l'autre.

√Ä moins que l'iPhone ne soit jailbreak√©, l'attaquant doit avoir acc√®s au p√©riph√©rique d√©bloqu√© pour voir ces captures d'√©cran. Par d√©faut, la derni√®re capture d'√©cran est stock√©e dans le sandbox de l'application dans le dossier `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (les ordinateurs de confiance ne peuvent pas acc√©der au syst√®me de fichiers √† partir de iOX 7.0).

Une fa√ßon de pr√©venir ce comportement ind√©sirable est de mettre un √©cran blanc ou de supprimer les donn√©es sensibles avant de prendre la capture d'√©cran en utilisant la fonction `ApplicationDidEnterBackground()`.

Voici un exemple de m√©thode de rem√©diation qui d√©finira une capture d'√©cran par d√©faut.

Swift :
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
    let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
    myBanner.frame = UIScreen.main.bounds
    backgroundImage = myBanner
    window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
    backgroundImage?.removeFromSuperview()
}
```
Objective-C :

Objective-C est un langage de programmation orient√© objet utilis√© pour d√©velopper des applications iOS et macOS. Il est bas√© sur le langage C et ajoute des fonctionnalit√©s de programmation orient√©e objet telles que l'h√©ritage, le polymorphisme et l'encapsulation. Objective-C est utilis√© pour d√©velopper des applications iOS depuis les premi√®res versions de l'iPhone et est toujours utilis√© aujourd'hui, bien que Swift soit devenu le langage de choix pour de nombreux d√©veloppeurs.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
    UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
    self.backgroundImage = myBanner;
    self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
    [self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
    [self.backgroundImage removeFromSuperview];
}
```
Cela d√©finit l'image de fond sur `overlayImage.png` chaque fois que l'application est mise en arri√®re-plan. Cela emp√™che les fuites de donn√©es sensibles car `overlayImage.png` remplacera toujours la vue actuelle.

### Keychain

Des outils tels que [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) peuvent √™tre utilis√©s pour extraire le trousseau (l'appareil doit √™tre jailbreak√©).\
Vous pouvez √©galement utiliser `ios keychain dump` de [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** est la classe parfaite pour **stocker le nom d'utilisateur et le mot de passe dans le trousseau**. Pas besoin de s'emb√™ter avec NSUserDefaults ni avec un wrapper de trousseau.\
Une fois que l'utilisateur est connect√©, vous pouvez **stocker** son nom d'utilisateur et son mot de passe dans le trousseau :
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Vous pouvez utiliser la commande `ios nsurlcredentialstorage dump` d'**Objection** pour extraire ces secrets.

## Claviers personnalis√©s/Cache de clavier

Depuis iOS 8.0, Apple permet l'installation d'extensions personnalis√©es pour iOS, comme des claviers personnalis√©s.\
Les claviers install√©s peuvent √™tre g√©r√©s via **R√©glages** > **G√©n√©ral** > **Clavier** > **Claviers**.\
Les claviers personnalis√©s peuvent √™tre utilis√©s pour **espionner** les **frappes** et les envoyer au serveur de l'attaquant. Cependant, notez que **les claviers personnalis√©s n√©cessitant une connectivit√© r√©seau seront signal√©s √† l'utilisateur.**\
De plus, **l'utilisateur peut passer √† un clavier diff√©rent** (plus fiable) **pour entrer les identifiants.**

De plus, **les applications peuvent emp√™cher leurs utilisateurs d'utiliser des claviers personnalis√©s** dans l'application (ou du moins pour les parties sensibles de l'application).

{% hint style="warning" %}
Il est recommand√© de ne pas autoriser les claviers tiers si vous estimez que les utilisateurs n'en ont pas besoin.
{% endhint %}

Notez que, en raison de la correction automatique et des suggestions automatiques, le clavier iOS par d√©faut capturera et stockera chaque mot non standard dans un fichier cache si l'attribut **securetTextEntry** n'est pas d√©fini sur **true** ou si **autoCorrectionType** n'est pas d√©fini sur **UITextAutoCorrectionTypeNo.**

Par d√©faut, les claviers **stockent ce cache** √† l'int√©rieur du sandbox de l'application dans le fichier `Library/Keyboard/{locale}-dynamic-text.dat` ou dans `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Cependant, il se peut qu'il enregistre les donn√©es ailleurs.\
Il est possible de r√©initialiser le cache dans _**R√©glages**_ > _**G√©n√©ral**_ > _**R√©initialiser**_ > _**R√©initialiser le dictionnaire du clavier**_

{% hint style="info" %}
Par cons√©quent, **v√©rifiez toujours ces fichiers** et recherchez des **informations sensibles** possibles.\
**Intercepter le trafic r√©seau** est un autre moyen de v√©rifier si le clavier personnalis√© envoie des frappes √† un serveur distant.
{% endhint %}

Le protocole [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) est utilis√© pour le cache de clavier. Les classes UITextField, UITextView et UISearchBar prennent automatiquement en charge ce protocole et offrent les propri√©t√©s suivantes :

* `var autocorrectionType: UITextAutocorrectionType` d√©termine si la correction automatique est activ√©e pendant la saisie. Lorsque la correction automatique est activ√©e, l'objet texte suit les mots inconnus et sugg√®re des remplacements appropri√©s, rempla√ßant automatiquement le texte saisi √† moins que l'utilisateur ne remplace le remplacement. La valeur par d√©faut de cette propri√©t√© est `UITextAutocorrectionTypeDefault`, qui pour la plupart des m√©thodes de saisie active la correction automatique.
* `var secureTextEntry: BOOL` d√©termine si la copie de texte et le cache de texte sont d√©sactiv√©s et masque le texte saisi pour `UITextField`. La valeur par d√©faut de cette propri√©t√© est `NO`.

**Pour identifier ce comportement dans le code :**

* Recherchez dans le code source des impl√©mentations similaires, telles que
```objectivec
  textObject.autocorrectionType = UITextAutocorrectionTypeNo;
  textObject.secureTextEntry = YES;
```
* Ouvrez les fichiers xib et storyboard dans l'`Interface Builder` de Xcode et v√©rifiez les √©tats de `Secure Text Entry` et `Correction` dans l'`Inspecteur d'attributs` pour l'objet appropri√©.

L'application doit emp√™cher la mise en cache des informations sensibles saisies dans les champs de texte. Vous pouvez emp√™cher la mise en cache en la d√©sactivant de mani√®re programmatique, en utilisant la directive `textObject.autocorrectionType = UITextAutocorrectionTypeNo` dans les UITextFields, UITextViews et UISearchBars souhait√©s. Pour les donn√©es qui doivent √™tre masqu√©es, telles que les codes PIN et les mots de passe, d√©finissez `textObject.secureTextEntry` sur `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Journaux**

Les moyens les plus courants de d√©boguer le code consistent √† utiliser des journaux, et l'application **peut imprimer des informations sensibles dans les journaux**.\
Dans les versions iOS 6 et inf√©rieures, les journaux √©taient lisibles par tous (une application malveillante pouvait lire les journaux d'autres applications et extraire des informations sensibles √† partir de l√†). **De nos jours, les applications ne peuvent acc√©der qu'√† leurs propres journaux**.

Cependant, un **attaquant** ayant un **acc√®s physique** √† un appareil **d√©verrouill√©** peut le connecter √† un ordinateur et **lire les journaux** (notez que les journaux √©crits sur le disque par une application ne sont pas supprim√©s si l'application est d√©sinstall√©e).

Il est recommand√© de **naviguer √† travers toutes les pages** de l'application et **d'interagir** avec **chaque** √©l√©ment d'interface utilisateur et **fonctionnalit√©** et de fournir du texte d'entr√©e dans tous les champs de texte et **d'examiner les journaux** √† la recherche d'informations **sensibles** expos√©es.

Utilisez les mots-cl√©s suivants pour v√©rifier le code source de l'application pour les d√©clarations de journalisation pr√©d√©finies et personnalis√©es :

* Pour les fonctions pr√©d√©finies et int√©gr√©es :
  * NSLog
  * NSAssert
  * NSCAssert
  * fprintf
* Pour les fonctions personnalis√©es :
  * Logging
  * Logfile

**Surveillance des journaux syst√®me**

De nombreuses applications enregistrent des messages informatifs (et potentiellement sensibles) dans le journal de la console. Le journal contient √©galement des rapports de plantage et d'autres informations utiles.

Vous pouvez utiliser ces outils :
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Vous pouvez collecter les journaux de console via la fen√™tre **Appareils** de Xcode de la mani√®re suivante :

1. Lancez Xcode.
2. Connectez votre appareil √† votre ordinateur h√¥te.
3. Choisissez **Fen√™tre** -> **Appareils et simulateurs**.
4. Cliquez sur votre appareil iOS connect√© dans la section de gauche de la fen√™tre Appareils.
5. Reproduisez le probl√®me.
6. Cliquez sur le bouton **Ouvrir la console** situ√© dans la partie sup√©rieure droite de la fen√™tre Appareils pour afficher les journaux de console sur une fen√™tre s√©par√©e.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (6).png>)

Vous pouvez √©galement vous connecter √† l'invite de commande de l'appareil comme expliqu√© dans l'acc√®s √† l'invite de commande de l'appareil, installer **socat** via **apt-get** et ex√©cuter la commande suivante :
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Utilisez [**Trickest**](https://trickest.io/) pour cr√©er et **automatiser des workflows** avec les outils communautaires les plus avanc√©s au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Sauvegardes

iOS inclut des fonctionnalit√©s de sauvegarde automatique qui cr√©ent des copies des donn√©es stock√©es sur l'appareil. Vous pouvez **faire des sauvegardes iOS** depuis votre ordinateur h√¥te en utilisant iTunes (jusqu'√† macOS Catalina) ou Finder (√† partir de macOS Catalina), ou via la fonction de sauvegarde iCloud. Dans les deux cas, la sauvegarde inclut presque toutes les donn√©es stock√©es sur l'appareil iOS, sauf les donn√©es hautement sensibles telles que les informations Apple Pay et les param√®tres Touch ID.

√âtant donn√© qu'iOS sauvegarde les applications install√©es et leurs donn√©es, une pr√©occupation √©vidente est de savoir si les donn√©es sensibles de l'utilisateur stock√©es par l'application pourraient **fuir accidentellement √† travers la sauvegarde**. Une autre pr√©occupation, bien que moins √©vidente, est de savoir si les param√®tres de configuration sensibles utilis√©s pour prot√©ger les donn√©es ou restreindre la fonctionnalit√© de l'application pourraient √™tre alt√©r√©s pour changer le comportement de l'application apr√®s la restauration d'une sauvegarde modifi√©e. Les deux pr√©occupations sont valides et ces vuln√©rabilit√©s se sont av√©r√©es exister dans un grand nombre d'applications aujourd'hui.

Une sauvegarde d'un appareil sur lequel une application mobile a √©t√© install√©e inclura tous les sous-r√©pertoires (√† l'exception de `Library/Caches/`) et fichiers dans le [r√©pertoire priv√© de l'application](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW12).\
Par cons√©quent, **√©vitez de stocker des donn√©es sensibles en texte clair dans l'un des fichiers ou dossiers qui se trouvent dans le r√©pertoire priv√© ou les sous-r√©pertoires de l'application**.

Bien que tous les fichiers dans `Documents/` et `Library/Application Support/` soient toujours sauvegard√©s par d√©faut, vous pouvez [exclure des fichiers de la sauvegarde](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW28) en appelant `NSURL setResourceValue:forKey:error:` avec la cl√© `NSURLIsExcludedFromBackupKey`.\
Vous pouvez utiliser les propri√©t√©s du syst√®me de fichiers [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple\_ref/c/data/NSURLIsExcludedFromBackupKey) et [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple\_ref/c/data/kCFURLIsExcludedFromBackupKey) pour exclure des fichiers et des r√©pertoires des sauvegardes.

{% hint style="warning" %}
Par cons√©quent, lors de la v√©rification de la sauvegarde d'une application, vous devez v√©rifier si **toute information sensible** est accessible et si vous pouvez **modifier tout comportement sensible** de l'application en **modifiant certains param√®tres de la sauvegarde** et en restaurant la sauvegarde.
{% endhint %}

**Comment tester**

Commencez par **cr√©er une sauvegarde de l'appareil** (vous pouvez le faire en utilisant Finder) et trouvez o√π est stock√©e la sauvegarde. La documentation officielle d'Apple vous aidera √† [localiser les sauvegardes de votre iPhone, iPad et iPod touch](https://support.apple.com/en-us/HT204215).

Une fois que vous avez trouv√© la sauvegarde de l'appareil (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), vous pouvez commencer √† chercher des informations sensibles en utilisant grep, par exemple, ou en utilisant des outils comme [iMazing](https://imazing.com)).

Pour identifier si une sauvegarde est chiffr√©e, vous pouvez v√©rifier la cl√© nomm√©e "IsEncrypted" du fichier "Manifest.plist", situ√© √† la racine du r√©pertoire de sauvegarde. L'exemple suivant montre une configuration indiquant que la sauvegarde est chiffr√©e :
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
 <key>Date</key>
 <date>2021-03-12T17:43:33Z</date>
 <key>IsEncrypted</key>
 <true/>
...
</plist>
```
Si vous devez travailler avec une sauvegarde chiffr√©e, il existe des scripts Python dans le d√©p√¥t GitHub de [DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), tels que **backup\_tool.py** et **backup\_passwd.py**, qui serviront de bon point de d√©part. Cependant, notez qu'ils pourraient ne pas fonctionner avec les derni√®res versions d'iTunes/Finder et qu'ils pourraient n√©cessiter des ajustements.

Vous pouvez √©galement utiliser l'outil [**iOSbackup**](https://pypi.org/project/iOSbackup/) pour lire et extraire facilement des fichiers √† partir d'une sauvegarde iOS chiffr√©e par mot de passe.

**Comment modifier le comportement**

Dans l'application open source de portefeuille Bitcoin, [Bither](https://github.com/bither/bither-ios), vous verrez qu'il est possible de configurer un code PIN pour verrouiller l'interface utilisateur.\
Ce code PIN est stock√© dans le fichier `net.bither.plist` √† l'int√©rieur de la **cl√©** **pin\_code**.\
Si vous effacez cette cl√© de ce plist dans la sauvegarde et restaurez la sauvegarde, vous pourrez acc√©der au portefeuille.

## Tester la m√©moire pour des donn√©es sensibles

√Ä un moment donn√©, des informations sensibles vont √™tre stock√©es en m√©moire. L'objectif est de s'assurer que ces informations sont expos√©es aussi bri√®vement que possible.

Pour enqu√™ter sur la m√©moire d'une application, cr√©ez d'abord un **dump de m√©moire**. Alternativement, vous pouvez **analyser la m√©moire en temps r√©el** avec, par exemple, un d√©bogueur. Quelle que soit la m√©thode que vous utilisez, c'est un processus tr√®s propice aux erreurs car les dumps fournissent les donn√©es laiss√©es par les fonctions ex√©cut√©es et vous pourriez manquer d'ex√©cuter des √©tapes critiques. De plus, il est assez facile d'omettre des donn√©es lors de l'analyse √† moins que vous ne connaissiez l'empreinte des donn√©es que vous recherchez (soit sa valeur exacte, soit son format). Par exemple, si l'application chiffre selon une cl√© sym√©trique g√©n√©r√©e de mani√®re al√©atoire, il est tr√®s peu probable que vous rep√©riez la cl√© en m√©moire √† moins que vous ne trouviez sa valeur par d'autres moyens.

**R√©cup√©ration et analyse d'un dump de m√©moire**

Que vous utilisiez un appareil jailbreak√© ou non jailbreak√©, vous pouvez extraire la m√©moire du processus de l'application avec [objection](https://github.com/sensepost/objection) et [Fridump](https://github.com/Nightbringer21/fridump).

Apr√®s que la m√©moire ait √©t√© extraite (par exemple dans un fichier appel√© "memory"), en fonction de la nature des donn√©es que vous recherchez, vous aurez besoin d'un ensemble d'outils diff√©rents pour traiter et analyser ce dump de m√©moire. Par exemple, si vous vous concentrez sur les cha√Ænes de caract√®res, il pourrait suffire d'ex√©cuter la commande `strings` ou `rabin2 -zz` pour extraire ces cha√Ænes de caract√®res.
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Ouvrez `strings.txt` dans votre √©diteur pr√©f√©r√© et fouillez-le pour identifier des informations sensibles.

Cependant, si vous souhaitez inspecter d'autres types de donn√©es, vous pr√©f√©rerez utiliser radare2 et ses capacit√©s de recherche. Consultez l'aide de radare2 sur la commande de recherche (`/?`) pour plus d'informations et une liste d'options. Ce qui suit n'en montre qu'un sous-ensemble :
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**Analyse de la m√©moire d'ex√©cution**

En utilisant [**r2frida**](https://github.com/nowsecure/r2frida), vous pouvez analyser et inspecter la m√©moire de l'application pendant son ex√©cution sans avoir besoin de la d√©charger. Par exemple, vous pouvez ex√©cuter les commandes de recherche pr√©c√©dentes √† partir de r2frida et rechercher dans la m√©moire une cha√Æne de caract√®res, des valeurs hexad√©cimales, etc. Lorsque vous le faites, n'oubliez pas de pr√©fixer la commande de recherche (et toute autre commande sp√©cifique √† r2frida) avec un backslash `\` apr√®s avoir d√©marr√© la session avec `r2 frida://usb//<nom_de_votre_application>`.

## Cryptographie cass√©e

### Mauvais processus de gestion des cl√©s

Certains d√©veloppeurs enregistrent des donn√©es sensibles dans le stockage local et les chiffrent avec une cl√© cod√©e en dur/pr√©visible dans le code. Cela ne devrait pas √™tre fait car une r√©tro-ing√©nierie pourrait permettre aux attaquants d'extraire les informations confidentielles.

### Utilisation d'algorithmes non s√©curis√©s et/ou obsol√®tes

Les d√©veloppeurs ne devraient pas utiliser des **algorithmes obsol√®tes** pour effectuer des **v√©rifications** d'autorisation, **stocker** ou **envoyer** des donn√©es. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hachages** sont utilis√©s pour stocker des mots de passe par exemple, des hachages r√©sistants √† la force brute devraient √™tre utilis√©s avec un sel.

### V√©rification

Les principales v√©rifications √† effectuer consistent √† rechercher des mots de passe/secrets **cod√©s en dur** dans le code, ou si ceux-ci sont **pr√©visibles**, et si le code utilise des algorithmes de **cryptographie** **faibles**.

Il est int√©ressant de savoir que vous pouvez **surveiller** automatiquement certaines **biblioth√®ques de cryptographie** en utilisant **objection** avec :
```swift
ios monitor crypt
```
Pour **plus d'informations** sur les API et biblioth√®ques cryptographiques iOS, acc√©dez √† [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Authentification locale

Le testeur doit √™tre conscient que **l'authentification locale doit toujours √™tre appliqu√©e √† un point d'extr√©mit√© distant** ou bas√©e sur une primitive cryptographique. Les attaquants peuvent facilement contourner l'authentification locale si aucune donn√©e ne retourne du processus d'authentification.

Le [**framework d'authentification locale**](https://developer.apple.com/documentation/localauthentication) \_\*\*\_fournit un ensemble d'API pour que les d√©veloppeurs √©tendent une bo√Æte de dialogue d'authentification √† un utilisateur. Dans le contexte de la connexion √† un service distant, il est possible (et recommand√©) d'utiliser le [trousseau](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pour impl√©menter l'authentification locale.

Le capteur **d'empreintes digitales** est exploit√© par le [coprocesseur de s√©curit√© SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) et n'expose pas les donn√©es d'empreintes digitales √† d'autres parties du syst√®me. √Ä c√¥t√© de Touch ID, Apple a introduit _Face ID_ : qui permet l'authentification bas√©e sur la reconnaissance faciale.

Les d√©veloppeurs ont deux options pour incorporer l'authentification Touch ID/Face ID :

* `LocalAuthentication.framework` est une API de haut niveau qui peut √™tre utilis√©e pour **authentifier l'utilisateur via Touch ID**. L'application ne peut pas acc√©der √† toutes les donn√©es associ√©es √† l'empreinte digitale enregistr√©e et est seulement notifi√©e si l'authentification a r√©ussi.
* `Security.framework` est une API de niveau inf√©rieur pour acc√©der aux [services de trousseau](https://developer.apple.com/documentation/security/keychain\_services). C'est une option s√©curis√©e si votre application doit **prot√©ger certaines donn√©es secr√®tes avec une authentification biom√©trique**, car le contr√¥le d'acc√®s est g√©r√© au niveau du syst√®me et ne peut pas √™tre facilement contourn√©. `Security.framework` a une API C, mais il existe plusieurs [enveloppes open source disponibles](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), rendant l'acc√®s au trousseau aussi simple que pour NSUserDefaults.

{% hint style="danger" %}
Veuillez noter que l'utilisation de `LocalAuthentication.framework` ou de `Security.framework` sera un contr√¥le qui peut √™tre contourn√© par un attaquant car il ne retourne qu'un bool√©en et aucune donn√©e pour continuer. Voir [Don't touch me that way, de David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) pour plus de d√©tails.
{% endhint %}

### Framework d'authentification locale

Les d√©veloppeurs peuvent afficher une **invite d'authentification** en utilisant la fonction **`evaluatePolicy`** de la classe **`LAContext`**. Deux politiques disponibles d√©finissent les formes d'authentification acceptables :

* `deviceOwnerAuthentication`(Swift) ou `LAPolicyDeviceOwnerAuthentication`(Objective-C) : Lorsque disponible, l'utilisateur est invit√© √† effectuer une authentification Touch ID. Si Touch ID n'est pas activ√©, le code d'acc√®s de l'appareil est demand√© √† la place. Si le code d'acc√®s de l'appareil n'est pas activ√©, l'√©valuation de la politique √©choue.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) ou `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C) : L'authentification est restreinte aux donn√©es biom√©triques o√π l'utilisateur est invit√© √† utiliser Touch ID.

La **fonction `evaluatePolicy` renvoie une valeur bool√©enne** indiquant si l'utilisateur s'est authentifi√© avec succ√®s. Ce qui signifie qu'il peut √™tre facilement contourn√© (voir ci-dessous)

### Authentification locale en utilisant le trousseau

Les **API de trousseau iOS peuvent (et doivent) √™tre utilis√©es pour impl√©menter l'authentification locale**. Au cours de ce processus, l'application stocke soit un jeton d'authentification secret, soit une autre pi√®ce de donn√©es secr√®tes identifiant l'utilisateur dans le trousseau. Pour s'authentifier aupr√®s d'un service distant, l'utilisateur doit d√©verrouiller le trousseau en utilisant son mot de passe ou son empreinte digitale pour obtenir les donn√©es secr√®tes.

Le trousseau permet de sauvegarder des √©l√©ments avec l'attribut sp√©cial `SecAccessControl`, qui permettra l'acc√®s √† l'√©l√©ment du trousseau uniquement apr√®s que l'utilisateur ait pass√© l'authentification Touch ID (ou le code d'acc√®s, si une telle solution de repli est autoris√©e par les param√®tres d'attribut).

Dans l'exemple suivant, nous allons enregistrer la cha√Æne "test\_strong\_password" dans le trousseau. La cha√Æne ne peut √™tre acc√©d√©e que sur l'appareil actuel tant que le code d'acc√®s est d√©fini (`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` param√®tre) et apr√®s l'authentification Touch ID pour les empreintes digitales actuellement enregistr√©es (`SecAccessControlCreateFlags.biometryCurrentSet` param√®tre) :

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
                                                          kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
                                                          SecAccessControlCreateFlags.biometryCurrentSet,
                                                          &error) else {
    // failed to create AccessControl object

    return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
    // successfully saved
} else {
    // error while saving
}
```
{% endtab %}

{% tab title="Fran√ßais" %}
{% endtab %}
```objectivec
    // 1. create AccessControl object that will represent authentication settings
    CFErrorRef *err = nil;

    SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
        kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
        kSecAccessControlUserPresence,
        err);

    // 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
    NSDictionary* query = @{
        (_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
        (__bridge id)kSecAttrLabel: @"com.me.myapp.password",
        (__bridge id)kSecAttrAccount: @"OWASP Account",
        (__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
        (__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
    };

    // 3. save item
    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

    if (status == noErr) {
        // successfully saved
    } else {
        // error while saving
    }
```
{% endtab %}
{% tab title="French" %}
Maintenant, nous pouvons demander l'√©l√©ment enregistr√© dans le trousseau. Les services de trousseau pr√©senteront la bo√Æte de dialogue d'authentification √† l'utilisateur et renverront des donn√©es ou nil en fonction de la fourniture ou non d'une empreinte digitale appropri√©e.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
    SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
    let password = String(data: queryResult as! Data, encoding: .utf8)!
    // successfully received password
} else {
    // authorization not passed
}
```
{% endtab %}

{% tab title="Fran√ßais" %}
{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
    (__bridge id)kSecReturnData: @YES,
    (__bridge id)kSecAttrAccount: @"My Name1",
    (__bridge id)kSecAttrLabel: @"com.me.myapp.password",
    (__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
    NSData* resultData = ( __bridge_transfer NSData* )queryResult;
    NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
    NSLog(@"%@", password);
} else {
    NSLog(@"Something went wrong");
}
```
### D√©tection

L'utilisation de frameworks dans une application peut √©galement √™tre d√©tect√©e en analysant la liste des biblioth√®ques dynamiques partag√©es de l'application binaire. Cela peut √™tre fait en utilisant `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Si `LocalAuthentication.framework` est utilis√© dans une application, la sortie contiendra les deux lignes suivantes (rappelez-vous que `LocalAuthentication.framework` utilise `Security.framework` sous le capot):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si `Security.framework` est utilis√©, seul le deuxi√®me sera affich√©.

### Contournement du Framework d'Authentification Locale

#### Objection

\*\*\*\*[**Contournement de la biom√©trie Objection**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) \*\*\*\* peut √™tre utilis√© pour contourner LocalAuthentication. Objection **utilise Frida pour instrumenter la fonction `evaluatePolicy` afin qu'elle renvoie `True`** m√™me si l'authentification n'a pas √©t√© effectu√©e avec succ√®s. Utilisez la commande `ios ui biometrics_bypass` pour contourner l'authentification biom√©trique non s√©curis√©e. Objection enregistrera un travail, qui remplacera le r√©sultat de `evaluatePolicy`. Cela fonctionnera dans les impl√©mentations Swift et Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Si vuln√©rable, le module contournera automatiquement le formulaire de connexion.

#### Frida

Un exemple d'utilisation de **`evaluatePolicy`** de l'application [DVIA-v2](https://github.com/prateek147/DVIA-v2) :
```swift
+(void)authenticateWithTouchID {
    LAContext *myContext = [[LAContext alloc] init];
    NSError *authError = nil;
    NSString *myLocalizedReasonString = @"Please authenticate yourself";
     
    if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
        [myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
                  localizedReason:myLocalizedReasonString
                            reply:^(BOOL success, NSError *error) {
                                if (success) {
                                    dispatch_async(dispatch_get_main_queue(), ^{
                                    [TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
                                    });
                                } else {
                                    dispatch_async(dispatch_get_main_queue(), ^{
                                       [TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
                                    });
                                }
                            }];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
        });
    }
}
```
Pour contourner l'authentification locale, nous devons √©crire un script Frida qui **contourne** la v√©rification _**evaluatePolicy** \_ mentionn√©e ci-dessus. Comme vous pouvez le voir dans l'extrait de code ci-dessus, **evaluatePolicy** utilise un **callback** qui d√©termine le **r√©sultat**. Ainsi, le moyen le plus simple de r√©aliser le piratage est d'intercepter ce rappel et de vous assurer qu'il retourne toujours **success=1**.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
    console.log("Injecting...");
    var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
    Interceptor.attach(hook.implementation, {
        onEnter: function(args) {
            var block = new ObjC.Block(args[4]);
            const callback = block.implementation;
            block.implementation = function (error, value)  {
 
                console.log("Changing the result value to true")
                const result = callback(1, null);
                return result;
            };
        },
    });
} else {
    console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposition de fonctionnalit√©s sensibles via IPC

### Gestionnaires d'URI personnalis√©s / Liens profonds / Sch√©mas personnalis√©s

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Liens universels

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Partage d'activit√©s UI

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensions d'application

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### S√©rialisation et encodage

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Communication r√©seau

Il est important de v√©rifier qu'aucune communication ne se produit **sans chiffrement** et que l'application **valide correctement le certificat TLS** du serveur.\
Pour v√©rifier ces types de probl√®mes, vous pouvez utiliser un proxy comme **Burp** :

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### V√©rification du nom d'h√¥te

Un probl√®me courant de validation du certificat TLS consiste √† v√©rifier que le certificat a √©t√© sign√© par une **AC de confiance**, mais **ne pas v√©rifier** si **le nom d'h√¥te** du certificat est le nom d'h√¥te qui est acc√©d√©.\
Pour v√©rifier ce probl√®me √† l'aide de Burp, apr√®s avoir fait confiance √† Burp CA sur l'iPhone, vous pouvez **cr√©er un nouveau certificat avec Burp pour un nom d'h√¥te diff√©rent** et l'utiliser. Si l'application fonctionne toujours, alors quelque chose est vuln√©rable.

### √âpinglage de certificat

Si une application utilise correctement SSL Pinning, alors l'application ne fonctionnera que si le certificat est celui qui est attendu. Lors du test d'une application, **cela peut poser probl√®me car Burp servira son propre certificat.**\
Pour contourner cette protection √† l'int√©rieur d'un appareil jailbreak√©, vous pouvez installer l'application [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou installer \[**Burp Mobile Assistant\_\*]\(\_**[**https://portswigger.net/burp/documentation/desktop/tools/mobile-assistant/installing)\\**](https://portswigger.net/burp/documentation/desktop/tools/mobile-assistant/installing\)/)\*

Vous pouvez √©galement utiliser la commande `ios sslpinning disable` d'**objection**.

## Divers

* Dans **`/System/Library`**, vous pouvez trouver les frameworks install√©s dans le t√©l√©phone utilis√©s par les applications syst√®me.
* Les applications install√©es par l'utilisateur depuis l'App Store sont situ√©es dans **`/User/Applications`**.
* Et **`/User/Library`** contient les donn√©es enregistr√©es par les applications de niveau utilisateur.
* Vous pouvez acc√©der √† **`/User/Library/Notes/notes.sqlite`** pour lire les notes enregistr√©es dans l'application.
* √Ä l'int√©rieur du dossier d'une application install√©e (**`/User/Applications/<ID DE L'APPLICATION>/`**), vous pouvez trouver des fichiers int√©ressants :
  * **`iTunesArtwork`** : L'ic√¥ne utilis√©e par l'application.
  * **`iTunesMetadata.plist`** : Informations de l'application utilis√©es dans l'App Store.
  * **`/Library/*`** : Contient les pr√©f√©rences et le cache. Dans **`/Library/Cache/Snapshots/*`**, vous pouvez trouver la capture d'√©cran effectu√©e par l'application avant de l'envoyer en arri√®re-plan.

### Patch √† chaud / Mise √† jour forc√©e

Les d√©veloppeurs peuvent **corriger √† distance toutes les installations de leur application instantan√©ment** sans avoir √† soumettre √† nouveau l'application √† l'App Store et attendre qu'elle soit approuv√©e.\
√Ä cette fin, on utilise g√©n√©ralement [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mais il existe d'autres options telles que [Siren](https://github.com/ArtSabintsev/Siren) et [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Il s'agit d'un m√©canisme dangereux qui pourrait √™tre utilis√© √† mauvais escient par des SDK tiers malveillants, il est donc recommand√© de v√©rifier quelle m√©thode est utilis√©e pour la mise √† jour automatique (le cas √©ch√©ant) et de la tester.** Vous pouvez essayer de t√©l√©charger une version pr√©c√©dente de l'application √† cette fin.

### Tiers

Un probl√®me des SDK tiers est qu'il n'y a **pas de contr√¥le granulaire sur les fonctionnalit√©s offertes par le SDK**. Vous pouvez utiliser le SDK et avoir toutes les fonctionnalit√©s (y compris les fuites de diagnostic et les connexions HTTP non s√©curis√©es), ou ne pas l'utiliser. De plus, il n'est g√©n√©ralement pas possible pour les d√©veloppeurs d'applications de **corriger une vuln√©rabilit√©** dans le SDK.\
De plus, certains SDK commencent **√† contenir des logiciels malveillants une fois qu'ils sont tr√®s fiables** par la communaut√©.

En outre, les fonctionnalit√©s que ces services fournissent peuvent impliquer des services de **suivi pour surveiller le comportement de l'utilisateur** lors de l'utilisation de l'application, la vente de banni√®res publicitaires ou l'am√©lioration de l'exp√©rience utilisateur. L'inconv√©nient des
