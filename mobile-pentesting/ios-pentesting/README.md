# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnove iOS-a

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## OkruÅ¾enje za testiranje

Na ovoj stranici moÅ¾ete pronaÄ‡i informacije o **iOS simulatoru**, **emulatorima** i **jailbreaking-u:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## PoÄetna analiza

### Osnovne operacije testiranja iOS-a

Tokom testiranja Ä‡e biti predloÅ¾ene **razliÄite operacije** (povezivanje sa ureÄ‘ajem, Äitanje/pisanje/otpisivanje/preuzimanje fajlova, koriÅ¡Ä‡enje nekih alata...). Stoga, ako ne znate kako da izvrÅ¡ite bilo koju od ovih radnji, molimo vas da **poÄnete sa Äitanjem stranice**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Za sledeÄ‡e korake **aplikacija treba biti instalirana** na ureÄ‘aju i veÄ‡ ste trebali dobiti **IPA fajl** aplikacije.\
ProÄitajte stranicu [Osnovne operacije testiranja iOS-a](basic-ios-testing-operations.md) da biste saznali kako to uraditi.
{% endhint %}

### Osnovna statiÄka analiza

PreporuÄuje se koriÅ¡Ä‡enje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za automatsku statiÄku analizu IPA fajla.

Identifikacija **zaÅ¡tita koje su prisutne u binarnom fajlu**:

*   **PIE (Position Independent Executable)**: Kada je omoguÄ‡eno, aplikacija se uÄitava na nasumiÄnu memorijsku adresu svaki put kada se pokrene, Äime se oteÅ¾ava predviÄ‘anje njene poÄetne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # Trebalo bi da ukljuÄuje zastavicu PIE
```
*   **Stack Canaries**: Da bi se validirala celovitost steka, 'canary' vrednost se postavlja na stek pre poziva funkcije i ponovo se validira kada funkcija zavrÅ¡i.

```bash
otool -I -v <app-binary> | grep stack_chk   # Trebalo bi da ukljuÄuje simbole: stack_chk_guard i stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Da bi se spreÄile uobiÄajene greÅ¡ke u korupciji memorije

```bash
otool -I -v <app-binary> | grep objc_release   # Trebalo bi da ukljuÄuje simbol _objc_release
```
*   **Enkriptovan binarni fajl**: Binarni fajl treba da bude enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid treba da bude 1
```

**Identifikacija osetljivih/nepouzdanih funkcija**

*   **Slabe funkcije za heÅ¡iranje**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Na linux-u
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Nepouzdane funkcije za generisanje sluÄajnih brojeva**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Na linux-u
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Nepouzdana 'Malloc' funkcija**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_malloc"

# Na linux-u
grep -iER "_malloc"
```
*   **Nepouzdane i ranjive funkcije**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Na linux-u
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Osnovna dinamiÄka analiza

Pogledajte dinamiÄku analizu koju vrÅ¡i [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Morate da navigujete kroz razliÄite prikaze i interagujete sa njima, ali Ä‡e povezati nekoliko klasa, obavljati druge radnje i pripremiti izveÅ¡taj kada zavrÅ¡ite.

### Lista instaliranih aplikacija

Koristite komandu `frida-ps -Uai` da biste odredili **identifikator paketa** instaliranih aplikacija:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Osnovna enumeracija i hakovanje

NauÄite kako da **enumeriÅ¡ete komponente aplikacije** i kako lako da **hukujete metode i klase** pomoÄ‡u objection alata:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Struktura IPA fajla

Struktura **IPA fajla** je suÅ¡tinski kao **zipovanog paketa**. Preimenovanjem ekstenzije u `.zip`, moÅ¾e se **dekompresovati** kako bi se otkrili njegovi sadrÅ¾aji. Unutar ove strukture, **Bundle** predstavlja potpuno zapakovanu aplikaciju spremnu za instalaciju. Unutar, pronaÄ‡i Ä‡ete direktorijum nazvan `<IME>.app`, koji obuhvata resurse aplikacije.

* **`Info.plist`**: Ovaj fajl sadrÅ¾i specifiÄne konfiguracione detalje aplikacije.
* **`_CodeSignature/`**: Ovaj direktorijum ukljuÄuje plist fajl koji sadrÅ¾i potpis, osiguravajuÄ‡i integritet svih fajlova u paketu.
* **`Assets.car`**: Kompresovani arhiv koji Äuva fajlove resursa poput ikona.
* **`Frameworks/`**: Ovaj folder sadrÅ¾i native biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
* **`PlugIns/`**: Ovde se mogu nalaziti proÅ¡irenja aplikacije, poznata kao `.appex` fajlovi, iako nisu uvek prisutni.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Koristi se za Äuvanje trajnih podataka vaÅ¡e aplikacije za offline koriÅ¡Ä‡enje, keÅ¡iranje privremenih podataka i dodavanje funkcionalnosti poniÅ¡tavanja u vaÅ¡u aplikaciju na jednom ureÄ‘aju. Da sinhronizujete podatke na viÅ¡e ureÄ‘aja u jednom iCloud nalogu, Core Data automatski preslikava vaÅ¡u Å¡emu u CloudKit kontejner.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Fajl `PkgInfo` je alternativni naÄin za specificiranje tipa i kreator koda vaÅ¡e aplikacije ili paketa.
* **en.lproj, fr.proj, Base.lproj**: Su jeziÄki paketi koji sadrÅ¾e resurse za te specifiÄne jezike, i podrazumevani resurs u sluÄaju da jezik nije podrÅ¾an.
* **Bezbednost**: Direktorijum `_CodeSignature/` igra kljuÄnu ulogu u bezbednosti aplikacije verifikujuÄ‡i integritet svih zapakovanih fajlova putem digitalnih potpisa.
* **Upravljanje resursima**: Fajl `Assets.car` koristi kompresiju za efikasno upravljanje grafiÄkim resursima, Å¡to je kljuÄno za optimizaciju performansi aplikacije i smanjenje njenog ukupnog obima.
* **Frameworks i PlugIns**: Ovi direktorijumi istiÄu modularnost iOS aplikacija, omoguÄ‡avajuÄ‡i programerima da ukljuÄe biblioteke sa ponovno iskoristivim kodom (`Frameworks/`) i proÅ¡ire funkcionalnost aplikacije (`PlugIns/`).
* **Lokalizacija**: Struktura podrÅ¾ava viÅ¡e jezika, olakÅ¡avajuÄ‡i globalni doseg aplikacije ukljuÄivanjem resursa za specifiÄne jeziÄke pakete.

**Info.plist**

**Info.plist** sluÅ¾i kao osnova za iOS aplikacije, obuhvatajuÄ‡i kljuÄne konfiguracione podatke u obliku **kljuÄ-vrednost** parova. Ovaj fajl je obavezan ne samo za aplikacije veÄ‡ i za proÅ¡irenja aplikacija i okvire koji su zapakovani unutar njih. Strukturiran je u XML ili binarnom formatu i sadrÅ¾i kljuÄne informacije koje se kreÄ‡u od dozvola aplikacije do sigurnosnih konfiguracija. Za detaljno istraÅ¾ivanje dostupnih kljuÄeva, moÅ¾ete se obratiti [**Apple Developer dokumentaciji**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Za one koji Å¾ele da rade sa ovim fajlom u pristupaÄnijem formatu, konverzija u XML format moÅ¾e se postiÄ‡i lako koriÅ¡Ä‡enjem `plutil` na macOS-u (dostupno nativno na verzijama 10.2 i kasnije) ili `plistutil` na Linux-u. Komande za konverziju su sledeÄ‡e:

* **Za macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Za Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
MeÄ‘u mnoÅ¡tvom informacija koje **Info.plist** fajl moÅ¾e otkriti, znaÄajni unosi ukljuÄuju niske dozvola aplikacije (`UsageDescription`), prilagoÄ‘ene URL Å¡eme (`CFBundleURLTypes`), i konfiguracije za bezbednost transporta aplikacije (`NSAppTransportSecurity`). Ovi unosi, zajedno sa drugima poput izvezenih/uvezenih prilagoÄ‘enih tipova dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaÄ‡i inspekcijom fajla ili koriÅ¡Ä‡enjem jednostavne `grep` komande:
```bash
$ grep -i <keyword> Info.plist
```
**Putanje podataka**

U iOS okruÅ¾enju, direktorijumi su posebno odreÄ‘eni za **sistemsku aplikaciju** i **korisniÄki instalirane aplikacije**. Sistemski aplikacije se nalaze u direktorijumu `/Applications`, dok se korisniÄki instalirane aplikacije smeÅ¡taju pod `/private/var/containers/`. Ove aplikacije su dodeljene jedinstveni identifikator poznat kao **128-bitni UUID**, Å¡to Äini ruÄno lociranje foldera aplikacije izazovnim zbog nasumiÄnosti imena direktorijuma.

Kako bi olakÅ¡ao otkrivanje direktorijuma instalacije korisniÄki instalirane aplikacije, **objection alat** pruÅ¾a korisnu komandu, `env`. Ova komanda otkriva detaljne informacije o direktorijumu za datu aplikaciju. U nastavku je primer kako koristiti ovu komandu:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativno, ime aplikacije moÅ¾e biti pretraÅ¾eno unutar `/private/var/containers` koriÅ¡Ä‡enjem `find` komande:
```bash
find /private/var/containers -name "Progname*"
```
Komande poput `ps` i `lsof` takoÄ‘e mogu biti iskoriÅ¡Ä‡ene za identifikaciju procesa aplikacije i listanje otvorenih fajlova, redom, pruÅ¾ajuÄ‡i uvid u aktivne putanje direktorijuma aplikacije:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Direktorijum paketa:**

* **AppName.app**
* Ovo je Aplikacioni Paket kao Å¡to je viÄ‘eno ranije u IPA, sadrÅ¾i osnovne podatke aplikacije, statiÄki sadrÅ¾aj kao i kompilirani binarni fajl aplikacije.
* Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu pisati u njega**.
* SadrÅ¾aj u ovom direktorijumu **nije rezervisan**.
* SadrÅ¾aj ovog foldera se koristi za **validaciju potpisa koda**.

**Direktorijum podataka:**

* **Documents/**
* SadrÅ¾i sve podatke koje je generisao korisnik. Korisnik aplikacije inicira kreiranje ovih podataka.
* Vidljiv korisnicima i **korisnici mogu pisati u njega**.
* SadrÅ¾aj u ovom direktorijumu je **rezervisan**.
* Aplikacija moÅ¾e onemoguÄ‡iti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/**
* SadrÅ¾i sve **fajlove koji nisu specifiÄni za korisnika**, kao Å¡to su **keÅ¡evi**, **postavke**, **kolaÄiÄ‡i**, i fajlovi konfiguracije property list (plist).
* iOS aplikacije obiÄno koriste poddirektorijume `Application Support` i `Caches`, ali aplikacija moÅ¾e kreirati prilagoÄ‘ene poddirektorijume.
* **Library/Caches/**
* SadrÅ¾i **polu-persistentne keÅ¡irane fajlove**.
* Nevidljiv korisnicima i **korisnici ne mogu pisati u njega**.
* SadrÅ¾aj u ovom direktorijumu **nije rezervisan**.
* OS moÅ¾e automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je prostor za skladiÅ¡tenje fajlova skoro popunjen.
* **Library/Application Support/**
* SadrÅ¾i **persistentne fajlove** neophodne za pokretanje aplikacije.
* **Nevidljiv** **korisnicima** i korisnici ne mogu pisati u njega.
* SadrÅ¾aj u ovom direktorijumu je **rezervisan**.
* Aplikacija moÅ¾e onemoguÄ‡iti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Koristi se za Äuvanje svojstava koja mogu **trajati Äak i nakon ponovnog pokretanja aplikacije**.
* Informacije se Äuvaju, neÅ¡ifrovane, unutar peska aplikacije u plist fajlu nazvanom \[BUNDLE\_ID].plist.
* Svi parovi kljuÄ/vrednost saÄuvani koriÅ¡Ä‡enjem `NSUserDefaults` mogu se pronaÄ‡i u ovom fajlu.
* **tmp/**
* Koristite ovaj direktorijum za pisanje **privremenih fajlova** koji ne moraju trajati izmeÄ‘u pokretanja aplikacije.
* SadrÅ¾i ne-persistentne keÅ¡irane fajlove.
* **Nevidljiv** korisnicima.
* SadrÅ¾aj u ovom direktorijumu nije rezervisan.
* OS moÅ¾e automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je prostor za skladiÅ¡tenje fajlova skoro popunjen.

Pogledajmo detaljnije Application Bundle (.app) direktorijum iGoat-Swift aplikacije unutar Bundle direktorijuma (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binarno Revertovanje

Unutar foldera `<ime-aplikacije>.app` pronaÄ‡i Ä‡ete binarni fajl nazvan `<ime-aplikacije>`. Ovo je fajl koji Ä‡e biti **izvrÅ¡en**. MoÅ¾ete izvrÅ¡iti osnovnu inspekciju binarnog fajla pomoÄ‡u alata **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Proverite da li je aplikacija enkriptovana**

Vidite da li postoji bilo kakav izlaz za:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Rastavljanje binarnog koda**

Rastavite tekstualni deo:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Da biste odÅ¡tampali **Objective-C segment** uzorka aplikacije, moÅ¾ete koristiti:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Da biste dobili kompaktniji Objective-C kod, moÅ¾ete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
MeÄ‘utim, najbolje opcije za rastavljanje binarnog koda su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## SkladiÅ¡tenje podataka

Da biste saznali kako iOS Äuva podatke na ureÄ‘aju, proÄitajte ovu stranicu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
SledeÄ‡a mesta za skladiÅ¡tenje informacija treba proveriti **odmah nakon instaliranja aplikacije**, **nakon provere svih funkcionalnosti** aplikacije i Äak nakon **odjavljivanja sa jednog korisnika i prijavljivanja sa drugog**.\
Cilj je pronaÄ‡i **nezaÅ¡tiÄ‡ene osetljive informacije** aplikacije (Å¡ifre, tokene), trenutnog korisnika i prethodno prijavljenih korisnika.
{% endhint %}

### Plist

**plist** fajlovi su strukturirani XML fajlovi koji **sadrÅ¾e parove kljuÄ-vrednost**. To je naÄin Äuvanja trajnih podataka, pa ponekad moÅ¾ete pronaÄ‡i **osetljive informacije u ovim fajlovima**. PreporuÄuje se provera ovih fajlova nakon instaliranja aplikacije i nakon intenzivnog koriÅ¡Ä‡enja kako biste videli da li su upisani novi podaci.

NajÄeÅ¡Ä‡i naÄin trajnog Äuvanja podataka u plist fajlovima je kroz koriÅ¡Ä‡enje **NSUserDefaults**. Ovaj plist fajl se Äuva unutar aplikacije u pesku u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) pruÅ¾a programski interfejs za interakciju sa podrazumevanim sistemom. Podrazumevani sistem omoguÄ‡ava aplikaciji da prilagodi svoje ponaÅ¡anje prema **korisniÄkim preferencama**. Podaci saÄuvani pomoÄ‡u `NSUserDefaults` mogu se pregledati u paketu aplikacije. Ova klasa Äuva **podatke** u **plist** **fajlu**, ali je namenjena za koriÅ¡Ä‡enje sa malim koliÄinama podataka.

Ovi podaci ne mogu se direktno pristupiti putem pouzdanog raÄunara, ali se mogu pristupiti pravljenjem **rezervne kopije**.

MoÅ¾ete **izbaciti** informacije saÄuvane koriÅ¡Ä‡enjem **`NSUserDefaults`** koristeÄ‡i `ios nsuserdefaults get` u objection-u.

Da biste pronaÅ¡li sve plist fajlove koje koristi aplikacija, moÅ¾ete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:
```bash
find ./ -name "*.plist"
```
Za konvertovanje fajlova iz **XML ili binarnog (bplist)** formata u XML, dostupne su razliÄite metode u zavisnosti od vaÅ¡eg operativnog sistema:

**Za korisnike macOS-a:** Iskoristite `plutil` komandu. To je ugraÄ‘eni alat u macOS (verzija 10.2+), dizajniran za tu svrhu:
```bash
$ plutil -convert xml1 Info.plist
```
**Za korisnike Linux-a:** Prvo instalirajte `libplist-utils`, zatim koristite `plistutil` da konvertujete vaÅ¡ fajl:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Unutar Objection sesije:** Za analizu mobilnih aplikacija, odreÄ‘ena komanda vam omoguÄ‡ava da direktno konvertujete plist fajlove:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) je okvir za upravljanje slojem modela objekata u vaÅ¡oj aplikaciji. [Core Data moÅ¾e koristiti SQLite kao svoje trajno skladiÅ¡te](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam okvir nije baza podataka.\
CoreData podaci nisu automatski Å¡ifrovani. MeÄ‘utim, dodatni sloj Å¡ifrovanja moÅ¾e biti dodat CoreDatu. Pogledajte [GitHub Repo](https://github.com/project-imas/encrypted-core-data) za viÅ¡e detalja.

Informacije o SQLite Core Data aplikaciji moÅ¾ete pronaÄ‡i na putanji `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako moÅ¾ete otvoriti SQLite i pristupiti osetljivim informacijama, onda ste pronaÅ¡li greÅ¡ku u konfiguraciji.**

{% code title="Kod iz iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je skladiÅ¡te kljuÄ/vrednost izgraÄ‘eno na vrhu SQLite-a.\
PoÅ¡to su Yap baze podataka sqlite baze podataka, moÅ¾ete ih pronaÄ‡i koristeÄ‡i namensku komandu iz prethodnog odeljka.

### Ostale SQLite baze podataka

ÄŒesto se deÅ¡ava da aplikacije kreiraju svoje sopstvene sqlite baze podataka. Mogu **skladiÅ¡titi** **osetljive** **podatke** na njima i ostaviti ih neÅ¡ifrovane. Stoga je uvek interesantno proveriti svaku bazu podataka unutar direktorijuma aplikacije. Zato idite u direktorijum aplikacije gde su podaci saÄuvani (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Programeri mogu **skladiÅ¡titi i sinhronizovati podatke** unutar **NoSQL cloud-hosted baze podataka** putem Firebase Real-Time baza podataka. Podaci se Äuvaju u JSON formatu i sinhronizuju se u realnom vremenu sa svim povezanim klijentima.

Kako proveriti da li su Firebase baze podataka netaÄno konfigurisane moÅ¾ete pronaÄ‡i ovde:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm baze podataka

[Realm Objective-C](https://realm.io/docs/objc/latest/) i [Realm Swift](https://realm.io/docs/swift/latest/) pruÅ¾aju moÄ‡nu alternativu za skladiÅ¡tenje podataka, Å¡to nije obezbeÄ‘eno od strane Apple-a. Podaci se podrazumevano **Äuvaju neÅ¡ifrovano**, a enkripcija je dostupna putem specifiÄne konfiguracije.

Baze podataka se nalaze na: `/private/var/mobile/Containers/Data/Application/{APPID}`. Za istraÅ¾ivanje ovih fajlova, mogu se koristiti komande poput:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Za pregledanje ovih baza podataka preporuÄuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije unutar Realm baze podataka, moÅ¾e se koristiti sledeÄ‡i kodni iseÄak:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Baze podataka Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) je opisan kao **lagani** i **ugraÄ‘eni** baziÄni sistem koji sledi **orijentisan prema dokumentima** (NoSQL) pristup. Dizajniran da bude prirodan za **iOS** i **macOS**, nudi moguÄ‡nost sinhronizacije podataka bez problema.

Da biste identifikovali potencijalne Couchbase baze podataka na ureÄ‘aju, trebalo bi da pregledate sledeÄ‡i direktorijum:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### KolaÄiÄ‡i

iOS Äuva kolaÄiÄ‡e aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar svake fascikle aplikacije. MeÄ‘utim, programeri ponekad odluÄe da ih saÄuvaju u **keychain-u** jer se pomenuti **fajl sa kolaÄiÄ‡ima moÅ¾e pristupiti u rezervnim kopijama**.

Da biste pregledali fajl sa kolaÄiÄ‡ima, moÅ¾ete koristiti [**ovaj Python skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**TakoÄ‘e moÅ¾ete koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### KeÅ¡iranje

Podrazumevano, NSURLSession Äuva podatke, kao Å¡to su **HTTP zahtevi i odgovori u Cache.db** bazi podataka. Ova baza moÅ¾e sadrÅ¾ati **osetljive podatke**, ako su tokeni, korisniÄka imena ili bilo koje druge osetljive informacije keÅ¡irane. Da biste pronaÅ¡li keÅ¡irane informacije, otvorite direktorijum podataka aplikacije (`/var/mobile/Containers/Data/Application/<UUID>`) i idite na `/Library/Caches/<Bundle Identifier>`. **WebKit keÅ¡iranje se takoÄ‘e Äuva u Cache.db** fajlu. **Objection** moÅ¾e otvoriti i interagovati sa bazom podataka komandom `sqlite connect Cache.db`, jer je to **obiÄna SQLite baza podataka**.

**PreporuÄuje se onemoguÄ‡avanje keÅ¡iranja ovih podataka**, jer moÅ¾e sadrÅ¾ati osetljive informacije u zahtevu ili odgovoru. U nastavku je prikazan spisak razliÄitih naÄina postizanja ovoga:

1. PreporuÄuje se uklanjanje keÅ¡iranih odgovora nakon odjave. To se moÅ¾e uraditi pomoÄ‡u pruÅ¾ene metode od strane Apple-a nazvane [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) MoÅ¾ete pozvati ovu metodu na sledeÄ‡i naÄin:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda Ä‡e ukloniti sve keÅ¡irane zahteve i odgovore iz Cache.db fajla.
2. Ako ne treba da koristite prednost kolaÄiÄ‡a, preporuÄuje se koriÅ¡Ä‡enje svojstva [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfiguracije URLSession, Å¡to Ä‡e onemoguÄ‡iti Äuvanje kolaÄiÄ‡a i keÅ¡iranje.

[Apple dokumentacija](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Objekat konfiguracije sesije ephemeral je sliÄan objektu konfiguracije sesije po podrazumevanim vrednostima (videti default), osim Å¡to odgovarajuÄ‡i objekat sesije ne Äuva keÅ¡ove, skladiÅ¡ta akreditacija ili bilo koje podatke vezane za sesiju na disku. Umesto toga, podaci vezani za sesiju se Äuvaju u RAM-u. Jedini put kada sesija ephemeral piÅ¡e podatke na disk je kada mu kaÅ¾ete da zapiÅ¡e sadrÅ¾aj URL-a u fajl.`
3. KeÅ¡iranje se takoÄ‘e moÅ¾e onemoguÄ‡iti postavljanjem Politike keÅ¡iranja na [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). To Ä‡e onemoguÄ‡iti Äuvanje keÅ¡a na bilo koji naÄin, bilo u memoriji ili na disku.

### Snimci

Kada pritisnete dugme za poÄetni ekran, iOS **pravi snimak trenutnog ekrana** kako bi mogao da izvrÅ¡i tranziciju ka aplikaciji na mnogo glaÄ‘i naÄin. MeÄ‘utim, ako su **osetljivi podaci** prisutni na trenutnom ekranu, biÄ‡e **saÄuvani** u **slici** (koja **traje** **preko** **ponovnog pokretanja**). Ovo su snimci do kojih moÅ¾ete pristupiti i dvostrukim dodirivanjem poÄetnog ekrana kako biste preÅ¡li izmeÄ‘u aplikacija.

Osoba koja napada, osim ako iPhone nije dÅ¾ejlbrejkan, mora imati **pristup** **odblokiranom** ureÄ‘aju da bi videla ove snimke ekrana. Podrazumevano, poslednji snimak se Äuva u sandbox-u aplikacije u `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` folderu (poverena raÄunara ne mogu pristupiti fajl sistemu od iOX 7.0).

Jedan naÄin da se spreÄi ovo neÅ¾eljeno ponaÅ¡anje je da se postavi prazan ekran ili uklone osetljivi podaci pre pravljenja snimka koriÅ¡Ä‡enjem funkcije `ApplicationDidEnterBackground()`.

U nastavku je prikazan primer metode za otklanjanje problema koji Ä‡e postaviti podrazumevani snimak.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Cilj-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Ovo postavlja pozadinsku sliku na `overlayImage.png` kada se aplikacija prebaci u pozadinu. To spreÄava curenje osetljivih podataka jer Ä‡e `overlayImage.png` uvek prekriti trenutni prikaz.

### Keychain

Za pristupanje i upravljanje iOS keychain-om, dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), pogodni za jailbroken ureÄ‘aje. Dodatno, [**Objection**](https://github.com/sensepost/objection) pruÅ¾a komandu `ios keychain dump` za sliÄne svrhe.

#### **ÄŒuvanje akreditacija**

Klasa **NSURLCredential** je idealna za Äuvanje osetljivih informacija direktno u keychain-u, zaobilazeÄ‡i potrebu za NSUserDefaults-om ili drugim omotaÄima. Za Äuvanje akreditacija nakon prijave, koristi se sledeÄ‡i Swift kod:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
## **PrilagoÄ‘ene tastature i keÅ¡ tastature**

Sa iOS 8.0 nadalje, korisnici mogu instalirati prilagoÄ‘ene ekstenzije tastature, koje se mogu upravljati pod **Postavke > OpÅ¡te > Tastatura > Tastature**. Iako ove tastature nude proÅ¡irene funkcionalnosti, one predstavljaju rizik od beleÅ¾enja pritisnutih tastera i slanja podataka eksternim serverima, iako korisnici dobijaju obaveÅ¡tenje o tastaturama koje zahtevaju pristup mreÅ¾i. Aplikacije mogu, i trebalo bi, ograniÄiti upotrebu prilagoÄ‘enih tastatura za unos osetljivih informacija.

**Preporuke za bezbednost:**

* PreporuÄuje se onemoguÄ‡avanje tastatura treÄ‡ih strana radi poboljÅ¡ane bezbednosti.
* Budite svesni funkcija automatske ispravke i automatskih predloga podrazumevane iOS tastature, koje mogu Äuvati osetljive informacije u keÅ¡ fajlovima smeÅ¡tenim u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keÅ¡ fajlovi treba redovno proveravati radi osetljivih podataka. PreporuÄuje se resetovanje reÄnika tastature putem **Postavke > OpÅ¡te > Resetovanje > Resetovanje reÄnika tastature** radi brisanja keÅ¡iranih podataka.
* Presretanje mreÅ¾nog saobraÄ‡aja moÅ¾e otkriti da li prilagoÄ‘ena tastatura daljinski prenosi pritisnute tastere.

### **Prevencija keÅ¡iranja polja za unos teksta**

Protokol [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi osobine za upravljanje automatskom ispravkom i bezbednim unosom teksta, Å¡to je kljuÄno za spreÄavanje keÅ¡iranja osetljivih informacija. Na primer, onemoguÄ‡avanje automatske ispravke i omoguÄ‡avanje bezbednog unosa teksta moÅ¾e se postiÄ‡i sa:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Dodatno, developeri treba da se pobrinu da tekstualna polja, posebno ona za unos osetljivih informacija poput lozinki i PIN-ova, onemoguÄ‡e keÅ¡iranje postavljanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logovi**

Debugiranje koda Äesto ukljuÄuje koriÅ¡Ä‡enje **logova**. Postoji rizik jer **logovi mogu sadrÅ¾ati osetljive informacije**. Ranije, u iOS 6 i starijim verzijama, logovi su bili dostupni svim aplikacijama, Å¡to je predstavljalo rizik od curenja osetljivih podataka. **Sada su aplikacije ograniÄene na pristup samo svojim logovima**.

Uprkos ovim ograniÄenjima, **napadaÄ sa fiziÄkim pristupom** otkljuÄanom ureÄ‘aju i dalje moÅ¾e iskoristiti ovo povezivanjem ureÄ‘aja sa raÄunarom i **Äitanjem logova**. VaÅ¾no je napomenuti da logovi ostaju na disku Äak i nakon deinstalacije aplikacije.

Da bi se smanjili rizici, preporuÄuje se **temeljno interagovanje sa aplikacijom**, istraÅ¾ujuÄ‡i sve njene funkcionalnosti i ulaze kako bi se osiguralo da se sluÄajno ne beleÅ¾e osetljive informacije.

Prilikom pregleda izvornog koda aplikacije radi potencijalnih curenja, potraÅ¾ite kako **unapred definisane** tako i **prilagoÄ‘ene izjave za logovanje** koristeÄ‡i kljuÄne reÄi poput `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugraÄ‘ene funkcije, i bilo kakve pomenute `Logging` ili `Logfile` za prilagoÄ‘ene implementacije.

### **Pratite Logove Sistemskog Sistem**

Aplikacije beleÅ¾e razliÄite informacije koje mogu biti osetljive. Za praÄ‡enje ovih logova, alati i komande poput:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Su korisne. Dodatno, **Xcode** pruÅ¾a naÄin za prikupljanje konzolnih zapisa:

1. Otvorite Xcode.
2. PoveÅ¾ite iOS ureÄ‘aj.
3. Idite na **Prozor** -> **UreÄ‘aji i Simulatori**.
4. Izaberite svoj ureÄ‘aj.
5. Pokrenite problem koji istraÅ¾ujete.
6. Koristite dugme **Otvori konzolu** da biste pregledali zapise u novom prozoru.

Za naprednije beleÅ¾enje, povezivanje sa ljuskom ureÄ‘aja i koriÅ¡Ä‡enje **socat**-a moÅ¾e omoguÄ‡iti praÄ‡enje logova u realnom vremenu:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
### BeleÅ¡ke

**Automatske funkcije za bekapovanje** su integrisane u iOS, olakÅ¡avajuÄ‡i kreiranje kopija podataka ureÄ‘aja putem iTunes-a (do macOS Catalina), Finder-a (od macOS Catalina nadalje) ili iCloud-a. Ovi bekapovi obuhvataju skoro sve podatke ureÄ‘aja, iskljuÄujuÄ‡i visoko osetljive elemente poput detalja Apple Pay-a i konfiguracija Touch ID-a.

### Bezbednosni rizici

UkljuÄivanje **instaliranih aplikacija i njihovih podataka** u bekapove postavlja pitanje potencijalnog **curenja podataka** i rizika da **modifikacije bekapova mogu promeniti funkcionalnost aplikacija**. PreporuÄuje se **ne Äuvati osetljive informacije u plaintext formatu** unutar direktorijuma bilo koje aplikacije ili njenih poddirektorijuma kako bi se umanjili ovi rizici.

### IskljuÄivanje Fajlova iz Bekapova

Fajlovi u `Documents/` i `Library/Application Support/` se automatski bekapuju. Razvojni programeri mogu iskljuÄiti odreÄ‘ene fajlove ili direktorijume iz bekapova koristeÄ‡i `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je kljuÄna za zaÅ¡titu osetljivih podataka od ukljuÄivanja u bekapove.

### Testiranje Ranjivosti

Da biste procenili bezbednost bekapova aplikacije, poÄnite sa **kreiranjem bekapa** koristeÄ‡i Finder, a zatim ga locirajte koristeÄ‡i smernice iz [zvaniÄne dokumentacije Apple-a](https://support.apple.com/en-us/HT204215). Analizirajte bekap radi osetljivih podataka ili konfiguracija koje bi mogle biti promenjene da bi uticale na ponaÅ¡anje aplikacije.

Osetljive informacije mogu se pronaÄ‡i koriÅ¡Ä‡enjem alata komandne linije ili aplikacija poput [iMazing](https://imazing.com). Za enkriptovane bekapove, prisustvo enkripcije se moÅ¾e potvrditi proverom kljuÄa "IsEncrypted" u fajlu "Manifest.plist" na korenu bekapova.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Za rukovanje enkriptovanim rezervnim kopijama, Python skripte dostupne u [DinoSec-ovom GitHub repozitorijumu](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), poput **backup\_tool.py** i **backup\_passwd.py**, mogu biti korisne, iako potencijalno zahtevaju prilagoÄ‘avanje za kompatibilnost sa najnovijim verzijama iTunes/Finder-a. [**iOSbackup** alat](https://pypi.org/project/iOSbackup/) je joÅ¡ jedna opcija za pristupanje fajlovima unutar zaÅ¡tiÄ‡enih lozinkom rezervnih kopija.

### Modifikovanje PonaÅ¡anja Aplikacije

Primer modifikovanja ponaÅ¡anja aplikacije putem modifikacija rezervne kopije je prikazan u [Bither bitcoin novÄanik aplikaciji](https://github.com/bither/bither-ios), gde se UI zakljuÄavanje PIN-a Äuva unutar `net.bither.plist` pod kljuÄem **pin\_code**. Uklanjanje ovog kljuÄa iz plist datoteke i vraÄ‡anje rezervne kopije uklanja zahtev za PIN, pruÅ¾ajuÄ‡i neograniÄen pristup.

## Rezime Testiranja Memorije za Osetljive Podatke

Kada se bavite osetljivim informacijama koje su smeÅ¡tene u memoriji aplikacije, kljuÄno je ograniÄiti vreme izlaganja ovih podataka. Postoje dva osnovna pristupa za istraÅ¾ivanje sadrÅ¾aja memorije: **kreiranje dump-a memorije** i **analiza memorije u realnom vremenu**. Oba metoda imaju svoje izazove, ukljuÄujuÄ‡i potencijal da se propuste kljuÄni podaci tokom procesa dump-a ili analize.

## **Dobijanje i Analiza Dump-a Memorije**

Za jailbroken i ne-jailbroken ureÄ‘aje, alati poput [objection](https://github.com/sensepost/objection) i [Fridump](https://github.com/Nightbringer21/fridump) omoguÄ‡avaju dump-ovanje memorije procesa aplikacije. Nakon Å¡to je dump-ovana, analiza ovih podataka zahteva razliÄite alate, zavisno od prirode informacija koje traÅ¾ite.

Za izvlaÄenje stringova iz dump-a memorije, mogu se koristiti komande poput `strings` ili `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Za detaljniju analizu, ukljuÄujuÄ‡i pretragu specifiÄnih tipova podataka ili obrazaca, **radare2** nudi obimne moguÄ‡nosti pretrage:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analiza memorije u toku izvrÅ¡avanja**

**r2frida** pruÅ¾a moÄ‡nu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za memorijskim ispuÅ¡tanjem. Ovaj alat omoguÄ‡ava izvrÅ¡avanje pretraga direktno na memoriji aplikacije koja se izvrÅ¡ava:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Slomljena Kriptografija

### LoÅ¡i Procesi Upravljanja KljuÄevima

Neki programeri Äuvaju osetljive podatke u lokalnom skladiÅ¡tu i Å¡ifriraju ih kljuÄem koji je unapred definisan/predvidljiv u kodu. Ovo ne bi trebalo raditi jer neko preokretanje moÅ¾e omoguÄ‡iti napadaÄima da izvuku poverljive informacije.

### KoriÅ¡Ä‡enje Nesigurnih i/ili Zastarelih Algoritama

Programeri ne bi trebalo da koriste **zastarele algoritme** za obavljanje **provera** autorizacije, **Äuvanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **heÅ¡evi** koriste za Äuvanje lozinki na primer, trebalo bi koristiti heÅ¡eve otporne na napade brute-force zajedno sa solju.

### Provera

Glavne provere koje treba obaviti su da li moÅ¾ete pronaÄ‡i **unapred definisane** lozinke/tajne u kodu, ili da li su te lozinke **predvidljive**, i da li kod koristi neku vrstu **slabe** **kriptografske** algoritme.

Zanimljivo je znati da moÅ¾ete **nadgledati** neke **kripto** **biblioteke** automatski koristeÄ‡i **objection** sa:
```swift
ios monitor crypt
```
Za **viÅ¡e informacija** o iOS kriptografskim API-ima i bibliotekama posetite [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna Autentikacija

**Lokalna autentikacija** igra kljuÄnu ulogu, posebno kada je u pitanju obezbeÄ‘ivanje pristupa na udaljenom krajnjem taÄkom putem kriptografskih metoda. SuÅ¡tina ovde je da bez pravilne implementacije, mehanizmi lokalne autentikacije mogu biti zaobiÄ‘eni.

Apple-ov [**Lokalni autentikacioni okvir**](https://developer.apple.com/documentation/localauthentication) i [**kljuÄnik**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pruÅ¾aju snaÅ¾ne API-je za programere kako bi olakÅ¡ali dijaloge autentikacije korisnika i sigurno rukovali tajnim podacima, redom. Secure Enclave obezbeÄ‘uje ID otiska prsta za Touch ID, dok se Face ID oslanja na prepoznavanje lica bez ugroÅ¾avanja biometrijskih podataka.

Da bi integrisali Touch ID/Face ID, programeri imaju dva API izbora:

* **`LocalAuthentication.framework`** za autentikaciju korisnika na visokom nivou bez pristupa biometrijskim podacima.
* **`Security.framework`** za pristup uslugama kljuÄnika na niÅ¾em nivou, obezbeÄ‘ujuÄ‡i tajne podatke biometrijskom autentikacijom. RazliÄiti [omotaÄi otvorenog koda](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakÅ¡avaju pristup kljuÄniku.

{% hint style="opasnost" %}
MeÄ‘utim, kako `LocalAuthentication.framework` tako i `Security.framework` predstavljaju ranjivosti, jer uglavnom vraÄ‡aju boolean vrednosti bez slanja podataka za autentikacione procese, ÄineÄ‡i ih podloÅ¾nim zaobilaÅ¾enju (videti [Ne dodiruj me na taj naÄin, od strane Davida Lindnera i drugih](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementacija Lokalne Autentikacije

Da bi korisnike uputili na autentikaciju, programeri treba da koriste metodu **`evaluatePolicy`** unutar klase **`LAContext`**, birajuÄ‡i izmeÄ‘u:

* **`deviceOwnerAuthentication`**: TraÅ¾i Touch ID ili Å¡ifru ureÄ‘aja, neuspeÅ¡no ako nijedno nije omoguÄ‡eno.
* **`deviceOwnerAuthenticationWithBiometrics`**: IskljuÄivo traÅ¾i Touch ID.

UspeÅ¡na autentikacija se oznaÄava boolean vrednoÅ¡Ä‡u koja se vraÄ‡a iz **`evaluatePolicy`**, istiÄuÄ‡i potencijalnu sigurnosnu manu.

### Lokalna Autentikacija koriÅ¡Ä‡enjem KljuÄnika

Implementacija **lokalne autentikacije** u iOS aplikacijama ukljuÄuje koriÅ¡Ä‡enje **kljuÄnik API-ja** za sigurno Äuvanje tajnih podataka kao Å¡to su autentikacioni tokeni. Ovaj proces osigurava da podaci mogu biti pristupljeni samo od strane korisnika, koriÅ¡Ä‡enjem njihove Å¡ifre ureÄ‘aja ili biometrijske autentikacije poput Touch ID-a.

KljuÄnik nudi moguÄ‡nost postavljanja stavki sa atributom `SecAccessControl`, koji ograniÄava pristup stavci dok korisnik uspeÅ¡no autentikuje putem Touch ID-a ili Å¡ifre ureÄ‘aja. Ova funkcija je kljuÄna za unapreÄ‘enje sigurnosti.

Ispod su primeri koda u Swift-u i Objective-C koji demonstriraju kako saÄuvati i povratiti string u/iz kljuÄnika, koristeÄ‡i ove sigurnosne funkcije. Primeri posebno pokazuju kako postaviti kontrolu pristupa da zahteva autentikaciju putem Touch ID-a i osigura da su podaci dostupni samo na ureÄ‘aju na kojem su postavljeni, pod uslovom da je konfigurisana Å¡ifra ureÄ‘aja.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

### Objective-C

Objective-C je stariji jezik koji se koristi za razvoj iOS aplikacija. Iako je Swift postao glavni jezik za razvoj aplikacija za iOS, joÅ¡ uvek moÅ¾ete naiÄ‡i na Objective-C kod prilikom pentestiranja iOS aplikacija. Evo nekoliko kljuÄnih taÄaka na koje treba obratiti paÅ¾nju prilikom pentestiranja Objective-C aplikacija:

- **Static Analysis (StatistiÄka analiza):** KoriÅ¡Ä‡enje alata poput `clang` i `scan-build` za pronalaÅ¾enje potencijalnih greÅ¡aka u kodu.
- **Dynamic Analysis (DinamiÄka analiza):** KoriÅ¡Ä‡enje alata poput `Cycript` za interaktivno testiranje i manipulaciju aplikacijom u pokretu.
- **Reverse Engineering (Reverse inÅ¾enjering):** KoriÅ¡Ä‡enje alata poput `Hopper` ili `IDA Pro` za analizu i razumevanje rada aplikacije.
- **Network Traffic Analysis (Analiza mreÅ¾nog saobraÄ‡aja):** PraÄ‡enje i analiza mreÅ¾nog saobraÄ‡aja koji generiÅ¡e aplikacija radi otkrivanja potencijalnih bezbednosnih propusta.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
Sada moÅ¾emo zatraÅ¾iti saÄuvanu stavku iz lanca kljuÄeva. Usluge lanca kljuÄeva Ä‡e prikazati dijalog za autentifikaciju korisniku i vratiti podatke ili nil u zavisnosti da li je pruÅ¾en odgovarajuÄ‡i otisak prsta ili ne.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

### Analiza statiÄkog koda

1. **KoriÅ¡Ä‡enje Clang Static Analyzer-a**

    Clang Static Analyzer je alat za analizu statiÄkog koda koji dolazi uz Xcode. MoÅ¾e se koristiti za otkrivanje potencijalnih greÅ¡aka u kodu, poput curenja memorije, neinicijalizovanih promenljivih, itd.

    Za pokretanje Clang Static Analyzer-a, otvorite Terminal i unesite sledeÄ‡u komandu:

    ```bash
    scan-build xcodebuild -configuration Debug
    ```

2. **KoriÅ¡Ä‡enje LLVM Analyzer-a**

    LLVM Analyzer je joÅ¡ jedan alat za analizu statiÄkog koda koji moÅ¾e otkriti potencijalne greÅ¡ke u kodu. MoÅ¾e se koristiti zajedno sa Clang Static Analyzer-om radi dodatne analize.

    Za pokretanje LLVM Analyzer-a, otvorite Terminal i unesite sledeÄ‡u komandu:

    ```bash
    scan-build -o /tmp/llvm xcodebuild -configuration Debug
    ```

3. **KoriÅ¡Ä‡enje OCLint-a**

    OCLint je alat za statiÄku analizu koda koji se moÅ¾e koristiti za otkrivanje greÅ¡aka, loÅ¡ih praksi i nepoÅ¾eljnog koda. MoÅ¾e se koristiti za poboljÅ¡anje kvaliteta koda i otkrivanje potencijalnih problema.

    Za pokretanje OCLint-a, otvorite Terminal i unesite sledeÄ‡u komandu:

    ```bash
    oclint-json-compilation-database -- -report-type pmd
    ```

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Otkrivanje

KoriÅ¡Ä‡enje okvira u aplikaciji takoÄ‘e moÅ¾e biti otkriveno analiziranjem liste deljenih dinamiÄkih biblioteka aplikacije. To se moÅ¾e uraditi koriÅ¡Ä‡enjem `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ako se koristi `LocalAuthentication.framework` u aplikaciji, izlaz Ä‡e sadrÅ¾ati obe sledeÄ‡e linije (imajte na umu da `LocalAuthentication.framework` koristi `Security.framework` ispod haube):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ako se koristi `Security.framework`, prikazan Ä‡e biti samo drugi.

### Bypass okvira za lokalnu autentikaciju

#### **Prigovor**

Putem **Objection Biometrics Bypass**, koji se nalazi na [ovoj GitHub stranici](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za prevazilaÅ¾enje mehanizma **LocalAuthentication**. SrÅ¾ ovog pristupa ukljuÄuje koriÅ¡Ä‡enje **Fride** za manipulaciju funkcije `evaluatePolicy`, osiguravajuÄ‡i da uvek daje rezultat `True`, bez obzira na stvarni uspeh autentikacije. Ovo je posebno korisno za zaobilaÅ¾enje neispravnih biometrijskih autentikacionih procesa.

Za aktiviranje ovog zaobilaska, koristi se sledeÄ‡a komanda:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ova komanda pokreÄ‡e sekvencu u kojoj Objection registruje zadatak koji efikasno menja ishod provere `evaluatePolicy` na `True`.

#### Frida

Primer koriÅ¡Ä‡enja **`evaluatePolicy`** iz aplikacije [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Za postizanje **bypass**-a lokalne autentikacije, napisan je Frida skript. Ova skripta cilja na proveru **evaluatePolicy**, presreÄ‡uÄ‡i njen povratni poziv kako bi se osiguralo da vraÄ‡a **success=1**. Menjanjem ponaÅ¡anja povratnog poziva, provera autentikacije efikasno se zaobilazi.

Skripta ispod je ubaÄena kako bi se izmenio rezultat metode **evaluatePolicy**. Menja rezultat povratnog poziva kako bi uvek pokazivao uspeh.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Da biste ubacili Frida skriptu i zaobiÅ¡li biometrijsku autentikaciju, koristi se sledeÄ‡a komanda:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Otkrivanje Osetljive Funkcionalnosti Putem IPC

### PrilagoÄ‘eni URI rukovaoci / Duboki linkovi / PrilagoÄ‘ene Å¡eme

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Univerzalni Linkovi

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Deljenje UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App Ekstenzije

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Veb PregledaÄi

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serijalizacija i Kodiranje

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Komunikacija putem MreÅ¾e

VaÅ¾no je proveriti da li se komunikacija odvija **bez enkripcije** i takoÄ‘e da li aplikacija pravilno **validira TLS sertifikat** servera.\
Da biste proverili ovakve probleme, moÅ¾ete koristiti proxy poput **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Provera Hostname-a

Jedan uobiÄajeni problem prilikom validacije TLS sertifikata je provera da li je sertifikat potpisan od strane **pouzdanog** **CA**, ali **ne proverava** da li je **hostname** sertifikata hostname koji se pristupa.\
Da biste proverili ovaj problem koristeÄ‡i Burp, nakon Å¡to poverite Burp CA na iPhone-u, moÅ¾ete **kreirati novi sertifikat sa Burp-om za drugi hostname** i koristiti ga. Ako aplikacija i dalje radi, onda je neÅ¡to ranjivo.

### Pinovanje Sertifikata

Ako aplikacija pravilno koristi SSL Pinning, tada Ä‡e aplikacija raditi samo ako je sertifikat onaj koji se oÄekuje. Prilikom testiranja aplikacije **ovo moÅ¾e biti problem jer Ä‡e Burp posluÅ¾iti svoj sertifikat.**\
Da biste zaobiÅ¡li ovu zaÅ¡titu unutar jailbroken ureÄ‘aja, moÅ¾ete instalirati aplikaciju [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ili instalirati [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

TakoÄ‘e moÅ¾ete koristiti `ios sslpinning disable` iz **objection-a**

## Razno

* U **`/System/Library`** moÅ¾ete pronaÄ‡i okvire instalirane u telefonu koje koriste sistemski programi
* Aplikacije instalirane od strane korisnika iz App Store-a nalaze se unutar **`/User/Applications`**
* A **`/User/Library`** sadrÅ¾i podatke saÄuvane od strane aplikacija na nivou korisnika
* MoÅ¾ete pristupiti **`/User/Library/Notes/notes.sqlite`** da proÄitate beleÅ¡ke saÄuvane unutar aplikacije.
* Unutar fascikle instalirane aplikacije (**`/User/Applications/<APP ID>/`**) moÅ¾ete pronaÄ‡i neke zanimljive datoteke:
  * **`iTunesArtwork`**: Ikona koriÅ¡Ä‡ena od strane aplikacije
  * **`iTunesMetadata.plist`**: Informacije o aplikaciji koriÅ¡Ä‡ene u App Store-u
  * **`/Library/*`**: SadrÅ¾i postavke i keÅ¡. U **`/Library/Cache/Snapshots/*`** moÅ¾ete pronaÄ‡i snimak izvrÅ¡en aplikaciji pre nego Å¡to je poslata u pozadinu.

### VruÄ‡e Popravljanje/AÅ¾uriranje

Razvojni timovi mogu daljinski **popraviti sve instalacije svoje aplikacije odmah** bez potrebe da ponovo podnose aplikaciju App Store-u i Äekaju odobrenje.\
Za tu svrhu se obiÄno koristi [**JSPatch**](https://github.com/bang590/JSPatch)**.** Ali postoje i druge opcije poput [Siren](https://github.com/ArtSabintsev/Siren) i [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Ovo je opasan mehanizam koji bi mogao biti zloupotrebljen od strane zlonamernih SDK-ova, stoga se preporuÄuje proveriti koji metod se koristi za automatsko aÅ¾uriranje (ako postoji) i testirati ga.** MoÅ¾ete pokuÅ¡ati da preuzmete prethodnu verziju aplikacije u tu svrhu.

### TreÄ‡e Strane

ZnaÄajan izazov sa **SDK-ovima treÄ‡ih strana** je **nedostatak granularne kontrole** nad njihovim funkcionalnostima. Razvojni timovi se suoÄavaju sa izborom: ili integriÅ¡u SDK i prihvate sve njegove funkcije, ukljuÄujuÄ‡i potencijalne sigurnosne ranjivosti i probleme privatnosti, ili potpuno odustanu od njegovih prednosti. ÄŒesto, razvojni timovi nisu u moguÄ‡nosti da zakrpe ranjivosti unutar ovih SDK-ova sami. Å taviÅ¡e, kako SDK-ovi stiÄu poverenje u zajednici, neki od njih mogu poÄeti da sadrÅ¾e zlonamerni softver.

Usluge koje pruÅ¾aju SDK-ovi treÄ‡ih strana mogu ukljuÄivati praÄ‡enje ponaÅ¡anja korisnika, prikazivanje reklama ili poboljÅ¡anja korisniÄkog iskustva. MeÄ‘utim, ovo uvodi rizik jer razvojni timovi moÅ¾da nisu potpuno svesni koda koji se izvrÅ¡ava od strane ovih biblioteka, Å¡to moÅ¾e dovesti do potencijalnih rizika po privatnost i sigurnost. VaÅ¾no je ograniÄiti informacije koje se dele sa uslugama treÄ‡ih strana na ono Å¡to je neophodno i osigurati da osetljivi podaci nisu izloÅ¾eni.

Implementacija usluga treÄ‡ih strana obiÄno dolazi u dva oblika: samostalna biblioteka ili potpuni SDK. Da bi se zaÅ¡titila privatnost korisnika, svi podaci koji se dele sa ovim uslugama trebalo bi da budu **anonimizovani** kako bi se spreÄilo otkrivanje liÄno identifikacionih informacija (PII).

Da bi se identifikovale biblioteke koje aplikacija koristi, moÅ¾e se koristiti komanda **`otool`**. Ovaj alat treba pokrenuti protiv aplikacije i svake deljene biblioteke koje koristi kako bi se otkrile dodatne biblioteke.
```bash
otool -L <application_path>
```
## **Reference & Dodatni Resursi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS besplatni kurs ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
