# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks:

* Ako Å¾elite da vidite **oglaÅ¡avanje vaÅ¡e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Pogledajte [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnove iOS-a

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testno okruÅ¾enje

Na ovoj stranici moÅ¾ete pronaÄ‡i informacije o **iOS simulatoru**, **emulatorima** i **jailbreaking-u**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## PoÄetna analiza

### Osnovne operacije testiranja iOS-a

Tokom testiranja Ä‡e biti predloÅ¾ene **neke operacije** (povezivanje sa ureÄ‘ajem, Äitanje/pisanje/otpisivanje/preuzimanje fajlova, koriÅ¡Ä‡enje nekih alata...). Ako ne znate kako da izvrÅ¡ite neku od ovih radnji, **poÄnite Äitati stranicu**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Za sledeÄ‡e korake, **aplikacija treba biti instalirana** na ureÄ‘aju i veÄ‡ treba da ste dobili **IPA fajl** aplikacije.\
ProÄitajte stranicu [Osnovne operacije testiranja iOS-a](basic-ios-testing-operations.md) da biste nauÄili kako to uraditi.
{% endhint %}

### Osnovna statiÄka analiza

PreporuÄuje se koriÅ¡Ä‡enje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za automatsku statiÄku analizu IPA fajla.

Identifikacija **zaÅ¡tita koje su prisutne u binarnom fajlu**:

*   **PIE (Position Independent Executable)**: Kada je omoguÄ‡eno, aplikacija se uÄitava na nasumiÄnu memorijsku adresu svaki put kada se pokrene, Å¡to oteÅ¾ava predviÄ‘anje poÄetne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # Trebalo bi da sadrÅ¾i zastavicu PIE
```
*   **Stack Canaries**: Da bi se potvrdila celovitost steka, vrednost 'canary' se postavlja na stek pre poziva funkcije i ponovo se proverava nakon zavrÅ¡etka funkcije.

```bash
otool -I -v <app-binary> | grep stack_chk   # Trebalo bi da sadrÅ¾i simbole: stack_chk_guard i stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Da bi se spreÄile uobiÄajene greÅ¡ke korupcije memorije

```bash
otool -I -v <app-binary> | grep objc_release   # Trebalo bi da sadrÅ¾i simbol _objc_release
```
*   **Enkriptovani binarni fajl**: Binarni fajl treba biti enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid treba da bude 1
```

**Identifikacija osetljivih/nepouzdanih funkcija**

*   **Slabe heÅ¡ funkcije**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Na linux-u
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Nepouzdane sluÄajne funkcije**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Na linux-u
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Nepouzdana 'Malloc' funkcija**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_malloc"

# Na linux-u
grep -iER "_malloc"
```
*   **Nepouzdane i ranjive funkcije**

```bash
# Na iOS ureÄ‘aju
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Na linux-u
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Osnovna dinamiÄka analiza

Pogledajte dinamiÄku analizu koju [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) vrÅ¡i. Morate da se kretate kroz razliÄite prikaze i da s njima interagujete, ali Ä‡e se povezivati sa nekoliko klasa i obavljati druge radnje, a zatim Ä‡e pripremiti izveÅ¡taj kada zavrÅ¡ite.

### Lista instaliranih aplikacija

Koristite komandu `frida-ps -Uai` da biste odredili **identifikator paketa** instaliranih aplikacija:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Osnovno prebrojavanje i hakovanje

NauÄite kako da **prebrojite komponente aplikacije** i kako lako da **hakujete metode i klase** pomoÄ‡u objekcije:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Struktura IPA fajla

Struktura **IPA fajla** je suÅ¡tinski kao kod **zipovanog paketa**. Promenom ekstenzije u `.zip`, moÅ¾e se **dekompresovati** i otkriti njegov sadrÅ¾aj. U ovoj strukturi, **Bundle** predstavlja potpuno zapakovanu aplikaciju spremnu za instalaciju. Unutar nje, nalazi se direktorijum nazvan `<IME>.app`, koji sadrÅ¾i resurse aplikacije.

* **`Info.plist`**: Ovaj fajl sadrÅ¾i specifiÄne konfiguracione detalje aplikacije.
* **`_CodeSignature/`**: Ovaj direktorijum ukljuÄuje plist fajl koji sadrÅ¾i potpis, obezbeÄ‘ujuÄ‡i integritet svih fajlova u paketu.
* **`Assets.car`**: Kompresovani arhiv koji Äuva fajlove resursa kao Å¡to su ikone.
* **`Frameworks/`**: Ovaj folder sadrÅ¾i nativne biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
* **`PlugIns/`**: Ovde se mogu nalaziti proÅ¡irenja aplikacije, poznata kao `.appex` fajlovi, mada nisu uvek prisutni.
*Â [**`Core Data`**](https://developer.apple.com/documentation/coredata): Koristi se za Äuvanje trajnih podataka aplikacije za offline upotrebu, keÅ¡iranje privremenih podataka i dodavanje moguÄ‡nosti poniÅ¡tavanja u aplikaciji na jednom ureÄ‘aju. Da biste sinhronizovali podatke na viÅ¡e ureÄ‘aja u jednom iCloud nalogu, Core Data automatski reflektuje vaÅ¡u Å¡emu u CloudKit kontejneru.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Fajl `PkgInfo` je alternativni naÄin za specificiranje tipa i kreator koda vaÅ¡e aplikacije ili paketa.
* **en.lproj, fr.proj, Base.lproj**: Ovo su jeziÄki paketi koji sadrÅ¾e resurse za odreÄ‘ene jezike, i podrazumevani resurs u sluÄaju da jezik nije podrÅ¾an.
* **Bezbednost**: Direktorijum `_CodeSignature/` igra kljuÄnu ulogu u bezbednosti aplikacije tako Å¡to proverava integritet svih zapakovanih fajlova putem digitalnih potpisa.
* **Upravljanje resursima**: Fajl `Assets.car` koristi kompresiju kako bi efikasno upravljao grafiÄkim resursima, Å¡to je kljuÄno za optimizaciju performansi aplikacije i smanjenje njene ukupne veliÄine.
* **Framework-i i PlugIn-ovi**: Ovi direktorijumi naglaÅ¡avaju modularnost iOS aplikacija, omoguÄ‡avajuÄ‡i programerima da ukljuÄe ponovno upotrebljive biblioteke koda (`Frameworks/`) i proÅ¡ire funkcionalnost aplikacije (`PlugIns/`).
* **Lokalizacija**: Struktura podrÅ¾ava viÅ¡e jezika, olakÅ¡avajuÄ‡i globalno dostizanje aplikacije ukljuÄivanjem resursa za odreÄ‘ene jeziÄke pakete.

**Info.plist**

**Info.plist** sluÅ¾i kao osnova za iOS aplikacije, enkapsulirajuÄ‡i kljuÄne konfiguracione podatke u obliku **kljuÄ-vrednost** parova. Ovaj fajl je neophodan ne samo za aplikacije, veÄ‡ i za proÅ¡irenja aplikacija i framework-ove koji su zapakovani unutar njih. Struktura fajla moÅ¾e biti u XML ili binarnom formatu i sadrÅ¾i kljuÄne informacije koje se kreÄ‡u od dozvola aplikacije do konfiguracija bezbednosti. Za detaljnije istraÅ¾ivanje dostupnih kljuÄeva, moÅ¾ete se referisati na [**Apple Developer dokumentaciju**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Za one koji Å¾ele da rade sa ovim fajlom u pristupaÄnijem formatu, konverzija u XML format se moÅ¾e lako postiÄ‡i koriÅ¡Ä‡enjem `plutil` na macOS-u (dostupan nativno u verzijama 10.2 i novijim) ili `plistutil` na Linux-u. Komande za konverziju su sledeÄ‡e:

- **Za macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Za Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
MeÄ‘u mnoÅ¡tvom informacija koje **Info.plist** datoteka moÅ¾e otkriti, znaÄajni unosi ukljuÄuju nizove dozvola aplikacije (`UsageDescription`), prilagoÄ‘ene URL sheme (`CFBundleURLTypes`) i konfiguracije za sigurnost transporta aplikacije (`NSAppTransportSecurity`). Ovi unosi, zajedno sa drugima poput izvezenih/uvezenih prilagoÄ‘enih tipova dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaÄ‡i inspekcijom datoteke ili upotrebom jednostavne `grep` komande:
```bash
$ grep -i <keyword> Info.plist
```
**Putanje podataka**

U iOS okruÅ¾enju, direktorijumi su posebno namenjeni **sistemskim aplikacijama** i **korisniÄki instaliranim aplikacijama**. Sistemski aplikacije se nalaze u direktorijumu `/Applications`, dok se korisniÄki instalirane aplikacije smeÅ¡taju pod `/private/var/containers/`. Ove aplikacije su dodeljene jedinstveni identifikator poznat kao **128-bitni UUID**, Å¡to Äini zadatkom ruÄnog pronalaÅ¾enja foldera aplikacije izazovnim zbog nasumiÄnosti imena direktorijuma.

Da bi se olakÅ¡alo otkrivanje direktorijuma instalacije korisniÄki instalirane aplikacije, **objection alat** pruÅ¾a korisnu komandu, `env`. Ova komanda otkriva detaljne informacije o direktorijumu za aplikaciju u pitanju. U nastavku je prikazan primer kako koristiti ovu komandu:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativno, ime aplikacije moÅ¾e biti pretraÅ¾eno unutar `/private/var/containers` koristeÄ‡i `find` komandu:
```bash
find /private/var/containers -name "Progname*"
```
Komande poput `ps` i `lsof` takoÄ‘e mogu biti iskoriÅ¡Ä‡ene kako bi se identifikovali procesi aplikacije i izlistali otvoreni fajlovi, pruÅ¾ajuÄ‡i uvid u aktivne putanje direktorijuma aplikacije:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Direktorijum paketa:**

* **AppName.app**
* Ovo je paket aplikacije koji je vidljiv u IPA formatu, sadrÅ¾i osnovne podatke aplikacije, statiÄki sadrÅ¾aj kao i prevedeni binarni fajl aplikacije.
* Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu pisati u njega**.
* SadrÅ¾aj ovog direktorijuma **se ne bekapuje**.
* SadrÅ¾aj ovog foldera se koristi za **validaciju potpisa koda**.

**Direktorijum podataka:**

* **Documents/**
* SadrÅ¾i sve podatke koje generiÅ¡e korisnik. Kreiranje ovih podataka inicira sam korisnik aplikacije.
* Vidljiv korisnicima i **korisnici mogu pisati u njega**.
* SadrÅ¾aj ovog direktorijuma **se bekapuje**.
* Aplikacija moÅ¾e onemoguÄ‡iti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/**
* SadrÅ¾i sve **fajlove koji nisu specifiÄni za korisnika**, kao Å¡to su **keÅ¡ memorija**, **postavke**, **kolaÄiÄ‡i** i konfiguracioni fajlovi u obliku property liste (plist).
* iOS aplikacije obiÄno koriste poddirektorijume `Application Support` i `Caches`, ali aplikacija moÅ¾e kreirati i prilagoÄ‘ene poddirektorijume.
* **Library/Caches/**
* SadrÅ¾i **polu-persistentne keÅ¡irane fajlove**.
* Nevidljiv korisnicima i **korisnici ne mogu pisati u njega**.
* SadrÅ¾aj ovog direktorijuma **se ne bekapuje**.
* Operativni sistem moÅ¾e automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladiÅ¡tenje.
* **Library/Application Support/**
* SadrÅ¾i **persistentne fajlove** neophodne za pokretanje aplikacije.
* **Nevidljiv** korisnicima i korisnici ne mogu pisati u njega.
* SadrÅ¾aj ovog direktorijuma **se bekapuje**.
* Aplikacija moÅ¾e onemoguÄ‡iti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Koristi se za Äuvanje svojstava koja **mogu trajati Äak i nakon ponovnog pokretanja aplikacije**.
* Informacije se Äuvaju neÅ¡ifrovano unutar peska aplikacije u plist fajlu koji se zove \[BUNDLE\_ID].plist.
* Svi parovi kljuÄ/vrednost koji se Äuvaju koristeÄ‡i `NSUserDefaults` mogu se pronaÄ‡i u ovom fajlu.
* **tmp/**
* Koristite ovaj direktorijum za pisanje **privremenih fajlova** koji ne moraju trajati izmeÄ‘u pokretanja aplikacije.
* SadrÅ¾i ne-persistentne keÅ¡irane fajlove.
* **Nevidljiv** korisnicima.
* SadrÅ¾aj ovog direktorijuma se ne bekapuje.
* Operativni sistem moÅ¾e automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladiÅ¡tenje.

Pogledajmo detaljnije direktorijum aplikacije iGoat-Swift (.app) unutar direktorijuma Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binarno obrtanje

Unutar foldera `<ime-aplikacije>.app` pronaÄ‡i Ä‡ete binarnu datoteku nazvanu `<ime-aplikacije>`. Ovo je datoteka koja Ä‡e biti **izvrÅ¡ena**. MoÅ¾ete izvrÅ¡iti osnovnu inspekciju binarne datoteke pomoÄ‡u alata **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Proverite da li je aplikacija enkriptovana**

Proverite da li postoji bilo kakav izlaz za:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Razlaganje binarnog koda**

RazloÅ¾i tekstualnu sekciju:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Da biste odÅ¡tampali **Objective-C segment** uzorka aplikacije, moÅ¾ete koristiti:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Da biste dobili kompaktniji Objective-C kod, moÅ¾ete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
MeÄ‘utim, najbolje opcije za rastavljanje binarnog koda su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** uz pomoÄ‡ najnaprednijih alata zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## SkladiÅ¡tenje podataka

Da biste saznali kako iOS skladiÅ¡ti podatke na ureÄ‘aju, proÄitajte ovu stranicu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
SledeÄ‡a mesta za skladiÅ¡tenje informacija treba proveriti **odmah nakon instaliranja aplikacije**, **nakon provere svih funkcionalnosti** aplikacije i Äak nakon **odjavljivanja sa jednog korisnika i prijavljivanja na drugog**.\
Cilj je pronaÄ‡i **nezaÅ¡tiÄ‡ene osetljive informacije** aplikacije (lozinke, tokene), trenutnog korisnika i prethodno prijavljenih korisnika.
{% endhint %}

### Plist

**plist** fajlovi su strukturirani XML fajlovi koji **sadrÅ¾e parove kljuÄ-vrednost**. To je naÄin za skladiÅ¡tenje trajnih podataka, pa se ponekad moÅ¾e pronaÄ‡i **osetljive informacije u ovim fajlovima**. PreporuÄuje se provera ovih fajlova nakon instaliranja aplikacije i nakon intenzivnog koriÅ¡Ä‡enja kako bi se videlo da li su upisani novi podaci.

NajÄeÅ¡Ä‡i naÄin za trajno skladiÅ¡tenje podataka u plist fajlovima je kroz koriÅ¡Ä‡enje **NSUserDefaults**. Ovaj plist fajl se Äuva unutar aplikacije u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) pruÅ¾a programski interfejs za interakciju sa podrazumevanim sistemom. Podrazumevani sistem omoguÄ‡ava aplikaciji da prilagodi svoje ponaÅ¡anje prema **korisniÄkim preferencama**. Podaci saÄuvani pomoÄ‡u `NSUserDefaults` mogu se videti u paketu aplikacije. Ova klasa skladiÅ¡ti **podatke** u **plist** **fajl**, ali je namenjena za koriÅ¡Ä‡enje sa malim koliÄinama podataka.

Ovi podaci ne mogu se viÅ¡e direktno pristupiti putem pouzdanog raÄunara, ali se mogu pristupiti izvrÅ¡avanjem **rezervne kopije**.

MoÅ¾ete **izvuÄ‡i** saÄuvane informacije koristeÄ‡i **`NSUserDefaults`** pomoÄ‡u komande `ios nsuserdefaults get` u alatu objection.

Da biste pronaÅ¡li sve plist fajlove koje koristi aplikacija, moÅ¾ete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:
```bash
find ./ -name "*.plist"
```
Da biste konvertovali fajlove iz **XML ili binarnog (bplist)** formata u XML, dostupne su razliÄite metode u zavisnosti od vaÅ¡eg operativnog sistema:

**Za korisnike macOS-a:**
Koristite `plutil` komandu. To je ugraÄ‘eni alat u macOS-u (verzija 10.2+), dizajniran za tu svrhu:
```bash
$ plutil -convert xml1 Info.plist
```
**Za korisnike Linuxa:**
Prvo instalirajte `libplist-utils`, a zatim koristite `plistutil` da biste konvertovali vaÅ¡ fajl:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Unutar Objection sesije:**
Za analizu mobilnih aplikacija, odreÄ‘ena komanda vam omoguÄ‡ava da direktno konvertujete plist fajlove:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) je okvir za upravljanje slojem modela objekata u vaÅ¡oj aplikaciji. [Core Data moÅ¾e koristiti SQLite kao svoje trajno skladiÅ¡te](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam okvir nije baza podataka.\
CoreData ne Å¡ifrira podatke prema zadanim postavkama. MeÄ‘utim, dodatni sloj Å¡ifriranja moÅ¾e se dodati CoreData. Pogledajte [GitHub Repo](https://github.com/project-imas/encrypted-core-data) za viÅ¡e detalja.

Informacije o SQLite Core Data aplikacije moÅ¾ete pronaÄ‡i na putanji `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako moÅ¾ete otvoriti SQLite i pristupiti osjetljivim informacijama, onda ste pronaÅ¡li greÅ¡ku u konfiguraciji.**

{% code title="Kod iz iGoat-a" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je skladiÅ¡te kljuÄ/vrednost izgraÄ‘eno na vrhu SQLite-a.\
PoÅ¡to su Yap baze podataka sqlite baze podataka, moÅ¾ete ih pronaÄ‡i koristeÄ‡i prethodno navedenu komandu.

### Ostale SQLite baze podataka

ÄŒesto se deÅ¡ava da aplikacije kreiraju svoje sopstvene sqlite baze podataka. Mogu da **Äuvaju** **osetljive** **podatke** na njima i ostave ih neÅ¡ifrovane. Zbog toga je uvek interesantno proveriti svaku bazu podataka unutar direktorijuma aplikacije. Zato idite u direktorijum aplikacije gde se podaci Äuvaju (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time baze podataka

Razvojnim programerima je omoguÄ‡eno da **skladiÅ¡te i sinhronizuju podatke** unutar **NoSQL baze podataka u oblaku** putem Firebase Real-Time baza podataka. Podaci se Äuvaju u JSON formatu i sinhronizuju se u realnom vremenu sa svim povezanim klijentima.

Kako proveriti da li su Firebase baze podataka konfigurisane na pogreÅ¡an naÄin moÅ¾ete pronaÄ‡i ovde:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm baze podataka

[Realm Objective-C](https://realm.io/docs/objc/latest/) i [Realm Swift](https://realm.io/docs/swift/latest/) pruÅ¾aju moÄ‡nu alternativu za skladiÅ¡tenje podataka koju Apple ne pruÅ¾a. Podaci se podrazumevano **Äuvaju neÅ¡ifrovano**, a Å¡ifrovanje je dostupno putem odreÄ‘ene konfiguracije.

Baze podataka se nalaze na lokaciji: `/private/var/mobile/Containers/Data/Application/{APPID}`. Za istraÅ¾ivanje ovih fajlova, mogu se koristiti komande kao Å¡to su:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Za pregledanje ovih baza podataka preporuÄuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije unutar Realm baze podataka, moÅ¾e se koristiti sledeÄ‡i kod:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite baze podataka

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) je opisan kao **lagani** i **ugraÄ‘eni** baza podataka engine koji sledi **dokument-orientisani** (NoSQL) pristup. Dizajniran da bude prirodan za **iOS** i **macOS**, nudi moguÄ‡nost sinhronizacije podataka bez problema.

Da biste identifikovali potencijalne Couchbase baze podataka na ureÄ‘aju, treba pregledati sledeÄ‡i direktorijum:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### KolaÄiÄ‡i

iOS Äuva kolaÄiÄ‡e aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar svake fascikle aplikacije. MeÄ‘utim, programeri ponekad odluÄe da ih saÄuvaju u **keychain-u** jer se pomenuti **fajl sa kolaÄiÄ‡ima moÅ¾e pristupiti u rezervnim kopijama**.

Da biste pregledali fajl sa kolaÄiÄ‡ima, moÅ¾ete koristiti [**ovaj Python skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**TakoÄ‘e moÅ¾ete koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### KeÅ¡iranje

Podrazumevano, NSURLSession Äuva podatke, kao Å¡to su **HTTP zahtevi i odgovori u bazi podataka Cache.db**. Ova baza podataka moÅ¾e sadrÅ¾ati **osetljive podatke**, ako su tokeni, korisniÄka imena ili bilo koje druge osetljive informacije keÅ¡irane. Da biste pronaÅ¡li keÅ¡irane informacije, otvorite direktorijum podataka aplikacije (`/var/mobile/Containers/Data/Application/<UUID>`) i idite na `/Library/Caches/<Bundle Identifier>`. **WebKit keÅ¡iranje takoÄ‘e se Äuva u fajlu Cache.db**. **Objection** moÅ¾e otvoriti i interagovati sa bazom podataka pomoÄ‡u komande `sqlite connect Cache.db`, jer je to **obiÄna SQLite baza podataka**.

PreporuÄuje se **onemoguÄ‡avanje keÅ¡iranja ovih podataka**, jer mogu sadrÅ¾ati osetljive informacije u zahtevu ili odgovoru. SledeÄ‡a lista prikazuje razliÄite naÄine postizanja ovoga:

1. PreporuÄuje se uklanjanje keÅ¡iranih odgovora nakon odjavljivanja. To se moÅ¾e uraditi pomoÄ‡u metode koju je obezbedio Apple pod nazivom [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). MoÅ¾ete pozvati ovu metodu na sledeÄ‡i naÄin:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda Ä‡e ukloniti sve keÅ¡irane zahteve i odgovore iz fajla Cache.db.
2. Ako ne morate koristiti prednosti kolaÄiÄ‡a, preporuÄuje se koriÅ¡Ä‡enje [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfiguracionog svojstva URLSession, koje Ä‡e onemoguÄ‡iti Äuvanje kolaÄiÄ‡a i keÅ¡iranje.

[Apple dokumentacija](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Objekat konfiguracije privremene sesije sliÄan je objektu konfiguracije podrazumevane sesije (vidi podrazumevano), osim Å¡to odgovarajuÄ‡i objekat sesije ne Äuva keÅ¡ove, skladiÅ¡ta akreditacija ili bilo koje podatke vezane za sesiju na disku. Umesto toga, podaci vezani za sesiju se Äuvaju u RAM-u. Jedini put kada privremena sesija upisuje podatke na disk je kada joj kaÅ¾ete da upiÅ¡e sadrÅ¾aj URL-a u fajl.`
3. KeÅ¡iranje se takoÄ‘e moÅ¾e onemoguÄ‡iti postavljanjem politike keÅ¡iranja na [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). To Ä‡e onemoguÄ‡iti Äuvanje keÅ¡a na bilo koji naÄin, bilo u memoriji ili na disku.

### Snimci ekrana

Svaki put kada pritisnete dugme za poÄetni ekran, iOS **pravi snimak trenutnog ekrana** kako bi mogao da izvrÅ¡i prelazak na aplikaciju na mnogo glaÄ‘i naÄin. MeÄ‘utim, ako se **osetljivi podaci** nalaze na trenutnom ekranu, oni Ä‡e biti **saÄuvani** u **slici** (koja **preÅ¾ivljava** **ponovno pokretanje** ureÄ‘aja). Ovo su snimci ekrana do kojih moÅ¾ete pristupiti i dvostrukim dodirivanjem poÄetnog ekrana kako biste prebacili aplikacije.

Ako iPhone nije jailbroken, **napadaÄ** mora imati **pristup** **odblokiranom** ureÄ‘aju da bi video ove snimke ekrana. Podrazumevano, poslednji snimak se Äuva u sandboxu aplikacije u fascikli `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` (povereni raÄunari ne mogu pristupiti fajl sistemu od iOS 7.0).

Jedan naÄin da se spreÄi ovo neÅ¾eljeno ponaÅ¡anje je da se postavi prazan ekran ili ukloni osetljivi podaci pre snimanja snimka koriÅ¡Ä‡enjem funkcije `ApplicationDidEnterBackground()`.

Evo primera metode za ispravljanje koja Ä‡e postaviti podrazumevani snimak.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C je objektno orijentisani programski jezik koji se koristi za razvoj aplikacija za iOS operativni sistem. Ovaj jezik je nastao kao proÅ¡irenje jezika C i koristi se za pisanje aplikacija za iPhone, iPad i iPod Touch ureÄ‘aje.

Objective-C ima bogatu sintaksu koja omoguÄ‡ava programerima da kreiraju objekte, definiÅ¡u metode i koriste nasleÄ‘ivanje. Ovaj jezik takoÄ‘e podrÅ¾ava dinamiÄko povezivanje, Å¡to znaÄi da se metode mogu pozivati u toku izvrÅ¡avanja programa.

Kada se radi pentesting na iOS aplikacijama, vaÅ¾no je razumeti Objective-C jezik kako biste mogli da analizirate izvorni kod i identifikujete potencijalne ranjivosti. Ovaj jezik se Äesto koristi za implementaciju funkcionalnosti kao Å¡to su autentifikacija, enkripcija i komunikacija sa serverom.

U nastavku su navedene neke od osnovnih karakteristika Objective-C jezika:

- Objektno orijentisana paradigma: Objective-C je baziran na objektno orijentisanoj paradigmi, Å¡to znaÄi da se programiranje vrÅ¡i pomoÄ‡u objekata koji imaju svoje osobine i metode.
- NasleÄ‘ivanje: Objective-C podrÅ¾ava nasleÄ‘ivanje, Å¡to omoguÄ‡ava programerima da kreiraju hijerarhiju klasa i dele funkcionalnosti izmeÄ‘u njih.
- DinamiÄko povezivanje: Objective-C podrÅ¾ava dinamiÄko povezivanje, Å¡to znaÄi da se metode mogu pozivati u toku izvrÅ¡avanja programa.
- Poruke: Umesto poziva funkcija, u Objective-C jeziku se koriste poruke za komunikaciju izmeÄ‘u objekata.
- ARC (Automatsko upravljanje memorijom): Objective-C podrÅ¾ava ARC, Å¡to znaÄi da se automatski upravlja memorijom i programerima nije potrebno ruÄno oslobaÄ‘ati memoriju.

Razumevanje Objective-C jezika je kljuÄno za uspeÅ¡no pentesting iOS aplikacija. ProuÄavanje sintakse, koncepta i funkcionalnosti ovog jezika Ä‡e vam pomoÄ‡i da identifikujete ranjivosti i izvrÅ¡ite sigurnosne testove na iOS aplikacijama.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Ovo postavlja pozadinsku sliku na `overlayImage.png` kada se aplikacija prebaci u pozadinu. To spreÄava curenje osetljivih podataka jer Ä‡e `overlayImage.png` uvek prekriti trenutni prikaz.

### Keychain

Za pristupanje i upravljanje iOS keychain-om, dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), koji su pogodni za jailbroken ureÄ‘aje. Dodatno, [**Objection**](https://github.com/sensepost/objection) pruÅ¾a komandu `ios keychain dump` za sliÄne svrhe.

#### **ÄŒuvanje akreditiva**

Klasa **NSURLCredential** je idealna za Äuvanje osetljivih informacija direktno u keychain-u, zaobilazeÄ‡i potrebu za NSUserDefaults ili drugim omotaÄima. Za Äuvanje akreditiva nakon prijave, koristi se sledeÄ‡i Swift kod:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Da biste izvukli ove saÄuvane akreditive, koristi se Objection-ova komanda `ios nsurlcredentialstorage dump`.

## **PrilagoÄ‘ene tastature i keÅ¡ tastature**

Od iOS 8.0 nadalje, korisnici mogu instalirati prilagoÄ‘ene tastaturne ekstenzije, koje se mogu upravljati pod **PodeÅ¡avanja > OpÅ¡te > Tastatura > Tastature**. Iako ove tastature nude proÅ¡irene funkcionalnosti, predstavljaju rizik od beleÅ¾enja unosa tastature i slanja podataka na eksterne servere, iako korisnici dobijaju obaveÅ¡tenje o tastaturama koje zahtevaju pristup mreÅ¾i. Aplikacije mogu, i trebaju, ograniÄiti upotrebu prilagoÄ‘enih tastatura za unos osetljivih informacija.

**Preporuke za bezbednost:**
- PreporuÄuje se onemoguÄ‡avanje tastatura treÄ‡ih strana radi poboljÅ¡ane bezbednosti.
- Treba biti svestan funkcija automatske ispravke i automatskih predloga podrazumevane iOS tastature, koje mogu Äuvati osetljive informacije u keÅ¡ fajlovima koji se nalaze u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keÅ¡ fajlovi trebaju redovno biti proveravani radi osetljivih podataka. PreporuÄuje se resetovanje reÄnika tastature putem **PodeÅ¡avanja > OpÅ¡te > Resetuj > Resetuj reÄnik tastature** kako bi se oÄistili keÅ¡irani podaci.
- Presretanje mreÅ¾nog saobraÄ‡aja moÅ¾e otkriti da li prilagoÄ‘ena tastatura prenosi unose tastature na daljinu.

### **SprjeÄavanje keÅ¡iranja polja za tekst**

Protokol [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi osobine za upravljanje automatskom ispravkom i unosom sigurnog teksta, Å¡to je kljuÄno za spreÄavanje keÅ¡iranja osetljivih informacija. Na primer, onemoguÄ‡avanje automatske ispravke i omoguÄ‡avanje unosa sigurnog teksta moÅ¾e se postiÄ‡i sa:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Dodatno, programeri bi trebali osigurati da tekstualna polja, posebno ona za unos osetljivih informacija poput lozinki i PIN-ova, onemoguÄ‡e keÅ¡iranje postavljanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Zapisi**

Otklanjanje greÅ¡aka u kodu Äesto ukljuÄuje koriÅ¡Ä‡enje **zapisa**. Postoji rizik jer **zapisi mogu sadrÅ¾avati osetljive informacije**. Ranije, u iOS 6 i starijim verzijama, zapisi su bili dostupni svim aplikacijama, Å¡to je predstavljalo rizik od curenja osetljivih podataka. **Sada, aplikacije su ograniÄene da pristupaju samo svojim zapisima**.

Uprkos ovim ograniÄenjima, **napadaÄ sa fiziÄkim pristupom** otkljuÄanom ureÄ‘aju i dalje moÅ¾e iskoristiti ovo povezivanjem ureÄ‘aja sa raÄunarom i **Äitanjem zapisa**. VaÅ¾no je napomenuti da zapisi ostaju na disku Äak i nakon deinstalacije aplikacije.

Da bi se smanjili rizici, preporuÄuje se **temeljno interagovati sa aplikacijom**, istraÅ¾ujuÄ‡i sve njene funkcionalnosti i unose kako bi se osiguralo da se sluÄajno ne beleÅ¾e osetljive informacije.

Pregledanjem izvornog koda aplikacije u potrazi za potencijalnim curenjima, potrebno je traÅ¾iti kako **unapred definisane** tako i **prilagoÄ‘ene izjave za beleÅ¾enje** koristeÄ‡i kljuÄne reÄi kao Å¡to su `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugraÄ‘ene funkcije, kao i bilo kakve pomena `Logging` ili `Logfile` za prilagoÄ‘ene implementacije.

### **Pratiti sistemske zapise**

Aplikacije beleÅ¾e razliÄite informacije koje mogu biti osetljive. Za praÄ‡enje ovih zapisa, koriste se alati i komande poput:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
su korisniku. Dodatno, **Xcode** pruÅ¾a naÄin za prikupljanje konzolnih zapisa:

1. Otvorite Xcode.
2. PoveÅ¾ite iOS ureÄ‘aj.
3. Idite na **Window** -> **Devices and Simulators**.
4. Odaberite svoj ureÄ‘aj.
5. Pokrenite problem koji istraÅ¾ujete.
6. Koristite dugme **Open Console** da biste pregledali zapise u novom prozoru.

Za naprednije zapisivanje, povezivanje sa ljuskom ureÄ‘aja i koriÅ¡Ä‡enje **socat**-a moÅ¾e omoguÄ‡iti praÄ‡enje zapisa u realnom vremenu:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
PrateÄ‡i naredbe za posmatranje aktivnosti dnevnika, koje mogu biti neprocenjive za dijagnostikovanje problema ili identifikaciju potencijalnog curenja podataka u dnevnicima.


***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete tokove rada** koji se pokreÄ‡u najnaprednijim alatima zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Rezervne kopije

**Automatske funkcije rezervnog kopiranja** su integrisane u iOS, olakÅ¡avajuÄ‡i kreiranje kopija podataka ureÄ‘aja putem iTunes-a (do macOS Catalina), Finder-a (od macOS Catalina nadalje) ili iCloud-a. Ove rezervne kopije obuhvataju skoro sve podatke ureÄ‘aja, izuzev visoko osetljivih elemenata kao Å¡to su detalji Apple Pay-a i konfiguracije Touch ID-a.

### Bezbednosni rizici

UkljuÄivanje **instaliranih aplikacija i njihovih podataka** u rezervne kopije postavlja pitanje potencijalnog **curenja podataka** i rizika da **izmene rezervne kopije mogu promeniti funkcionalnost aplikacija**. PreporuÄuje se da se **ne Äuvaju osetljive informacije u tekstualnom formatu** unutar direktorijuma aplikacije ili njenih poddirektorijuma kako bi se umanjili ovi rizici.

### IskljuÄivanje fajlova iz rezervnih kopija

Podrazumevano se vrÅ¡i rezervno kopiranje fajlova u `Documents/` i `Library/Application Support/`. Razvojni programeri mogu iskljuÄiti odreÄ‘ene fajlove ili direktorijume iz rezervnih kopija koristeÄ‡i `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je kljuÄna za zaÅ¡titu osetljivih podataka od ukljuÄivanja u rezervne kopije.

### Testiranje ranjivosti

Da biste procenili sigurnost rezervne kopije aplikacije, prvo **kreirajte rezervnu kopiju** koristeÄ‡i Finder, a zatim je pronaÄ‘ite koristeÄ‡i uputstva iz [zvaniÄne dokumentacije Apple-a](https://support.apple.com/en-us/HT204215). Analizirajte rezervnu kopiju u potrazi za osetljivim podacima ili konfiguracijama koje bi mogle biti promenjene kako bi se uticalo na ponaÅ¡anje aplikacije.

Osetljive informacije mogu se pronaÄ‡i koriÅ¡Ä‡enjem alata komandne linije ili aplikacija poput [iMazing](https://imazing.com). Za Å¡ifrovane rezervne kopije, prisustvo Å¡ifrovanja se moÅ¾e potvrditi proverom kljuÄa "IsEncrypted" u fajlu "Manifest.plist" u korenu rezervne kopije.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Za rukovanje sa enkriptovanim rezervnim kopijama, Python skripte dostupne u [DinoSec-ovom GitHub repozitorijumu](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), poput **backup_tool.py** i **backup_passwd.py**, mogu biti korisne, iako potencijalno zahtevaju prilagoÄ‘avanje za kompatibilnost sa najnovijim verzijama iTunes/Finder-a. [**iOSbackup** alat](https://pypi.org/project/iOSbackup/) je joÅ¡ jedna opcija za pristupanje datotekama unutar zaÅ¡tiÄ‡enih rezervnih kopija.

### Modifikacija ponaÅ¡anja aplikacije

Primer izmene ponaÅ¡anja aplikacije putem modifikacija rezervne kopije je prikazan u [Bither bitcoin novÄanik aplikaciji](https://github.com/bither/bither-ios), gde se PIN za zakljuÄavanje korisniÄkog interfejsa Äuva unutar `net.bither.plist` pod kljuÄem **pin_code**. Uklanjanje ovog kljuÄa iz plist datoteke i vraÄ‡anje rezervne kopije uklanja zahtev za PIN-om, pruÅ¾ajuÄ‡i neograniÄen pristup.

## Rezime testiranja memorije za osetljive podatke

Kada se bavite osetljivim informacijama koje se Äuvaju u memoriji aplikacije, kljuÄno je ograniÄiti vreme izlaganja ovih podataka. Postoje dva osnovna pristupa istraÅ¾ivanju sadrÅ¾aja memorije: **kreiranje memorijskog ispisa** i **analiza memorije u realnom vremenu**. Oba metoda imaju svoje izazove, ukljuÄujuÄ‡i moguÄ‡nost propuÅ¡tanja kljuÄnih podataka tokom procesa ispisa ili analize.

## **Dobijanje i analiza memorijskog ispisa**

Za ureÄ‘aje sa i bez dÅ¾ailbrejka, alati poput [objection](https://github.com/sensepost/objection) i [Fridump](https://github.com/Nightbringer21/fridump) omoguÄ‡avaju ispisivanje memorije procesa aplikacije. Nakon Å¡to se ispise, za analizu ovih podataka su potrebni razni alati, u zavisnosti od prirode informacija koje traÅ¾ite.

Za izvlaÄenje nizova iz memorijskog ispisa, mogu se koristiti komande poput `strings` ili `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Za detaljniju analizu, ukljuÄujuÄ‡i pretragu odreÄ‘enih vrsta podataka ili uzoraka, **radare2** nudi Å¡iroke moguÄ‡nosti pretrage:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analiza memorije u toku izvrÅ¡avanja**

**r2frida** pruÅ¾a moÄ‡nu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za memorijalnim iskopom. Ovaj alat omoguÄ‡ava izvrÅ¡avanje pretraga direktno nad memorijom pokrenute aplikacije:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Slomljena kriptografija

### Slabi procesi upravljanja kljuÄevima

Neki programeri Äuvaju osetljive podatke u lokalnom skladiÅ¡tu i Å¡ifruju ih kljuÄem koji je unapred definisan/predvidljiv u kodu. Ovo ne bi trebalo da se radi jer neko ko vrÅ¡i reverzno inÅ¾enjering moÅ¾e da izvuÄe poverljive informacije.

### KoriÅ¡Ä‡enje nesigurnih i/ili zastarelih algoritama

Programeri ne bi trebalo da koriste **zastarele algoritme** za izvrÅ¡avanje **provera** autorizacije, **skladiÅ¡tenje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se koriste **heÅ¡evi** za skladiÅ¡tenje lozinki, na primer, treba koristiti heÅ¡eve koji su otporni na napade brute-force uz upotrebu soli.

### Provera

Glavne provere koje treba izvrÅ¡iti su da li moÅ¾ete pronaÄ‡i **unapred definisane** lozinke/tajne u kodu, ili da li su one **predvidljive**, i da li kod koristi neku vrstu **slabe** **kriptografije** algoritme.

Interesantno je znati da moÅ¾ete **automatski pratiti** neke **kripto** **biblioteke** koristeÄ‡i **objection** sa:
```swift
ios monitor crypt
```
Za **viÅ¡e informacija** o iOS kriptografskim API-ima i bibliotekama posetite [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna autentifikacija

**Lokalna autentifikacija** igra kljuÄnu ulogu, posebno kada je u pitanju zaÅ¡tita pristupa na udaljenom krajnjem taÄkom putem kriptografskih metoda. SuÅ¡tina ovde je da bez odgovarajuÄ‡e implementacije, mehanizmi lokalne autentifikacije mogu biti zaobiÄ‘eni.

Apple-ov **[Local Authentication framework](https://developer.apple.com/documentation/localauthentication)** i **[keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** pruÅ¾aju snaÅ¾ne API-je za razvojne programere kako bi olakÅ¡ali dijaloge autentifikacije korisnika i sigurno rukovali tajnim podacima, redom. Secure Enclave obezbeÄ‘uje sigurnost otiska prsta za Touch ID, dok se Face ID oslanja na prepoznavanje lica bez ugroÅ¾avanja biometrijskih podataka.

Da bi integrisali Touch ID/Face ID, programeri imaju dva izbora API-ja:
- **`LocalAuthentication.framework`** za autentifikaciju korisnika na visokom nivou bez pristupa biometrijskim podacima.
- **`Security.framework`** za pristup uslugama keÅ¡a na niÅ¾em nivou, obezbeÄ‘ujuÄ‡i tajne podatke biometrijskom autentifikacijom. Razni [open-source omotaÄi](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakÅ¡avaju pristup keÅ¡u.

{% hint style="danger" %}
MeÄ‘utim, kako `LocalAuthentication.framework` tako i `Security.framework` predstavljaju ranjivosti, jer uglavnom vraÄ‡aju boolean vrednosti bez prenosa podataka za autentifikacione procese, Äime su podloÅ¾ni zaobilaÅ¾enju (videti [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementacija lokalne autentifikacije

Da bi korisnike upitali za autentifikaciju, programeri treba da koriste metodu **`evaluatePolicy`** unutar klase **`LAContext`**, birajuÄ‡i izmeÄ‘u:
- **`deviceOwnerAuthentication`**: Upita za Touch ID ili Å¡ifru ureÄ‘aja, neuspevajuÄ‡i ako nijedno nije omoguÄ‡eno.
- **`deviceOwnerAuthenticationWithBiometrics`**: IskljuÄivo upita za Touch ID.

UspeÅ¡na autentifikacija se oznaÄava boolean vrednoÅ¡Ä‡u koju vraÄ‡a **`evaluatePolicy`**, ukazujuÄ‡i na potencijalnu sigurnosnu manu.

### Lokalna autentifikacija koriÅ¡Ä‡enjem keÅ¡a

Implementacija **lokane autentifikacije** u iOS aplikacijama ukljuÄuje koriÅ¡Ä‡enje **keÅ¡ API-ja** za sigurno Äuvanje tajnih podataka kao Å¡to su autentifikacioni tokeni. Ovaj proces osigurava da podaci mogu biti pristupljeni samo od strane korisnika, koristeÄ‡i njihovu Å¡ifru ureÄ‘aja ili biometrijsku autentifikaciju poput Touch ID-a.

KeÅ¡ nudi moguÄ‡nost postavljanja stavki sa atributom `SecAccessControl`, koji ograniÄava pristup stavci sve dok korisnik uspeÅ¡no autentifikuje putem Touch ID-a ili Å¡ifre ureÄ‘aja. Ova funkcija je kljuÄna za poboljÅ¡anje sigurnosti.

U nastavku su prikazani primeri koda u Swift-u i Objective-C-u koji demonstriraju kako saÄuvati i dobiti string iz keÅ¡a, koristeÄ‡i ove sigurnosne funkcije. Primeri posebno pokazuju kako postaviti kontrolu pristupa koja zahteva autentifikaciju putem Touch ID-a i osigurava da su podaci dostupni samo na ureÄ‘aju na kojem su postavljeni, pod uslovom da je konfigurisana Å¡ifra ureÄ‘aja.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Sada moÅ¾emo zatraÅ¾iti saÄuvanu stavku iz kljuÄnog lanca. Usluge kljuÄnog lanca Ä‡e prikazati dijalog za autentifikaciju korisniku i vratiti podatke ili nil u zavisnosti od toga da li je pruÅ¾en odgovarajuÄ‡i otisak prsta ili ne.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Otkrivanje

KoriÅ¡Ä‡enje okvira u aplikaciji takoÄ‘e moÅ¾e biti otkriveno analizom liste deljenih dinamiÄkih biblioteka aplikacije. To se moÅ¾e uraditi koriÅ¡Ä‡enjem `otool` alata:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ako se koristi `LocalAuthentication.framework` u aplikaciji, izlaz Ä‡e sadrÅ¾avati oba sledeÄ‡a reda (zapamtite da `LocalAuthentication.framework` koristi `Security.framework` ispod haube):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ako se koristi `Security.framework`, prikazuje se samo drugi.

### ZaobilaÅ¾enje okvira za lokalnu autentifikaciju

#### **Objection**

Kroz **Objection Biometrics Bypass**, koji se nalazi na [ovoj GitHub stranici](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za prevazilaÅ¾enje mehanizma **LocalAuthentication**. SrÅ¾ ovog pristupa je koriÅ¡Ä‡enje **Fride** za manipulaciju funkcijom `evaluatePolicy`, osiguravajuÄ‡i da uvek daje rezultat `True`, bez obzira na stvarni uspeh autentifikacije. Ovo je posebno korisno za zaobilaÅ¾enje nedostataka biometrijskih autentifikacionih procesa.

Za aktiviranje ovog zaobilaÅ¾enja koristi se sledeÄ‡a komanda:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ova komanda pokreÄ‡e sekvencu u kojoj Objection registruje zadatak koji efektivno menja rezultat provere `evaluatePolicy` na `True`.

#### Frida

Primer koriÅ¡Ä‡enja **`evaluatePolicy`** iz aplikacije [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Da bi se postigao **bypass** lokalne autentifikacije, napisan je Frida skript. Ovaj skript cilja na proveru **evaluatePolicy**, presreÄ‡uÄ‡i njegov povratni poziv kako bi se osiguralo da uvek vraÄ‡a **success=1**. Menjanjem ponaÅ¡anja povratnog poziva, provera autentifikacije se efektivno zaobilazi.

Skript ispod se ubacuje kako bi se izmenio rezultat metode **evaluatePolicy**. Menja rezultat povratnog poziva kako bi uvek pokazivao uspeh.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Da biste ubacili Frida skriptu i zaobiÅ¡li biometrijsku autentifikaciju, koristi se sledeÄ‡a komanda:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Otkrivanje osetljive funkcionalnosti putem IPC-a

### PrilagoÄ‘eni URI rukovaoci / Duboki linkovi / PrilagoÄ‘ene Å¡eme

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Univerzalni linkovi

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Deljenje preko UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App ekstenzije

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serijalizacija i enkodiranje

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## MreÅ¾na komunikacija

VaÅ¾no je proveriti da se ne odvija nikakva komunikacija **bez enkripcije** i da aplikacija pravilno **proverava TLS sertifikat** servera.\
Da biste proverili ove vrste problema, moÅ¾ete koristiti proxy kao Å¡to je **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Provera imena hosta

ÄŒesto se javlja problem prilikom provere TLS sertifikata, gde se proverava da li je sertifikat potpisan od strane **pouzdane** **CA**, ali se **ne proverava** da li je **ime hosta** na sertifikatu ime hosta koje se pristupa.\
Da biste proverili ovaj problem koristeÄ‡i Burp, nakon Å¡to ste poverili Burp CA na iPhone-u, moÅ¾ete **kreirati novi sertifikat sa Burp-om za drugi naziv hosta** i koristiti ga. Ako aplikacija i dalje radi, onda je neÅ¡to ranjivo.

### Prikivanje sertifikata

Ako aplikacija pravilno koristi SSL Prikivanje, tada Ä‡e aplikacija raditi samo ako je sertifikat onaj koji se oÄekuje. Prilikom testiranja aplikacije, **ovo moÅ¾e biti problem jer Ä‡e Burp koristiti svoj sertifikat.**\
Da biste zaobiÅ¡li ovu zaÅ¡titu na jailbroken ureÄ‘aju, moÅ¾ete instalirati aplikaciju [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ili instalirati [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

TakoÄ‘e moÅ¾ete koristiti **objection's** `ios sslpinning disable`

## Razno

* U **`/System/Library`** moÅ¾ete pronaÄ‡i okvire instalirane na telefonu koje koriste sistemski programi
* Aplikacije koje je korisnik instalirao iz App Store-a nalaze se unutar **`/User/Applications`**
* A **`/User/Library`** sadrÅ¾i podatke koje je korisnik saÄuvao u aplikacijama na nivou korisnika
* MoÅ¾ete pristupiti **`/User/Library/Notes/notes.sqlite`** da biste proÄitali beleÅ¡ke saÄuvane u aplikaciji.
* Unutar fascikle instalirane aplikacije (**`/User/Applications/<APP ID>/`**) moÅ¾ete pronaÄ‡i neke zanimljive datoteke:
* **`iTunesArtwork`**: Ikona koju koristi aplikacija
* **`iTunesMetadata.plist`**: Informacije o aplikaciji koje se koriste u App Store-u
* **`/Library/*`**: SadrÅ¾i postavke i keÅ¡. U **`/Library/Cache/Snapshots/*`** moÅ¾ete pronaÄ‡i snimak koji je napravljen aplikaciji pre nego Å¡to je poslata u pozadinu.

### Hot Patching/Enforced Updateing

Razvojni programeri mogu daljinski **popraviti sve instalacije svoje aplikacije odmah** bez potrebe da ponovo podnesu aplikaciju App Store-u i Äekaju odobrenje.\
U tu svrhu se obiÄno koristi [**JSPatch**](https://github.com/bang590/JSPatch)**.** Ali postoje i druge opcije kao Å¡to su [Siren](https://github.com/ArtSabintsev/Siren) i [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Ovo je opasni mehanizam koji moÅ¾e biti zloupotrebljen od strane zlonamernih SDK-ova, stoga se preporuÄuje provera koje metode se koriste za automatsko aÅ¾uriranje (ako ih ima) i testiranje.** MoÅ¾ete pokuÅ¡ati preuzeti prethodnu verziju aplikacije u tu svrhu.

### TreÄ‡e strane

ZnaÄajan izazov sa **SDK-ovima treÄ‡ih strana** je **nedostatak granularne kontrole** nad njihovim funkcionalnostima. Razvojni programeri se suoÄavaju sa izborom: ili integriÅ¡u SDK i prihvataju sve njegove funkcije, ukljuÄujuÄ‡i potencijalne sigurnosne ranjivosti i probleme privatnosti, ili potpuno odustaju od njegovih prednosti. ÄŒesto, razvojni programeri nisu u moguÄ‡nosti da sami isprave ranjivosti unutar ovih SDK-ova. Osim toga, kako SDK-ovi stiÄu poverenje u zajednici, neki od njih mogu sadrÅ¾ati zlonamerni softver.

Usluge koje pruÅ¾aju SDK-ovi treÄ‡ih strana mogu ukljuÄivati praÄ‡enje ponaÅ¡anja korisnika, prikazivanje reklama ili poboljÅ¡anje korisniÄkog iskustva. MeÄ‘utim, to predstavlja rizik jer razvojni programeri moÅ¾da nisu potpuno svesni koda koji se izvrÅ¡ava u ovim bibliotekama, Å¡to moÅ¾e dovesti do potencijalnih problema sa privatnoÅ¡Ä‡u i sigurnoÅ¡Ä‡u. VaÅ¾no je ograniÄiti informacije koje se dele sa uslugama treÄ‡ih strana samo na ono Å¡to je neophodno i obezbediti da nijedan osetljivi podatak nije izloÅ¾en.

Implementacija usluga treÄ‡ih strana obiÄno dolazi u dva oblika: samostalna biblioteka ili potpuni SDK. Da bi se zaÅ¡titila privatnost korisnika, svi podaci koji se dele sa ovim uslugama trebaju biti **anonimizovani** kako bi se spreÄilo otkrivanje liÄno prepoznatljivih informacija (PII).

Da biste identifikovali biblioteke koje aplikacija koristi, moÅ¾ete koristiti komandu **`otool`**. Ovaj alat treba pokrenuti protiv aplikacije i svake deljene biblioteke koju koristi kako biste otkrili dodatne biblioteke.
```bash
otool -L <application_path>
```
## **Reference & Dodatni resursi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS besplatni kurs ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **oglaÅ¡avanje vaÅ¡e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
