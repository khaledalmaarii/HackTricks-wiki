```markdown
# S√©paration des privil√®ges et Sandbox

Les applications auxquelles l'utilisateur peut acc√©der s'ex√©cutent en tant qu'utilisateur **mobile** tandis que les processus syst√®me critiques s'ex√©cutent en tant que **root**.\
Cependant, le sandbox permet un meilleur contr√¥le sur les actions que les processus et les applications peuvent effectuer.

Par exemple, m√™me si deux processus s'ex√©cutent en tant que m√™me utilisateur (mobile), ils **ne sont pas autoris√©s √† acc√©der ou modifier les donn√©es de l'autre**.

Chaque application est install√©e sous **`private/var/mobile/Applications/{ID al√©atoire}`**\
Une fois install√©es, les applications ont un acc√®s en lecture limit√© √† certaines zones et fonctions du syst√®me (SMS, appel t√©l√©phonique...). Si une application souhaite acc√©der √† une **zone prot√©g√©e,** une **fen√™tre pop-up demandant la permission** appara√Æt.

# Protection des donn√©es

Les d√©veloppeurs d'applications peuvent tirer parti des API de _Protection des donn√©es_ d'iOS pour mettre en ≈ìuvre un **contr√¥le d'acc√®s granulaire** pour les donn√©es utilisateur stock√©es dans la m√©moire flash. Les API sont construites sur le dessus du **Secure Enclave Processor** (SEP). Le SEP est un coprocesseur qui fournit des **op√©rations cryptographiques pour la protection des donn√©es et la gestion des cl√©s**. Une cl√© mat√©rielle sp√©cifique √† l'appareil, l'**UID de l'appareil** (Identifiant Unique), est **int√©gr√©e dans l'enclave s√©curis√©e**, assurant l'int√©grit√© de la protection des donn√©es m√™me lorsque le noyau du syst√®me d'exploitation est compromis.

Lorsqu'un **fichier est cr√©√©** sur le disque, une nouvelle cl√© **AES 256 bits est g√©n√©r√©e** avec l'aide du g√©n√©rateur de nombres al√©atoires bas√© sur le mat√©riel de l'enclave s√©curis√©e. Le **contenu du fichier est ensuite chiffr√© avec la cl√© g√©n√©r√©e**. Ensuite, cette **cl√© est sauvegard√©e chiffr√©e avec une cl√© de classe** ainsi que **l'ID de classe,** avec **les deux donn√©es chiffr√©es par la cl√© du syst√®me,** √† l'int√©rieur des **m√©tadonn√©es** du fichier.

![](<../../.gitbook/assets/image (473).png>)

Pour d√©chiffrer le fichier, les **m√©tadonn√©es sont d√©chiffr√©es en utilisant la cl√© du syst√®me**. Ensuite, en **utilisant l'ID de classe** la **cl√© de classe est r√©cup√©r√©e** **pour d√©chiffrer la cl√© de fichier et d√©chiffrer le fichier.**

Les fichiers peuvent √™tre attribu√©s √† l'une des **quatre** **classes de protection** **diff√©rentes**, qui sont expliqu√©es plus en d√©tail dans le [Guide de s√©curit√© de la plateforme Apple](https://help.apple.com/pdf/security/en_US/apple-platform-security-guide.pdf) :

* **Protection compl√®te (NSFileProtectionComplete)** : Une cl√© d√©riv√©e du code d'acc√®s de l'utilisateur et de l'UID de l'appareil prot√®ge cette cl√© de classe. La cl√© d√©riv√©e est effac√©e de la m√©moire peu apr√®s que l'appareil est verrouill√©, rendant les donn√©es inaccessibles jusqu'√† ce que l'utilisateur d√©verrouille l'appareil.
* **Prot√©g√© sauf si ouvert (NSFileProtectionCompleteUnlessOpen)** : Cette classe de protection est similaire √† la Protection compl√®te, mais, si le fichier est ouvert lorsque d√©verrouill√©, l'application peut continuer √† acc√©der au fichier m√™me si l'utilisateur verrouille l'appareil. Cette classe de protection est utilis√©e lorsque, par exemple, une pi√®ce jointe de courrier est t√©l√©charg√©e en arri√®re-plan.
* **Prot√©g√© jusqu'√† la premi√®re authentification de l'utilisateur (NSFileProtectionCompleteUntilFirstUserAuthentication)** : Le fichier peut √™tre acc√©d√© d√®s que l'utilisateur d√©verrouille l'appareil pour la premi√®re fois apr√®s le d√©marrage. Il peut √™tre acc√©d√© m√™me si l'utilisateur verrouille par la suite l'appareil et la cl√© de classe n'est pas retir√©e de la m√©moire.
* **Aucune protection (NSFileProtectionNone)** : La cl√© pour cette classe de protection est prot√©g√©e uniquement avec l'UID. La cl√© de classe est stock√©e dans "Effaceable Storage", qui est une r√©gion de la m√©moire flash sur l'appareil iOS qui permet le stockage de petites quantit√©s de donn√©es. Cette classe de protection existe pour un effacement √† distance rapide (suppression imm√©diate de la cl√© de classe, ce qui rend les donn√©es inaccessibles).

Toutes les cl√©s de classe √† l'exception de `NSFileProtectionNone` sont chiffr√©es avec une cl√© d√©riv√©e de l'UID de l'appareil et du code d'acc√®s de l'utilisateur. En cons√©quence, le d√©chiffrement ne peut se produire que sur l'appareil lui-m√™me et n√©cessite le bon code d'acc√®s.

Depuis iOS 7, la classe de protection des donn√©es par d√©faut est "Prot√©g√© jusqu'√† la premi√®re authentification de l'utilisateur".

[**FileDP**](https://github.com/abjurato/FileDp-Source) est un programme que vous pouvez t√©l√©charger et utiliser √† l'int√©rieur de l'iPhone pour **inspecter la classe de protection des donn√©es** de chaque fichier.

## Le Keychain

Un keychain est un **conteneur chiffr√©** o√π chaque application peut **stocker** des morceaux d'**informations sensibles** et seule la m√™me application (ou les applications autoris√©es) peut r√©cup√©rer le contenu.\
iOS **g√©n√®re son propre mot de passe pour le keychain** et **stocke** une version **chiffr√©e** de cette cl√© dans l'appareil. Ce mot de passe est chiffr√© avec AES en utilisant une cl√© AES cr√©√©e par une fonction **PBKDF2** du **code d'acc√®s de l'utilisateur + sel** (le **UID de l'appareil 256 bits** **uniquement accessible** au chipset de l'enclave s√©curis√©e sur l'appareil). En raison de l'utilisation de cet UID de l'appareil comme sel, un appareil ne pourra pas d√©chiffrer le keychain d'un autre appareil m√™me en connaissant le code d'acc√®s des utilisateurs.

L'acc√®s au Keychain est g√©r√© par le daemon **`securityd`**, qui accorde l'acc√®s selon les droits `Keychain-access-groups`, `application-identifier` et `application-group` de l'application.

L'[API Keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html) comprend les op√©rations principales suivantes :

* `SecItemAdd`
* `SecItemUpdate`
* `SecItemCopyMatching`
* `SecItemDelete`

Les seules fa√ßons d'essayer de BF ce mot de passe est de dumper la cl√© chiffr√©e et de BF le code d'acc√®s + sel (la fonction **pbkdf2** utilise **au moins 10000 it√©rations**). Ou d'essayer de **BF √† l'int√©rieur de l'appareil** pour √©viter de BF le sel, cependant, l'enclave s√©curis√©e assure qu'il y a au moins un **d√©lai de 5 secondes entre 2 tentatives de mot de passe √©chou√©es**.

Vous pouvez configurer **la protection des donn√©es pour les √©l√©ments Keychain** en d√©finissant la cl√© `kSecAttrAccessible` dans l'appel √† `SecItemAdd` ou `SecItemUpdate`. Les valeurs d'accessibilit√© configurables suivantes pour kSecAttrAccessible sont les classes de protection des donn√©es Keychain :

* **`kSecAttrAccessibleAlways`** : Les donn√©es de l'√©l√©ment Keychain peuvent **toujours √™tre accessibles**, que l'appareil soit verrouill√© ou non.
* **`kSecAttrAccessibleAlwaysThisDeviceOnly`** : Les donn√©es de l'√©l√©ment Keychain peuvent **toujours √™tre accessibles**, que l'appareil soit verrouill√© ou non. Les donn√©es **ne seront pas incluses dans une sauvegarde iCloud** ou locale.
* **`kSecAttrAccessibleAfterFirstUnlock`** : Les donn√©es de l'√©l√©ment Keychain ne peuvent pas √™tre accessibles apr√®s un red√©marrage jusqu'√† ce que **l'appareil ait √©t√© d√©verrouill√© une fois** par l'utilisateur.
* **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`** : Les donn√©es de l'√©l√©ment Keychain ne peuvent pas √™tre accessibles apr√®s un red√©marrage jusqu'√† ce que **l'appareil ait √©t√© d√©verrouill√© une fois** par l'utilisateur. Les √©l√©ments avec cet attribut ne **migrent pas vers un nouvel appareil**. Ainsi, apr√®s la restauration √† partir d'une sauvegarde d'un autre appareil, ces √©l√©ments ne seront pas pr√©sents.
* **`kSecAttrAccessibleWhenUnlocked`** : Les donn√©es de l'√©l√©ment Keychain peuvent √™tre accessibles **uniquement lorsque l'appareil est d√©verrouill√©** par l'utilisateur.
* **`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`** : Les donn√©es de l'√©l√©ment Keychain peuvent √™tre accessibles **uniquement lorsque l'appareil est d√©verrouill√©** par l'utilisateur. Les donn√©es **ne seront pas incluses dans une sauvegarde iCloud ou locale**.
* **`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`** : Les donn√©es du Keychain peuvent √™tre accessibles **uniquement lorsque l'appareil est d√©verrouill√©**. Cette classe de protection est **disponible uniquement si un code d'acc√®s est d√©fini** sur l'appareil. Les donn√©es **ne seront pas incluses dans une sauvegarde iCloud ou locale**.

**`AccessControlFlags`** d√©finissent les m√©canismes avec lesquels les utilisateurs peuvent authentifier la cl√© (`SecAccessControlCreateFlags`) :

* **`kSecAccessControlDevicePasscode`** : Acc√©der √† l'√©l√©ment via un code d'acc√®s.
* **`kSecAccessControlBiometryAny`** : Acc√©der √† l'√©l√©ment via l'une des empreintes digitales enregistr√©es sur Touch ID. Ajouter ou supprimer une empreinte digitale n'invalidera pas l'√©l√©ment.
* **`kSecAccessControlBiometryCurrentSet`** : Acc√©der √† l'√©l√©ment via l'une des empreintes digitales enregistr√©es sur Touch ID. Ajouter ou supprimer une empreinte digitale _invalidera_ l'√©l√©ment.
* **`kSecAccessControlUserPresence`** : Acc√©der √† l'√©l√©ment via l'une des empreintes digitales enregistr√©es (en utilisant Touch ID) ou par d√©faut au code d'acc√®s.

Veuillez noter que les cl√©s s√©curis√©es par Touch ID (via `kSecAccessControlBiometryAny` ou `kSecAccessControlBiometryCurrentSet`) sont prot√©g√©es par l'Enclave s√©curis√©e : le Keychain d√©tient un jeton seulement, pas la cl√© r√©elle. La cl√© r√©side dans l'Enclave s√©curis√©e.

L'iPhone utilise le **code d'acc√®s introduit par l'utilisateur d√©verrouillant l'appareil pour d√©chiffrer les secrets dans le keychain**.

iOS utilise le _**AppIdentifierPrefix**_ (ID de l'√©quipe) et le _**BundleIdentifier**_ (fourni par le d√©veloppeur) pour appliquer un **contr√¥le d'acc√®s sur les √©l√©ments du keychain**. Ainsi, la m√™me √©quipe **peut** **configurer** **2 applications pour partager des √©l√©ments du keychain**.

Lorsqu'un processus de sauvegarde est initi√©, les **donn√©es du keychain sauvegard√©es restent chiffr√©es et le mot de passe du keychain n'est pas inclus dans la sauvegarde**.

{% hint style="warning" %}
**Sur un appareil jailbreak√©, le keychain n'est pas prot√©g√©.**
{% endhint %}

### **Persistance des donn√©es Keychain**

Sur iOS, lorsqu'une application est d√©sinstall√©e, les donn√©es Keychain utilis√©es par l'application sont conserv√©es par l'appareil, contrairement aux donn√©es stock√©es par le sandbox de l'application qui sont effac√©es. Dans l'√©ventualit√© o√π un **utilisateur vend son appareil sans effectuer une r√©initialisation d'usine, l'acheteur de l'appareil pourrait √™tre en mesure d'acc√©der aux comptes et donn√©es d'application de l'utilisateur pr√©c√©dent en r√©installant** les m√™mes applications utilis√©es par l'utilisateur pr√©c√©dent. Cela ne n√©cessiterait aucune comp√©tence technique pour √™tre r√©alis√©.

Il n'existe pas d'API iOS que les d√©veloppeurs peuvent utiliser pour forcer l'effacement des donn√©es lorsqu'une application est d√©sinstall√©e. Au lieu de cela, les d√©veloppeurs devraient prendre les mesures suivantes pour emp√™cher les donn√©es Keychain de persister entre les installations d'applications :

* Lorsqu'une application est lanc√©e pour la premi√®re fois apr√®s l'installation, effacer toutes les donn√©es Keychain associ√©es √† l'application. Cela emp√™chera un deuxi√®me utilisateur de l'appareil d'acc√©der accidentellement aux comptes de l'utilisateur pr√©c√©dent. L'exemple Swift suivant est une d√©monstration basique de cette proc√©dure d'effacement :
```
```objectivec
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
// Remove Keychain items here

// Update the flag indicator
userDefaults.set(true, forKey: "hasRunBefore")
userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
* Lors du d√©veloppement de la fonctionnalit√© de d√©connexion pour une application iOS, assurez-vous que les donn√©es du Keychain sont effac√©es lors de la d√©connexion du compte. Cela permettra aux utilisateurs d'effacer leurs comptes avant de d√©sinstaller une application.

# **Capacit√©s de l'application**

**Chaque application poss√®de un r√©pertoire d'accueil unique et est en mode sandbox**, de sorte qu'elle ne peut pas acc√©der aux ressources prot√©g√©es du syst√®me ou aux fichiers stock√©s par le syst√®me ou par d'autres applications. Ces restrictions sont mises en ≈ìuvre via des politiques de sandbox (√©galement connues sous le nom de _profils_), qui sont appliqu√©es par le [Trusted BSD (MAC) Mandatory Access Control Framework](http://www.trustedbsd.org/mac.html) via une extension du noyau.

Certaines [**capacit√©s/permissions**](https://help.apple.com/developer-account/#/dev21218dfd6) peuvent √™tre configur√©es par les d√©veloppeurs de l'application (par exemple, la protection des donn√©es ou le partage de Keychain) et prendront effet directement apr√®s l'installation. Cependant, pour d'autres, **l'utilisateur sera explicitement invit√© la premi√®re fois que l'application tente d'acc√©der √† une ressource prot√©g√©e**.

Les [_Purpose strings_](https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037322) ou _cha√Ænes de description d'utilisation_ sont des textes personnalis√©s qui sont pr√©sent√©s aux utilisateurs dans l'alerte de demande de permission du syst√®me lorsqu'une autorisation d'acc√®s √† des donn√©es ou ressources prot√©g√©es est demand√©e.

![](https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQw8W2q7BB5-il7r%2Fpermission_request_alert.png?alt=media)

Si vous disposez du code source original, vous pouvez v√©rifier les permissions incluses dans le fichier `Info.plist` :

* Ouvrez le projet avec Xcode.
* Trouvez et ouvrez le fichier `Info.plist` dans l'√©diteur par d√©faut et recherchez les cl√©s commen√ßant par `"Privacy -"`.

Vous pouvez changer la vue pour afficher les valeurs brutes en cliquant avec le bouton droit et en s√©lectionnant "Show Raw Keys/Values" (ainsi par exemple `"Privacy - Location When In Use Usage Description"` se transformera en `NSLocationWhenInUseUsageDescription`).

Si vous disposez seulement de l'IPA :

* D√©compressez l'IPA.
* Le `Info.plist` se trouve dans `Payload/<appname>.app/Info.plist`.
* Convertissez-le si n√©cessaire (par exemple, `plutil -convert xml1 Info.plist`) comme expliqu√© dans le chapitre "iOS Basic Security Testing", section "The Info.plist File".
*   Inspectez toutes les cl√©s _purpose strings Info.plist_, se terminant g√©n√©ralement par `UsageDescription` :

```markup
<plist version="1.0">
<dict>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Votre position est utilis√©e pour fournir des indications de navigation vers votre destination.</string>
```

## Capacit√©s de l'appareil

Les capacit√©s de l'appareil sont utilis√©es par l'App Store pour s'assurer que seuls les appareils compatibles sont r√©pertori√©s et donc autoris√©s √† t√©l√©charger l'application. Elles sont sp√©cifi√©es dans le fichier `Info.plist` de l'application sous la cl√© [`UIRequiredDeviceCapabilities`](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/plist/info/UIRequiredDeviceCapabilities).
```markup
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
</array>
```
> Typiquement, vous trouverez la capacit√© `armv7`, signifiant que l'application est compil√©e uniquement pour le jeu d'instructions armv7, ou si c'est une application universelle 32/64 bits.

Par exemple, une application pourrait √™tre enti√®rement d√©pendante de la NFC pour fonctionner (par exemple, une application ["NFC Tag Reader"](https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596)). Selon la [r√©f√©rence archiv√©e de compatibilit√© des appareils iOS](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html), la NFC est disponible seulement √† partir de l'iPhone 7 (et iOS 11). Un d√©veloppeur pourrait vouloir exclure tous les appareils incompatibles en d√©finissant la capacit√© de l'appareil `nfc`.

## Entitlements

> Les Entitlements sont des paires cl√©-valeur qui sont sign√©es dans une application et permettent une authentification au-del√† des facteurs d'ex√©cution, comme l'ID utilisateur UNIX. Comme les Entitlements sont num√©riquement sign√©s, ils ne peuvent pas √™tre modifi√©s. Les Entitlements sont largement utilis√©s par les applications syst√®me et les daemons pour **effectuer des op√©rations privil√©gi√©es sp√©cifiques qui n√©cessiteraient autrement que le processus s'ex√©cute en tant que root**. Cela r√©duit consid√©rablement le potentiel d'escalade de privil√®ges par une application syst√®me ou un daemon compromis.

Par exemple, si vous souhaitez d√©finir la capacit√© "Protection des donn√©es par d√©faut", vous devrez aller dans l'onglet **Capabilities** dans Xcode et activer la **Protection des donn√©es**. Cela est directement √©crit par Xcode dans le fichier `<appname>.entitlements` comme l'entitlement `com.apple.developer.default-data-protection` avec la valeur par d√©faut `NSFileProtectionComplete`. Dans l'IPA, nous pourrions trouver cela dans le `embedded.mobileprovision` comme :
```markup
<key>Entitlements</key>
<dict>
...
<key>com.apple.developer.default-data-protection</key>
<string>NSFileProtectionComplete</string>
</dict>
```
Pour d'autres capacit√©s telles que HealthKit, l'utilisateur doit √™tre sollicit√© pour obtenir la permission, donc il ne suffit pas d'ajouter les droits, des cl√©s sp√©ciales et des cha√Ænes doivent √™tre ajout√©es au fichier `Info.plist` de l'application.

# Bases de Objective-C et Swift

**Objective-C** poss√®de un **runtime dynamique**, donc lorsqu'un programme Objective-C est ex√©cut√© sur iOS, il appelle des biblioth√®ques dont les **adresses sont r√©solues au runtime** en comparant le nom de la fonction envoy√©e dans le message contre une liste de tous les noms de fonction disponibles.

Au d√©but, seules les applications cr√©√©es par Apple fonctionnaient sur les iPhones, elles avaient donc **acc√®s √† tout** car elles √©taient **de confiance**. Cependant, lorsque Apple a **autoris√© les applications tierces**, Apple a simplement retir√© les fichiers d'en-t√™te des fonctions puissantes pour les "cacher" aux d√©veloppeurs. Cependant, les d√©veloppeurs ont d√©couvert que les fonctions "s√ªres" n√©cessitaient certaines de ces fonctions non document√©es et en cr√©ant simplement un **fichier d'en-t√™te personnalis√© avec les noms des fonctions non document√©es, il √©tait possible d'invoquer ces puissantes fonctions cach√©es.** En r√©alit√©, Apple, avant d'autoriser la publication d'une application, v√©rifie si l'application appelle l'une de ces fonctions interdites.

Puis, Swift est apparu. Comme **Swift est li√© statiquement** (il ne r√©sout pas l'adresse des fonctions au runtime comme Objective-C), il est plus facile de v√©rifier les appels qu'un programme Swift va effectuer via une analyse de code statique.

# Gestion des appareils

√Ä partir de la version 6 d'iOS, il existe un **support int√©gr√© pour la gestion des appareils** avec des contr√¥les pr√©cis qui permettent √† une organisation de contr√¥ler les appareils Apple d'entreprise.\
L'inscription peut √™tre **initi√©e par l'utilisateur en installant un agent** afin d'acc√©der aux applications d'entreprise. Dans ce cas, l'appareil appartient g√©n√©ralement √† l'utilisateur.\
Ou l'**entreprise peut indiquer les num√©ros de s√©rie** des appareils achet√©s ou l'ID de commande d'achat et sp√©cifier le profil MDM √† installer sur ces appareils. Notez qu'Apple **ne permet pas d'inscrire un appareil particulier de cette mani√®re deux fois**. Une fois que le premier profil est supprim√©, l'utilisateur doit donner son consentement pour en installer un autre.

L'utilisateur peut voir les politiques install√©es dans _**R√©glages**_ --> _**G√©n√©ral**_ --> _**Gestion des profils et des appareils**_

Comme ces politiques MDM v√©rifient et limitent d'autres applications, elles **s'ex√©cutent avec plus de privil√®ges**.\
Une politique MDM peut **obliger** les **utilisateurs** √† avoir un **code d'acc√®s** d√©fini avec une **complexit√©** de mot de passe **minimale**.\
Les profils sont li√©s √† l'ID de l'appareil, **sign√©s** et **chiffr√©s** par le serveur MDM et **√† l'√©preuve des manipulations**. Ils **ne peuvent pas** √™tre **retir√©s** sans **perdre** toutes les **donn√©es d'entreprise**.\
Les profils MDM permettent d'**effacer** toutes les **donn√©es** s'il y a X **tentatives de mot de passe √©chou√©es**. De plus, l'**administrateur** peut **effacer √† distance** l'iPhone √† tout moment via l'interface MDM.

Les agents MDM **v√©rifient** √©galement les **√©ventuels jailbreaks de l'appareil**, car c'est un √©tat tr√®s dangereux pour un iPhone.


<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
