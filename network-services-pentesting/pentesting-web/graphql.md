# GraphQL

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichen.

</details>
{% endhint %}

## Einf√ºhrung

GraphQL wird als **effiziente Alternative** zu REST API **hervorgehoben**, die einen vereinfachten Ansatz zum Abfragen von Daten aus dem Backend bietet. Im Gegensatz zu REST, das oft zahlreiche Anfragen √ºber verschiedene Endpunkte erfordert, um Daten zu sammeln, erm√∂glicht GraphQL das Abrufen aller ben√∂tigten Informationen √ºber eine **einzelne Anfrage**. Diese Vereinfachung **kommt Entwicklern** erheblich zugute, indem sie die Komplexit√§t ihrer Datenabrufprozesse verringert.

## GraphQL und Sicherheit

Mit dem Aufkommen neuer Technologien, einschlie√ülich GraphQL, entstehen auch neue Sicherheitsanf√§lligkeiten. Ein wichtiger Punkt ist, dass **GraphQL standardm√§√üig keine Authentifizierungsmechanismen enth√§lt**. Es liegt in der Verantwortung der Entwickler, solche Sicherheitsma√ünahmen zu implementieren. Ohne angemessene Authentifizierung k√∂nnen GraphQL-Endpunkte sensible Informationen f√ºr nicht authentifizierte Benutzer offenlegen, was ein erhebliches Sicherheitsrisiko darstellt.

### Verzeichnis-Brute-Force-Angriffe und GraphQL

Um exponierte GraphQL-Instanzen zu identifizieren, wird empfohlen, spezifische Pfade in Verzeichnis-Brute-Force-Angriffen einzuschlie√üen. Diese Pfade sind:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Die Identifizierung offener GraphQL-Instanzen erm√∂glicht die Untersuchung der unterst√ºtzten Abfragen. Dies ist entscheidend f√ºr das Verst√§ndnis der √ºber den Endpunkt zug√§nglichen Daten. Das Introspektionssystem von GraphQL erleichtert dies, indem es die Abfragen detailliert, die ein Schema unterst√ºtzt. Weitere Informationen dazu finden Sie in der GraphQL-Dokumentation zur Introspektion: [**GraphQL: Eine Abfragesprache f√ºr APIs.**](https://graphql.org/learn/introspection/)

### Fingerabdruck

Das Tool [**graphw00f**](https://github.com/dolevf/graphw00f) kann erkennen, welcher GraphQL-Engine auf einem Server verwendet wird, und druckt dann einige hilfreiche Informationen f√ºr den Sicherheitspr√ºfer.

#### Universelle Abfragen <a href="#universal-queries" id="universal-queries"></a>

Um zu √ºberpr√ºfen, ob eine URL ein GraphQL-Dienst ist, kann eine **universelle Abfrage**, `query{__typename}`, gesendet werden. Wenn die Antwort `{"data": {"__typename": "Query"}}` enth√§lt, best√§tigt dies, dass die URL einen GraphQL-Endpunkt hostet. Diese Methode basiert auf dem `__typename`-Feld von GraphQL, das den Typ des abgefragten Objekts offenbart.
```javascript
query{__typename}
```
### Grundlegende Enumeration

Graphql unterst√ºtzt normalerweise **GET**, **POST** (x-www-form-urlencoded) und **POST**(json). Obwohl es aus Sicherheitsgr√ºnden empfohlen wird, nur json zuzulassen, um CSRF-Angriffe zu verhindern.

#### Introspektion

Um Introspektion zu verwenden, um Schema-Informationen zu entdecken, abfragen Sie das `__schema`-Feld. Dieses Feld ist auf dem Wurzeltyp aller Abfragen verf√ºgbar.
```bash
query={__schema{types{name,fields{name}}}}
```
Mit dieser Abfrage finden Sie die Namen aller verwendeten Typen:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Mit dieser Abfrage k√∂nnen Sie alle Typen, deren Felder und deren Argumente (sowie den Typ der Argumente) extrahieren. Dies wird sehr n√ºtzlich sein, um zu wissen, wie man die Datenbank abfragt.

![](<../../.gitbook/assets/image (950).png>)

**Fehler**

Es ist interessant zu wissen, ob die **Fehler** angezeigt werden, da sie mit n√ºtzlichen **Informationen** beitragen werden.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**Datenbankschema √ºber Introspektion auflisten**

{% hint style="info" %}
Wenn die Introspektion aktiviert ist, aber die obige Abfrage nicht ausgef√ºhrt wird, versuchen Sie, die `onOperation`, `onFragment` und `onField` Direktiven aus der Abfrage-Struktur zu entfernen.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Inline-Introspektionsabfrage:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Die letzte Codezeile ist eine GraphQL-Abfrage, die alle Metainformationen aus dem GraphQL (Objektnamen, Parameter, Typen...) ausgibt.

![](<../../.gitbook/assets/image (363).png>)

Wenn die Introspektion aktiviert ist, k√∂nnen Sie [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) verwenden, um in einer GUI alle Optionen anzuzeigen.

### Abfragen

Jetzt, da wir wissen, welche Art von Informationen in der Datenbank gespeichert ist, lassen Sie uns versuchen, **einige Werte zu extrahieren**.

In der Introspektion k√∂nnen Sie **sehen, welches Objekt Sie direkt abfragen k√∂nnen** (weil Sie ein Objekt nicht nur abfragen k√∂nnen, weil es existiert). Im folgenden Bild sehen Sie, dass der "_queryType_" "_Query_" genannt wird und dass eines der Felder des "_Query_"-Objekts "_flags_" ist, das ebenfalls ein Objekttyp ist. Daher k√∂nnen Sie das Flag-Objekt abfragen.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Beachten Sie, dass der Typ der Abfrage "_flags_" "_Flags_" ist, und dieses Objekt ist wie folgt definiert:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Sie k√∂nnen sehen, dass die "_Flags_"-Objekte aus **name** und **value** bestehen. Dann k√∂nnen Sie alle Namen und Werte der Flags mit der Abfrage erhalten:
```javascript
query={flags{name, value}}
```
Beachten Sie, dass im Falle des **Objekts, das abgefragt werden soll**, ein **primitiver** **Typ** wie **string** ist, wie im folgenden Beispiel

![](<../../.gitbook/assets/image (958).png>)

Sie k√∂nnen es einfach abfragen mit:
```javascript
query={hiddenFlags}
```
In einem anderen Beispiel, in dem es 2 Objekte im "_Query_" Typobjekt gab: "_user_" und "_users_".\
Wenn diese Objekte keine Argumente zum Suchen ben√∂tigen, k√∂nnte man **alle Informationen von ihnen abrufen**, indem man einfach nach den gew√ºnschten Daten fragt. In diesem Beispiel aus dem Internet k√∂nnte man die gespeicherten Benutzernamen und Passw√∂rter extrahieren:

![](<../../.gitbook/assets/image (880).png>)

Wenn man jedoch in diesem Beispiel versucht, dies zu tun, erh√§lt man diesen **Fehler**:

![](<../../.gitbook/assets/image (1042).png>)

Es scheint, dass es irgendwie mit dem "_**uid**_" Argument vom Typ _**Int**_ suchen wird.\
Wie auch immer, wir wussten bereits, dass im Abschnitt [Basic Enumeration](graphql.md#basic-enumeration) eine Abfrage vorgeschlagen wurde, die uns alle ben√∂tigten Informationen zeigte: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Wenn du das Bild liest, das bereitgestellt wurde, als ich diese Abfrage ausgef√ºhrt habe, wirst du sehen, dass "_**user**_" das **arg** "_**uid**_" vom Typ _Int_ hatte.

Durch einige leichte _**uid**_ Bruteforce fand ich heraus, dass bei _**uid**=**1**_ ein Benutzername und ein Passwort abgerufen wurden:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Beachte, dass ich **entdeckt** habe, dass ich nach den **Parametern** "_**user**_" und "_**password**_" fragen konnte, denn wenn ich versuche, nach etwas zu suchen, das nicht existiert (`query={user(uid:1){noExists}}`), erhalte ich diesen Fehler:

![](<../../.gitbook/assets/image (707).png>)

Und w√§hrend der **Enumeration-Phase** entdeckte ich, dass das "_**dbuser**_" Objekt die Felder "_**user**_" und "_**password**_" hatte.

**Query-String-Dump-Trick (danke an @BinaryShadow\_)**

Wenn du nach einem String-Typ suchen kannst, wie: `query={theusers(description: ""){username,password}}` und du **nach einem leeren String suchst**, wird es **alle Daten dumpen**. (_Beachte, dass dieses Beispiel nicht mit dem Beispiel der Tutorials zusammenh√§ngt, f√ºr dieses Beispiel gehe davon aus, dass du mit "**theusers**" nach einem String-Feld namens "**description**" suchen kannst_).

### Suchen

In diesem Setup enth√§lt eine **Datenbank** **Personen** und **Filme**. **Personen** werden durch ihre **E-Mail** und **Namen** identifiziert; **Filme** durch ihren **Namen** und **Bewertung**. **Personen** k√∂nnen Freunde miteinander sein und auch Filme haben, was Beziehungen innerhalb der Datenbank anzeigt.

Du kannst **Personen** **nach** dem **Namen** suchen und ihre E-Mails erhalten:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Du kannst **Personen** **nach** dem **Namen** **suchen** und ihre **abonnierten** **Filme** erhalten:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Beachten Sie, wie angegeben ist, um den `name` der `subscribedMovies` der Person abzurufen.

Sie k√∂nnen auch **mehrere Objekte gleichzeitig suchen**. In diesem Fall wird eine Suche nach 2 Filmen durchgef√ºhrt:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Oder sogar **Beziehungen mehrerer verschiedener Objekte mithilfe von Aliassen**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutationen

**Mutationen werden verwendet, um √Ñnderungen auf der Serverseite vorzunehmen.**

In der **Introspektion** k√∂nnen Sie die **deklarierten** **Mutationen** finden. Im folgenden Bild wird der "_MutationType_" als "_Mutation_" bezeichnet und das "_Mutation_"-Objekt enth√§lt die Namen der Mutationen (wie "_addPerson_" in diesem Fall):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

In diesem Setup enth√§lt eine **Datenbank** **Personen** und **Filme**. **Personen** werden durch ihre **E-Mail** und **Namen** identifiziert; **Filme** durch ihren **Namen** und **Bewertung**. **Personen** k√∂nnen Freunde miteinander sein und auch Filme haben, was Beziehungen innerhalb der Datenbank anzeigt.

Eine Mutation, um **neue** Filme in der Datenbank zu **erstellen**, k√∂nnte wie folgt aussehen (in diesem Beispiel wird die Mutation `addMovie` genannt):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Beachten Sie, wie sowohl die Werte als auch der Datentyp in der Abfrage angegeben sind.**

Zus√§tzlich unterst√ºtzt die Datenbank eine **Mutation**-Operation, die `addPerson` genannt wird und die Erstellung von **Personen** zusammen mit ihren Verbindungen zu bestehenden **Freunden** und **Filmen** erm√∂glicht. Es ist wichtig zu beachten, dass die Freunde und Filme bereits in der Datenbank vorhanden sein m√ºssen, bevor sie mit der neu erstellten Person verkn√ºpft werden.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Wie in [**einer der Schwachstellen, die in diesem Bericht beschrieben sind**](https://www.landh.tech/blog/20240304-google-hack-50000/) erkl√§rt, bedeutet eine Directive Overloading, eine Direktive sogar Millionen von Malen aufzurufen, um den Server dazu zu bringen, Operationen zu verschwenden, bis es m√∂glich ist, ihn DoS zu machen.

### Batching brute-force in 1 API request

Diese Informationen stammen von [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Authentifizierung √ºber die GraphQL-API mit **gleichzeitigem Senden vieler Abfragen mit unterschiedlichen Anmeldeinformationen**, um dies zu √ºberpr√ºfen. Es handelt sich um einen klassischen Brute-Force-Angriff, aber jetzt ist es m√∂glich, mehr als ein Login/Passwort-Paar pro HTTP-Anfrage zu senden, dank der GraphQL-Batching-Funktion. Dieser Ansatz w√ºrde externe Rate-√úberwachungsanwendungen t√§uschen, indem er denkt, dass alles in Ordnung ist und kein Brute-Forcing-Bot versucht, Passw√∂rter zu erraten.

Unten finden Sie die einfachste Demonstration einer Anwendungsauthentifizierungsanfrage, mit **3 verschiedenen E-Mail/Passwort-Paaren gleichzeitig**. Offensichtlich ist es m√∂glich, Tausende in einer einzigen Anfrage auf die gleiche Weise zu senden:

![](<../../.gitbook/assets/image (1081).png>)

Wie wir aus dem Screenshot der Antwort sehen k√∂nnen, gaben die erste und die dritte Anfrage _null_ zur√ºck und spiegelten die entsprechenden Informationen im _error_-Bereich wider. Die **zweite Mutation hatte die korrekten Authentifizierungs**daten und die Antwort enth√§lt das korrekte Authentifizierungssession-Token.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Without Introspection

Immer mehr **GraphQL-Endpunkte deaktivieren die Introspektion**. Die Fehler, die GraphQL wirft, wenn eine unerwartete Anfrage empfangen wird, sind jedoch ausreichend f√ºr Tools wie [**clairvoyance**](https://github.com/nikitastupin/clairvoyance), um den gr√∂√üten Teil des Schemas zu rekonstruieren.

Dar√ºber hinaus beobachtet die Burp Suite-Erweiterung [**GraphQuail**](https://github.com/forcesunseen/graphquail) **GraphQL-API-Anfragen, die durch Burp gehen**, und **baut** ein internes GraphQL-**Schema** mit jeder neuen Abfrage, die sie sieht. Es kann auch das Schema f√ºr GraphiQL und Voyager offenlegen. Die Erweiterung gibt eine gef√§lschte Antwort zur√ºck, wenn sie eine Introspektionsanfrage erh√§lt. Infolgedessen zeigt GraphQuail alle Abfragen, Argumente und Felder, die innerhalb der API verf√ºgbar sind. F√ºr weitere Informationen [**hier √ºberpr√ºfen**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Eine sch√∂ne **Wortliste**, um [**GraphQL-Entit√§ten zu entdecken, finden Sie hier**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Bypassing GraphQL introspection defences <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Um Einschr√§nkungen bei Introspektionsanfragen in APIs zu umgehen, erweist sich das Einf√ºgen eines **Sonderzeichens nach dem `__schema`-Schl√ºsselwort** als effektiv. Diese Methode nutzt h√§ufige Entwicklerfehler in Regex-Mustern aus, die darauf abzielen, die Introspektion zu blockieren, indem sie sich auf das `__schema`-Schl√ºsselwort konzentrieren. Durch das Hinzuf√ºgen von Zeichen wie **Leerzeichen, Zeilenumbr√ºchen und Kommas**, die GraphQL ignoriert, aber m√∂glicherweise nicht in Regex ber√ºcksichtigt werden, k√∂nnen Einschr√§nkungen umgangen werden. Zum Beispiel kann eine Introspektionsanfrage mit einem Zeilenumbruch nach `__schema` solche Verteidigungen umgehen:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Wenn dies nicht erfolgreich ist, ziehen Sie alternative Anforderungsmethoden in Betracht, wie **GET-Anfragen** oder **POST mit `x-www-form-urlencoded`**, da Einschr√§nkungen m√∂glicherweise nur f√ºr POST-Anfragen gelten.

### Versuchen Sie WebSockets

Wie in [**diesem Vortrag**](https://www.youtube.com/watch?v=tIo\_t5uUK50) erw√§hnt, √ºberpr√ºfen Sie, ob es m√∂glich sein k√∂nnte, sich √ºber WebSockets mit graphQL zu verbinden, da dies Ihnen m√∂glicherweise erm√∂glicht, eine potenzielle WAF zu umgehen und die Websocket-Kommunikation das Schema von graphQL preiszugeben:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Entdecken von Exponierten GraphQL-Strukturen**

Wenn die Introspektion deaktiviert ist, ist das Durchsuchen des Quellcodes der Website nach vorab geladenen Abfragen in JavaScript-Bibliotheken eine n√ºtzliche Strategie. Diese Abfragen k√∂nnen im `Sources`-Tab der Entwicklertools gefunden werden, was Einblicke in das Schema der API bietet und potenziell **exponierte sensible Abfragen** offenbart. Die Befehle zur Suche innerhalb der Entwicklertools sind:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Wenn Sie nicht wissen, was CSRF ist, lesen Sie die folgende Seite:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Dort drau√üen werden Sie mehrere GraphQL-Endpunkte finden, die **ohne CSRF-Token konfiguriert sind.**

Beachten Sie, dass GraphQL-Anfragen normalerweise √ºber POST-Anfragen mit dem Content-Type **`application/json`** gesendet werden.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Allerdings unterst√ºtzen die meisten GraphQL-Endpunkte auch **`form-urlencoded` POST-Anfragen:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Daher ist es m√∂glich, **√Ñnderungen** in der GraphQL durch Ausnutzung einer CSRF vorzunehmen, da CSRF-Anfragen wie die vorherigen **ohne Preflight-Anfragen** gesendet werden.

Beachten Sie jedoch, dass der neue Standardwert des Cookie-Werts des `samesite`-Flags von Chrome `Lax` ist. Das bedeutet, dass das Cookie nur von einer Drittanbieter-Website in GET-Anfragen gesendet wird.

Es ist zu beachten, dass es normalerweise m√∂glich ist, die **Abfrage** **Anfrage** auch als **GET** **Anfrage** zu senden und das CSRF-Token m√∂glicherweise in einer GET-Anfrage nicht validiert wird.

Au√üerdem k√∂nnte es m√∂glich sein, durch Ausnutzung eines [**XS-Search**](../../pentesting-web/xs-search/) **Angriffs** Inhalte vom GraphQL-Endpunkt unter Ausnutzung der Anmeldeinformationen des Benutzers zu exfiltrieren.

F√ºr weitere Informationen **√ºberpr√ºfen Sie den** [**originalen Beitrag hier**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Cross-Site-WebSocket-Hijacking in GraphQL

√Ñhnlich wie bei CRSF-Schwachstellen, die GraphQL ausnutzen, ist es auch m√∂glich, ein **Cross-Site-WebSocket-Hijacking durchzuf√ºhren, um eine Authentifizierung mit GraphQL mit ungesch√ºtzten Cookies auszunutzen** und einen Benutzer dazu zu bringen, unerwartete Aktionen in GraphQL auszuf√ºhren.

F√ºr weitere Informationen √ºberpr√ºfen Sie:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Autorisierung in GraphQL

Viele GraphQL-Funktionen, die am Endpunkt definiert sind, √ºberpr√ºfen m√∂glicherweise nur die Authentifizierung des Anforderers, jedoch nicht die Autorisierung.

Das Modifizieren von Abfrageeingabevariablen k√∂nnte zu sensiblen Kontodetails [leaked](https://hackerone.com/reports/792927) f√ºhren.

Mutation k√∂nnte sogar zu einem Account-√úbernahmeversuch f√ºhren, indem versucht wird, andere Kontodaten zu √§ndern.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Umgehung der Autorisierung in GraphQL

[Abfragen verketten](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) kann ein schwaches Authentifizierungssystem umgehen.

Im folgenden Beispiel sehen Sie, dass die Operation "forgotPassword" ist und dass sie nur die zugeh√∂rige forgotPassword-Abfrage ausf√ºhren sollte. Dies kann umgangen werden, indem am Ende eine Abfrage hinzugef√ºgt wird, in diesem Fall f√ºgen wir "register" und eine Benutzer-Variable hinzu, damit das System sich als neuer Benutzer registriert.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Umgehung von Ratenlimits mit Aliassen in GraphQL

In GraphQL sind Aliasse ein leistungsstarkes Feature, das die **explizite Benennung von Eigenschaften** bei der Durchf√ºhrung einer API-Anfrage erm√∂glicht. Diese F√§higkeit ist besonders n√ºtzlich, um **mehrere Instanzen desselben Typs** von Objekten innerhalb einer einzigen Anfrage abzurufen. Aliasse k√∂nnen verwendet werden, um die Einschr√§nkung zu √ºberwinden, die verhindert, dass GraphQL-Objekte mehrere Eigenschaften mit demselben Namen haben.

F√ºr ein detailliertes Verst√§ndnis von GraphQL-Aliassen wird die folgende Ressource empfohlen: [Aliasse](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

W√§hrend der Hauptzweck von Aliassen darin besteht, die Notwendigkeit f√ºr zahlreiche API-Aufrufe zu reduzieren, wurde ein unbeabsichtigter Anwendungsfall identifiziert, bei dem Aliasse genutzt werden k√∂nnen, um Brute-Force-Angriffe auf einen GraphQL-Endpunkt durchzuf√ºhren. Dies ist m√∂glich, weil einige Endpunkte durch Ratenbegrenzer gesch√ºtzt sind, die darauf ausgelegt sind, Brute-Force-Angriffe zu verhindern, indem sie die **Anzahl der HTTP-Anfragen** einschr√§nken. Diese Ratenbegrenzer ber√ºcksichtigen jedoch m√∂glicherweise nicht die Anzahl der Operationen innerhalb jeder Anfrage. Da Aliasse die Einbeziehung mehrerer Abfragen in einer einzigen HTTP-Anfrage erm√∂glichen, k√∂nnen sie solche Ratenbegrenzungsma√ünahmen umgehen.

Betrachten Sie das unten angegebene Beispiel, das veranschaulicht, wie aliierte Abfragen verwendet werden k√∂nnen, um die G√ºltigkeit von Rabattcodes im Gesch√§ft zu √ºberpr√ºfen. Diese Methode k√∂nnte Ratenbegrenzungen umgehen, da sie mehrere Abfragen in einer HTTP-Anfrage zusammenfasst, was m√∂glicherweise die √úberpr√ºfung zahlreicher Rabattcodes gleichzeitig erm√∂glicht.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Tools

### Vulnerability scanners

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testen von h√§ufigen Fehlkonfigurationen von GraphQL-Endpunkten
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): GraphQL-Sicherheitspr√ºfskript mit Fokus auf das Durchf√ºhren von Batch-GraphQL-Abfragen und -Mutationen.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Fingerabdruck des verwendeten GraphQL erstellen
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit, das verwendet werden kann, um Schemata zu erfassen und nach sensiblen Daten zu suchen, Autorisierung zu testen, Schemata zu brute-forcen und Pfade zu einem bestimmten Typ zu finden.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Kann als Standalone oder [Burp-Erweiterung](https://github.com/doyensec/inql) verwendet werden.
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Kann auch als CLI-Client verwendet werden, um Angriffe zu automatisieren
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Tool, das die verschiedenen M√∂glichkeiten auflistet, **einen bestimmten Typ in einem GraphQL-Schema zu erreichen**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Der Nachfolger der Standalone- und CLI-Modi von InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp-Erweiterung f√ºr fortgeschrittenes GraphQL-Testing. Der _**Scanner**_ ist der Kern von InQL v5.0, wo Sie einen GraphQL-Endpunkt oder eine lokale Introspektionsschema-Datei analysieren k√∂nnen. Er generiert automatisch alle m√∂glichen Abfragen und Mutationen und organisiert sie in einer strukturierten Ansicht f√ºr Ihre Analyse. Die _**Attacker**_-Komponente erm√∂glicht es Ihnen, Batch-GraphQL-Angriffe durchzuf√ºhren, was n√ºtzlich sein kann, um schlecht implementierte Ratenlimits zu umgehen.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Versuchen Sie, das Schema selbst bei deaktivierter Introspektion zu erhalten, indem Sie die Hilfe einiger GraphQL-Datenbanken in Anspruch nehmen, die die Namen von Mutationen und Parametern vorschlagen.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI-Client
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI-Client

### Automatic Tests

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video, das AutoGraphQL erkl√§rt: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## References

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
