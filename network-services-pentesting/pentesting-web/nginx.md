# Nginx

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

**Impostazione disponibile istantaneamente per la valutazione delle vulnerabilit√† e il penetration testing**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla reportistica. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento e sfruttamento per dare loro pi√π tempo per approfondire, aprire shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Quando si configura il server Nginx, la **direttiva root** gioca un ruolo critico definendo la directory di base da cui vengono serviti i file. Considera l'esempio qui sotto:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In questa configurazione, `/etc/nginx` √® designato come la directory radice. Questa impostazione consente l'accesso ai file all'interno della directory radice specificata, come `/hello.txt`. Tuttavia, √® fondamentale notare che √® definita solo una posizione specifica (`/hello.txt`). Non c'√® configurazione per la posizione radice (`location / {...}`). Questa omissione significa che la direttiva radice si applica globalmente, consentendo le richieste al percorso radice `/` di accedere ai file sotto `/etc/nginx`.

Una considerazione critica per la sicurezza deriva da questa configurazione. Una semplice richiesta `GET`, come `GET /nginx.conf`, potrebbe esporre informazioni sensibili servendo il file di configurazione di Nginx situato in `/etc/nginx/nginx.conf`. Impostare la radice su una directory meno sensibile, come `/etc`, potrebbe mitigare questo rischio, ma potrebbe comunque consentire accessi non intenzionali ad altri file critici, inclusi altri file di configurazione, log di accesso e persino credenziali crittografate utilizzate per l'autenticazione di base HTTP.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nei file di configurazione di Nginx, √® necessaria un'attenta ispezione per le direttive "location". Una vulnerabilit√† nota come Local File Inclusion (LFI) pu√≤ essere introdotta involontariamente attraverso una configurazione che somiglia alla seguente:
```
location /imgs {
alias /path/images/;
}
```
Questa configurazione √® soggetta ad attacchi LFI a causa del server che interpreta le richieste come `/imgs../flag.txt` come un tentativo di accedere a file al di fuori della directory prevista, risolvendo effettivamente a `/path/images/../flag.txt`. Questo difetto consente agli attaccanti di recuperare file dal filesystem del server che non dovrebbero essere accessibili tramite il web.

Per mitigare questa vulnerabilit√†, la configurazione dovrebbe essere modificata per:
```
location /imgs/ {
alias /path/images/;
}
```
Maggiore info: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Test di Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restrizione del percorso non sicuro <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Controlla la seguente pagina per imparare come bypassare direttive come:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Uso non sicuro delle variabili / Suddivisione della richiesta HTTP <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
Variabili vulnerabili `$uri` e `$document_uri` e questo pu√≤ essere risolto sostituendole con `$request_uri`.

Una regex pu√≤ anche essere vulnerabile come:

`location ~ /docs/([^/])? { ‚Ä¶ $1 ‚Ä¶ }` - Vulnerabile&#x20;

`location ~ /docs/([^/\s])? { ‚Ä¶ $1 ‚Ä¶ }` - Non vulnerabile (controllo degli spazi)

`location ~ /docs/(.*)? { ‚Ä¶ $1 ‚Ä¶ }`  - Non vulnerabile
{% endhint %}

Una vulnerabilit√† nella configurazione di Nginx √® dimostrata dall'esempio seguente:
```
location / {
return 302 https://example.com$uri;
}
```
I caratteri \r (Carriage Return) e \n (Line Feed) significano caratteri di nuova linea nelle richieste HTTP, e le loro forme codificate in URL sono rappresentate come `%0d%0a`. Includere questi caratteri in una richiesta (ad esempio, `http://localhost/%0d%0aDetectify:%20clrf`) a un server mal configurato porta il server a emettere un nuovo header chiamato `Detectify`. Questo accade perch√© la variabile $uri decodifica i caratteri di nuova linea codificati in URL, portando a un header imprevisto nella risposta:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Scopri di pi√π sui rischi dell'iniezione CRLF e della divisione della risposta su [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Inoltre, questa tecnica √® [**spiegata in questo intervento**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) con alcuni esempi vulnerabili e meccanismi di rilevamento. Ad esempio, per rilevare questa misconfigurazione da una prospettiva blackbox, potresti utilizzare queste richieste:

* `https://example.com/%20X` - Qualsiasi codice HTTP
* `https://example.com/%20H` - 400 Bad Request

Se vulnerabile, il primo restituir√† "X" poich√© √® un metodo HTTP valido e il secondo restituir√† un errore poich√© H non √® un metodo valido. Quindi il server ricever√† qualcosa come: `GET / H HTTP/1.1` e questo attiver√† l'errore.

Altri esempi di rilevamento potrebbero essere:

* `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Qualsiasi codice HTTP
* `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Alcune configurazioni vulnerabili trovate in quel intervento erano:

* Nota come **`$uri`** √® impostato cos√¨ com'√® nell'URL finale.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Nota come di nuovo **`$uri`** √® nell'URL (questa volta all'interno di un parametro)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Ora in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Any variable

√à stato scoperto che **i dati forniti dall'utente** potrebbero essere trattati come una **variabile Nginx** in determinate circostanze. La causa di questo comportamento rimane piuttosto elusiva, eppure non √® rara n√© semplice da verificare. Questa anomalia √® stata evidenziata in un rapporto di sicurezza su HackerOne, che pu√≤ essere visualizzato [qui](https://hackerone.com/reports/370094). Ulteriori indagini sul messaggio di errore hanno portato all'identificazione della sua occorrenza all'interno del [modulo di filtro SSI del codice di Nginx](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx\_http\_ssi\_filter\_module.c#L365), individuando le Include lato server (SSI) come causa principale.

Per **rilevare questa misconfigurazione**, √® possibile eseguire il seguente comando, che prevede l'impostazione di un'intestazione referer per testare la stampa delle variabili:
```bash
$ curl -H ‚ÄòReferer: bar‚Äô http://localhost/foo$http_referer | grep ‚Äòfoobar‚Äô
```
Scans per questa misconfigurazione su sistemi hanno rivelato molteplici istanze in cui le variabili Nginx potevano essere stampate da un utente. Tuttavia, una diminuzione del numero di istanze vulnerabili suggerisce che gli sforzi per correggere questo problema sono stati in qualche modo efficaci.

## Lettura della risposta backend grezza

Nginx offre una funzionalit√† attraverso `proxy_pass` che consente l'intercettazione di errori e intestazioni HTTP prodotte dal backend, con l'obiettivo di nascondere messaggi di errore interni e intestazioni. Questo viene realizzato da Nginx servendo pagine di errore personalizzate in risposta agli errori del backend. Tuttavia, sorgono sfide quando Nginx incontra una richiesta HTTP non valida. Tale richiesta viene inoltrata al backend cos√¨ com'√®, e la risposta grezza del backend viene quindi inviata direttamente al client senza l'intervento di Nginx.

Considera un esempio di scenario che coinvolge un'applicazione uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Per gestire questo, vengono utilizzate direttive specifiche nella configurazione di Nginx:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Questa direttiva consente a Nginx di servire una risposta personalizzata per le risposte del backend con un codice di stato superiore a 300. Garantisce che, per il nostro esempio di applicazione uWSGI, una risposta `500 Error` venga intercettata e gestita da Nginx.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Come suggerisce il nome, questa direttiva nasconde gli header HTTP specificati dal client, migliorando la privacy e la sicurezza.

Quando viene effettuata una richiesta `GET` valida, Nginx la elabora normalmente, restituendo una risposta di errore standard senza rivelare alcun header segreto. Tuttavia, una richiesta HTTP non valida bypassa questo meccanismo, risultando nell'esposizione delle risposte raw del backend, inclusi header segreti e messaggi di errore.

## merge\_slashes impostato su off

Per impostazione predefinita, la **direttiva `merge_slashes` di Nginx** √® impostata su **`on`**, che comprime pi√π barre oblique in un URL in una singola barra. Questa funzionalit√†, pur semplificando l'elaborazione degli URL, pu√≤ inavvertitamente nascondere vulnerabilit√† nelle applicazioni dietro Nginx, in particolare quelle soggette ad attacchi di inclusione di file locali (LFI). Gli esperti di sicurezza **Danny Robinson e Rotem Bar** hanno evidenziato i potenziali rischi associati a questo comportamento predefinito, specialmente quando Nginx funge da reverse-proxy.

Per mitigare tali rischi, si raccomanda di **disattivare la direttiva `merge_slashes`** per le applicazioni suscettibili a queste vulnerabilit√†. Questo garantisce che Nginx inoltri le richieste all'applicazione senza alterare la struttura dell'URL, evitando cos√¨ di mascherare eventuali problemi di sicurezza sottostanti.

Per ulteriori informazioni, controlla [Danny Robinson e Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Intestazioni di Risposta Maclicious**

Come mostrato in [**questo writeup**](https://mizu.re/post/cors-playground), ci sono alcune intestazioni che, se presenti nella risposta del server web, cambieranno il comportamento del proxy Nginx. Puoi controllarle [**nella documentazione**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

* `X-Accel-Redirect`: Indica a Nginx di reindirizzare internamente una richiesta a una posizione specificata.
* `X-Accel-Buffering`: Controlla se Nginx deve bufferizzare la risposta o meno.
* `X-Accel-Charset`: Imposta il set di caratteri per la risposta quando si utilizza X-Accel-Redirect.
* `X-Accel-Expires`: Imposta il tempo di scadenza per la risposta quando si utilizza X-Accel-Redirect.
* `X-Accel-Limit-Rate`: Limita il tasso di trasferimento per le risposte quando si utilizza X-Accel-Redirect.

Ad esempio, l'intestazione **`X-Accel-Redirect`** causer√† un **reindirizzamento** interno in nginx. Quindi avere una configurazione nginx con qualcosa come **`root /`** e una risposta dal server web con **`X-Accel-Redirect: .env`** far√† s√¨ che nginx invii il contenuto di **`/.env`** (Path Traversal).

### **Valore Predefinito nella Direttiva Map**

Nella **configurazione di Nginx**, la direttiva `map` gioca spesso un ruolo nel **controllo dell'autorizzazione**. Un errore comune √® non specificare un valore **predefinito**, il che potrebbe portare ad accessi non autorizzati. Ad esempio:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Senza un `default`, un **utente malintenzionato** pu√≤ eludere la sicurezza accedendo a un **URI non definito** all'interno di `/map-poc`. [Il manuale di Nginx](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html) consiglia di impostare un **valore predefinito** per evitare tali problemi.

### **Vulnerabilit√† di Spoofing DNS**

Lo spoofing DNS contro Nginx √® fattibile in determinate condizioni. Se un attaccante conosce il **server DNS** utilizzato da Nginx e pu√≤ intercettare le sue query DNS, pu√≤ falsificare i record DNS. Questo metodo, tuttavia, √® inefficace se Nginx √® configurato per utilizzare **localhost (127.0.0.1)** per la risoluzione DNS. Nginx consente di specificare un server DNS come segue:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` e Direttive `internal`**

La direttiva **`proxy_pass`** √® utilizzata per reindirizzare le richieste ad altri server, sia internamente che esternamente. La direttiva **`internal`** garantisce che determinate posizioni siano accessibili solo all'interno di Nginx. Sebbene queste direttive non siano vulnerabilit√† di per s√©, la loro configurazione richiede un'attenta esaminazione per prevenire lacune di sicurezza.

## proxy\_set\_header Upgrade & Connection

Se il server nginx √® configurato per passare le intestazioni Upgrade e Connection, un [**attacco h2c Smuggling**](../../pentesting-web/h2c-smuggling.md) potrebbe essere eseguito per accedere a endpoint protetti/interni.

{% hint style="danger" %}
Questa vulnerabilit√† consentirebbe a un attaccante di **stabilire una connessione diretta con l'endpoint `proxy_pass`** (`http://backend:9999` in questo caso) il cui contenuto non verr√† controllato da nginx.
{% endhint %}

Esempio di configurazione vulnerabile per rubare `/flag` da [qui](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Nota che anche se il `proxy_pass` puntava a un **percorso** specifico come `http://backend:9999/socket.io`, la connessione sar√† stabilita con `http://backend:9999`, quindi puoi **contattare qualsiasi altro percorso all'interno di quel punto finale interno. Quindi non importa se un percorso √® specificato nell'URL di proxy_pass.**
{% endhint %}

## Provalo tu stesso

Detectify ha creato un repository GitHub dove puoi utilizzare Docker per impostare il tuo server di test Nginx vulnerabile con alcune delle misconfigurazioni discusse in questo articolo e provare a trovarle tu stesso!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Strumenti di analisi statica

### [GIXY](https://github.com/yandex/gixy)

Gixy √® uno strumento per analizzare la configurazione di Nginx. L'obiettivo principale di Gixy √® prevenire la misconfigurazione della sicurezza e automatizzare il rilevamento dei difetti.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner √® uno strumento semplice per cercare comuni misconfigurazioni e vulnerabilit√† di Nginx.

## Riferimenti

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

**Impostazione immediatamente disponibile per la valutazione delle vulnerabilit√† e il penetration testing**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla reportistica. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento e sfruttamento per restituire loro un po' di tempo per approfondire, aprire shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

{% hint style="success" %}
Impara e pratica il hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica il hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository GitHub.

</details>
{% endhint %}
