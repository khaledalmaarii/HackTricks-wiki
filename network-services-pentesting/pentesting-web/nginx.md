# Nginx

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

**Sofort verf√ºgbare Einrichtung f√ºr Schwachstellenbewertung & Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Pentest von √ºberall mit √ºber 20 Tools & Funktionen durch, die von Recon bis Reporting reichen. Wir ersetzen keine Pentester - wir entwickeln ma√ügeschneiderte Tools, Erkennungs- & Ausnutzungs-Module, um ihnen etwas Zeit zur√ºckzugeben, um tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Fehlender Root-Standort <a href="#missing-root-location" id="missing-root-location"></a>

Bei der Konfiguration des Nginx-Servers spielt die **Root-Direktive** eine entscheidende Rolle, indem sie das Basisverzeichnis definiert, aus dem Dateien bereitgestellt werden. Betrachten Sie das folgende Beispiel:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In dieser Konfiguration ist `/etc/nginx` als das Stammverzeichnis festgelegt. Dieses Setup erm√∂glicht den Zugriff auf Dateien innerhalb des angegebenen Stammverzeichnisses, wie z.B. `/hello.txt`. Es ist jedoch wichtig zu beachten, dass nur ein spezifischer Ort (`/hello.txt`) definiert ist. Es gibt keine Konfiguration f√ºr den Stammort (`location / {...}`). Diese Auslassung bedeutet, dass die Stamm-Direktive global gilt, was es Anfragen erm√∂glicht, auf den Stammpfad `/` zuzugreifen und Dateien unter `/etc/nginx` zu erreichen.

Eine kritische Sicherheits√ºberlegung ergibt sich aus dieser Konfiguration. Eine einfache `GET`-Anfrage, wie `GET /nginx.conf`, k√∂nnte sensible Informationen offenlegen, indem die Nginx-Konfigurationsdatei unter `/etc/nginx/nginx.conf` bereitgestellt wird. Das Setzen des Stammverzeichnisses auf ein weniger sensibles Verzeichnis, wie `/etc`, k√∂nnte dieses Risiko mindern, dennoch k√∂nnte es weiterhin unbeabsichtigten Zugriff auf andere kritische Dateien, einschlie√ülich anderer Konfigurationsdateien, Zugriffsprotokolle und sogar verschl√ºsselter Anmeldeinformationen f√ºr die HTTP-Basisauthentifizierung, erm√∂glichen.

## Alias LFI Fehlkonfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In den Konfigurationsdateien von Nginx ist eine genaue √úberpr√ºfung der "location"-Direktiven erforderlich. Eine Schwachstelle, die als Local File Inclusion (LFI) bekannt ist, kann unbeabsichtigt durch eine Konfiguration eingef√ºhrt werden, die der folgenden √§hnelt:
```
location /imgs {
alias /path/images/;
}
```
Diese Konfiguration ist anf√§llig f√ºr LFI-Angriffe, da der Server Anfragen wie `/imgs../flag.txt` als Versuch interpretiert, auf Dateien au√üerhalb des vorgesehenen Verzeichnisses zuzugreifen, was effektiv zu `/path/images/../flag.txt` aufgel√∂st wird. Dieser Fehler erm√∂glicht es Angreifern, Dateien aus dem Dateisystem des Servers abzurufen, die nicht √ºber das Web zug√§nglich sein sollten.

Um diese Schwachstelle zu mindern, sollte die Konfiguration angepasst werden zu:
```
location /imgs/ {
alias /path/images/;
}
```
Mehr Informationen: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-Tests:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsichere Pfadbeschr√§nkung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

√úberpr√ºfen Sie die folgende Seite, um zu erfahren, wie man Direktiven wie umgeht:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Unsichere Variablenverwendung / HTTP-Anforderungsaufteilung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
Anf√§llige Variablen `$uri` und `$document_uri` und dies kann behoben werden, indem sie durch `$request_uri` ersetzt werden.

Ein Regex kann ebenfalls anf√§llig sein wie:

`location ~ /docs/([^/])? { ‚Ä¶ $1 ‚Ä¶ }` - Anf√§llig&#x20;

`location ~ /docs/([^/\s])? { ‚Ä¶ $1 ‚Ä¶ }` - Nicht anf√§llig (√ºberpr√ºft Leerzeichen)

`location ~ /docs/(.*)? { ‚Ä¶ $1 ‚Ä¶ }`  - Nicht anf√§llig
{% endhint %}

Eine Schwachstelle in der Nginx-Konfiguration wird durch das folgende Beispiel veranschaulicht:
```
location / {
return 302 https://example.com$uri;
}
```
Die Zeichen \r (Carriage Return) und \n (Line Feed) kennzeichnen Zeilenumbr√ºche in HTTP-Anfragen, und ihre URL-kodierten Formen werden als `%0d%0a` dargestellt. Das Einf√ºgen dieser Zeichen in eine Anfrage (z. B. `http://localhost/%0d%0aDetectify:%20clrf`) an einen falsch konfigurierten Server f√ºhrt dazu, dass der Server einen neuen Header mit dem Namen `Detectify` ausgibt. Dies geschieht, weil die $uri-Variable die URL-kodierten Zeilenumbr√ºche dekodiert, was zu einem unerwarteten Header in der Antwort f√ºhrt:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Lernen Sie mehr √ºber die Risiken von CRLF-Injection und Response-Splitting unter [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Diese Technik wird auch [**in diesem Vortrag erkl√§rt**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) mit einigen anf√§lligen Beispielen und Erkennungsmechanismen. Zum Beispiel, um diese Fehlkonfiguration aus einer Blackbox-Perspektive zu erkennen, k√∂nnten Sie diese Anfragen verwenden:

* `https://example.com/%20X` - Jeder HTTP-Code
* `https://example.com/%20H` - 400 Bad Request

Wenn anf√§llig, wird die erste als "X" zur√ºckgegeben, da X jede HTTP-Methode ist, und die zweite wird einen Fehler zur√ºckgeben, da H keine g√ºltige Methode ist. Der Server erh√§lt also etwas wie: `GET / H HTTP/1.1` und dies wird den Fehler ausl√∂sen.

Ein weiteres Erkennungsbeispiel w√§re:

* `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Jeder HTTP-Code
* `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Einige gefundene anf√§llige Konfigurationen, die in diesem Vortrag pr√§sentiert wurden, waren:

* Beachten Sie, wie **`$uri`** im endg√ºltigen URL so gesetzt ist, wie es ist.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Beachten Sie, wie erneut **`$uri`** in der URL ist (diesmal innerhalb eines Parameters)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Jetzt in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Any variable

Es wurde entdeckt, dass **benutzereingereichte Daten** unter bestimmten Umst√§nden als **Nginx-Variable** behandelt werden k√∂nnten. Die Ursache f√ºr dieses Verhalten bleibt etwas unklar, ist jedoch weder selten noch einfach zu √ºberpr√ºfen. Diese Anomalie wurde in einem Sicherheitsbericht auf HackerOne hervorgehoben, der [hier](https://hackerone.com/reports/370094) eingesehen werden kann. Weitere Untersuchungen der Fehlermeldung f√ºhrten zur Identifizierung ihres Auftretens innerhalb des [SSI-Filtermoduls des Nginx-Codebases](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wobei Server Side Includes (SSI) als Hauptursache festgestellt wurden.

Um diese Fehlkonfiguration zu **erkennen**, kann der folgende Befehl ausgef√ºhrt werden, der das Setzen eines Referer-Headers beinhaltet, um das Drucken von Variablen zu testen:
```bash
$ curl -H ‚ÄòReferer: bar‚Äô http://localhost/foo$http_referer | grep ‚Äòfoobar‚Äô
```
Scans f√ºr diese Fehlkonfiguration √ºber Systeme hinweg zeigten mehrere F√§lle, in denen Nginx-Variablen von einem Benutzer ausgegeben werden konnten. Ein R√ºckgang der Anzahl der verwundbaren Instanzen deutet jedoch darauf hin, dass die Bem√ºhungen, dieses Problem zu beheben, einigerma√üen erfolgreich waren.

## Rohes Backend-Antwortlesen

Nginx bietet eine Funktion √ºber `proxy_pass`, die die Abfangung von Fehlern und HTTP-Headern, die vom Backend erzeugt werden, erm√∂glicht, um interne Fehlermeldungen und Header zu verbergen. Dies wird erreicht, indem Nginx benutzerdefinierte Fehlerseiten als Antwort auf Backend-Fehler bereitstellt. Herausforderungen treten jedoch auf, wenn Nginx eine ung√ºltige HTTP-Anfrage erh√§lt. Eine solche Anfrage wird unver√§ndert an das Backend weitergeleitet, und die rohe Antwort des Backends wird dann direkt an den Client gesendet, ohne dass Nginx eingreift.

Betrachten Sie ein Beispiel-Szenario mit einer uWSGI-Anwendung:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Um dies zu verwalten, werden spezifische Direktiven in der Nginx-Konfiguration verwendet:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Diese Direktive erm√∂glicht es Nginx, eine benutzerdefinierte Antwort f√ºr Backend-Antworten mit einem Statuscode gr√∂√üer als 300 bereitzustellen. Sie stellt sicher, dass f√ºr unsere Beispiel-uWSGI-Anwendung eine `500 Error`-Antwort von Nginx abgefangen und verarbeitet wird.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Wie der Name schon sagt, verbirgt diese Direktive bestimmte HTTP-Header vor dem Client und verbessert so die Privatsph√§re und Sicherheit.

Wenn eine g√ºltige `GET`-Anfrage gestellt wird, verarbeitet Nginx sie normalerweise und gibt eine standardm√§√üige Fehlerantwort zur√ºck, ohne geheime Header offenzulegen. Eine ung√ºltige HTTP-Anfrage umgeht jedoch diesen Mechanismus, was zur Offenlegung von rohen Backend-Antworten, einschlie√ülich geheimer Header und Fehlermeldungen, f√ºhrt.

## merge\_slashes auf aus gesetzt

Standardm√§√üig ist die **`merge_slashes`-Direktive** von Nginx auf **`on`** gesetzt, was mehrere aufeinanderfolgende Schr√§gstriche in einer URL zu einem einzelnen Schr√§gstrich komprimiert. Diese Funktion, die die Verarbeitung von URLs optimiert, kann unbeabsichtigt Schwachstellen in Anwendungen hinter Nginx verbergen, insbesondere solche, die anf√§llig f√ºr lokale Datei-Inklusionsangriffe (LFI) sind. Sicherheitsexperten **Danny Robinson und Rotem Bar** haben die potenziellen Risiken hervorgehoben, die mit diesem Standardverhalten verbunden sind, insbesondere wenn Nginx als Reverse-Proxy fungiert.

Um solche Risiken zu mindern, wird empfohlen, die **`merge_slashes`-Direktive auszuschalten** f√ºr Anwendungen, die anf√§llig f√ºr diese Schwachstellen sind. Dies stellt sicher, dass Nginx Anfragen an die Anwendung weiterleitet, ohne die URL-Struktur zu √§ndern, und somit keine zugrunde liegenden Sicherheitsprobleme maskiert.

F√ºr weitere Informationen siehe [Danny Robinson und Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Wie in [**diesem Bericht**](https://mizu.re/post/cors-playground) gezeigt, gibt es bestimmte Header, die, wenn sie in der Antwort des Webservers vorhanden sind, das Verhalten des Nginx-Proxys √§ndern. Sie k√∂nnen sie [**in den Dokumenten**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) √ºberpr√ºfen:

* `X-Accel-Redirect`: Weist Nginx an, eine Anfrage intern an einen bestimmten Ort weiterzuleiten.
* `X-Accel-Buffering`: Steuert, ob Nginx die Antwort puffern soll oder nicht.
* `X-Accel-Charset`: Legt den Zeichensatz f√ºr die Antwort fest, wenn X-Accel-Redirect verwendet wird.
* `X-Accel-Expires`: Legt die Ablaufzeit f√ºr die Antwort fest, wenn X-Accel-Redirect verwendet wird.
* `X-Accel-Limit-Rate`: Begrenzung der √úbertragungsrate f√ºr Antworten, wenn X-Accel-Redirect verwendet wird.

Zum Beispiel wird der Header **`X-Accel-Redirect`** eine interne **Umleitung** in Nginx verursachen. Wenn also eine Nginx-Konfiguration mit etwas wie **`root /`** und einer Antwort vom Webserver mit **`X-Accel-Redirect: .env`** vorhanden ist, wird Nginx den Inhalt von **`/.env`** senden (Path Traversal).

### **Standardwert in der Map-Direktive**

In der **Nginx-Konfiguration** spielt die `map`-Direktive oft eine Rolle bei der **Autorisierungskontrolle**. Ein h√§ufiger Fehler besteht darin, keinen **Standard**-Wert anzugeben, was zu unbefugtem Zugriff f√ºhren k√∂nnte. Zum Beispiel:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Ohne ein `default` kann ein **b√∂swilliger Benutzer** die Sicherheit umgehen, indem er auf eine **nicht definierte URI** innerhalb von `/map-poc` zugreift. [Das Nginx-Handbuch](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html) empfiehlt, einen **Standardwert** festzulegen, um solche Probleme zu vermeiden.

### **DNS Spoofing Verwundbarkeit**

DNS-Spoofing gegen Nginx ist unter bestimmten Bedingungen m√∂glich. Wenn ein Angreifer den **DNS-Server** kennt, der von Nginx verwendet wird, und seine DNS-Abfragen abfangen kann, kann er DNS-Eintr√§ge f√§lschen. Diese Methode ist jedoch ineffektiv, wenn Nginx so konfiguriert ist, dass es **localhost (127.0.0.1)** f√ºr die DNS-Aufl√∂sung verwendet. Nginx erlaubt die Angabe eines DNS-Servers wie folgt:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` und `internal` Direktiven**

Die **`proxy_pass`** Direktive wird verwendet, um Anfragen an andere Server weiterzuleiten, entweder intern oder extern. Die **`internal`** Direktive stellt sicher, dass bestimmte Standorte nur innerhalb von Nginx zug√§nglich sind. Obwohl diese Direktiven an sich keine Schwachstellen sind, erfordert ihre Konfiguration eine sorgf√§ltige Pr√ºfung, um Sicherheitsl√ºcken zu vermeiden.

## proxy\_set\_header Upgrade & Connection

Wenn der Nginx-Server so konfiguriert ist, dass er die Upgrade- und Connection-Header weitergibt, k√∂nnte ein [**h2c Smuggling-Angriff**](../../pentesting-web/h2c-smuggling.md) durchgef√ºhrt werden, um auf gesch√ºtzte/interne Endpunkte zuzugreifen.

{% hint style="danger" %}
Diese Schwachstelle w√ºrde es einem Angreifer erm√∂glichen, **eine direkte Verbindung mit dem `proxy_pass` Endpunkt** (`http://backend:9999` in diesem Fall) herzustellen, dessen Inhalt nicht von Nginx √ºberpr√ºft wird.
{% endhint %}

Beispiel f√ºr eine verwundbare Konfiguration, um `/flag` von [hier](https://bishopfox.com/blog/h2c-smuggling-request) zu stehlen:
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Beachten Sie, dass selbst wenn `proxy_pass` auf einen bestimmten **Pfad** wie `http://backend:9999/socket.io` zeigt, die Verbindung mit `http://backend:9999` hergestellt wird, sodass Sie **jeden anderen Pfad innerhalb dieses internen Endpunkts kontaktieren k√∂nnen. Es spielt also keine Rolle, ob ein Pfad in der URL von proxy_pass angegeben ist.**
{% endhint %}

## Probieren Sie es selbst aus

Detectify hat ein GitHub-Repository erstellt, in dem Sie Docker verwenden k√∂nnen, um Ihren eigenen verwundbaren Nginx-Testserver mit einigen der in diesem Artikel besprochenen Fehlkonfigurationen einzurichten und selbst nach ihnen zu suchen!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statische Analysetools

### [GIXY](https://github.com/yandex/gixy)

Gixy ist ein Tool zur Analyse der Nginx-Konfiguration. Das Hauptziel von Gixy ist es, Sicherheitsfehlkonfigurationen zu verhindern und die Fehlererkennung zu automatisieren.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ist ein einfaches Tool, um nach h√§ufigen Nginx-Fehlkonfigurationen und -anf√§lligkeiten zu suchen.

## Referenzen

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

**Sofort verf√ºgbare Einrichtung f√ºr Schwachstellenbewertung & Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Pentest von √ºberall mit √ºber 20 Tools und Funktionen durch, die von Recon bis Reporting reichen. Wir ersetzen keine Pentester - wir entwickeln ma√ügeschneiderte Tools, Erkennungs- und Ausnutzungs-Module, um ihnen etwas Zeit zur√ºckzugeben, um tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
