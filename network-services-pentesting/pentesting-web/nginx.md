# Nginx

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="/.gitbook/assets/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Mchakato wa haraka wa kutathmini udhaifu & kupenya**. Fanya pentest kamili kutoka mahali popote na zana 20+ & vipengele vinavyotoka kwenye recon hadi ripoti. Hatubadilishi pentesters - tunatengeneza zana maalum, moduli za kugundua & kutumia ili kuwapa muda wa kuchimba zaidi, kufungua shells, na kufurahia.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Wakati wa kusanidi seva ya Nginx, **root directive** ina jukumu muhimu kwa kufafanua saraka ya msingi kutoka ambayo faili hutolewa. Fikiria mfano ulio hapa chini:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Katika usanidi huu, `/etc/nginx` imewekwa kama saraka ya mzizi. Mipangilio hii inaruhusu ufikiaji wa faili ndani ya saraka iliyoainishwa, kama vile `/hello.txt`. Hata hivyo, ni muhimu kutambua kwamba eneo maalum tu (`/hello.txt`) limeainishwa. Hakuna usanidi kwa eneo la mzizi (`location / {...}`). Kukosekana kwa hili kunamaanisha kwamba mwelekeo wa mzizi unatumika kwa ujumla, ukiruhusu maombi kwa njia ya mzizi `/` kufikia faili chini ya `/etc/nginx`.

Kipengele muhimu cha usalama kinatokea kutokana na usanidi huu. Ombi rahisi la `GET`, kama `GET /nginx.conf`, linaweza kufichua taarifa nyeti kwa kutoa faili ya usanidi wa Nginx iliyoko `/etc/nginx/nginx.conf`. Kuweka mzizi kwenye saraka isiyo nyeti sana, kama `/etc`, kunaweza kupunguza hatari hii, lakini bado kunaweza kuruhusu ufikiaji usio kusudiwa kwa faili nyingine muhimu, ikiwa ni pamoja na faili zingine za usanidi, kumbukumbu za ufikiaji, na hata akidi zilizofichwa zinazotumika kwa uthibitishaji wa msingi wa HTTP.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Katika faili za usanidi za Nginx, ukaguzi wa karibu unahitajika kwa mwelekeo wa "location". Uthibitisho wa udhaifu unaojulikana kama Local File Inclusion (LFI) unaweza kuanzishwa bila kukusudia kupitia usanidi unaofanana na yafuatayo:
```
location /imgs {
alias /path/images/;
}
```
Hii usanidi ina uwezekano wa mashambulizi ya LFI kutokana na seva kufasiri maombi kama `/imgs../flag.txt` kama jaribio la kufikia faili nje ya saraka iliyokusudiwa, ikitafsiriwa kwa ufanisi kama `/path/images/../flag.txt`. Kasoro hii inaruhusu washambuliaji kupata faili kutoka kwa mfumo wa faili wa seva ambao haupaswi kupatikana kupitia wavuti.

Ili kupunguza udhaifu huu, usanidi unapaswa kubadilishwa ili:
```
location /imgs/ {
alias /path/images/;
}
```
Zaidi ya habari: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Majaribio ya Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Hatari ya vizuizi vya njia <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Angalia ukurasa ufuatao kujifunza jinsi ya kupita maagizo kama:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Matumizi yasiyo salama ya mabadiliko / Kutenganisha Maombi ya HTTP <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
Mabadiliko yaliyo hatarini `$uri` na `$document_uri` na hii inaweza kurekebishwa kwa kuyabadilisha na `$request_uri`.

Regex inaweza pia kuwa hatarini kama:

`location ~ /docs/([^/])? { ‚Ä¶ $1 ‚Ä¶ }` - Hatarini&#x20;

`location ~ /docs/([^/\s])? { ‚Ä¶ $1 ‚Ä¶ }` - Si hatarini (kuangalia nafasi)

`location ~ /docs/(.*)? { ‚Ä¶ $1 ‚Ä¶ }`  - Si hatarini
{% endhint %}

Uthibitisho wa udhaifu katika usanidi wa Nginx unadhihirishwa na mfano hapa chini:
```
location / {
return 302 https://example.com$uri;
}
```
Mara nyingi \r (Carriage Return) na \n (Line Feed) zinaashiria wahusika wapya katika maombi ya HTTP, na aina zao za URL-encoded zinawakilishwa kama `%0d%0a`. Kuongeza wahusika hawa katika ombi (kwa mfano, `http://localhost/%0d%0aDetectify:%20clrf`) kwa seva isiyo na usanidi mzuri kunasababisha seva kutoa kichwa kipya kinachoitwa `Detectify`. Hii inatokea kwa sababu ya $uri variable inachambua wahusika wapya wa URL-encoded, na kusababisha kichwa kisichotarajiwa katika jibu:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Jifunze zaidi kuhusu hatari za CRLF injection na response splitting kwenye [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Pia, mbinu hii [**imeelezwa katika mazungumzo haya**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) ikiwa na mifano yenye udhaifu na mitambo ya kugundua. Kwa mfano, ili kugundua usakinishaji huu usio sahihi kutoka kwa mtazamo wa blackbox unaweza kutumia maombi haya:

* `https://example.com/%20X` - Kila nambari ya HTTP
* `https://example.com/%20H` - 400 Bad Request

Ikiwa kuna udhaifu, ya kwanza itarudisha kama "X" ni njia yoyote ya HTTP na ya pili itarudisha kosa kwani H si njia halali. Hivyo, seva itapokea kitu kama: `GET / H HTTP/1.1` na hii itasababisha kosa.

Mifano mingine ya kugundua ingekuwa:

* `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Kila nambari ya HTTP
* `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Baadhi ya usanidi ulio na udhaifu ulioonekana katika mazungumzo hayo ulikuwa:

* Kumbuka jinsi **`$uri`** ilivyowekwa kama ilivyo katika URL ya mwisho.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Kumbuka jinsi tena **`$uri`** iko kwenye URL (wakati huu ndani ya parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Sasa katika AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Any variable

Iligundulika kwamba **data inayotolewa na mtumiaji** inaweza kut treated kama **Nginx variable** chini ya hali fulani. Sababu ya tabia hii bado ni ngumu kidogo, lakini si ya kawaida wala rahisi kuthibitisha. Anomali hii ilisisitizwa katika ripoti ya usalama kwenye HackerOne, ambayo inaweza kuonekana [hapa](https://hackerone.com/reports/370094). Uchunguzi zaidi wa ujumbe wa kosa ulisababisha kutambua kutokea kwake ndani ya [moduli ya chujio ya SSI ya msimbo wa Nginx](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), ikitaja Server Side Includes (SSI) kama sababu kuu.

Ili **kubaini hii misconfiguration**, amri ifuatayo inaweza kutekelezwa, ambayo inahusisha kuweka kichwa cha referer ili kujaribu uchapishaji wa variable:
```bash
$ curl -H ‚ÄòReferer: bar‚Äô http://localhost/foo$http_referer | grep ‚Äòfoobar‚Äô
```
Scans for this misconfiguration across systems revealed multiple instances where Nginx variables could be printed by a user. Hata hivyo, kupungua kwa idadi ya matukio yenye hatari kunaonyesha kwamba juhudi za kurekebisha tatizo hili zimefanikiwa kwa kiasi fulani.

## Raw backend response reading

Nginx inatoa kipengele kupitia `proxy_pass` ambacho kinaruhusu kukamatwa kwa makosa na vichwa vya HTTP vinavyotolewa na backend, kwa lengo la kuficha ujumbe wa makosa ya ndani na vichwa. Hii inafanywa na Nginx ikihudumia kurasa za makosa za kawaida kama majibu ya makosa ya backend. Hata hivyo, changamoto zinatokea wakati Nginx inakutana na ombi la HTTP lisilo sahihi. Ombi kama hilo linapelekwa kwa backend kama lilivyo, na jibu la moja kwa moja la backend kisha linatumwa moja kwa moja kwa mteja bila kuingilia kati kwa Nginx.

Consider an example scenario involving a uWSGI application:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Ili kusimamia hili, maagizo maalum katika usanidi wa Nginx yanatumika:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Hii amri inaruhusu Nginx kutoa jibu maalum kwa majibu ya nyuma yenye msimbo wa hali zaidi ya 300. Inahakikisha kwamba, kwa mfano wetu wa programu ya uWSGI, jibu la `500 Error` linakamatwa na kushughulikiwa na Nginx.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Kama jina linavyopendekeza, hii amri inaficha vichwa vya HTTP vilivyotajwa kutoka kwa mteja, ikiongeza faragha na usalama.

Wakati ombi halali la `GET` linapotolewa, Nginx linafanya kazi yake kawaida, ikirudisha jibu la makosa la kawaida bila kufichua vichwa vya siri. Hata hivyo, ombi la HTTP lisilo sahihi linapita mfumo huu, na kusababisha kufichuliwa kwa majibu ya nyuma ya kawaida, ikiwa ni pamoja na vichwa vya siri na ujumbe wa makosa.

## merge\_slashes set to off

Kwa kawaida, amri ya **`merge_slashes` ya Nginx** imewekwa kuwa **`on`**, ambayo inakusanya slashi nyingi za mbele katika URL kuwa slashi moja. Kipengele hiki, ingawa kinaboresha usindikaji wa URL, kinaweza kwa bahati mbaya kuficha udhaifu katika programu zilizo nyuma ya Nginx, hasa zile zinazoweza kukabiliwa na mashambulizi ya kuingiza faili za ndani (LFI). Wataalamu wa usalama **Danny Robinson na Rotem Bar** wameonyesha hatari zinazoweza kutokea zinazohusiana na tabia hii ya kawaida, hasa wakati Nginx inafanya kazi kama reverse-proxy.

Ili kupunguza hatari kama hizo, inapendekezwa **kugeuza amri ya `merge_slashes` kuwa off** kwa programu zinazoweza kukabiliwa na udhaifu hizi. Hii inahakikisha kwamba Nginx inapeleka maombi kwa programu bila kubadilisha muundo wa URL, hivyo basi haitaweza kuficha matatizo yoyote ya usalama yaliyofichika.

Kwa maelezo zaidi angalia [Danny Robinson na Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Kama inavyoonyeshwa katika [**hii andiko**](https://mizu.re/post/cors-playground), kuna vichwa fulani ambavyo ikiwa vipo katika jibu kutoka kwa seva ya wavuti vitabadilisha tabia ya proxy ya Nginx. Unaweza kuvikagua [**katika nyaraka**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

* `X-Accel-Redirect`: Inamuru Nginx kuhamasisha ombi kwa ndani kwenye eneo lililotajwa.
* `X-Accel-Buffering`: Inadhibiti ikiwa Nginx inapaswa kubuffer jibu au la.
* `X-Accel-Charset`: Inapanga seti ya wahusika kwa jibu wakati wa kutumia X-Accel-Redirect.
* `X-Accel-Expires`: Inapanga muda wa kumalizika kwa jibu wakati wa kutumia X-Accel-Redirect.
* `X-Accel-Limit-Rate`: Inapunguza kiwango cha uhamishaji kwa majibu wakati wa kutumia X-Accel-Redirect.

Kwa mfano, kichwa **`X-Accel-Redirect`** kitasababisha **redirect** ya ndani katika nginx. Hivyo kuwa na usanidi wa nginx na kitu kama **`root /`** na jibu kutoka kwa seva ya wavuti yenye **`X-Accel-Redirect: .env`** kutaifanya nginx kutuma maudhui ya **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Katika **usanidi wa Nginx**, amri ya `map` mara nyingi ina jukumu katika **udhibiti wa mamlaka**. Kosa la kawaida ni kutoshughulikia **thamani ya default**, ambayo inaweza kusababisha ufikiaji usioidhinishwa. Kwa mfano:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bila `default`, **mtumiaji mbaya** anaweza kupita usalama kwa kufikia **URI isiyofafanuliwa** ndani ya `/map-poc`. [Mwongozo wa Nginx](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html) unashauri kuweka **thamani ya default** ili kuepuka matatizo kama haya.

### **Udhaifu wa DNS Spoofing**

DNS spoofing dhidi ya Nginx inawezekana chini ya hali fulani. Ikiwa mshambuliaji anajua **seva ya DNS** inayotumika na Nginx na anaweza kukamata maswali yake ya DNS, wanaweza kudanganya rekodi za DNS. Hata hivyo, njia hii haiwezi kufanya kazi ikiwa Nginx imewekwa kutumia **localhost (127.0.0.1)** kwa ajili ya ufumbuzi wa DNS. Nginx inaruhusu kuweka seva ya DNS kama ifuatavyo:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` na `internal` Miongozo**

Miongozo ya **`proxy_pass`** inatumika kwa ajili ya kuelekeza maombi kwa seva nyingine, ama ndani au nje. Miongozo ya **`internal`** inahakikisha kwamba maeneo fulani yanapatikana tu ndani ya Nginx. Ingawa miongozo hii si udhaifu kwa wenyewe, usanidi wao unahitaji uchunguzi wa makini ili kuzuia mapungufu ya usalama.

## proxy\_set\_header Upgrade & Connection

Ikiwa seva ya nginx imewekwa ili kupitisha vichwa vya Upgrade na Connection, [**shambulio la h2c Smuggling**](../../pentesting-web/h2c-smuggling.md) linaweza kufanywa ili kufikia mwisho wa ndani uliohifadhiwa.

{% hint style="danger" %}
Udhaifu huu utamruhusu mshambuliaji **kuanzisha muunganisho wa moja kwa moja na mwisho wa `proxy_pass`** (`http://backend:9999` katika kesi hii) ambao maudhui yake hayataangaliwa na nginx.
{% endhint %}

Mfano wa usanidi ulio hatarini kuiba `/flag` kutoka [hapa](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Kumbuka kwamba hata kama `proxy_pass` ilikuwa ikielekeza kwenye **path** maalum kama `http://backend:9999/socket.io` muunganisho utaanzishwa na `http://backend:9999` hivyo unaweza **kuwasiliana na path nyingine yoyote ndani ya mwisho huo wa ndani. Hivyo haijalishi kama path imeainishwa katika URL ya proxy_pass.**
{% endhint %}

## Jaribu mwenyewe

Detectify imeunda hazina ya GitHub ambapo unaweza kutumia Docker kuanzisha seva yako ya mtihani ya Nginx yenye udhaifu na baadhi ya makosa ya usanidi yaliyajadiliwa katika makala hii na jaribu kuyapata mwenyewe!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Zana za Mchambuzi wa Kihandisi

### [GIXY](https://github.com/yandex/gixy)

Gixy ni zana ya kuchambua usanidi wa Nginx. Lengo kuu la Gixy ni kuzuia makosa ya usalama na kuharakisha kugundua kasoro.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ni zana rahisi ya kutafuta makosa ya kawaida ya Nginx na udhaifu.

## Marejeo

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="/.gitbook/assets/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Mipangilio inayopatikana mara moja kwa ajili ya tathmini ya udhaifu & pentesting**. Fanya pentest kamili kutoka mahali popote na zana 20+ & vipengele vinavyotoka kwenye upelelezi hadi ripoti. Hatubadilishi wapentester - tunatengeneza zana maalum, moduli za kugundua & kutumia ili kuwapa muda wa kuchimba zaidi, kufungua shells, na kufurahia.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{% hint style="success" %}
Jifunze & fanya mazoezi ya AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & fanya mazoezi ya GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuatilie** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki hila za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) hazina za github.

</details>
{% endhint %}
