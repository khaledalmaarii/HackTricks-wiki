# Browser Extension Pentesting Methodology

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informazioni di base

Le estensioni del browser sono scritte in JavaScript e caricate dal browser in background. Hanno il loro [DOM](https://www.w3schools.com/js/js\_htmldom.asp) ma possono interagire con i DOM di altri siti. Ci√≤ significa che possono compromettere la riservatezza, l'integrit√† e la disponibilit√† (CIA) di altri siti.

## Componenti principali

I layout delle estensioni appaiono meglio quando visualizzati e consistono in tre componenti. Esaminiamo ciascun componente in dettaglio.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Script di contenuto**

Ogni script di contenuto ha accesso diretto al DOM di una **singola pagina web** ed √® quindi esposto a **input potenzialmente dannosi**. Tuttavia, lo script di contenuto non contiene permessi se non la possibilit√† di inviare messaggi al core dell'estensione.

### **Core dell'estensione**

Il core dell'estensione contiene la maggior parte dei privilegi/accessi dell'estensione, ma il core dell'estensione pu√≤ interagire con i contenuti web solo tramite [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) e script di contenuto. Inoltre, il core dell'estensione non ha accesso diretto alla macchina host.

### **Binary nativo**

L'estensione consente un binary nativo che pu√≤ **accedere alla macchina host con i privilegi completi dell'utente.** Il binary nativo interagisce con il core dell'estensione tramite l'interfaccia di programmazione delle applicazioni standard Netscape Plugin ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilizzata da Flash e altri plug-in del browser.

### Confini

{% hint style="danger" %}
Per ottenere i privilegi completi dell'utente, un attaccante deve convincere l'estensione a passare input dannosi dallo script di contenuto al core dell'estensione e dal core dell'estensione al binary nativo.
{% endhint %}

Ogni componente dell'estensione √® separato dagli altri da **forti confini protettivi**. Ogni componente viene eseguito in un **processo di sistema operativo separato**. Gli script di contenuto e i core delle estensioni vengono eseguiti in **processi sandbox** non disponibili per la maggior parte dei servizi del sistema operativo.

Inoltre, gli script di contenuto sono separati dalle loro pagine web associate **eseguendo in un heap JavaScript separato**. Lo script di contenuto e la pagina web hanno **accesso allo stesso DOM sottostante**, ma i due **non scambiano mai puntatori JavaScript**, prevenendo la fuoriuscita di funzionalit√† JavaScript.

## **`manifest.json`**

Un'estensione di Chrome √® semplicemente una cartella ZIP con un'estensione di file [.crx](https://www.lifewire.com/crx-file-2620391). Il core dell'estensione √® il file **`manifest.json`** nella radice della cartella, che specifica layout, permessi e altre opzioni di configurazione.

Esempio:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

I contenuti degli script vengono **caricati** ogni volta che l'utente **naviga a una pagina corrispondente**, nel nostro caso qualsiasi pagina che corrisponde all'espressione **`https://example.com/*`** e non corrisponde all'espressione regolare **`*://*/*/business*`**. Eseguono **come gli script della pagina** e hanno accesso arbitrario al [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) della pagina.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Per includere o escludere pi√π URL, √® anche possibile utilizzare **`include_globs`** e **`exclude_globs`**.

Questo √® un esempio di script di contenuto che aggiunger√† un pulsante di spiegazione alla pagina quando [l'API di archiviazione](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) per recuperare il valore `message` dallo storage dell'estensione.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Un messaggio viene inviato alle pagine dell'estensione dallo script di contenuto quando questo pulsante viene cliccato, attraverso l'utilizzo dell'[**API runtime.sendMessage()**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Questo √® dovuto alla limitazione dello script di contenuto nell'accesso diretto alle API, con `storage` che √® tra le poche eccezioni. Per funzionalit√† oltre queste eccezioni, i messaggi vengono inviati alle pagine dell'estensione con cui gli script di contenuto possono comunicare.

{% hint style="warning" %}
A seconda del browser, le capacit√† dello script di contenuto possono variare leggermente. Per i browser basati su Chromium, l'elenco delle capacit√† √® disponibile nella [documentazione degli sviluppatori di Chrome](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), e per Firefox, il [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) funge da fonte principale.\
√à anche degno di nota che gli script di contenuto hanno la capacit√† di comunicare con gli script di background, consentendo loro di eseguire azioni e trasmettere risposte.
{% endhint %}

Per visualizzare e fare debug degli script di contenuto in Chrome, il menu degli strumenti per sviluppatori di Chrome pu√≤ essere accesso da Opzioni > Altri strumenti > Strumenti per sviluppatori OPPURE premendo Ctrl + Shift + I.

Una volta visualizzati gli strumenti per sviluppatori, √® necessario cliccare sulla scheda **Sorgente**, seguita dalla scheda **Script di contenuto**. Questo consente di osservare gli script di contenuto in esecuzione da varie estensioni e di impostare punti di interruzione per tracciare il flusso di esecuzione.

### Script di contenuto iniettati

{% hint style="success" %}
Nota che **gli script di contenuto non sono obbligatori** poich√© √® anche possibile **iniettare dinamicamente** script e **iniettarli programmaticamente** nelle pagine web tramite **`tabs.executeScript`**. Questo fornisce effettivamente pi√π **controlli granulari**.
{% endhint %}

Per l'iniezione programmatica di uno script di contenuto, l'estensione deve avere [permessi di host](https://developer.chrome.com/docs/extensions/reference/permissions) per la pagina in cui gli script devono essere iniettati. Questi permessi possono essere ottenuti sia **richiedendoli** all'interno del manifesto dell'estensione sia su base temporanea tramite [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Esempio di estensione basata su activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Inietta un file JS al clic:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Inietta una funzione** al clic:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Esempio con permessi di scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
In order to include or exclude more URLs it's also possible to use **`include_globs`** and **`exclude_globs`**.

### Content Scripts `run_at`

Il campo `run_at` controlla **quando i file JavaScript vengono iniettati nella pagina web**. Il valore preferito e predefinito √® `"document_idle"`.

I valori possibili sono:

* **`document_idle`**: Ogni volta che √® possibile
* **`document_start`**: Dopo qualsiasi file da `css`, ma prima che venga costruito qualsiasi altro DOM o che venga eseguito qualsiasi altro script.
* **`document_end`**: Immediatamente dopo che il DOM √® completo, ma prima che le sottorisorse come immagini e frame siano state caricate.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Via **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

I messaggi inviati dagli script di contenuto vengono ricevuti dalla **pagina di background**, che svolge un ruolo centrale nel coordinare i componenti dell'estensione. In particolare, la pagina di background persiste per tutta la durata dell'estensione, operando discretamente senza interazione diretta dell'utente. Possiede il proprio Document Object Model (DOM), consentendo interazioni complesse e gestione dello stato.

**Punti Chiave**:

* **Ruolo della Pagina di Background:** Funziona come il centro nevralgico per l'estensione, garantendo comunicazione e coordinamento tra le varie parti dell'estensione.
* **Persistenza:** √à un'entit√† sempre presente, invisibile all'utente ma fondamentale per la funzionalit√† dell'estensione.
* **Generazione Automatica:** Se non definita esplicitamente, il browser creer√† automaticamente una pagina di background. Questa pagina generata automaticamente includer√† tutti gli script di background specificati nel manifesto dell'estensione, garantendo il funzionamento senza soluzione di continuit√† dei compiti di background dell'estensione.

{% hint style="success" %}
La comodit√† fornita dal browser nella generazione automatica di una pagina di background (quando non dichiarata esplicitamente) garantisce che tutti gli script di background necessari siano integrati e operativi, semplificando il processo di configurazione dell'estensione.
{% endhint %}

Esempio di script di background:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Utilizza l'[API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) per ascoltare i messaggi. Quando viene ricevuto un messaggio `"explain"`, utilizza l'[API tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) per aprire una pagina in una nuova scheda.

Per eseguire il debug dello script di background, puoi andare ai **dettagli dell'estensione e ispezionare il service worker,** questo aprir√† gli strumenti per sviluppatori con lo script di background:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Pagine delle opzioni e altro

Le estensioni del browser possono contenere vari tipi di pagine:

* **Le pagine di azione** vengono visualizzate in un **menu a discesa quando si fa clic sull'icona dell'estensione**.
* Pagine che l'estensione **caricher√† in una nuova scheda**.
* **Pagine delle opzioni**: Questa pagina viene visualizzata sopra l'estensione quando viene cliccata. Nel precedente manifest, nel mio caso, sono riuscito ad accedere a questa pagina in `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` o cliccando:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Nota che queste pagine non sono persistenti come le pagine di background poich√© caricano contenuti dinamicamente secondo necessit√†. Nonostante ci√≤, condividono alcune capacit√† con la pagina di background:

* **Comunicazione con gli script di contenuto:** Simile alla pagina di background, queste pagine possono ricevere messaggi dagli script di contenuto, facilitando l'interazione all'interno dell'estensione.
* **Accesso alle API specifiche dell'estensione:** Queste pagine godono di un accesso completo alle API specifiche dell'estensione, soggetto alle autorizzazioni definite per l'estensione.

### `permissions` & `host_permissions`

**`permissions`** e **`host_permissions`** sono voci del `manifest.json` che indicheranno **quali autorizzazioni** ha l'estensione del browser (memoria, posizione...) e in **quali pagine web**.

Poich√© le estensioni del browser possono essere cos√¨ **privilegiate**, una malevola o una compromessa potrebbe consentire all'attaccante **diversi mezzi per rubare informazioni sensibili e spiare l'utente**.

Controlla come funzionano queste impostazioni e come potrebbero essere abusate in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Una **politica di sicurezza dei contenuti** pu√≤ essere dichiarata anche all'interno del `manifest.json`. Se ce n'√® una definita, potrebbe essere **vulnerabile**.

L'impostazione predefinita per le pagine delle estensioni del browser √® piuttosto restrittiva:
```bash
script-src 'self'; object-src 'self';
```
Per ulteriori informazioni su CSP e potenziali bypass, controlla:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

affinch√© una pagina web possa accedere a una pagina di un'estensione del browser, ad esempio una pagina `.html`, questa pagina deve essere menzionata nel campo **`web_accessible_resources`** del `manifest.json`.\
Ad esempio:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Queste pagine sono accessibili all'URL come:
```
chrome-extension://<extension-id>/message.html
```
In public extensions the **extension-id √® accessibile**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Tuttavia, se il parametro `manifest.json` **`use_dynamic_url`** √® utilizzato, questo **id pu√≤ essere dinamico**.

{% hint style="success" %}
Nota che anche se una pagina √® menzionata qui, potrebbe essere **protetta contro il ClickJacking** grazie alla **Content Security Policy**. Quindi devi anche controllarlo (sezione frame-ancestors) prima di confermare che un attacco di ClickJacking sia possibile.
{% endhint %}

Essere autorizzati ad accedere a queste pagine rende queste pagine **potenzialmente vulnerabili al ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Consentire a queste pagine di essere caricate solo dall'estensione e non da URL casuali potrebbe prevenire attacchi di ClickJacking.
{% endhint %}

{% hint style="danger" %}
Nota che le pagine da **`web_accessible_resources`** e altre pagine dell'estensione sono anche in grado di **contattare script di background**. Quindi, se una di queste pagine √® vulnerabile a **XSS**, potrebbe aprire una vulnerabilit√† pi√π grande.

Inoltre, nota che puoi aprire solo le pagine indicate in **`web_accessible_resources`** all'interno di iframe, ma da una nuova scheda √® possibile accedere a qualsiasi pagina nell'estensione conoscendo l'ID dell'estensione. Pertanto, se viene trovata una XSS abusando degli stessi parametri, potrebbe essere abusata anche se la pagina non √® configurata in **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

Come indicato nella [**documentazione**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), La propriet√† di manifest `"externally_connectable"` dichiara **quali estensioni e pagine web possono connettersi** alla tua estensione tramite [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) e [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Se la chiave **`externally_connectable`** **non** √® dichiarata nel manifest della tua estensione o √® dichiarata come **`"ids": ["*"]`**, **tutte le estensioni possono connettersi, ma nessuna pagina web pu√≤ connettersi**.
* Se **ID specifici sono specificati**, come in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **solo quelle applicazioni** possono connettersi.
* Se sono specificati **matches**, quelle web app saranno in grado di connettersi:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Se √® specificato come vuoto: **`"externally_connectable": {}`**, nessuna app o web sar√† in grado di connettersi.

Meno **estensioni e URL** indicati qui, pi√π **piccola sar√† la superficie di attacco**.

{% hint style="danger" %}
Se una pagina web **vulnerabile a XSS o takeover** √® indicata in **`externally_connectable`**, un attaccante sar√† in grado di **inviare messaggi direttamente allo script di background**, bypassando completamente il Content Script e il suo CSP.

Pertanto, questo √® un **bypass molto potente**.

Inoltre, se il client installa un'estensione malevola, anche se non √® autorizzata a comunicare con l'estensione vulnerabile, potrebbe iniettare **dati XSS in una pagina web consentita** o abusare delle API **`WebRequest`** o **`DeclarativeNetRequest`** per manipolare le richieste su un dominio mirato alterando la richiesta di una **file JavaScript**. (Nota che il CSP sulla pagina mirata potrebbe prevenire questi attacchi). Questa idea proviene [**da questo writeup**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Riepilogo della comunicazione

### Estensione <--> WebApp

Per comunicare tra lo script di contenuto e la pagina web, di solito si utilizzano messaggi post. Pertanto, nell'applicazione web troverai di solito chiamate alla funzione **`window.postMessage`** e nello script di contenuto listener come **`window.addEventListener`**. Nota per√≤ che l'estensione potrebbe anche **comunicare con l'applicazione web inviando un Post Message** (e quindi il web dovrebbe aspettarselo) o semplicemente far caricare al web un nuovo script.

### All'interno dell'estensione

Di solito la funzione **`chrome.runtime.sendMessage`** √® utilizzata per inviare un messaggio all'interno dell'estensione (di solito gestito dallo script `background`) e per riceverlo e gestirlo viene dichiarato un listener chiamando **`chrome.runtime.onMessage.addListener`**.

√à anche possibile utilizzare **`chrome.runtime.connect()`** per avere una connessione persistente invece di inviare messaggi singoli, √® possibile utilizzarlo per **inviare** e **ricevere** **messaggi** come nel seguente esempio:

<details>

<summary><code>chrome.runtime.connect()</code> esempio</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

√à anche possibile inviare messaggi da uno script di background a uno script di contenuto situato in una scheda specifica chiamando **`chrome.tabs.sendMessage`** dove sar√† necessario indicare l'**ID della scheda** a cui inviare il messaggio.

### Da `externally_connectable` consentito all'estensione

**Le app web e le estensioni del browser esterne consentite** nella configurazione `externally_connectable` possono inviare richieste utilizzando :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Dove √® necessario menzionare l'**ID dell'estensione**.

### Messaggistica Nativa

√à possibile per gli script di background comunicare con i binari all'interno del sistema, che potrebbero essere **soggetti a vulnerabilit√† critiche come RCE** se questa comunicazione non √® adeguatamente protetta. [Di pi√π su questo pi√π tardi](./#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
## Web **‚ÜîÔ∏é** Comunicazione tra Script di Contenuto

Gli ambienti in cui operano gli **script di contenuto** e dove esistono le pagine host sono **separati** l'uno dall'altro, garantendo **isolamento**. Nonostante questo isolamento, entrambi hanno la capacit√† di interagire con il **Document Object Model (DOM)** della pagina, una risorsa condivisa. Affinch√© la pagina host possa comunicare con lo **script di contenuto**, o indirettamente con l'estensione tramite lo script di contenuto, √® necessario utilizzare il **DOM** accessibile da entrambe le parti come canale di comunicazione.

### Messaggi Post

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Una comunicazione sicura tramite Post Message dovrebbe controllare l'autenticit√† del messaggio ricevuto, questo pu√≤ essere fatto controllando:

* **`event.isTrusted`**: Questo √® True solo se l'evento √® stato attivato da un'azione dell'utente
* Lo script di contenuto potrebbe aspettarsi un messaggio solo se l'utente esegue qualche azione
* **dominio di origine**: potrebbe aspettarsi un messaggio solo da un elenco di domini autorizzati.
* Se viene utilizzata una regex, fai molta attenzione
* **Fonte**: `received_message.source !== window` pu√≤ essere utilizzato per controllare se il messaggio proviene **dalla stessa finestra** in cui lo Script di Contenuto sta ascoltando.

I controlli precedenti, anche se eseguiti, potrebbero essere vulnerabili, quindi controlla nella seguente pagina **potenziali bypass di Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Un altro possibile modo di comunicazione potrebbe essere attraverso **URL di Iframe**, puoi trovare un esempio in:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Questo non √® "esattamente" un modo di comunicazione, ma il **web e lo script di contenuto avranno accesso al DOM web**. Quindi, se lo **script di contenuto** sta leggendo alcune informazioni da esso, **fidandosi del DOM web**, il web potrebbe **modificare questi dati** (perch√© il web non dovrebbe essere fidato, o perch√© il web √® vulnerabile a XSS) e **compromettere lo Script di Contenuto**.

Puoi anche trovare un esempio di un **XSS basato su DOM per compromettere un'estensione del browser** in:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Comunicazione tra Script di Contenuto **‚ÜîÔ∏é** Script di Background

Uno Script di Contenuto pu√≤ utilizzare le funzioni [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **o** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) per inviare un messaggio **JSON-serializzabile** **una tantum**.

Per gestire la **risposta**, utilizza la **Promise** restituita. Anche se, per compatibilit√† retroattiva, puoi ancora passare un **callback** come ultimo argomento.

Inviare una richiesta da uno **script di contenuto** appare cos√¨:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Invio di una richiesta dall'**estensione** (di solito uno **script di background**). Esempio di come inviare un messaggio allo script di contenuto nella scheda selezionata:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Sul **lato ricevente**, √® necessario impostare un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **listener di eventi** per gestire il messaggio. Questo appare lo stesso da uno script di contenuto o da una pagina di estensione.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Nell'esempio evidenziato, **`sendResponse()`** √® stato eseguito in modo sincrono. Per modificare il gestore dell'evento `onMessage` per l'esecuzione asincrona di `sendResponse()`, √® imperativo incorporare `return true;`.

Una considerazione importante √® che negli scenari in cui pi√π pagine sono impostate per ricevere eventi `onMessage`, **la prima pagina a eseguire `sendResponse()`** per un evento specifico sar√† l'unica in grado di fornire la risposta in modo efficace. Qualsiasi risposta successiva allo stesso evento non sar√† presa in considerazione.

Quando si creano nuove estensioni, la preferenza dovrebbe essere per le promesse piuttosto che per i callback. Per quanto riguarda l'uso dei callback, la funzione `sendResponse()` √® considerata valida solo se viene eseguita direttamente all'interno del contesto sincrono, o se il gestore dell'evento indica un'operazione asincrona restituendo `true`. Se nessuno dei gestori restituisce `true` o se la funzione `sendResponse()` viene rimossa dalla memoria (garbage-collected), il callback associato alla funzione `sendMessage()` verr√† attivato per impostazione predefinita.

## Native Messaging

Le estensioni del browser consentono anche di comunicare con **binaries nel sistema tramite stdin**. L'applicazione deve installare un json che lo indica in un json come:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Dove il `name` √® la stringa passata a [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) o [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) per comunicare con l'applicazione dagli script di background dell'estensione del browser. Il `path` √® il percorso del binario, c'√® solo 1 `type` valido che √® stdio (usa stdin e stdout) e gli `allowed_origins` indicano le estensioni che possono accedervi (e non possono avere caratteri jolly).

Chrome/Chromium cercher√† questo json in alcuni registri di Windows e in alcuni percorsi in macOS e Linux (maggiori informazioni nella [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

{% hint style="success" %}
L'estensione del browser ha anche bisogno del permesso `nativeMessaing` dichiarato per poter utilizzare questa comunicazione.
{% endhint %}

Questo √® come appare un codice di script di background che invia messaggi a un'applicazione nativa:
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
In [**questo post del blog**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), viene proposto un modello vulnerabile che abusa dei messaggi nativi:

1. L'estensione del browser ha un modello wildcard per lo script di contenuto.
2. Lo script di contenuto passa i messaggi `postMessage` allo script di background utilizzando `sendMessage`.
3. Lo script di background passa il messaggio all'applicazione nativa utilizzando `sendNativeMessage`.
4. L'applicazione nativa gestisce il messaggio in modo pericoloso, portando all'esecuzione di codice.

E all'interno di esso viene spiegato un esempio di **passare da qualsiasi pagina a RCE abusando di un'estensione del browser**.

## Informazioni Sensibili in Memoria/Codice/Clipboard

Se un'estensione del browser memorizza **informazioni sensibili all'interno della sua memoria**, queste potrebbero essere **estratte** (soprattutto su macchine Windows) e **cercate** per queste informazioni.

Pertanto, la memoria dell'estensione del browser **non dovrebbe essere considerata sicura** e **informazioni sensibili** come credenziali o frasi mnemoniche **non dovrebbero essere memorizzate**.

Naturalmente, **non mettere informazioni sensibili nel codice**, poich√© saranno **pubbliche**.

Per estrarre la memoria dal browser, puoi **estrarre la memoria del processo** oppure andare alle **impostazioni** dell'estensione del browser cliccando su **`Ispeziona pop-up`** -> Nella sezione **`Memoria`** -> **`Prendi uno snapshot`** e **`CTRL+F`** per cercare all'interno dello snapshot informazioni sensibili.

Inoltre, informazioni altamente sensibili come chiavi mnemoniche o password **non dovrebbero poter essere copiate negli appunti** (o almeno rimuoverle dagli appunti dopo pochi secondi) perch√© i processi che monitorano gli appunti potrebbero ottenerle.

## Caricamento di un'Estensione nel Browser

1. **Scarica** l'estensione del browser & decomprimi
2. Vai su **`chrome://extensions/`** e **abilita** la `Modalit√† Sviluppatore`
3. Clicca sul pulsante **`Carica non impacchettata`**

In **Firefox** vai su **`about:debugging#/runtime/this-firefox`** e clicca sul pulsante **`Carica componente aggiuntivo temporaneo`**.

## Ottenere il codice sorgente dallo store

Il codice sorgente di un'estensione Chrome pu√≤ essere ottenuto attraverso vari metodi. Di seguito sono fornite spiegazioni dettagliate e istruzioni per ciascuna opzione.

### Scarica l'Estensione come ZIP tramite Linea di Comando

Il codice sorgente di un'estensione Chrome pu√≤ essere scaricato come file ZIP utilizzando la linea di comando. Questo comporta l'uso di `curl` per recuperare il file ZIP da un URL specifico e poi estrarre il contenuto del file ZIP in una directory. Ecco i passaggi:

1. Sostituisci `"extension_id"` con l'ID effettivo dell'estensione.
2. Esegui i seguenti comandi:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Usa il sito CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Usa l'estensione CRX Viewer

Un altro metodo conveniente √® utilizzare il Chrome Extension Source Viewer, che √® un progetto open-source. Pu√≤ essere installato dal [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Il codice sorgente del visualizzatore √® disponibile nel suo [repository GitHub](https://github.com/Rob--W/crxviewer).

### Visualizza il sorgente dell'estensione installata localmente

Le estensioni di Chrome installate localmente possono essere ispezionate. Ecco come:

1. Accedi alla directory del tuo profilo locale di Chrome visitando `chrome://version/` e localizzando il campo "Profile Path".
2. Naviga nella sottocartella `Extensions/` all'interno della directory del profilo.
3. Questa cartella contiene tutte le estensioni installate, tipicamente con il loro codice sorgente in un formato leggibile.

Per identificare le estensioni, puoi mappare i loro ID ai nomi:

* Abilita la Modalit√† Sviluppatore nella pagina `about:extensions` per vedere gli ID di ciascuna estensione.
* All'interno della cartella di ciascuna estensione, il file `manifest.json` contiene un campo `name` leggibile, che ti aiuta a identificare l'estensione.

### Usa un File Archiver o Unpacker

Vai al Chrome Web Store e scarica l'estensione. Il file avr√† un'estensione `.crx`. Cambia l'estensione del file da `.crx` a `.zip`. Usa qualsiasi file archiver (come WinRAR, 7-Zip, ecc.) per estrarre il contenuto del file ZIP.

### Usa la Modalit√† Sviluppatore in Chrome

Apri Chrome e vai su `chrome://extensions/`. Abilita "Modalit√† sviluppatore" in alto a destra. Clicca su "Carica estensione non pacchettizzata...". Naviga nella directory della tua estensione. Questo non scarica il codice sorgente, ma √® utile per visualizzare e modificare il codice di un'estensione gi√† scaricata o sviluppata.

## Dataset del manifesto delle estensioni di Chrome

Per cercare di individuare estensioni del browser vulnerabili, puoi utilizzare il [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) e controllare i loro file di manifesto per segni potenzialmente vulnerabili. Ad esempio, per controllare le estensioni con pi√π di 25000 utenti, `content_scripts` e il permesso `nativeMessaing`:

{% code overflow="wrap" %}
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
{% endcode %}

## Checklist di Audit di Sicurezza

Anche se le Estensioni del Browser hanno una **superficie di attacco limitata**, alcune di esse potrebbero contenere **vulnerabilit√†** o **miglioramenti potenziali di indurimento**. Le seguenti sono le pi√π comuni:

* [ ] **Limitare** il pi√π possibile le **`permissions`** richieste
* [ ] **Limitare** il pi√π possibile le **`host_permissions`**
* [ ] Utilizzare una **forte** **`content_security_policy`**
* [ ] **Limitare** il pi√π possibile il **`externally_connectable`**, se non √® necessario e possibile, non lasciarlo di default, specificare **`{}`**
* [ ] Se qui √® menzionato un **URL vulnerabile a XSS o a takeover**, un attaccante sar√† in grado di **inviare messaggi agli script di background direttamente**. Bypass molto potente.
* [ ] **Limitare** il pi√π possibile le **`web_accessible_resources`**, anche vuote se possibile.
* [ ] Se **`web_accessible_resources`** non √® nullo, controllare per [**ClickJacking**](browext-clickjacking.md)
* [ ] Se avviene qualsiasi **comunicazione** dall'**estensione** alla **pagina web**, [**controllare per vulnerabilit√† XSS**](browext-xss-example.md) causate nella comunicazione.
* [ ] Se vengono utilizzati Post Messages, controllare per [**vulnerabilit√† Post Message**](../postmessage-vulnerabilities/)**.**
* [ ] Se il **Content Script accede ai dettagli del DOM**, controllare che non **stia introducendo un XSS** se viene **modificato** dal web
* [ ] Fare particolare attenzione se questa comunicazione √® coinvolta anche nella **comunicazione Content Script -> Background script**
* [ ] Se lo script di background comunica tramite **native messaging**, controllare che la comunicazione sia sicura e sanificata
* [ ] **Le informazioni sensibili non dovrebbero essere memorizzate** all'interno del codice dell'Estensione del Browser
* [ ] **Le informazioni sensibili non dovrebbero essere memorizzate** all'interno della memoria dell'Estensione del Browser
* [ ] **Le informazioni sensibili non dovrebbero essere memorizzate** all'interno del **file system non protetto**

## Strumenti

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Estrae qualsiasi estensione Chrome da un link fornito del Chrome webstore.
* Visualizzatore di [**manifest.json**](https://developer.chrome.com/extensions/manifest): visualizza semplicemente una versione JSON formattata del manifesto dell'estensione.
* **Analisi del Fingerprint**: Rilevamento di [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) e generazione automatica di JavaScript per il fingerprinting delle estensioni Chrome.
* **Analisi Potenziale di Clickjacking**: Rilevamento di pagine HTML dell'estensione con la direttiva [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) impostata. Queste sono potenzialmente vulnerabili al clickjacking a seconda dello scopo delle pagine.
* Visualizzatore di **Avvisi di Permesso**: che mostra un elenco di tutti gli avvisi di richiesta di permesso di Chrome che verranno visualizzati quando un utente tenta di installare l'estensione.
* **Funzione(i) Pericolosa(e)**: mostra la posizione delle funzioni pericolose che potrebbero essere potenzialmente sfruttate da un attaccante (ad es. funzioni come innerHTML, chrome.tabs.executeScript).
* **Punto(i) di Entrata**: mostra dove l'estensione riceve input da utenti/esterni. Questo √® utile per comprendere l'area di superficie di un'estensione e cercare potenziali punti per inviare dati malevoli all'estensione.
* Sia gli scanner di Funzione(i) Pericolosa(e) che di Punto(i) di Entrata hanno quanto segue per i loro avvisi generati:
* Frammento di codice pertinente e riga che ha causato l'avviso.
* Descrizione del problema.
* Un pulsante "Visualizza File" per visualizzare il file sorgente completo contenente il codice.
* Il percorso del file avvisato.
* L'URI completo dell'estensione Chrome del file avvisato.
* Il tipo di file, come uno script di Pagina di Background, Content Script, Azione del Browser, ecc.
* Se la riga vulnerabile √® in un file JavaScript, i percorsi di tutte le pagine in cui √® inclusa, cos√¨ come il tipo di queste pagine e lo stato di [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Analizzatore di Content Security Policy (CSP) e controllore di bypass**: Questo evidenzier√† le debolezze nella CSP della tua estensione e illuminer√† anche eventuali modi potenziali per bypassare la tua CSP a causa di CDN autorizzati, ecc.
* **Librerie Vulnerabili Conosciute**: Questo utilizza [Retire.js](https://retirejs.github.io/retire.js/) per controllare l'uso di librerie JavaScript note come vulnerabili.
* Scarica l'estensione e versioni formattate.
* Scarica l'estensione originale.
* Scarica una versione abbellita dell'estensione (HTML e JavaScript auto formattati).
* Caching automatico dei risultati della scansione, eseguire una scansione dell'estensione richieder√† un buon tempo la prima volta che la esegui. Tuttavia, la seconda volta, assumendo che l'estensione non sia stata aggiornata, sar√† quasi istantanea grazie ai risultati memorizzati nella cache.
* URL di Report linkabili, facilmente collegabili a qualcun altro a un report di estensione generato da tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Il progetto Neto √® un pacchetto Python 3 concepito per analizzare e svelare funzionalit√† nascoste di plugin e estensioni del browser per browser ben noti come Firefox e Chrome. Automatizza il processo di estrazione dei file impacchettati per estrarre queste funzionalit√† da risorse pertinenti in un'estensione come `manifest.json`, cartelle di localizzazione o file sorgente Javascript e HTML.

## Riferimenti

* **Grazie a** [**@naivenom**](https://twitter.com/naivenom) **per l'aiuto con questa metodologia**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
