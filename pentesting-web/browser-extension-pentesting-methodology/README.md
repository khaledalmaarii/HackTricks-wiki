# Browser Extension Pentesting Methodology

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Extensions za kivinjari zimeandikwa kwa JavaScript na zinapakiwa na kivinjari kwa nyuma. Ina [DOM](https://www.w3schools.com/js/js\_htmldom.asp) yake lakini inaweza kuingiliana na DOM za tovuti nyingine. Hii inamaanisha kwamba inaweza kuhatarisha usiri, uadilifu, na upatikanaji (CIA) wa tovuti nyingine.

## Main Components

Muundo wa nyongeza unaonekana bora unapofikiriwa na unajumuisha vipengele vitatu. Hebu tuangalie kila kipengele kwa undani.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Content Scripts**

Kila script ya maudhui ina ufikiaji wa moja kwa moja kwa DOM ya **ukurasa mmoja wa wavuti** na hivyo inakabiliwa na **ingizo linaloweza kuwa na uharibifu**. Hata hivyo, script ya maudhui haina ruhusa zaidi ya uwezo wa kutuma ujumbe kwa msingi wa nyongeza.

### **Extension Core**

Msingi wa nyongeza unajumuisha ruhusa nyingi za nyongeza, lakini msingi wa nyongeza unaweza kuingiliana tu na maudhui ya wavuti kupitia [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) na scripts za maudhui. Pia, msingi wa nyongeza hauna ufikiaji wa moja kwa moja kwa mashine mwenyeji.

### **Native Binary**

Nyongeza inaruhusu binary asilia ambayo inaweza **kufikia mashine mwenyeji kwa ruhusa kamili ya mtumiaji.** Binary asilia inaingiliana na msingi wa nyongeza kupitia Kiolesura cha Programu ya Plugin ya Netscape ya kawaida ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) inayotumiwa na Flash na nyongeza nyingine za kivinjari.

### Boundaries

{% hint style="danger" %}
Ili kupata ruhusa kamili za mtumiaji, mshambuliaji lazima amshawishi nyongeza kupitisha ingizo la uharibifu kutoka kwa script ya maudhui hadi msingi wa nyongeza na kutoka kwa msingi wa nyongeza hadi binary asilia.
{% endhint %}

Kila kipengele cha nyongeza kimewekwa mbali na kingine kwa **mipaka yenye ulinzi mkali**. Kila kipengele kinakimbia katika **mchakato tofauti wa mfumo wa uendeshaji**. Scripts za maudhui na msingi wa nyongeza zinakimbia katika **mchakato wa sandbox** ambao haupatikani kwa huduma nyingi za mfumo wa uendeshaji.

Zaidi ya hayo, scripts za maudhui ziko mbali na kurasa zao za wavuti zinazohusiana kwa **kukimbia katika heap tofauti ya JavaScript**. Script ya maudhui na ukurasa wa wavuti zina **ufikiaji wa DOM sawa ya msingi**, lakini hizo mbili **hazibadilishani viashiria vya JavaScript**, kuzuia kuvuja kwa kazi za JavaScript.

## **`manifest.json`**

Nyongeza ya Chrome ni tu folda ya ZIP yenye [.crx file extension](https://www.lifewire.com/crx-file-2620391). Msingi wa nyongeza ni **`manifest.json`** faili katika mzizi wa folda, ambayo inaelezea muundo, ruhusa, na chaguzi zingine za usanidi.

Example:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content scripts zinapakiwa kila wakati mtumiaji anapohamia kwenye ukurasa unaolingana, katika kesi yetu ukurasa wowote unaolingana na **`https://example.com/*`** na usiozingatia regex ya **`*://*/*/business*`**. Zinatekelezwa **kama vile scripts za ukurasa wenyewe** na zina ufikiaji wa kiholela kwa [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) wa ukurasa.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Ili kujumuisha au kutengwa kwa URLs zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

Hii ni mfano wa skripti ya maudhui ambayo itaongeza kitufe cha maelezo kwenye ukurasa wakati [API ya hifadhi](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) inatumika kupata thamani ya `message` kutoka kwenye hifadhi ya nyongeza.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Ujumbe unatumwa kwa kurasa za nyongeza na skripti ya maudhui wakati kitufe hiki kinapobonyezwa, kupitia matumizi ya [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Hii ni kutokana na kikomo cha skripti ya maudhui katika ufikiaji wa moja kwa moja wa APIs, ambapo `storage` ni miongoni mwa visÿ´i vichache. Kwa kazi zaidi ya visÿ´i hivi, ujumbe unatumwa kwa kurasa za nyongeza ambazo skripti za maudhui zinaweza kuwasiliana nazo.

{% hint style="warning" %}
Kulingana na kivinjari, uwezo wa skripti za maudhui unaweza kutofautiana kidogo. Kwa kivinjari kinachotegemea Chromium, orodha ya uwezo inapatikana katika [Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), na kwa Firefox, [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) inatumika kama chanzo kikuu.\
Pia ni muhimu kutambua kwamba skripti za maudhui zina uwezo wa kuwasiliana na skripti za nyuma, na kuwapa uwezo wa kutekeleza vitendo na kurudisha majibu.
{% endhint %}

Ili kuona na kufanyia kazi skripti za maudhui katika Chrome, menyu ya zana za maendeleo za Chrome inaweza kufikiwa kutoka Chaguo > Zana zaidi > Zana za maendeleo AU kwa kubonyeza Ctrl + Shift + I.

Baada ya zana za maendeleo kuonyeshwa, **tab ya Chanzo** inapaswa kubonyezwa, ikifuatiwa na tab ya **Skripti za Maudhui**. Hii inaruhusu kuangalia skripti za maudhui zinazotumika kutoka nyongeza mbalimbali na kuweka alama za kuvunja ili kufuatilia mtiririko wa utekelezaji.

### Skripti za maudhui zilizowekwa

{% hint style="success" %}
Kumbuka kwamba **Skripti za Maudhui si lazima** kwani pia inawezekana **kudumu** **kuweka** skripti na **kuziweka kimaandishi** kwenye kurasa za wavuti kupitia **`tabs.executeScript`**. Hii kwa kweli inatoa **udhibiti wa kina** zaidi.
{% endhint %}

Ili kuweka skripti ya maudhui kimaandishi, nyongeza inahitaji kuwa na [idhini za mwenyeji](https://developer.chrome.com/docs/extensions/reference/permissions) kwa ukurasa ambao skripti zitakazo wekwa. Idhini hizi zinaweza kupatikana kwa **kuziomba** ndani ya hati ya nyongeza au kwa msingi wa muda kupitia [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Mfano wa nyongeza inayotegemea activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Ingiza faili la JS kwa kubonyeza:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Weka kazi** kwa kubonyeza:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Mfano na ruhusa za skripti
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Ili kujumuisha au kutengwa kwa URLs zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

### Content Scripts `run_at`

Sehemu ya `run_at` inasimamia **wakati faili za JavaScript zinapoinjizwa kwenye ukurasa wa wavuti**. Thamani inayopendekezwa na ya default ni `"document_idle"`.

Thamani zinazowezekana ni:

* **`document_idle`**: Wakati wowote iwezekanavyo
* **`document_start`**: Baada ya faili zozote kutoka `css`, lakini kabla ya DOM nyingine yoyote kujengwa au script nyingine yoyote kuendeshwa.
* **`document_end`**: Mara moja baada ya DOM kukamilika, lakini kabla ya rasilimali ndogo kama picha na fremu kupakiwa.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Kupitia **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

Meseji zinazotumwa na scripts za maudhui zinapokelewa na **background page**, ambayo ina jukumu kuu katika kuratibu vipengele vya nyongeza. Kwa kuzingatia, background page inadumu wakati wa maisha ya nyongeza, ikifanya kazi kwa siri bila mwingiliano wa moja kwa moja na mtumiaji. Ina Document Object Model (DOM) yake mwenyewe, ikiruhusu mwingiliano tata na usimamizi wa hali.

**Mambo Muhimu**:

* **Jukumu la Background Page:** Inafanya kazi kama kituo cha neva kwa nyongeza, kuhakikisha mawasiliano na uratibu kati ya sehemu mbalimbali za nyongeza.
* **Uendelevu:** Ni kiumbe kilichopo kila wakati, kisichoonekana kwa mtumiaji lakini muhimu kwa utendaji wa nyongeza.
* **Uundaji Otomatiki:** Ikiwa haijafafanuliwa wazi, kivinjari kitaunda kiotomatiki background page. Ukurasa huu ulioundwa kiotomatiki utajumuisha scripts zote za background zilizotajwa katika hati ya nyongeza, kuhakikisha uendeshaji usio na mshono wa kazi za background za nyongeza.

{% hint style="success" %}
Urahisi unaotolewa na kivinjari katika kuunda kiotomatiki background page (wakati haijatangazwa wazi) unahakikisha kuwa scripts zote muhimu za background zimejumuishwa na zinafanya kazi, zikifanya mchakato wa kuweka nyongeza kuwa rahisi.
{% endhint %}

Mfano wa script ya background:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Inatumia [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) kusikiliza ujumbe. Wakati ujumbe wa `"explain"` unapopokelewa, inatumia [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) kufungua ukurasa katika tab mpya.

Ili kubaini makosa katika skripti ya nyuma unaweza kwenda kwenye **maelezo ya nyongeza na kukagua huduma ya mfanyakazi,** hii itafungua zana za maendeleo na skripti ya nyuma:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Kurasa za chaguo na nyingine

Nyongeza za kivinjari zinaweza kuwa na aina mbalimbali za kurasa:

* **Kurasa za hatua** zinaonyeshwa katika **orodha ya kushuka wakati ikoni ya nyongeza** inabonyezwa.
* Kurasa ambazo nyongeza it **pakia katika tab mpya**.
* **Kurasa za Chaguo**: Ukurasa huu unaonyeshwa juu ya nyongeza wakati unabonyezwa. Katika hati ya awali Katika kesi yangu niliweza kufikia ukurasa huu katika `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` au kubonyeza:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Kumbuka kwamba kurasa hizi si za kudumu kama kurasa za nyuma kwani zinapakia maudhui kwa njia ya kidinamikali kulingana na mahitaji. Licha ya hili, zinashiriki uwezo fulani na ukurasa wa nyuma:

* **Mawasiliano na Skripti za Maudhui:** Kama ilivyo kwa ukurasa wa nyuma, kurasa hizi zinaweza kupokea ujumbe kutoka kwa skripti za maudhui, kurahisisha mwingiliano ndani ya nyongeza.
* **Upatikanaji wa APIs za Maalum za Nyongeza:** Kurasa hizi zinafurahia upatikanaji mpana wa APIs maalum za nyongeza, kulingana na ruhusa zilizofafanuliwa kwa nyongeza.

### `permissions` & `host_permissions`

**`permissions`** na **`host_permissions`** ni entries kutoka `manifest.json` ambazo zitaonyesha **ni ruhusa zipi** nyongeza za kivinjari zina (hifadhi, eneo...) na **katika kurasa zipi za wavuti**.

Kama nyongeza za kivinjari zinaweza kuwa na **mamlaka makubwa**, moja mbaya au moja iliyovunjwa inaweza kumruhusu mshambuliaji **njia tofauti za kuiba taarifa nyeti na kupeleleza mtumiaji**.

Angalia jinsi mipangilio hii inavyofanya kazi na jinsi inaweza kutumika vibaya katika:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

**sera ya usalama wa maudhui** inaweza kutangazwa pia ndani ya `manifest.json`. Ikiwa kuna moja iliyofafanuliwa, inaweza kuwa **hatari**.

Mipangilio ya default kwa kurasa za nyongeza za kivinjari ni ya kukatisha tamaa:
```bash
script-src 'self'; object-src 'self';
```
Kwa maelezo zaidi kuhusu CSP na uwezekano wa kupita angalia:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

ili ukurasa wa wavuti uweze kufikia ukurasa wa Kiongezeo cha Kivinjari, ukurasa wa `.html` kwa mfano, ukurasa huu unahitaji kutajwa katika uwanja wa **`web_accessible_resources`** wa `manifest.json`.\
Kwa mfano:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Hizi kurasa zinapatikana katika URL kama:
```
chrome-extension://<extension-id>/message.html
```
Katika nyongeza za umma, **extension-id inapatikana**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Hata hivyo, ikiwa parameter ya `manifest.json` **`use_dynamic_url`** inatumika, **id hii inaweza kuwa ya dinamik**.

{% hint style="success" %}
Kumbuka kwamba hata kama ukurasa umeelezewa hapa, unaweza kuwa **ulindwa dhidi ya ClickJacking** kutokana na **Content Security Policy**. Hivyo unahitaji kuangalia pia (sehemu ya frame-ancestors) kabla ya kuthibitisha kuwa shambulio la ClickJacking linawezekana.
{% endhint %}

Kuruhusiwa kufikia kurasa hizi kunafanya kurasa hizi **kuwa na uwezekano wa kuwa na udhaifu wa ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Kuruhusu kurasa hizi kupakuliwa tu na nyongeza na si kwa URL za nasibu kunaweza kuzuia shambulio la ClickJacking.
{% endhint %}

{% hint style="danger" %}
Kumbuka kwamba kurasa kutoka **`web_accessible_resources`** na kurasa nyingine za nyongeza pia zina uwezo wa **kuwasiliana na scripts za nyuma**. Hivyo ikiwa moja ya kurasa hizi ina udhaifu wa **XSS** inaweza kufungua udhaifu mkubwa zaidi.

Zaidi ya hayo, kumbuka kwamba unaweza kufungua tu kurasa zilizoonyeshwa katika **`web_accessible_resources`** ndani ya iframes, lakini kutoka kwenye tab mpya inawezekana kufikia ukurasa wowote katika nyongeza ukijua extension ID. Hivyo, ikiwa XSS inapatikana ikitumia vigezo sawa, inaweza kutumika hata kama ukurasa haujawekwa katika **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

Kulingana na [**docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), mali ya `"externally_connectable"` ya manifest inatangaza **ni nyongeza zipi na kurasa za wavuti zipi zinaweza kuungana** na nyongeza yako kupitia [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) na [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Ikiwa ufunguo wa **`externally_connectable`** **haujaelezwa** katika manifest ya nyongeza yako au umeelezwa kama **`"ids": ["*"]`**, **nyongeza zote zinaweza kuungana, lakini hakuna kurasa za wavuti zinaweza kuungana**.
* Ikiwa **IDs maalum zimeelezwa**, kama katika `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **tu programu hizo** zinaweza kuungana.
* Ikiwa **mifano** imeelezwa, programu hizo za wavuti zitakuwa na uwezo wa kuungana:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Ikiwa imeelezwa kama tupu: **`"externally_connectable": {}`**, hakuna programu au wavuti itakayoweza kuungana.

**Idadi ndogo ya nyongeza na URL** zilizoorodheshwa hapa, **uso wa shambulio** utakuwa mdogo.

{% hint style="danger" %}
Ikiwa ukurasa wa wavuti **unaotetereka kwa XSS au takeover** umeonyeshwa katika **`externally_connectable`**, mshambuliaji ataweza **kutuma ujumbe moja kwa moja kwa skripti ya nyuma**, akipita kabisa Skripti ya Maudhui na CSP yake.

Hivyo, hii ni **kikosi cha kupita nguvu sana**.

Zaidi ya hayo, ikiwa mteja ataweka nyongeza ya uongo, hata kama hairuhusiwi kuwasiliana na nyongeza inayotetereka, inaweza kuingiza **data za XSS katika ukurasa wa wavuti ulio ruhusiwa** au kutumia **`WebRequest`** au **`DeclarativeNetRequest`** APIs kudhibiti maombi kwenye kikoa kilicholengwa kubadilisha ombi la ukurasa kwa **faili ya JavaScript**. (Kumbuka kwamba CSP kwenye ukurasa ulio kwenye lengo inaweza kuzuia mashambulizi haya). Wazo hili linatokana na [**hiki andiko**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Muhtasari wa mawasiliano

### Nyongeza <--> WebApp

Ili kuwasiliana kati ya skripti ya maudhui na ukurasa wa wavuti, ujumbe wa baada ya kawaida hutumiwa. Hivyo, katika programu ya wavuti mara nyingi utapata simu za kazi **`window.postMessage`** na katika skripti ya maudhui wasikilizaji kama **`window.addEventListener`**. Tafadhali kumbuka, hata hivyo, kwamba nyongeza inaweza pia **kuwasiliana na programu ya wavuti ikituma Ujumbe wa Post** (na hivyo wavuti inapaswa kuutarajia) au tu kufanya wavuti ipakue skripti mpya.

### Ndani ya nyongeza

Kawaida kazi **`chrome.runtime.sendMessage`** hutumiwa kutuma ujumbe ndani ya nyongeza (kawaida inashughulikiwa na skripti ya `background`) na ili kupokea na kushughulikia inatangazwa msikilizaji akitumia **`chrome.runtime.onMessage.addListener`**.

Pia inawezekana kutumia **`chrome.runtime.connect()`** kuwa na muunganisho endelevu badala ya kutuma ujumbe mmoja mmoja, inawezekana kuitumia **kutuma** na **kupokea** **ujumbe** kama katika mfano ufuatao:

<details>

<summary><code>chrome.runtime.connect()</code> mfano</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Pia inawezekana kutuma ujumbe kutoka kwa script ya nyuma hadi script ya maudhui iliyoko katika tab maalum kwa kuita **`chrome.tabs.sendMessage`** ambapo utahitaji kuonyesha **ID ya tab** ya kutuma ujumbe.

### Kutoka kwa `externally_connectable` inayoruhusiwa hadi nyongeza

**Programu za wavuti na nyongeza za kivinjari za nje zinazoruhusiwa** katika usanidi wa `externally_connectable` zinaweza kutuma maombi kwa kutumia:
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Mahali inahitajika kutaja **extension ID**.

### Native Messaging

Inawezekana kwa scripts za background kuwasiliana na binaries ndani ya mfumo, ambayo yanaweza kuwa **na udhaifu mkubwa kama RCEs** ikiwa mawasiliano haya hayajashughulikiwa ipasavyo. [Zaidi kuhusu hii baadaye](./#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
## Web **‚ÜîÔ∏é** Mawasiliano ya Skripti za Maudhui

Mazingira ambapo **skripti za maudhui** zinafanya kazi na ambapo kurasa za mwenyeji zipo ni **separated** kutoka kwa kila mmoja, kuhakikisha **isolation**. Licha ya **isolation** hii, zote zina uwezo wa kuingiliana na **Document Object Model (DOM)** ya ukurasa, rasilimali inayoshirikiwa. Ili ukurasa wa mwenyeji ushirikiane na **skripti ya maudhui**, au kwa njia isiyo ya moja kwa moja na nyongeza kupitia skripti ya maudhui, inahitajika kutumia **DOM** ambayo inapatikana na pande zote kama njia ya mawasiliano.

### Post Messages

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Mawasiliano salama ya Post Message inapaswa kuangalia uhalali wa ujumbe ulipokelewa, hii inaweza kufanywa kwa kuangalia:

* **`event.isTrusted`**: Hii ni Kweli tu ikiwa tukio lilichochewa na kitendo cha mtumiaji
* Skripti ya maudhui inaweza kutarajia ujumbe tu ikiwa mtumiaji atafanya kitendo fulani
* **domain ya asili**: inaweza kutarajia ujumbe tu kutoka kwenye orodha ya domain zilizoidhinishwa.
* Ikiwa regex inatumika, kuwa makini sana
* **Chanzo**: `received_message.source !== window` inaweza kutumika kuangalia ikiwa ujumbe ulikuwa **kutoka kwenye dirisha lile lile** ambapo Skripti ya Maudhui inasikiliza.

Ukaguzi wa awali, hata kama umefanywa, unaweza kuwa na udhaifu, hivyo angalia kwenye ukurasa ufuatao **uwezekano wa Post Message bypasses**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Njia nyingine inayowezekana ya mawasiliano inaweza kuwa kupitia **Iframe URLs**, unaweza kupata mfano katika:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Hii si "haswa" njia ya mawasiliano, lakini **mtandao na skripti ya maudhui zitakuwa na ufikiaji wa DOM ya wavuti**. Hivyo, ikiwa **skripti ya maudhui** inasoma taarifa fulani kutoka kwake, **ikitegemea DOM ya wavuti**, wavuti inaweza **kubadilisha data hii** (kwa sababu wavuti haipaswi kuaminika, au kwa sababu wavuti ina udhaifu wa XSS) na **kuathiri Skripti ya Maudhui**.

Unaweza pia kupata mfano wa **XSS inayotegemea DOM kuathiri nyongeza ya kivinjari** katika:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Mawasiliano ya Skripti ya Maudhui **‚ÜîÔ∏é** Skripti ya Nyuma

Skripti ya Maudhui inaweza kutumia kazi [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **au** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) kutuma ujumbe **wa mara moja unaoweza kuwasilishwa kwa JSON**.

Ili kushughulikia **jibu**, tumia **Promise** iliyorejeshwa. Ingawa, kwa ajili ya ulinganifu wa nyuma, bado unaweza kupitisha **callback** kama hoja ya mwisho.

Kutuma ombi kutoka kwa **skripti ya maudhui** kunaonekana kama hii:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Kutuma ombi kutoka kwenye **extension** (kawaida ni **background script**). Mfano wa jinsi ya kutuma ujumbe kwa script ya maudhui katika tab iliyochaguliwa:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Katika **kipande cha kupokea**, unahitaji kuweka [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **mwanachama wa tukio** ili kushughulikia ujumbe. Hii inaonekana sawa kutoka kwa skripti ya maudhui au ukurasa wa nyongeza.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Katika mfano ulioangaziwa, **`sendResponse()`** ilitekelezwa kwa njia ya synchronous. Ili kubadilisha mhandisi wa tukio la `onMessage` kwa utekelezaji wa asynchronous wa `sendResponse()`, ni muhimu kuingiza `return true;`.

Kitu muhimu cha kuzingatia ni kwamba katika hali ambapo kurasa nyingi zimewekwa kupokea matukio ya `onMessage`, **kurasa ya kwanza kutekeleza `sendResponse()`** kwa tukio maalum itakuwa pekee inayoweza kutoa jibu kwa ufanisi. Majibu yoyote yanayofuata kwa tukio hilo hilo hayatazingatiwa.

Wakati wa kuunda nyongeza mpya, upendeleo unapaswa kuwa kwa ahadi badala ya callbacks. Kuhusu matumizi ya callbacks, kazi ya `sendResponse()` inachukuliwa kuwa halali tu ikiwa inatekelezwa moja kwa moja ndani ya muktadha wa synchronous, au ikiwa mhandisi wa tukio unaonyesha operesheni ya asynchronous kwa kurudisha `true`. Ikiwa hakuna mhandisi yeyote anayerudisha `true` au ikiwa kazi ya `sendResponse()` imeondolewa kutoka kwenye kumbukumbu (garbage-collected), callback inayohusiana na kazi ya `sendMessage()` itachochewa kwa default.

## Ujumbe wa Asili

Nyongeza za kivinjari pia zinaruhusu kuwasiliana na **binaries katika mfumo kupitia stdin**. Programu lazima iweke json ikionyesha hivyo katika json kama:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Wakati `name` ni mfuatano unaopitishwa kwa [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) au [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) kuwasiliana na programu kutoka kwa skripti za nyuma za nyongeza ya kivinjari. `path` ni njia ya binary, kuna `type` moja tu halali ambayo ni stdio (tumia stdin na stdout) na `allowed_origins` inaonyesha nyongeza ambazo zinaweza kuipata (na haziwezi kuwa na wildcard).

Chrome/Chromium itatafuta json hii katika baadhi ya usajili wa madirisha na baadhi ya njia katika macOS na Linux (maelezo zaidi katika [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

{% hint style="success" %}
Nyongeza ya kivinjari pia inahitaji ruhusa ya `nativeMessaing` kutangazwa ili iweze kutumia mawasiliano haya.
{% endhint %}

Hivi ndivyo inavyoonekana kama baadhi ya msimbo wa skripti za nyuma ukituma ujumbe kwa programu asilia:
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
Katika [**hiki kipande cha blogu**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), mfano wa muundo dhaifu unaotumia ujumbe wa asili unapendekezwa:

1. Kiongezeo cha kivinjari kina muundo wa wildcard kwa skripti ya maudhui.
2. Skripti ya maudhui inapita ujumbe wa `postMessage` kwa skripti ya nyuma kwa kutumia `sendMessage`.
3. Skripti ya nyuma inapita ujumbe kwa programu ya asili kwa kutumia `sendNativeMessage`.
4. Programu ya asili inashughulikia ujumbe kwa njia hatari, ikisababisha utekelezaji wa msimbo.

Na ndani yake mfano wa **kuenda kutoka ukurasa wowote hadi RCE kwa kutumia kiongezeo cha kivinjari unafafanuliwa**.

## Taarifa Nyeti Katika Kumbukumbu/Msimbo/Clipboard

Ikiwa Kiongezeo cha Kivinjari kina **taarifa nyeti ndani ya kumbukumbu yake**, hii inaweza **kutolewa** (hasa katika mashine za Windows) na **kutafutwa** kwa taarifa hii.

Kwa hivyo, kumbukumbu ya Kiongezeo cha Kivinjari **haipaswi kuzingatiwa kuwa salama** na **taarifa nyeti** kama vile akidi au maneno ya kumbukumbu **haipaswi kuhifadhiwa**.

Kwa hakika, usiweke **taarifa nyeti katika msimbo**, kwani itakuwa **ya umma**.

Ili kutoa kumbukumbu kutoka kwa kivinjari unaweza **kutoa kumbukumbu ya mchakato** au kwenda kwenye **mipangilio** ya kiongezeo cha kivinjari bonyeza **`Inspect pop-up`** -> Katika sehemu ya **`Memory`** -> **`Take a snaphost`** na **`CTRL+F`** kutafuta ndani ya picha ya kumbukumbu kwa taarifa nyeti.

Zaidi ya hayo, taarifa nyeti sana kama funguo za kumbukumbu au nywila **hazipaswi kuruhusiwa kunakiliwa kwenye clipboard** (au angalau kuondolewa kutoka kwenye clipboard ndani ya sekunde chache) kwa sababu basi michakato inayofuatilia clipboard itakuwa na uwezo wa kuzipata.

## Kupakia Kiongezeo Katika Kivinjari

1. **Pakua** Kiongezeo cha Kivinjari & uondoe zipu
2. Nenda kwenye **`chrome://extensions/`** na **wezesha** `Developer Mode`
3. Bonyeza kitufe cha **`Load unpacked`**

Katika **Firefox** unakwenda kwenye **`about:debugging#/runtime/this-firefox`** na bonyeza kitufe cha **`Load Temporary Add-on`**.

## Kupata msimbo wa chanzo kutoka dukani

Msimbo wa chanzo wa kiongezeo cha Chrome unaweza kupatikana kupitia njia mbalimbali. Hapa chini kuna maelezo ya kina na maagizo kwa kila chaguo.

### Pakua Kiongezeo kama ZIP kupitia Mstari wa Amri

Msimbo wa chanzo wa kiongezeo cha Chrome unaweza kupakuliwa kama faili ya ZIP kwa kutumia mstari wa amri. Hii inahusisha kutumia `curl` kupata faili ya ZIP kutoka URL maalum na kisha kutoa yaliyomo ya faili ya ZIP kwenye directory. Hapa kuna hatua:

1. Badilisha `"extension_id"` na ID halisi ya kiongezeo.
2. Tekeleza amri zifuatazo:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Tumia tovuti ya CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Tumia nyongeza ya CRX Viewer

Njia nyingine rahisi ni kutumia Chrome Extension Source Viewer, ambayo ni mradi wa chanzo wazi. Inaweza kupakuliwa kutoka [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Msimbo wa chanzo wa viewer upatikana katika [GitHub repository](https://github.com/Rob--W/crxviewer).

### Angalia chanzo cha nyongeza iliyosakinishwa kwa ndani

Nyongeza za Chrome zilizowekwa kwa ndani pia zinaweza kukaguliwa. Hapa kuna jinsi:

1. Fikia saraka yako ya wasifu wa Chrome kwa kutembelea `chrome://version/` na kutafuta uwanja wa "Profile Path".
2. Tembea hadi ndogo ya `Extensions/` ndani ya saraka ya wasifu.
3. Folda hii ina nyongeza zote zilizowekwa, kawaida zikiwa na msimbo wao wa chanzo katika muundo unaoweza kusomeka.

Ili kubaini nyongeza, unaweza kuoanisha IDs zao na majina:

* Wezesha Hali ya Mwandishi kwenye ukurasa wa `about:extensions` ili kuona IDs za kila nyongeza.
* Ndani ya folda ya kila nyongeza, faili ya `manifest.json` ina uwanja wa `name` unaoweza kusomeka, ikikusaidia kubaini nyongeza hiyo.

### Tumia Mchambuzi wa Faili au Unpacker

Nenda kwenye Chrome Web Store na upakue nyongeza. Faili itakuwa na kiambishi cha `.crx`. Badilisha kiambishi cha faili kutoka `.crx` hadi `.zip`. Tumia mchambuzi wowote wa faili (kama WinRAR, 7-Zip, nk.) kutoa yaliyomo ya faili ya ZIP.

### Tumia Hali ya Mwandishi katika Chrome

Fungua Chrome na nenda kwenye `chrome://extensions/`. Wezesha "Hali ya Mwandishi" katika kona ya juu kulia. Bonyeza "Load unpacked extension...". Tembea hadi saraka ya nyongeza yako. Hii haisaidii kupakua msimbo wa chanzo, lakini ni muhimu kwa kuangalia na kubadilisha msimbo wa nyongeza ambayo tayari imeshapakwa au kuandaliwa.

## Seti ya data ya manifest ya nyongeza ya Chrome

Ili kujaribu kubaini nyongeza za kivinjari zenye udhaifu unaweza kutumia [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) na kuangalia faili zao za manifest kwa ishara zinazoweza kuwa na udhaifu. Kwa mfano kuangalia nyongeza zenye watumiaji zaidi ya 25000, `content_scripts` na ruhusa `nativeMessaing`:

{% code overflow="wrap" %}
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
{% endcode %}

## Orodha ya Ukaguzi wa Usalama

Ingawa Kiongezeo cha Kivinjari kina **uso wa shambulio ulio na mipaka**, baadhi yao wanaweza kuwa na **mapungufu** au **mabadiliko yanayoweza kuimarishwa**. Hizi hapa ni za kawaida zaidi:

* [ ] **Punguza** kadri iwezekanavyo **`permissions`** zilizohitajika
* [ ] **Punguza** kadri iwezekanavyo **`host_permissions`**
* [ ] Tumia **sera thabiti ya usalama wa maudhui** **`content_security_policy`**
* [ ] **Punguza** kadri iwezekanavyo **`externally_connectable`**, ikiwa hakuna inahitajika na inawezekana, usiache kwa chaguo-msingi, eleza **`{}`**
* [ ] Ikiwa **URL inayoweza kuathiriwa na XSS au kuchukuliwa** imetajwa hapa, mshambuliaji ataweza **kutuma ujumbe kwa scripts za nyuma moja kwa moja**. Njia yenye nguvu sana ya kupita.
* [ ] **Punguza** kadri iwezekanavyo **`web_accessible_resources`**, hata ikiwa ni tupu ikiwa inawezekana.
* [ ] Ikiwa **`web_accessible_resources`** si hakuna, angalia [**ClickJacking**](browext-clickjacking.md)
* [ ] Ikiwa mawasiliano yoyote yanatokea kutoka kwa **kiongezeo** hadi **ukurasa wa wavuti**, [**angalia XSS**](browext-xss-example.md) **mapungufu** yaliyosababishwa katika mawasiliano.
* [ ] Ikiwa Ujumbe wa Post unatumiwa, angalia [**mapungufu ya Ujumbe wa Post**](../postmessage-vulnerabilities/)**.**
* [ ] Ikiwa **Content Script inapata maelezo ya DOM**, angalia kwamba **hazileti XSS** ikiwa zinapewa **mabadiliko** na wavuti
* [ ] Fanya mkazo maalum ikiwa mawasiliano haya yanahusishwa pia katika **mawasiliano ya Content Script -> Background script**
* [ ] Ikiwa script ya nyuma inawasiliana kupitia **ujumbe wa asili** angalia mawasiliano ni salama na yameondolewa
* [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya msimbo wa Kiongezeo cha Kivinjari
* [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya kumbukumbu ya Kiongezeo cha Kivinjari
* [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **mfumo wa faili usiolindwa**

## Zana

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Inavuta kiongezeo chochote cha Chrome kutoka kiungo kilichotolewa cha duka la wavuti la Chrome.
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **mtazamaji**: inaonyesha toleo la JSON lililopambwa la hati ya kiongezeo.
* **Uchambuzi wa Alama ya Kidole**: Ugunduzi wa [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) na uzalishaji wa moja kwa moja wa JavaScript ya alama ya kidole ya kiongezeo cha Chrome.
* **Uchambuzi wa Uwezekano wa Clickjacking**: Ugunduzi wa kurasa za HTML za kiongezeo zenye mwelekeo wa [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) zilizowekwa. Hizi zinaweza kuwa na mapungufu ya clickjacking kulingana na kusudi la kurasa hizo.
* **Mtazamaji wa Onyo la Ruhusa**: unaonyesha orodha ya onyo zote za ruhusa za Chrome ambazo zitaonyeshwa wakati mtumiaji anajaribu kufunga kiongezeo.
* **Kazi Hatari**: inaonyesha eneo la kazi hatari ambazo zinaweza kutumiwa na mshambuliaji (mfano: kazi kama innerHTML, chrome.tabs.executeScript).
* **Nukta za Kuingia**: inaonyesha mahali kiongezeo kinapochukua pembejeo za mtumiaji/za nje. Hii ni muhimu kwa kuelewa eneo la uso la kiongezeo na kutafuta maeneo yanayoweza kutumiwa kutuma data iliyoundwa kwa uovu kwa kiongezeo.
* Wote skana za Kazi Hatari na Nukta za Kuingia zina yafuatayo kwa arifa zao zilizozalishwa:
* Kipande cha msimbo kinachohusiana na mstari ulioleta arifa.
* Maelezo ya tatizo.
* Kitufe cha "Tazama Faili" ili kuona faili kamili ya chanzo inayohusisha msimbo.
* Njia ya faili iliyoonyeshwa.
* URI kamili ya kiongezeo cha Chrome ya faili iliyoonyeshwa.
* Aina ya faili ni, kama vile script ya Ukurasa wa Nyuma, Script ya Maudhui, Kitendo cha Kivinjari, nk.
* Ikiwa mstari unaoweza kuathiriwa uko katika faili ya JavaScript, njia za kurasa zote ambapo imejumuishwa pamoja na aina za kurasa hizi, na hali ya [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Mchambuzi wa Sera ya Usalama wa Maudhui (CSP) na mchakato wa kupita**: Hii itabainisha udhaifu katika CSP ya kiongezeo chako na pia itaonyesha njia zozote zinazoweza kupita CSP yako kutokana na CDNs zilizoorodheshwa, nk.
* **Maktaba Zinazojulikana za Kuweza Kuathiriwa**: Hii inatumia [Retire.js](https://retirejs.github.io/retire.js/) kuangalia matumizi ya maktaba za JavaScript zinazojulikana kuwa na mapungufu.
* Pakua kiongezeo na toleo lililopangwa.
* Pakua kiongezeo asilia.
* Pakua toleo lililopambwa la kiongezeo (HTML na JavaScript iliyopambwa kiotomatiki).
* Hifadhi kiotomatiki ya matokeo ya uchunguzi, kuendesha uchunguzi wa kiongezeo kutachukua muda mzuri mara ya kwanza unapoendesha. Hata hivyo, mara ya pili, ikiwa kiongezeo hakijasasishwa, itakuwa karibu mara moja kutokana na matokeo kuhifadhiwa.
* URL za Ripoti zinazoweza kuunganishwa, rahisi kuunganisha mtu mwingine kwenye ripoti ya kiongezeo iliyozalishwa na tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Mradi wa Neto ni kifurushi cha Python 3 kilichoundwa kuchambua na kufichua vipengele vilivyofichwa vya plugins na kiongezeo kwa vivinjari maarufu kama Firefox na Chrome. Inafanya mchakato wa kufungua faili zilizofungashwa ili kutoa vipengele hivi kutoka kwa rasilimali zinazohusiana katika kiongezeo kama `manifest.json`, folda za lugha au faili za chanzo za Javascript na HTML.

## Marejeleo

* **Shukrani kwa** [**@naivenom**](https://twitter.com/naivenom) **kwa msaada na mbinu hii**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Jifunze na fanya mazoezi ya AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze na fanya mazoezi ya GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Angalia [**mpango wa usajili**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **fuata** sisi kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
