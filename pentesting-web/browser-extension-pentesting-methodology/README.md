# Metodologia de Pentesting de Extens√µes de Navegador

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

As extens√µes de navegador s√£o escritas em JavaScript e carregadas pelo navegador em segundo plano. Elas t√™m seu [DOM](https://www.w3schools.com/js/js\_htmldom.asp) mas podem interagir com os DOMs de outros sites. Isso significa que podem comprometer a confidencialidade, integridade e disponibilidade (CIA) de outros sites.

## Componentes Principais

Os layouts de extens√£o ficam melhores quando visualizados e consistem em tr√™s componentes. Vamos analisar cada componente em profundidade.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Conte√∫do**

Cada script de conte√∫do tem acesso direto ao DOM de uma **√∫nica p√°gina da web** e, portanto, est√° exposto a **entrada potencialmente maliciosa**. No entanto, o script de conte√∫do n√£o cont√©m permiss√µes al√©m da capacidade de enviar mensagens ao n√∫cleo da extens√£o.

### **N√∫cleo da Extens√£o**

O n√∫cleo da extens√£o cont√©m a maioria dos privil√©gios/acessos da extens√£o, mas o n√∫cleo da extens√£o s√≥ pode interagir com o conte√∫do da web via [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) e scripts de conte√∫do. Al√©m disso, o n√∫cleo da extens√£o n√£o tem acesso direto √† m√°quina host.

### **Bin√°rio Nativo**

A extens√£o permite um bin√°rio nativo que pode **acessar a m√°quina host com os privil√©gios totais do usu√°rio.** O bin√°rio nativo interage com o n√∫cleo da extens√£o atrav√©s da Interface de Programa√ß√£o de Aplicativos de Plugin Netscape padr√£o ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) usada pelo Flash e outros plug-ins de navegador.

### Limites

{% hint style="danger" %}
Para obter os privil√©gios totais do usu√°rio, um atacante deve convencer a extens√£o a passar entrada maliciosa do script de conte√∫do para o n√∫cleo da extens√£o e do n√∫cleo da extens√£o para o bin√°rio nativo.
{% endhint %}

Cada componente da extens√£o √© separado dos outros por **fortes limites protetores**. Cada componente √© executado em um **processo de sistema operacional separado**. Scripts de conte√∫do e n√∫cleos de extens√£o s√£o executados em **processos de sandbox** indispon√≠veis para a maioria dos servi√ßos do sistema operacional.

Al√©m disso, os scripts de conte√∫do s√£o separados de suas p√°ginas da web associadas por **executarem em um heap JavaScript separado**. O script de conte√∫do e a p√°gina da web t√™m **acesso ao mesmo DOM subjacente**, mas os dois **nunca trocam ponteiros JavaScript**, prevenindo o vazamento de funcionalidade JavaScript.

## **`manifest.json`**

Uma extens√£o do Chrome √© apenas uma pasta ZIP com uma [.crx file extension](https://www.lifewire.com/crx-file-2620391). O n√∫cleo da extens√£o √© o **`manifest.json`** arquivo na raiz da pasta, que especifica layout, permiss√µes e outras op√ß√µes de configura√ß√£o.

Exemplo:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Os scripts de conte√∫do s√£o **carregados** sempre que o usu√°rio **navega para uma p√°gina correspondente**, neste caso, qualquer p√°gina que corresponda √† express√£o **`https://example.com/*`** e n√£o corresponda √† regex **`*://*/*/business*`**. Eles s√£o executados **como os pr√≥prios scripts da p√°gina** e t√™m acesso arbitr√°rio ao [Modelo de Objeto de Documento (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) da p√°gina.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Para incluir ou excluir mais URLs, tamb√©m √© poss√≠vel usar **`include_globs`** e **`exclude_globs`**.

Este √© um exemplo de script de conte√∫do que adicionar√° um bot√£o de explica√ß√£o √† p√°gina quando [a API de armazenamento](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) for usada para recuperar o valor `message` do armazenamento da extens√£o.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Uma mensagem √© enviada para as p√°ginas da extens√£o pelo script de conte√∫do quando este bot√£o √© clicado, atrav√©s da utiliza√ß√£o da [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Isso se deve √† limita√ß√£o do script de conte√∫do em acessar diretamente as APIs, sendo `storage` uma das poucas exce√ß√µes. Para funcionalidades al√©m dessas exce√ß√µes, mensagens s√£o enviadas para as p√°ginas da extens√£o com as quais os scripts de conte√∫do podem se comunicar.

{% hint style="warning" %}
Dependendo do navegador, as capacidades do script de conte√∫do podem variar ligeiramente. Para navegadores baseados em Chromium, a lista de capacidades est√° dispon√≠vel na [documenta√ß√£o dos desenvolvedores do Chrome](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), e para o Firefox, o [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) serve como a fonte principal.\
√â tamb√©m not√°vel que os scripts de conte√∫do t√™m a capacidade de se comunicar com scripts de fundo, permitindo que realizem a√ß√µes e retransmitam respostas.
{% endhint %}

Para visualizar e depurar scripts de conte√∫do no Chrome, o menu de ferramentas de desenvolvedor do Chrome pode ser acessado em Op√ß√µes > Mais ferramentas > Ferramentas do desenvolvedor OU pressionando Ctrl + Shift + I.

Ao exibir as ferramentas de desenvolvedor, a **aba Fonte** deve ser clicada, seguida pela aba **Scripts de Conte√∫do**. Isso permite a observa√ß√£o de scripts de conte√∫do em execu√ß√£o de v√°rias extens√µes e a defini√ß√£o de pontos de interrup√ß√£o para rastrear o fluxo de execu√ß√£o.

### Scripts de conte√∫do injetados

{% hint style="success" %}
Observe que **Scripts de Conte√∫do n√£o s√£o obrigat√≥rios** pois tamb√©m √© poss√≠vel **injetar** scripts **dinamicamente** e **injet√°-los programaticamente** em p√°ginas da web via **`tabs.executeScript`**. Isso na verdade fornece **controles mais granulares**.
{% endhint %}

Para a inje√ß√£o program√°tica de um script de conte√∫do, a extens√£o deve ter [permiss√µes de host](https://developer.chrome.com/docs/extensions/reference/permissions) para a p√°gina na qual os scripts devem ser injetados. Essas permiss√µes podem ser obtidas solicitando-as dentro do manifesto da extens√£o ou de forma tempor√°ria atrav√©s de [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Exemplo de extens√£o baseada em activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injetar um arquivo JS ao clicar:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Injetar uma fun√ß√£o** ao clicar:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Exemplo com permiss√µes de script
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Para incluir ou excluir mais URLs, tamb√©m √© poss√≠vel usar **`include_globs`** e **`exclude_globs`**.

### Content Scripts `run_at`

O campo `run_at` controla **quando os arquivos JavaScript s√£o injetados na p√°gina da web**. O valor preferido e padr√£o √© `"document_idle"`.

Os valores poss√≠veis s√£o:

* **`document_idle`**: Sempre que poss√≠vel
* **`document_start`**: Ap√≥s quaisquer arquivos de `css`, mas antes que qualquer outro DOM seja constru√≠do ou qualquer outro script seja executado.
* **`document_end`**: Imediatamente ap√≥s o DOM estar completo, mas antes que subrecursos como imagens e frames tenham sido carregados.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Via **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

As mensagens enviadas por scripts de conte√∫do s√£o recebidas pela **p√°gina de fundo**, que desempenha um papel central na coordena√ß√£o dos componentes da extens√£o. Notavelmente, a p√°gina de fundo persiste ao longo da vida √∫til da extens√£o, operando discretamente sem intera√ß√£o direta do usu√°rio. Ela possui seu pr√≥prio Modelo de Objeto de Documento (DOM), permitindo intera√ß√µes complexas e gerenciamento de estado.

**Pontos Chave**:

* **Papel da P√°gina de Fundo:** Atua como o centro nervoso da extens√£o, garantindo comunica√ß√£o e coordena√ß√£o entre v√°rias partes da extens√£o.
* **Persist√™ncia:** √â uma entidade sempre presente, invis√≠vel ao usu√°rio, mas integral √† funcionalidade da extens√£o.
* **Gera√ß√£o Autom√°tica:** Se n√£o for explicitamente definida, o navegador criar√° automaticamente uma p√°gina de fundo. Esta p√°gina gerada automaticamente incluir√° todos os scripts de fundo especificados no manifesto da extens√£o, garantindo a opera√ß√£o cont√≠nua das tarefas de fundo da extens√£o.

{% hint style="success" %}
A conveni√™ncia proporcionada pelo navegador ao gerar automaticamente uma p√°gina de fundo (quando n√£o declarada explicitamente) garante que todos os scripts de fundo necess√°rios estejam integrados e operacionais, simplificando o processo de configura√ß√£o da extens√£o.
{% endhint %}

Exemplo de script de fundo:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Ele usa a [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) para escutar mensagens. Quando uma mensagem `"explain"` √© recebida, ele usa a [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) para abrir uma p√°gina em uma nova aba.

Para depurar o script de fundo, voc√™ pode ir aos **detalhes da extens√£o e inspecionar o service worker,** isso abrir√° as ferramentas de desenvolvedor com o script de fundo:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### P√°ginas de op√ß√µes e outras

As extens√µes do navegador podem conter v√°rios tipos de p√°ginas:

* **P√°ginas de a√ß√£o** s√£o exibidas em um **menu suspenso quando o √≠cone da extens√£o** √© clicado.
* P√°ginas que a extens√£o ir√° **carregar em uma nova aba**.
* **P√°ginas de Op√ß√µes**: Esta p√°gina √© exibida no topo da extens√£o quando clicada. No manifesto anterior, no meu caso, consegui acessar esta p√°gina em `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` ou clicando:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Note que essas p√°ginas n√£o s√£o persistentes como as p√°ginas de fundo, pois carregam conte√∫do dinamicamente conforme necess√°rio. Apesar disso, elas compartilham certas capacidades com a p√°gina de fundo:

* **Comunica√ß√£o com Scripts de Conte√∫do:** Semelhante √† p√°gina de fundo, essas p√°ginas podem receber mensagens de scripts de conte√∫do, facilitando a intera√ß√£o dentro da extens√£o.
* **Acesso a APIs Espec√≠ficas da Extens√£o:** Essas p√°ginas t√™m acesso abrangente a APIs espec√≠ficas da extens√£o, sujeito √†s permiss√µes definidas para a extens√£o.

### `permissions` & `host_permissions`

**`permissions`** e **`host_permissions`** s√£o entradas do `manifest.json` que indicar√£o **quais permiss√µes** a extens√£o do navegador possui (armazenamento, localiza√ß√£o...) e em **quais p√°ginas da web**.

Como as extens√µes do navegador podem ser t√£o **privilegiadas**, uma maliciosa ou uma que esteja comprometida poderia permitir ao atacante **diferentes meios de roubar informa√ß√µes sens√≠veis e espionar o usu√°rio**.

Verifique como essas configura√ß√µes funcionam e como podem ser abusadas em:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Uma **pol√≠tica de seguran√ßa de conte√∫do** pode ser declarada tamb√©m dentro do `manifest.json`. Se houver uma definida, ela pode ser **vulner√°vel**.

A configura√ß√£o padr√£o para p√°ginas de extens√£o do navegador √© bastante restritiva:
```bash
script-src 'self'; object-src 'self';
```
Para mais informa√ß√µes sobre CSP e poss√≠veis contornos, consulte:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Para que uma p√°gina da web acesse uma p√°gina de uma Extens√£o do Navegador, uma p√°gina `.html`, por exemplo, essa p√°gina precisa ser mencionada no campo **`web_accessible_resources`** do `manifest.json`.\
Por exemplo:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Estas p√°ginas s√£o acess√≠veis em URL como:
```
chrome-extension://<extension-id>/message.html
```
Em extens√µes p√∫blicas, o **extension-id √© acess√≠vel**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Embora, se o par√¢metro `manifest.json` **`use_dynamic_url`** for usado, esse **id pode ser din√¢mico**.

{% hint style="success" %}
Observe que mesmo que uma p√°gina seja mencionada aqui, ela pode estar **protegida contra ClickJacking** gra√ßas √† **Content Security Policy**. Portanto, voc√™ tamb√©m precisa verific√°-la (se√ß√£o frame-ancestors) antes de confirmar que um ataque de ClickJacking √© poss√≠vel.
{% endhint %}

Ter permiss√£o para acessar essas p√°ginas torna essas p√°ginas **potencialmente vulner√°veis a ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Permitir que essas p√°ginas sejam carregadas apenas pela extens√£o e n√£o por URLs aleat√≥rias poderia prevenir ataques de ClickJacking.
{% endhint %}

{% hint style="danger" %}
Observe que as p√°ginas de **`web_accessible_resources`** e outras p√°ginas da extens√£o tamb√©m s√£o capazes de **contatar scripts de fundo**. Portanto, se uma dessas p√°ginas for vulner√°vel a **XSS**, isso poderia abrir uma vulnerabilidade maior.

Al√©m disso, note que voc√™ s√≥ pode abrir p√°ginas indicadas em **`web_accessible_resources`** dentro de iframes, mas de uma nova aba √© poss√≠vel acessar qualquer p√°gina na extens√£o conhecendo o ID da extens√£o. Portanto, se um XSS for encontrado abusando dos mesmos par√¢metros, ele poderia ser explorado mesmo que a p√°gina n√£o esteja configurada em **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

De acordo com a [**documenta√ß√£o**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), a propriedade de manifesto `"externally_connectable"` declara **quais extens√µes e p√°ginas da web podem se conectar** √† sua extens√£o via [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) e [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Se a chave **`externally_connectable`** **n√£o** for declarada no manifesto da sua extens√£o ou for declarada como **`"ids": ["*"]`**, **todas as extens√µes podem se conectar, mas nenhuma p√°gina da web pode se conectar**.
* Se **IDs espec√≠ficos forem especificados**, como em `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **apenas esses aplicativos** podem se conectar.
* Se **matches** forem especificados, esses aplicativos da web poder√£o se conectar:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Se estiver especificado como vazio: **`"externally_connectable": {}`**, nenhum aplicativo ou site poder√° se conectar.

Quanto **menos extens√µes e URLs** indicadas aqui, **menor ser√° a superf√≠cie de ataque**.

{% hint style="danger" %}
Se uma p√°gina da web **vulner√°vel a XSS ou takeover** estiver indicada em **`externally_connectable`**, um atacante poder√° **enviar mensagens diretamente para o script de fundo**, contornando completamente o Content Script e seu CSP.

Portanto, este √© um **bypass muito poderoso**.

Al√©m disso, se o cliente instalar uma extens√£o maliciosa, mesmo que n√£o seja permitido comunicar-se com a extens√£o vulner√°vel, ela poder√° injetar **dados XSS em uma p√°gina da web permitida** ou abusar das APIs **`WebRequest`** ou **`DeclarativeNetRequest`** para manipular solicita√ß√µes em um dom√≠nio alvo alterando a solicita√ß√£o de uma **arquivo JavaScript**. (Observe que o CSP na p√°gina alvo pode prevenir esses ataques). Esta ideia vem [**deste writeup**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Resumo da comunica√ß√£o

### Extens√£o <--> WebApp

Para se comunicar entre o script de conte√∫do e a p√°gina da web, mensagens postadas s√£o geralmente usadas. Portanto, na aplica√ß√£o web voc√™ geralmente encontrar√° chamadas para a fun√ß√£o **`window.postMessage`** e no script de conte√∫do ouvintes como **`window.addEventListener`**. Note, no entanto, que a extens√£o tamb√©m pode **comunicar-se com a aplica√ß√£o web enviando uma Post Message** (e, portanto, a web deve esperar por isso) ou apenas fazer a web carregar um novo script.

### Dentro da extens√£o

Geralmente, a fun√ß√£o **`chrome.runtime.sendMessage`** √© usada para enviar uma mensagem dentro da extens√£o (geralmente tratada pelo script `background`) e, para receb√™-la e manipul√°-la, um ouvinte √© declarado chamando **`chrome.runtime.onMessage.addListener`**.

Tamb√©m √© poss√≠vel usar **`chrome.runtime.connect()`** para ter uma conex√£o persistente em vez de enviar mensagens √∫nicas, √© poss√≠vel us√°-lo para **enviar** e **receber** **mensagens** como no seguinte exemplo:

<details>

<summary><code>chrome.runtime.connect()</code> exemplo</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Tamb√©m √© poss√≠vel enviar mensagens de um script de fundo para um script de conte√∫do localizado em uma aba espec√≠fica chamando **`chrome.tabs.sendMessage`**, onde voc√™ precisar√° indicar o **ID da aba** para a qual enviar a mensagem.

### De `externally_connectable` permitido para a extens√£o

**Aplicativos da web e extens√µes de navegador externas permitidas** na configura√ß√£o `externally_connectable` podem enviar solicita√ß√µes usando:
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Onde √© necess√°rio mencionar o **extension ID**.

## Web **‚ÜîÔ∏é** Comunica√ß√£o de Script de Conte√∫do

Os ambientes onde os **content scripts** operam e onde as p√°ginas host existem s√£o **separados** um do outro, garantindo **isolamento**. Apesar desse isolamento, ambos t√™m a capacidade de interagir com o **Document Object Model (DOM)** da p√°gina, um recurso compartilhado. Para que a p√°gina host se envolva em comunica√ß√£o com o **content script**, ou indiretamente com a extens√£o atrav√©s do content script, √© necess√°rio utilizar o **DOM** que √© acess√≠vel por ambas as partes como o canal de comunica√ß√£o.

### Post Messages

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Uma comunica√ß√£o segura de Post Message deve verificar a autenticidade da mensagem recebida, isso pode ser feito verificando:

* **`event.isTrusted`**: Isso √© True apenas se o evento foi acionado por uma a√ß√£o do usu√°rio
* O script de conte√∫do pode esperar uma mensagem apenas se o usu√°rio realizar alguma a√ß√£o
* **dom√≠nio de origem**: pode esperar uma mensagem apenas de uma lista de dom√≠nios permitidos.
* Se uma regex for usada, tenha muito cuidado
* **Fonte**: `received_message.source !== window` pode ser usado para verificar se a mensagem foi **da mesma janela** onde o Script de Conte√∫do est√° ouvindo.

As verifica√ß√µes anteriores, mesmo se realizadas, podem ser vulner√°veis, ent√£o verifique na p√°gina seguinte **potenciais bypasses de Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Outra poss√≠vel forma de comunica√ß√£o pode ser atrav√©s de **URLs de Iframe**, voc√™ pode encontrar um exemplo em:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Isso n√£o √© "exatamente" uma forma de comunica√ß√£o, mas o **web e o script de conte√∫do ter√£o acesso ao DOM da web**. Portanto, se o **script de conte√∫do** estiver lendo alguma informa√ß√£o dele, **confiando no DOM da web**, a web pode **modificar esses dados** (porque a web n√£o deve ser confi√°vel, ou porque a web √© vulner√°vel a XSS) e **comprometer o Script de Conte√∫do**.

Voc√™ tamb√©m pode encontrar um exemplo de um **XSS baseado em DOM para comprometer uma extens√£o de navegador** em:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Comunica√ß√£o entre Script de Conte√∫do **‚ÜîÔ∏é** Script de Fundo

Um Script de Conte√∫do pode usar as fun√ß√µes [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **ou** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) para enviar uma mensagem **JSON-serializ√°vel de uma √∫nica vez**.

Para lidar com a **resposta**, use a **Promise** retornada. Embora, para compatibilidade retroativa, voc√™ ainda possa passar um **callback** como o √∫ltimo argumento.

Enviar uma solicita√ß√£o de um **script de conte√∫do** se parece com isso:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Enviando uma solicita√ß√£o do **extension** (geralmente um **background script**). Exemplo de como enviar uma mensagem para o script de conte√∫do na aba selecionada:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
No **lado receptor**, voc√™ precisa configurar um [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **ouvinte de eventos** para lidar com a mensagem. Isso parece o mesmo a partir de um script de conte√∫do ou p√°gina de extens√£o.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
No exemplo destacado, **`sendResponse()`** foi executado de forma s√≠ncrona. Para modificar o manipulador de eventos `onMessage` para a execu√ß√£o ass√≠ncrona de `sendResponse()`, √© imperativo incorporar `return true;`.

Uma considera√ß√£o importante √© que, em cen√°rios onde v√°rias p√°ginas est√£o configuradas para receber eventos `onMessage`, **a primeira p√°gina a executar `sendResponse()`** para um evento espec√≠fico ser√° a √∫nica capaz de entregar a resposta efetivamente. Quaisquer respostas subsequentes para o mesmo evento n√£o ser√£o levadas em conta.

Ao criar novas extens√µes, a prefer√™ncia deve ser por promessas em vez de callbacks. Em rela√ß√£o ao uso de callbacks, a fun√ß√£o `sendResponse()` √© considerada v√°lida apenas se for executada diretamente dentro do contexto s√≠ncrono, ou se o manipulador de eventos indicar uma opera√ß√£o ass√≠ncrona retornando `true`. Se nenhum dos manipuladores retornar `true` ou se a fun√ß√£o `sendResponse()` for removida da mem√≥ria (coletada pelo lixo), o callback associado √† fun√ß√£o `sendMessage()` ser√° acionado por padr√£o.

## Informa√ß√µes Sens√≠veis na Mem√≥ria/C√≥digo/√Årea de Transfer√™ncia

Se uma Extens√£o de Navegador armazena **informa√ß√µes sens√≠veis dentro de sua mem√≥ria**, isso pode ser **despejado** (especialmente em m√°quinas Windows) e **pesquisado** por essas informa√ß√µes.

Portanto, a mem√≥ria da Extens√£o de Navegador **n√£o deve ser considerada segura** e **informa√ß√µes sens√≠veis** como credenciais ou frases mnem√¥nicas **n√£o devem ser armazenadas**.

Claro, **n√£o coloque informa√ß√µes sens√≠veis no c√≥digo**, pois isso ser√° **p√∫blico**.

Para despejar a mem√≥ria do navegador, voc√™ pode **despejar a mem√≥ria do processo** ou ir para as **configura√ß√µes** da extens√£o do navegador, clicar em **`Inspecionar pop-up`** -> Na se√ß√£o **`Mem√≥ria`** -> **`Tirar um instant√¢neo`** e **`CTRL+F`** para pesquisar dentro do instant√¢neo por informa√ß√µes sens√≠veis.

Al√©m disso, informa√ß√µes altamente sens√≠veis, como chaves mnem√¥nicas ou senhas, **n√£o devem ser permitidas para serem copiadas na √°rea de transfer√™ncia** (ou pelo menos remov√™-las da √°rea de transfer√™ncia em alguns segundos), pois assim processos que monitoram a √°rea de transfer√™ncia poder√£o obt√™-las.

## Carregando uma Extens√£o no Navegador

1. **Baixe** a Extens√£o do Navegador & descompacte
2. V√° para **`chrome://extensions/`** e **ative** o `Modo de Desenvolvedor`
3. Clique no bot√£o **`Carregar sem compacta√ß√£o`**

No **Firefox**, voc√™ vai para **`about:debugging#/runtime/this-firefox`** e clica no bot√£o **`Carregar complemento tempor√°rio`**.

## Obtendo o c√≥digo-fonte da loja

O c√≥digo-fonte de uma extens√£o do Chrome pode ser obtido atrav√©s de v√°rios m√©todos. Abaixo est√£o explica√ß√µes detalhadas e instru√ß√µes para cada op√ß√£o.

### Baixar Extens√£o como ZIP via Linha de Comando

O c√≥digo-fonte de uma extens√£o do Chrome pode ser baixado como um arquivo ZIP usando a linha de comando. Isso envolve usar `curl` para buscar o arquivo ZIP de uma URL espec√≠fica e, em seguida, extrair o conte√∫do do arquivo ZIP para um diret√≥rio. Aqui est√£o os passos:

1. Substitua `"extension_id"` pelo ID real da extens√£o.
2. Execute os seguintes comandos:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Use o site CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Use a extens√£o CRX Viewer

Outro m√©todo conveniente √© usar o Chrome Extension Source Viewer, que √© um projeto de c√≥digo aberto. Ele pode ser instalado na [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=pt). O c√≥digo-fonte do visualizador est√° dispon√≠vel em seu [reposit√≥rio GitHub](https://github.com/Rob--W/crxviewer).

### Visualizar o c√≥digo da extens√£o instalada localmente

As extens√µes do Chrome instaladas localmente tamb√©m podem ser inspecionadas. Veja como:

1. Acesse o diret√≥rio do seu perfil local do Chrome visitando `chrome://version/` e localizando o campo "Profile Path".
2. Navegue at√© a subpasta `Extensions/` dentro do diret√≥rio do perfil.
3. Esta pasta cont√©m todas as extens√µes instaladas, tipicamente com seu c√≥digo-fonte em um formato leg√≠vel.

Para identificar extens√µes, voc√™ pode mapear seus IDs para nomes:

* Ative o Modo Desenvolvedor na p√°gina `about:extensions` para ver os IDs de cada extens√£o.
* Dentro da pasta de cada extens√£o, o arquivo `manifest.json` cont√©m um campo `name` leg√≠vel, ajudando voc√™ a identificar a extens√£o.

### Use um Arquivador de Arquivos ou Descompactador

V√° para a Chrome Web Store e baixe a extens√£o. O arquivo ter√° uma extens√£o `.crx`. Altere a extens√£o do arquivo de `.crx` para `.zip`. Use qualquer arquivador de arquivos (como WinRAR, 7-Zip, etc.) para extrair o conte√∫do do arquivo ZIP.

### Use o Modo Desenvolvedor no Chrome

Abra o Chrome e v√° para `chrome://extensions/`. Ative o "Modo desenvolvedor" no canto superior direito. Clique em "Carregar extens√£o descompactada...". Navegue at√© o diret√≥rio da sua extens√£o. Isso n√£o baixa o c√≥digo-fonte, mas √© √∫til para visualizar e modificar o c√≥digo de uma extens√£o j√° baixada ou desenvolvida.

## Lista de Verifica√ß√£o de Auditoria de Seguran√ßa

Embora as Extens√µes de Navegador tenham uma **superf√≠cie de ataque limitada**, algumas delas podem conter **vulnerabilidades** ou **melhorias potenciais de endurecimento**. As seguintes s√£o as mais comuns:

* [ ] **Limitar** o m√°ximo poss√≠vel as **`permissions`** solicitadas
* [ ] **Limitar** o m√°ximo poss√≠vel as **`host_permissions`**
* [ ] Usar uma **`content_security_policy`** **forte**
* [ ] **Limitar** o m√°ximo poss√≠vel o **`externally_connectable`**, se nenhum for necess√°rio e poss√≠vel, n√£o deix√°-lo por padr√£o, especificar **`{}`**
* [ ] Se **URL vulner√°vel a XSS ou a takeover** for mencionada aqui, um atacante poder√° **enviar mensagens para os scripts de fundo diretamente**. Um bypass muito poderoso.
* [ ] **Limitar** o m√°ximo poss√≠vel os **`web_accessible_resources`**, mesmo vazios se poss√≠vel.
* [ ] Se **`web_accessible_resources`** n√£o for nenhum, verifique por [**ClickJacking**](browext-clickjacking.md)
* [ ] Se qualquer **comunica√ß√£o** ocorrer da **extens√£o** para a **p√°gina da web**, [**verifique por XSS**](browext-xss-example.md) **vulnerabilidades** causadas na comunica√ß√£o.
* [ ] Se Post Messages forem usados, verifique por [**vulnerabilidades de Post Message**](../postmessage-vulnerabilities/)**.**
* [ ] Se o **Content Script acessar detalhes do DOM**, verifique se eles **n√£o est√£o introduzindo um XSS** se forem **modificados** pela web
* [ ] Fa√ßa uma √™nfase especial se essa comunica√ß√£o tamb√©m estiver envolvida na **comunica√ß√£o do Content Script -> script de fundo**
* [ ] **Informa√ß√µes sens√≠veis n√£o devem ser armazenadas** dentro do c√≥digo da Extens√£o do Navegador
* [ ] **Informa√ß√µes sens√≠veis n√£o devem ser armazenadas** dentro da mem√≥ria da Extens√£o do Navegador

## Ferramentas

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Extrai qualquer extens√£o do Chrome a partir de um link fornecido da Chrome Webstore.
* Visualizador de [**manifest.json**](https://developer.chrome.com/extensions/manifest): simplesmente exibe uma vers√£o JSON formatada do manifesto da extens√£o.
* **An√°lise de Impress√£o Digital**: Detec√ß√£o de [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) e gera√ß√£o autom√°tica de JavaScript de impress√£o digital de extens√£o do Chrome.
* **An√°lise Potencial de Clickjacking**: Detec√ß√£o de p√°ginas HTML de extens√£o com a diretiva [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) definida. Estas s√£o potencialmente vulner√°veis a clickjacking dependendo do prop√≥sito das p√°ginas.
* Visualizador de **Aviso(s) de Permiss√£o**: que mostra uma lista de todos os avisos de solicita√ß√£o de permiss√£o do Chrome que ser√£o exibidos quando um usu√°rio tentar instalar a extens√£o.
* **Fun√ß√£o(√µes) Perigosa(s)**: mostra a localiza√ß√£o de fun√ß√µes perigosas que poderiam potencialmente ser exploradas por um atacante (por exemplo, fun√ß√µes como innerHTML, chrome.tabs.executeScript).
* **Ponto(s) de Entrada**: mostra onde a extens√£o recebe entrada de usu√°rio/externa. Isso √© √∫til para entender a √°rea de superf√≠cie de uma extens√£o e procurar pontos potenciais para enviar dados maliciosamente elaborados para a extens√£o.
* Tanto os scanners de Fun√ß√£o(√µes) Perigosa(s) quanto de Ponto(s) de Entrada t√™m o seguinte para seus alertas gerados:
* Trecho de c√≥digo relevante e linha que causou o alerta.
* Descri√ß√£o do problema.
* Um bot√£o ‚ÄúVer Arquivo‚Äù para visualizar o arquivo fonte completo contendo o c√≥digo.
* O caminho do arquivo alertado.
* A URI completa da extens√£o do Chrome do arquivo alertado.
* O tipo de arquivo que √©, como um script de P√°gina de Fundo, Script de Conte√∫do, A√ß√£o do Navegador, etc.
* Se a linha vulner√°vel estiver em um arquivo JavaScript, os caminhos de todas as p√°ginas onde est√° inclu√≠da, bem como o tipo dessas p√°ginas, e o status de [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Analisador de Pol√≠tica de Seguran√ßa de Conte√∫do (CSP) e verificador de bypass**: Isso apontar√° fraquezas na CSP da sua extens√£o e tamb√©m iluminar√° quaisquer maneiras potenciais de contornar sua CSP devido a CDNs na lista branca, etc.
* **Bibliotecas Conhecidas Vulner√°veis**: Isso usa [Retire.js](https://retirejs.github.io/retire.js/) para verificar qualquer uso de bibliotecas JavaScript conhecidas como vulner√°veis.
* Baixar extens√£o e vers√µes formatadas.
* Baixar a extens√£o original.
* Baixar uma vers√£o embelezada da extens√£o (HTML e JavaScript automaticamente formatados).
* Cache autom√°tico dos resultados da varredura, executar uma varredura de extens√£o levar√° um bom tempo na primeira vez que voc√™ a executar. No entanto, na segunda vez, assumindo que a extens√£o n√£o foi atualizada, ser√° quase instant√¢neo devido aos resultados estarem em cache.
* URLs de Relat√≥rio link√°veis, facilmente vincule algu√©m a um relat√≥rio de extens√£o gerado pelo tarnish.

### [Neto](https://github.com/elevenpaths/neto)

O projeto Neto √© um pacote Python 3 concebido para analisar e desvendar recursos ocultos de plugins e extens√µes de navegadores bem conhecidos, como Firefox e Chrome. Ele automatiza o processo de descompactar os arquivos empacotados para extrair esses recursos de recursos relevantes em uma extens√£o, como `manifest.json`, pastas de localiza√ß√£o ou arquivos de origem JavaScript e HTML.

## Refer√™ncias

* **Agradecimentos a** [**@naivenom**](https://twitter.com/naivenom) **pela ajuda com esta metodologia**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
