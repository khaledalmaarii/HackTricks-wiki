# Metodolog√≠a de Pentesting de Extensiones de Navegador

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

## Informaci√≥n B√°sica

Las extensiones de navegador est√°n escritas en JavaScript y son cargadas por el navegador en segundo plano. Tienen su [DOM](https://www.w3schools.com/js/js\_htmldom.asp) pero pueden interactuar con los DOMs de otros sitios. Esto significa que puede comprometer la confidencialidad, integridad y disponibilidad (CIA) de otros sitios.

## Componentes Principales

Los dise√±os de las extensiones se ven mejor cuando se visualizan y constan de tres componentes. Veamos cada componente en profundidad.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Contenido**

Cada script de contenido tiene acceso directo al DOM de una **√∫nica p√°gina web** y, por lo tanto, est√° expuesto a **entradas potencialmente maliciosas**. Sin embargo, el script de contenido no contiene permisos aparte de la capacidad de enviar mensajes al n√∫cleo de la extensi√≥n.

### **N√∫cleo de la Extensi√≥n**

El n√∫cleo de la extensi√≥n contiene la mayor√≠a de los privilegios/accesos de la extensi√≥n, pero el n√∫cleo de la extensi√≥n solo puede interactuar con el contenido web a trav√©s de [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) y scripts de contenido. Adem√°s, el n√∫cleo de la extensi√≥n no tiene acceso directo a la m√°quina host.

### **Binario Nativo**

La extensi√≥n permite un binario nativo que puede **acceder a la m√°quina host con todos los privilegios del usuario.** El binario nativo interact√∫a con el n√∫cleo de la extensi√≥n a trav√©s de la interfaz de programaci√≥n de aplicaciones de plugins de Netscape est√°ndar ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilizada por Flash y otros complementos de navegador.

### L√≠mites

{% hint style="danger" %}
Para obtener los privilegios completos del usuario, un atacante debe convencer a la extensi√≥n de pasar entradas maliciosas del script de contenido al n√∫cleo de la extensi√≥n y del n√∫cleo de la extensi√≥n al binario nativo.
{% endhint %}

Cada componente de la extensi√≥n est√° separado entre s√≠ por **fuertes l√≠mites protectores**. Cada componente se ejecuta en un **proceso de sistema operativo separado**. Los scripts de contenido y los n√∫cleos de extensi√≥n se ejecutan en **procesos de sandbox** no disponibles para la mayor√≠a de los servicios del sistema operativo.

Adem√°s, los scripts de contenido est√°n separados de sus p√°ginas web asociadas al **ejecutarse en un mont√≥n de JavaScript separado**. El script de contenido y la p√°gina web tienen **acceso al mismo DOM subyacente**, pero los dos **nunca intercambian punteros de JavaScript**, lo que previene la filtraci√≥n de funcionalidad de JavaScript.

## **`manifest.json`**

Una extensi√≥n de Chrome es solo una carpeta ZIP con una [.crx file extension](https://www.lifewire.com/crx-file-2620391). El n√∫cleo de la extensi√≥n es el **`manifest.json`** archivo en la ra√≠z de la carpeta, que especifica el dise√±o, permisos y otras opciones de configuraci√≥n.

Ejemplo:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Los scripts de contenido se **cargan** cada vez que el usuario **navega a una p√°gina que coincide**, en nuestro caso, cualquier p√°gina que coincida con la **`https://example.com/*`** expresi√≥n y que no coincida con la **`*://*/*/business*`** regex. Se ejecutan **como los propios scripts de la p√°gina** y tienen acceso arbitrario al [Modelo de Objetos del Documento (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) de la p√°gina.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Para incluir o excluir m√°s URLs, tambi√©n es posible usar **`include_globs`** y **`exclude_globs`**.

Este es un ejemplo de script de contenido que a√±adir√° un bot√≥n de explicaci√≥n a la p√°gina cuando [la API de almacenamiento](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) para recuperar el valor de `message` del almacenamiento de la extensi√≥n.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Un mensaje es enviado a las p√°ginas de la extensi√≥n por el script de contenido cuando se hace clic en este bot√≥n, a trav√©s de la utilizaci√≥n de la [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Esto se debe a la limitaci√≥n del script de contenido en el acceso directo a las APIs, siendo `storage` una de las pocas excepciones. Para funcionalidades m√°s all√° de estas excepciones, se env√≠an mensajes a las p√°ginas de la extensi√≥n con las que los scripts de contenido pueden comunicarse.

{% hint style="warning" %}
Dependiendo del navegador, las capacidades del script de contenido pueden variar ligeramente. Para navegadores basados en Chromium, la lista de capacidades est√° disponible en la [documentaci√≥n de Chrome Developers](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), y para Firefox, el [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) sirve como la fuente principal.\
Tambi√©n es notable que los scripts de contenido tienen la capacidad de comunicarse con scripts de fondo, lo que les permite realizar acciones y retransmitir respuestas.
{% endhint %}

Para ver y depurar scripts de contenido en Chrome, se puede acceder al men√∫ de herramientas de desarrollador de Chrome desde Opciones > M√°s herramientas > Herramientas de desarrollador O presionando Ctrl + Shift + I.

Una vez que se muestran las herramientas de desarrollador, se debe hacer clic en la **pesta√±a Fuente**, seguida de la pesta√±a **Scripts de contenido**. Esto permite observar los scripts de contenido en ejecuci√≥n de varias extensiones y establecer puntos de interrupci√≥n para rastrear el flujo de ejecuci√≥n.

### Scripts de contenido inyectados

{% hint style="success" %}
Tenga en cuenta que **los scripts de contenido no son obligatorios** ya que tambi√©n es posible **inyectar din√°micamente** scripts y **inyectarlos program√°ticamente** en p√°ginas web a trav√©s de **`tabs.executeScript`**. Esto en realidad proporciona un control m√°s **granular**.
{% endhint %}

Para la inyecci√≥n program√°tica de un script de contenido, se requiere que la extensi√≥n tenga [permisos de host](https://developer.chrome.com/docs/extensions/reference/permissions) para la p√°gina en la que se van a inyectar los scripts. Estos permisos pueden asegurarse ya sea **solicit√°ndolos** dentro del manifiesto de la extensi√≥n o de manera temporal a trav√©s de [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Ejemplo de extensi√≥n basada en activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Inyectar un archivo JS al hacer clic:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Inyectar una funci√≥n** al hacer clic:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Ejemplo con permisos de scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Para incluir o excluir m√°s URLs, tambi√©n es posible usar **`include_globs`** y **`exclude_globs`**.

### Scripts de Contenido `run_at`

El campo `run_at` controla **cu√°ndo se inyectan los archivos JavaScript en la p√°gina web**. El valor preferido y predeterminado es `"document_idle"`.

Los valores posibles son:

* **`document_idle`**: Siempre que sea posible
* **`document_start`**: Despu√©s de cualquier archivo de `css`, pero antes de que se construya cualquier otro DOM o se ejecute cualquier otro script.
* **`document_end`**: Inmediatamente despu√©s de que el DOM est√© completo, pero antes de que se hayan cargado subrecursos como im√°genes y marcos.

#### A trav√©s de `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
A trav√©s de **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

Los mensajes enviados por los scripts de contenido son recibidos por la **p√°gina de fondo**, que desempe√±a un papel central en la coordinaci√≥n de los componentes de la extensi√≥n. Notablemente, la p√°gina de fondo persiste a lo largo de la vida de la extensi√≥n, operando discretamente sin interacci√≥n directa del usuario. Posee su propio Modelo de Objetos del Documento (DOM), lo que permite interacciones complejas y gesti√≥n del estado.

**Puntos Clave**:

* **Rol de la P√°gina de Fondo:** Act√∫a como el centro neur√°lgico de la extensi√≥n, asegurando la comunicaci√≥n y coordinaci√≥n entre las diversas partes de la extensi√≥n.
* **Persistencia:** Es una entidad siempre presente, invisible para el usuario pero integral para la funcionalidad de la extensi√≥n.
* **Generaci√≥n Autom√°tica:** Si no se define expl√≠citamente, el navegador crear√° autom√°ticamente una p√°gina de fondo. Esta p√°gina generada autom√°ticamente incluir√° todos los scripts de fondo especificados en el manifiesto de la extensi√≥n, asegurando el funcionamiento sin problemas de las tareas de fondo de la extensi√≥n.

{% hint style="success" %}
La conveniencia proporcionada por el navegador al generar autom√°ticamente una p√°gina de fondo (cuando no se declara expl√≠citamente) asegura que todos los scripts de fondo necesarios est√©n integrados y operativos, simplificando el proceso de configuraci√≥n de la extensi√≥n.
{% endhint %}

Ejemplo de script de fondo:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Utiliza la [API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) para escuchar mensajes. Cuando se recibe un mensaje de `"explain"`, utiliza la [API tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) para abrir una p√°gina en una nueva pesta√±a.

Para depurar el script de fondo, puedes ir a los **detalles de la extensi√≥n e inspeccionar el service worker,** esto abrir√° las herramientas de desarrollo con el script de fondo:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### P√°ginas de opciones y otras

Las extensiones de navegador pueden contener varios tipos de p√°ginas:

* **Las p√°ginas de acci√≥n** se muestran en un **men√∫ desplegable cuando se hace clic en el √≠cono de la extensi√≥n.**
* P√°ginas que la extensi√≥n **cargar√° en una nueva pesta√±a.**
* **P√°ginas de opciones**: Esta p√°gina se muestra en la parte superior de la extensi√≥n cuando se hace clic. En el manifiesto anterior, en mi caso, pude acceder a esta p√°gina en `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` o haciendo clic en:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Ten en cuenta que estas p√°ginas no son persistentes como las p√°ginas de fondo, ya que cargan contenido din√°micamente seg√∫n sea necesario. A pesar de esto, comparten ciertas capacidades con la p√°gina de fondo:

* **Comunicaci√≥n con scripts de contenido:** Similar a la p√°gina de fondo, estas p√°ginas pueden recibir mensajes de scripts de contenido, facilitando la interacci√≥n dentro de la extensi√≥n.
* **Acceso a APIs espec√≠ficas de la extensi√≥n:** Estas p√°ginas disfrutan de acceso completo a APIs espec√≠ficas de la extensi√≥n, sujeto a los permisos definidos para la extensi√≥n.

### `permissions` & `host_permissions`

**`permissions`** y **`host_permissions`** son entradas del `manifest.json` que indicar√°n **qu√© permisos** tiene la extensi√≥n del navegador (almacenamiento, ubicaci√≥n...) y en **qu√© p√°ginas web**.

Dado que las extensiones de navegador pueden ser tan **privilegiadas**, una maliciosa o una que haya sido comprometida podr√≠a permitir al atacante **diferentes medios para robar informaci√≥n sensible y espiar al usuario**.

Consulta c√≥mo funcionan estas configuraciones y c√≥mo podr√≠an ser abusadas en:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Una **pol√≠tica de seguridad de contenido** tambi√©n puede declararse dentro del `manifest.json`. Si hay una definida, podr√≠a ser **vulnerable**.

La configuraci√≥n predeterminada para las p√°ginas de extensiones de navegador es bastante restrictiva:
```bash
script-src 'self'; object-src 'self';
```
Para m√°s informaci√≥n sobre CSP y posibles bypasses, consulta:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Para que una p√°gina web acceda a una p√°gina de una extensi√≥n de navegador, una p√°gina `.html` por ejemplo, esta p√°gina debe mencionarse en el campo **`web_accessible_resources`** del `manifest.json`.\
Por ejemplo:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Estas p√°ginas son accesibles en URL como:
```
chrome-extension://<extension-id>/message.html
```
En las extensiones p√∫blicas, el **extension-id es accesible**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Sin embargo, si se utiliza el par√°metro **`use_dynamic_url`** en `manifest.json`, este **id puede ser din√°mico**.

{% hint style="success" %}
Ten en cuenta que incluso si una p√°gina se menciona aqu√≠, podr√≠a estar **protegida contra ClickJacking** gracias a la **Content Security Policy**. As√≠ que tambi√©n necesitas verificarlo (secci√≥n frame-ancestors) antes de confirmar que un ataque de ClickJacking es posible.
{% endhint %}

El hecho de poder acceder a estas p√°ginas hace que estas p√°ginas sean **potencialmente vulnerables a ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Permitir que estas p√°ginas se carguen solo por la extensi√≥n y no por URLs aleatorias podr√≠a prevenir ataques de ClickJacking.
{% endhint %}

{% hint style="danger" %}
Ten en cuenta que las p√°ginas de **`web_accessible_resources`** y otras p√°ginas de la extensi√≥n tambi√©n son capaces de **contactar scripts de fondo**. As√≠ que si una de estas p√°ginas es vulnerable a **XSS**, podr√≠a abrir una vulnerabilidad mayor.

Adem√°s, ten en cuenta que solo puedes abrir p√°ginas indicadas en **`web_accessible_resources`** dentro de iframes, pero desde una nueva pesta√±a es posible acceder a cualquier p√°gina en la extensi√≥n conociendo el ID de la extensi√≥n. Por lo tanto, si se encuentra un XSS abusando de los mismos par√°metros, podr√≠a ser explotado incluso si la p√°gina no est√° configurada en **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

Seg√∫n la [**documentaci√≥n**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propiedad de manifiesto `"externally_connectable"` declara **qu√© extensiones y p√°ginas web pueden conectarse** a tu extensi√≥n a trav√©s de [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) y [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la clave **`externally_connectable`** **no** est√° declarada en el manifiesto de tu extensi√≥n o se declara como **`"ids": ["*"]`**, **todas las extensiones pueden conectarse, pero ninguna p√°gina web puede conectarse**.
* Si se especifican **IDs espec√≠ficos**, como en `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **solo esas aplicaciones** pueden conectarse.
* Si se especifican **coincidencias**, esas aplicaciones web podr√°n conectarse:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Si se especifica como vac√≠o: **`"externally_connectable": {}`**, ninguna aplicaci√≥n o web podr√° conectarse.

Cuantas **menos extensiones y URLs** se indiquen aqu√≠, **menor ser√° la superficie de ataque**.

{% hint style="danger" %}
Si una p√°gina web **vulnerable a XSS o takeover** se indica en **`externally_connectable`**, un atacante podr√° **enviar mensajes directamente al script de fondo**, eludiendo completamente el Content Script y su CSP.

Por lo tanto, este es un **bypass muy poderoso**.

Adem√°s, si el cliente instala una extensi√≥n maliciosa, incluso si no se le permite comunicarse con la extensi√≥n vulnerable, podr√≠a inyectar **datos XSS en una p√°gina web permitida** o abusar de las APIs **`WebRequest`** o **`DeclarativeNetRequest`** para manipular solicitudes en un dominio objetivo alterando la solicitud de una **archivo JavaScript**. (Tenga en cuenta que el CSP en la p√°gina objetivo podr√≠a prevenir estos ataques). Esta idea proviene de [**este informe**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Resumen de comunicaci√≥n

### Extensi√≥n <--> WebApp

Para comunicarse entre el script de contenido y la p√°gina web, generalmente se utilizan mensajes post. Por lo tanto, en la aplicaci√≥n web, generalmente encontrar√° llamadas a la funci√≥n **`window.postMessage`** y en el script de contenido oyentes como **`window.addEventListener`**. Sin embargo, tenga en cuenta que la extensi√≥n tambi√©n podr√≠a **comunicarse con la aplicaci√≥n web enviando un Post Message** (y por lo tanto la web deber√≠a esperarlo) o simplemente hacer que la web cargue un nuevo script.

### Dentro de la extensi√≥n

Generalmente se utiliza la funci√≥n **`chrome.runtime.sendMessage`** para enviar un mensaje dentro de la extensi√≥n (generalmente manejado por el script `background`) y para recibirlo y manejarlo se declara un oyente llamando a **`chrome.runtime.onMessage.addListener`**.

Tambi√©n es posible usar **`chrome.runtime.connect()`** para tener una conexi√≥n persistente en lugar de enviar mensajes individuales, es posible usarlo para **enviar** y **recibir** **mensajes** como en el siguiente ejemplo:

<details>

<summary><code>chrome.runtime.connect()</code> ejemplo</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Tambi√©n es posible enviar mensajes desde un script de fondo a un script de contenido ubicado en una pesta√±a espec√≠fica llamando a **`chrome.tabs.sendMessage`** donde necesitar√°s indicar el **ID de la pesta√±a** a la que enviar el mensaje.

### Desde `externally_connectable` permitido a la extensi√≥n

**Las aplicaciones web y las extensiones de navegador externas permitidas** en la configuraci√≥n de `externally_connectable` pueden enviar solicitudes usando :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Donde es necesario mencionar el **extension ID**.

### Mensajer√≠a Nativa

Es posible que los scripts de fondo se comuniquen con binarios dentro del sistema, lo que podr√≠a ser **propenso a vulnerabilidades cr√≠ticas como RCEs** si esta comunicaci√≥n no est√° debidamente asegurada. [M√°s sobre esto m√°s adelante](./#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
## Web **‚ÜîÔ∏é** Comunicaci√≥n entre Scripts de Contenido

Los entornos donde operan los **scripts de contenido** y donde existen las p√°ginas anfitrionas est√°n **separados** entre s√≠, asegurando **aislamiento**. A pesar de este aislamiento, ambos tienen la capacidad de interactuar con el **Modelo de Objetos del Documento (DOM)** de la p√°gina, un recurso compartido. Para que la p√°gina anfitriona participe en la comunicaci√≥n con el **script de contenido**, o indirectamente con la extensi√≥n a trav√©s del script de contenido, se requiere utilizar el **DOM** que es accesible por ambas partes como canal de comunicaci√≥n.

### Mensajes Post

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Una comunicaci√≥n segura de Post Message debe verificar la autenticidad del mensaje recibido, esto se puede hacer verificando:

* **`event.isTrusted`**: Esto es Verdadero solo si el evento fue desencadenado por una acci√≥n del usuario.
* El script de contenido podr√≠a esperar un mensaje solo si el usuario realiza alguna acci√≥n.
* **dominio de origen**: podr√≠a esperar un mensaje solo de una lista permitida de dominios.
* Si se utiliza una expresi√≥n regular, ten mucho cuidado.
* **Fuente**: `received_message.source !== window` se puede usar para verificar si el mensaje fue **del mismo ventana** donde el Script de Contenido est√° escuchando.

Las verificaciones anteriores, incluso si se realizan, podr√≠an ser vulnerables, as√≠ que verifica en la siguiente p√°gina **posibles bypasses de Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Otra posible forma de comunicaci√≥n podr√≠a ser a trav√©s de **URLs de Iframe**, puedes encontrar un ejemplo en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Esto no es "exactamente" una forma de comunicaci√≥n, pero el **web y el script de contenido tendr√°n acceso al DOM web**. As√≠ que, si el **script de contenido** est√° leyendo alguna informaci√≥n de √©l, **confiando en el DOM web**, el web podr√≠a **modificar estos datos** (porque el web no deber√≠a ser confiable, o porque el web es vulnerable a XSS) y **comprometer el Script de Contenido**.

Tambi√©n puedes encontrar un ejemplo de un **XSS basado en DOM para comprometer una extensi√≥n de navegador** en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Comunicaci√≥n entre Script de Contenido **‚ÜîÔ∏é** Script de Fondo

Un Script de Contenido puede usar las funciones [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **o** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) para enviar un mensaje **serializable en JSON de una sola vez**.

Para manejar la **respuesta**, usa la **Promesa** devuelta. Aunque, por compatibilidad hacia atr√°s, a√∫n puedes pasar un **callback** como el √∫ltimo argumento.

Enviar una solicitud desde un **script de contenido** se ve as√≠:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Enviando una solicitud desde la **extensi√≥n** (generalmente un **script de fondo**). Ejemplo de c√≥mo enviar un mensaje al script de contenido en la pesta√±a seleccionada:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
En el **lado receptor**, necesitas configurar un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **escuchador de eventos** para manejar el mensaje. Esto se ve igual desde un script de contenido o una p√°gina de extensi√≥n.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
En el ejemplo destacado, **`sendResponse()`** se ejecut√≥ de manera sincr√≥nica. Para modificar el controlador de eventos `onMessage` para la ejecuci√≥n asincr√≥nica de `sendResponse()`, es imperativo incorporar `return true;`.

Una consideraci√≥n importante es que en escenarios donde m√∫ltiples p√°ginas est√°n configuradas para recibir eventos `onMessage`, **la primera p√°gina en ejecutar `sendResponse()`** para un evento espec√≠fico ser√° la √∫nica capaz de entregar la respuesta de manera efectiva. Cualquier respuesta subsiguiente al mismo evento no ser√° tenida en cuenta.

Al crear nuevas extensiones, la preferencia debe ser hacia promesas en lugar de callbacks. En cuanto al uso de callbacks, la funci√≥n `sendResponse()` se considera v√°lida solo si se ejecuta directamente dentro del contexto sincr√≥nico, o si el controlador de eventos indica una operaci√≥n asincr√≥nica al devolver `true`. Si ninguno de los controladores devuelve `true` o si la funci√≥n `sendResponse()` se elimina de la memoria (recolectada por el garbage collector), el callback asociado con la funci√≥n `sendMessage()` se activar√° por defecto.

## Mensajer√≠a Nativa

Las extensiones del navegador tambi√©n permiten comunicarse con **binarios en el sistema a trav√©s de stdin**. La aplicaci√≥n debe instalar un json que indique esto en un json como:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Donde el `name` es la cadena pasada a [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) o [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) para comunicarse con la aplicaci√≥n desde los scripts de fondo de la extensi√≥n del navegador. El `path` es la ruta al binario, solo hay 1 `type` v√°lido que es stdio (usar stdin y stdout) y los `allowed_origins` indican las extensiones que pueden acceder a √©l (y no pueden tener comod√≠n).

Chrome/Chromium buscar√° este json en algunos registros de Windows y algunas rutas en macOS y Linux (m√°s informaci√≥n en los [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

{% hint style="success" %}
La extensi√≥n del navegador tambi√©n necesita el permiso `nativeMessaing` declarado para poder usar esta comunicaci√≥n.
{% endhint %}

As√≠ es como se ve un c√≥digo de script de fondo enviando mensajes a una aplicaci√≥n nativa:
```javascript
chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
```
En [**esta publicaci√≥n del blog**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), se propone un patr√≥n vulnerable que abusa de los mensajes nativos:

1. La extensi√≥n del navegador tiene un patr√≥n comod√≠n para el script de contenido.
2. El script de contenido pasa mensajes `postMessage` al script de fondo usando `sendMessage`.
3. El script de fondo pasa el mensaje a la aplicaci√≥n nativa usando `sendNativeMessage`.
4. La aplicaci√≥n nativa maneja el mensaje de manera peligrosa, lo que lleva a la ejecuci√≥n de c√≥digo.

Y dentro de esto se explica un ejemplo de **c√≥mo ir de cualquier p√°gina a RCE abusando de una extensi√≥n del navegador**.

## Informaci√≥n Sensible en Memoria/C√≥digo/Portapapeles

Si una Extensi√≥n del Navegador almacena **informaci√≥n sensible dentro de su memoria**, esto podr√≠a ser **volcado** (especialmente en m√°quinas Windows) y **buscado** para esta informaci√≥n.

Por lo tanto, la memoria de la Extensi√≥n del Navegador **no debe considerarse segura** y **la informaci√≥n sensible** como credenciales o frases mnemot√©cnicas **no debe ser almacenada**.

Por supuesto, **no ponga informaci√≥n sensible en el c√≥digo**, ya que ser√° **p√∫blica**.

Para volcar la memoria del navegador, podr√≠a **volcar la memoria del proceso** o ir a la **configuraci√≥n** de la extensi√≥n del navegador y hacer clic en **`Inspeccionar pop-up`** -> En la secci√≥n **`Memoria`** -> **`Tomar un instant√°neo`** y **`CTRL+F`** para buscar dentro del instant√°neo informaci√≥n sensible.

Adem√°s, informaci√≥n altamente sensible como claves mnemot√©cnicas o contrase√±as **no deber√≠a permitirse que se copie en el portapapeles** (o al menos eliminarla del portapapeles en unos segundos) porque entonces los procesos que monitorean el portapapeles podr√°n obtenerlas.

## Cargando una Extensi√≥n en el Navegador

1. **Descargue** la Extensi√≥n del Navegador y descompr√≠mala.
2. Vaya a **`chrome://extensions/`** y **active** el `Modo de Desarrollador`.
3. Haga clic en el bot√≥n **`Cargar descomprimido`**.

En **Firefox**, vaya a **`about:debugging#/runtime/this-firefox`** y haga clic en el bot√≥n **`Cargar complemento temporal`**.

## Obteniendo el c√≥digo fuente de la tienda

El c√≥digo fuente de una extensi√≥n de Chrome se puede obtener a trav√©s de varios m√©todos. A continuaci√≥n se detallan explicaciones e instrucciones para cada opci√≥n.

### Descargar Extensi√≥n como ZIP a trav√©s de la L√≠nea de Comandos

El c√≥digo fuente de una extensi√≥n de Chrome se puede descargar como un archivo ZIP utilizando la l√≠nea de comandos. Esto implica usar `curl` para obtener el archivo ZIP de una URL espec√≠fica y luego extraer el contenido del archivo ZIP a un directorio. Aqu√≠ est√°n los pasos:

1. Reemplace `"extension_id"` con el ID real de la extensi√≥n.
2. Ejecute los siguientes comandos:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Usa el sitio web CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Usa la extensi√≥n CRX Viewer

Otro m√©todo conveniente es usar el Chrome Extension Source Viewer, que es un proyecto de c√≥digo abierto. Se puede instalar desde la [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). El c√≥digo fuente del visor est√° disponible en su [repositorio de GitHub](https://github.com/Rob--W/crxviewer).

### Ver el c√≥digo fuente de la extensi√≥n instalada localmente

Las extensiones de Chrome instaladas localmente tambi√©n se pueden inspeccionar. Aqu√≠ te explicamos c√≥mo:

1. Accede a tu directorio de perfil local de Chrome visitando `chrome://version/` y localizando el campo "Profile Path".
2. Navega a la subcarpeta `Extensions/` dentro del directorio del perfil.
3. Esta carpeta contiene todas las extensiones instaladas, t√≠picamente con su c√≥digo fuente en un formato legible.

Para identificar extensiones, puedes mapear sus IDs a nombres:

* Habilita el Modo Desarrollador en la p√°gina `about:extensions` para ver los IDs de cada extensi√≥n.
* Dentro de la carpeta de cada extensi√≥n, el archivo `manifest.json` contiene un campo `name` legible, ayud√°ndote a identificar la extensi√≥n.

### Usa un archivador de archivos o descompresor

Ve a la Chrome Web Store y descarga la extensi√≥n. El archivo tendr√° una extensi√≥n `.crx`. Cambia la extensi√≥n del archivo de `.crx` a `.zip`. Usa cualquier archivador de archivos (como WinRAR, 7-Zip, etc.) para extraer el contenido del archivo ZIP.

### Usa el Modo Desarrollador en Chrome

Abre Chrome y ve a `chrome://extensions/`. Habilita "Modo desarrollador" en la parte superior derecha. Haz clic en "Cargar extensi√≥n descomprimida...". Navega al directorio de tu extensi√≥n. Esto no descarga el c√≥digo fuente, pero es √∫til para ver y modificar el c√≥digo de una extensi√≥n ya descargada o desarrollada.

## Conjunto de datos del manifiesto de la extensi√≥n de Chrome

Para intentar detectar extensiones de navegador vulnerables, podr√≠as usar el [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) y revisar sus archivos de manifiesto en busca de se√±ales potencialmente vulnerables. Por ejemplo, para verificar extensiones con m√°s de 25000 usuarios, `content_scripts` y el permiso `nativeMessaing`:

{% code overflow="wrap" %}
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
{% endcode %}

## Lista de Verificaci√≥n de Auditor√≠a de Seguridad

Aunque las extensiones de navegador tienen una **superficie de ataque limitada**, algunas de ellas pueden contener **vulnerabilidades** o **mejoras de endurecimiento potenciales**. Las siguientes son las m√°s comunes:

* [ ] **Limitar** tanto como sea posible los **`permisos`** solicitados
* [ ] **Limitar** tanto como sea posible los **`host_permissions`**
* [ ] Usar una **pol√≠tica de seguridad de contenido** **`content_security_policy`** **fuerte**
* [ ] **Limitar** tanto como sea posible el **`externally_connectable`**, si no se necesita y es posible, no dejarlo por defecto, especificar **`{}`**
* [ ] Si se menciona aqu√≠ una **URL vulnerable a XSS o a toma de control**, un atacante podr√° **enviar mensajes a los scripts de fondo directamente**. Un bypass muy poderoso.
* [ ] **Limitar** tanto como sea posible los **`web_accessible_resources`**, incluso vac√≠os si es posible.
* [ ] Si **`web_accessible_resources`** no es ninguno, verificar [**ClickJacking**](browext-clickjacking.md)
* [ ] Si ocurre alguna **comunicaci√≥n** de la **extensi√≥n** a la **p√°gina web**, [**verificar XSS**](browext-xss-example.md) **vulnerabilidades** causadas en la comunicaci√≥n.
* [ ] Si se utilizan Post Messages, verificar [**vulnerabilidades de Post Message**](../postmessage-vulnerabilities/)**.**
* [ ] Si el **Content Script accede a detalles del DOM**, verificar que **no est√©n introduciendo un XSS** si son **modificados** por la web
* [ ] Hacer un √©nfasis especial si esta comunicaci√≥n tambi√©n est√° involucrada en la **comunicaci√≥n de Content Script -> script de fondo**
* [ ] Si el script de fondo se comunica a trav√©s de **native messaging**, verificar que la comunicaci√≥n sea segura y est√© saneada
* [ ] **La informaci√≥n sensible no debe ser almacenada** dentro del **c√≥digo** de la extensi√≥n del navegador
* [ ] **La informaci√≥n sensible no debe ser almacenada** dentro de la **memoria** de la extensi√≥n del navegador
* [ ] **La informaci√≥n sensible no debe ser almacenada** dentro del **sistema de archivos sin protecci√≥n**

## Herramientas

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Extrae cualquier extensi√≥n de Chrome de un enlace proporcionado de la tienda web de Chrome.
* Visor de [**manifest.json**](https://developer.chrome.com/extensions/manifest): simplemente muestra una versi√≥n JSON formateada del manifiesto de la extensi√≥n.
* **An√°lisis de huellas digitales**: Detecci√≥n de [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) y generaci√≥n autom√°tica de JavaScript de huellas digitales de extensiones de Chrome.
* **An√°lisis de Clickjacking potencial**: Detecci√≥n de p√°ginas HTML de extensiones con la directiva [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) establecida. Estas son potencialmente vulnerables a clickjacking dependiendo del prop√≥sito de las p√°ginas.
* Visor de advertencias de **permisos**: que muestra una lista de todas las advertencias de solicitud de permisos de Chrome que se mostrar√°n cuando un usuario intente instalar la extensi√≥n.
* **Funci√≥n(es) peligrosa(s)**: muestra la ubicaci√≥n de funciones peligrosas que podr√≠an ser potencialmente explotadas por un atacante (por ejemplo, funciones como innerHTML, chrome.tabs.executeScript).
* **Punto(s) de entrada**: muestra d√≥nde la extensi√≥n recibe entrada de usuario/externa. Esto es √∫til para entender la superficie de una extensi√≥n y buscar puntos potenciales para enviar datos maliciosamente elaborados a la extensi√≥n.
* Tanto los esc√°neres de Funci√≥n(es) Peligrosa(s) como de Punto(s) de Entrada tienen lo siguiente para sus alertas generadas:
* Fragmento de c√≥digo relevante y l√≠nea que caus√≥ la alerta.
* Descripci√≥n del problema.
* Un bot√≥n de ‚ÄúVer Archivo‚Äù para ver el archivo fuente completo que contiene el c√≥digo.
* La ruta del archivo alertado.
* La URI completa de la extensi√≥n de Chrome del archivo alertado.
* El tipo de archivo que es, como un script de P√°gina de Fondo, Script de Contenido, Acci√≥n del Navegador, etc.
* Si la l√≠nea vulnerable est√° en un archivo JavaScript, las rutas de todas las p√°ginas donde est√° incluida, as√≠ como el tipo de estas p√°ginas y el estado de [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Analizador de Pol√≠tica de Seguridad de Contenido (CSP) y verificador de bypass**: Esto se√±alar√° debilidades en la CSP de su extensi√≥n y tambi√©n iluminar√° cualquier forma potencial de eludir su CSP debido a CDNs en la lista blanca, etc.
* **Bibliotecas Vulnerables Conocidas**: Esto utiliza [Retire.js](https://retirejs.github.io/retire.js/) para verificar cualquier uso de bibliotecas JavaScript conocidas como vulnerables.
* Descargar extensi√≥n y versiones formateadas.
* Descargar la extensi√≥n original.
* Descargar una versi√≥n embellecida de la extensi√≥n (HTML y JavaScript auto formateados).
* Cach√© autom√°tica de resultados de escaneo, ejecutar un escaneo de extensi√≥n tomar√° un buen tiempo la primera vez que lo ejecute. Sin embargo, la segunda vez, suponiendo que la extensi√≥n no ha sido actualizada, ser√° casi instant√°neo debido a que los resultados est√°n en cach√©.
* URLs de informes enlazables, f√°cilmente enlazar a alguien m√°s a un informe de extensi√≥n generado por tarnish.

### [Neto](https://github.com/elevenpaths/neto)

El proyecto Neto es un paquete de Python 3 concebido para analizar y desentra√±ar caracter√≠sticas ocultas de plugins y extensiones de navegador para navegadores bien conocidos como Firefox y Chrome. Automatiza el proceso de descomprimir los archivos empaquetados para extraer estas caracter√≠sticas de recursos relevantes en una extensi√≥n como `manifest.json`, carpetas de localizaci√≥n o archivos fuente de Javascript y HTML.

## Referencias

* **Gracias a** [**@naivenom**](https://twitter.com/naivenom) **por la ayuda con esta metodolog√≠a**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
