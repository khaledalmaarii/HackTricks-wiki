# Metodolog铆a de Pentesting de Extensiones de Navegador

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci贸n**](https://github.com/sponsors/carlospolop)!
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

## Informaci贸n B谩sica

Las extensiones de navegador est谩n escritas en JavaScript y son cargadas por el navegador en segundo plano. Tienen su [DOM](https://www.w3schools.com/js/js\_htmldom.asp) pero pueden interactuar con los DOM de otros sitios. Esto significa que puede comprometer la confidencialidad, integridad y disponibilidad (CIA) de otros sitios.

## Componentes Principales

Los dise帽os de extensiones se ven mejor cuando se visualizan y constan de tres componentes. Veamos cada componente en profundidad.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Contenido**

Cada script de contenido tiene acceso directo al DOM de una **煤nica p谩gina web** y est谩 expuesto a **entrada potencialmente maliciosa**. Sin embargo, el script de contenido no contiene permisos aparte de la capacidad de enviar mensajes al n煤cleo de la extensi贸n.

### **N煤cleo de la Extensi贸n**

El n煤cleo de la extensi贸n contiene la mayor铆a de los privilegios/accesos de la extensi贸n, pero el n煤cleo de la extensi贸n solo puede interactuar con el contenido web a trav茅s de [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) y scripts de contenido. Adem谩s, el n煤cleo de la extensi贸n no tiene acceso directo a la m谩quina host.

### **Binario Nativo**

La extensi贸n permite un binario nativo que puede **acceder a la m谩quina host con todos los privilegios del usuario.** El binario nativo interact煤a con el n煤cleo de la extensi贸n a trav茅s de la interfaz de programaci贸n de aplicaciones de plugins de Netscape est谩ndar ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilizada por Flash y otros complementos de navegador.

### L铆mites

{% hint style="danger" %}
Para obtener los privilegios completos del usuario, un atacante debe convencer a la extensi贸n de pasar entrada maliciosa desde el script de contenido al n煤cleo de la extensi贸n y desde el n煤cleo de la extensi贸n al binario nativo.
{% endhint %}

Cada componente de la extensi贸n est谩 separado entre s铆 por **fuertes l铆mites protectores**. Cada componente se ejecuta en un **proceso de sistema operativo separado**. Los scripts de contenido y los n煤cleos de extensi贸n se ejecutan en **procesos de sandbox** no disponibles para la mayor铆a de los servicios del sistema operativo.

Adem谩s, los scripts de contenido est谩n separados de sus p谩ginas web asociadas al **ejecutarse en un mont贸n de JavaScript separado**. El script de contenido y la p谩gina web tienen **acceso al mismo DOM subyacente**, pero los dos **nunca intercambian punteros de JavaScript**, lo que previene la filtraci贸n de funcionalidad de JavaScript.

## **`manifest.json`**

Una extensi贸n de Chrome es solo una carpeta ZIP con una [.crx file extension](https://www.lifewire.com/crx-file-2620391). El n煤cleo de la extensi贸n es el **`manifest.json`** archivo en la ra铆z de la carpeta, que especifica el dise帽o, permisos y otras opciones de configuraci贸n.

Ejemplo:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Los scripts de contenido se **cargan** cada vez que el usuario **navega a una p谩gina que coincide**, en nuestro caso, cualquier p谩gina que coincida con la **`https://example.com/*`** expresi贸n y no coincida con la **`*://*/*/business*`** regex. Se ejecutan **como los propios scripts de la p谩gina** y tienen acceso arbitrario al [Modelo de Objetos del Documento (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) de la p谩gina.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Para incluir o excluir m谩s URLs, tambi茅n es posible usar **`include_globs`** y **`exclude_globs`**.

Este es un ejemplo de script de contenido que a帽adir谩 un bot贸n de explicaci贸n a la p谩gina cuando [la API de almacenamiento](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) para recuperar el valor de `message` del almacenamiento de la extensi贸n.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Un mensaje se env铆a a las p谩ginas de la extensi贸n por el script de contenido cuando se hace clic en este bot贸n, a trav茅s de la utilizaci贸n de la [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Esto se debe a la limitaci贸n del script de contenido en el acceso directo a las APIs, siendo `storage` una de las pocas excepciones. Para funcionalidades m谩s all谩 de estas excepciones, se env铆an mensajes a las p谩ginas de la extensi贸n con las que los scripts de contenido pueden comunicarse.

{% hint style="warning" %}
Dependiendo del navegador, las capacidades del script de contenido pueden variar ligeramente. Para los navegadores basados en Chromium, la lista de capacidades est谩 disponible en la [documentaci贸n de Chrome Developers](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), y para Firefox, el [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) sirve como la fuente principal.\
Tambi茅n es notable que los scripts de contenido tienen la capacidad de comunicarse con los scripts de fondo, lo que les permite realizar acciones y retransmitir respuestas.
{% endhint %}

Para ver y depurar scripts de contenido en Chrome, se puede acceder al men煤 de herramientas de desarrollador de Chrome desde Opciones > M谩s herramientas > Herramientas de desarrollador O presionando Ctrl + Shift + I.

Una vez que se muestran las herramientas de desarrollador, se debe hacer clic en la **pesta帽a Fuente**, seguida de la pesta帽a **Scripts de contenido**. Esto permite observar los scripts de contenido en ejecuci贸n de varias extensiones y establecer puntos de interrupci贸n para rastrear el flujo de ejecuci贸n.

### Scripts de contenido inyectados

{% hint style="success" %}
Tenga en cuenta que **los scripts de contenido no son obligatorios** ya que tambi茅n es posible **inyectar din谩micamente** scripts y **inyectarlos program谩ticamente** en p谩ginas web a trav茅s de **`tabs.executeScript`**. Esto proporciona en realidad m谩s **controles granulares**.
{% endhint %}

Para la inyecci贸n program谩tica de un script de contenido, se requiere que la extensi贸n tenga [permisos de host](https://developer.chrome.com/docs/extensions/reference/permissions) para la p谩gina en la que se van a inyectar los scripts. Estos permisos pueden asegurarse ya sea **solicit谩ndolos** dentro del manifiesto de la extensi贸n o de manera temporal a trav茅s de [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Ejemplo de extensi贸n basada en activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Inyectar un archivo JS al hacer clic:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Inyectar una funci贸n** al hacer clic:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Ejemplo con permisos de scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Para incluir o excluir m谩s URLs, tambi茅n es posible usar **`include_globs`** y **`exclude_globs`**.

### Content Scripts `run_at`

El campo `run_at` controla **cu谩ndo se inyectan los archivos JavaScript en la p谩gina web**. El valor preferido y predeterminado es `"document_idle"`.

Los valores posibles son:

* **`document_idle`**: Siempre que sea posible
* **`document_start`**: Despu茅s de cualquier archivo de `css`, pero antes de que se construya cualquier otro DOM o se ejecute cualquier otro script.
* **`document_end`**: Inmediatamente despu茅s de que el DOM est茅 completo, pero antes de que se hayan cargado subrecursos como im谩genes y marcos.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
A trav茅s de **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

Los mensajes enviados por los scripts de contenido son recibidos por la **p谩gina de fondo**, que desempe帽a un papel central en la coordinaci贸n de los componentes de la extensi贸n. Notablemente, la p谩gina de fondo persiste a lo largo de la vida de la extensi贸n, operando discretamente sin interacci贸n directa del usuario. Posee su propio Modelo de Objetos del Documento (DOM), lo que permite interacciones complejas y gesti贸n del estado.

**Puntos Clave**:

* **Rol de la P谩gina de Fondo:** Act煤a como el centro neur谩lgico de la extensi贸n, asegurando la comunicaci贸n y coordinaci贸n entre las diversas partes de la extensi贸n.
* **Persistencia:** Es una entidad siempre presente, invisible para el usuario pero integral para la funcionalidad de la extensi贸n.
* **Generaci贸n Autom谩tica:** Si no se define expl铆citamente, el navegador crear谩 autom谩ticamente una p谩gina de fondo. Esta p谩gina generada autom谩ticamente incluir谩 todos los scripts de fondo especificados en el manifiesto de la extensi贸n, asegurando el funcionamiento sin problemas de las tareas de fondo de la extensi贸n.

{% hint style="success" %}
La conveniencia proporcionada por el navegador al generar autom谩ticamente una p谩gina de fondo (cuando no se declara expl铆citamente) asegura que todos los scripts de fondo necesarios est茅n integrados y operativos, simplificando el proceso de configuraci贸n de la extensi贸n.
{% endhint %}

Ejemplo de script de fondo:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Utiliza la [API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) para escuchar mensajes. Cuando se recibe un mensaje `"explain"`, utiliza la [API tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) para abrir una p谩gina en una nueva pesta帽a.

Para depurar el script de fondo, puedes ir a los **detalles de la extensi贸n e inspeccionar el service worker,** esto abrir谩 las herramientas de desarrollo con el script de fondo:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### P谩ginas de opciones y otras

Las extensiones de navegador pueden contener varios tipos de p谩ginas:

* **Las p谩ginas de acci贸n** se muestran en un **men煤 desplegable cuando se hace clic en el 铆cono de la extensi贸n.**
* P谩ginas que la extensi贸n **cargar谩 en una nueva pesta帽a.**
* **P谩ginas de opciones**: Esta p谩gina se muestra en la parte superior de la extensi贸n cuando se hace clic. En el manifiesto anterior, en mi caso, pude acceder a esta p谩gina en `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` o haciendo clic en:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Ten en cuenta que estas p谩ginas no son persistentes como las p谩ginas de fondo, ya que cargan contenido din谩micamente seg煤n sea necesario. A pesar de esto, comparten ciertas capacidades con la p谩gina de fondo:

* **Comunicaci贸n con scripts de contenido:** Similar a la p谩gina de fondo, estas p谩ginas pueden recibir mensajes de scripts de contenido, facilitando la interacci贸n dentro de la extensi贸n.
* **Acceso a APIs espec铆ficas de la extensi贸n:** Estas p谩ginas disfrutan de acceso completo a APIs espec铆ficas de la extensi贸n, sujeto a los permisos definidos para la extensi贸n.

### `permissions` & `host_permissions`

**`permissions`** y **`host_permissions`** son entradas del `manifest.json` que indicar谩n **qu茅 permisos** tiene la extensi贸n del navegador (almacenamiento, ubicaci贸n...) y en **qu茅 p谩ginas web**.

Dado que las extensiones de navegador pueden ser tan **privilegiadas**, una maliciosa o una que haya sido comprometida podr铆a permitir al atacante **diferentes medios para robar informaci贸n sensible y espiar al usuario**.

Consulta c贸mo funcionan estas configuraciones y c贸mo podr铆an ser abusadas en:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Una **pol铆tica de seguridad de contenido** tambi茅n puede declararse dentro del `manifest.json`. Si hay una definida, podr铆a ser **vulnerable**.

La configuraci贸n predeterminada para las p谩ginas de extensiones de navegador es bastante restrictiva:
```bash
script-src 'self'; object-src 'self';
```
Para m谩s informaci贸n sobre CSP y posibles bypasses, consulta:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Para que una p谩gina web acceda a una p谩gina de una extensi贸n de navegador, una p谩gina `.html` por ejemplo, esta p谩gina debe mencionarse en el campo **`web_accessible_resources`** del `manifest.json`.\
Por ejemplo:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Estas p谩ginas son accesibles en URL como:
```
chrome-extension://<extension-id>/message.html
```
En las extensiones p煤blicas, el **extension-id es accesible**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Sin embargo, si se utiliza el par谩metro **`use_dynamic_url`** en el `manifest.json`, este **id puede ser din谩mico**.

{% hint style="success" %}
Ten en cuenta que incluso si una p谩gina se menciona aqu铆, podr铆a estar **protegida contra ClickJacking** gracias a la **Content Security Policy**. As铆 que tambi茅n necesitas verificarlo (secci贸n frame-ancestors) antes de confirmar que un ataque de ClickJacking es posible.
{% endhint %}

El acceso a estas p谩ginas hace que estas p谩ginas sean **potencialmente vulnerables a ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Permitir que estas p谩ginas se carguen solo por la extensi贸n y no por URLs aleatorias podr铆a prevenir ataques de ClickJacking.
{% endhint %}

{% hint style="danger" %}
Ten en cuenta que las p谩ginas de **`web_accessible_resources`** y otras p谩ginas de la extensi贸n tambi茅n son capaces de **contactar scripts de fondo**. As铆 que si una de estas p谩ginas es vulnerable a **XSS**, podr铆a abrir una vulnerabilidad mayor.

Adem谩s, ten en cuenta que solo puedes abrir p谩ginas indicadas en **`web_accessible_resources`** dentro de iframes, pero desde una nueva pesta帽a es posible acceder a cualquier p谩gina en la extensi贸n conociendo el ID de la extensi贸n. Por lo tanto, si se encuentra un XSS abusando de los mismos par谩metros, podr铆a ser explotado incluso si la p谩gina no est谩 configurada en **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

Seg煤n la [**documentaci贸n**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propiedad del manifiesto `"externally_connectable"` declara **qu茅 extensiones y p谩ginas web pueden conectarse** a tu extensi贸n a trav茅s de [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) y [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la clave **`externally_connectable`** **no** est谩 declarada en el manifiesto de tu extensi贸n o est谩 declarada como **`"ids": ["*"]`**, **todas las extensiones pueden conectarse, pero ninguna p谩gina web puede conectarse**.
* Si se especifican **IDs espec铆ficos**, como en `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **solo esas aplicaciones** pueden conectarse.
* Si se especifican **coincidencias**, esas aplicaciones web podr谩n conectarse:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Si se especifica como vac铆o: **`"externally_connectable": {}`**, ninguna aplicaci贸n o web podr谩 conectarse.

Cuantas **menos extensiones y URLs** se indiquen aqu铆, **menor ser谩 la superficie de ataque**.

{% hint style="danger" %}
Si una p谩gina web **vulnerable a XSS o takeover** se indica en **`externally_connectable`**, un atacante podr谩 **enviar mensajes directamente al script de fondo**, eludiendo completamente el Content Script y su CSP.

Por lo tanto, este es un **bypass muy poderoso**.

Adem谩s, si el cliente instala una extensi贸n maliciosa, incluso si no se le permite comunicarse con la extensi贸n vulnerable, podr铆a inyectar **datos XSS en una p谩gina web permitida** o abusar de las APIs **`WebRequest`** o **`DeclarativeNetRequest`** para manipular solicitudes en un dominio objetivo alterando la solicitud de una **archivo JavaScript**. (Tenga en cuenta que el CSP en la p谩gina objetivo podr铆a prevenir estos ataques). Esta idea proviene de [**este informe**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Resumen de comunicaci贸n

### Extensi贸n <--> WebApp

Para comunicarse entre el script de contenido y la p谩gina web, generalmente se utilizan mensajes post. Por lo tanto, en la aplicaci贸n web, generalmente encontrar谩 llamadas a la funci贸n **`window.postMessage`** y en el script de contenido oyentes como **`window.addEventListener`**. Sin embargo, tenga en cuenta que la extensi贸n tambi茅n podr铆a **comunicarse con la aplicaci贸n web enviando un Post Message** (y por lo tanto la web deber铆a esperarlo) o simplemente hacer que la web cargue un nuevo script.

### Dentro de la extensi贸n

Generalmente se utiliza la funci贸n **`chrome.runtime.sendMessage`** para enviar un mensaje dentro de la extensi贸n (generalmente manejado por el script `background`) y para recibirlo y manejarlo se declara un oyente llamando a **`chrome.runtime.onMessage.addListener`**.

Tambi茅n es posible usar **`chrome.runtime.connect()`** para tener una conexi贸n persistente en lugar de enviar mensajes individuales, es posible usarlo para **enviar** y **recibir** **mensajes** como en el siguiente ejemplo:

<details>

<summary><code>chrome.runtime.connect()</code> ejemplo</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Tambi茅n es posible enviar mensajes desde un script de fondo a un script de contenido ubicado en una pesta帽a espec铆fica llamando a **`chrome.tabs.sendMessage`** donde necesitar谩s indicar el **ID de la pesta帽a** a la que enviar el mensaje.

### Desde `externally_connectable` permitido a la extensi贸n

**Las aplicaciones web y las extensiones de navegador externas permitidas** en la configuraci贸n de `externally_connectable` pueden enviar solicitudes usando :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Donde es necesario mencionar el **extension ID**.

## Web **锔** Comunicaci贸n de Scripts de Contenido

Los entornos donde operan los **scripts de contenido** y donde existen las p谩ginas host est谩n **separados** entre s铆, asegurando **aislamiento**. A pesar de este aislamiento, ambos tienen la capacidad de interactuar con el **Document Object Model (DOM)** de la p谩gina, un recurso compartido. Para que la p谩gina host participe en la comunicaci贸n con el **script de contenido**, o indirectamente con la extensi贸n a trav茅s del script de contenido, es necesario utilizar el **DOM** que es accesible por ambas partes como canal de comunicaci贸n.

### Mensajes Post

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Una comunicaci贸n segura de Post Message debe verificar la autenticidad del mensaje recibido, esto se puede hacer verificando:

* **`event.isTrusted`**: Esto es Verdadero solo si el evento fue desencadenado por una acci贸n del usuario.
* El script de contenido podr铆a esperar un mensaje solo si el usuario realiza alguna acci贸n.
* **dominio de origen**: podr铆a esperar un mensaje solo de una lista permitida de dominios.
* Si se utiliza una expresi贸n regular, ten mucho cuidado.
* **Fuente**: `received_message.source !== window` se puede usar para verificar si el mensaje fue **de la misma ventana** donde el Script de Contenido est谩 escuchando.

Las verificaciones anteriores, incluso si se realizan, podr铆an ser vulnerables, as铆 que verifica en la siguiente p谩gina **posibles bypasses de Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Otra posible forma de comunicaci贸n podr铆a ser a trav茅s de **URLs de Iframe**, puedes encontrar un ejemplo en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Esto no es "exactamente" una forma de comunicaci贸n, pero el **web y el script de contenido tendr谩n acceso al DOM web**. As铆 que, si el **script de contenido** est谩 leyendo alguna informaci贸n de 茅l, **confiando en el DOM web**, el web podr铆a **modificar estos datos** (porque el web no deber铆a ser confiable, o porque el web es vulnerable a XSS) y **comprometer el Script de Contenido**.

Tambi茅n puedes encontrar un ejemplo de un **XSS basado en DOM para comprometer una extensi贸n de navegador** en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Comunicaci贸n entre Script de Contenido **锔** Script de Fondo

Un Script de Contenido puede usar las funciones [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **o** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) para enviar un mensaje **serializable en JSON de una sola vez**.

Para manejar la **respuesta**, usa la **Promesa** devuelta. Aunque, por compatibilidad hacia atr谩s, a煤n puedes pasar un **callback** como el 煤ltimo argumento.

Enviar una solicitud desde un **script de contenido** se ve as铆:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Enviando una solicitud desde la **extensi贸n** (generalmente un **script de fondo**). Ejemplo de c贸mo enviar un mensaje al script de contenido en la pesta帽a seleccionada:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
En el **lado receptor**, necesitas configurar un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **escuchador de eventos** para manejar el mensaje. Esto se ve igual desde un script de contenido o una p谩gina de extensi贸n.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
En el ejemplo destacado, **`sendResponse()`** se ejecut贸 de manera sincr贸nica. Para modificar el controlador de eventos `onMessage` para la ejecuci贸n asincr贸nica de `sendResponse()`, es imperativo incorporar `return true;`.

Una consideraci贸n importante es que en escenarios donde m煤ltiples p谩ginas est谩n configuradas para recibir eventos `onMessage`, **la primera p谩gina en ejecutar `sendResponse()`** para un evento espec铆fico ser谩 la 煤nica capaz de entregar la respuesta de manera efectiva. Cualquier respuesta posterior al mismo evento no ser谩 tenida en cuenta.

Al crear nuevas extensiones, la preferencia debe ser hacia promesas en lugar de callbacks. Con respecto al uso de callbacks, la funci贸n `sendResponse()` se considera v谩lida solo si se ejecuta directamente dentro del contexto sincr贸nico, o si el controlador de eventos indica una operaci贸n asincr贸nica al devolver `true`. Si ninguno de los controladores devuelve `true` o si la funci贸n `sendResponse()` se elimina de la memoria (recolectada por el garbage collector), el callback asociado con la funci贸n `sendMessage()` se activar谩 por defecto.

## Informaci贸n Sensible en Memoria/C贸digo/Portapapeles

Si una extensi贸n de navegador almacena **informaci贸n sensible dentro de su memoria**, esto podr铆a ser **volcado** (especialmente en m谩quinas con Windows) y **buscado** para esta informaci贸n.

Por lo tanto, la memoria de la extensi贸n de navegador **no debe considerarse segura** y **la informaci贸n sensible** como credenciales o frases mnemot茅cnicas **no debe ser almacenada**.

Por supuesto, **no ponga informaci贸n sensible en el c贸digo**, ya que ser谩 **p煤blica**.

Para volcar la memoria del navegador, podr铆a **volcar la memoria del proceso** o ir a la **configuraci贸n** de la extensi贸n del navegador y hacer clic en **`Inspeccionar pop-up`** -> En la secci贸n **`Memoria`** -> **`Tomar un snapshot`** y **`CTRL+F`** para buscar dentro del snapshot informaci贸n sensible.

Adem谩s, informaci贸n altamente sensible como claves mnemot茅cnicas o contrase帽as **no deber铆a permitirse que se copie en el portapapeles** (o al menos eliminarla del portapapeles en unos segundos) porque entonces los procesos que monitorean el portapapeles podr谩n obtenerlas.

## Cargando una Extensi贸n en el Navegador

1. **Descargue** la extensi贸n del navegador y descompr铆mala.
2. Vaya a **`chrome://extensions/`** y **active** el `Modo de Desarrollador`.
3. Haga clic en el bot贸n **`Cargar descomprimido`**.

En **Firefox**, vaya a **`about:debugging#/runtime/this-firefox`** y haga clic en el bot贸n **`Cargar complemento temporal`**.

## Obteniendo el c贸digo fuente de la tienda

El c贸digo fuente de una extensi贸n de Chrome se puede obtener a trav茅s de varios m茅todos. A continuaci贸n se detallan explicaciones e instrucciones para cada opci贸n.

### Descargar Extensi贸n como ZIP a trav茅s de la L铆nea de Comandos

El c贸digo fuente de una extensi贸n de Chrome se puede descargar como un archivo ZIP utilizando la l铆nea de comandos. Esto implica usar `curl` para obtener el archivo ZIP de una URL espec铆fica y luego extraer el contenido del archivo ZIP a un directorio. Aqu铆 est谩n los pasos:

1. Reemplace `"extension_id"` con el ID real de la extensi贸n.
2. Ejecute los siguientes comandos:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Usa el sitio web CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Usa la extensi贸n CRX Viewer

Otro m茅todo conveniente es usar el Chrome Extension Source Viewer, que es un proyecto de c贸digo abierto. Se puede instalar desde la [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). El c贸digo fuente del visor est谩 disponible en su [repositorio de GitHub](https://github.com/Rob--W/crxviewer).

### Ver el c贸digo fuente de la extensi贸n instalada localmente

Las extensiones de Chrome instaladas localmente tambi茅n se pueden inspeccionar. Aqu铆 te explicamos c贸mo:

1. Accede a tu directorio de perfil local de Chrome visitando `chrome://version/` y localizando el campo "Profile Path".
2. Navega a la subcarpeta `Extensions/` dentro del directorio del perfil.
3. Esta carpeta contiene todas las extensiones instaladas, t铆picamente con su c贸digo fuente en un formato legible.

Para identificar las extensiones, puedes mapear sus IDs a nombres:

* Activa el Modo Desarrollador en la p谩gina `about:extensions` para ver los IDs de cada extensi贸n.
* Dentro de la carpeta de cada extensi贸n, el archivo `manifest.json` contiene un campo `name` legible, ayud谩ndote a identificar la extensi贸n.

### Usa un archivador de archivos o descompresor

Ve a la Chrome Web Store y descarga la extensi贸n. El archivo tendr谩 una extensi贸n `.crx`. Cambia la extensi贸n del archivo de `.crx` a `.zip`. Usa cualquier archivador de archivos (como WinRAR, 7-Zip, etc.) para extraer el contenido del archivo ZIP.

### Usa el Modo Desarrollador en Chrome

Abre Chrome y ve a `chrome://extensions/`. Activa "Modo desarrollador" en la parte superior derecha. Haz clic en "Cargar extensi贸n descomprimida...". Navega al directorio de tu extensi贸n. Esto no descarga el c贸digo fuente, pero es 煤til para ver y modificar el c贸digo de una extensi贸n ya descargada o desarrollada.

## Lista de verificaci贸n de auditor铆a de seguridad

A pesar de que las extensiones de navegador tienen una **superficie de ataque limitada**, algunas de ellas pueden contener **vulnerabilidades** o **mejoras de endurecimiento potenciales**. Las siguientes son las m谩s comunes:

* [ ] **Limitar** tanto como sea posible los **`permissions`** solicitados
* [ ] **Limitar** tanto como sea posible los **`host_permissions`**
* [ ] Usar una **`content_security_policy`** **fuerte**
* [ ] **Limitar** tanto como sea posible el **`externally_connectable`**, si no se necesita y es posible, no dejarlo por defecto, especificar **`{}`**
* [ ] Si se menciona aqu铆 una **URL vulnerable a XSS o a toma de control**, un atacante podr谩 **enviar mensajes a los scripts de fondo directamente**. Un bypass muy poderoso.
* [ ] **Limitar** tanto como sea posible los **`web_accessible_resources`**, incluso vac铆os si es posible.
* [ ] Si **`web_accessible_resources`** no es ninguno, verifica [**ClickJacking**](browext-clickjacking.md)
* [ ] Si ocurre alguna **comunicaci贸n** de la **extensi贸n** a la **p谩gina web**, [**verifica las vulnerabilidades XSS**](browext-xss-example.md) causadas en la comunicaci贸n.
* [ ] Si se utilizan Post Messages, verifica las [**vulnerabilidades de Post Message**](../postmessage-vulnerabilities/)**.**
* [ ] Si el **Content Script accede a detalles del DOM**, verifica que no **est茅n introduciendo un XSS** si son **modificados** por la web.
* [ ] Haz un 茅nfasis especial si esta comunicaci贸n tambi茅n est谩 involucrada en la **comunicaci贸n de Content Script -> script de fondo**
* [ ] **La informaci贸n sensible no debe ser almacenada** dentro del **c贸digo de la extensi贸n del navegador**
* [ ] **La informaci贸n sensible no debe ser almacenada** dentro de la **memoria de la extensi贸n del navegador**

## Herramientas

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Extrae cualquier extensi贸n de Chrome de un enlace proporcionado de la tienda web de Chrome.
* Visor de [**manifest.json**](https://developer.chrome.com/extensions/manifest): simplemente muestra una versi贸n JSON embellecida del manifiesto de la extensi贸n.
* **An谩lisis de huellas digitales**: Detecci贸n de [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) y generaci贸n autom谩tica de JavaScript de huellas digitales de extensiones de Chrome.
* **An谩lisis de Clickjacking potencial**: Detecci贸n de p谩ginas HTML de extensiones con la directiva [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) establecida. Estas son potencialmente vulnerables a clickjacking dependiendo del prop贸sito de las p谩ginas.
* Visor de advertencias de **Permisos**: que muestra una lista de todas las advertencias de permisos de Chrome que se mostrar谩n cuando un usuario intente instalar la extensi贸n.
* **Funci贸n(es) peligrosa(s)**: muestra la ubicaci贸n de funciones peligrosas que podr铆an ser potencialmente explotadas por un atacante (por ejemplo, funciones como innerHTML, chrome.tabs.executeScript).
* **Punto(s) de entrada**: muestra d贸nde la extensi贸n recibe entrada de usuario/externa. Esto es 煤til para entender la superficie de una extensi贸n y buscar puntos potenciales para enviar datos maliciosamente elaborados a la extensi贸n.
* Tanto los esc谩neres de Funci贸n(es) Peligrosa(s) como de Punto(s) de Entrada tienen lo siguiente para sus alertas generadas:
* Fragmento de c贸digo relevante y l铆nea que caus贸 la alerta.
* Descripci贸n del problema.
* Un bot贸n "Ver archivo" para ver el archivo fuente completo que contiene el c贸digo.
* La ruta del archivo alertado.
* La URI completa de la extensi贸n de Chrome del archivo alertado.
* El tipo de archivo que es, como un script de p谩gina de fondo, script de contenido, acci贸n del navegador, etc.
* Si la l铆nea vulnerable est谩 en un archivo JavaScript, las rutas de todas las p谩ginas donde est谩 incluida, as铆 como el tipo de estas p谩ginas y el estado de [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Analizador de Pol铆tica de Seguridad de Contenido (CSP) y verificador de bypass**: Esto se帽alar谩 debilidades en la CSP de tu extensi贸n y tambi茅n iluminar谩 cualquier forma potencial de eludir tu CSP debido a CDNs en la lista blanca, etc.
* **Bibliotecas vulnerables conocidas**: Esto utiliza [Retire.js](https://retirejs.github.io/retire.js/) para verificar cualquier uso de bibliotecas JavaScript conocidas como vulnerables.
* Descargar extensi贸n y versiones formateadas.
* Descargar la extensi贸n original.
* Descargar una versi贸n embellecida de la extensi贸n (HTML y JavaScript auto embellecidos).
* Cach茅 autom谩tica de resultados de escaneo, ejecutar un escaneo de extensi贸n tomar谩 un buen tiempo la primera vez que lo ejecutes. Sin embargo, la segunda vez, asumiendo que la extensi贸n no ha sido actualizada, ser谩 casi instant谩neo debido a que los resultados est谩n en cach茅.
* URLs de informes enlazables, f谩cilmente enlaza a alguien m谩s a un informe de extensi贸n generado por tarnish.

### [Neto](https://github.com/elevenpaths/neto)

El proyecto Neto es un paquete de Python 3 concebido para analizar y desentra帽ar caracter铆sticas ocultas de los complementos y extensiones de navegador para navegadores bien conocidos como Firefox y Chrome. Automatiza el proceso de descomprimir los archivos empaquetados para extraer estas caracter铆sticas de recursos relevantes en una extensi贸n como `manifest.json`, carpetas de localizaci贸n o archivos fuente de Javascript y HTML.

## Referencias

* **Gracias a** [**@naivenom**](https://twitter.com/naivenom) **por la ayuda con esta metodolog铆a**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
