# M√©thodologie de Pentesting des Extensions de Navigateur

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## Informations de Base

Les extensions de navigateur sont √©crites en JavaScript et charg√©es par le navigateur en arri√®re-plan. Elles ont leur [DOM](https://www.w3schools.com/js/js\_htmldom.asp) mais peuvent interagir avec les DOM d'autres sites. Cela signifie qu'elles peuvent compromettre la confidentialit√©, l'int√©grit√© et la disponibilit√© (CIA) d'autres sites.

## Composants Principaux

Les mises en page des extensions sont mieux visualis√©es et se composent de trois composants. Examinons chaque composant en profondeur.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Contenu**

Chaque script de contenu a un acc√®s direct au DOM d'une **page web unique** et est donc expos√© √† des **entr√©es potentiellement malveillantes**. Cependant, le script de contenu ne contient aucune autorisation autre que la capacit√© d'envoyer des messages au c≈ìur de l'extension.

### **C≈ìur de l'Extension**

Le c≈ìur de l'extension contient la plupart des privil√®ges/acc√®s de l'extension, mais le c≈ìur de l'extension ne peut interagir avec le contenu web que via [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) et les scripts de contenu. De plus, le c≈ìur de l'extension n'a pas d'acc√®s direct √† la machine h√¥te.

### **Binaire Natif**

L'extension permet un binaire natif qui peut **acc√©der √† la machine h√¥te avec tous les privil√®ges de l'utilisateur.** Le binaire natif interagit avec le c≈ìur de l'extension via l'interface de programmation d'application de plugin Netscape standard ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilis√©e par Flash et d'autres plugins de navigateur.

### Limites

{% hint style="danger" %}
Pour obtenir tous les privil√®ges de l'utilisateur, un attaquant doit convaincre l'extension de transmettre des entr√©es malveillantes du script de contenu au c≈ìur de l'extension et du c≈ìur de l'extension au binaire natif.
{% endhint %}

Chaque composant de l'extension est s√©par√© des autres par de **fortes limites de protection**. Chaque composant s'ex√©cute dans un **processus de syst√®me d'exploitation s√©par√©**. Les scripts de contenu et les c≈ìurs d'extension s'ex√©cutent dans des **processus de bac √† sable** inaccessibles √† la plupart des services du syst√®me d'exploitation.

De plus, les scripts de contenu sont s√©par√©s de leurs pages web associ√©es en **s'ex√©cutant dans un tas JavaScript s√©par√©**. Le script de contenu et la page web ont **acc√®s au m√™me DOM sous-jacent**, mais les deux **n'√©changent jamais de pointeurs JavaScript**, emp√™chant la fuite de la fonctionnalit√© JavaScript.

## **`manifest.json`**

Une extension Chrome est simplement un dossier ZIP avec une [extension de fichier .crx](https://www.lifewire.com/crx-file-2620391). Le c≈ìur de l'extension est le **fichier `manifest.json`** √† la racine du dossier, qui sp√©cifie la mise en page, les autorisations et d'autres options de configuration.

Exemple :
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Les scripts de contenu sont **charg√©s** chaque fois que l'utilisateur **navigue vers une page correspondante**, dans notre cas toute page correspondant √† l'expression **`https://example.com/*`** et ne correspondant pas √† l'expression r√©guli√®re **`*://*/*/business*`**. Ils s'ex√©cutent **comme les propres scripts de la page** et ont un acc√®s arbitraire au [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) de la page.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Pour inclure ou exclure plus d'URLs, il est √©galement possible d'utiliser **`include_globs`** et **`exclude_globs`**.

Ceci est un exemple de script de contenu qui ajoutera un bouton d'explication √† la page lorsque [l'API de stockage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) sera utilis√©e pour r√©cup√©rer la valeur `message` du stockage de l'extension.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Un message est envoy√© aux pages d'extension par le script de contenu lorsque ce bouton est cliqu√©, gr√¢ce √† l'utilisation de l'[**API runtime.sendMessage()**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Cela est d√ª √† la limitation du script de contenu dans l'acc√®s direct aux API, avec `storage` √©tant parmi les rares exceptions. Pour des fonctionnalit√©s au-del√† de ces exceptions, des messages sont envoy√©s aux pages d'extension avec lesquelles les scripts de contenu peuvent communiquer.

{% hint style="warning" %}
Selon le navigateur, les capacit√©s du script de contenu peuvent varier l√©g√®rement. Pour les navigateurs bas√©s sur Chromium, la liste des capacit√©s est disponible dans la [documentation des d√©veloppeurs Chrome](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), et pour Firefox, le [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) sert de source principale.\
Il est √©galement √† noter que les scripts de contenu ont la capacit√© de communiquer avec les scripts d'arri√®re-plan, leur permettant d'effectuer des actions et de relayer des r√©ponses.
{% endhint %}

Pour visualiser et d√©boguer les scripts de contenu dans Chrome, le menu des outils de d√©veloppement Chrome peut √™tre accessible depuis Options > Plus d'outils > Outils de d√©veloppement OU en appuyant sur Ctrl + Shift + I.

Une fois les outils de d√©veloppement affich√©s, l'onglet **Source** doit √™tre cliqu√©, suivi de l'onglet **Scripts de contenu**. Cela permet d'observer les scripts de contenu en cours d'ex√©cution de diverses extensions et de d√©finir des points d'arr√™t pour suivre le flux d'ex√©cution.

### Scripts de contenu inject√©s

{% hint style="success" %}
Notez que **les scripts de contenu ne sont pas obligatoires** car il est √©galement possible de **dynamiser** **l'injection** de scripts et de **les injecter par programme** dans des pages web via **`tabs.executeScript`**. Cela fournit en fait un contr√¥le **plus granulaire**.
{% endhint %}

Pour l'injection programmatique d'un script de contenu, l'extension doit avoir des [permissions d'h√¥te](https://developer.chrome.com/docs/extensions/reference/permissions) pour la page dans laquelle les scripts doivent √™tre inject√©s. Ces permissions peuvent √™tre s√©curis√©es soit en **les demandant** dans le manifeste de l'extension, soit sur une base temporaire via [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Exemple d'extension bas√©e sur activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injecter un fichier JS au clic :**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Injecter une fonction** au clic :
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Exemple avec des permissions de script
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Pour inclure ou exclure plus d'URLs, il est √©galement possible d'utiliser **`include_globs`** et **`exclude_globs`**.

### Scripts de contenu `run_at`

Le champ `run_at` contr√¥le **quand les fichiers JavaScript sont inject√©s dans la page web**. La valeur pr√©f√©r√©e et par d√©faut est `"document_idle"`.

Les valeurs possibles sont :

* **`document_idle`** : Chaque fois que c'est possible
* **`document_start`** : Apr√®s tous les fichiers de `css`, mais avant que tout autre DOM soit construit ou que tout autre script soit ex√©cut√©.
* **`document_end`** : Imm√©diatement apr√®s que le DOM soit complet, mais avant que les sous-ressources comme les images et les cadres aient √©t√© charg√©es.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Via **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `background`

Les messages envoy√©s par les scripts de contenu sont re√ßus par la **page d'arri√®re-plan**, qui joue un r√¥le central dans la coordination des composants de l'extension. Notamment, la page d'arri√®re-plan persiste tout au long de la vie de l'extension, fonctionnant discr√®tement sans interaction directe de l'utilisateur. Elle poss√®de son propre Document Object Model (DOM), permettant des interactions complexes et la gestion de l'√©tat.

**Points Cl√©s**:

* **R√¥le de la Page d'Arri√®re-plan :** Agit comme le centre n√©vralgique de l'extension, assurant la communication et la coordination entre les diff√©rentes parties de l'extension.
* **Persistance :** C'est une entit√© toujours pr√©sente, invisible √† l'utilisateur mais int√©grale au fonctionnement de l'extension.
* **G√©n√©ration Automatique :** Si elle n'est pas explicitement d√©finie, le navigateur cr√©era automatiquement une page d'arri√®re-plan. Cette page g√©n√©r√©e automatiquement inclura tous les scripts d'arri√®re-plan sp√©cifi√©s dans le manifeste de l'extension, garantissant le bon fonctionnement des t√¢ches d'arri√®re-plan de l'extension.

{% hint style="success" %}
La commodit√© fournie par le navigateur en g√©n√©rant automatiquement une page d'arri√®re-plan (lorsqu'elle n'est pas explicitement d√©clar√©e) garantit que tous les scripts d'arri√®re-plan n√©cessaires sont int√©gr√©s et op√©rationnels, simplifiant le processus de configuration de l'extension.
{% endhint %}

Exemple de script d'arri√®re-plan :
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Il utilise l'[API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) pour √©couter les messages. Lorsqu'un message `"explain"` est re√ßu, il utilise l'[API tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) pour ouvrir une page dans un nouvel onglet.

Pour d√©boguer le script d'arri√®re-plan, vous pouvez aller dans les **d√©tails de l'extension et inspecter le service worker,** cela ouvrira les outils de d√©veloppement avec le script d'arri√®re-plan :

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Pages d'options et autres

Les extensions de navigateur peuvent contenir divers types de pages :

* Les **pages d'action** s'affichent dans un **menu d√©roulant lorsque l'ic√¥ne de l'extension** est cliqu√©e.
* Pages que l'extension va **charger dans un nouvel onglet**.
* **Pages d'options** : Cette page s'affiche au-dessus de l'extension lorsqu'elle est cliqu√©e. Dans le manifeste pr√©c√©dent, dans mon cas, j'ai pu acc√©der √† cette page dans `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` ou en cliquant :

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Notez que ces pages ne sont pas persistantes comme les pages d'arri√®re-plan car elles chargent dynamiquement du contenu selon les besoins. Malgr√© cela, elles partagent certaines capacit√©s avec la page d'arri√®re-plan :

* **Communication avec les scripts de contenu :** Semblable √† la page d'arri√®re-plan, ces pages peuvent recevoir des messages des scripts de contenu, facilitant l'interaction au sein de l'extension.
* **Acc√®s aux API sp√©cifiques √† l'extension :** Ces pages b√©n√©ficient d'un acc√®s complet aux API sp√©cifiques √† l'extension, sous r√©serve des autorisations d√©finies pour l'extension.

### `permissions` & `host_permissions`

**`permissions`** et **`host_permissions`** sont des entr√©es du `manifest.json` qui indiqueront **quelles autorisations** l'extension de navigateur a (stockage, localisation...) et **sur quelles pages web**.

Comme les extensions de navigateur peuvent √™tre si **privil√©gi√©es**, une malveillante ou compromise pourrait permettre √† l'attaquant **diff√©rentes m√©thodes pour voler des informations sensibles et espionner l'utilisateur**.

V√©rifiez comment ces param√®tres fonctionnent et comment ils pourraient √™tre abus√©s dans :

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Une **politique de s√©curit√© de contenu** peut √©galement √™tre d√©clar√©e √† l'int√©rieur du `manifest.json`. S'il y en a une d√©finie, elle pourrait √™tre **vuln√©rable**.

Le param√®tre par d√©faut pour les pages d'extension de navigateur est plut√¥t restrictif :
```bash
script-src 'self'; object-src 'self';
```
Pour plus d'informations sur CSP et les contournements potentiels, consultez :

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Pour qu'une page web puisse acc√©der √† une page d'une extension de navigateur, une page `.html` par exemple, cette page doit √™tre mentionn√©e dans le champ **`web_accessible_resources`** du `manifest.json`.\
Par exemple :
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Ces pages sont accessibles √† l'URL comme :
```
chrome-extension://<extension-id>/message.html
```
Dans les extensions publiques, l'**extension-id est accessible** :

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Cependant, si le param√®tre `manifest.json` **`use_dynamic_url`** est utilis√©, cet **id peut √™tre dynamique**.

{% hint style="success" %}
Notez que m√™me si une page est mentionn√©e ici, elle pourrait √™tre **prot√©g√©e contre le ClickJacking** gr√¢ce √† la **Content Security Policy**. Vous devez donc √©galement v√©rifier cela (section frame-ancestors) avant de confirmer qu'une attaque ClickJacking est possible.
{% endhint %}

Le fait d'√™tre autoris√© √† acc√©der √† ces pages rend ces pages **potentiellement vuln√©rables au ClickJacking** :

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Autoriser ces pages √† √™tre charg√©es uniquement par l'extension et non par des URL al√©atoires pourrait pr√©venir les attaques de ClickJacking.
{% endhint %}

{% hint style="danger" %}
Notez que les pages de **`web_accessible_resources`** et d'autres pages de l'extension sont √©galement capables de **contacter des scripts d'arri√®re-plan**. Donc, si l'une de ces pages est vuln√©rable √† **XSS**, cela pourrait ouvrir une vuln√©rabilit√© plus importante.

De plus, notez que vous ne pouvez ouvrir que les pages indiqu√©es dans **`web_accessible_resources`** √† l'int√©rieur des iframes, mais depuis un nouvel onglet, il est possible d'acc√©der √† n'importe quelle page de l'extension en connaissant l'ID de l'extension. Par cons√©quent, si un XSS est trouv√© en abusant des m√™mes param√®tres, il pourrait √™tre exploit√© m√™me si la page n'est pas configur√©e dans **`web_accessible_resources`**.
{% endhint %}

### `externally_connectable`

Selon les [**docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propri√©t√© de manifeste `"externally_connectable"` d√©clare **quelles extensions et pages web peuvent se connecter** √† votre extension via [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) et [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la cl√© **`externally_connectable`** **n'est pas** d√©clar√©e dans le manifeste de votre extension ou qu'elle est d√©clar√©e comme **`"ids": ["*"]`**, **toutes les extensions peuvent se connecter, mais aucune page web ne peut se connecter**.
* Si **des ID sp√©cifiques sont sp√©cifi√©s**, comme dans `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **seules ces applications** peuvent se connecter.
* Si des **matches** sont sp√©cifi√©s, ces applications web pourront se connecter :
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* S'il est sp√©cifi√© comme vide : **`"externally_connectable": {}`**, aucune application ou site web ne pourra se connecter.

Le **moins d'extensions et d'URLs** indiqu√©s ici, plus la **surface d'attaque** sera **petite**.

{% hint style="danger" %}
Si une page web **vuln√©rable √† XSS ou takeover** est indiqu√©e dans **`externally_connectable`**, un attaquant pourra **envoyer des messages directement au script d'arri√®re-plan**, contournant compl√®tement le Content Script et son CSP.

Par cons√©quent, c'est un **contournement tr√®s puissant**.

De plus, si le client installe une extension malveillante, m√™me si elle n'est pas autoris√©e √† communiquer avec l'extension vuln√©rable, elle pourrait injecter **des donn√©es XSS dans une page web autoris√©e** ou abuser des API **`WebRequest`** ou **`DeclarativeNetRequest`** pour manipuler des requ√™tes sur un domaine cibl√© en modifiant la requ√™te d'une **fichier JavaScript**. (Notez que le CSP sur la page cibl√©e pourrait emp√™cher ces attaques). Cette id√©e vient [**de cet article**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## R√©sum√© de la communication

### Extension <--> WebApp

Pour communiquer entre le script de contenu et la page web, des messages post sont g√©n√©ralement utilis√©s. Par cons√©quent, dans l'application web, vous trouverez g√©n√©ralement des appels √† la fonction **`window.postMessage`** et dans le script de contenu des √©couteurs comme **`window.addEventListener`**. Notez cependant que l'extension pourrait √©galement **communiquer avec l'application web en envoyant un Post Message** (et donc le web devrait s'y attendre) ou simplement faire charger un nouveau script par le web.

### √Ä l'int√©rieur de l'extension

G√©n√©ralement, la fonction **`chrome.runtime.sendMessage`** est utilis√©e pour envoyer un message √† l'int√©rieur de l'extension (g√©n√©ralement g√©r√© par le script `background`) et pour le recevoir et le g√©rer, un √©couteur est d√©clar√© en appelant **`chrome.runtime.onMessage.addListener`**.

Il est √©galement possible d'utiliser **`chrome.runtime.connect()`** pour avoir une connexion persistante au lieu d'envoyer des messages uniques, il est possible de l'utiliser pour **envoyer** et **recevoir** **des messages** comme dans l'exemple suivant :

<details>

<summary><code>chrome.runtime.connect()</code> exemple</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Il est √©galement possible d'envoyer des messages d'un script d'arri√®re-plan √† un script de contenu situ√© dans un onglet sp√©cifique en appelant **`chrome.tabs.sendMessage`** o√π vous devrez indiquer l'**ID de l'onglet** √† qui envoyer le message.

### Des `externally_connectable` autoris√©s √† l'extension

**Les applications web et les extensions de navigateur externes autoris√©es** dans la configuration `externally_connectable` peuvent envoyer des requ√™tes en utilisant :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
O√π il est n√©cessaire de mentionner l'**ID d'extension**.

## Web **‚ÜîÔ∏é** Communication de Script de Contenu

Les environnements o√π les **scripts de contenu** op√®rent et o√π les pages h√¥tes existent sont **s√©par√©s** les uns des autres, garantissant **l'isolement**. Malgr√© cet isolement, les deux ont la capacit√© d'interagir avec le **Document Object Model (DOM)** de la page, une ressource partag√©e. Pour que la page h√¥te engage une communication avec le **script de contenu**, ou indirectement avec l'extension via le script de contenu, il est n√©cessaire d'utiliser le **DOM** qui est accessible par les deux parties comme canal de communication.

### Messages Postaux

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Une communication s√©curis√©e par Post Message doit v√©rifier l'authenticit√© du message re√ßu, cela peut √™tre fait en v√©rifiant :

* **`event.isTrusted`** : Ceci est vrai uniquement si l'√©v√©nement a √©t√© d√©clench√© par une action de l'utilisateur
* Le script de contenu pourrait s'attendre √† un message uniquement si l'utilisateur effectue une action
* **domaine d'origine** : pourrait s'attendre √† un message uniquement √† partir d'une liste blanche de domaines.
* Si une regex est utilis√©e, soyez tr√®s prudent
* **Source** : `received_message.source !== window` peut √™tre utilis√© pour v√©rifier si le message provient **de la m√™me fen√™tre** o√π le script de contenu √©coute.

Les v√©rifications pr√©c√©dentes, m√™me si elles sont effectu√©es, pourraient √™tre vuln√©rables, alors v√©rifiez sur la page suivante **les contournements potentiels de Post Message** :

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Une autre fa√ßon possible de communication pourrait √™tre √† travers **les URL Iframe**, vous pouvez trouver un exemple dans :

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Ce n'est pas "exactement" une fa√ßon de communiquer, mais le **web et le script de contenu auront acc√®s au DOM web**. Donc, si le **script de contenu** lit certaines informations √† partir de celui-ci, **faisant confiance au DOM web**, le web pourrait **modifier ces donn√©es** (car le web ne devrait pas √™tre digne de confiance, ou parce que le web est vuln√©rable √† XSS) et **compromettre le script de contenu**.

Vous pouvez √©galement trouver un exemple de **XSS bas√© sur le DOM pour compromettre une extension de navigateur** dans :

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Communication entre le Script de Contenu **‚ÜîÔ∏é** le Script d'Arri√®re-plan

Un Script de Contenu peut utiliser les fonctions [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **ou** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) pour envoyer un message **s√©rialisable en JSON** **√† usage unique**.

Pour g√©rer la **r√©ponse**, utilisez la **Promise** retourn√©e. Bien que, pour des raisons de compatibilit√© ascendante, vous puissiez toujours passer un **callback** comme dernier argument.

L'envoi d'une requ√™te depuis un **script de contenu** ressemble √† ceci :
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Envoyer une requ√™te depuis l'**extension** (g√©n√©ralement un **script d'arri√®re-plan**). Exemple de la fa√ßon d'envoyer un message au script de contenu dans l'onglet s√©lectionn√© :
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Sur le **receiving end**, vous devez configurer un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **√©couteur d'√©v√©nements** pour g√©rer le message. Cela ressemble √† la m√™me chose depuis un script de contenu ou une page d'extension.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Dans l'exemple mis en √©vidence, **`sendResponse()`** a √©t√© ex√©cut√© de mani√®re synchrone. Pour modifier le gestionnaire d'√©v√©nements `onMessage` pour une ex√©cution asynchrone de `sendResponse()`, il est imp√©ratif d'incorporer `return true;`.

Une consid√©ration importante est que dans les sc√©narios o√π plusieurs pages sont configur√©es pour recevoir des √©v√©nements `onMessage`, **la premi√®re page √† ex√©cuter `sendResponse()`** pour un √©v√©nement sp√©cifique sera la seule capable de livrer la r√©ponse efficacement. Toute r√©ponse ult√©rieure au m√™me √©v√©nement ne sera pas prise en compte.

Lors de la cr√©ation de nouvelles extensions, la pr√©f√©rence devrait √™tre donn√©e aux promesses plut√¥t qu'aux rappels. En ce qui concerne l'utilisation des rappels, la fonction `sendResponse()` est consid√©r√©e comme valide uniquement si elle est ex√©cut√©e directement dans le contexte synchrone, ou si le gestionnaire d'√©v√©nements indique une op√©ration asynchrone en retournant `true`. Si aucun des gestionnaires ne retourne `true` ou si la fonction `sendResponse()` est supprim√©e de la m√©moire (collect√©e par le garbage collector), le rappel associ√© √† la fonction `sendMessage()` sera d√©clench√© par d√©faut.

## Informations sensibles en m√©moire/code/clipboard

Si une extension de navigateur stocke **des informations sensibles dans sa m√©moire**, celles-ci pourraient √™tre **dump√©es** (surtout sur les machines Windows) et **recherch√©es** pour ces informations.

Par cons√©quent, la m√©moire de l'extension de navigateur **ne doit pas √™tre consid√©r√©e comme s√©curis√©e** et **les informations sensibles** telles que les identifiants ou les phrases mn√©motechniques **ne doivent pas √™tre stock√©es**.

Bien s√ªr, ne **mettez pas d'informations sensibles dans le code**, car cela sera **public**.

Pour dumper la m√©moire du navigateur, vous pourriez **dumper la m√©moire du processus** ou aller dans les **param√®tres** de l'extension de navigateur, cliquer sur **`Inspect pop-up`** -> Dans la section **`Memory`** -> **`Take a snapshot`** et **`CTRL+F`** pour rechercher dans le snapshot des informations sensibles.

De plus, des informations hautement sensibles comme des cl√©s mn√©motechniques ou des mots de passe **ne devraient pas √™tre autoris√©es √† √™tre copi√©es dans le presse-papiers** (ou au moins les retirer du presse-papiers apr√®s quelques secondes) car alors les processus surveillant le presse-papiers pourront les obtenir.

## Chargement d'une extension dans le navigateur

1. **T√©l√©chargez** l'extension de navigateur & d√©compressez-la
2. Allez √† **`chrome://extensions/`** et **activez** le `Mode d√©veloppeur`
3. Cliquez sur le bouton **`Load unpacked`**

Dans **Firefox**, allez √† **`about:debugging#/runtime/this-firefox`** et cliquez sur le bouton **`Load Temporary Add-on`**.

## Obtenir le code source depuis le store

Le code source d'une extension Chrome peut √™tre obtenu par divers moyens. Voici des explications d√©taill√©es et des instructions pour chaque option.

### T√©l√©charger l'extension en tant que ZIP via la ligne de commande

Le code source d'une extension Chrome peut √™tre t√©l√©charg√© sous forme de fichier ZIP en utilisant la ligne de commande. Cela implique d'utiliser `curl` pour r√©cup√©rer le fichier ZIP √† partir d'une URL sp√©cifique, puis d'extraire le contenu du fichier ZIP dans un r√©pertoire. Voici les √©tapes :

1. Remplacez `"extension_id"` par l'ID r√©el de l'extension.
2. Ex√©cutez les commandes suivantes :
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Utilisez le site CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Utilisez l'extension CRX Viewer

Une autre m√©thode pratique consiste √† utiliser le Chrome Extension Source Viewer, qui est un projet open-source. Il peut √™tre install√© depuis le [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Le code source du visualiseur est disponible dans son [d√©p√¥t GitHub](https://github.com/Rob--W/crxviewer).

### Voir le code source de l'extension install√©e localement

Les extensions Chrome install√©es localement peuvent √©galement √™tre inspect√©es. Voici comment :

1. Acc√©dez √† votre r√©pertoire de profil local Chrome en visitant `chrome://version/` et en localisant le champ "Profile Path".
2. Naviguez vers le sous-dossier `Extensions/` dans le r√©pertoire de profil.
3. Ce dossier contient toutes les extensions install√©es, g√©n√©ralement avec leur code source dans un format lisible.

Pour identifier les extensions, vous pouvez mapper leurs ID √† des noms :

* Activez le mode d√©veloppeur sur la page `about:extensions` pour voir les ID de chaque extension.
* Dans le dossier de chaque extension, le fichier `manifest.json` contient un champ `name` lisible, vous aidant √† identifier l'extension.

### Utilisez un archiveur de fichiers ou un d√©compresseur

Allez sur le Chrome Web Store et t√©l√©chargez l'extension. Le fichier aura une extension `.crx`. Changez l'extension du fichier de `.crx` √† `.zip`. Utilisez n'importe quel archiveur de fichiers (comme WinRAR, 7-Zip, etc.) pour extraire le contenu du fichier ZIP.

### Utilisez le mode d√©veloppeur dans Chrome

Ouvrez Chrome et allez √† `chrome://extensions/`. Activez "Mode d√©veloppeur" en haut √† droite. Cliquez sur "Charger l'extension non empaquet√©e...". Naviguez vers le r√©pertoire de votre extension. Cela ne t√©l√©charge pas le code source, mais c'est utile pour visualiser et modifier le code d'une extension d√©j√† t√©l√©charg√©e ou d√©velopp√©e.

## Liste de contr√¥le de l'audit de s√©curit√©

Bien que les extensions de navigateur aient une **surface d'attaque limit√©e**, certaines d'entre elles peuvent contenir des **vuln√©rabilit√©s** ou des **am√©liorations potentielles de durcissement**. Les suivantes sont les plus courantes :

* [ ] **Limitez** autant que possible les **`permissions`** demand√©es
* [ ] **Limitez** autant que possible les **`host_permissions`**
* [ ] Utilisez une **politique de s√©curit√© de contenu** **forte**
* [ ] **Limitez** autant que possible le **`externally_connectable`**, si aucun n'est n√©cessaire et possible, ne le laissez pas par d√©faut, sp√©cifiez **`{}`**
* [ ] Si une **URL vuln√©rable √† XSS ou √† la prise de contr√¥le** est mentionn√©e ici, un attaquant pourra **envoyer des messages aux scripts d'arri√®re-plan directement**. Contournement tr√®s puissant.
* [ ] **Limitez** autant que possible les **`web_accessible_resources`**, m√™me vides si possible.
* [ ] Si **`web_accessible_resources`** n'est pas nul, v√©rifiez pour [**ClickJacking**](browext-clickjacking.md)
* [ ] Si une **communication** se produit de l'**extension** √† la **page web**, [**v√©rifiez les vuln√©rabilit√©s XSS**](browext-xss-example.md) caus√©es dans la communication.
* [ ] Si des messages post sont utilis√©s, v√©rifiez pour [**les vuln√©rabilit√©s de message post**](../postmessage-vulnerabilities/)**.**
* [ ] Si le **Content Script acc√®de aux d√©tails DOM**, v√©rifiez qu'ils **n'introduisent pas un XSS** s'ils sont **modifi√©s** par le web
* [ ] Mettez un accent particulier si cette communication est √©galement impliqu√©e dans la **communication Content Script -> script d'arri√®re-plan**
* [ ] **Les informations sensibles ne doivent pas √™tre stock√©es** √† l'int√©rieur du code de l'extension de navigateur
* [ ] **Les informations sensibles ne doivent pas √™tre stock√©es** √† l'int√©rieur de la m√©moire de l'extension de navigateur

## Outils

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* R√©cup√®re n'importe quelle extension Chrome √† partir d'un lien de Chrome Webstore fourni.
* Visualiseur de [**manifest.json**](https://developer.chrome.com/extensions/manifest) : affiche simplement une version JSON format√©e du manifeste de l'extension.
* **Analyse de l'empreinte** : D√©tection des [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) et g√©n√©ration automatique de JavaScript d'empreinte d'extension Chrome.
* **Analyse potentielle de Clickjacking** : D√©tection des pages HTML d'extension avec la directive [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) d√©finie. Celles-ci sont potentiellement vuln√©rables au clickjacking selon l'objectif des pages.
* Visualiseur d'avertissement(s) de permission : qui montre une liste de tous les avertissements de demande de permission Chrome qui seront affich√©s lorsqu'un utilisateur tentera d'installer l'extension.
* **Fonction(s) dangereuse(s)** : montre l'emplacement des fonctions dangereuses qui pourraient potentiellement √™tre exploit√©es par un attaquant (par exemple, des fonctions telles que innerHTML, chrome.tabs.executeScript).
* **Point(s) d'entr√©e** : montre o√π l'extension prend des entr√©es utilisateur/externe. Cela est utile pour comprendre la surface d'une extension et rechercher des points potentiels pour envoyer des donn√©es malicieusement con√ßues √† l'extension.
* Les scanners de Fonction(s) dangereuse(s) et Point(s) d'entr√©e ont les √©l√©ments suivants pour leurs alertes g√©n√©r√©es :
* Extrait de code pertinent et ligne qui a caus√© l'alerte.
* Description du probl√®me.
* Un bouton "Voir le fichier" pour voir le fichier source complet contenant le code.
* Le chemin du fichier alert√©.
* L'URI compl√®te de l'extension Chrome du fichier alert√©.
* Le type de fichier, tel qu'un script de page d'arri√®re-plan, un script de contenu, une action de navigateur, etc.
* Si la ligne vuln√©rable se trouve dans un fichier JavaScript, les chemins de toutes les pages o√π elle est incluse ainsi que le type de ces pages, et le statut de [web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
* **Analyseur de politique de s√©curit√© de contenu (CSP) et v√©rificateur de contournement** : Cela mettra en √©vidence les faiblesses de la CSP de votre extension et mettra √©galement en lumi√®re d'√©ventuelles fa√ßons de contourner votre CSP en raison de CDNs sur liste blanche, etc.
* **Biblioth√®ques vuln√©rables connues** : Cela utilise [Retire.js](https://retirejs.github.io/retire.js/) pour v√©rifier toute utilisation de biblioth√®ques JavaScript connues comme vuln√©rables.
* T√©l√©charger l'extension et les versions format√©es.
* T√©l√©charger l'extension originale.
* T√©l√©charger une version beautifi√©e de l'extension (HTML et JavaScript auto-format√©s).
* Mise en cache automatique des r√©sultats de scan, ex√©cuter un scan d'extension prendra un bon moment la premi√®re fois que vous l'ex√©cutez. Cependant, la deuxi√®me fois, √† condition que l'extension n'ait pas √©t√© mise √† jour, sera presque instantan√©e gr√¢ce aux r√©sultats √©tant mis en cache.
* URLs de rapport liables, permettant de lier facilement quelqu'un √† un rapport d'extension g√©n√©r√© par tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Le projet Neto est un package Python 3 con√ßu pour analyser et d√©chiffrer les fonctionnalit√©s cach√©es des plugins et extensions de navigateur pour des navigateurs bien connus tels que Firefox et Chrome. Il automatise le processus de d√©compression des fichiers empaquet√©s pour extraire ces fonctionnalit√©s des ressources pertinentes dans une extension comme `manifest.json`, des dossiers de localisation ou des fichiers source Javascript et HTML.

## R√©f√©rences

* **Merci √†** [**@naivenom**](https://twitter.com/naivenom) **pour l'aide avec cette m√©thodologie**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
