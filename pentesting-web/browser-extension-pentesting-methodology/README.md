# Browser-Erweiterungs-Pentesting-Methodik

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Grundlegende Informationen

Browser-Erweiterungen werden in JavaScript geschrieben und vom Browser im Hintergrund geladen. Sie haben ihr [DOM](https://www.w3schools.com/js/js\_htmldom.asp), k√∂nnen jedoch mit DOMs anderer Websites interagieren. Dies bedeutet, dass sie die Vertraulichkeit, Integrit√§t und Verf√ºgbarkeit (CIA) anderer Websites beeintr√§chtigen k√∂nnen.

## Hauptkomponenten

Die Layouts von Erweiterungen sehen am besten aus, wenn sie visualisiert werden und bestehen aus drei Komponenten. Schauen wir uns jede Komponente genauer an.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Inhaltsskripte**

Jedes Inhaltsskript hat direkten Zugriff auf das DOM einer **einzigen Webseite** und ist somit **potenziell b√∂sartigen Eingaben** ausgesetzt. Das Inhaltsskript hat jedoch keine Berechtigungen au√üer der F√§higkeit, Nachrichten an den Erweiterungskern zu senden.

### **Erweiterungskern**

Der Erweiterungskern enth√§lt die meisten Berechtigungen/Zugriffe der Erweiterung, kann jedoch nur √ºber [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) und Inhaltsskripte mit Webinhalten interagieren. Der Erweiterungskern hat auch keinen direkten Zugriff auf den Host-Rechner.

### **Native Bin√§rdatei**

Die Erweiterung erm√∂glicht eine native Bin√§rdatei, die mit den vollen Benutzerrechten auf den Host-Rechner zugreifen kann. Die native Bin√§rdatei interagiert √ºber die standardm√§√üige Netscape Plugin Application Programming Interface ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)), die von Flash und anderen Browser-Plug-Ins verwendet wird, mit dem Erweiterungskern.

### Grenzen

{% hint style="danger" %}
Um die vollen Benutzerrechte zu erlangen, muss ein Angreifer die Erweiterung davon √ºberzeugen, b√∂sartige Eingaben vom Inhaltsskript an den Erweiterungskern und vom Erweiterungskern an die native Bin√§rdatei weiterzuleiten.
{% endhint %}

Jede Komponente der Erweiterung ist durch **starke Schutzgrenzen** voneinander getrennt. Jede Komponente l√§uft in einem **eigenen Betriebssystemprozess**. Inhaltsskripte und Erweiterungskerne laufen in **Sandbox-Prozessen**, die f√ºr die meisten Betriebssystemdienste nicht verf√ºgbar sind.

Dar√ºber hinaus sind Inhaltsskripte von ihren zugeh√∂rigen Webseiten durch **Ausf√ºhrung in einem separaten JavaScript-Heap** getrennt. Das Inhaltsskript und die Webseite haben **Zugriff auf das gleiche zugrunde liegende DOM**, aber die beiden **tauschen niemals JavaScript-Zeiger aus**, um das Auslaufen von JavaScript-Funktionalit√§t zu verhindern.

## **`manifest.json`**

Eine Chrome-Erweiterung ist nur ein ZIP-Ordner mit einer [.crx-Dateierweiterung](https://www.lifewire.com/crx-file-2620391). Der Kern der Erweiterung ist die **`manifest.json`**-Datei im Stammverzeichnis des Ordners, die Layout, Berechtigungen und andere Konfigurationsoptionen festlegt.

Beispiel:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content-Skripte werden **geladen**, wann immer der Benutzer zu einer passenden Seite navigiert, in unserem Fall zu einer Seite, die der Ausdruck **`https://example.com/*`** entspricht und nicht dem regul√§ren Ausdruck **`*://*/*/business*`** entspricht. Sie werden **wie die eigenen Skripte der Seite** ausgef√ºhrt und haben beliebigen Zugriff auf das [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) der Seite.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Um weitere URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

Dies ist ein Beispiel f√ºr ein Inhalts-Skript, das der Seite eine Erkl√§rungsschaltfl√§che hinzuf√ºgt, wenn [die Storage-API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) verwendet wird, um den Wert `message` aus dem Speicher der Erweiterung abzurufen.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Wenn auf diese Schaltfl√§che geklickt wird, sendet das Inhalts-Skript eine Nachricht an die Erweiterungsseiten √ºber die Verwendung der [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Dies liegt daran, dass das Inhalts-Skript keinen direkten Zugriff auf APIs hat, mit Ausnahme von `storage` als eine der wenigen Ausnahmen. F√ºr Funktionalit√§ten, die √ºber diese Ausnahmen hinausgehen, werden Nachrichten an Erweiterungsseiten gesendet, mit denen Inhalts-Skripts kommunizieren k√∂nnen.

{% hint style="warning" %}
Je nach Browser k√∂nnen die F√§higkeiten des Inhalts-Skripts geringf√ºgig variieren. F√ºr Chromium-basierte Browser ist die Liste der F√§higkeiten in der [Chrome Developers-Dokumentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities) verf√ºgbar, und f√ºr Firefox dient die [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) als prim√§re Quelle.\
Es ist auch erw√§hnenswert, dass Inhalts-Skripts die M√∂glichkeit haben, mit Hintergrund-Skripts zu kommunizieren, sodass sie Aktionen ausf√ºhren und Antworten zur√ºckgeben k√∂nnen.
{% endhint %}

Um Inhalts-Skripts in Chrome anzuzeigen und zu debuggen, kann das Chrome-Entwicklertools-Men√º √ºber Optionen > Weitere Tools > Entwicklertools aufgerufen werden oder indem Sie Strg + Umschalt + I dr√ºcken.

Nachdem die Entwicklertools angezeigt werden, klicken Sie auf den **Quellcode-Tab**, gefolgt vom **Inhalts-Skripts-Tab**. Dadurch k√∂nnen laufende Inhalts-Skripts von verschiedenen Erweiterungen beobachtet und Breakpoints gesetzt werden, um den Ausf√ºhrungsfluss zu verfolgen.

### Eingef√ºgte Inhalts-Skripts

{% hint style="success" %}
Beachten Sie, dass **Inhalts-Skripts nicht obligatorisch** sind, da es auch m√∂glich ist, Skripte **dynamisch einzuf√ºgen** und sie **programmgesteuert** in Webseiten √ºber **`tabs.executeScript`** einzuf√ºgen. Dadurch werden tats√§chlich **feingranulare Kontrollen** erm√∂glicht.
{% endhint %}

F√ºr die programmgesteuerte Injektion eines Inhalts-Skripts ben√∂tigt die Erweiterung [Host-Berechtigungen](https://developer.chrome.com/docs/extensions/reference/permissions) f√ºr die Seite, in die die Skripte eingef√ºgt werden sollen. Diese Berechtigungen k√∂nnen entweder durch **Anforderung** in der Erweiterungsmanifestdatei oder vor√ºbergehend √ºber [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab) gesichert werden.

#### Beispiel f√ºr eine auf activeTab basierende Erweiterung

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injizieren einer JS-Datei beim Klicken:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Funktion einschleusen** beim Klicken:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Beispiel mit Skriptberechtigungen

In diesem Beispiel werden wir uns mit den Berechtigungen f√ºr Skripte befassen.

1. **Analyse der Berechtigungen**: √úberpr√ºfen Sie die Berechtigungen der Erweiterung, um festzustellen, ob sie Skriptausf√ºhrungen erlaubt. Dies kann in der `manifest.json`-Datei oder in den Einstellungen der Erweiterung gefunden werden.

2. **Identifizierung von Schwachstellen**: Suchen Sie nach Schwachstellen in der Erweiterung, die es einem Angreifer erm√∂glichen k√∂nnten, b√∂sartige Skripte auszuf√ºhren. Dies kann beispielsweise durch unsichere Codeimplementierungen oder fehlerhafte Validierung von Benutzereingaben geschehen.

3. **Ausnutzung der Schwachstellen**: Wenn Sie eine Schwachstelle gefunden haben, k√∂nnen Sie versuchen, sie auszunutzen, um b√∂sartige Skripte in der Erweiterung auszuf√ºhren. Dies kann dazu f√ºhren, dass der Angreifer auf vertrauliche Informationen zugreifen oder sch√§dlichen Code auf dem System des Benutzers ausf√ºhren kann.

4. **Absicherung der Erweiterung**: Um die Sicherheit der Erweiterung zu verbessern, sollten Sie sicherstellen, dass nur vertrauensw√ºrdiger Code ausgef√ºhrt wird. √úberpr√ºfen Sie alle Eingaben sorgf√§ltig und implementieren Sie bew√§hrte Sicherheitspraktiken, um Schwachstellen zu vermeiden.

5. **√úberwachung und Aktualisierung**: √úberwachen Sie regelm√§√üig die Sicherheit der Erweiterung und halten Sie sie auf dem neuesten Stand. Aktualisieren Sie die Erweiterung, um bekannte Schwachstellen zu beheben und neue Sicherheitsfunktionen zu implementieren.

Durch die sorgf√§ltige Analyse der Berechtigungen, die Identifizierung von Schwachstellen, die Ausnutzung dieser Schwachstellen, die Absicherung der Erweiterung und die regelm√§√üige √úberwachung und Aktualisierung k√∂nnen Sie die Sicherheit von Erweiterungen mit Skriptberechtigungen verbessern.
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Um weitere URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

### Content Scripts `run_at`

Das Feld `run_at` steuert **wann JavaScript-Dateien in die Webseite eingef√ºgt werden**. Der bevorzugte und standardm√§√üige Wert ist `"document_idle"`.

Die m√∂glichen Werte sind:

* **`document_idle`**: Immer wenn m√∂glich
* **`document_start`**: Nach allen Dateien aus `css`, aber vor dem Aufbau des DOM oder der Ausf√ºhrung eines anderen Skripts.
* **`document_end`**: Unmittelbar nachdem der DOM vollst√§ndig ist, aber bevor Unterressourcen wie Bilder und Frames geladen werden.

#### √úber `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
√úber **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `Hintergrund`

Nachrichten, die von Inhaltsskripten gesendet werden, werden von der **Hintergrundseite** empfangen, die eine zentrale Rolle bei der Koordination der Komponenten der Erweiterung spielt. Die Hintergrundseite bleibt w√§hrend der gesamten Laufzeit der Erweiterung bestehen und arbeitet diskret ohne direkte Benutzerinteraktion. Sie verf√ºgt √ºber ihr eigenes Document Object Model (DOM), das komplexe Interaktionen und Zustandsverwaltung erm√∂glicht.

**Hauptpunkte**:

- **Rolle der Hintergrundseite:** Dient als Nervenzentrum f√ºr die Erweiterung und gew√§hrleistet die Kommunikation und Koordination zwischen den verschiedenen Teilen der Erweiterung.
- **Persistenz:** Sie ist eine st√§ndig vorhandene Entit√§t, unsichtbar f√ºr den Benutzer, aber integraler Bestandteil der Funktionalit√§t der Erweiterung.
- **Automatische Generierung:** Wenn nicht explizit definiert, erstellt der Browser automatisch eine Hintergrundseite. Diese automatisch generierte Seite enth√§lt alle im Manifest der Erweiterung angegebenen Hintergrundskripte und gew√§hrleistet den nahtlosen Betrieb der Hintergrundaufgaben der Erweiterung.

{% hint style="success" %}
Die vom Browser bereitgestellte Bequemlichkeit, automatisch eine Hintergrundseite zu generieren (wenn nicht explizit deklariert), stellt sicher, dass alle erforderlichen Hintergrundskripte integriert und funktionsf√§hig sind und den Einrichtungsprozess der Erweiterung optimieren.
{% endhint %}

Beispielhintergrundskript:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Es verwendet die [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage), um auf Nachrichten zu lauschen. Wenn eine Nachricht mit dem Inhalt `"explain"` empfangen wird, verwendet es die [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs), um eine Seite in einem neuen Tab zu √∂ffnen.

Um das Hintergrundskript zu debuggen, k√∂nnen Sie zu den **Erweiterungsdetails gehen und den Service Worker inspizieren**. Dadurch werden die Entwicklertools mit dem Hintergrundskript ge√∂ffnet:

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

### Optionsseiten und andere

Browser-Erweiterungen k√∂nnen verschiedene Arten von Seiten enthalten:

* **Aktionsseiten** werden in einem **Dropdown-Men√º angezeigt**, wenn auf das Erweiterungssymbol geklickt wird.
* Seiten, die die Erweiterung in einem **neuen Tab laden**.
* **Optionsseiten**: Diese Seite wird angezeigt, wenn auf die Erweiterung geklickt wird. In der vorherigen Manifestdatei konnte ich auf diese Seite unter `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` zugreifen oder auf:

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

Beachten Sie, dass diese Seiten im Gegensatz zu Hintergrundseiten nicht persistent sind, da sie bei Bedarf dynamisch Inhalte laden. Trotzdem teilen sie bestimmte Funktionen mit der Hintergrundseite:

- **Kommunikation mit Inhalts-Skripten:** √Ñhnlich wie die Hintergrundseite k√∂nnen diese Seiten Nachrichten von Inhalts-Skripten empfangen und so die Interaktion innerhalb der Erweiterung erleichtern.
- **Zugriff auf erweiterungsspezifische APIs:** Diese Seiten haben umfassenden Zugriff auf erweiterungsspezifische APIs, abh√§ngig von den f√ºr die Erweiterung definierten Berechtigungen.

### `permissions` & `host_permissions`

**`permissions`** und **`host_permissions`** sind Eintr√§ge in der `manifest.json`, die anzeigen, **welche Berechtigungen** die Browser-Erweiterung hat (Speicher, Standort...) und **auf welchen Webseiten**.

Da Browser-Erweiterungen so **privilegiert** sein k√∂nnen, k√∂nnte eine b√∂sartige oder kompromittierte Erweiterung dem Angreifer verschiedene M√∂glichkeiten bieten, sensible Informationen zu stehlen und den Benutzer auszuspionieren.

Erfahren Sie, wie diese Einstellungen funktionieren und wie sie missbraucht werden k√∂nnen:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Eine **Content Security Policy** kann ebenfalls in der `manifest.json` deklariert werden. Wenn eine solche definiert ist, k√∂nnte sie **anf√§llig** sein.

Die Standardkonfiguration f√ºr Browser-Erweiterungsseiten ist eher restriktiv:
```bash
script-src 'self'; object-src 'self';
```
F√ºr weitere Informationen √ºber CSP und m√∂gliche Umgehungen siehe:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Damit eine Webseite auf eine Seite einer Browsererweiterung zugreifen kann, z.B. eine `.html`-Seite, muss diese Seite im **`web_accessible_resources`**-Feld der `manifest.json` erw√§hnt werden.\
Zum Beispiel:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Diese Seiten sind √ºber URLs wie folgt erreichbar:
```
chrome-extension://<extension-id>/message.html
```
In √∂ffentlichen Erweiterungen ist die **Erweiterungs-ID zug√§nglich**:

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

Wenn jedoch der `manifest.json`-Parameter **`use_dynamic_url`** verwendet wird, kann diese **ID dynamisch sein**.

Die M√∂glichkeit, auf diese Seiten zuzugreifen, macht sie anf√§llig f√ºr **potenzielle ClickJacking-Angriffe**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Wenn diese Seiten nur von der Erweiterung und nicht von zuf√§lligen URLs geladen werden d√ºrfen, k√∂nnen ClickJacking-Angriffe verhindert werden.
{% endhint %}

### `externally_connectable`

Gem√§√ü der [**Dokumentation**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable) gibt die Eigenschaft `"externally_connectable"` im Manifest an, **welche Erweiterungen und Webseiten** √ºber [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) und [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) eine Verbindung zu Ihrer Erweiterung herstellen k√∂nnen.

* Wenn der Schl√ºssel **`externally_connectable`** nicht im Manifest Ihrer Erweiterung deklariert ist oder als **`"ids": ["*"]`** deklariert ist, k√∂nnen **alle Erweiterungen eine Verbindung herstellen, aber keine Webseiten**.
* Wenn **bestimmte IDs** angegeben sind, wie z.B. in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, k√∂nnen **nur diese Anwendungen** eine Verbindung herstellen.
* Wenn **√úbereinstimmungen** angegeben sind, k√∂nnen diese Webanwendungen eine Verbindung herstellen:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Wenn es als leer angegeben ist: **`"externally_connectable": {}`**, kann keine App oder Website eine Verbindung herstellen.

Je weniger Erweiterungen und URLs hier angegeben sind, desto kleiner ist die Angriffsfl√§che.

{% hint style="danger" %}
Wenn eine Webseite, die anf√§llig f√ºr XSS oder √úbernahme ist, in **`externally_connectable`** angegeben ist, kann ein Angreifer Nachrichten direkt an das Hintergrundskript senden und dabei das Content-Skript und seine CSP vollst√§ndig umgehen.

Daher handelt es sich um einen sehr leistungsstarken Bypass.
{% endhint %}

## Kommunikation zwischen Web und Content-Skript

Die Umgebungen, in denen Content-Skripte arbeiten, und die Umgebungen, in denen die Host-Seiten existieren, sind voneinander getrennt und gew√§hrleisten eine Isolierung. Trotz dieser Isolierung haben beide die M√∂glichkeit, mit dem Document Object Model (DOM) der Seite zu interagieren, das eine gemeinsam genutzte Ressource ist. Damit die Host-Seite mit dem Content-Skript oder indirekt mit der Erweiterung √ºber das Content-Skript kommunizieren kann, muss sie das DOM als Kommunikationskanal nutzen, auf das beide Parteien zugreifen k√∂nnen.

### Post-Nachrichten

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% code title="beispiel.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Eine sichere Post-Nachrichten-Kommunikation sollte die Authentizit√§t der empfangenen Nachricht √ºberpr√ºfen. Dies kann durch folgende √úberpr√ºfungen erfolgen:

* **`event.isTrusted`**: Dies ist nur dann True, wenn das Ereignis durch eine Benutzeraktion ausgel√∂st wurde.
* Das Inhalts-Skript erwartet m√∂glicherweise eine Nachricht nur, wenn der Benutzer eine Aktion ausf√ºhrt.
* **Ursprungsdom√§ne**: Erwartet m√∂glicherweise eine Nachricht nur von einer Whitelist von Dom√§nen.
* Wenn ein Regex verwendet wird, seien Sie sehr vorsichtig.
* **Quelle**: `received_message.source !== window` kann verwendet werden, um zu √ºberpr√ºfen, ob die Nachricht **aus demselben Fenster** stammt, in dem das Inhalts-Skript lauscht.

Die zuvor genannten √úberpr√ºfungen k√∂nnen trotz ihrer Durchf√ºhrung anf√§llig sein. √úberpr√ºfen Sie daher auf der folgenden Seite **potenzielle Post-Nachrichten-Bypasses**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Eine weitere m√∂gliche Kommunikationsmethode k√∂nnte √ºber **Iframe-URLs** erfolgen. Ein Beispiel finden Sie unter:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Dies ist nicht "genau" eine Kommunikationsmethode, aber das **Web und das Inhalts-Skript haben Zugriff auf das Web-DOM**. Wenn das **Inhalts-Skript** also Informationen daraus liest und dem Web-DOM vertraut, k√∂nnte das Web diese Daten √§ndern (weil dem Web nicht vertraut werden sollte oder weil das Web anf√§llig f√ºr XSS ist) und das Inhalts-Skript **kompromittieren**.

Sie finden auch ein Beispiel f√ºr einen **DOM-basierten XSS-Angriff zur Kompromittierung einer Browser-Erweiterung** unter:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Sensible Informationen im Speicher/Code

Wenn eine Browser-Erweiterung **sensible Informationen im Speicher** speichert, k√∂nnen diese Informationen (insbesondere auf Windows-Maschinen) **ausgelesen** und nach ihnen gesucht werden.

Daher sollte der Speicher der Browser-Erweiterung nicht als sicher betrachtet werden, und **sensible Informationen** wie Anmeldeinformationen oder mnemonische Phrasen sollten **nicht gespeichert werden**.

Nat√ºrlich sollten **sensible Informationen nicht im Code** abgelegt werden, da sie **√∂ffentlich** zug√§nglich sind.

## Kommunikation zwischen Inhalts-Skript **‚ÜîÔ∏é** Hintergrund-Skript

Ein Inhalts-Skript kann die Funktionen [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **oder** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) verwenden, um eine **einmalige JSON-serialisierbare** Nachricht zu senden.

Um die **Antwort** zu verarbeiten, verwenden Sie das zur√ºckgegebene **Promise**. F√ºr die Abw√§rtskompatibilit√§t k√∂nnen Sie jedoch immer noch eine **R√ºckruffunktion** als letzten Argument √ºbergeben.

Das Senden einer Anfrage von einem **Inhalts-Skript** sieht wie folgt aus:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Das Senden einer Anfrage von der **Erweiterung** (normalerweise ein **Hintergrundskript**) aus. Ein Inhalts-Skript kann die Funktionen verwenden, mit der Ausnahme, dass Sie angeben m√ºssen, an welchen Tab sie gesendet werden soll. Beispiel, wie Sie eine Nachricht an das Inhalts-Skript im ausgew√§hlten Tab senden k√∂nnen:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Auf der **Empfangsseite** m√ºssen Sie einen [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **Ereignislistener** einrichten, um die Nachricht zu verarbeiten. Dies sieht sowohl in einem Inhalts-Script als auch auf einer Erweiterungsseite gleich aus.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Im hervorgehobenen Beispiel wurde **`sendResponse()`** synchron ausgef√ºhrt. Um den `onMessage`-Event-Handler f√ºr die asynchrone Ausf√ºhrung von `sendResponse()` zu √§ndern, ist es unerl√§sslich, `return true;` einzubinden.

Eine wichtige √úberlegung ist, dass in Szenarien, in denen mehrere Seiten `onMessage`-Events empfangen sollen, **die erste Seite, die `sendResponse()`** f√ºr ein bestimmtes Event ausf√ºhrt, die einzige ist, die die Antwort effektiv liefern kann. Alle nachfolgenden Antworten auf dasselbe Event werden nicht ber√ºcksichtigt.

Bei der Erstellung neuer Erweiterungen sollte der Vorzug Promises gegen√ºber Callbacks gegeben werden. In Bezug auf die Verwendung von Callbacks wird die Funktion `sendResponse()` nur dann als g√ºltig betrachtet, wenn sie direkt im synchronen Kontext ausgef√ºhrt wird oder wenn der Event-Handler eine asynchrone Operation anzeigt, indem er `true` zur√ºckgibt. Wenn keiner der Handler `true` zur√ºckgibt oder wenn die Funktion `sendResponse()` aus dem Speicher entfernt wird (garbage-collected), wird das mit der Funktion `sendMessage()` verkn√ºpfte Callback standardm√§√üig ausgel√∂st.


## Laden einer Erweiterung im Browser

1. **Laden** Sie die Browser-Erweiterung herunter und entpacken Sie sie.
2. Gehen Sie zu **`chrome://extensions/`** und **aktivieren** Sie den `Entwicklermodus`.
3. Klicken Sie auf die Schaltfl√§che **`Ungepackte Erweiterung laden`**.

In **Firefox** gehen Sie zu **`about:debugging#/runtime/this-firefox`** und klicken Sie auf die Schaltfl√§che **`Tempor√§re Erweiterung laden`**.

## Abrufen des Quellcodes aus dem Store

Der Quellcode einer Chrome-Erweiterung kann auf verschiedene Arten abgerufen werden. Im Folgenden finden Sie detaillierte Erkl√§rungen und Anweisungen f√ºr jede Option.

### Herunterladen der Erweiterung als ZIP √ºber die Befehlszeile

Der Quellcode einer Chrome-Erweiterung kann √ºber die Befehlszeile als ZIP-Datei heruntergeladen werden. Hierbei wird `curl` verwendet, um die ZIP-Datei von einer bestimmten URL abzurufen, und anschlie√üend werden die Inhalte der ZIP-Datei in ein Verzeichnis extrahiert. Hier sind die Schritte:

1. Ersetzen Sie `"extension_id"` durch die tats√§chliche ID der Erweiterung.
2. F√ºhren Sie die folgenden Befehle aus:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Verwenden Sie die Website CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Verwenden Sie die CRX Viewer-Erweiterung

Eine weitere praktische Methode ist die Verwendung des Chrome Extension Source Viewer, der ein Open-Source-Projekt ist. Sie kann aus dem [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) installiert werden. Der Quellcode des Viewers ist in seinem [GitHub-Repository](https://github.com/Rob--W/crxviewer) verf√ºgbar.

### Quellcode einer lokal installierten Erweiterung anzeigen

Lokal installierte Chrome-Erweiterungen k√∂nnen ebenfalls inspiziert werden. So geht's:

1. Greifen Sie auf Ihr lokales Chrome-Profilverzeichnis zu, indem Sie `chrome://version/` aufrufen und das Feld "Profilpfad" suchen.
2. Navigieren Sie zum Unterordner `Extensions/` im Profilverzeichnis.
3. Dieser Ordner enth√§lt alle installierten Erweiterungen, in der Regel mit ihrem Quellcode in einem lesbaren Format.

Um Erweiterungen zu identifizieren, k√∂nnen Sie ihre IDs den Namen zuordnen:

- Aktivieren Sie den Entwicklermodus auf der Seite `about:extensions`, um die IDs jeder Erweiterung zu sehen.
- In jedem Erweiterungsordner enth√§lt die Datei `manifest.json` ein lesbares Feld `name`, das Ihnen bei der Identifizierung der Erweiterung hilft.

### Verwenden Sie einen Dateiarchivierer oder -entpacker
Gehen Sie zum Chrome Web Store und laden Sie die Erweiterung herunter. Die Datei hat die Erweiterung `.crx`.
√Ñndern Sie die Dateierweiterung von `.crx` in `.zip`.
Verwenden Sie einen beliebigen Dateiarchivierer (wie WinRAR, 7-Zip usw.), um den Inhalt der ZIP-Datei zu extrahieren.

### Verwenden Sie den Entwicklermodus in Chrome
√ñffnen Sie Chrome und gehen Sie zu `chrome://extensions/`.
Aktivieren Sie oben rechts den "Entwicklermodus".
Klicken Sie auf "Entpackte Erweiterung laden...".
Navigieren Sie zum Verzeichnis Ihrer Erweiterung.
Dies l√§dt nicht den Quellcode herunter, ist aber n√ºtzlich zum Anzeigen und √Ñndern des Codes einer bereits heruntergeladenen oder entwickelten Erweiterung.

## Sicherheits√ºberpr√ºfungs-Checkliste

Obwohl Browser-Erweiterungen eine **begrenzte Angriffsfl√§che** haben, k√∂nnen einige von ihnen **Schwachstellen** oder **potenzielle Verbesserungen der Absicherung** enthalten. Die folgenden sind die h√§ufigsten:

* [ ] Begrenzen Sie so weit wie m√∂glich die angeforderten **`permissions`**.
* [ ] Begrenzen Sie so weit wie m√∂glich die **`host_permissions`**.
* [ ] Verwenden Sie eine **starke** **`content_security_policy`**.
* [ ] Begrenzen Sie so weit wie m√∂glich die **`externally_connectable`**, wenn keine ben√∂tigt wird und m√∂glich ist, lassen Sie sie nicht standardm√§√üig offen, geben Sie **`{}`** an.
* [ ] Wenn hier eine URL anf√§llig f√ºr XSS oder √úbernahme erw√§hnt wird, kann ein Angreifer Nachrichten direkt an die Hintergrundskripte senden. Sehr m√§chtiger Umgehungsschutz.
* [ ] Begrenzen Sie so weit wie m√∂glich die **`web_accessible_resources`**, auch wenn sie leer ist, wenn m√∂glich.
* [ ] Wenn **`web_accessible_resources`** nicht leer ist, √ºberpr√ºfen Sie auf [**ClickJacking**](browext-clickjacking.md).
* [ ] Wenn eine **Kommunikation** von der **Erweiterung** zur **Webseite** erfolgt, √ºberpr√ºfen Sie auf XSS-Schwachstellen, die durch die Kommunikation verursacht werden k√∂nnen.
* [ ] Wenn Post Messages verwendet werden, √ºberpr√ºfen Sie auf [**Post Message-Schwachstellen**](../postmessage-vulnerabilities/)**.**
* [ ] Wenn das **Content Script auf DOM-Details zugreift**, stellen Sie sicher, dass sie keine XSS einf√ºhren, wenn sie vom Web ge√§ndert werden.
* [ ] Legen Sie besonderen Wert darauf, wenn diese Kommunikation auch an der **Kommunikation zwischen dem Content Script und dem Hintergrundskript** beteiligt ist.
* [ ] **Sensible Informationen sollten nicht** im Code der Browser-Erweiterung **gespeichert werden**.
* [ ] **Sensible Informationen sollten nicht** im Speicher der Browser-Erweiterung **gespeichert werden**.

## Tools

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* L√§dt eine beliebige Chrome-Erweiterung von einem bereitgestellten Chrome Webstore-Link herunter.
* **manifest.json**-Viewer: Zeigt einfach eine JSON-formatierte Version des Manifests der Erweiterung an.
* Fingerprint-Analyse: Erkennung von [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) und automatische Generierung von JavaScript zur Erstellung von Fingerabdr√ºcken f√ºr Chrome-Erweiterungen.
* Analyse potenzieller Clickjacking-Angriffe: Erkennung von Erweiterungs-HTML-Seiten mit der Direktive [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources). Diese sind je nach Zweck der Seiten potenziell anf√§llig f√ºr Clickjacking.
* Viewer f√ºr Berechtigungswarnungen: Zeigt eine Liste aller Chrome-Berechtigungswarnungen an, die angezeigt werden, wenn ein Benutzer versucht, die Erweiterung zu installieren.
* Gef√§hrliche Funktionen: Zeigt den Ort gef√§hrlicher Funktionen an, die potenziell von einem Angreifer ausgenutzt werden k√∂nnten (z. B. Funktionen wie innerHTML, chrome.tabs.executeScript).
* Einstiegspunkte: Zeigt, wo die Erweiterung Benutzer-/externe Eingaben entgegennimmt. Dies ist n√ºtzlich, um den Umfang einer Erweiterung zu verstehen und potenzielle Punkte zu finden, an denen b√∂sartig gestaltete Daten an die Erweiterung gesendet werden k√∂nnen.
* Sowohl die Scanner f√ºr gef√§hrliche Funktionen als auch die Einstiegspunkte haben folgende Funktionen f√ºr ihre generierten Warnungen:
* Relevanter Codeausschnitt und Zeile, die die Warnung verursacht hat.
* Beschreibung des Problems.
* Eine Schaltfl√§che "Datei anzeigen", um die vollst√§ndige Quelldatei mit dem Code anzuzeigen.
* Der Pfad der alarmierten Datei.
* Die vollst√§ndige Chrome-Erweiterungs-URI der alarmierten Datei.
* Der Dateityp, z. B. ein Hintergrundseitenskript, ein Inhalts-Skript, eine Browseraktion usw.
* Wenn die anf√§llige Zeile in einer JavaScript-Datei ist, die Pfade aller Seiten, in denen sie enthalten ist, sowie der Typ dieser Seiten und der Status von [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Content Security Policy (CSP)-Analyzer und Bypass-Checker**: Dies zeigt Schwachstellen in der CSP Ihrer Erweiterung auf und zeigt auch potenzielle M√∂glichkeiten auf, Ihre CSP aufgrund von whitelisteten CDNs usw. zu umgehen.
* **Bekannte anf√§llige Bibliotheken**: Hier wird mit [Retire.js](https://retirejs.github.io/retire.js/) √ºberpr√ºft, ob bekannte anf√§llige JavaScript-Bibliotheken verwendet werden.
* Erweiterung und formatierte Versionen herunterladen.
* Die urspr√ºngliche Erweiterung herunterladen.
* Eine formatierte Version der Erweiterung herunterladen (automatisch formatierter HTML- und JavaScript-Code).
* Automatisches Zwischenspeichern von Scanergebnissen. Das Ausf√ºhren eines Erweiterungsscans dauert beim ersten Mal eine gute Zeit. Beim zweiten Mal, sofern die Erweiterung nicht aktualisiert wurde, erfolgt die Ausf√ºhrung fast sofort, da die Ergebnisse zwischengespeichert werden.
* Verlinkbare Berichts-URLs, mit denen Sie jemand anderen einfach zu einem von Tarnish generierten Erweiterungsbericht
* Wenn Sie Ihr Unternehmen in HackTricks bewerben m√∂chten oder HackTricks als PDF herunterladen m√∂chten, √ºberpr√ºfen Sie die [ABONNEMENTPL√ÑNE](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [offizielle PEASS & HackTricks-Merchandise](https://peass.creator-spring.com)
* Entdecken Sie [Die PEASS-Familie](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [NFTs](https://opensea.io/collection/the-peass-family)
* Treten Sie der üí¨ [Discord-Gruppe](https://discord.gg/hRep4RUj7f) oder der [Telegram-Gruppe](https://t.me/peass) bei oder folgen Sie uns auf Twitter üê¶ [@carlospolopm](https://twitter.com/hacktricks_live).
* Teilen Sie Ihre Hacking-Tricks, indem Sie PRs zu den GitHub-Repositories [HackTricks](https://github.com/carlospolop/hacktricks) und [HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud) einreichen.

</details>
