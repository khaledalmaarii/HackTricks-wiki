# Cache Poisoning und Cache T√§uschung

<details>

<summary>Lernen Sie AWS-Hacking von Grund auf mit <a href="https://training.hacktricks.xyz/courses/arte">htARTE (HackTricks AWS Red Team Expert)</a>!</summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

- Wenn Sie Ihr Unternehmen in HackTricks bewerben m√∂chten oder HackTricks als PDF herunterladen m√∂chten, √ºberpr√ºfen Sie die [ABONNEMENTPL√ÑNE](https://github.com/sponsors/carlospolop)!
- Holen Sie sich das offizielle PEASS & HackTricks-Merchandise
- Entdecken Sie die PEASS-Familie, unsere Sammlung exklusiver NFTs
- Treten Sie der Discord-Gruppe oder der Telegram-Gruppe bei oder folgen Sie uns auf Twitter
- Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die HackTricks- und HackTricks Cloud-GitHub-Repositories senden.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [Trickest](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Der Unterschied

> Was ist der Unterschied zwischen Web-Cache-Vergiftung und Web-Cache-T√§uschung?
>
> - Bei der **Web-Cache-Vergiftung** veranlasst der Angreifer die Anwendung, einige b√∂sartige Inhalte im Cache zu speichern, und diese Inhalte werden anderen Anwendungsbenutzern aus dem Cache bereitgestellt.
> - Bei der **Web-Cache-T√§uschung** veranlasst der Angreifer die Anwendung, einige sensible Inhalte eines anderen Benutzers im Cache zu speichern, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

## Cache-Vergiftung

Die Cache-Vergiftung zielt darauf ab, den Client-Cache zu manipulieren, um die Clients dazu zu zwingen, Ressourcen zu laden, die unerwartet, teilweise oder unter der Kontrolle eines Angreifers stehen. Das Ausma√ü der Auswirkungen h√§ngt von der Beliebtheit der betroffenen Seite ab, da die kontaminierte Antwort ausschlie√ülich an Benutzer geliefert wird, die die Seite w√§hrend des Zeitraums der Cache-Kontamination besuchen.

Die Durchf√ºhrung eines Cache-Vergiftungsangriffs umfasst mehrere Schritte:

1. **Identifizierung von nicht gekennzeichneten Eingaben**: Dies sind Parameter, die zwar nicht f√ºr eine zwischengespeicherte Anfrage erforderlich sind, aber die vom Server zur√ºckgegebene Antwort √§ndern k√∂nnen. Die Identifizierung dieser Eingaben ist entscheidend, da sie ausgenutzt werden k√∂nnen, um den Cache zu manipulieren.

2. **Ausnutzung der nicht gekennzeichneten Eingaben**: Nach der Identifizierung der nicht gekennzeichneten Eingaben besteht der n√§chste Schritt darin, herauszufinden, wie diese Parameter missbraucht werden k√∂nnen, um die Antwort des Servers auf eine Weise zu √§ndern, die dem Angreifer zugutekommt.

3. **Sicherstellen, dass die vergiftete Antwort zwischengespeichert wird**: Der letzte Schritt besteht darin, sicherzustellen, dass die manipulierte Antwort im Cache gespeichert wird. Auf diese Weise erh√§lt jeder Benutzer, der w√§hrend der Vergiftung des Caches auf die betroffene Seite zugreift, die kontaminierte Antwort.

### Entdeckung: √úberpr√ºfen der HTTP-Header

Normalerweise gibt es einen Header, der anzeigt, dass eine Antwort im Cache gespeichert wurde. Sie k√∂nnen √ºberpr√ºfen, auf welche Header Sie in diesem Beitrag achten sollten: [HTTP-Cache-Header](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Entdeckung: Caching von Statuscode 400

Wenn Sie vermuten, dass die Antwort im Cache gespeichert wird, k√∂nnen Sie versuchen, Anfragen mit einem ung√ºltigen Header zu senden, auf die mit dem Statuscode 400 geantwortet werden sollte. Versuchen Sie dann, die Anfrage normal abzurufen, und wenn die Antwort ein Statuscode 400 ist, wissen Sie, dass sie verwundbar ist (und Sie k√∂nnten sogar einen DoS-Angriff durchf√ºhren).
Ein schlecht konfigurierter Header k√∂nnte einfach `\:` als Header sein.
Beachten Sie, dass solche Statuscodes manchmal nicht zwischengespeichert werden, sodass dieser Test nutzlos sein wird.

### Entdeckung: Identifizieren und Bewerten nicht gekennzeichneter Eingaben

Sie k√∂nnen [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) verwenden, um Parameter und Header zu brute-forcen, die die Antwort der Seite √§ndern k√∂nnen. Eine Seite kann beispielsweise den Header `X-Forwarded-For` verwenden, um den Client anzuweisen, das Skript von dort zu laden:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicitieren Sie eine sch√§dliche Antwort vom Backend-Server

√úberpr√ºfen Sie mit dem identifizierten Parameter/ Header, wie er **ges√§ubert** wird und **wo** er sich in der Antwort des Headers **widerspiegelt** oder diese beeinflusst. K√∂nnen Sie ihn missbrauchen (eine XSS durchf√ºhren oder einen von Ihnen kontrollierten JS-Code laden? Einen DoS durchf√ºhren?...)

### Holen Sie sich die zwischengespeicherte Antwort

Sobald Sie die **Seite** identifiziert haben, die missbraucht werden kann, welchen **Parameter**/**Header** Sie verwenden und wie Sie ihn missbrauchen k√∂nnen, m√ºssen Sie die Seite zwischenspeichern. Je nach Ressource, die Sie im Cache abrufen m√∂chten, kann dies einige Zeit dauern. Sie m√ºssen m√∂glicherweise mehrere Sekunden lang versuchen.\
Der Header **`X-Cache`** in der Antwort kann sehr n√ºtzlich sein, da er den Wert **`miss`** haben kann, wenn die Anfrage nicht zwischengespeichert wurde, und den Wert **`hit`**, wenn sie zwischengespeichert ist.\
Der Header **`Cache-Control`** ist auch interessant, um festzustellen, ob eine Ressource zwischengespeichert wird und wann die Ressource das n√§chste Mal wieder zwischengespeichert wird: `Cache-Control: public, max-age=1800`\
Ein weiterer interessanter Header ist **`Vary`**. Dieser Header wird h√§ufig verwendet, um **zus√§tzliche Header** anzugeben, die als **Teil des Cache-Schl√ºssels** behandelt werden, auch wenn sie normalerweise nicht als Schl√ºssel verwendet werden. Wenn der Benutzer den `User-Agent` des Opfers kennt, kann er den Cache f√ºr Benutzer vergiften, die diesen bestimmten `User-Agent` verwenden.\
Ein weiterer Header, der mit dem Cache zusammenh√§ngt, ist **`Age`**. Er definiert die Zeit in Sekunden, die das Objekt im Proxy-Cache verbracht hat.

Beim Zwischenspeichern einer Anfrage sollten Sie **vorsichtig mit den verwendeten Headern** sein, da einige von ihnen **unerwartet als Schl√ºssel verwendet werden** k√∂nnten und das Opfer diesen gleichen Header verwenden muss. Testen Sie immer eine Cache-Vergiftung mit **verschiedenen Browsern**, um zu √ºberpr√ºfen, ob sie funktioniert.

## Beispiele f√ºr Ausnutzung

### Einfachstes Beispiel

Ein Header wie `X-Forwarded-For` wird unsaniert in der Antwort reflektiert.\
Sie k√∂nnen eine grundlegende XSS-Payload senden und den Cache vergiften, sodass jeder, der auf die Seite zugreift, XSS ausgesetzt wird:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Verwendung von Web-Cache-Vergiftung zur Ausnutzung von Cookie-Handling-Schwachstellen

Cookies k√∂nnen auch in der Antwort einer Seite reflektiert werden. Wenn Sie es zum Beispiel missbrauchen k√∂nnen, um eine XSS zu verursachen, k√∂nnten Sie in der Lage sein, XSS in mehreren Clients auszunutzen, die die b√∂sartige Cache-Antwort laden.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Beachten Sie, dass der anf√§llige Cookie durch regelm√§√üige Anfragen von der Cache bereinigt werden kann.

### Verwendung mehrerer Header zur Ausnutzung von Schwachstellen bei der Web-Cache-Vergiftung <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Manchmal m√ºssen Sie **mehrere nicht gekennzeichnete Eingaben** ausnutzen, um einen Cache zu missbrauchen. Zum Beispiel k√∂nnen Sie eine **Offene Weiterleitung** finden, wenn Sie `X-Forwarded-Host` auf eine von Ihnen kontrollierte Domain und `X-Forwarded-Scheme` auf `http` setzen. **Wenn** der **Server** alle **HTTP**-Anfragen **an HTTPS** weiterleitet und den Header `X-Forwarded-Scheme` als Domainnamen f√ºr die Weiterleitung verwendet. Sie k√∂nnen kontrollieren, wohin die Seite durch die Weiterleitung zeigt.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Ausnutzung mit begrenztem `Vary`-Header

Wenn Sie feststellen, dass der Header **`X-Host`** als **Domainname zum Laden einer JS-Ressource** verwendet wird, der **`Vary`**-Header in der Antwort jedoch auf **`User-Agent`** hinweist, m√ºssen Sie einen Weg finden, um den User-Agent des Opfers auszulesen und den Cache mit diesem User-Agent zu manipulieren:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Ausnutzung der HTTP-Cache-Vergiftung durch Missbrauch des HTTP-Request-Smuggling

Erfahren Sie hier, wie Sie [Cache-Vergiftungsangriffe durch Missbrauch des HTTP-Request-Smuggling](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) durchf√ºhren k√∂nnen.

### Automatisiertes Testen auf Web-Cache-Vergiftung

Der [Web-Cache-Vulnerability-Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kann verwendet werden, um automatisch auf Web-Cache-Vergiftung zu testen. Er unterst√ºtzt viele verschiedene Techniken und ist hochgradig anpassbar.

Beispielhafte Verwendung: `wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Anf√§llige Beispiele

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS leitete das Fragment in der URL weiter, ohne es zu entfernen, und generierte den Cache-Schl√ºssel nur unter Verwendung des Hosts, des Pfads und der Abfrage (wobei das Fragment ignoriert wurde). Daher wurde die Anfrage `/#/../?r=javascript:alert(1)` als `/#/../?r=javascript:alert(1)` an den Backend gesendet und der Cache-Schl√ºssel enthielt die Nutzlast nicht, sondern nur Host, Pfad und Abfrage.

### GitHub CP-DoS

Das Senden eines ung√ºltigen Werts im Content-Type-Header l√∂ste eine zwischengespeicherte 405-Antwort aus. Der Cache-Schl√ºssel enthielt das Cookie, sodass nur nicht authentifizierte Benutzer angegriffen werden konnten.

### GitLab + GCP CP-DoS

GitLab verwendet GCP-Buckets zur Speicherung von statischem Inhalt. **GCP Buckets** unterst√ºtzen den Header `x-http-method-override`. Es war also m√∂glich, den Header `x-http-method-override: HEAD` zu senden und den Cache dazu zu bringen, eine leere Antwort zur√ºckzugeben. Es k√∂nnte auch die Methode `PURGE` unterst√ºtzen.

### Rack Middleware (Ruby on Rails)

In Ruby on Rails-Anwendungen wird h√§ufig Rack-Middleware verwendet. Der Zweck des Rack-Codes besteht darin, den Wert des Headers **`x-forwarded-scheme`** zu nehmen und ihn als Schema der Anfrage festzulegen. Wenn der Header `x-forwarded-scheme: http` gesendet wird, erfolgt eine 301-Weiterleitung zum selben Ort, was potenziell zu einer Denial-of-Service (DoS) f√ºr diese Ressource f√ºhren kann. Dar√ºber hinaus kann die Anwendung den `X-forwarded-host`-Header erkennen und Benutzer zur angegebenen Host-Adresse umleiten. Dieses Verhalten kann dazu f√ºhren, dass JavaScript-Dateien von einem Server eines Angreifers geladen werden, was ein Sicherheitsrisiko darstellt.

### 403 und Storage Buckets

Cloudflare hat fr√ºher 403-Antworten zwischengespeichert. Wenn versucht wurde, auf S3- oder Azure Storage-Blobs mit falschen Autorisierungsheadern zuzugreifen, wurde eine 403-Antwort zwischengespeichert. Obwohl Cloudflare aufgeh√∂rt hat, 403-Antworten zu zwischenspeichern, k√∂nnte dieses Verhalten bei anderen Proxy-Diensten noch vorhanden sein.

### Einf√ºgen von Schl√ºsselparametern

Caches enthalten oft bestimmte GET-Parameter im Cache-Schl√ºssel. Zum Beispiel hat Fastlys Varnish den `size`-Parameter in Anfragen zwischengespeichert. Wenn jedoch eine URL-codierte Version des Parameters (z. B. `siz%65`) mit einem fehlerhaften Wert gesendet wurde, wurde der Cache-Schl√ºssel unter Verwendung des korrekten `size`-Parameters konstruiert. Die Backend-Verarbeitung erfolgte jedoch mit dem Wert im URL-codierten Parameter. Durch die URL-Codierung des zweiten `size`-Parameters wurde dieser vom Cache ausgelassen, aber vom Backend verwendet. Das Zuweisen eines Werts von 0 zu diesem Parameter f√ºhrte zu einem zwischenspeicherbaren 400 Bad Request-Fehler.

### User-Agent-Regeln

Einige Entwickler blockieren Anfragen mit User-Agents, die denen von stark frequentierten Tools wie FFUF oder Nuclei entsprechen, um die Serverlast zu verwalten. Ironischerweise kann dieser Ansatz Sicherheitsl√ºcken wie Cache-Vergiftung und DoS einf√ºhren.

### Ung√ºltige Header-Felder

Die [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) gibt die akzeptablen Zeichen in Header-Namen an. Header, die Zeichen au√üerhalb des angegebenen **tchar**-Bereichs enthalten, sollten idealerweise eine 400 Bad Request-Antwort ausl√∂sen. In der Praxis halten sich Server jedoch nicht immer an diesen Standard. Ein bemerkenswertes Beispiel ist Akamai, das Header mit ung√ºltigen Zeichen weiterleitet und jeden 400-Fehler zwischenspeichert, solange der `cache-control`-Header nicht vorhanden ist. Es wurde ein ausnutzbares Muster identifiziert, bei dem das Senden eines Headers mit einem ung√ºltigen Zeichen, wie z. B. `\`, zu einem zwischenspeicherbaren 400 Bad Request-Fehler f√ºhrte.

### Auffinden neuer Header

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache-T√§uschung

Das Ziel der Cache-T√§uschung besteht darin, dass Clients **Ressourcen laden, die vom Cache mit ihren sensiblen Informationen gespeichert werden**.

Zun√§chst ist zu beachten, dass **Erweiterungen** wie `.css`, `.js`, `.png` usw. normalerweise so **konfiguriert** sind, dass sie im **Cache gespeichert** werden. Wenn Sie also auf `www.example.com/profile.php/nonexistent.js` zugreifen, wird der Cache wahrscheinlich die Antwort speichern, weil er die `.js`-**Erweiterung** sieht. Wenn die **Anwendung** jedoch mit den **sensiblen** Benutzerinhalten, die in _www.example.com/profile.php_ gespeichert sind, wiederholt wird, k√∂nnen Sie diese Inhalte von anderen Benutzern **stehlen**.

Andere Dinge, die getestet werden k√∂nnen:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Verwenden Sie weniger bekannte Erweiterungen wie_ `.avif`

Ein weiteres sehr deutliches Beispiel finden Sie in diesem Bericht: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In dem Beispiel wird erkl√§rt, dass beim Laden einer nicht vorhandenen Seite wie _http://www.example.com/home.php/non-existent.css_ der Inhalt von _http://www.example.com/home.php_ (**mit den sensiblen Informationen des Benutzers**) zur√ºckgegeben wird und der Cache-Server das Ergebnis speichert.\
Dann kann der **Angreifer** _http://www.example.com/home.php/non-existent.css_ in seinem eigenen Browser aufrufen und die **vertraulichen Informationen** der zuvor aufgerufenen Benutzer beobachten.

Beachten Sie, dass der **Cache-Proxy** so konfiguriert sein sollte, dass Dateien **basierend** auf der **Erweiterung** der Datei (_.css_) und nicht basierend auf dem Content-Type zwischengespeichert werden. In dem Beispiel wird _http://www.example.com/home.php/non-existent.css_ einen `text/html`-Content-Type anstelle eines `text
<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
