# Sonsuz Bekleme Yoluyla LFI2RCE

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramana Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**]'na (https://github.com/sponsors/carlospolop) gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**]'yi (https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**]'i (https://opensea.io/collection/the-peass-family) iÃ§eren koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubumuza**](https://discord.gg/hRep4RUj7f) veya [**telegram grubumuza**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'lar gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## Temel Bilgiler

Bir dosya PHP'ye yÃ¼klendiÄŸinde (beklemese bile), **`php[a-zA-Z0-9]{6}`** gibi bir isme sahip geÃ§ici bir dosya oluÅŸturur `/tmp` iÃ§inde, ancak bazÄ± docker gÃ¶rÃ¼ntÃ¼lerinde oluÅŸturulan dosyalarÄ±n rakamlar iÃ§ermediÄŸini gÃ¶rdÃ¼m.

Yerel dosya dahilinde, **o yÃ¼klenen dosyayÄ± dahil edebilirseniz, RCE elde edersiniz**.

VarsayÄ±lan olarak **PHP yalnÄ±zca tek bir istekte 20 dosya yÃ¼klemeye izin verir** (ayarlanÄ±r `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
AyrÄ±ca, **potansiyel dosya adedi 62\*62\*62\*62\*62\*62 = 56800235584**

### DiÄŸer teknikler

DiÄŸer teknikler, PHP protokollerine saldÄ±rarak (yolu sadece son kÄ±smÄ± kontrol ediyorsanÄ±z baÅŸarÄ±lÄ± olamazsÄ±nÄ±z), dosyanÄ±n yolunu ifÅŸa ederek, beklenen dosyalarÄ± kÃ¶tÃ¼ye kullanarak veya **PHP'nin bir segmentasyon hatasÄ± yaÅŸamasÄ±nÄ± saÄŸlayarak yÃ¼klenen geÃ§ici dosyalarÄ±n silinmemesini saÄŸlamak** Ã¼zerine kuruludur.\
Bu teknik, **bir sÄ±fÄ±r gÃ¼n bulma gerektirmeden** son teknikle Ã§ok benzerdir.

### Sonsuz bekleme tekniÄŸi

Bu teknikte **yalnÄ±zca gÃ¶receli bir yol kontrol etmemiz gerekir**. EÄŸer dosyalarÄ± yÃ¼klemeyi baÅŸarabilir ve **LFI'nin hiÃ§ bitmemesini saÄŸlarsak**, "yeterince zamanÄ±mÄ±z" olacak ve **yÃ¼klendiÄŸi tespit edilen dosyalarÄ±** **kaba kuvvet uygulayarak bulabileceÄŸiz**.

Bu tekniÄŸin **avantajlarÄ±**:

* Bir include iÃ§inde bir gÃ¶receli yol kontrol etmeniz yeterlidir
* Nginx veya log dosyalarÄ±na beklenmedik dÃ¼zeyde eriÅŸim gerektirmez
* Bir segmentasyon hatasÄ± oluÅŸturmak iÃ§in bir sÄ±fÄ±r gÃ¼n gerektirmez
* Bir yol ifÅŸasÄ± gerektirmez

Bu tekniÄŸin **ana sorunlarÄ±** ÅŸunlardÄ±r:

* Belirli bir dosyanÄ±n mevcut olmasÄ± gereklidir (daha fazla olabilir)
* **Ã‡Ä±lgÄ±nca** potansiyel dosya adedi: **56800235584**
* Sunucu **rakamlarÄ± kullanmÄ±yorsa** toplam potansiyel miktar: **19770609664**
* VarsayÄ±lan olarak **tek bir istekte 20 dosya** yÃ¼klenebilir.
* KullanÄ±lan sunucunun **maksimum eÅŸzamanlÄ± iÅŸÃ§i sayÄ±sÄ±**.
* Bu sÄ±nÄ±rlama ve Ã¶ncekiler bu saldÄ±rÄ±nÄ±n Ã§ok uzun sÃ¼rmesine neden olabilir
* **Bir PHP isteÄŸi iÃ§in zaman aÅŸÄ±mÄ±**. Ä°deal olarak bu sonsuz olmalÄ± veya PHP iÅŸlemini silmeden geÃ§ici yÃ¼klenen dosyalarÄ± silmelidir, aksi takdirde bu da bir sorun olacaktÄ±r

Peki, bir PHP include'Ä± **asla bitmeyecek ÅŸekilde nasÄ±l yapabilirsiniz**? Sadece **`/sys/kernel/security/apparmor/revision`** dosyasÄ±nÄ± dahil ederek. (**Ne yazÄ±k ki Docker konteynerlerinde mevcut deÄŸil...**).

Sadece ÅŸunu Ã§aÄŸÄ±rarak deneyin:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

VarsayÄ±lan olarak, Apache **150 eÅŸzamanlÄ± baÄŸlantÄ±yÄ±** destekler, [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) adresinde belirtildiÄŸi gibi bu sayÄ±yÄ± 8000'e kadar yÃ¼kseltmek mÃ¼mkÃ¼ndÃ¼r. Bu modÃ¼lle PHP kullanmak iÃ§in ÅŸu adÄ±mlarÄ± izleyin: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

VarsayÄ±lan olarak, (testlerimde gÃ¶rdÃ¼ÄŸÃ¼m kadarÄ±yla) **bir PHP iÅŸlemi sonsuza kadar sÃ¼rebilir**.

Åimdi biraz matematik yapalÄ±m:

* **149 baÄŸlantÄ±** kullanarak **149 \* 20 = 2980 geÃ§ici dosya** oluÅŸturabiliriz web kabuÄŸumuzla.
* ArdÄ±ndan, potansiyel dosyalarÄ± **kaba kuvvet** ile aramak iÃ§in **son baÄŸlantÄ±yÄ±** kullanÄ±n.
* **10 istek/s** hÄ±zÄ±nda zamanlar ÅŸunlardÄ±r:
* 56800235584 / 2980 / 10 / 3600 \~= **530 saat** (265 saatte %50 olasÄ±lÄ±k)
* (ondalÄ±ksÄ±z) 19770609664 / 2980 / 10 / 3600 \~= 185 saat (93 saatte %50 olasÄ±lÄ±k)

{% hint style="warning" %}
Ã–nceki Ã¶rnekte **diÄŸer istemcileri tamamen DoS** ediyoruz!
{% endhint %}

EÄŸer Apache sunucusu iyileÅŸtirilirse ve **4000 baÄŸlantÄ±yÄ±** (maksimum sayÄ±nÄ±n yarÄ±sÄ±) kullanabilirsek. `3999*20 = 79980` **dosya** oluÅŸturabilir ve **sayÄ±** yaklaÅŸÄ±k olarak **19.7 saat** veya **6.9 saat** (10 saat, 3.5 saat %50 olasÄ±lÄ±k) olur.

## PHP-FMP

EÄŸer web sayfasÄ± PHP betiklerini Ã§alÄ±ÅŸtÄ±rmak iÃ§in dÃ¼zenli php modunu kullanmak yerine **PHP-FMP** kullanÄ±yorsa (bu web sayfasÄ±nÄ±n verimliliÄŸini artÄ±rÄ±r, bu yÃ¼zden sÄ±kÃ§a karÅŸÄ±laÅŸÄ±lÄ±r), tekniÄŸi iyileÅŸtirmek iÃ§in baÅŸka bir ÅŸey yapÄ±labilir.

PHP-FMP, **`/etc/php/<php-sÃ¼rÃ¼mÃ¼>/fpm/pool.d/www.conf`** iÃ§inde **`request_terminate_timeout`** parametresini **ayarlamaya** izin verir.\
Bu parametre, **PHP'ye yapÄ±lan isteÄŸin** **ne zaman sonlanmasÄ± gerektiÄŸini** belirtir (varsayÄ±lan olarak sonsuzdur, ancak **parametre yorumlanÄ±rsa 30 saniyedir**). Bir istek PHP tarafÄ±ndan iÅŸlenirken belirtilen saniye sayÄ±sÄ±na ulaÅŸtÄ±ÄŸÄ±nda, **sonlandÄ±rÄ±lÄ±r**. Bu, istek geÃ§ici dosyalar yÃ¼klenirken **php iÅŸlemi durdurulduÄŸunda**, bu **dosyalarÄ±n silinmeyeceÄŸi** anlamÄ±na gelir. DolayÄ±sÄ±yla, bir isteÄŸi o sÃ¼re boyunca sÃ¼rdÃ¼rebilirseniz, silinmeyecek **binlerce geÃ§ici dosya oluÅŸturabilirsiniz**, bu da onlarÄ± bulma sÃ¼recini hÄ±zlandÄ±rÄ±r ve tÃ¼m baÄŸlantÄ±larÄ± tÃ¼keterek platforma bir DoS olasÄ±lÄ±ÄŸÄ±nÄ± azaltÄ±r.

Bu nedenle, **DoS'yi Ã¶nlemek** iÃ§in bir **saldÄ±rganÄ±n aynÄ± anda yalnÄ±zca 100 baÄŸlantÄ±yÄ±** ve php-fmp tarafÄ±ndan belirlenen **php maksimum iÅŸlem sÃ¼resini** (`request_terminate_timeout`**)** **30 saniye** olarak kullanacaÄŸÄ±nÄ± varsayalÄ±m. DolayÄ±sÄ±yla, saniyede oluÅŸturulabilecek **geÃ§ici dosya sayÄ±sÄ±** `100*20/30 = 66.67` olacaktÄ±r.

Sonra, **10000 dosya** oluÅŸturmak iÃ§in bir saldÄ±rganÄ±n ihtiyacÄ± olan sÃ¼re: **`10000/66.67 = 150 saniye`** (100000 dosya oluÅŸturmak iÃ§in gereken sÃ¼re ise **25 dakika** olacaktÄ±r).

ArdÄ±ndan, saldÄ±rgan bu **100 baÄŸlantÄ±yÄ±** kullanarak bir **arama kaba kuvveti** gerÃ§ekleÅŸtirebilir. **300 istek/s** hÄ±zÄ±nda Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± varsayarsak, bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in gereken sÃ¼re ÅŸÃ¶yledir:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 saat** (2.63 saatte %50 olasÄ±lÄ±k)
* (100000 dosya ile) 56800235584 / 100000 / 300 / 3600 \~= **0.525 saat** (0.263 saatte %50 olasÄ±lÄ±k)

Evet, bir EC2 orta boyutlu Ã¶rneÄŸinde 100000 geÃ§ici dosya oluÅŸturmak mÃ¼mkÃ¼ndÃ¼r:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Zaman aÅŸÄ±mÄ±nÄ± tetiklemek iÃ§in **yeterli olacak ÅŸekilde zafiyetli LFI sayfasÄ±nÄ±** iÃ§erdiÄŸinizi unutmayÄ±n, bÃ¶ylece sonsuz bir dahil dÃ¶ngÃ¼ye girer.
{% endhint %}

## Nginx

VarsayÄ±lan olarak Nginx'in aynÄ± anda **512 paralel baÄŸlantÄ±yÄ±** desteklediÄŸi gÃ¶rÃ¼nÃ¼yor (bu sayÄ± artÄ±rÄ±labilir).
