# LFI2RCE via Eternal waiting

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informazioni di base

Per impostazione predefinita, quando un file viene caricato su PHP (anche se non lo sta aspettando), genera un file temporaneo in `/tmp` con un nome come **`php[a-zA-Z0-9]{6}`**, anche se ho visto alcune immagini docker in cui i file generati non contengono cifre.

In un'inclusione di file locale, **se riesci a includere quel file caricato, otterrai RCE**.

Nota che per impostazione predefinita **PHP consente di caricare solo 20 file in una singola richiesta** (impostato in `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Also, il **numero di nomi di file potenziali √® 62\*62\*62\*62\*62\*62 = 56800235584**

### Altre tecniche

Altre tecniche si basano sull'attacco ai protocolli PHP (non sarai in grado se controlli solo l'ultima parte del percorso), divulgando il percorso del file, abusando di file attesi, o **facendo soffrire PHP di un errore di segmentazione in modo che i file temporanei caricati non vengano eliminati**.\
Questa tecnica √® **molto simile all'ultima ma senza dover trovare un zero day**.

### Tecnica dell'attesa eterna

In questa tecnica **abbiamo solo bisogno di controllare un percorso relativo**. Se riusciamo a caricare file e far s√¨ che **LFI non finisca mai**, avremo "abbastanza tempo" per **forzare i file caricati** e **trovare** uno di quelli caricati.

**Vantaggi di questa tecnica**:

* Devi solo controllare un percorso relativo all'interno di un include
* Non richiede nginx o un livello inaspettato di accesso ai file di log
* Non richiede un 0 day per causare un errore di segmentazione
* Non richiede una divulgazione del percorso

I **principali problemi** di questa tecnica sono:

* Necessit√† che un file specifico sia presente (potrebbero essercene di pi√π)
* L'**insana** quantit√† di nomi di file potenziali: **56800235584**
* Se il server **non utilizza cifre** la quantit√† totale potenziale √®: **19770609664**
* Per impostazione predefinita **solo 20 file** possono essere caricati in una **singola richiesta**.
* Il **numero massimo di lavoratori paralleli** del server utilizzato.
* Questo limite con i precedenti pu√≤ far durare troppo a lungo questo attacco
* **Timeout per una richiesta PHP**. Idealmente questo dovrebbe essere eterno o dovrebbe terminare il processo PHP senza eliminare i file temporanei caricati, altrimenti, questo sar√† anche un problema

Quindi, come puoi **far s√¨ che un include PHP non finisca mai**? Basta includere il file **`/sys/kernel/security/apparmor/revision`** (**non disponibile nei container Docker** purtroppo...).

Provalo semplicemente chiamando:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Per impostazione predefinita, Apache supporta **150 connessioni concorrenti**, seguendo [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) √® possibile aumentare questo numero fino a 8000. Segui questo per utilizzare PHP con quel modulo: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Per impostazione predefinita, (come posso vedere nei miei test), un **processo PHP pu√≤ durare eternamente**.

Facciamo un po' di conti:

* Possiamo utilizzare **149 connessioni** per generare **149 \* 20 = 2980 file temporanei** con il nostro webshell.
* Poi, usa la **ultima connessione** per **brute-forzare** file potenziali.
* A una velocit√† di **10 richieste/s** i tempi sono:
* 56800235584 / 2980 / 10 / 3600 \~= **530 ore** (50% di probabilit√† in 265h)
* (senza cifre) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% di probabilit√† in 93h)

{% hint style="warning" %}
Nota che nell'esempio precedente stiamo **completamente DoSando altri clienti**!
{% endhint %}

Se il server Apache √® migliorato e potessimo abusare di **4000 connessioni** (met√† del numero massimo). Potremmo creare `3999*20 = 79980` **file** e il **numero** sarebbe **ridotto** a circa **19.7h** o **6.9h** (10h, 3.5h 50% di probabilit√†).

## PHP-FMP

Se invece di utilizzare il modulo php regolare per apache per eseguire script PHP, la **pagina web sta utilizzando** **PHP-FMP** (questo migliora l'efficienza della pagina web, quindi √® comune trovarlo), c'√® qualcos'altro che pu√≤ essere fatto per migliorare la tecnica.

PHP-FMP consente di **configurare** il **parametro** **`request_terminate_timeout`** in **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Questo parametro indica la quantit√† massima di secondi **quando** **la richiesta a PHP deve terminare** (infinito per impostazione predefinita, ma **30s se il parametro √® decommentato**). Quando una richiesta viene elaborata da PHP per il numero di secondi indicato, viene **terminata**. Questo significa che, se la richiesta stava caricando file temporanei, poich√© il **processo PHP √® stato interrotto**, quei **file non verranno eliminati**. Pertanto, se riesci a far durare una richiesta quel tempo, puoi **generare migliaia di file temporanei** che non verranno eliminati, il che **accelerer√† il processo di trovarli** e riduce la probabilit√† di un DoS per la piattaforma consumando tutte le connessioni.

Quindi, per **evitare DoS**, supponiamo che un **attaccante utilizzer√† solo 100 connessioni** contemporaneamente e il tempo massimo di elaborazione PHP per **php-fmp** (`request_terminate_timeout`**)** √® **30s**. Pertanto, il numero di **file temporanei** che possono essere generati **al secondo** √® `100*20/30 = 66.67`.

Quindi, per generare **10000 file** un attaccante avrebbe bisogno di: **`10000/66.67 = 150s`** (per generare **100000 file** il tempo sarebbe **25min**).

Quindi, l'attaccante potrebbe utilizzare quelle **100 connessioni** per eseguire una **ricerca brute-force**. \*\*\*\* Supponendo una velocit√† di 300 req/s, il tempo necessario per sfruttare questo √® il seguente:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 ore** (50% di probabilit√† in 2.63h)
* (con 100000 file) 56800235584 / 100000 / 300 / 3600 \~= **0.525 ore** (50% di probabilit√† in 0.263h)

S√¨, √® possibile generare 100000 file temporanei in un'istanza EC2 di dimensioni medie:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Nota che per attivare il timeout sarebbe **sufficiente includere la pagina LFI vulnerabile**, in modo che entri in un ciclo di inclusione eterno.
{% endhint %}

## Nginx

Sembra che per impostazione predefinita Nginx supporti **512 connessioni parallele** contemporaneamente (e questo numero pu√≤ essere migliorato).

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
{% endhint %}
