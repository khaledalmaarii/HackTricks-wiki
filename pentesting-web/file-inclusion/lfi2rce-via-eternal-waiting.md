# LFI2RCE putem ve캜nog 캜ekanja

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Podrazumevano, kada se fajl otpremi na PHP (캜ak i ako se ne o캜ekuje), generisa캖e se privremeni fajl u `/tmp` sa imenom kao 코to je **`php[a-zA-Z0-9]{6}`**, iako sam video neke Docker slike gde generisani fajlovi ne sadr쬰 cifre.

U lokalnom uklju캜ivanju fajla, **ako uspete da uklju캜ite taj otpremljeni fajl, dobi캖ete RCE**.

Imajte na umu da podrazumevano **PHP dozvoljava samo otpremanje 20 fajlova u jednom zahtevu** (postavljeno u `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Tako캠e, **broj potencijalnih imena datoteka je 62\*62\*62\*62\*62\*62 = 56800235584**

### Ostale tehnike

Druge tehnike se oslanjaju na napade na PHP protokole (ne캖ete mo캖i ako kontroli코ete samo poslednji deo putanje), otkrivanje putanje datoteke, zloupotrebu o캜ekivanih datoteka ili **izazivanje segmentacijske gre코ke u PHP-u kako bi privremene datoteke koje su otpremljene nisu obrisane**.\
Ova tehnika je **vrlo sli캜na prethodnoj, ali ne zahteva pronala쬰nje nultog dana**.

### Tehnika ve캜nog 캜ekanja

U ovoj tehnici **samo trebamo kontrolisati relativnu putanju**. Ako uspemo da otpremimo datoteke i **LFI nikada ne zavr코i**, ima캖emo "dovoljno vremena" da **brute-force otpremljene datoteke** i **prona캠emo** bilo koju od njih.

**Prednosti ove tehnike**:

* Samo trebate kontrolisati relativnu putanju unutar include-a
* Ne zahteva nginx ili neo캜ekivan nivo pristupa log datotekama
* Ne zahteva nultu gre코ku da bi izazvala segmentacijsku gre코ku
* Ne zahteva otkrivanje putanje

**Glavni problemi** ove tehnike su:

* Potrebna je odre캠ena datoteka (mo쬰 ih biti vi코e)
* **Nevjerovatna** koli캜ina potencijalnih imena datoteka: **56800235584**
* Ako server **ne koristi cifre**, ukupna potencijalna koli캜ina je: **19770609664**
* Podrazumijevano se **samo 20 datoteka** mo쬰 otpremiti u **jednom zahtjevu**.
* **Maksimalan broj paralelnih radnika** kori코tenog servera.
* Ovo ograni캜enje zajedno sa prethodnim mo쬰 u캜initi da ovaj napad traje predugo
* **Vremensko ograni캜enje za PHP zahtjev**. Idealno bi bilo da je vje캜no ili da ubije PHP proces bez brisanja privremeno otpremljenih datoteka, ako to nije slu캜aj, i to 캖e biti problem

Dakle, kako mo쬰te **napraviti da PHP include nikada ne zavr코i**? Samo uklju캜ivanjem datoteke **`/sys/kernel/security/apparmor/revision`** (**na쬬lost, nije dostupno u Docker kontejnerima**).

Poku코ajte to samo pozivaju캖i:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Podrazumevano, Apache podr쬬va **150 istovremenih veza**, prema [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) mogu캖e je pove캖ati ovaj broj do 8000. Sledite ovo da biste koristili PHP sa tim modulom: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Podrazumevano, (kako sam primetio u svojim testovima), **PHP proces mo쬰 trajati ve캜no**.

Hajde da uradimo malo matematike:

* Mo쬰mo koristiti **149 veza** da generi코emo **149 \* 20 = 2980 privremenih fajlova** sa na코im webshell-om.
* Zatim, koristimo **poslednju vezu** da **brute-force** potencijalne fajlove.
* Pri brzini od **10 zahteva/s**, vreme je:
* 56800235584 / 2980 / 10 / 3600 \~= **530 sati** (50% 코anse u 265h)
* (bez cifara) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% 코anse u 93h)

{% hint style="warning" %}
Imajte na umu da u prethodnom primeru **potpuno DoS-ujemo druge klijente**!
{% endhint %}

Ako je Apache server pobolj코an i mo쬰mo zloupotrebiti **4000 veza** (polovina maksimalnog broja). Mogli bismo kreirati `3999*20 = 79980` **fajlova** i **broj** bi se **smanjio** na oko **19.7h** ili **6.9h** (10h, 3.5h 50% 코anse).

## PHP-FMP

Ako umesto kori코캖enja regularnog php moda za apache za pokretanje PHP skripti, **veb stranica koristi PHP-FMP** (코to pobolj코ava efikasnost veb stranice, pa je 캜esto prisutno), postoji ne코to drugo 코to se mo쬰 uraditi da se pobolj코a tehnika.

PHP-FMP omogu캖ava **konfigurisanje parametra** **`request_terminate_timeout`** u **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Ovaj parametar ozna캜ava maksimalan broj sekundi **kada** **zahtev ka PHP-u mora biti zavr코en** (podrazumevano je beskona캜no, ali **30s ako je parametar odkomentarisan**). Kada zahtev bude obra캠en od strane PHP-a u ozna캜enom broju sekundi, on 캖e biti **ubijen**. To zna캜i da ako je zahtev bio u procesu otpremanja privremenih fajlova, jer je **obrada PHP-a zaustavljena**, ti **fajlovi ne캖e biti obrisani**. Dakle, ako mo쬰te da produ쬴te trajanje zahteva na to vreme, mo쬰te **generisati hiljade privremenih fajlova** koji ne캖e biti obrisani, 코to 캖e **ubrzati proces pronala쬰nja** i smanjiti verovatno캖u DoS-a platforme konzumiranjem svih veza.

Dakle, da bismo **izbegli DoS**, pretpostavimo da 캖e **napada캜 koristiti samo 100 veza** istovremeno i maksimalno vreme obrade PHP-a od strane **php-fmp** (`request_terminate_timeout`**)** je **30s**. Dakle, broj **privremenih fajlova** koji mogu biti generisani **po sekundi** je `100*20/30 = 66.67`.

Zatim, da biste generisali **10000 fajlova**, napada캜u bi trebalo: **`10000/66.67 = 150s`** (da biste generisali **100000 fajlova**, vreme bi bilo **25 minuta**).

Zatim, napada캜 mo쬰 koristiti te **100 veza** da izvr코i **brute-force pretragu**. Pretpostavljaju캖i brzinu od 300 zahteva/s, vreme potrebno za iskori코캖avanje ovoga je slede캖e:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 sati** (50% 코anse u 2.63h)
* (sa 100000 fajlova) 56800235584 / 100000 / 300 / 3600 \~= **0.525 sati** (50% 코anse u 0.263h)

Da, mogu캖e je generisati 100000 privremenih fajlova na instanci srednje veli캜ine EC2:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Imajte na umu da bi bilo **dovoljno uklju캜iti ranjivu LFI stranicu** da biste pokrenuli prekora캜enje vremena, tako da u캠e u ve캜no uklju캜ivanje.
{% endhint %}

## Nginx

Izgleda da Nginx podrazumevano podr쬬va **512 paralelnih veza** istovremeno (i ovaj broj se mo쬰 pobolj코ati).
