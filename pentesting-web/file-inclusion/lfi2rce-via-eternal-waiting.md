# Sonsuz Bekleme ile LFI2RCE

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek** veya **HackTricks'i PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI'na**](https://github.com/sponsors/carlospolop) gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**'Ä± takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na **PR gÃ¶ndererek paylaÅŸÄ±n**.

</details>

## Temel Bilgiler

PHP'ye bir dosya yÃ¼klendiÄŸinde (beklemese bile), varsayÄ±lan olarak `/tmp` dizininde **`php[a-zA-Z0-9]{6}`** gibi bir isimle geÃ§ici bir dosya oluÅŸturulur. Ancak bazÄ± docker gÃ¶rÃ¼ntÃ¼lerinde oluÅŸturulan dosyalarÄ±n rakamlar iÃ§ermediÄŸini gÃ¶rdÃ¼m.

Yerel dosya dahilinde, **yÃ¼klÃ¼ dosyayÄ± dahil etmeyi baÅŸarÄ±rsanÄ±z RCE elde edersiniz**.

UnutmayÄ±n ki varsayÄ±lan olarak **PHP, tek bir istekte 20 dosya yÃ¼klemeye izin verir** (`/etc/php/<sÃ¼rÃ¼m>/apache2/php.ini`'de ayarlanÄ±r):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
AyrÄ±ca, potansiyel dosya adÄ± sayÄ±sÄ± 62\*62\*62\*62\*62\*62 = 56800235584'dir.

### DiÄŸer teknikler

DiÄŸer teknikler, PHP protokollerine saldÄ±rmayÄ± (yolu sadece son bÃ¶lÃ¼mÃ¼ kontrol ediyorsanÄ±z baÅŸaramazsÄ±nÄ±z), dosyanÄ±n yolunu ifÅŸa etmeyi, beklenen dosyalarÄ± kÃ¶tÃ¼ye kullanmayÄ± veya **PHP'yi bir segmentasyon hatasÄ±yla karÅŸÄ±laÅŸtÄ±rmayÄ± saÄŸlayarak yÃ¼klenen geÃ§ici dosyalarÄ±n silinmemesini saÄŸlamayÄ±** iÃ§erir.\
Bu teknik, **bir sÄ±fÄ±r gÃ¼n bulma gereksinimi olmadan** son teknikle Ã§ok benzerdir.

### Sonsuz bekleme tekniÄŸi

Bu teknikte, **yalnÄ±zca bir gÃ¶receli yol kontrol etmemiz gerekmektedir**. DosyalarÄ± yÃ¼klemeyi baÅŸarÄ±r ve **LFI hiÃ§ bitmezse**, yÃ¼klenen dosyalardan herhangi birini **brute-force** yaparak bulmak iÃ§in "yeterli zaman"Ä±mÄ±z olacaktÄ±r.

**Bu teknikle ilgili avantajlar**:

* Bir include iÃ§inde yalnÄ±zca bir gÃ¶receli yolu kontrol etmeniz yeterlidir
* Nginx veya beklenmeyen dÃ¼zeyde eriÅŸim log dosyalarÄ±na ihtiyaÃ§ duymaz
* Bir segmentasyon hatasÄ± oluÅŸturmak iÃ§in bir sÄ±fÄ±r gÃ¼n gerektirmez
* Bir yol ifÅŸasÄ± gerektirmez

Bu tekniklerin **ana sorunlarÄ±** ÅŸunlardÄ±r:

* Belirli bir dosyanÄ±n (daha fazla olabilir) mevcut olmasÄ± gerekmektedir
* **Ã‡Ä±lgÄ±nca** miktarda potansiyel dosya adÄ±: **56800235584**
* Sunucu **rakamlar kullanmÄ±yorsa** toplam potansiyel miktar: **19770609664**
* VarsayÄ±lan olarak **yalnÄ±zca 20 dosya**, **tek bir istekte** yÃ¼klenebilir.
* KullanÄ±lan sunucunun **eÅŸzamanlÄ± Ã§alÄ±ÅŸanlarÄ±n maksimum sayÄ±sÄ±**.
* Bu sÄ±nÄ±rlama, diÄŸerleriyle birlikte bu saldÄ±rÄ±nÄ±n Ã§ok uzun sÃ¼rmesine neden olabilir
* Bir PHP isteÄŸi iÃ§in **zaman aÅŸÄ±mÄ±**. Ä°deal olarak, bu sonsuz olmalÄ± veya PHP iÅŸlemini silmeden geÃ§ici yÃ¼klenen dosyalarÄ± silmelidir; aksi takdirde, bu da bir sorun olacaktÄ±r.

Peki, bir PHP include'Ä±nÄ± **asla bitmeyecek ÅŸekilde nasÄ±l yapabilirsiniz**? Sadece **`/sys/kernel/security/apparmor/revision`** dosyasÄ±nÄ± dahil ederek (**ne yazÄ±k ki Docker konteynerlerinde mevcut deÄŸil...**).

Bunu denemek iÃ§in sadece aÅŸaÄŸÄ±daki komutu Ã§aÄŸÄ±rÄ±n:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

VarsayÄ±lan olarak, Apache **150 eÅŸzamanlÄ± baÄŸlantÄ±yÄ±** destekler, [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) adresinde belirtildiÄŸi gibi bu sayÄ±yÄ± 8000'e kadar yÃ¼kseltmek mÃ¼mkÃ¼ndÃ¼r. PHP'yi bu modÃ¼lle kullanmak iÃ§in ÅŸu adÄ±mlarÄ± izleyin: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

VarsayÄ±lan olarak (testlerimde gÃ¶rdÃ¼ÄŸÃ¼m kadarÄ±yla), bir **PHP iÅŸlemi sonsuza kadar sÃ¼rebilir**.

Biraz matematik yapalÄ±m:

* **149 baÄŸlantÄ±yÄ±** web kabuÄŸumuzla birlikte **149 \* 20 = 2980 geÃ§ici dosya** oluÅŸturmak iÃ§in kullanabiliriz.
* ArdÄ±ndan, **son baÄŸlantÄ±yÄ±** potansiyel dosyalarÄ± **brute-force** etmek iÃ§in kullanÄ±n.
* **10 istek/s** hÄ±zÄ±nda zamanlar ÅŸunlardÄ±r:
* 56800235584 / 2980 / 10 / 3600 \~= **530 saat** (265 saatte %50 olasÄ±lÄ±k)
* (rakamlar olmadan) 19770609664 / 2980 / 10 / 3600 \~= 185 saat (93 saatte %50 olasÄ±lÄ±k)

{% hint style="warning" %}
Ã–nceki Ã¶rnekte **diÄŸer istemcileri tamamen DoS** ediyoruz!
{% endhint %}

EÄŸer Apache sunucusu iyileÅŸtirilirse ve **4000 baÄŸlantÄ±yÄ±** (maksimum sayÄ±nÄ±n yarÄ±sÄ±) kullanabilirsek, `3999*20 = 79980` **dosya** oluÅŸturabiliriz ve **sÃ¼re** yaklaÅŸÄ±k olarak **19.7 saat** veya **6.9 saat** (10 saat, 3.5 saatte %50 olasÄ±lÄ±k) azalÄ±r.

## PHP-FPM

EÄŸer web sayfasÄ± PHP betiklerini Ã§alÄ±ÅŸtÄ±rmak iÃ§in dÃ¼zenli php modu yerine **PHP-FPM** kullanÄ±yorsa (bu web sayfasÄ±nÄ±n verimliliÄŸini artÄ±rÄ±r, bu yÃ¼zden sÄ±kÃ§a karÅŸÄ±laÅŸÄ±lÄ±r), teknikleri iyileÅŸtirmek iÃ§in baÅŸka bir ÅŸey yapÄ±labilir.

PHP-FPM, **`/etc/php/<php-sÃ¼rÃ¼mÃ¼>/fpm/pool.d/www.conf`** yolunda **`request_terminate_timeout`** parametresini yapÄ±landÄ±rmaya izin verir.\
Bu parametre, PHP'ye yapÄ±lan isteÄŸin **sonlandÄ±rÄ±lmasÄ± gereken maksimum saniye sayÄ±sÄ±nÄ±** belirtir (varsayÄ±lan olarak sonsuz, ancak parametre yorum satÄ±rÄ± deÄŸilse **30 saniye**). Bir istek PHP tarafÄ±ndan iÅŸlenirken belirtilen saniye sayÄ±sÄ±na ulaÅŸÄ±rsa, **sonlandÄ±rÄ±lÄ±r**. Bu, istek geÃ§ici dosyalar yÃ¼kleniyorsa, Ã§Ã¼nkÃ¼ **php iÅŸlemi durduÄŸunda**, bu dosyalarÄ±n **silinmeyeceÄŸi** anlamÄ±na gelir. Bu nedenle, bir isteÄŸi bu sÃ¼re boyunca sÃ¼rdÃ¼rebilirseniz, **silinmeyecek binlerce geÃ§ici dosya** oluÅŸturabilirsiniz, bu da onlarÄ± bulma sÃ¼recini **hÄ±zlandÄ±rÄ±r** ve tÃ¼m baÄŸlantÄ±larÄ± tÃ¼keterek platforma bir DoS olasÄ±lÄ±ÄŸÄ±nÄ± azaltÄ±r.

Bu nedenle, bir **saldÄ±rganÄ±n aynÄ± anda yalnÄ±zca 100 baÄŸlantÄ±yÄ±** kullanacaÄŸÄ±nÄ± ve php-fpm tarafÄ±ndan belirlenen **php maksimum iÅŸlem sÃ¼resinin** (`request_terminate_timeout`**)** **30 saniye** olduÄŸunu varsayalÄ±m. Bu durumda, **saniye baÅŸÄ±na oluÅŸturulan geÃ§ici dosya** sayÄ±sÄ± `100*20/30 = 66.67` olur.

DolayÄ±sÄ±yla, bir saldÄ±rganÄ±n **10000 dosya** oluÅŸturmasÄ± iÃ§in gereken sÃ¼re: **`10000/66.67 = 150 saniye`** (100000 dosya oluÅŸturmak iÃ§in gereken sÃ¼re ise **25 dakika** olur).

SaldÄ±rgan, bu **100 baÄŸlantÄ±yÄ±** bir **arama brute-force** iÅŸlemi gerÃ§ekleÅŸtirmek iÃ§in kullanabilir. 300 istek/s hÄ±zÄ±nda Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± varsayarsak, bu iÅŸlemi gerÃ§ekleÅŸtirmek iÃ§in gereken sÃ¼re aÅŸaÄŸÄ±daki gibidir:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 saat** (2.63 saatte %50 olasÄ±lÄ±k)
* (100000 dosya ile) 56800235584 / 100000 / 300 / 3600 \~= **0.525 saat** (0.263 saatte %50 olasÄ±lÄ±k)

Evet, bir EC2 orta boyutlu Ã¶rnekte 100000 geÃ§ici dosya oluÅŸturmak mÃ¼mkÃ¼ndÃ¼r:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Zaman aÅŸÄ±mÄ±nÄ± tetiklemek iÃ§in yalnÄ±zca **kaynak kodu aÃ§Ä±k olan LFI sayfasÄ±nÄ± dahil etmek** yeterlidir, bÃ¶ylece sonsuz bir dahil dÃ¶ngÃ¼sÃ¼ne girer.
{% endhint %}

## Nginx

VarsayÄ±lan olarak, Nginx'in aynÄ± anda **512 paralel baÄŸlantÄ±yÄ±** desteklediÄŸi gÃ¶rÃ¼nÃ¼yor (ve bu sayÄ± iyileÅŸtirilebilir).
