# LFI2RCE via Eternal waiting

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** ğŸ’¬ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Standaard, wanneer 'n lÃªer na PHP opgelaai word (selfs al verwag dit nie), sal dit 'n tydelike lÃªer in `/tmp` genereer met 'n naam soos **`php[a-zA-Z0-9]{6}`**, alhoewel ek sommige docker beelde gesien het waar die gegenereerde lÃªers geen syfers bevat nie.

In 'n plaaslike lÃªerinvoeging, **as jy daarin slaag om daardie opgelaaide lÃªer in te sluit, sal jy RCE kry**.

Let daarop dat standaard **PHP slegs toelaat om 20 lÃªers in 'n enkele versoek op te laai** (gestel in `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Ook, die **aantal potensiÃ«le lÃªernames is 62\*62\*62\*62\*62\*62 = 56800235584**

### Ander tegnieke

Ander tegnieke berus op die aanval van PHP protokolle (jy sal nie in staat wees as jy net die laaste deel van die pad beheer nie), die pad van die lÃªer openbaar, die misbruik van verwagte lÃªers, of **maak PHP 'n segmentasiefout ly sodat opgelaaide tydelike lÃªers nie verwyder word nie**.\
Hierdie tegniek is **baie soortgelyk aan die laaste een, maar sonder om 'n nuldag te vind**.

### Ewige wag tegniek

In hierdie tegniek **het ons net 'n relatiewe pad nodig om te beheer**. As ons daarin slaag om lÃªers op te laai en die **LFI nooit te laat eindig nie**, sal ons "genoeg tyd" hÃª om **brute-force opgelaaide lÃªers** en **vind** enige van die opgelaaide.

**Voordele van hierdie tegniek**:

* Jy moet net 'n relatiewe pad binne 'n insluiting beheer
* Vereis nie nginx of 'n onverwagte vlak van toegang tot log lÃªers nie
* Vereis nie 'n 0 dag om 'n segmentasiefout te veroorsaak nie
* Vereis nie 'n pad openbaar nie

Die **hoofprobleme** van hierdie tegniek is:

* 'n Spesifieke lÃªer(s) moet teenwoordig wees (daar mag meer wees)
* Die **mal** hoeveelheid potensiÃ«le lÃªernames: **56800235584**
* As die bediener **nie syfers gebruik nie** is die totale potensiÃ«le hoeveelheid: **19770609664**
* Standaard kan **slegs 20 lÃªers** in 'n **enkele versoek** opgelaai word.
* Die **maksimum aantal parallelle werkers** van die gebruikte bediener.
* Hierdie limiet saam met die vorige kan hierdie aanval te lank laat duur
* **Tydsduur vir 'n PHP versoek**. Ideaal gesproke moet dit ewige wees of die PHP-proses moet doodgemaak word sonder om die tydelike opgelaaide lÃªers te verwyder, anders sal dit ook 'n pyn wees

So, hoe kan jy **maak dat 'n PHP insluiting nooit eindig nie**? Net deur die lÃªer **`/sys/kernel/security/apparmor/revision`** in te sluit (**nie beskikbaar in Docker houers** ongelukkig...). 

Probeer dit net deur te bel:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Standaard ondersteun Apache **150 gelyktydige verbindings**, volgens [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) is dit moontlik om hierdie getal tot 8000 te verhoog. Volg dit om PHP met daardie module te gebruik: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Standaard, (soos ek in my toetse kan sien), kan 'n **PHP-proses ewig duur**.

Kom ons doen 'n bietjie wiskunde:

* Ons kan **149 verbindings** gebruik om **149 \* 20 = 2980 tydelike lÃªers** met ons webshell te genereer.
* Dan, gebruik die **laaste verbinding** om **brute-force** potensiÃ«le lÃªers.
* Teen 'n spoed van **10 versoeke/s** is die tye:
* 56800235584 / 2980 / 10 / 3600 \~= **530 ure** (50% kans in 265h)
* (sonder syfers) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% kans in 93h)

{% hint style="warning" %}
Let daarop dat ons in die vorige voorbeeld **heeltemal ander kliÃ«nte DoSing**!
{% endhint %}

As die Apache-bediener verbeter word en ons **4000 verbindings** kan misbruik (halfpad na die maksimum getal). Ons kan `3999*20 = 79980` **lÃªers** skep en die **getal** sou **verminder** tot ongeveer **19.7h** of **6.9h** (10h, 3.5h 50% kans).

## PHP-FMP

As die **webblad** **PHP-FMP** gebruik in plaas van die gewone php-mod vir apache om PHP-skripte uit te voer (dit verbeter die doeltreffendheid van die webblad, so dit is algemeen om dit te vind), is daar iets anders wat gedoen kan word om die tegniek te verbeter.

PHP-FMP laat toe om die **parameter** **`request_terminate_timeout`** in **`/etc/php/<php-version>/fpm/pool.d/www.conf`** te **konfigureer**.\
Hierdie parameter dui die maksimum aantal sekondes aan **wanneer** **versoek aan PHP moet beÃ«indig** (oneindig per standaard, maar **30s as die param nie kommentaar is nie**). Wanneer 'n versoek deur PHP verwerk word, word die aangeduide aantal sekondes, dit **vermoor**. Dit beteken dat as die versoek tydelike lÃªers opgelaai het, omdat die **php-verwerking gestop is**, daardie **lÃªers nie verwyder gaan word nie**. Daarom, as jy 'n versoek kan laat duur vir daardie tyd, kan jy **duisende tydelike lÃªers genereer** wat nie verwyder sal word nie, wat die **proses om hulle te vind** versnel en die waarskynlikheid van 'n DoS op die platform verminder deur al die verbindings te verbruik.

So, om **DoS** te **vermy**, kom ons veronderstel dat 'n **aanvaller slegs 100 verbindings** terselfdertyd sal gebruik en die maksimum verwerkingstyd van php deur **php-fmp** (`request_terminate_timeout`**)** is **30s**. Daarom is die aantal **tydelike lÃªers** wat per sekonde gegenereer kan word **`100*20/30 = 66.67`**.

Dan, om **10000 lÃªers** te genereer, sal 'n aanvaller nodig hÃª: **`10000/66.67 = 150s`** (om **100000 lÃªers** te genereer, sal die tyd **25min** wees).

Dan kan die aanvaller daardie **100 verbindings** gebruik om 'n **soek brute-force** uit te voer. \*\*\*\* Veronderstel 'n spoed van 300 req/s, die tyd wat nodig is om dit te ontgin is die volgende:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 ure** (50% kans in 2.63h)
* (met 100000 lÃªers) 56800235584 / 100000 / 300 / 3600 \~= **0.525 ure** (50% kans in 0.263h)

Ja, dit is moontlik om 100000 tydelike lÃªers in 'n EC2 medium grootte instansie te genereer:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Let daarop dat dit voldoende sou wees om die kwesbare LFI-bladsy in te sluit om die tydsduur te aktiveer, sodat dit in 'n ewige insluitingslus ingaan.
{% endhint %}

## Nginx

Dit lyk of Nginx standaard **512 parallel verbindings** terselfdertyd ondersteun (en hierdie getal kan verbeter word).

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** ğŸ’¬ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
