# Sonsuz Bekleme Yoluyla LFI2RCE

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olmaya kadar AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**]'na (https://github.com/sponsors/carlospolop) gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n veya** bizi **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek HackTricks ve HackTricks Cloud github depolarÄ±na PR gÃ¶ndererek paylaÅŸÄ±n.**

</details>

## Temel Bilgiler

Bir dosya PHP'ye yÃ¼klendiÄŸinde (beklemese bile), **`php[a-zA-Z0-9]{6}`** gibi bir isme sahip geÃ§ici bir dosya oluÅŸturur `/tmp` iÃ§inde, ancak bazÄ± docker gÃ¶rÃ¼ntÃ¼lerinde oluÅŸturulan dosyalarÄ±n rakamlar iÃ§ermediÄŸini gÃ¶rdÃ¼m.

Yerel dosya dahilinde, **yÃ¼klÃ¼ dosyayÄ± dahil etmeyi baÅŸarÄ±rsanÄ±z RCE alÄ±rsÄ±nÄ±z**.

VarsayÄ±lan olarak **PHP yalnÄ±zca tek bir istekte 20 dosya yÃ¼klemeye izin verir** (ayarlanÄ±r `/etc/php/<sÃ¼rÃ¼m>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
### DiÄŸer teknikler

DiÄŸer teknikler, PHP protokollerine saldÄ±rarak (yolun sadece son kÄ±smÄ±nÄ± kontrol ediyorsanÄ±z baÅŸarÄ±lÄ± olamazsÄ±nÄ±z), dosyanÄ±n yolunu ifÅŸa ederek, beklenen dosyalarÄ± kÃ¶tÃ¼ye kullanarak veya **PHP'yi bir segmentasyon hatasÄ± yaÅŸatÄ±p yÃ¼klenen geÃ§ici dosyalarÄ±n silinmemesini saÄŸlayarak** Ã§alÄ±ÅŸÄ±r. Bu teknik, **bir sÄ±fÄ±r gÃ¼n bulmaya gerek olmadan** son teknikle Ã§ok benzerdir.

### Sonsuz bekleme tekniÄŸi

Bu teknikte **yalnÄ±zca gÃ¶receli bir yol kontrol etmemiz gerekir**. EÄŸer dosyalarÄ± yÃ¼klemeyi baÅŸarabilir ve **LFI'nin hiÃ§ bitmemesini saÄŸlarsak**, "yeterince zamanÄ±mÄ±z" olacak ve yÃ¼klenen dosyalardan **herhangi birini** **kaba kuvvet uygulayarak bulabileceÄŸiz**.

**Bu tekniÄŸin avantajlarÄ±**:

- Bir include iÃ§inde bir gÃ¶receli yol kontrol etmeniz yeterlidir
- Nginx veya log dosyalarÄ±na beklenmedik dÃ¼zeyde eriÅŸim gerektirmez
- Bir segmentasyon hatasÄ± oluÅŸturmak iÃ§in bir sÄ±fÄ±r gÃ¼n gerektirmez
- Bir yol ifÅŸasÄ± gerektirmez

Bu tekniÄŸin **ana sorunlarÄ±** ÅŸunlardÄ±r:

- Belirli bir dosyanÄ±n mevcut olmasÄ± gerekmektedir (daha fazla olabilir)
- **Potansiyel dosya adlarÄ± iÃ§in inanÄ±lmaz** bir miktar: **56800235584**
- Sunucu **rakamlar kullanmÄ±yorsa** toplam potansiyel miktar: **19770609664**
- VarsayÄ±lan olarak **yalnÄ±zca bir istekte 20 dosya** yÃ¼klenebilir.
- KullanÄ±lan sunucunun **maksimum eÅŸzamanlÄ± iÅŸÃ§i sayÄ±sÄ±**.
- Bu sÄ±nÄ±rlama ile birlikte bu saldÄ±rÄ±nÄ±n Ã§ok uzun sÃ¼rmesine neden olabilir
- **Bir PHP isteÄŸi iÃ§in zaman aÅŸÄ±mÄ±**. Ä°deal olarak bu sonsuz olmalÄ± veya PHP iÅŸlemini silmeden geÃ§ici yÃ¼klenen dosyalarÄ± silmelidir, aksi takdirde bu da bir sorun olacaktÄ±r

Peki, bir PHP include'Ä± **asla bitmeyecek ÅŸekilde nasÄ±l yapabilirsiniz**? Sadece **`/sys/kernel/security/apparmor/revision`** dosyasÄ±nÄ± dahil ederek. (**Ne yazÄ±k ki Docker konteynerlerinde mevcut deÄŸil...**).

Denemek iÃ§in sadece ÅŸunu Ã§aÄŸÄ±rÄ±n:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Apache, varsayÄ±lan olarak **150 eÅŸzamanlÄ± baÄŸlantÄ±yÄ±** destekler, [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) adresinde belirtildiÄŸi gibi bu sayÄ±yÄ± 8000'e kadar yÃ¼kseltmek mÃ¼mkÃ¼ndÃ¼r. Bu modÃ¼lle PHP kullanmak iÃ§in ÅŸu adÄ±mlarÄ± izleyin: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

VarsayÄ±lan olarak (testlerimde gÃ¶rdÃ¼ÄŸÃ¼m kadarÄ±yla), bir **PHP iÅŸlemi sonsuza kadar sÃ¼rebilir**.

Åimdi biraz matematik yapalÄ±m:

* **149 baÄŸlantÄ±** kullanarak **149 \* 20 = 2980 geÃ§ici dosya** oluÅŸturabiliriz.
* ArdÄ±ndan, **son baÄŸlantÄ±yÄ±** potansiyel dosyalarÄ± **brute-force** etmek iÃ§in kullanÄ±n.
* **10 istek/s** hÄ±zÄ±nda zamanlar ÅŸunlardÄ±r:
* 56800235584 / 2980 / 10 / 3600 \~= **530 saat** (265 saatte %50 olasÄ±lÄ±k)
* (ondalÄ±ksÄ±z) 19770609664 / 2980 / 10 / 3600 \~= 185 saat (93 saatte %50 olasÄ±lÄ±k)

{% hint style="warning" %}
Ã–nceki Ã¶rnekte **baÅŸka istemcileri tamamen DoS** ediyoruz!
{% endhint %}

EÄŸer Apache sunucusu geliÅŸtirilirse ve **4000 baÄŸlantÄ±yÄ±** (maksimum sayÄ±nÄ±n yarÄ±sÄ±) kullanabilirsek, `3999*20 = 79980` **dosya** oluÅŸturabilir ve **sayÄ±** yaklaÅŸÄ±k olarak **19.7 saat** veya **6.9 saat** (10 saat, 3.5 saat %50 olasÄ±lÄ±k) olur.

## PHP-FMP

EÄŸer web sayfasÄ± PHP betiklerini Ã§alÄ±ÅŸtÄ±rmak iÃ§in varsayÄ±lan php modunu deÄŸil de **PHP-FMP**'yi kullanÄ±yorsa (bu web sayfasÄ±nÄ±n verimliliÄŸini artÄ±rÄ±r, bu yÃ¼zden sÄ±kÃ§a karÅŸÄ±laÅŸÄ±lÄ±r), tekniÄŸi geliÅŸtirmek iÃ§in baÅŸka bir ÅŸey yapÄ±labilir.

PHP-FMP, **`/etc/php/<php-sÃ¼rÃ¼mÃ¼>/fpm/pool.d/www.conf`** iÃ§inde **`request_terminate_timeout`** parametresini **ayarlamaya izin verir**.\
Bu parametre, **PHP'ye yapÄ±lan isteÄŸin** **ne zaman sonlanmasÄ± gerektiÄŸini** belirtir (varsayÄ±lan olarak sonsuzdur, ancak **parametre yorumlanÄ±rsa 30 saniyedir**). Bir istek PHP tarafÄ±ndan iÅŸlenirken belirtilen saniye sayÄ±sÄ±na ulaÅŸtÄ±ÄŸÄ±nda, **sonlandÄ±rÄ±lÄ±r**. Bu, isteÄŸin geÃ§ici dosyalar yÃ¼klediÄŸi durumda, Ã§Ã¼nkÃ¼ **php iÅŸlemi durdurulduÄŸunda**, bu **dosyalarÄ±n silinmeyeceÄŸi** anlamÄ±na gelir. DolayÄ±sÄ±yla, bir isteÄŸi o sÃ¼re boyunca sÃ¼rdÃ¼rebilirseniz, silinmeyecek **binlerce geÃ§ici dosya oluÅŸturabilirsiniz**, bu da onlarÄ± bulma sÃ¼recini hÄ±zlandÄ±rÄ±r ve tÃ¼m baÄŸlantÄ±larÄ± tÃ¼keterek platforma DoS olasÄ±lÄ±ÄŸÄ±nÄ± azaltÄ±r.

Bu nedenle, **DoS'yi Ã¶nlemek** iÃ§in bir saldÄ±rganÄ±n aynÄ± anda yalnÄ±zca **100 baÄŸlantÄ±yÄ±** kullanacaÄŸÄ±nÄ± ve php-fmp tarafÄ±ndan belirlenen maksimum iÅŸlem sÃ¼resinin (`request_terminate_timeout`**)** **30 saniye** olduÄŸunu varsayalÄ±m. DolayÄ±sÄ±yla, saniyede oluÅŸturulabilecek **geÃ§ici dosya sayÄ±sÄ±** `100*20/30 = 66.67` olacaktÄ±r.

Sonra, **10000 dosya** oluÅŸturmak iÃ§in bir saldÄ±rganÄ±n ihtiyacÄ± olan sÃ¼re: **`10000/66.67 = 150 saniye`** (100000 dosya oluÅŸturmak iÃ§in gereken sÃ¼re ise **25 dakika** olacaktÄ±r).

ArdÄ±ndan, saldÄ±rgan bu **100 baÄŸlantÄ±yÄ±** kullanarak bir **arama brute-force** gerÃ§ekleÅŸtirebilir. **300 istek/s** hÄ±zÄ±nda Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± varsayarsak, bu saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in gereken sÃ¼re ÅŸÃ¶yledir:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 saat** (2.63 saatte %50 olasÄ±lÄ±k)
* (100000 dosya ile) 56800235584 / 100000 / 300 / 3600 \~= **0.525 saat** (0.263 saatte %50 olasÄ±lÄ±k)

Evet, bir EC2 orta boyutlu Ã¶rneÄŸinde 100000 geÃ§ici dosya oluÅŸturmak mÃ¼mkÃ¼ndÃ¼r:

<figure><img src="../../.gitbook/assets/image (237).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Zaman aÅŸÄ±mÄ±nÄ± tetiklemek iÃ§in **savunmasÄ±z LFI sayfasÄ±nÄ± iÃ§ermek yeterlidir**, bÃ¶ylece sonsuz bir dahil dÃ¶ngÃ¼ye girer.
{% endhint %}

## Nginx

VarsayÄ±lan olarak Nginx'in aynÄ± anda **512 paralel baÄŸlantÄ±yÄ±** desteklediÄŸi gÃ¶rÃ¼nÃ¼yor (bu sayÄ± artÄ±rÄ±labilir).
