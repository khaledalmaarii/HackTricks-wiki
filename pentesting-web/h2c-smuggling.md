# Upgrade Header Smuggling

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

- Travaillez-vous dans une **entreprise de cybersÃ©curitÃ©** ? Voulez-vous voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

### HTTP2 sur texte clair (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

Une connexion HTTP normale dure gÃ©nÃ©ralement seulement pendant la durÃ©e d'une seule requÃªte. Cependant, H2C ou "**http2 sur texte clair**" est lÃ  oÃ¹ une connexion http transitoire normale est mise Ã  niveau vers une connexion persistante qui utilise le protocole binaire http2 pour communiquer en continu au lieu d'une seule requÃªte en utilisant le protocole http en texte clair.

La deuxiÃ¨me partie de la contrebande se produit lorsqu'un **proxy inverse est utilisÃ©**. Normalement, lorsque des requÃªtes http sont effectuÃ©es vers un proxy inverse, le proxy gÃ¨re la requÃªte, traite une sÃ©rie de rÃ¨gles de routage, puis transfÃ¨re la requÃªte vers l'arriÃ¨re-plan et renvoie ensuite la rÃ©ponse. Lorsqu'une requÃªte http inclut un en-tÃªte `Connection: Upgrade`, comme pour une connexion websocket, le proxy inverse maintiendra la connexion persistante entre le client et le serveur, permettant la communication continue nÃ©cessaire pour ces protocoles. Pour une connexion H2C, le RFC exige que 3 en-tÃªtes soient prÃ©sents :
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
OÃ¹ se trouve la faille ? **Lors de la mise Ã  niveau d'une connexion, le proxy inverse cessera souvent de traiter les demandes individuelles**, en supposant que une fois la connexion Ã©tablie, son travail de routage est terminÃ©. En utilisant H2C Smuggling, nous pouvons contourner les rÃ¨gles qu'un proxy inverse utilise lors du traitement des demandes telles que le routage basÃ© sur le chemin, l'authentification ou le traitement WAF, Ã  condition que nous puissions Ã©tablir une connexion H2C en premier.

![](<../.gitbook/assets/image (454).png>)

### Proxies vulnÃ©rables <a href="#exploitation" id="exploitation"></a>

Notez dans l'explication de la vulnÃ©rabilitÃ© que le serveur proxy doit **transfÃ©rer l'en-tÃªte Upgrade**, et parfois l'en-tÃªte **Connection** doit Ã©galement Ãªtre transfÃ©rÃ© avec succÃ¨s.

Par dÃ©faut, les services suivants **transfÃ¨rent** les en-tÃªtes **Upgrade** et **Connection** lors de la transmission par proxy, permettant ainsi la contrebande h2c dÃ¨s la sortie de la boÃ®te :

* HAProxy
* Traefik
* Nuster

Par dÃ©faut, ces services ne transfÃ¨rent pas les en-tÃªtes Upgrade et Connection lors de la transmission par proxy, mais **peuvent Ãªtre configurÃ©s de maniÃ¨re non sÃ©curisÃ©e** (en passant des en-tÃªtes Upgrade et Connection non filtrÃ©s) :

* AWS ALB/CLB
* NGINX
* Apache
* Squid
* Varnish
* Kong
* Envoy
* Apache Traffic Server

### Exploitation <a href="#exploitation" id="exploitation"></a>

Le billet de blog original souligne que tous les serveurs ne transfÃ©reront pas les en-tÃªtes requis pour une mise Ã  niveau de connexion H2C conforme. Cela signifie que les Ã©quilibreurs de charge tels que AWS ALB/CLB, NGINX et Apache Traffic Server, entre autres, **empÃªcheront une connexion H2C par dÃ©faut**. Cependant, Ã  la fin du billet de blog, il mentionne que Â« tous les backends n'Ã©taient pas conformes, et nous pouvions **tester avec la variante non conforme `Connection: Upgrade`, oÃ¹ la valeur `HTTP2-Settings` est omise de l'en-tÃªte `Connection`** Â».

{% hint style="danger" %}
Notez que mÃªme si l'URL de `proxy_pass` (le point final vers lequel le proxy transfÃ¨re la connexion) pointait vers un **chemin** spÃ©cifique tel que `http://backend:9999/socket.io`, la connexion sera Ã©tablie avec `http://backend:9999`, vous pouvez donc **contacter tout autre chemin Ã  l'intÃ©rieur de ce point final interne en abusant de cette technique. Il n'est donc pas important qu'un chemin soit spÃ©cifiÃ© dans l'URL de proxy\_pass.**
{% endhint %}

En utilisant les outils [**https://github.com/BishopFox/h2csmuggler**](https://github.com/BishopFox/h2csmuggler) **et** [**https://github.com/assetnote/h2csmuggler**](https://github.com/assetnote/h2csmuggler), vous pouvez essayer de **contourner les protections imposÃ©es** par le proxy en Ã©tablissant une connexion H2C et accÃ©der aux ressources protÃ©gÃ©es par le proxy.

Suivez ce lien pour [**plus d'informations sur cette vulnÃ©rabilitÃ© dans Nginx**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection).

## Contrebande de WebSocket

Similaire Ã  la technique prÃ©cÃ©dente, celle-ci **au lieu de crÃ©er un tunnel HTTP2** vers un point final accessible via un proxy, elle crÃ©era un **tunnel WebSocket** Ã  la mÃªme fin, **contournant les limitations potentielles des proxies** et communiquant directement avec le point final :

![](<../.gitbook/assets/image (651) (2) (1).png>)

### ScÃ©nario 1

Nous avons un backend qui expose une **API WebSocket publique** et a Ã©galement une **API REST interne non disponible** de l'extÃ©rieur. Un client malveillant veut accÃ©der Ã  l'API REST interne.

Ã€ la **premiÃ¨re** Ã©tape, le client envoie une **demande de mise Ã  niveau** au proxy inverse, mais avec une **mauvaise version de protocole** dans l'en-tÃªte `Sec-WebSocket-Version`. Le **proxy** ne valide pas l'en-tÃªte `Sec-WebSocket-Version` et pense que la **demande de mise Ã  niveau est correcte**. Ensuite, il traduit la demande vers le backend.

Ã€ la deuxiÃ¨me Ã©tape, le backend envoie une **rÃ©ponse avec le code d'Ã©tat `426` car la version du protocole est incorrecte** dans l'en-tÃªte `Sec-WebSocket-Version`. Cependant, **le proxy inverse ne vÃ©rifie pas** suffisamment la rÃ©ponse du backend (y compris le code d'Ã©tat) et **pense que le backend est prÃªt pour la communication WebSocket**. Ensuite, il traduit la demande vers le client.

Enfin, le **proxy inverse pense** que la **connexion WebSocket est Ã©tablie entre le client et le backend**. En rÃ©alitÃ©, il n'y a pas de connexion WebSocket - le backend a refusÃ© la demande de mise Ã  niveau. En mÃªme temps, le proxy inverse maintient la connexion TCP ou TLS entre le client et le backend en Ã©tat ouvert. **Le client peut facilement accÃ©der Ã  l'API REST privÃ©e en envoyant une requÃªte HTTP sur la connexion.**

![](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

Il a Ã©tÃ© constatÃ© que les reverse proxies suivants sont affectÃ©s :

* Varnish - l'Ã©quipe a refusÃ© de corriger le problÃ¨me dÃ©crit.
* Envoy proxy 1.8.0 (ou plus ancien) - dans les versions plus rÃ©centes, le mÃ©canisme de mise Ã  niveau a Ã©tÃ© modifiÃ©.
* Autres - Ã€ dÃ©terminer.

### ScÃ©nario 2

La majoritÃ© des reverse proxies (par exemple NGINX) **vÃ©rifient le code d'Ã©tat du backend** pendant la partie de poignÃ©e de main. Cela rend l'attaque plus difficile mais pas impossible.

Observons le deuxiÃ¨me scÃ©nario. Nous avons un backend qui expose une API WebSocket publique et une API REST publique pour la vÃ©rification de l'Ã©tat de santÃ© et a Ã©galement une **API REST interne non disponible** de l'extÃ©rieur. Un client malveillant veut accÃ©der Ã  l'API REST interne. NGINX est utilisÃ© comme proxy inverse. L'API WebSocket est disponible sur le chemin `/api/socket.io/` et l'API de vÃ©rification de l'Ã©tat de santÃ© sur le chemin `/api/health`.

L'API de vÃ©rification de l'Ã©tat de santÃ© est invoquÃ©e en envoyant une requÃªte POST, le paramÃ¨tre portant le nom `u` contrÃ´le l'URL. Le backend atteint la ressource externe et renvoie le code d'Ã©tat au client.

Ã€ la **premiÃ¨re** Ã©tape, le client envoie une requÃªte POST pour invoquer **l'API de vÃ©rification de l'Ã©tat de santÃ© mais avec un en-tÃªte HTTP supplÃ©mentaire `Upgrade: websocket`**. NGINX pense qu'il s'agit d'une **demande de mise Ã  niveau normale**, il ne recherche que l'en-tÃªte `Upgrade` en ignorant les autres parties de la demande. Ensuite, le proxy traduit la demande vers le backend.

Ã€ la **deuxiÃ¨me** Ã©tape, le backend invoque l'API de vÃ©rification de l'Ã©tat de santÃ©. Il atteint la ressource externe contrÃ´lÃ©e par des utilisateurs malveillants qui renvoie une **rÃ©ponse HTTP avec le code d'Ã©tat `101
