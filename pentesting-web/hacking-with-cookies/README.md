# Cookies Hacking

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}


## Cookie Attributes

Les cookies poss√®dent plusieurs attributs qui contr√¥lent leur comportement dans le navigateur de l'utilisateur. Voici un aper√ßu de ces attributs dans une voix plus passive :

### Expires et Max-Age

La date d'expiration d'un cookie est d√©termin√©e par l'attribut `Expires`. √Ä l'inverse, l'attribut `Max-age` d√©finit le temps en secondes jusqu'√† ce qu'un cookie soit supprim√©. **Optez pour `Max-age` car il refl√®te des pratiques plus modernes.**

### Domain

Les h√¥tes qui re√ßoivent un cookie sont sp√©cifi√©s par l'attribut `Domain`. Par d√©faut, cela est d√©fini sur l'h√¥te qui a √©mis le cookie, sans inclure ses sous-domaines. Cependant, lorsque l'attribut `Domain` est explicitement d√©fini, il englobe √©galement les sous-domaines. Cela rend la sp√©cification de l'attribut `Domain` une option moins restrictive, utile dans les sc√©narios o√π le partage de cookies entre sous-domaines est n√©cessaire. Par exemple, d√©finir `Domain=mozilla.org` rend les cookies accessibles sur ses sous-domaines comme `developer.mozilla.org`.

### Path

Un chemin d'URL sp√©cifique qui doit √™tre pr√©sent dans l'URL demand√©e pour que l'en-t√™te `Cookie` soit envoy√© est indiqu√© par l'attribut `Path`. Cet attribut consid√®re le caract√®re `/` comme un s√©parateur de r√©pertoire, permettant des correspondances dans les sous-r√©pertoires √©galement.

### Ordering Rules

Lorsque deux cookies portent le m√™me nom, celui choisi pour l'envoi est bas√© sur :

* Le cookie correspondant au chemin le plus long dans l'URL demand√©e.
* Le cookie le plus r√©cemment d√©fini si les chemins sont identiques.

### SameSite

* L'attribut `SameSite` dicte si les cookies sont envoy√©s lors de requ√™tes provenant de domaines tiers. Il offre trois param√®tres :
* **Strict** : Restreint l'envoi du cookie lors de requ√™tes tierces.
* **Lax** : Permet l'envoi du cookie avec des requ√™tes GET initi√©es par des sites web tiers.
* **None** : Permet l'envoi du cookie depuis n'importe quel domaine tiers.

N'oubliez pas, lors de la configuration des cookies, que comprendre ces attributs peut aider √† garantir qu'ils se comportent comme pr√©vu dans diff√©rents sc√©narios.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
Un cookie avec l'attribut _**SameSite**_ **att√©nuera les attaques CSRF** o√π une session connect√©e est n√©cessaire.

**\*Notez qu'√† partir de Chrome80 (f√©vrier 2019), le comportement par d√©faut d'un cookie sans attribut SameSite** **sera lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Notez qu'apr√®s avoir appliqu√© ce changement, les **cookies sans politique SameSite** dans Chrome seront **trait√©s comme None** pendant les **2 premi√®res minutes, puis comme Lax pour les requ√™tes POST intersites de niveau sup√©rieur.**

## Cookies Flags

### HttpOnly

Cela emp√™che le **client** d'acc√©der au cookie (via **Javascript**, par exemple : `document.cookie`)

#### **Bypasses**

* Si la page **envoie les cookies en r√©ponse** √† des requ√™tes (par exemple dans une page **PHPinfo**), il est possible d'abuser de l'XSS pour envoyer une requ√™te √† cette page et **voler les cookies** de la r√©ponse (voir un exemple sur [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
* Cela pourrait √™tre contourn√© avec des requ√™tes **TRACE** **HTTP** car la r√©ponse du serveur (si cette m√©thode HTTP est disponible) refl√©tera les cookies envoy√©s. Cette technique est appel√©e **Cross-Site Tracking**.
* Cette technique est √©vit√©e par **les navigateurs modernes en ne permettant pas l'envoi d'une requ√™te TRACE** depuis JS. Cependant, certains contournements ont √©t√© trouv√©s dans des logiciels sp√©cifiques comme l'envoi de `\r\nTRACE` au lieu de `TRACE` √† IE6.0 SP2.
* Une autre fa√ßon est l'exploitation de vuln√©rabilit√©s zero-day des navigateurs.
* Il est possible de **surcharger les cookies HttpOnly** en effectuant une attaque de d√©bordement de Cookie Jar :

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Il est possible d'utiliser l'attaque [**Cookie Smuggling**](./#cookie-smuggling) pour exfiltrer ces cookies

### Secure

La requ√™te **n'enverra** le cookie que dans une requ√™te HTTP si la requ√™te est transmise par un canal s√©curis√© (typiquement **HTTPS**).

## Cookies Prefixes

Les cookies pr√©fix√©s par `__Secure-` doivent √™tre d√©finis avec le drapeau `secure` des pages s√©curis√©es par HTTPS.

Pour les cookies pr√©fix√©s par `__Host-`, plusieurs conditions doivent √™tre remplies :

* Ils doivent √™tre d√©finis avec le drapeau `secure`.
* Ils doivent provenir d'une page s√©curis√©e par HTTPS.
* Ils sont interdits de sp√©cifier un domaine, emp√™chant leur transmission aux sous-domaines.
* Le chemin pour ces cookies doit √™tre d√©fini sur `/`.

Il est important de noter que les cookies pr√©fix√©s par `__Host-` ne sont pas autoris√©s √† √™tre envoy√©s √† des superdomaines ou sous-domaines. Cette restriction aide √† isoler les cookies d'application. Ainsi, utiliser le pr√©fixe `__Host-` pour tous les cookies d'application peut √™tre consid√©r√© comme une bonne pratique pour am√©liorer la s√©curit√© et l'isolation.

### Overwriting cookies

Ainsi, l'une des protections des cookies pr√©fix√©s par `__Host-` est d'emp√™cher leur √©crasement depuis des sous-domaines. Pr√©venir par exemple les [**attaques de Cookie Tossing**](cookie-tossing.md). Dans la pr√©sentation [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F\_wAzF4a7Xg) ([**papier**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)), il est pr√©sent√© qu'il √©tait possible de d√©finir des cookies pr√©fix√©s par \_\_HOST- depuis un sous-domaine, en trompant le parseur, par exemple, en ajoutant "=" au d√©but ou √† la fin... :

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

Ou en PHP, il √©tait possible d'ajouter **d'autres caract√®res au d√©but** du nom du cookie qui allaient √™tre **remplac√©s par des caract√®res de soulignement**, permettant d'√©craser les cookies `__HOST-` :

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Cookies Attacks

Si un cookie personnalis√© contient des donn√©es sensibles, v√©rifiez-le (surtout si vous participez √† un CTF), car il pourrait √™tre vuln√©rable.

### Decoding and Manipulating Cookies

Les donn√©es sensibles int√©gr√©es dans les cookies doivent toujours √™tre examin√©es. Les cookies encod√©s en Base64 ou dans des formats similaires peuvent souvent √™tre d√©cod√©s. Cette vuln√©rabilit√© permet aux attaquants de modifier le contenu du cookie et d'usurper d'autres utilisateurs en r√©encodant leurs donn√©es modifi√©es dans le cookie.

### Session Hijacking

Cette attaque consiste √† voler le cookie d'un utilisateur pour obtenir un acc√®s non autoris√© √† son compte dans une application. En utilisant le cookie vol√©, un attaquant peut usurper l'utilisateur l√©gitime.

### Session Fixation

Dans ce sc√©nario, un attaquant trompe une victime pour qu'elle utilise un cookie sp√©cifique pour se connecter. Si l'application n'attribue pas un nouveau cookie lors de la connexion, l'attaquant, poss√©dant le cookie d'origine, peut usurper la victime. Cette technique repose sur le fait que la victime se connecte avec un cookie fourni par l'attaquant.

Si vous avez trouv√© un **XSS dans un sous-domaine** ou si vous **contr√¥lez un sous-domaine**, lisez :

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Session Donation

Ici, l'attaquant convainc la victime d'utiliser le cookie de session de l'attaquant. La victime, croyant qu'elle est connect√©e √† son propre compte, effectuera involontairement des actions dans le contexte du compte de l'attaquant.

Si vous avez trouv√© un **XSS dans un sous-domaine** ou si vous **contr√¥lez un sous-domaine**, lisez :

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Cliquez sur le lien pr√©c√©dent pour acc√©der √† une page expliquant les d√©fauts possibles dans JWT.

Les JSON Web Tokens (JWT) utilis√©s dans les cookies peuvent √©galement pr√©senter des vuln√©rabilit√©s. Pour des informations approfondies sur les d√©fauts potentiels et comment les exploiter, il est recommand√© d'acc√©der au document li√© sur le hacking JWT.

### Cross-Site Request Forgery (CSRF)

Cette attaque force un utilisateur connect√© √† ex√©cuter des actions non d√©sir√©es sur une application web dans laquelle il est actuellement authentifi√©. Les attaquants peuvent exploiter les cookies qui sont automatiquement envoy√©s avec chaque requ√™te vers le site vuln√©rable.

### Empty Cookies

(V√©rifiez plus de d√©tails dans la [recherche originale](https://blog.ankursundara.com/cookie-bugs/)) Les navigateurs permettent la cr√©ation de cookies sans nom, ce qui peut √™tre d√©montr√© par JavaScript comme suit :
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Le r√©sultat dans l'en-t√™te de cookie envoy√© est `a=v1; test value; b=v2;`. Intriguement, cela permet la manipulation des cookies si un cookie avec un nom vide est d√©fini, contr√¥lant potentiellement d'autres cookies en d√©finissant le cookie vide √† une valeur sp√©cifique :
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
Cela conduit le navigateur √† envoyer un en-t√™te de cookie interpr√©t√© par chaque serveur web comme un cookie nomm√© `a` avec une valeur `b`.

#### Bug Chrome : Probl√®me de Codepoint de Surrogate Unicode

Dans Chrome, si un codepoint de surrogate Unicode fait partie d'un cookie d√©fini, `document.cookie` devient corrompu, renvoyant une cha√Æne vide par la suite :
```js
document.cookie = "\ud800=meep";
```
Cela entra√Æne que `document.cookie` renvoie une cha√Æne vide, indiquant une corruption permanente.

#### Cookie Smuggling en raison de probl√®mes de parsing

(Voir plus de d√©tails dans la [recherche originale](https://blog.ankursundara.com/cookie-bugs/)) Plusieurs serveurs web, y compris ceux de Java (Jetty, TomCat, Undertow) et Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), g√®rent mal les cha√Ænes de cookies en raison d'un support obsol√®te de RFC2965. Ils lisent une valeur de cookie entre guillemets comme une seule valeur m√™me si elle inclut des points-virgules, qui devraient normalement s√©parer les paires cl√©-valeur :
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Vuln√©rabilit√©s d'injection de cookies

(Voir plus de d√©tails dans la [recherche originale](https://blog.ankursundara.com/cookie-bugs/)) Le parsing incorrect des cookies par les serveurs, notamment Undertow, Zope, et ceux utilisant `http.cookie.SimpleCookie` et `http.cookie.BaseCookie` de Python, cr√©e des opportunit√©s pour des attaques par injection de cookies. Ces serveurs ne parviennent pas √† d√©limiter correctement le d√©but de nouveaux cookies, permettant aux attaquants de falsifier des cookies :

* Undertow s'attend √† un nouveau cookie imm√©diatement apr√®s une valeur entre guillemets sans point-virgule.
* Zope recherche une virgule pour commencer √† parser le cookie suivant.
* Les classes de cookies de Python commencent √† parser sur un caract√®re d'espace.

Cette vuln√©rabilit√© est particuli√®rement dangereuse dans les applications web s'appuyant sur une protection CSRF bas√©e sur des cookies, car elle permet aux attaquants d'injecter des cookies de token CSRF falsifi√©s, contournant potentiellement les mesures de s√©curit√©. Le probl√®me est aggrav√© par la gestion des noms de cookies en double par Python, o√π la derni√®re occurrence remplace les pr√©c√©dentes. Cela soul√®ve √©galement des pr√©occupations pour les cookies `__Secure-` et `__Host-` dans des contextes non s√©curis√©s et pourrait entra√Æner des contournements d'autorisation lorsque des cookies sont transmis √† des serveurs back-end susceptibles de falsification.

### V√©rifications suppl√©mentaires des cookies vuln√©rables

#### **V√©rifications de base**

* Le **cookie** est le **m√™me** chaque fois que vous **vous connectez**.
* D√©connectez-vous et essayez d'utiliser le m√™me cookie.
* Essayez de vous connecter avec 2 appareils (ou navigateurs) au m√™me compte en utilisant le m√™me cookie.
* V√©rifiez si le cookie contient des informations et essayez de le modifier.
* Essayez de cr√©er plusieurs comptes avec des noms d'utilisateur presque identiques et v√©rifiez si vous pouvez voir des similitudes.
* V√©rifiez l'option "**se souvenir de moi**" si elle existe pour voir comment elle fonctionne. Si elle existe et pourrait √™tre vuln√©rable, utilisez toujours le cookie de **se souvenir de moi** sans aucun autre cookie.
* V√©rifiez si le cookie pr√©c√©dent fonctionne m√™me apr√®s avoir chang√© le mot de passe.

#### **Attaques avanc√©es sur les cookies**

Si le cookie reste le m√™me (ou presque) lorsque vous vous connectez, cela signifie probablement que le cookie est li√© √† un champ de votre compte (probablement le nom d'utilisateur). Ensuite, vous pouvez :

* Essayer de cr√©er beaucoup de **comptes** avec des noms d'utilisateur tr√®s **similaires** et essayer de **deviner** comment l'algorithme fonctionne.
* Essayer de **bruteforcer le nom d'utilisateur**. Si le cookie est uniquement enregistr√© comme m√©thode d'authentification pour votre nom d'utilisateur, alors vous pouvez cr√©er un compte avec le nom d'utilisateur "**Bmin**" et **bruteforcer** chaque **bit** de votre cookie car l'un des cookies que vous allez essayer sera celui appartenant √† "**admin**".
* Essayer **Padding** **Oracle** (vous pouvez d√©chiffrer le contenu du cookie). Utilisez **padbuster**.

**Padding Oracle - Exemples de Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster fera plusieurs tentatives et vous demandera quelle condition est la condition d'erreur (celle qui n'est pas valide).

Ensuite, il commencera √† d√©chiffrer le cookie (cela peut prendre plusieurs minutes)

Si l'attaque a √©t√© r√©alis√©e avec succ√®s, vous pourriez essayer de chiffrer une cha√Æne de votre choix. Par exemple, si vous souhaitez **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Cette ex√©cution vous donnera le cookie correctement chiffr√© et encod√© avec la cha√Æne **user=administrator** √† l'int√©rieur.

**CBC-MAC**

Peut-√™tre qu'un cookie pourrait avoir une certaine valeur et pourrait √™tre sign√© en utilisant CBC. Ensuite, l'int√©grit√© de la valeur est la signature cr√©√©e en utilisant CBC avec la m√™me valeur. Comme il est recommand√© d'utiliser comme IV un vecteur nul, ce type de v√©rification d'int√©grit√© pourrait √™tre vuln√©rable.

**L'attaque**

1. Obtenez la signature du nom d'utilisateur **administ** = **t**
2. Obtenez la signature du nom d'utilisateur **rator\x00\x00\x00 XOR t** = **t'**
3. Mettez dans le cookie la valeur **administrator+t'** (**t'** sera une signature valide de **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Si le cookie est chiffr√© en utilisant ECB, il pourrait √™tre vuln√©rable.\
Lorsque vous vous connectez, le cookie que vous recevez doit toujours √™tre le m√™me.

**Comment d√©tecter et attaquer :**

Cr√©ez 2 utilisateurs avec presque les m√™mes donn√©es (nom d'utilisateur, mot de passe, e-mail, etc.) et essayez de d√©couvrir un certain motif √† l'int√©rieur du cookie donn√©.

Cr√©ez un utilisateur appel√© par exemple "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" et v√©rifiez s'il y a un motif dans le cookie (comme ECB chiffre avec la m√™me cl√© chaque bloc, les m√™mes octets chiffr√©s pourraient appara√Ætre si le nom d'utilisateur est chiffr√©).

Il devrait y avoir un motif (avec la taille d'un bloc utilis√©). Donc, sachant comment un tas de "a" est chiffr√©, vous pouvez cr√©er un nom d'utilisateur : "a"\*(taille du bloc)+"admin". Ensuite, vous pourriez supprimer le motif chiffr√© d'un bloc de "a" du cookie. Et vous aurez le cookie du nom d'utilisateur "admin".

## R√©f√©rences

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)


{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* V√©rifiez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
