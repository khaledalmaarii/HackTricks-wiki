# Cookies Hacking

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}


## Cookie-Attribute

Cookies verf√ºgen √ºber mehrere Attribute, die ihr Verhalten im Browser des Benutzers steuern. Hier ist eine √úbersicht √ºber diese Attribute in einer passiveren Stimme:

### Expires und Max-Age

Das Ablaufdatum eines Cookies wird durch das `Expires`-Attribut bestimmt. Umgekehrt definiert das `Max-age`-Attribut die Zeit in Sekunden, bis ein Cookie gel√∂scht wird. **Bevorzuge `Max-age`, da es modernere Praktiken widerspiegelt.**

### Domain

Die Hosts, die ein Cookie empfangen sollen, werden durch das `Domain`-Attribut festgelegt. Standardm√§√üig ist dies auf den Host eingestellt, der das Cookie ausgegeben hat, ohne seine Subdomains einzuschlie√üen. Wenn das `Domain`-Attribut jedoch ausdr√ºcklich festgelegt wird, umfasst es auch Subdomains. Dies macht die Spezifikation des `Domain`-Attributs zu einer weniger restriktiven Option, die n√ºtzlich ist, wenn das Teilen von Cookies √ºber Subdomains erforderlich ist. Zum Beispiel macht die Einstellung `Domain=mozilla.org` Cookies auf seinen Subdomains wie `developer.mozilla.org` zug√§nglich.

### Path

Ein spezifischer URL-Pfad, der in der angeforderten URL vorhanden sein muss, damit der `Cookie`-Header gesendet wird, wird durch das `Path`-Attribut angezeigt. Dieses Attribut betrachtet das `/`-Zeichen als Verzeichnistrenner, was auch √úbereinstimmungen in Unterverzeichnissen erm√∂glicht.

### Reihenfolge-Regeln

Wenn zwei Cookies denselben Namen tragen, wird dasjenige, das zum Senden ausgew√§hlt wird, basierend auf:

* Dem Cookie, das den l√§ngsten Pfad in der angeforderten URL √ºbereinstimmt.
* Dem zuletzt gesetzten Cookie, wenn die Pfade identisch sind.

### SameSite

* Das `SameSite`-Attribut bestimmt, ob Cookies bei Anfragen von Drittanbieter-Domains gesendet werden. Es bietet drei Einstellungen:
* **Strict**: Beschr√§nkt das Cookie, um bei Anfragen von Drittanbietern gesendet zu werden.
* **Lax**: Erlaubt das Senden des Cookies mit GET-Anfragen, die von Drittanbieter-Websites initiiert werden.
* **None**: Erlaubt das Senden des Cookies von jeder Drittanbieter-Domain.

Denke daran, dass das Verst√§ndnis dieser Attribute bei der Konfiguration von Cookies helfen kann, um sicherzustellen, dass sie in verschiedenen Szenarien wie erwartet funktionieren.

| **Anfragetyp**   | **Beispielcode**                   | **Cookies werden gesendet, wenn** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Bild             | \<img src="...">                   | NetSet\*, None        |

Tabelle von [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) und leicht modifiziert.\
Ein Cookie mit _**SameSite**_ Attribut wird **CSRF-Angriffe mildern**, bei denen eine angemeldete Sitzung erforderlich ist.

**\*Beachte, dass ab Chrome80 (Februar 2019) das Standardverhalten eines Cookies ohne ein Cookie SameSite** **Attribut lax** sein wird ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Beachte, dass vor√ºbergehend, nach Anwendung dieser √Ñnderung, die **Cookies ohne eine SameSite** **Richtlinie** in Chrome **w√§hrend der ersten 2 Minuten als None** behandelt werden und dann als Lax f√ºr die oberste Ebene der Cross-Site-POST-Anfrage.

## Cookies-Flags

### HttpOnly

Dies verhindert, dass der **Client** auf das Cookie zugreift (zum Beispiel √ºber **Javascript**: `document.cookie`)

#### **Umgehungen**

* Wenn die Seite **die Cookies als Antwort** auf eine Anfrage sendet (zum Beispiel auf einer **PHPinfo**-Seite), ist es m√∂glich, XSS auszunutzen, um eine Anfrage an diese Seite zu senden und **die Cookies** aus der Antwort zu **stehlen** (siehe ein Beispiel unter [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Dies k√∂nnte mit **TRACE** **HTTP**-Anfragen umgangen werden, da die Antwort des Servers (wenn diese HTTP-Methode verf√ºgbar ist) die gesendeten Cookies widerspiegelt. Diese Technik wird als **Cross-Site Tracking** bezeichnet.
* Diese Technik wird von **modernen Browsern vermieden, indem das Senden einer TRACE**-Anfrage von JS nicht erlaubt wird. Einige Umgehungen daf√ºr wurden jedoch in spezifischer Software gefunden, wie das Senden von `\r\nTRACE` anstelle von `TRACE` an IE6.0 SP2.
* Eine andere M√∂glichkeit ist die Ausnutzung von Zero-Day-Sicherheitsanf√§lligkeiten der Browser.
* Es ist m√∂glich, **HttpOnly-Cookies** durch einen Cookie-Jar-Overflow-Angriff zu **√ºberschreiben**:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Es ist m√∂glich, den [**Cookie Smuggling**](./#cookie-smuggling) Angriff zu verwenden, um diese Cookies zu exfiltrieren.

### Secure

Die Anfrage sendet das Cookie **nur**, wenn die Anfrage √ºber einen sicheren Kanal (typischerweise **HTTPS**) √ºbertragen wird.

## Cookies-Pr√§fixe

Cookies, die mit `__Secure-` beginnen, m√ºssen zusammen mit dem `secure`-Flag von Seiten gesetzt werden, die durch HTTPS gesichert sind.

F√ºr Cookies, die mit `__Host-` beginnen, m√ºssen mehrere Bedingungen erf√ºllt sein:

* Sie m√ºssen mit dem `secure`-Flag gesetzt werden.
* Sie m√ºssen von einer Seite stammen, die durch HTTPS gesichert ist.
* Es ist verboten, eine Domain anzugeben, was ihre √úbertragung an Subdomains verhindert.
* Der Pfad f√ºr diese Cookies muss auf `/` gesetzt werden.

Es ist wichtig zu beachten, dass Cookies, die mit `__Host-` beginnen, nicht an Superdomains oder Subdomains gesendet werden d√ºrfen. Diese Einschr√§nkung hilft, Anwendungscookies zu isolieren. Daher kann die Verwendung des `__Host-`-Pr√§fixes f√ºr alle Anwendungscookies als gute Praxis zur Verbesserung der Sicherheit und Isolation angesehen werden.

### √úberschreiben von Cookies

Eine der Schutzma√ünahmen von `__Host-`-pr√§fixierten Cookies besteht darin, sie daran zu hindern, von Subdomains √ºberschrieben zu werden. Dies verhindert beispielsweise [**Cookie Tossing-Angriffe**](cookie-tossing.md). In dem Vortrag [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F\_wAzF4a7Xg) ([**Paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) wird pr√§sentiert, dass es m√∂glich war, \_\_HOST- pr√§fixierte Cookies von einer Subdomain zu setzen, indem man den Parser t√§uschte, zum Beispiel, indem man "=" am Anfang oder am Ende hinzuf√ºgte...:

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

Oder in PHP war es m√∂glich, **andere Zeichen am Anfang** des Cookie-Namens hinzuzuf√ºgen, die durch Unterstriche **ersetzt** werden sollten, was es erm√∂glichte, `__HOST-` Cookies zu √ºberschreiben:

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Cookies-Angriffe

Wenn ein benutzerdefiniertes Cookie sensible Daten enth√§lt, √ºberpr√ºfe es (insbesondere wenn du an einem CTF teilnimmst), da es anf√§llig sein k√∂nnte.

### Dekodierung und Manipulation von Cookies

Sensible Daten, die in Cookies eingebettet sind, sollten immer √ºberpr√ºft werden. Cookies, die in Base64 oder √§hnlichen Formaten kodiert sind, k√∂nnen oft dekodiert werden. Diese Sicherheitsanf√§lligkeit erm√∂glicht es Angreifern, den Inhalt des Cookies zu √§ndern und sich als andere Benutzer auszugeben, indem sie ihre modifizierten Daten wieder in das Cookie kodieren.

### Sitzungs√ºbernahme

Dieser Angriff besteht darin, das Cookie eines Benutzers zu stehlen, um unbefugten Zugriff auf dessen Konto innerhalb einer Anwendung zu erlangen. Durch die Verwendung des gestohlenen Cookies kann ein Angreifer den legitimen Benutzer imitieren.

### Sitzungsfixierung

In diesem Szenario bringt ein Angreifer ein Opfer dazu, ein bestimmtes Cookie zum Anmelden zu verwenden. Wenn die Anwendung beim Anmelden kein neues Cookie zuweist, kann der Angreifer, der das urspr√ºngliche Cookie besitzt, das Opfer imitieren. Diese Technik beruht darauf, dass das Opfer sich mit einem Cookie anmeldet, das vom Angreifer bereitgestellt wurde.

Wenn du ein **XSS in einer Subdomain** gefunden hast oder **eine Subdomain kontrollierst**, lies:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Sitzungsdonation

Hier √ºberzeugt der Angreifer das Opfer, das Sitzungscookie des Angreifers zu verwenden. Das Opfer, das glaubt, in seinem eigenen Konto angemeldet zu sein, wird unbeabsichtigt Aktionen im Kontext des Kontos des Angreifers ausf√ºhren.

Wenn du ein **XSS in einer Subdomain** gefunden hast oder **eine Subdomain kontrollierst**, lies:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT-Cookies](../hacking-jwt-json-web-tokens.md)

Klicke auf den vorherigen Link, um auf eine Seite zuzugreifen, die m√∂gliche Schw√§chen in JWT erkl√§rt.

JSON Web Tokens (JWT), die in Cookies verwendet werden, k√∂nnen ebenfalls Sicherheitsanf√§lligkeiten aufweisen. F√ºr detaillierte Informationen zu potenziellen Schw√§chen und deren Ausnutzung wird empfohlen, das verlinkte Dokument √ºber das Hacken von JWT zu konsultieren.

### Cross-Site Request Forgery (CSRF)

Dieser Angriff zwingt einen angemeldeten Benutzer, unerw√ºnschte Aktionen in einer Webanwendung auszuf√ºhren, in der er derzeit authentifiziert ist. Angreifer k√∂nnen Cookies ausnutzen, die automatisch mit jeder Anfrage an die anf√§llige Seite gesendet werden.

### Leere Cookies

(Weitere Details findest du in der [originalen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Browser erlauben die Erstellung von Cookies ohne Namen, was durch JavaScript wie folgt demonstriert werden kann:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Das Ergebnis im gesendeten Cookie-Header ist `a=v1; test value; b=v2;`. Interessanterweise erm√∂glicht dies die Manipulation von Cookies, wenn ein Cookie mit leerem Namen gesetzt wird, wodurch m√∂glicherweise andere Cookies kontrolliert werden k√∂nnen, indem das leere Cookie auf einen bestimmten Wert gesetzt wird:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
Dies f√ºhrt dazu, dass der Browser einen Cookie-Header sendet, der von jedem Webserver als ein Cookie mit dem Namen `a` und dem Wert `b` interpretiert wird.

#### Chrome-Bug: Unicode-Surrogat-Codepunkt-Problem

In Chrome, wenn ein Unicode-Surrogat-Codepunkt Teil eines gesetzten Cookies ist, wird `document.cookie` besch√§digt und gibt anschlie√üend einen leeren String zur√ºck:
```js
document.cookie = "\ud800=meep";
```
Dies f√ºhrt dazu, dass `document.cookie` einen leeren String ausgibt, was auf eine permanente Besch√§digung hinweist.

#### Cookie-Smuggling aufgrund von Parsing-Problemen

(Weitere Details finden Sie in der [originalen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Mehrere Webserver, einschlie√ülich der von Java (Jetty, TomCat, Undertow) und Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), behandeln Cookie-Strings aufgrund veralteter RFC2965-Unterst√ºtzung falsch. Sie lesen einen doppelt zitierten Cookie-Wert als einen einzigen Wert, selbst wenn er Semikolons enth√§lt, die normalerweise Schl√ºssel-Wert-Paare trennen sollten:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Die falsche Analyse von Cookies durch Server, insbesondere Undertow, Zope und solche, die Python's `http.cookie.SimpleCookie` und `http.cookie.BaseCookie` verwenden, schafft M√∂glichkeiten f√ºr Cookie-Injektionsangriffe. Diese Server vers√§umen es, den Beginn neuer Cookies ordnungsgem√§√ü zu kennzeichnen, was es Angreifern erm√∂glicht, Cookies zu f√§lschen:

* Undertow erwartet ein neues Cookie sofort nach einem zitierten Wert ohne Semikolon.
* Zope sucht nach einem Komma, um mit der Analyse des n√§chsten Cookies zu beginnen.
* Die Cookie-Klassen von Python beginnen mit der Analyse bei einem Leerzeichen.

Diese Schwachstelle ist besonders gef√§hrlich in Webanwendungen, die auf cookie-basiertem CSRF-Schutz basieren, da sie Angreifern erm√∂glicht, gef√§lschte CSRF-Token-Cookies einzuschleusen, was potenziell Sicherheitsma√ünahmen umgeht. Das Problem wird durch die Handhabung von doppelten Cookie-Namen in Python versch√§rft, bei der das letzte Vorkommen fr√ºhere √ºberschreibt. Es wirft auch Bedenken hinsichtlich `__Secure-` und `__Host-` Cookies in unsicheren Kontexten auf und k√∂nnte zu Autorisierungsumgehungen f√ºhren, wenn Cookies an Backend-Server weitergegeben werden, die anf√§llig f√ºr Spoofing sind.

### Extra Vulnerable Cookies Checks

#### **Basic checks**

* Das **Cookie** ist jedes Mal, wenn Sie sich **anmelden**, **gleich**.
* Melden Sie sich ab und versuchen Sie, dasselbe Cookie zu verwenden.
* Versuchen Sie, sich mit 2 Ger√§ten (oder Browsern) mit demselben Cookie in dasselbe Konto einzuloggen.
* √úberpr√ºfen Sie, ob das Cookie Informationen enth√§lt, und versuchen Sie, es zu √§ndern.
* Versuchen Sie, mehrere Konten mit fast demselben Benutzernamen zu erstellen, und √ºberpr√ºfen Sie, ob Sie √Ñhnlichkeiten sehen k√∂nnen.
* √úberpr√ºfen Sie die Option "**remember me**", falls vorhanden, um zu sehen, wie sie funktioniert. Wenn sie vorhanden ist und anf√§llig sein k√∂nnte, verwenden Sie immer das Cookie von **remember me** ohne ein anderes Cookie.
* √úberpr√ºfen Sie, ob das vorherige Cookie funktioniert, selbst nachdem Sie das Passwort ge√§ndert haben.

#### **Advanced cookies attacks**

Wenn das Cookie beim Anmelden gleich bleibt (oder fast gleich bleibt), bedeutet dies wahrscheinlich, dass das Cookie mit einem Feld Ihres Kontos (wahrscheinlich dem Benutzernamen) verbunden ist. Dann k√∂nnen Sie:

* Versuchen, viele **Konten** mit sehr **√§hnlichen** Benutzernamen zu erstellen und versuchen, zu **erraten**, wie der Algorithmus funktioniert.
* Versuchen, den **Benutzernamen zu bruteforcen**. Wenn das Cookie nur als Authentifizierungsmethode f√ºr Ihren Benutzernamen gespeichert wird, k√∂nnen Sie ein Konto mit dem Benutzernamen "**Bmin**" erstellen und jeden einzelnen **Bit** Ihres Cookies **bruteforcen**, da eines der Cookies, die Sie versuchen werden, das von "**admin**" sein wird.
* Versuchen Sie **Padding** **Oracle** (Sie k√∂nnen den Inhalt des Cookies entschl√ºsseln). Verwenden Sie **padbuster**.

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster wird mehrere Versuche unternehmen und Sie fragen, welche Bedingung die Fehlerbedingung ist (die, die nicht g√ºltig ist).

Dann beginnt es, das Cookie zu entschl√ºsseln (es kann mehrere Minuten dauern).

Wenn der Angriff erfolgreich durchgef√ºhrt wurde, k√∂nnten Sie versuchen, eine Zeichenfolge Ihrer Wahl zu verschl√ºsseln. Zum Beispiel, wenn Sie **encrypt** **user=administrator** verschl√ºsseln m√∂chten.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Diese Ausf√ºhrung gibt Ihnen das Cookie korrekt verschl√ºsselt und kodiert mit dem String **user=administrator** darin.

**CBC-MAC**

Vielleicht k√∂nnte ein Cookie einen Wert haben und mit CBC signiert werden. Dann ist die Integrit√§t des Wertes die Signatur, die durch die Verwendung von CBC mit demselben Wert erstellt wird. Da empfohlen wird, als IV einen Nullvektor zu verwenden, k√∂nnte diese Art der Integrit√§tspr√ºfung anf√§llig sein.

**Der Angriff**

1. Holen Sie sich die Signatur des Benutzernamens **administ** = **t**
2. Holen Sie sich die Signatur des Benutzernamens **rator\x00\x00\x00 XOR t** = **t'**
3. Setzen Sie im Cookie den Wert **administrator+t'** (**t'** wird eine g√ºltige Signatur von **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** sein)

**ECB**

Wenn das Cookie mit ECB verschl√ºsselt ist, k√∂nnte es anf√§llig sein.\
Wenn Sie sich anmelden, muss das Cookie, das Sie erhalten, immer dasselbe sein.

**Wie man erkennt und angreift:**

Erstellen Sie 2 Benutzer mit fast denselben Daten (Benutzername, Passwort, E-Mail usw.) und versuchen Sie, ein Muster im gegebenen Cookie zu entdecken.

Erstellen Sie einen Benutzer mit dem Namen "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" und √ºberpr√ºfen Sie, ob es ein Muster im Cookie gibt (da ECB mit demselben Schl√ºssel jeden Block verschl√ºsselt, k√∂nnten die gleichen verschl√ºsselten Bytes erscheinen, wenn der Benutzername verschl√ºsselt wird).

Es sollte ein Muster (mit der Gr√∂√üe eines verwendeten Blocks) geben. Wenn Sie wissen, wie eine Menge von "a" verschl√ºsselt ist, k√∂nnen Sie einen Benutzernamen erstellen: "a"\*(Gr√∂√üe des Blocks)+"admin". Dann k√∂nnten Sie das verschl√ºsselte Muster eines Blocks von "a" aus dem Cookie l√∂schen. Und Sie haben das Cookie des Benutzernamens "admin".

## Referenzen

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)


{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
