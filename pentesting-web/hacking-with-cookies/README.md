# Cookies Hacking

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Cookie Attribute

Cookies werden mit mehreren Attributen geliefert, die ihr Verhalten im Browser des Benutzers steuern. Hier ist eine √úbersicht √ºber diese Attribute in einer passiveren Sprache:

### Ablaufdatum und Max-Age

Das Ablaufdatum eines Cookies wird durch das Attribut `Expires` bestimmt. Umgekehrt definiert das Attribut `Max-age` die Zeit in Sekunden, bis ein Cookie gel√∂scht wird. **W√§hlen Sie `Max-age`, da es modernere Praktiken widerspiegelt.**

### Domain

Die Hosts, die ein Cookie erhalten sollen, werden durch das Attribut `Domain` angegeben. Standardm√§√üig ist dies auf den Host festgelegt, der das Cookie ausgestellt hat, ohne seine Subdomains einzubeziehen. Wenn jedoch das Attribut `Domain` explizit festgelegt ist, umfasst es auch Subdomains. Dies macht die Spezifikation des `Domain`-Attributs zu einer weniger restriktiven Option, die in Szenarien n√ºtzlich ist, in denen ein Cookieaustausch √ºber Subdomains erforderlich ist. Beispielsweise macht das Setzen von `Domain=mozilla.org` Cookies auf seinen Subdomains wie `developer.mozilla.org` zug√§nglich.

### Pfad

Ein spezifischer URL-Pfad, der in der angeforderten URL vorhanden sein muss, damit der `Cookie`-Header gesendet wird, wird durch das Attribut `Path` angezeigt. Dieses Attribut betrachtet das `/`-Zeichen als Verzeichnistrennzeichen und erm√∂glicht √úbereinstimmungen in Unterverzeichnissen.

### Bestellregeln

Wenn zwei Cookies denselben Namen haben, wird das zum Senden ausgew√§hlte Cookie basierend auf folgendem ausgew√§hlt:

* Das Cookie, das zum l√§ngsten Pfad in der angeforderten URL passt.
* Das zuletzt gesetzte Cookie, wenn die Pfade identisch sind.

### SameSite

* Das Attribut `SameSite` bestimmt, ob Cookies bei Anfragen von Drittanbieterdomains gesendet werden. Es bietet drei Einstellungen:
* **Strict**: Beschr√§nkt das Senden des Cookies bei Anfragen von Drittanbieterdomains.
* **Lax**: Erlaubt das Senden des Cookies bei GET-Anfragen, die von Websites von Drittanbietern initiiert wurden.
* **None**: Erlaubt das Senden des Cookies von jeder Drittanbieterdomain.

Beachten Sie, dass beim Konfigurieren von Cookies das Verst√§ndnis dieser Attribute dazu beitragen kann, sicherzustellen, dass sie sich in verschiedenen Szenarien wie erwartet verhalten.

| **Anforderungstyp** | **Beispielcode**                   | **Gesendete Cookies bei** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Formular GET     | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Formular POST    | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Bild             | \<img src="...">                   | NetSet\*, None        |

Tabelle von [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) und leicht modifiziert.\
Ein Cookie mit _**SameSite**_-Attribut wird **CSRF-Angriffe abmildern**, bei denen eine angemeldete Sitzung erforderlich ist.

**\*Beachten Sie, dass ab Chrome80 (Feb/2019) das Standardverhalten eines Cookies ohne ein Cookie-Samesite-Attribut lax sein wird** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Beachten Sie vor√ºbergehend, dass die **Cookies ohne eine SameSite-Richtlinie** in Chrome w√§hrend der **ersten 2 Minuten als None** und dann als Lax f√ºr Cross-Site-POST-Anforderungen auf h√∂chster Ebene behandelt werden.

## Cookies-Flags

### HttpOnly

Dies verhindert, dass der **Client** auf das Cookie zugreift (zum Beispiel √ºber **Javascript** wie `document.cookie`)

#### **Umgehungen**

* Wenn die Seite die Cookies als Antwort auf eine Anfrage sendet (zum Beispiel auf einer **PHPinfo**-Seite), ist es m√∂glich, XSS zu missbrauchen, um eine Anfrage an diese Seite zu senden und die Cookies aus der Antwort zu **stehlen** (√ºberpr√ºfen Sie ein Beispiel unter [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Dies k√∂nnte mit **TRACE**-**HTTP**-Anfragen umgangen werden, da die Antwort des Servers (falls diese HTTP-Methode verf√ºgbar ist) die gesendeten Cookies widerspiegelt. Diese Technik wird als **Cross-Site-Tracking** bezeichnet.
* Moderne Browser vermeiden diese Technik, indem sie das Senden einer TRACE-Anfrage von JS nicht zulassen. Es wurden jedoch einige Umgehungen f√ºr spezifische Software gefunden, wie das Senden von `\r\nTRACE` anstelle von `TRACE` an IE6.0 SP2.
* Ein anderer Weg ist die Ausnutzung von Zero-Day-Schwachstellen der Browser.
* Es ist m√∂glich, **HttpOnly-Cookies zu √ºberschreiben**, indem ein Cookie-Jar-√úberlaufangriff durchgef√ºhrt wird:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Es ist m√∂glich, einen [**Cookie-Smuggling**](./#cookie-smuggling)-Angriff zu verwenden, um diese Cookies zu exfiltrieren

### Secure

Die Anfrage sendet das Cookie **nur**, wenn die Anfrage √ºber einen sicheren Kanal √ºbertragen wird (typischerweise **HTTPS**).

## Cookies-Pr√§fixe

Cookies mit dem Pr√§fix `__Secure-` m√ºssen zusammen mit der `secure`-Flag von Seiten gesetzt werden, die durch HTTPS gesichert sind.

F√ºr Cookies mit dem Pr√§fix `__Host-` m√ºssen mehrere Bedingungen erf√ºllt sein:

* Sie m√ºssen mit der `secure`-Flag gesetzt werden.
* Sie m√ºssen von einer Seite stammen, die durch HTTPS gesichert ist.
* Es ist verboten, eine Domain anzugeben, um deren √úbertragung an Subdomains zu verhindern.
* Der Pfad f√ºr diese Cookies muss auf `/` gesetzt sein.

Es ist wichtig zu beachten, dass Cookies mit dem Pr√§fix `__Host-` nicht an Superdomains oder Subdomains gesendet werden d√ºrfen. Diese Einschr√§nkung tr√§gt dazu bei, Anwendungscookies zu isolieren. Daher kann die Verwendung des Pr√§fix `__Host-` f√ºr alle Anwendungscookies als bew√§hrte Praxis zur Verbesserung von Sicherheit und Isolierung betrachtet werden.
## Cookie-Angriffe

Wenn ein benutzerdefinierter Cookie sensible Daten enth√§lt, √ºberpr√ºfen Sie ihn (insbesondere wenn Sie an einem CTF teilnehmen), da er m√∂glicherweise anf√§llig ist.

### Dekodieren und Manipulieren von Cookies

In Cookies eingebettete sensible Daten sollten immer √ºberpr√ºft werden. Cookies, die in Base64 oder √§hnlichen Formaten codiert sind, k√∂nnen oft decodiert werden. Diese Schwachstelle erm√∂glicht es Angreifern, den Inhalt des Cookies zu √§ndern und sich als andere Benutzer auszugeben, indem sie ihre modifizierten Daten zur√ºck in das Cookie codieren.

### Sitzungshijacking

Bei diesem Angriff wird ein Benutzercookie gestohlen, um unbefugten Zugriff auf das Konto eines Benutzers innerhalb einer Anwendung zu erlangen. Indem der gestohlene Cookie verwendet wird, kann ein Angreifer den legitimen Benutzer imitieren.

### Sitzungsfestlegung

In diesem Szenario t√§uscht ein Angreifer ein Opfer dazu, ein bestimmtes Cookie zum Einloggen zu verwenden. Wenn die Anwendung beim Einloggen kein neues Cookie vergibt, kann der Angreifer, der das urspr√ºngliche Cookie besitzt, das Opfer imitieren. Diese Technik basiert darauf, dass das Opfer sich mit einem vom Angreifer bereitgestellten Cookie einloggt.

Wenn Sie ein **XSS in einem Subdomain** gefunden haben oder Sie **eine Subdomain kontrollieren**, lesen Sie:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Sitzungsspende

Hier √ºberzeugt der Angreifer das Opfer, den Sitzungscookie des Angreifers zu verwenden. Das Opfer, das glaubt, in sein eigenes Konto eingeloggt zu sein, wird unbeabsichtigt Aktionen im Kontext des Kontos des Angreifers ausf√ºhren.

Wenn Sie ein **XSS in einem Subdomain** gefunden haben oder Sie **eine Subdomain kontrollieren**, lesen Sie:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT-Cookies](../hacking-jwt-json-web-tokens.md)

Klicken Sie auf den vorherigen Link, um auf eine Seite zuzugreifen, die m√∂gliche Schwachstellen in JWT erkl√§rt.

JSON Web Tokens (JWT), die in Cookies verwendet werden, k√∂nnen ebenfalls Schwachstellen aufweisen. F√ºr detaillierte Informationen zu potenziellen Schwachstellen und wie man sie ausnutzen kann, wird empfohlen, das verlinkte Dokument zum Hacken von JWT aufzurufen.

### Cross-Site Request Forgery (CSRF)

Dieser Angriff zwingt einen eingeloggten Benutzer, unerw√ºnschte Aktionen auf einer Webanwendung auszuf√ºhren, f√ºr die er derzeit authentifiziert ist. Angreifer k√∂nnen Cookies ausnutzen, die automatisch mit jeder Anfrage an die verwundbare Website gesendet werden.

### Leere Cookies

(Weitere Details finden Sie in der [urspr√ºnglichen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Browser erlauben die Erstellung von Cookies ohne Namen, was durch JavaScript wie folgt demonstriert werden kann:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Der Wert im gesendeten Cookie-Header lautet `a=v1; test value; b=v2;`. Interessanterweise erm√∂glicht dies die Manipulation von Cookies, wenn ein Cookie mit leerem Namen gesetzt wird, wodurch m√∂glicherweise andere Cookies kontrolliert werden k√∂nnen, indem das leere Cookie auf einen bestimmten Wert gesetzt wird:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
#### Chrome-Bug: Unicode-Ersatzcodepunkt-Problem

In Chrome wird, wenn ein Unicode-Ersatzcodepunkt Teil eines gesetzten Cookies ist, `document.cookie` besch√§digt, und gibt anschlie√üend einen leeren String zur√ºck:
```js
document.cookie = "\ud800=meep";
```
Dies f√ºhrt dazu, dass `document.cookie` eine leere Zeichenfolge ausgibt, was auf eine dauerhafte Besch√§digung hinweist.

#### Cookie-Schmuggel aufgrund von Parsing-Problemen

(Weitere Details finden Sie in der [urspr√ºnglichen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Mehrere Webserver, darunter solche von Java (Jetty, TomCat, Undertow) und Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), behandeln Cookie-Zeichenfolgen aufgrund veralteter RFC2965-Unterst√ºtzung falsch. Sie lesen einen in doppelte Anf√ºhrungszeichen gesetzten Cookie-Wert als einzelnen Wert, auch wenn er Semikolons enth√§lt, die normalerweise Schl√ºssel-Wert-Paare trennen sollten:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie-Injection-Schwachstellen

(√úberpr√ºfen Sie weitere Details in der [urspr√ºnglichen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Die inkorrekte Analyse von Cookies durch Server, insbesondere Undertow, Zope und solche, die Python's `http.cookie.SimpleCookie` und `http.cookie.BaseCookie` verwenden, schafft M√∂glichkeiten f√ºr Cookie-Injection-Angriffe. Diese Server vers√§umen es, den Beginn neuer Cookies ordnungsgem√§√ü zu begrenzen, was es Angreifern erm√∂glicht, Cookies zu f√§lschen:

- Undertow erwartet ein neues Cookie unmittelbar nach einem in Anf√ºhrungszeichen gesetzten Wert ohne Semikolon.
- Zope sucht nach einem Komma, um mit der Analyse des n√§chsten Cookies zu beginnen.
- Die Cookie-Klassen von Python beginnen mit der Analyse bei einem Leerzeichen.

Diese Schwachstelle ist besonders gef√§hrlich in Webanwendungen, die auf cookiebasierten CSRF-Schutz angewiesen sind, da sie es Angreifern erm√∂glicht, gef√§lschte CSRF-Token-Cookies einzuf√ºgen und m√∂glicherweise Sicherheitsma√ünahmen zu umgehen. Das Problem wird durch Pythons Umgang mit doppelten Cookienamen versch√§rft, bei dem das letzte Auftreten fr√ºhere √ºberschreibt. Es wirft auch Bedenken hinsichtlich der `__Secure-` und `__Host-`-Cookies in unsicheren Kontexten auf und k√∂nnte zu Autorisierungsumgehungen f√ºhren, wenn Cookies an anf√§llige Backend-Server weitergeleitet werden, die anf√§llig f√ºr F√§lschungen sind.

### Zus√§tzliche √úberpr√ºfungen f√ºr anf√§llige Cookies

#### **Grundlegende √úberpr√ºfungen**

- Das **Cookie** ist jedes Mal **dasselbe**, wenn Sie sich **anmelden**.
- Melden Sie sich ab und versuchen Sie, dasselbe Cookie zu verwenden.
- Versuchen Sie, sich mit 2 Ger√§ten (oder Browsern) am selben Konto mit demselben Cookie anzumelden.
- √úberpr√ºfen Sie, ob das Cookie Informationen enth√§lt und versuchen Sie, es zu √§ndern.
- Versuchen Sie, mehrere Konten mit fast demselben Benutzernamen zu erstellen und pr√ºfen Sie, ob Sie √Ñhnlichkeiten sehen k√∂nnen.
- √úberpr√ºfen Sie die Option "**Angemeldet bleiben**", falls vorhanden, um zu sehen, wie sie funktioniert. Wenn sie vorhanden ist und anf√§llig sein k√∂nnte, verwenden Sie immer das Cookie von **Angemeldet bleiben** ohne ein anderes Cookie.
- √úberpr√ºfen Sie, ob das vorherige Cookie auch nach √Ñnderung des Passworts funktioniert.

#### **Fortgeschrittene Cookie-Angriffe**

Wenn das Cookie beim Einloggen dasselbe bleibt (oder fast dasselbe), bedeutet dies wahrscheinlich, dass das Cookie mit einem Feld Ihres Kontos zusammenh√§ngt (wahrscheinlich der Benutzername). Dann k√∂nnen Sie:

- Versuchen Sie, viele **Konten** mit sehr **√§hnlichen Benutzernamen** zu erstellen und versuchen Sie zu **erraten**, wie der Algorithmus funktioniert.
- Versuchen Sie, den Benutzernamen **bruteforce**. Wenn das Cookie nur als Authentifizierungsmethode f√ºr Ihren Benutzernamen gespeichert wird, k√∂nnen Sie ein Konto mit dem Benutzernamen "**Bmin**" erstellen und jedes einzelne **Bit** Ihres Cookies **bruteforcen**, da eines der Cookies, die Sie ausprobieren werden, dem von "**admin**" geh√∂rt.
- Versuchen Sie **Padding Oracle** (Sie k√∂nnen den Inhalt des Cookies entschl√ºsseln). Verwenden Sie **padbuster**.

**Padding Oracle - Padbuster-Beispiele**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster wird mehrere Versuche unternehmen und Sie nach der Fehlerbedingung fragen (die ung√ºltige).

Dann wird es beginnen, das Cookie zu entschl√ºsseln (es kann mehrere Minuten dauern).

Wenn der Angriff erfolgreich war, k√∂nnten Sie versuchen, einen String Ihrer Wahl zu verschl√ºsseln. Zum Beispiel, wenn Sie **user=administrator** **verschl√ºsseln** m√∂chten.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Diese Ausf√ºhrung gibt Ihnen das Cookie korrekt verschl√ºsselt und codiert mit dem String **user=administrator** darin.

**CBC-MAC**

M√∂glicherweise k√∂nnte ein Cookie einen Wert haben und mit CBC signiert werden. Dann ist die Integrit√§t des Werts die Signatur, die durch Verwendung von CBC mit dem gleichen Wert erstellt wurde. Da empfohlen wird, als IV einen Nullvektor zu verwenden, k√∂nnte diese Art der Integrit√§tspr√ºfung anf√§llig sein.

**Der Angriff**

1. Erhalten Sie die Signatur des Benutzernamens **administ** = **t**
2. Erhalten Sie die Signatur des Benutzernamens **rator\x00\x00\x00 XOR t** = **t'**
3. Setzen Sie im Cookie den Wert **administrator+t'** (**t'** wird eine g√ºltige Signatur von **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** sein

**ECB**

Wenn das Cookie mit ECB verschl√ºsselt ist, k√∂nnte es anf√§llig sein.\
Wenn Sie sich anmelden, muss das Cookie, das Sie erhalten, immer dasselbe sein.

**Wie man erkennt und angreift:**

Erstellen Sie 2 Benutzer mit fast denselben Daten (Benutzername, Passwort, E-Mail usw.) und versuchen Sie, ein Muster im gegebenen Cookie zu entdecken

Erstellen Sie einen Benutzer namens zum Beispiel "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" und √ºberpr√ºfen Sie, ob es ein Muster im Cookie gibt (da ECB mit dem gleichen Schl√ºssel jeden Block verschl√ºsselt, k√∂nnten die gleichen verschl√ºsselten Bytes erscheinen, wenn der Benutzername verschl√ºsselt ist).

Es sollte ein Muster geben (mit der Gr√∂√üe eines verwendeten Blocks). So k√∂nnen Sie, wenn Sie wissen, wie eine Menge von "a" verschl√ºsselt ist, einen Benutzernamen erstellen: "a"\*(Gr√∂√üe des Blocks)+"admin". Dann k√∂nnten Sie das verschl√ºsselte Muster eines Blocks von "a" aus dem Cookie l√∂schen. Und Sie haben das Cookie des Benutzernamens "admin".

## Referenzen

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Heldenniveau mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
