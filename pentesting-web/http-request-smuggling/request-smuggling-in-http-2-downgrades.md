# DÃ©tournement de requÃªte dans les rÃ©trogradations HTTP/2

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Origines

L'origine principale de cette vulnÃ©rabilitÃ© est le fait que le **reverse proxy** va **communiquer avec le client** en utilisant **HTTP/2** puis il va **transformer** cette **communication** avec le **serveur back-end** en **HTTP/1.1**.

![](<../../.gitbook/assets/image (636) (1).png>)

Le problÃ¨me avec cette approche est que l'**utilisateur** va pouvoir **injecter** des **en-tÃªtes** inutilement dans la **communication HTTP/2** qui probablement **ne seront pas vÃ©rifiÃ©s** par le proxy. Mais ensuite, lorsque ceux-ci sont **injectÃ©s Ã  l'aveugle dans la communication HTTP/1.1**, **une attaque de dÃ©tournement de requÃªte peut Ãªtre rÃ©alisÃ©e**.

## Exemples

### DÃ©synchronisation H2.CL

La spÃ©cification HTTP/2 indique que l'en-tÃªte **Content-Length n'est pas nÃ©cessaire mais peut Ãªtre indiquÃ©**. Par consÃ©quent, le **reverse proxy** va **traiter tout le contenu envoyÃ© par les utilisateurs** comme la requÃªte, mais ensuite, lors de la **rÃ©trogradation en HTTP/1.1**, cet **en-tÃªte** va Ãªtre **injectÃ©** dans la **requÃªte** et donc, le **serveur back-end traitera la requÃªte comme 2 requÃªtes diffÃ©rentes** comme vous pouvez le voir dans l'image ci-dessous :

![](<../../.gitbook/assets/image (639).png>)

### DÃ©tournement H2.TE et Hijack de Token d'URL

La spÃ©cification HTTP/2 indique Ã©galement que **tout message contenant des champs d'en-tÃªte spÃ©cifiques Ã  la connexion doit Ãªtre traitÃ© comme malformÃ©... mais si vous ne suivez pas cette rÃ¨gle, vous Ãªtes vulnÃ©rable**.

Cette technique a Ã©tÃ© abusÃ©e sur le load balancer AWS, donc s'assurer que les utilisateurs accÃ¨dent Ã  un en-tÃªte Host pointant vers un serveur contrÃ´lÃ© par l'attaquant les fera accÃ©der Ã  ce serveur.

![](<../../.gitbook/assets/image (631) (1).png>)

### DÃ©tournement H2.TE et Hijack d'En-tÃªte

C'est exactement la mÃªme technique que prÃ©cÃ©demment, mais en vÃ©rifiant les requÃªtes, James a remarquÃ© que les clients demandaient Ã  lui envoyer leurs identifiants, il a donc juste modifiÃ© son serveur pour permettre Ã  CORS de lui envoyer les identifiants des gens :

![](<../../.gitbook/assets/image (662) (1) (1) (1) (1) (1).png>)

### H2.TE via Injection d'En-tÃªte de RequÃªte

**HTTP/2 n'autorisera Ã©galement pas Ã  mettre des caractÃ¨res non autorisÃ©s dans les en-tÃªtes**, mais si le serveur **ne respecte pas** cette rÃ¨gle, vous pouvez **injecter des en-tÃªtes arbitraires** lorsque la communication est **rÃ©trogradÃ©e** en HTTP/1.1.

Dans ce cas, **l'en-tÃªte Transfer-Encoding a Ã©tÃ© injectÃ©**.

![](<../../.gitbook/assets/image (648) (1) (1) (1) (1) (1).png>)

### H2.TE via Injection de Nom d'En-tÃªte

HTTP/2 sur certains serveurs vous permet de mettre un **deux-points dans le nom de l'en-tÃªte, et avec un** vous pouvez injecter un nouvel en-tÃªte Ã  l'intÃ©rieur du nom de l'en-tÃªte comme ceci :

![](<../../.gitbook/assets/image (632) (1).png>)

Notez que si vous mettez juste les caractÃ¨res de nouvelle ligne en envoyant un en-tÃªte sans contenu, la requÃªte va Ãªtre traitÃ©e comme **non valide** :

![](<../../.gitbook/assets/image (647) (1) (1) (1).png>)

### H2.TE via Injection de Ligne de RequÃªte

Dans ce cas, l'injection a Ã©tÃ© rÃ©alisÃ©e Ã  l'intÃ©rieur de la ligne de requÃªte :

![](<../../.gitbook/assets/image (640) (1).png>)

### Injection de PrÃ©fixe d'URL

Ã€ l'intÃ©rieur du schÃ©ma de la connexion HTTP/2, vous pourriez Ãªtre capable d'envoyer une URL complÃ¨te qui Ã©crasera celle indiquÃ©e dans le chemin :

![](<../../.gitbook/assets/image (661) (1) (1).png>)

### Injection de Ligne de RequÃªte via des espaces

![](<../../.gitbook/assets/image (641) (1).png>)

## RÃ©utilisation de la connexion frontend->backend

Parfois, vous constaterez qu'en effectuant une attaque de DÃ©tournement de RequÃªte HTTP, **vous ne pouvez attaquer que vous-mÃªme**. Cela pourrait Ãªtre parce que le reverse proxy a dÃ©cidÃ© d'**utiliser une connexion diffÃ©rente avec le serveur back-end** par IP.

Notez que **mÃªme** avec cette **restriction**, vous pouvez toujours rÃ©aliser des attaques telles que des **contournements d'autorisation**, des fuites d'en-tÃªtes internes et des attaques de **tromperie de cache et d'empoisonnement de cache**.

Habituellement, cette restriction n'existe pas, vous pouvez donc **dÃ©tourner des requÃªtes dans la connexion entre le reverse proxy et le back-end** que d'autres personnes utilisent, mais il est mÃªme **possible** que le **proxy** ne **rÃ©utilise mÃªme pas une connexion avec des connexions de la mÃªme IP** (restriction assez lourde pour ce type d'attaque).

![](<../../.gitbook/assets/image (646) (1) (1).png>)

Dans la restriction la plus lourde (pas de rÃ©utilisation de connexion), vous dÃ©tecterez la vulnÃ©rabilitÃ© avec la technique basÃ©e sur le temps, mais en la testant, vous constaterez qu'il s'agit d'un "faux positif".

### Confirmation de Tunneling

Une maniÃ¨re de **confirmer** si le **point de terminaison est vulnÃ©rable** mais que la connexion est **Ã  l'intÃ©rieur d'un "tunnel"** est de **dÃ©tourner 2 requÃªtes complÃ¨tes** en 1.

Le **problÃ¨me** avec **HTTP/1.1** est que si vous **recevez 2 rÃ©ponses HTTP**, vous **ne savez pas** si le point de terminaison Ã©tait **vulnÃ©rable** ou non et la **requÃªte "dÃ©tournÃ©e" a juste Ã©tÃ© traitÃ©e comme une requÃªte rÃ©guliÃ¨re**.

Cependant, cette technique peut Ãªtre utilisÃ©e **en HTTP/2** car si le point de terminaison Ã©tait **vulnÃ©rable** et que vous avez dÃ©tournÃ© une requÃªte, vous verrez les **en-tÃªtes de la rÃ©ponse Ã  la requÃªte dÃ©tournÃ©e dans la rÃ©ponse du reverse proxy** :

![](<../../.gitbook/assets/image (652) (1) (1) (1).png>)

### ProblÃ¨me de Vision en Tunnel

Il pourrait y avoir un autre problÃ¨me, si la **rÃ©ponse** Ã  la requÃªte lÃ©gitime **contient** un **Content-Length**, le **reverse proxy** ne va lire que les **octets spÃ©cifiÃ©s lÃ  et pas plus, donc vous ne pourrez pas lire la rÃ©ponse de la requÃªte dÃ©tournÃ©e.**

Cependant, la requÃªte **HEAD** **ne contient pas de corps** mais elle contient gÃ©nÃ©ralement le **Content-Length** comme si la requÃªte Ã©tait une requÃªte GET. Par consÃ©quent, en envoyant une requÃªte **HEAD** **au lieu d'une requÃªte POST**, vous pouvez **lire les octets du Content-Length HEAD** de la rÃ©ponse Ã  la requÃªte dÃ©tournÃ©e.

![](<../../.gitbook/assets/image (628) (1) (1).png>)

### Fuite d'En-tÃªtes Internes via Tunneling

Si vous trouvez un **paramÃ¨tre POST** Ã  l'intÃ©rieur de l'application dont le **contenu** va Ãªtre **reflÃ©tÃ©** dans la **rÃ©ponse**, alors vous pouvez essayer d'injecter des caractÃ¨res HTTP/1.1 \r\n Ã  l'intÃ©rieur d'un en-tÃªte de requÃªte HTTP/2 afin que les nouveaux en-tÃªtes injectÃ©s par le proxy soient ajoutÃ©s dans le paramÃ¨tre POST qui sera reflÃ©tÃ© dans la rÃ©ponse :

![](<../../.gitbook/assets/image (656) (1) (1).png>)

Notez que dans ce cas, l'**attaquant** se soucie juste de la **rÃ©ponse** Ã  la **premiÃ¨re** **requÃªte**, il n'a pas besoin de lire la requÃªte Ã  la deuxiÃ¨me requÃªte dÃ©tournÃ©e invalide.

{% hint style="info" %}
Utiliser cette attaque **contre diffÃ©rentes parties du web (mÃ©thode, chemin...)** peut conduire Ã  l'utilisation de diffÃ©rents back-ends et Ã  la **fuite d'informations sensibles diffÃ©rentes**
{% endhint %}

### Empoisonnement de Cache via Tunneling

Dans ce scÃ©nario, une requÃªte **HEAD** vers l'**URL** **dont le** **cache** va Ãªtre **empoisonnÃ©** est envoyÃ©e tout en **dÃ©tournant** une **requÃªte** dont le **contenu de la rÃ©ponse contiendra le payload** (peut-Ãªtre un payload XSS).

Du fait que la **rÃ©ponse HEAD contient le `Content-Type: text/html`** et parce que le reverse proxy pense que **toute la rÃ©ponse Ã  la requÃªte dÃ©tournÃ©e est le corps de la requÃªte HEAD**, le **payload XSS** va Ãªtre **traitÃ© comme du HTML** mÃªme si la page n'Ã©tait pas vulnÃ©rable au XSS.

![](<../../.gitbook/assets/image (659) (1).png>)

## HTTP/2 CachÃ©

Habituellement, les serveurs annoncent le support via le champ ALPN dans la poignÃ©e de main TLS, mais certains ne le font pas.

Il peut Ãªtre facilement dÃ©tectÃ© en utilisant `curl --http2 --http2-prior-knowledge`

## Outils

* Extension Burp : HTTP Request Smuggler
* [https://github.com/neex/http2smugl](https://github.com/neex/http2smugl)

## RÃ©fÃ©rences

* Cette confÃ©rence explique parfaitement toutes les techniques indiquÃ©es ici : [https://www.youtube.com/watch?v=rHxVVeM9R-M](https://www.youtube.com/watch?v=rHxVVeM9R-M)

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
