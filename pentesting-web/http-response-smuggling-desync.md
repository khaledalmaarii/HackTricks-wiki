# HTTP Response Smuggling / Desync

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts github.

</details>
{% endhint %}

**La technique de ce post a Ã©tÃ© tirÃ©e de la vidÃ©o :** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## DÃ©synchronisation de la file d'attente des requÃªtes HTTP

Tout d'abord, cette technique **abuse d'une vulnÃ©rabilitÃ© de HTTP Request Smuggling**, donc vous devez savoir ce que c'est :

La **principale** **diffÃ©rence** entre cette technique et un smuggling HTTP Request commun est que **au lieu** de **cibler** la **requÃªte** de la **victime** **en ajoutant un prÃ©fixe**, nous allons **fuiter ou modifier la rÃ©ponse que la victime reÃ§oit**. Cela se fait en, au lieu d'envoyer 1 requÃªte et demie pour abuser du HTTP Request smuggling, **envoyer 2 requÃªtes complÃ¨tes pour dÃ©synchroniser la file d'attente des rÃ©ponses des proxies**.

C'est parce que nous allons pouvoir **dÃ©synchroniser la file d'attente des rÃ©ponses** afin que la **rÃ©ponse** de la **requÃªte** **lÃ©gitime** de la **victime soit envoyÃ©e Ã  l'attaquant**, ou en **injectant du contenu contrÃ´lÃ© par l'attaquant dans la rÃ©ponse Ã  la victime**.

### DÃ©synchronisation du pipeline HTTP

HTTP/1.1 permet de demander des **ressources diffÃ©rentes sans avoir besoin d'attendre les prÃ©cÃ©dentes**. Par consÃ©quent, s'il y a un **proxy** au **milieu**, c'est la tÃ¢che des proxies de **maintenir une correspondance synchronisÃ©e des requÃªtes envoyÃ©es au backend et des rÃ©ponses provenant de celui-ci**.

Cependant, il y a un problÃ¨me de dÃ©synchronisation de la file d'attente des rÃ©ponses. Si un attaquant envoie une attaque de HTTP Response smuggling et que les rÃ©ponses Ã  la **requÃªte initiale et Ã  celle smuggled sont rÃ©pondues immÃ©diatement**, la rÃ©ponse smuggled ne sera pas insÃ©rÃ©e dans la file d'attente de la rÃ©ponse de la victime mais sera **juste rejetÃ©e comme une erreur**.

![](<../.gitbook/assets/image (633).png>)

Par consÃ©quent, il est nÃ©cessaire que la **requÃªte smuggled** **prenne plus de temps Ã  Ãªtre traitÃ©e** Ã  l'intÃ©rieur du serveur backend. Ainsi, au moment oÃ¹ la requÃªte smuggled est traitÃ©e, la communication avec l'attaquant sera terminÃ©e.

Si dans cette situation spÃ©cifique une **victime a envoyÃ© une requÃªte** et que la **requÃªte smuggled est rÃ©pondue avant** la requÃªte lÃ©gitime, la **rÃ©ponse smuggled sera envoyÃ©e Ã  la victime**. Par consÃ©quent, l'attaquant va **contrÃ´ler la requÃªte "effectuÃ©e" par la victime**.

De plus, si l'**attaquant effectue ensuite une requÃªte** et que la **rÃ©ponse lÃ©gitime** Ã  la **requÃªte** de la **victime** est **rÃ©pondue** **avant** la requÃªte de l'attaquant. La **rÃ©ponse Ã  la victime va Ãªtre envoyÃ©e Ã  l'attaquant**, **volant** la rÃ©ponse Ã  la victime (qui peut contenir par exemple l'en-tÃªte **Set-Cookie**).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Injections imbriquÃ©es multiples

Une autre **diffÃ©rence intÃ©ressante** avec le **HTTP Request Smuggling** commun est que, dans une attaque de smuggling commune, le **but** est de **modifier le dÃ©but de la requÃªte de la victime** afin qu'elle effectue une action inattendue. Dans une **attaque de HTTP Response smuggling**, comme vous **envoyez des requÃªtes complÃ¨tes**, vous pouvez **injecter dans une charge utile des dizaines de rÃ©ponses** qui vont **dÃ©synchroniser des dizaines d'utilisateurs** qui vont **recevoir** les **rÃ©ponses injectÃ©es**.

En plus de pouvoir **distribuer plus facilement des dizaines d'exploits** parmi des utilisateurs lÃ©gitimes, cela pourrait Ã©galement Ãªtre utilisÃ© pour provoquer un **DoS** sur le serveur.

### Organisation de l'exploit

Comme expliquÃ© prÃ©cÃ©demment, pour abuser de cette technique, il est nÃ©cessaire que le **premier message smuggled** dans le serveur **prenne beaucoup de temps Ã  Ãªtre traitÃ©**.

Cette **requÃªte consommatrice de temps est suffisante** si nous voulons juste **essayer de voler la rÃ©ponse de la victime.** Mais si vous voulez effectuer un exploit plus complexe, cela sera une structure commune pour l'exploit.

Tout d'abord la **requÃªte initiale** abusant du **HTTP** **Request** **smuggling**, puis la **requÃªte consommatrice de temps** et ensuite **1 ou plusieurs requÃªtes de charge utile** dont les rÃ©ponses seront envoyÃ©es aux victimes.

## Abus de la dÃ©synchronisation de la file d'attente des rÃ©ponses HTTP

### Capturer les requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Comme avec les charges utiles connues de HTTP Request Smuggling, vous pouvez **voler la requÃªte de la victime** avec une diffÃ©rence importante : Dans ce cas, vous avez juste besoin que le **contenu envoyÃ© soit reflÃ©tÃ© dans la rÃ©ponse**, **aucun stockage persistant** n'est nÃ©cessaire.

Tout d'abord, l'attaquant envoie une charge utile contenant une **requÃªte POST finale avec le paramÃ¨tre rÃ©flÃ©chi** Ã  la fin et une grande Content-Length.

![](<../.gitbook/assets/image (1053).png>)

Ensuite, une fois que la **requÃªte initiale** (bleue) a Ã©tÃ© **traitÃ©e** et **pendant** que la **requÃªte lente** est en cours de traitement (jaune), la **prochaine requÃªte qui arrive d'une victime** va Ãªtre **ajoutÃ©e dans la file d'attente juste aprÃ¨s le paramÃ¨tre rÃ©flÃ©chi** :

![](<../.gitbook/assets/image (794).png>)

Ensuite, la **victime** va **recevoir** la **rÃ©ponse Ã  la requÃªte lente** et si entre-temps l'**attaquant** **envoie** **une autre** **requÃªte**, la **rÃ©ponse de la requÃªte de contenu rÃ©flÃ©chi sera envoyÃ©e Ã  lui**.

## DÃ©synchronisation de la rÃ©ponse

Jusqu'Ã  prÃ©sent, nous avons appris comment abuser des attaques de HTTP Request Smuggling pour **contrÃ´ler** la **requÃªte** **dont** la **rÃ©ponse** un **client** va **recevoir** et comment vous pouvez ensuite **voler la rÃ©ponse qui Ã©tait destinÃ©e Ã  la victime**.

Mais il est encore possible de **dÃ©synchroniser encore** plus les rÃ©ponses.

Il existe des requÃªtes intÃ©ressantes comme la requÃªte **HEAD** qui sont spÃ©cifiÃ©es pour ne pas avoir **de contenu Ã  l'intÃ©rieur du corps des rÃ©ponses** et qui devraient (doivent) **contenir la Content-Length** de la requÃªte comme **si c'Ã©tait une requÃªte GET**.

Par consÃ©quent, si un attaquant **injecte** une **requÃªte HEAD**, comme dans ces images :

![](<../.gitbook/assets/image (1107).png>)

Alors, **une fois que la bleue est rÃ©pondue Ã  l'attaquant**, la prochaine requÃªte de la victime va Ãªtre introduite dans la file d'attente :

![](<../.gitbook/assets/image (999).png>)

Ensuite, la **victime** va **recevoir** la **rÃ©ponse** de la **requÃªte HEAD**, qui va **contenir une Content-Length mais aucun contenu du tout**. Par consÃ©quent, le proxy **ne va pas envoyer cette rÃ©ponse** Ã  la victime, mais va **attendre** un **contenu**, qui en rÃ©alitÃ© va Ãªtre la **rÃ©ponse Ã  la requÃªte jaune** (Ã©galement injectÃ©e par l'attaquant) :

![](<../.gitbook/assets/image (735).png>)

### Confusion de contenu

En suivant l'exemple prÃ©cÃ©dent, sachant que vous pouvez **contrÃ´ler le corps** de la requÃªte dont la rÃ©ponse va Ãªtre reÃ§ue par la victime et qu'une **rÃ©ponse HEAD** **contient gÃ©nÃ©ralement dans ses en-tÃªtes le **Content-Type et le Content-Length**, vous pouvez **envoyer une requÃªte comme la suivante** pour **provoquer un XSS** chez la victime sans que la page soit vulnÃ©rable au XSS :

![](<../.gitbook/assets/image (688).png>)

### Poisoning de cache

En abusant de l'attaque de dÃ©synchronisation de rÃ©ponse commentÃ©e prÃ©cÃ©demment, **si le cache stocke la rÃ©ponse Ã  la requÃªte effectuÃ©e par la victime et que cette rÃ©ponse est une rÃ©ponse injectÃ©e provoquant un XSS, alors le cache est empoisonnÃ©**.

RequÃªte malveillante contenant la charge utile XSS :

![](<../.gitbook/assets/image (614).png>)

RÃ©ponse malveillante Ã  la victime qui contient l'en-tÃªte indiquant au cache de stocker la rÃ©ponse :

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Notez que dans ce cas, si la **"victime" est l'attaquant**, il peut maintenant effectuer **un empoisonnement de cache sur des URL arbitraires** car il peut **contrÃ´ler l'URL qui va Ãªtre mise en cache** avec la rÃ©ponse malveillante.
{% endhint %}

### Tromperie de cache web

Cette attaque est similaire Ã  la prÃ©cÃ©dente, mais **au lieu d'injecter une charge utile dans le cache, l'attaquant va mettre en cache des informations de la victime Ã  l'intÃ©rieur du cache :**

![](<../.gitbook/assets/image (991).png>)

### Division de rÃ©ponse

Le **but** de cette attaque est d'abuser Ã  nouveau de la **dÃ©synchronisation** de la **rÃ©ponse** afin de **faire en sorte que le proxy envoie une rÃ©ponse gÃ©nÃ©rÃ©e Ã  100 % par l'attaquant**.

Pour y parvenir, l'attaquant doit trouver un point de terminaison de l'application web qui **reflÃ¨te certaines valeurs Ã  l'intÃ©rieur de la rÃ©ponse** et **connaÃ®tre la longueur de contenu de la rÃ©ponse HEAD**.

Il enverra un **exploit** comme :

![](<../.gitbook/assets/image (911).png>)

AprÃ¨s que la premiÃ¨re requÃªte soit rÃ©solue et renvoyÃ©e Ã  l'attaquant, la **requÃªte de la victime est ajoutÃ©e dans la file d'attente** :

![](<../.gitbook/assets/image (737).png>)

La victime recevra comme rÃ©ponse la **rÃ©ponse HEAD + le contenu de la rÃ©ponse de la deuxiÃ¨me requÃªte (contenant une partie des donnÃ©es rÃ©flÃ©chies) :**

![](<../.gitbook/assets/image (356).png>)

Cependant, notez comment les **donnÃ©es rÃ©flÃ©chies avaient une taille selon la Content-Length** de la **rÃ©ponse HEAD** qui **a gÃ©nÃ©rÃ© une rÃ©ponse HTTP valide dans la file d'attente des rÃ©ponses**.

Par consÃ©quent, la **prochaine requÃªte de la deuxiÃ¨me victime** va **recevoir** comme **rÃ©ponse quelque chose complÃ¨tement fabriquÃ© par l'attaquant**. Comme la rÃ©ponse est complÃ¨tement fabriquÃ©e par l'attaquant, il peut Ã©galement **faire en sorte que le proxy mette en cache la rÃ©ponse**.

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts github.

</details>
{% endhint %}
