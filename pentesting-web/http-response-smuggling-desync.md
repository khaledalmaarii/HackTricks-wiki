# HTTP Response Smuggling / Desync

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## DÃ©synchronisation de la file d'attente des requÃªtes HTTP

Tout d'abord, cette technique **exploite une vulnÃ©rabilitÃ© de HTTP Request Smuggling**, donc vous devez savoir ce que c'est :

La **principale diffÃ©rence** entre cette technique et un HTTP Request Smuggling classique est qu'**au lieu** d'**attaquer** la **requÃªte** de la **victime en ajoutant un prÃ©fixe**, nous allons **fuir ou modifier la rÃ©ponse que la victime reÃ§oit**. Cela se fait en envoyant **2 requÃªtes complÃ¨tes pour dÃ©synchroniser la file d'attente des rÃ©ponses des proxies**.

Cela permet de **dÃ©synchroniser la file d'attente des rÃ©ponses** afin que la **rÃ©ponse** de la **requÃªte lÃ©gitime** de la **victime soit envoyÃ©e Ã  l'attaquant**, ou en **injectant un contenu contrÃ´lÃ© par l'attaquant dans la rÃ©ponse Ã  la victime**.

### DÃ©synchronisation de pipeline HTTP

HTTP/1.1 permet de demander **diffÃ©rentes ressources sans avoir Ã  attendre les prÃ©cÃ©dentes**. Par consÃ©quent, s'il y a un **proxy** au **milieu**, c'est la tÃ¢che du proxy de **maintenir une correspondance synchronisÃ©e des requÃªtes envoyÃ©es au backend et des rÃ©ponses provenant de celui-ci**.

Cependant, il y a un problÃ¨me pour dÃ©synchroniser la file d'attente des rÃ©ponses. Si un attaquant envoie une attaque de HTTP Response Smuggling et que les rÃ©ponses Ã  la **requÃªte initiale et Ã  la requÃªte introduite sont immÃ©diatement rÃ©pondues**, la rÃ©ponse introduite ne sera pas insÃ©rÃ©e dans la file d'attente de la rÃ©ponse de la victime mais sera **simplement Ã©cartÃ©e comme une erreur**.

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

Il est donc nÃ©cessaire que la **requÃªte introduite** **prenne plus de temps Ã  Ãªtre traitÃ©e** Ã  l'intÃ©rieur du serveur backend. Ainsi, lorsque la requÃªte introduite est traitÃ©e, la communication avec l'attaquant sera terminÃ©e.

Si dans cette situation spÃ©cifique une **victime a envoyÃ© une requÃªte** et que la **rÃ©ponse Ã  la requÃªte introduite est donnÃ©e avant** la requÃªte lÃ©gitime, la **rÃ©ponse introduite sera envoyÃ©e Ã  la victime**. Par consÃ©quent, l'attaquant **contrÃ´lera la requÃªte "effectuÃ©e" par la victime**.

De plus, si l'**attaquant effectue ensuite une requÃªte** et que la **rÃ©ponse lÃ©gitime** Ã  la **requÃªte de la victime** est **rÃ©pondue** **avant** la requÃªte de l'attaquant. La **rÃ©ponse Ã  la victime va Ãªtre envoyÃ©e Ã  l'attaquant**, **volant** la rÃ©ponse destinÃ©e Ã  la victime (qui peut contenir par exemple l'en-tÃªte **Set-Cookie**).

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### Injections multiples imbriquÃ©es

Une **autre diffÃ©rence intÃ©ressante** avec le HTTP Request Smuggling classique est que, dans une attaque de smuggling classique, l'**objectif** est de **modifier le dÃ©but de la requÃªte de la victime** pour qu'elle effectue une action inattendue. Dans une **attaque de HTTP Response Smuggling**, comme vous **envoyez des requÃªtes complÃ¨tes**, vous pouvez **injecter dans une seule charge utile des dizaines de rÃ©ponses** qui vont **dÃ©synchroniser des dizaines d'utilisateurs** qui vont **recevoir** les **rÃ©ponses injectÃ©es**.

En plus de pouvoir **distribuer plus facilement des dizaines d'exploits** parmi les utilisateurs lÃ©gitimes, cela pourrait Ã©galement Ãªtre utilisÃ© pour provoquer un **DoS** sur le serveur.

### Organisation de l'exploit

Comme expliquÃ© prÃ©cÃ©demment, pour abuser de cette technique, il est nÃ©cessaire que le **premier message introduit** dans le serveur **nÃ©cessite beaucoup de temps pour Ãªtre traitÃ©**.

Cette **requÃªte chronophage est suffisante** si nous voulons juste **essayer de voler la rÃ©ponse de la victime.** Mais si vous voulez rÃ©aliser un exploit plus complexe, voici une structure commune pour l'exploit.

Tout d'abord la **requÃªte initiale** abusant du **HTTP Request Smuggling**, puis la **requÃªte chronophage** et ensuite **1 ou plusieurs requÃªtes de charge utile** dont les rÃ©ponses seront envoyÃ©es aux victimes.

## Exploitation de la dÃ©synchronisation de la file d'attente des rÃ©ponses HTTP

### Capturer les requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Comme avec les charges utiles connues de HTTP Request Smuggling, vous pouvez **voler la requÃªte de la victime** avec une diffÃ©rence importante : dans ce cas, vous avez juste besoin d'**envoyer du contenu pour qu'il soit reflÃ©tÃ© dans la rÃ©ponse**, **aucun stockage persistant** n'est nÃ©cessaire.

D'abord, l'attaquant envoie une charge utile contenant une **requÃªte POST finale avec le paramÃ¨tre reflÃ©tÃ©** Ã  la fin et une grande Content-Length

![](<../.gitbook/assets/image (625).png>)

Ensuite, une fois la **requÃªte initiale** (bleue) **traitÃ©e** et **pendant** que celle **endormie** est en cours de traitement (jaune), la **prochaine requÃªte qui arrive d'une victime** va Ãªtre **ajoutÃ©e dans la file d'attente juste aprÃ¨s le paramÃ¨tre reflÃ©tÃ©** :

![](<../.gitbook/assets/image (634) (1).png>)

Ensuite, la **victime** **recevra** la **rÃ©ponse Ã  la requÃªte endormie** et si entre-temps l'**attaquant** **envoie** **une autre** **requÃªte**, la **rÃ©ponse du contenu reflÃ©tÃ© sera envoyÃ©e Ã  lui**.

## DÃ©synchronisation des rÃ©ponses

Jusqu'Ã  prÃ©sent, nous avons appris Ã  exploiter les attaques de HTTP Request Smuggling pour **contrÃ´ler** la **requÃªte** **dont** la **rÃ©ponse** va Ãªtre **reÃ§ue** par un **client** et comment vous pouvez ensuite **voler la rÃ©ponse qui Ã©tait destinÃ©e Ã  la victime**.

Mais il est encore possible de **dÃ©synchroniser encore plus** les rÃ©ponses.

Il existe des requÃªtes intÃ©ressantes comme la requÃªte **HEAD** qui sont spÃ©cifiÃ©es pour ne pas avoir **de contenu Ã  l'intÃ©rieur du corps des rÃ©ponses** et qui doivent (doivent) **contenir le Content-Length** de la requÃªte comme **si c'Ã©tait une requÃªte GET**.

Par consÃ©quent, si un attaquant **injecte** une **requÃªte HEAD**, comme dans ces images :

![](<../.gitbook/assets/image (626).png>)

Ensuite, **une fois que la bleue est rÃ©pondue Ã  l'attaquant**, la prochaine requÃªte de la victime va Ãªtre introduite dans la file d'attente :

![](<../.gitbook/assets/image (651) (1) (1) (1) (1) (1) (1).png>)

Ensuite, la **victime** **recevra** la **rÃ©ponse** de la **requÃªte HEAD**, qui va **contenir un Content-Length mais pas de contenu du tout**. Par consÃ©quent, le proxy **n'enverra pas cette rÃ©ponse** Ã  la victime, mais **attendra** un **contenu**, qui en rÃ©alitÃ© va Ãªtre **la rÃ©ponse Ã  la requÃªte jaune** (Ã©galement injectÃ©e par l'attaquant) :

![](<../.gitbook/assets/image (627) (1).png>)

### Confusion de contenu

Suivant l'exemple prÃ©cÃ©dent, sachant que vous pouvez **contrÃ´ler le corps** de la requÃªte dont la rÃ©ponse va Ãªtre reÃ§ue par la victime et qu'une **rÃ©ponse HEAD** contient habituellement dans ses en-tÃªtes le **Content-Type et le Content-Length**, vous pouvez **envoyer une requÃªte comme la suivante** pour **provoquer un XSS** chez la victime sans que la page soit vulnÃ©rable au XSS :

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### Empoisonnement du cache

En abusant de l'attaque de dÃ©synchronisation de rÃ©ponse et de confusion de contenu prÃ©cÃ©demment commentÃ©e, **si le cache stocke la rÃ©ponse Ã  la requÃªte effectuÃ©e par la victime et que cette rÃ©ponse est une rÃ©ponse injectÃ©e provoquant un XSS, alors le cache est empoisonnÃ©**.

RequÃªte malveillante contenant la charge utile XSS :

![](<../.gitbook/assets/image (644) (1).png>)

RÃ©ponse malveillante Ã  la victime qui contient l'en-tÃªte indiquant au cache de stocker la rÃ©ponse :

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
Notez que dans ce cas, si le **"victime" est l'attaquant**, il peut maintenant effectuer **l'empoisonnement du cache sur des URL arbitraires** car il peut **contrÃ´ler l'URL qui va Ãªtre mise en cache** avec la rÃ©ponse malveillante.
{% endhint %}

### Tromperie du cache Web

Cette attaque est similaire Ã  la prÃ©cÃ©dente, mais **au lieu d'injecter une charge utile dans le cache, l'attaquant va mettre en cache des informations de la victime Ã  l'intÃ©rieur du cache** :

![](<../.gitbook/assets/image (643) (1) (1).png>)

### SÃ©paration de rÃ©ponse

L'**objectif** de cette attaque est d'abuser Ã  nouveau de la **dÃ©synchronisation des rÃ©ponses** afin de **faire envoyer par le proxy une rÃ©ponse gÃ©nÃ©rÃ©e Ã  100% par l'attaquant**.

Pour y parvenir, l'attaquant doit trouver un point de terminaison de l'application web qui **reflÃ¨te certaines valeurs Ã  l'intÃ©rieur de la rÃ©ponse** et **connaÃ®tre la longueur du contenu de la rÃ©ponse HEAD**.

Il enverra un **exploit** comme :

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

AprÃ¨s que la premiÃ¨re requÃªte soit rÃ©solue et renvoyÃ©e Ã  l'attaquant, la **requÃªte de la victime est ajoutÃ©e dans la file d'attente** :

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

La victime recevra comme rÃ©ponse la **rÃ©ponse HEAD + le contenu de la rÃ©ponse de la deuxiÃ¨me requÃªte (contenant une partie des donnÃ©es reflÃ©tÃ©es) :**

![](<../.gitbook/assets/image (633) (1).png>)

Cependant, notez comment les **donnÃ©es reflÃ©tÃ©es avaient une taille selon le Content-Length** de la **rÃ©ponse HEAD** qui **a gÃ©nÃ©rÃ© une rÃ©ponse HTTP valide dans la file d'attente des rÃ©ponses**.

Par consÃ©quent, la **prochaine requÃªte de la deuxiÃ¨me victime** va **recevoir** comme **rÃ©ponse quelque chose complÃ¨tement fabriquÃ© par l'attaquant**. Comme la rÃ©ponse est complÃ¨tement fabriquÃ©e par l'attaquant, il peut aussi **faire en sorte que le proxy mette la rÃ©ponse en cache**.

## RÃ©fÃ©rences

* N'oubliez pas de regarder cette vidÃ©o expliquant toutes ces techniques trÃ¨s bien : [https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux dÃ©pÃ´ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
