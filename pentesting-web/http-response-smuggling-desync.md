# Smuggling / DÃ©synchronisation des RÃ©ponses HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en Ã©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts GitHub.

</details>

**La technique de ce post a Ã©tÃ© tirÃ©e de la vidÃ©o :** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## DÃ©synchronisation de la File d'Attente des RequÃªtes HTTP

Tout d'abord, cette technique **exploite une vulnÃ©rabilitÃ© de Smuggling de RequÃªtes HTTP**, donc vous devez savoir ce que c'est :

La **principale** **diffÃ©rence** entre cette technique et un Smuggling de RequÃªtes HTTP classique est que **au lieu d'attaquer la requÃªte de la victime en lui ajoutant un prÃ©fixe**, nous allons **dÃ©voiler ou modifier la rÃ©ponse que la victime reÃ§oit**. Cela se fait en envoyant non pas 1 requÃªte et demie pour abuser du Smuggling de RequÃªtes HTTP, mais **en envoyant 2 requÃªtes complÃ¨tes pour dÃ©synchroniser la file des rÃ©ponses des proxys**.

Cela est dÃ» au fait que nous allons Ãªtre en mesure de **dÃ©synchroniser la file des rÃ©ponses** afin que la **rÃ©ponse** de la **requÃªte lÃ©gitime de la victime soit envoyÃ©e Ã  l'attaquant**, ou en **injectant un contenu contrÃ´lÃ© par l'attaquant dans la rÃ©ponse Ã  la victime**.

### DÃ©synchronisation de la File d'Attente des Pipelines HTTP

HTTP/1.1 permet de demander **diffÃ©rentes ressources sans attendre les prÃ©cÃ©dentes**. Par consÃ©quent, s'il y a un **proxy** au **milieu**, c'est au proxy de **maintenir une correspondance synchronisÃ©e des requÃªtes envoyÃ©es au backend et des rÃ©ponses qui en proviennent**.

Cependant, il y a un problÃ¨me de dÃ©synchronisation de la file des rÃ©ponses. Si un attaquant envoie une attaque de Smuggling de RÃ©ponses HTTP et que les rÃ©ponses Ã  la **requÃªte initiale et Ã  celle smugglÃ©e sont rÃ©pondues immÃ©diatement**, la rÃ©ponse smugglÃ©e ne sera pas insÃ©rÃ©e dans la file de rÃ©ponse de la victime mais sera **simplement rejetÃ©e comme une erreur**.

![](<../.gitbook/assets/image (633).png>)

Il est donc nÃ©cessaire que la **requÃªte smugglÃ©e prenne plus de temps Ã  Ãªtre traitÃ©e** dans le serveur backend. Par consÃ©quent, au moment oÃ¹ la requÃªte smugglÃ©e est traitÃ©e, la communication avec l'attaquant sera terminÃ©e.

Dans cette situation spÃ©cifique, si une **victime a envoyÃ© une requÃªte** et que la **requÃªte smugglÃ©e est rÃ©pondue avant** la requÃªte lÃ©gitime, la **rÃ©ponse smugglÃ©e sera envoyÃ©e Ã  la victime**. Par consÃ©quent, l'attaquant va **contrÃ´ler la requÃªte "effectuÃ©e" par la victime**.

De plus, si l'**attaquant effectue ensuite une requÃªte** et que la **rÃ©ponse lÃ©gitime** Ã  la **requÃªte de la victime est rÃ©pondue avant** la requÃªte de l'attaquant. La **rÃ©ponse Ã  la victime sera envoyÃ©e Ã  l'attaquant**, **volant** la rÃ©ponse Ã  la victime (qui peut contenir par exemple l'en-tÃªte **Set-Cookie**).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Injections Multiples et EmboÃ®tÃ©es

Une autre **diffÃ©rence intÃ©ressante** avec le **Smuggling de RequÃªtes HTTP** classique est que, dans une attaque de Smuggling classique, le **but** est de **modifier le dÃ©but de la requÃªte de la victime** pour qu'elle effectue une action inattendue. Dans une attaque de **Smuggling de RÃ©ponses HTTP**, comme vous **envoyez des requÃªtes complÃ¨tes**, vous pouvez **injecter dans une charge utile des dizaines de rÃ©ponses** qui vont **dÃ©synchroniser des dizaines d'utilisateurs** qui vont **recevoir les rÃ©ponses injectÃ©es**.

En plus de pouvoir **distribuer plus facilement des dizaines d'exploits** parmi les utilisateurs lÃ©gitimes, cela pourrait Ã©galement Ãªtre utilisÃ© pour provoquer un **DÃ©ni de Service** sur le serveur.

### Organisation de l'Exploitation

Comme expliquÃ© prÃ©cÃ©demment, pour exploiter cette technique, il est nÃ©cessaire que le **premier message smugglÃ©** dans le serveur **prenne beaucoup de temps Ã  Ãªtre traitÃ©**.

Cette **requÃªte chronophage est suffisante** si vous voulez simplement **essayer de voler la rÃ©ponse de la victime**. Mais si vous voulez effectuer un exploit plus complexe, voici une structure commune pour l'exploit.

Tout d'abord, la **requÃªte initiale** abusant du **Smuggling de RequÃªtes HTTP**, puis la **requÃªte chronophage** et ensuite **1 ou plusieurs requÃªtes de charge utile** dont les rÃ©ponses seront envoyÃ©es aux victimes.

## Abus de la DÃ©synchronisation de la File d'Attente des RÃ©ponses HTTP

### Capture des requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Comme pour les charges utiles connues de Smuggling de RequÃªtes HTTP, vous pouvez **voler la requÃªte de la victime** avec une diffÃ©rence importante : dans ce cas, vous avez juste besoin que le **contenu envoyÃ© soit reflÃ©tÃ© dans la rÃ©ponse**, **aucun stockage persistant** n'est nÃ©cessaire.

Tout d'abord, l'attaquant envoie une charge utile contenant une **derniÃ¨re requÃªte POST avec le paramÃ¨tre reflÃ©tÃ©** Ã  la fin et un grand Content-Length

![](<../.gitbook/assets/image (1053).png>)

Ensuite, une fois que la **requÃªte initiale** (bleue) a Ã©tÃ© **traitÃ©e** et **pendant que** la **requÃªte endormie** est en cours de traitement (jaune), la **prochaine requÃªte qui arrive d'une victime** va Ãªtre **ajoutÃ©e dans la file juste aprÃ¨s le paramÃ¨tre reflÃ©tÃ©** :

![](<../.gitbook/assets/image (794).png>)

Ensuite, la **victime** va **recevoir** la **rÃ©ponse Ã  la requÃªte endormie** et si entre-temps l'**attaquant envoie une autre requÃªte**, la **rÃ©ponse de la requÃªte de contenu reflÃ©tÃ© lui sera envoyÃ©e**.

## DÃ©synchronisation des RÃ©ponses

Jusqu'Ã  prÃ©sent, nous avons appris comment abuser des attaques de Smuggling de RequÃªtes HTTP pour **contrÃ´ler** la **requÃªte dont** la **rÃ©ponse** qu'un **client va recevoir** et comment vous pouvez ensuite **voler la rÃ©ponse qui Ã©tait destinÃ©e Ã  la victime**.

Mais il est toujours possible de **dÃ©synchroniser encore plus** les rÃ©ponses.

Il existe des requÃªtes intÃ©ressantes comme la requÃªte **HEAD** qui sont spÃ©cifiÃ©es pour ne pas avoir **de contenu dans le corps des rÃ©ponses** et qui devraient (doivent) **contenir la longueur du contenu** de la requÃªte comme **si c'Ã©tait une requÃªte GET**.

Par consÃ©quent, si un attaquant **injecte** une requÃªte **HEAD**, comme dans ces images :

![](<../.gitbook/assets/image (1107).png>)

Ensuite, **une fois que la requÃªte bleue est rÃ©pondue Ã  l'attaquant**, la prochaine requÃªte de la victime va Ãªtre introduite dans la file :

![](<../.gitbook/assets/image (999).png>)

Ensuite, la **victime** va **recevoir** la **rÃ©ponse** de la **requÃªte HEAD**, qui **va contenir une longueur de contenu mais aucun contenu du tout**. Par consÃ©quent, le proxy **ne va pas envoyer cette rÃ©ponse** Ã  la victime, mais va **attendre** un **contenu**, qui sera en fait la **rÃ©ponse Ã  la requÃªte jaune** (Ã©galement injectÃ©e par l'attaquant) :

![](<../.gitbook/assets/image (735).png>)
### Confusion de contenu

Suivant l'exemple prÃ©cÃ©dent, sachant que vous pouvez **contrÃ´ler le corps** de la requÃªte dont la rÃ©ponse va recevoir la victime et qu'une rÃ©ponse **HEAD** contient gÃ©nÃ©ralement dans ses en-tÃªtes le **Content-Type et le Content-Length**, vous pouvez **envoyer une requÃªte comme celle-ci** pour **causer une XSS** chez la victime sans que la page soit vulnÃ©rable Ã  la XSS :

![](<../.gitbook/assets/image (688).png>)

### Empoisonnement de cache

Abusant de l'attaque de confusion de contenu par dÃ©synchronisation de rÃ©ponse prÃ©cÃ©demment commentÃ©e, **si le cache stocke la rÃ©ponse Ã  la requÃªte effectuÃ©e par la victime et que cette rÃ©ponse est une injection provoquant une XSS, alors le cache est empoisonnÃ©**.

RequÃªte malveillante contenant la charge utile XSS :

![](<../.gitbook/assets/image (614).png>)

RÃ©ponse malveillante Ã  la victime contenant l'en-tÃªte indiquant au cache de stocker la rÃ©ponse :

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Notez que dans ce cas si le **"victim" est l'attaquant** il peut maintenant effectuer **l'empoisonnement de cache dans des URL arbitraires** car il peut **contrÃ´ler l'URL qui va Ãªtre mise en cache** avec la rÃ©ponse malveillante.
{% endhint %}

### Tromperie de cache Web

Cette attaque est similaire Ã  la prÃ©cÃ©dente, mais **au lieu d'injecter une charge utile dans le cache, l'attaquant mettra en cache des informations de la victime Ã  l'intÃ©rieur du cache :**

![](<../.gitbook/assets/image (991).png>)

### Fractionnement de rÃ©ponse

Le **but** de cette attaque est d'abuser Ã  nouveau de la **dÃ©synchronisation de rÃ©ponse** pour **faire en sorte que le proxy envoie une rÃ©ponse 100% gÃ©nÃ©rÃ©e par l'attaquant**.

Pour y parvenir, l'attaquant doit trouver un point de terminaison de l'application Web qui **reflÃ¨te certaines valeurs dans la rÃ©ponse** et **connaÃ®tre la longueur du contenu de la rÃ©ponse HEAD**.

Il enverra un **exploit** comme suit :

![](<../.gitbook/assets/image (911).png>)

AprÃ¨s que la premiÃ¨re requÃªte soit rÃ©solue et renvoyÃ©e Ã  l'attaquant, la **requÃªte de la victime est ajoutÃ©e Ã  la file d'attente** :

![](<../.gitbook/assets/image (737).png>)

La victime recevra en rÃ©ponse le **HEAD response + le contenu de la deuxiÃ¨me rÃ©ponse de la requÃªte (contenant une partie des donnÃ©es rÃ©flÃ©chies) :**

![](<../.gitbook/assets/image (356).png>)

Cependant, notez comment les **donnÃ©es rÃ©flÃ©chies avaient une taille conforme au Content-Length** de la rÃ©ponse **HEAD** qui **a gÃ©nÃ©rÃ© une rÃ©ponse HTTP valide dans la file de rÃ©ponses**.

Par consÃ©quent, la **prochaine requÃªte du deuxiÃ¨me victime** recevra en **rÃ©ponse quelque chose entiÃ¨rement fabriquÃ© par l'attaquant**. Comme la rÃ©ponse est entiÃ¨rement fabriquÃ©e par l'attaquant, il peut Ã©galement **faire en sorte que le proxy mette en cache la rÃ©ponse**.
