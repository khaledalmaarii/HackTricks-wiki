# Smuggling / DÃ©synchronisation des RÃ©ponses HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zÃ©ro Ã  hÃ©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en Ã©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres faÃ§ons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ou **tÃ©lÃ©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* DÃ©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** ğŸ’¬ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dÃ©pÃ´ts GitHub.

</details>

**La technique de ce post a Ã©tÃ© tirÃ©e de la vidÃ©o : [https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)**

## DÃ©synchronisation de la File d'Attente des RequÃªtes HTTP

Tout d'abord, cette technique **exploite une vulnÃ©rabilitÃ© de Smuggling de RequÃªtes HTTP**, donc vous devez savoir ce que c'est :

La **principale** **diffÃ©rence** entre cette technique et un Smuggling de RequÃªtes HTTP classique est que **au lieu d'attaquer la requÃªte de la victime en lui ajoutant un prÃ©fixe**, nous allons **dÃ©voiler ou modifier la rÃ©ponse que la victime reÃ§oit**. Cela se fait en envoyant non pas 1 requÃªte et demie pour abuser du Smuggling de RequÃªtes HTTP, mais **en envoyant 2 requÃªtes complÃ¨tes pour dÃ©synchroniser la file des rÃ©ponses des proxies**.

Cela est dÃ» au fait que nous allons Ãªtre en mesure de **dÃ©synchroniser la file des rÃ©ponses** afin que la **rÃ©ponse** de la **requÃªte lÃ©gitime de la victime soit envoyÃ©e Ã  l'attaquant**, ou en **injectant du contenu contrÃ´lÃ© par l'attaquant dans la rÃ©ponse Ã  la victime**.

### DÃ©synchronisation de la File d'Attente des Pipelines HTTP

HTTP/1.1 permet de demander **diffÃ©rentes ressources sans attendre les prÃ©cÃ©dentes**. Par consÃ©quent, s'il y a un **proxy** au **milieu**, c'est au proxy de **maintenir une correspondance synchronisÃ©e des requÃªtes envoyÃ©es au backend et des rÃ©ponses qui en proviennent**.

Cependant, il y a un problÃ¨me de dÃ©synchronisation de la file des rÃ©ponses. Si un attaquant envoie une attaque de Smuggling de RÃ©ponses HTTP et que les rÃ©ponses Ã  la **requÃªte initiale et Ã  celle smugglÃ©e sont rÃ©pondues immÃ©diatement**, la rÃ©ponse smugglÃ©e ne sera pas insÃ©rÃ©e dans la file de rÃ©ponse de la victime mais sera **simplement rejetÃ©e comme une erreur**.

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

Par consÃ©quent, il est nÃ©cessaire que la **requÃªte smugglÃ©e prenne plus de temps Ã  Ãªtre traitÃ©e** Ã  l'intÃ©rieur du serveur backend. Ainsi, au moment oÃ¹ la requÃªte smugglÃ©e est traitÃ©e, la communication avec l'attaquant sera terminÃ©e.

Dans cette situation spÃ©cifique, si une **victime a envoyÃ© une requÃªte** et que la **requÃªte smugglÃ©e est rÃ©pondue avant** la requÃªte lÃ©gitime, la **rÃ©ponse smugglÃ©e sera envoyÃ©e Ã  la victime**. Par consÃ©quent, l'attaquant va **contrÃ´ler la requÃªte "effectuÃ©e" par la victime**.

De plus, si l'**attaquant effectue ensuite une requÃªte** et que la **rÃ©ponse lÃ©gitime** Ã  la **requÃªte de la victime est rÃ©pondue avant** la requÃªte de l'attaquant. La **rÃ©ponse Ã  la victime sera envoyÃ©e Ã  l'attaquant**, **volant** la rÃ©ponse Ã  la victime (qui peut contenir par exemple l'en-tÃªte **Set-Cookie**).

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### Multiples Injections EmboÃ®tÃ©es

Une autre **diffÃ©rence intÃ©ressante** avec le **Smuggling de RequÃªtes HTTP** classique est que, dans une attaque de Smuggling classique, le **but** est de **modifier le dÃ©but de la requÃªte de la victime** pour qu'elle effectue une action inattendue. Dans une **attaque de Smuggling de RÃ©ponses HTTP**, comme vous **envoyez des requÃªtes complÃ¨tes**, vous pouvez **injecter dans une charge utile des dizaines de rÃ©ponses** qui vont **dÃ©synchroniser des dizaines d'utilisateurs** qui vont **recevoir** les **rÃ©ponses** **injectÃ©es**.

En plus de pouvoir **distribuer plus facilement des dizaines d'exploits** parmi les utilisateurs lÃ©gitimes, cela pourrait Ã©galement Ãªtre utilisÃ© pour provoquer un **DÃ©ni de Service (DoS)** sur le serveur.

### Organisation de l'Exploitation

Comme expliquÃ© prÃ©cÃ©demment, pour exploiter cette technique, il est nÃ©cessaire que le **premier message smugglÃ©** dans le serveur **nÃ©cessite beaucoup de temps pour Ãªtre traitÃ©**.

Cette **requÃªte chronophage est suffisante** si vous voulez simplement **essayer de voler la rÃ©ponse des victimes**. Mais si vous voulez effectuer un exploit plus complexe, voici une structure commune pour l'exploit.

Tout d'abord, la **requÃªte initiale exploitant le Smuggling de RequÃªtes HTTP**, puis la **requÃªte chronophage** et ensuite **1 ou plusieurs requÃªtes de charge utile** dont les rÃ©ponses seront envoyÃ©es aux victimes.

## Abus de la DÃ©synchronisation de la File d'Attente des RÃ©ponses HTTP

### Capture des requÃªtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Comme pour les charges utiles connues du Smuggling de RequÃªtes HTTP, vous pouvez **voler la requÃªte des victimes** avec une diffÃ©rence importante : dans ce cas, vous avez juste besoin que le **contenu envoyÃ© soit reflÃ©tÃ© dans la rÃ©ponse**, **aucun stockage persistant** n'est nÃ©cessaire.

Tout d'abord, l'attaquant envoie une charge utile contenant une **derniÃ¨re requÃªte POST avec le paramÃ¨tre reflÃ©tÃ©** Ã  la fin et une longue Content-Length

![](<../.gitbook/assets/image (625).png>)

Ensuite, une fois que la **requÃªte initiale** (bleue) a Ã©tÃ© **traitÃ©e** et **pendant que** la **requÃªte chronophage** est en cours de traitement (jaune), la **prochaine requÃªte qui arrive d'une victime** va Ãªtre **ajoutÃ©e dans la file juste aprÃ¨s le paramÃ¨tre reflÃ©tÃ©** :

![](<../.gitbook/assets/image (634) (1).png>)

Ensuite, la **victime** va **recevoir** la **rÃ©ponse Ã  la requÃªte chronophage** et si entre-temps l'**attaquant envoie une autre requÃªte**, la **rÃ©ponse de la requÃªte de contenu reflÃ©tÃ© lui sera envoyÃ©e**.

## DÃ©synchronisation des RÃ©ponses

Jusqu'Ã  prÃ©sent, nous avons appris comment exploiter les attaques de Smuggling de RequÃªtes HTTP pour **contrÃ´ler** la **requÃªte dont** la **rÃ©ponse** qu'un **client** va **recevoir** et comment vous pouvez ensuite **voler la rÃ©ponse qui Ã©tait destinÃ©e Ã  la victime**.

Mais il est toujours possible de **dÃ©synchroniser encore plus** les rÃ©ponses.

Il existe des requÃªtes intÃ©ressantes comme la requÃªte **HEAD** qui sont spÃ©cifiÃ©es pour ne pas avoir **de contenu dans le corps des rÃ©ponses** et qui devraient (doivent) **contenir la Content-Length** de la requÃªte comme **si c'Ã©tait une requÃªte GET**.

Par consÃ©quent, si un attaquant **injecte** une requÃªte **HEAD**, comme dans ces images :

![](<../.gitbook/assets/image (626).png>)

Ensuite, **une fois que la requÃªte bleue est rÃ©pondue Ã  l'attaquant**, la prochaine requÃªte de la victime va Ãªtre introduite dans la file :

![](<../.gitbook/assets/image (651) (1) (1) (1) (1) (1) (1).png>)

Ensuite, la **victime** va **recevoir** la **rÃ©ponse** de la **requÃªte HEAD**, qui va **contenir une Content-Length mais aucun contenu du tout**. Par consÃ©quent, le proxy **ne va pas envoyer cette rÃ©ponse** Ã  la victime, mais va **attendre** un **contenu**, qui sera en fait la **rÃ©ponse Ã  la requÃªte jaune** (Ã©galement injectÃ©e par l'attaquant) :

![](<../.gitbook/assets/image (627) (1).png>)

### Confusion de Contenu

En suivant l'exemple prÃ©cÃ©dent, sachant que vous pouvez **contrÃ´ler le corps** de la requÃªte dont la rÃ©ponse va Ãªtre reÃ§ue par la victime et qu'une **rÃ©ponse HEAD** **contient gÃ©nÃ©ralement dans ses en-tÃªtes le Content-Type et la Content-Length**, vous pouvez **envoyer une requÃªte comme celle-ci** pour **causer une XSS** chez la victime sans que la page soit vulnÃ©rable Ã  la XSS :

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### Empoisonnement de Cache

En exploitant l'attaque de Confusion de Contenu de dÃ©synchronisation de la rÃ©ponse prÃ©cÃ©demment commentÃ©e, **si le cache stocke la rÃ©ponse Ã  la requÃªte effectuÃ©e par la victime et que cette rÃ©ponse est une rÃ©ponse injectÃ©e provoquant une XSS, alors le cache est empoisonnÃ©**.

RequÃªte malveillante contenant la charge utile XSS :

![](<../.gitbook/assets/image (644) (1).png>)

RÃ©ponse malveillante Ã  la victime contenant l'en-tÃªte indiquant au cache de stocker la rÃ©ponse :

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
Notez que dans ce cas, si le **"victim" est l'attaquant**, il peut maintenant effectuer un **empoisonnement de cache dans des URL arbitraires** car il peut **contrÃ´ler l'URL qui va Ãªtre mise en cache** avec la rÃ©ponse malveillante.
{% endhint %}

### Tromperie de Cache Web

Cette attaque est similaire Ã  la prÃ©cÃ©dente, mais **au lieu d'injecter une charge utile dans le cache, l'attaquant va mettre en cache des informations de la victime Ã  l'intÃ©rieur du cache :**

![](<../.gitbook/assets/image (643) (1) (1).png>)

### Fractionnement de RÃ©ponse

Le **but** de cette attaque est d'exploiter Ã  nouveau la **dÃ©synchronisation de la rÃ©ponse** afin de **faire envoyer au proxy une rÃ©ponse 100% gÃ©nÃ©rÃ©e par l'attaquant**.

Pour y parvenir, l'attaquant doit trouver un point de terminaison de l'application web qui **reflÃ¨te certaines valeurs dans la rÃ©ponse** et **connaÃ®tre la longueur du contenu de la rÃ©ponse HEAD**.

Il enverra un **exploit** comme :

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

AprÃ¨s que la premiÃ¨re requÃªte soit rÃ©solue et renvoyÃ©e Ã  l'attaquant, la **requÃªte de la victime est ajoutÃ©e Ã  la file** :

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

La victime recevra en rÃ©ponse le **HEAD response + le contenu de la rÃ©ponse de la deuxiÃ¨me requÃªte (contenant une partie des donnÃ©es reflÃ©tÃ©es) :**

![](<../.gitbook/assets/image (633) (1).png>)

Cependant, notez comment les **donnÃ©es reflÃ©tÃ©es avaient une taille conforme Ã  la Content-Length** de la **rÃ©ponse HEAD qui a gÃ©nÃ©rÃ© une rÃ©ponse HTTP valide dans la file de rÃ©ponse**.

Par consÃ©quent, la **prochaine requÃªte du deuxiÃ¨me victime** va **recevoir** en **rÃ©ponse quelque chose entiÃ¨rement fabriquÃ© par l'attaquant**. Comme la rÃ©ponse est entiÃ¨rement fabriquÃ©e par l'attaquant, il peut Ã©galement **faire en sorte que le proxy mette en cache la rÃ©ponse**.
