# HTTP Response Smuggling / Desync

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

**A t√©cnica deste post foi retirada do v√≠deo:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## Desincroniza√ß√£o da Fila de Requisi√ß√µes HTTP

Primeiramente, esta t√©cnica **explora uma vulnerabilidade de HTTP Request Smuggling**, ent√£o voc√™ precisa saber o que √©:

A **principal** **diferen√ßa** entre esta t√©cnica e um comum HTTP Request smuggling √© que **em vez** de **atacar** a **requisi√ß√£o** da **v√≠tima** **adicionando um prefixo a ela**, n√≥s vamos **vazar ou modificar a resposta que a v√≠tima recebe**. Isso √© feito ao inv√©s de enviar 1 requisi√ß√£o e meia para abusar do HTTP Request smuggling, **enviar 2 requisi√ß√µes completas para desincronizar a fila de respostas dos proxies**.

Isso ocorre porque vamos conseguir **desincronizar a fila de respostas** para que a **resposta** da **requisi√ß√£o** **leg√≠tima** da **v√≠tima seja enviada ao atacante**, ou **injetando conte√∫do controlado pelo atacante na resposta para a v√≠tima**.

### Desync do Pipeline HTTP

HTTP/1.1 permite solicitar **recursos diferentes sem precisar esperar pelos anteriores**. Portanto, se houver um **proxy** no **meio**, √© tarefa dos proxies **manter uma correspond√™ncia sincronizada das requisi√ß√µes enviadas para o backend e as respostas que v√™m dele**.

No entanto, h√° um problema em desincronizar a fila de respostas. Se um atacante enviar um ataque de HTTP Response smuggling e as respostas para a **requisi√ß√£o inicial e a smuggled forem respondidas imediatamente**, a resposta smuggled n√£o ser√° inserida na fila de resposta da v√≠tima, mas ser√° **apenas descartada como um erro**.

![](<../.gitbook/assets/image (633).png>)

Portanto, √© necess√°rio que a **requisi√ß√£o smuggled** **demore mais tempo para ser processada** dentro do servidor backend. Assim, quando a requisi√ß√£o smuggled for processada, a comunica√ß√£o com o atacante j√° ter√° terminado.

Se nesta situa√ß√£o espec√≠fica uma **v√≠tima enviou uma requisi√ß√£o** e a **requisi√ß√£o smuggled for respondida antes** da requisi√ß√£o leg√≠tima, a **resposta smuggled ser√° enviada para a v√≠tima**. Portanto, o atacante estar√° **controlando a requisi√ß√£o "realizada" pela v√≠tima**.

Al√©m disso, se o **atacante ent√£o realizar uma requisi√ß√£o** e a **resposta leg√≠tima** para a **requisi√ß√£o** da **v√≠tima** for **respondida** **antes** da requisi√ß√£o do atacante. A **resposta para a v√≠tima ser√° enviada ao atacante**, **roubando** a resposta da v√≠tima (que pode conter, por exemplo, o cabe√ßalho **Set-Cookie**).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Inje√ß√µes M√∫ltiplas Aninhadas

Outra **diferen√ßa interessante** com o comum **HTTP Request Smuggling** √© que, em um ataque comum de smuggling, o **objetivo** √© **modificar o in√≠cio da requisi√ß√£o da v√≠tima** para que ela realize uma a√ß√£o inesperada. Em um **ataque de HTTP Response smuggling**, como voc√™ est√° **enviando requisi√ß√µes completas**, voc√™ pode **injetar em um payload dezenas de respostas** que estar√£o **desincronizando dezenas de usu√°rios** que estar√£o **recebendo** as **respostas injetadas**.

Al√©m de poder **distribuir mais facilmente dezenas de exploits** entre usu√°rios leg√≠timos, isso tamb√©m pode ser usado para causar um **DoS** no servidor.

### Organiza√ß√£o do Exploit

Como explicado anteriormente, para abusar desta t√©cnica, √© necess√°rio que a **primeira mensagem smuggled** no servidor **exija muito tempo para ser processada**.

Esta **requisi√ß√£o que consome tempo √© suficiente** se apenas quisermos **tentar roubar a resposta da v√≠tima.** Mas se voc√™ quiser realizar um exploit mais complexo, esta ser√° uma estrutura comum para o exploit.

Primeiramente a **requisi√ß√£o inicial** abusando do **HTTP** **Request** **smuggling**, em seguida a **requisi√ß√£o que consome tempo** e depois **1 ou mais requisi√ß√µes payload** cujas respostas ser√£o enviadas para as v√≠timas.

## Abusando da Desincroniza√ß√£o da Fila de Respostas HTTP

### Capturando requisi√ß√µes de outros usu√°rios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Assim como com payloads conhecidos de HTTP Request Smuggling, voc√™ pode **roubar a requisi√ß√£o da v√≠tima** com uma diferen√ßa importante: Neste caso, voc√™ s√≥ precisa que o **conte√∫do enviado seja refletido na resposta**, **nenhum armazenamento persistente** √© necess√°rio.

Primeiro, o atacante envia um payload contendo uma **requisi√ß√£o POST final com o par√¢metro refletido** no final e um grande Content-Length

![](<../.gitbook/assets/image (1053).png>)

Ent√£o, uma vez que a **requisi√ß√£o inicial** (azul) foi **processada** e **enquanto** a **requisi√ß√£o lenta** est√° sendo processada (amarela), a **pr√≥xima requisi√ß√£o que chega de uma v√≠tima** ser√° **adicionada na fila logo ap√≥s o par√¢metro refletido**:

![](<../.gitbook/assets/image (794).png>)

Ent√£o, a **v√≠tima** receber√° a **resposta** para a **requisi√ß√£o lenta** e se, nesse meio tempo, o **atacante** **enviar** **outra** **requisi√ß√£o**, a **resposta da requisi√ß√£o de conte√∫do refletido ser√° enviada a ele**.

## Desincroniza√ß√£o da Resposta

At√© este ponto, aprendemos como abusar de ataques de HTTP Request Smuggling para **controlar** a **requisi√ß√£o** **cuja** **resposta** um **cliente** vai **receber** e como voc√™ pode ent√£o **roubar a resposta que era destinada √† v√≠tima**.

Mas ainda √© poss√≠vel **desincronizar ainda mais** as respostas.

Existem requisi√ß√µes interessantes como a **requisi√ß√£o HEAD** que s√£o especificadas para n√£o ter **nenhum conte√∫do dentro do corpo das respostas** e que devem (devem) **conter o Content-Length** da requisi√ß√£o como **se fosse uma requisi√ß√£o GET**.

Portanto, se um atacante **injeta** uma **requisi√ß√£o HEAD**, como nas imagens:

![](<../.gitbook/assets/image (1107).png>)

Ent√£o, **uma vez que a azul √© respondida ao atacante**, a pr√≥xima requisi√ß√£o da v√≠tima ser√° introduzida na fila:

![](<../.gitbook/assets/image (999).png>)

Ent√£o, a **v√≠tima** receber√° a **resposta** da **requisi√ß√£o HEAD**, que **vai conter um Content-Length mas nenhum conte√∫do**. Portanto, o proxy **n√£o enviar√° esta resposta** para a v√≠tima, mas **esperar√°** por algum **conte√∫do**, que na verdade ser√° a **resposta para a requisi√ß√£o amarela** (tamb√©m injetada pelo atacante):

![](<../.gitbook/assets/image (735).png>)

### Confus√£o de Conte√∫do

Seguindo o exemplo anterior, sabendo que voc√™ pode **controlar o corpo** da requisi√ß√£o cuja resposta a v√≠tima vai receber e que uma **resposta HEAD** geralmente cont√©m em seus cabe√ßalhos o **Content-Type e o Content-Length**, voc√™ pode **enviar uma requisi√ß√£o como a seguinte** para **causar XSS** na v√≠tima sem que a p√°gina seja vulner√°vel a XSS:

![](<../.gitbook/assets/image (688).png>)

### Envenenamento de Cache

Abusando do ataque de Confus√£o de Conte√∫do de desincroniza√ß√£o de resposta comentado anteriormente, **se o cache armazenar a resposta para a requisi√ß√£o realizada pela v√≠tima e essa resposta for uma injetada causando um XSS, ent√£o o cache est√° envenenado**.

Requisi√ß√£o maliciosa contendo o payload de XSS:

![](<../.gitbook/assets/image (614).png>)

Resposta maliciosa para a v√≠tima que cont√©m o cabe√ßalho que indica ao cache para armazenar a resposta:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Note que neste caso, se a **"v√≠tima" for o atacante**, ele pode agora realizar **envenenamento de cache em URLs arbitr√°rias** j√° que ele pode **controlar a URL que ser√° armazenada** com a resposta maliciosa.
{% endhint %}

### Engano de Cache Web

Este ataque √© semelhante ao anterior, mas **em vez de injetar um payload dentro do cache, o atacante estar√° armazenando informa√ß√µes da v√≠tima dentro do cache:**

![](<../.gitbook/assets/image (991).png>)

### Divis√£o de Resposta

O **objetivo** deste ataque √© abusar novamente da **desincroniza√ß√£o** da **resposta** para **fazer o proxy enviar uma resposta 100% gerada pelo atacante**.

Para alcan√ßar isso, o atacante precisa encontrar um endpoint da aplica√ß√£o web que esteja **refletindo alguns valores dentro da resposta** e **saber o tamanho do conte√∫do da resposta HEAD**.

Ele enviar√° um **exploit** como:

![](<../.gitbook/assets/image (911).png>)

Ap√≥s a primeira requisi√ß√£o ser resolvida e enviada de volta ao atacante, a **requisi√ß√£o da v√≠tima √© adicionada na fila**:

![](<../.gitbook/assets/image (737).png>)

A v√≠tima receber√° como resposta a **resposta HEAD + o conte√∫do da resposta da segunda requisi√ß√£o (contendo parte dos dados refletidos):**

![](<../.gitbook/assets/image (356).png>)

No entanto, note como os **dados refletidos tinham um tamanho de acordo com o Content-Length** da **resposta HEAD** que **gerou uma resposta HTTP v√°lida na fila de respostas**.

Portanto, a **pr√≥xima requisi√ß√£o do segundo v√≠tima** estar√° **recebendo** como **resposta algo completamente elaborado pelo atacante**. Como a resposta √© completamente elaborada pelo atacante, ele tamb√©m pode **fazer o proxy armazenar a resposta**.

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
