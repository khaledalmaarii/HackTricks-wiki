# OAuth zu Account√ºbernahme

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Grundinformationen <a href="#d4a8" id="d4a8"></a>

OAuth bietet verschiedene Versionen, mit grundlegenden Einblicken, die in der [OAuth 2.0-Dokumentation](https://oauth.net/2/) zug√§nglich sind. Diese Diskussion konzentriert sich haupts√§chlich auf den weit verbreiteten [OAuth 2.0 Autorisierungscode-Grant-Typ](https://oauth.net/2/grant-types/authorization-code/), der ein **Autorisierungsframework bereitstellt, das einer Anwendung den Zugriff auf oder die Durchf√ºhrung von Aktionen im Konto eines Benutzers in einer anderen Anwendung** (dem Autorisierungsserver) erm√∂glicht.

Betrachten wir eine hypothetische Website _**https://example.com**_, die **alle deine Social-Media-Beitr√§ge**, einschlie√ülich privater, anzeigen soll. Um dies zu erreichen, wird OAuth 2.0 verwendet. _https://example.com_ wird um deine Erlaubnis bitten, **auf deine Social-Media-Beitr√§ge zuzugreifen**. Folglich erscheint ein Zustimmungsbildschirm auf _https://socialmedia.com_, der die **angeforderten Berechtigungen und den Entwickler, der die Anfrage stellt, umrei√üt**. Nach deiner Genehmigung erh√§lt _https://example.com_ die F√§higkeit, **in deinem Namen auf deine Beitr√§ge zuzugreifen**.

Es ist wichtig, die folgenden Komponenten innerhalb des OAuth 2.0-Frameworks zu verstehen:

* **resource owner**: Du, als der **Benutzer/Entit√§t**, autorisierst den Zugriff auf deine Ressource, wie deine Social-Media-Konten.
* **resource server**: Der **Server, der authentifizierte Anfragen verwaltet**, nachdem die Anwendung ein `access token` im Namen des `resource owner` gesichert hat, z.B. **https://socialmedia.com**.
* **client application**: Die **Anwendung, die Autorisierung** vom `resource owner` anfordert, wie **https://example.com**.
* **authorization server**: Der **Server, der `access tokens`** an die `client application` nach erfolgreicher Authentifizierung des `resource owner` und Sicherstellung der Autorisierung ausgibt, z.B. **https://socialmedia.com**.
* **client\_id**: Ein √∂ffentlicher, eindeutiger Identifikator f√ºr die Anwendung.
* **client\_secret:** Ein vertraulicher Schl√ºssel, der nur der Anwendung und dem Autorisierungsserver bekannt ist, der zur Generierung von `access_tokens` verwendet wird.
* **response\_type**: Ein Wert, der **den angeforderten Token-Typ angibt**, wie `code`.
* **scope**: Der **Zugriffslevel**, den die `client application` vom `resource owner` anfordert.
* **redirect\_uri**: Die **URL, zu der der Benutzer nach der Autorisierung umgeleitet wird**. Diese muss in der Regel mit der vorab registrierten Umleitungs-URL √ºbereinstimmen.
* **state**: Ein Parameter, um **Daten w√§hrend der Umleitung des Benutzers zum und vom Autorisierungsserver aufrechtzuerhalten**. Seine Einzigartigkeit ist entscheidend, um als **CSRF-Schutzmechanismus** zu dienen.
* **grant\_type**: Ein Parameter, der **den Grant-Typ und den zur√ºckzugebenden Token-Typ angibt**.
* **code**: Der Autorisierungscode vom `authorization server`, der zusammen mit `client_id` und `client_secret` von der Client-Anwendung verwendet wird, um ein `access_token` zu erwerben.
* **access\_token**: Der **Token, den die Client-Anwendung f√ºr API-Anfragen** im Namen des `resource owner` verwendet.
* **refresh\_token**: Erm√∂glicht der Anwendung, **einen neuen `access_token` zu erhalten, ohne den Benutzer erneut zu fragen**.

### Ablauf

Der **tats√§chliche OAuth-Ablauf** verl√§uft wie folgt:

1. Du navigierst zu [https://example.com](https://example.com) und w√§hlst die Schaltfl√§che ‚ÄûMit Social Media integrieren‚Äú.
2. Die Seite sendet dann eine Anfrage an [https://socialmedia.com](https://socialmedia.com) und bittet um deine Genehmigung, damit die Anwendung von https://example.com auf deine Beitr√§ge zugreifen kann. Die Anfrage ist wie folgt strukturiert:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ihnen wird dann eine Zustimmungsseite angezeigt.  
4. Nach Ihrer Genehmigung sendet Social Media eine Antwort an die `redirect_uri` mit den Parametern `code` und `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com verwendet diesen `code`, zusammen mit seiner `client_id` und `client_secret`, um eine serverseitige Anfrage zu stellen, um ein `access_token` in Ihrem Namen zu erhalten, das den Zugriff auf die Berechtigungen erm√∂glicht, denen Sie zugestimmt haben:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Schlie√ülich endet der Prozess, wenn https://example.com Ihr `access_token` verwendet, um einen API-Aufruf an Social Media zu t√§tigen, um auf

## Schwachstellen <a href="#id-323a" id="id-323a"></a>

### Offene redirect\_uri <a href="#cc36" id="cc36"></a>

Die `redirect_uri` ist entscheidend f√ºr die Sicherheit in OAuth- und OpenID-Implementierungen, da sie angibt, wohin sensible Daten, wie Autorisierungscodes, nach der Autorisierung gesendet werden. Wenn sie falsch konfiguriert ist, k√∂nnte dies Angreifern erm√∂glichen, diese Anfragen an b√∂sartige Server umzuleiten, was einen Account Takeover erm√∂glicht.

Die Ausnutzungstechniken variieren je nach Validierungslogik des Autorisierungsservers. Sie k√∂nnen von striktem Pfadabgleich bis hin zur Akzeptanz beliebiger URLs innerhalb der angegebenen Domain oder Unterverzeichnisse reichen. Zu den g√§ngigen Ausnutzungsmethoden geh√∂ren offene Umleitungen, Pfadtraversierung, das Ausnutzen schwacher Regex und HTML-Injection zum Diebstahl von Tokens.

Neben `redirect_uri` sind auch andere OAuth- und OpenID-Parameter wie `client_uri`, `policy_uri`, `tos_uri` und `initiate_login_uri` anf√§llig f√ºr Umleitungsangriffe. Diese Parameter sind optional und ihre Unterst√ºtzung variiert zwischen den Servern.

F√ºr diejenigen, die einen OpenID-Server anvisieren, listet der Discovery-Endpunkt (`**.well-known/openid-configuration**`) oft wertvolle Konfigurationsdetails wie `registration_endpoint`, `request_uri_parameter_supported` und "`require_request_uri_registration`. Diese Details k√∂nnen helfen, den Registrierungsendpunkt und andere Konfigurationsspezifika des Servers zu identifizieren.

### XSS in der Redirect-Implementierung <a href="#bda5" id="bda5"></a>

Wie in diesem Bug-Bounty-Bericht erw√§hnt [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) k√∂nnte es m√∂glich sein, dass die Redirect **URL in der Antwort** des Servers nach der Authentifizierung des Benutzers **reflektiert wird und somit anf√§llig f√ºr XSS ist**. M√∂gliche Payload zum Testen:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Unsachgem√§√üe Handhabung des Statusparameters <a href="#bda5" id="bda5"></a>

In OAuth-Implementierungen kann der Missbrauch oder das Vers√§umnis des **`state`-Parameters** das Risiko von **Cross-Site Request Forgery (CSRF)**-Angriffen erheblich erh√∂hen. Diese Schwachstelle tritt auf, wenn der `state`-Parameter entweder **nicht verwendet, als statischer Wert verwendet oder nicht ordnungsgem√§√ü validiert** wird, was Angreifern erm√∂glicht, CSRF-Schutzma√ünahmen zu umgehen.

Angreifer k√∂nnen dies ausnutzen, indem sie den Autorisierungsprozess abfangen, um ihr Konto mit dem Konto eines Opfers zu verkn√ºpfen, was zu potenziellen **Konto√ºbernahmen** f√ºhren kann. Dies ist besonders kritisch in Anwendungen, in denen OAuth f√ºr **Authentifizierungszwecke** verwendet wird.

Echte Beispiele f√ºr diese Schwachstelle wurden in verschiedenen **CTF-Herausforderungen** und **Hacking-Plattformen** dokumentiert, die ihre praktischen Auswirkungen hervorheben. Das Problem erstreckt sich auch auf Integrationen mit Drittanbieterdiensten wie **Slack**, **Stripe** und **PayPal**, wo Angreifer Benachrichtigungen oder Zahlungen auf ihre Konten umleiten k√∂nnen.

Eine ordnungsgem√§√üe Handhabung und Validierung des **`state`-Parameters** ist entscheidend, um sich gegen CSRF zu sch√ºtzen und den OAuth-Fluss abzusichern.

### Vor der Konto√ºbernahme <a href="#ebe4" id="ebe4"></a>

1. **Ohne E-Mail-Verifizierung bei der Kontoerstellung**: Angreifer k√∂nnen proaktiv ein Konto mit der E-Mail des Opfers erstellen. Wenn das Opfer sp√§ter einen Drittanbieterdienst f√ºr die Anmeldung verwendet, k√∂nnte die Anwendung versehentlich dieses Drittanbieter-Konto mit dem vorab erstellten Konto des Angreifers verkn√ºpfen, was zu unbefugtem Zugriff f√ºhrt.
2. **Ausnutzung laxen OAuth-E-Mail-Verifizierung**: Angreifer k√∂nnen OAuth-Dienste ausnutzen, die E-Mails nicht verifizieren, indem sie sich bei ihrem Dienst registrieren und dann die Kontoe-Mail auf die des Opfers √§ndern. Diese Methode birgt √§hnlich das Risiko eines unbefugten Zugriffs auf das Konto, √§hnlich dem ersten Szenario, jedoch √ºber einen anderen Angriffsvektor.

### Offenlegung von Geheimnissen <a href="#e177" id="e177"></a>

Die Identifizierung und der Schutz geheimer OAuth-Parameter sind entscheidend. W√§hrend die **`client_id`** sicher offengelegt werden kann, birgt die Offenlegung des **`client_secret`** erhebliche Risiken. Wenn das `client_secret` kompromittiert wird, k√∂nnen Angreifer die Identit√§t und das Vertrauen der Anwendung ausnutzen, um **Benutzer-`access_tokens`** und private Informationen zu **stehlen**.

Eine h√§ufige Schwachstelle tritt auf, wenn Anwendungen f√§lschlicherweise den Austausch des Autorisierungscodes gegen ein `access_token` auf der Client-Seite anstelle der Server-Seite behandeln. Dieser Fehler f√ºhrt zur Offenlegung des `client_secret`, was es Angreifern erm√∂glicht, `access_tokens` im Namen der Anwendung zu generieren. Dar√ºber hinaus k√∂nnten Angreifer durch Social Engineering Privilegien erh√∂hen, indem sie zus√§tzliche Scopes zur OAuth-Autorisierung hinzuf√ºgen und so den vertrauensw√ºrdigen Status der Anwendung weiter ausnutzen.

### Client Secret Bruteforce

Sie k√∂nnen versuchen, das **client\_secret** eines Dienstanbieters mit dem Identit√§tsanbieter zu **bruteforcen**, um zu versuchen, Konten zu stehlen.\
Die Anfrage zum BF k√∂nnte √§hnlich aussehen wie:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer-Header leckt Code + State

Sobald der Client den **Code und State** hat, wenn er **im Referer-Header reflektiert wird**, w√§hrend er zu einer anderen Seite browsed, ist er anf√§llig.

### Zugriffstoken im Browserverlauf gespeichert

Gehe zum **Browserverlauf und √ºberpr√ºfe, ob das Zugriffstoken dort gespeichert ist**.

### Dauerhafter Autorisierungscode

Der **Autorisierungscode sollte nur f√ºr eine gewisse Zeit g√ºltig sein, um das Zeitfenster zu begrenzen, in dem ein Angreifer ihn stehlen und verwenden kann**.

### Autorisierungs-/Aktualisierungstoken nicht an den Client gebunden

Wenn du den **Autorisierungscode erhalten und ihn mit einem anderen Client verwenden kannst, kannst du andere Konten √ºbernehmen**.

### Gl√ºckliche Pfade, XSS, Iframes & Post-Nachrichten zum Lecken von Code- & State-Werten

[**√úberpr√ºfe diesen Beitrag**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In diesem Bug-Bounty-Bericht: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) kannst du sehen, dass das **Token**, das **AWS Cognito** dem Benutzer zur√ºckgibt, **ausreichende Berechtigungen haben k√∂nnte, um die Benutzerdaten zu √ºberschreiben**. Daher, wenn du **die Benutzer-E-Mail f√ºr eine andere Benutzer-E-Mail √§ndern kannst**, k√∂nntest du in der Lage sein, **andere Konten zu √ºbernehmen**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS cognito check:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Wie [**in diesem Bericht erw√§hnt**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), k√∂nnten OAuth-Flows, die erwarten, das **Token** (und nicht einen Code) zu erhalten, anf√§llig sein, wenn sie nicht √ºberpr√ºfen, ob das Token zur App geh√∂rt.

Das liegt daran, dass ein **Angreifer** eine **Anwendung erstellen k√∂nnte, die OAuth unterst√ºtzt und sich mit Facebook anmeldet** (zum Beispiel) in seiner eigenen Anwendung. Sobald ein Opfer sich dann mit Facebook in der **Anwendung des Angreifers** anmeldet, k√∂nnte der Angreifer das **OAuth-Token des Benutzers, das seiner Anwendung gegeben wurde, erhalten und es verwenden, um sich in der OAuth-Anwendung des Opfers mit dem Benutzer-Token des Opfers anzumelden**.

{% hint style="danger" %}
Daher, wenn es dem Angreifer gelingt, dass der Benutzer auf seine eigene OAuth-Anwendung zugreift, wird er in der Lage sein, das Konto des Opfers in Anwendungen zu √ºbernehmen, die ein Token erwarten und nicht √ºberpr√ºfen, ob das Token ihrer App-ID zugewiesen wurde.
{% endhint %}

### Two links & cookie <a href="#bda5" id="bda5"></a>

Laut [**diesem Bericht**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f) war es m√∂glich, ein Opfer eine Seite mit einem **returnUrl** zu √∂ffnen, die auf den Host des Angreifers zeigt. Diese Informationen w√ºrden in einem **Cookie (RU)** gespeichert und in einem **sp√§teren Schritt** wird die **Eingabeaufforderung** den **Benutzer** fragen, ob er Zugriff auf den Host des Angreifers gew√§hren m√∂chte.

Um diese Eingabeaufforderung zu umgehen, war es m√∂glich, einen Tab zu √∂ffnen, um den **Oauth-Flow** zu initiieren, der dieses RU-Cookie mit der **returnUrl** setzen w√ºrde, den Tab zu schlie√üen, bevor die Eingabeaufforderung angezeigt wird, und einen neuen Tab ohne diesen Wert zu √∂ffnen. Dann wird die **Eingabeaufforderung nicht √ºber den Host des Angreifers informieren**, aber das Cookie w√ºrde auf ihn gesetzt, sodass das **Token an den Host des Angreifers** in der Umleitung gesendet wird.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Wie in [**diesem Video erkl√§rt**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), erlauben einige OAuth-Implementierungen, den **`prompt`** GET-Parameter als None (**`&prompt=none`**) anzugeben, um **zu verhindern, dass Benutzer gefragt werden, ob sie den gegebenen Zugriff** in einer Eingabeaufforderung im Web best√§tigen m√∂chten, wenn sie bereits in der Plattform angemeldet sind.

### response\_mode

Wie [**in diesem Video erkl√§rt**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), k√∂nnte es m√∂glich sein, den Parameter **`response_mode`** anzugeben, um zu bestimmen, wo der Code in der endg√ºltigen URL bereitgestellt werden soll:

* `response_mode=query` -> Der Code wird innerhalb eines GET-Parameters bereitgestellt: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Der Code wird innerhalb des URL-Fragmentparameters `#code=2397rf3gu93f` bereitgestellt
* `response_mode=form_post` -> Der Code wird innerhalb eines POST-Formulars mit einem Eingabefeld namens `code` und dem Wert bereitgestellt
* `response_mode=web_message` -> Der Code wird in einer Post-Nachricht gesendet: `window.opener.postMessage({"code": "asdasdasd...`

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**√úberpr√ºfen Sie diese Forschung**](https://portswigger.net/research/hidden-oauth-attack-vectors) **F√ºr weitere Details zu dieser Technik.**

Die dynamische Client-Registrierung in OAuth dient als weniger offensichtlicher, aber kritischer Vektor f√ºr Sicherheitsanf√§lligkeiten, insbesondere f√ºr **Server-Side Request Forgery (SSRF)**-Angriffe. Dieser Endpunkt erm√∂glicht es OAuth-Servern, Details √ºber Client-Anwendungen zu erhalten, einschlie√ülich sensibler URLs, die ausgenutzt werden k√∂nnten.

**Wichtige Punkte:**

* **Dynamische Client-Registrierung** wird oft auf `/register` abgebildet und akzeptiert Details wie `client_name`, `client_secret`, `redirect_uris` und URLs f√ºr Logos oder JSON Web Key Sets (JWKs) √ºber POST-Anfragen.
* Diese Funktion entspricht den in **RFC7591** und **OpenID Connect Registration 1.0** festgelegten Spezifikationen, die Parameter enthalten, die potenziell anf√§llig f√ºr SSRF sind.
* Der Registrierungsprozess kann unbeabsichtigt Server auf verschiedene Weise f√ºr SSRF anf√§llig machen:
* **`logo_uri`**: Eine URL f√ºr das Logo der Client-Anwendung, die m√∂glicherweise vom Server abgerufen wird, was SSRF ausl√∂sen oder zu XSS f√ºhren kann, wenn die URL falsch behandelt wird.
* **`jwks_uri`**: Eine URL zum JWK-Dokument des Clients, die, wenn sie b√∂swillig erstellt wird, den Server dazu bringen kann, ausgehende Anfragen an einen vom Angreifer kontrollierten Server zu senden.
* **`sector_identifier_uri`**: Verweist auf ein JSON-Array von `redirect_uris`, die der Server abrufen k√∂nnte, was eine SSRF-M√∂glichkeit schafft.
* **`request_uris`**: Listet erlaubte Anfrage-URIs f√ºr den Client auf, die ausgenutzt werden k√∂nnen, wenn der Server diese URIs zu Beginn des Autorisierungsprozesses abruft.

**Exploits-Strategie:**

* SSRF kann ausgel√∂st werden, indem ein neuer Client mit b√∂sartigen URLs in Parametern wie `logo_uri`, `jwks_uri` oder `sector_identifier_uri` registriert wird.
* W√§hrend eine direkte Ausnutzung √ºber `request_uris` durch Whitelist-Kontrollen gemildert werden kann, kann die Bereitstellung einer vorregistrierten, vom Angreifer kontrollierten `request_uri` SSRF w√§hrend der Autorisierungsphase erleichtern.

## OAuth providers Race Conditions

Wenn die Plattform, die Sie testen, ein OAuth-Anbieter ist, [**lesen Sie dies, um m√∂gliche Race Conditions zu testen**](race-condition.md).

## References

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
