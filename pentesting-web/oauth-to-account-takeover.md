# OAuth do przejcia konta

<details>

<summary><strong>Dowiedz si, jak hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje <a href="#d4a8" id="d4a8"></a>

OAuth oferuje r贸偶ne wersje, a podstawowe informacje s dostpne w [dokumentacji OAuth 2.0](https://oauth.net/2/). Niniejsza dyskusja skupia si g贸wnie na powszechnie stosowanym typie autoryzacji [OAuth 2.0 - kod autoryzacyjny](https://oauth.net/2/grant-types/authorization-code/), kt贸ry zapewnia **ramy autoryzacji, umo偶liwiajce aplikacji dostp lub wykonywanie dziaa na koncie u偶ytkownika w innej aplikacji** (serwer autoryzacji).

Rozwa偶my hipotetyczn witryn _**https://example.com**_, kt贸ra ma na celu **prezentacj wszystkich Twoich post贸w w mediach spoecznociowych**, w tym prywatnych. W tym celu wykorzystywany jest OAuth 2.0. _https://example.com_ poprosi o zgod na **dostp do Twoich post贸w w mediach spoecznociowych**. W rezultacie na _https://socialmedia.com_ pojawi si ekran zgody, na kt贸rym bd przedstawione **uprawnienia, kt贸re s 偶dane, oraz deweloper, kt贸ry skada 偶danie**. Po udzieleniu autoryzacji _https://example.com_ uzyskuje mo偶liwo **dostpu do Twoich post贸w w Twoim imieniu**.

Wa偶ne jest zrozumienie nastpujcych komponent贸w w ramach OAuth 2.0:

- **waciciel zasobu**: Ty, jako **u偶ytkownik/entitet**, autoryzujesz dostp do swojego zasobu, takiego jak posty na koncie w mediach spoecznociowych.
- **serwer zasob贸w**: **Serwer zarzdzajcy uwierzytelnionymi 偶daniami** po tym, jak aplikacja uzyskaa `token dostpu` w imieniu `waciciela zasobu`, np. **https://socialmedia.com**.
- **aplikacja klienta**: **Aplikacja, kt贸ra ubiega si o autoryzacj** od `waciciela zasobu`, np. **https://example.com**.
- **serwer autoryzacji**: **Serwer, kt贸ry wydaje `tokeny dostpu`** dla `aplikacji klienta` po pomylnym uwierzytelnieniu `waciciela zasobu` i uzyskaniu autoryzacji, np. **https://socialmedia.com**.
- **client\_id**: Publiczny, unikalny identyfikator aplikacji.
- **client\_secret:** Tajny klucz, znany tylko aplikacji i serwerowi autoryzacji, u偶ywany do generowania `token贸w dostpu`.
- **response\_type**: Warto okrelajca **typ 偶danego tokenu**, np. `code`.
- **scope**: **Poziom dostpu**, kt贸ry `aplikacja klienta` 偶da od `waciciela zasobu`.
- **redirect\_uri**: **Adres URL, na kt贸ry u偶ytkownik zostanie przekierowany po autoryzacji**. Zazwyczaj musi by zgodny z wczeniej zarejestrowanym adresem URL przekierowania.
- **state**: Parametr su偶cy do **przekazywania danych midzy przekierowaniem u偶ytkownika a serwerem autoryzacji**. Jego unikalno jest istotna dla zapewnienia **ochrony przed CSRF**.
- **grant\_type**: Parametr wskazujcy **typ autoryzacji i typ 偶danego tokenu**.
- **code**: Kod autoryzacji z `serwera autoryzacji`, u偶ywany w poczeniu z `client_id` i `client_secret` przez aplikacj klienta do uzyskania `tokena dostpu`.
- **access\_token**: **Token, kt贸ry aplikacja klienta u偶ywa do 偶da API** w imieniu `waciciela zasobu`.
- **refresh\_token**: Umo偶liwia aplikacji **uzyskanie nowego `tokena dostpu` bez ponownego pytania u偶ytkownika**.

### Przebieg

**Rzeczywisty przebieg OAuth** wyglda nastpujco:

1. Przechodzisz do [https://example.com](https://example.com) i wybierasz przycisk "Integruj z mediami spoecznociowymi".
2. Strona wysya 偶danie do [https://socialmedia.com](https://socialmedia.com), proszc o autoryzacj dostpu aplikacji https://example.com do Twoich post贸w. 呕danie jest zbudowane w nastpujcy spos贸b:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Nastpnie zostajesz przekierowany na stron zgody.

4. Po zatwierdzeniu, Social Media wysya odpowied藕 na `redirect_uri` z parametrami `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com wykorzystuje ten `code`, wraz z `client_id` i `client_secret`, aby dokona 偶dania po stronie serwera w celu uzyskania `access_token` w Twoim imieniu, umo偶liwiajc dostp do uprawnie, na kt贸re wyrazie zgod:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Ostatecznie proces koczy si, gdy https://example.com u偶ywa twojego `access_token` do wykonania wywoania API do Social Media w celu uzyskania dostpu.

## Podatnoci <a href="#323a" id="323a"></a>

### Otwarte przekierowanie `redirect_uri` <a href="#cc36" id="cc36"></a>

`redirect_uri` jest kluczowy dla bezpieczestwa w implementacjach OAuth i OpenID, poniewa偶 kieruje, gdzie wysyane s wra偶liwe dane, takie jak kody autoryzacji, po autoryzacji. Jeli jest 藕le skonfigurowany, mo偶e umo偶liwi atakujcym przekierowanie tych 偶da do zoliwych serwer贸w, umo偶liwiajc przejcie konta.

Techniki eksploatacji r贸偶ni si w zale偶noci od logiki walidacji serwera autoryzacji. Mog obejmowa odporne dopasowanie cie偶ki, akceptowanie dowolnego adresu URL w okrelonej domenie lub podkatalogu. Powszechne metody eksploatacji obejmuj otwarte przekierowania, przechodzenie cie偶ek, wykorzystywanie sabych wyra偶e regularnych i wstrzykiwanie HTML w celu kradzie偶y token贸w.

Opr贸cz `redirect_uri`, inne parametry OAuth i OpenID, takie jak `client_uri`, `policy_uri`, `tos_uri` i `initiate_login_uri`, s r贸wnie偶 podatne na ataki przekierowania. Te parametry s opcjonalne, a ich obsuga r贸偶ni si w zale偶noci od serwer贸w.

Dla os贸b celujcych w serwer OpenID, punkt kocowy odkrywania (`**.well-known/openid-configuration**`) czsto zawiera cenne szczeg贸y konfiguracji, takie jak `registration_endpoint`, `request_uri_parameter_supported` i "`require_request_uri_registration`. Te szczeg贸y mog pom贸c w identyfikacji punktu kocowego rejestracji i innych szczeg贸贸w konfiguracji serwera.

### XSS w implementacji przekierowania <a href="#bda5" id="bda5"></a>

Jak wspomniano w tym raporcie z programu bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), mo偶liwe jest, 偶e **URL przekierowania jest odbijany w odpowiedzi** serwera po uwierzytelnieniu u偶ytkownika, co czyni go **podatnym na XSS**. Mo偶liwy adunek do przetestowania:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Niewaciwe obsugiwanie parametru stanu <a href="#bda5" id="bda5"></a>

W implementacjach OAuth, niewaciwe u偶ycie lub pominicie parametru **`state`** mo偶e znacznie zwikszy ryzyko atak贸w **Cross-Site Request Forgery (CSRF)**. Ta podatno wystpuje, gdy parametr `state` jest albo **nie u偶ywany, u偶ywany jako warto statyczna, albo nieprawidowo sprawdzany**, co umo偶liwia atakujcym obejcie zabezpiecze CSRF.

Atakujcy mog wykorzysta to, przechwytujc proces autoryzacji, aby poczy swoje konto z kontem ofiary, co prowadzi do potencjalnego **przejcia konta**. Jest to szczeg贸lnie krytyczne w aplikacjach, gdzie OAuth jest u偶ywany w celach **uwierzytelniania**.

Przykady tej podatnoci w wiecie rzeczywistym zostay udokumentowane w r贸偶nych **wyzwaniach CTF** i **platformach do hakowania**, co podkrela jej praktyczne implikacje. Problem ten dotyczy r贸wnie偶 integracji z usugami os贸b trzecich, takimi jak **Slack**, **Stripe** i **PayPal**, gdzie atakujcy mog przekierowywa powiadomienia lub patnoci na swoje konta.

Prawidowe obsugiwanie i sprawdzanie parametru **`state`** s kluczowe dla ochrony przed CSRF i zabezpieczenia przepywu OAuth.

### Przed przejciem konta <a href="#ebe4" id="ebe4"></a>

1. **Bez weryfikacji adresu e-mail podczas tworzenia konta**: Atakujcy mog wczeniej utworzy konto, u偶ywajc adresu e-mail ofiary. Jeli ofiara p贸藕niej u偶yje usugi os贸b trzecich do logowania, aplikacja mo偶e nieumylnie poczy to konto os贸b trzecich z wczeniej utworzonym kontem atakujcego, co prowadzi do nieautoryzowanego dostpu.

2. **Wykorzystanie lu藕nej weryfikacji e-mail w OAuth**: Atakujcy mog wykorzysta usugi OAuth, kt贸re nie weryfikuj adres贸w e-mail, rejestrujc si w ich usudze, a nastpnie zmieniajc adres e-mail konta na adres ofiary. Ta metoda podobnie nara偶a na nieautoryzowany dostp do konta, podobnie jak w pierwszym scenariuszu, ale za pomoc innego wektora ataku.

### Ujawnienie sekret贸w <a href="#e177" id="e177"></a>

Identyfikacja i ochrona tajnych parametr贸w OAuth jest kluczowa. Podczas gdy **`client_id`** mo偶na bezpiecznie ujawni, ujawnienie **`client_secret`** niesie ze sob znaczne ryzyko. Jeli `client_secret` zostanie kompromitowany, atakujcy mog wykorzysta to偶samo i zaufanie aplikacji, aby **ukra `access_tokeny`** i prywatne informacje.

Powszechn podatnoci jest niewaciwe obsugiwane wymiany kodu autoryzacji na `access_token` po stronie klienta, a nie po stronie serwera. Ten bd prowadzi do ujawnienia `client_secret`, umo偶liwiajc atakujcym generowanie `access_token贸w` pod przykrywk aplikacji. Ponadto, za pomoc in偶ynierii spoecznej, atakujcy mog eskalowa uprawnienia, dodajc dodatkowe zakresy do autoryzacji OAuth, dalsze wykorzystujc zaufane statusu aplikacji.

### Bruteforce tajnego klienta

Mo偶esz spr贸bowa **przeama tajny klienta** dostawcy usug przy u偶yciu dostawcy to偶samoci, aby pr贸bowa kra konta.\
呕danie do BF mo偶e wyglda podobnie do:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Wyciek kodu i stanu za pomoc nag贸wka Referer

Jeli klient posiada **kod i stan**, a s one **odzwierciedlone w nag贸wku Referer** podczas przegldania innej strony, to jest to podatno.

### Token dostpu przechowywany w historii przegldarki

Przejd藕 do **historii przegldarki i sprawd藕, czy token dostpu jest tam zapisany**.

### Wieczny kod autoryzacyjny

**Kod autoryzacyjny powinien istnie tylko przez pewien czas, aby ograniczy okno czasowe, w kt贸rym atakujcy mo偶e go ukra i wykorzysta**.

### Token autoryzacyjny/odwie偶ania niepowizany z klientem

Jeli mo偶esz uzyska **kod autoryzacyjny i u偶y go z innym klientem, to mo偶esz przej inne konta**.

### Szczliwe cie偶ki, XSS, Iframes i Post Messages do wycieku kodu i wartoci stanu

**[Sprawd藕 ten post](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)**

### AWS Cognito <a href="#bda5" id="bda5"></a>

W raporcie z programu bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) mo偶na zobaczy, 偶e **token**, kt贸ry **AWS Cognito** zwraca u偶ytkownikowi, mo偶e mie **wystarczajce uprawnienia do nadpisania danych u偶ytkownika**. Dlatego, jeli mo偶esz **zmieni adres e-mail u偶ytkownika na inny adres e-mail**, mo偶esz **przej** inne konta.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Aby uzyska bardziej szczeg贸owe informacje na temat nadu偶ywania AWS Cognito, sprawd藕:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Nadu偶ywanie token贸w innych aplikacji <a href="#bda5" id="bda5"></a>

Jak [**wspomniano w tym opracowaniu**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), przepywy OAuth, kt贸re oczekuj otrzymania **tokenu** (a nie kodu), mog by podatne, jeli nie sprawdzaj, czy token nale偶y do aplikacji.

Dzieje si tak dlatego, 偶e **atakujcy** mo偶e stworzy **aplikacj obsugujc OAuth i zalogowa si za pomoc Facebooka** (na przykad) w swojej wasnej aplikacji. Nastpnie, gdy ofiara zaloguje si za pomoc Facebooka w **aplikacji atakujcego**, atakujcy mo偶e uzyska **token OAuth u偶ytkownika przekazany do swojej aplikacji i u偶y go do zalogowania si w aplikacji OAuth ofiary, u偶ywajc tokenu u偶ytkownika ofiary**.

{% hint style="danger" %}
Dlatego jeli atakujcy zdoa skoni u偶ytkownika do udostpnienia dostpu do swojej wasnej aplikacji OAuth, bdzie m贸g przej konto ofiary w aplikacjach, kt贸re oczekuj tokenu i nie sprawdzaj, czy token zosta przyznany dla ich identyfikatora aplikacji.
{% endhint %}

### Dwa linki i cookie <a href="#bda5" id="bda5"></a>

Zgodnie z [**tym opracowaniem**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), byo mo偶liwe zmuszenie ofiary do otwarcia strony z **returnUrl**, wskazujc na host atakujcego. Te informacje byy **przechowywane w pliku cookie (RU)**, a w **kolejnym kroku** **okno dialogowe** pytao **u偶ytkownika**, czy chce udzieli dostpu temu hostowi atakujcego.

Aby omin to okno dialogowe, mo偶na byo otworzy kart, aby rozpocz **przepyw OAuth**, kt贸ry ustawiaby to plik cookie RU za pomoc **returnUrl**, zamkn kart przed wywietleniem okna dialogowego i otworzy now kart bez tej wartoci. Wtedy **okno dialogowe nie informowaoby o hostu atakujcego**, ale plik cookie byby do niego ustawiony, wic **token zostanie wysany do hosta atakujcego** w przekierowaniu.

### Parametry SSRF <a href="#bda5" id="bda5"></a>

**[Sprawd藕 t analiz](https://portswigger.net/research/hidden-oauth-attack-vectors) dla dalszych szczeg贸贸w na temat tej techniki.**

Dynamiczna rejestracja klienta w OAuth stanowi mniej oczywisty, ale krytyczny wektor podatnoci na bezpieczestwo, zwaszcza dla atak贸w typu **Server-Side Request Forgery (SSRF)**. Ten punkt kocowy umo偶liwia serwerom OAuth otrzymywanie informacji na temat aplikacji klienta, w tym wra偶liwych adres贸w URL, kt贸re mog by wykorzystane.

**Kluczowe punkty:**

- Dynamiczna rejestracja klienta jest czsto mapowana na `/register` i akceptuje szczeg贸y, takie jak `client_name`, `client_secret`, `redirect_uris` oraz adresy URL dla logotyp贸w lub zestaw贸w kluczy JSON Web (JWKs) za pomoc 偶da POST.
- Ta funkcja przestrzega specyfikacji okrelonej w **RFC7591** i **OpenID Connect Registration 1.0**, kt贸ra obejmuje parametry podatne na SSRF.
- Proces rejestracji mo偶e nieumylnie narazi serwery na SSRF na kilka sposob贸w:
- **`logo_uri`**: Adres URL logotypu aplikacji klienta, kt贸ry mo偶e by pobrany przez serwer, wywoujc SSRF lub prowadzc do XSS, jeli adres URL jest nieprawidowo obsugiwany.
- **`jwks_uri`**: Adres URL do dokumentu JWK klienta, kt贸ry w przypadku zoliwego opracowania mo偶e spowodowa, 偶e serwer wyle 偶dania do serwera kontrolowanego przez atakujcego.
- **`sector_identifier_uri`**: Odwouje si do tablicy JSON `redirect_uris`, kt贸re serwer mo偶e pobra, tworzc mo偶liwo SSRF.
- **`request_uris`**: Wylicza dozwolone adresy URL 偶da dla klienta, kt贸re mog by wykorzystane, jeli serwer pobiera te adresy URL na pocztku procesu autoryzacji.

**Strategia wykorzystania:**

- SSRF mo偶na wywoa, rejestrujc nowego klienta z zoliwymi adresami URL w parametrach takich jak `logo_uri`, `jwks_uri` lub `sector_identifier_uri`.
- Chocia偶 bezporednie wykorzystanie za pomoc `request_uris` mo偶e by ograniczone przez kontrol listy biaej, dostarczenie wczeniej zarejestrowanego, kontrolowanego przez atakujcego `request_uri` mo偶e uatwi SSRF podczas fazy autoryzacji.
