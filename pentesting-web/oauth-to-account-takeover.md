# OAuth a Toma de Control de Cuenta

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Informaci√≥n B√°sica <a href="#d4a8" id="d4a8"></a>

OAuth ofrece varias versiones, con informaci√≥n fundamental accesible en [documentaci√≥n de OAuth 2.0](https://oauth.net/2/). Esta discusi√≥n se centra principalmente en el ampliamente utilizado [tipo de concesi√≥n de c√≥digo de autorizaci√≥n de OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/), proporcionando un **marco de autorizaci√≥n que permite a una aplicaci√≥n acceder o realizar acciones en la cuenta de un usuario en otra aplicaci√≥n** (el servidor de autorizaci√≥n).

Considera un sitio web hipot√©tico _**https://example.com**_, dise√±ado para **mostrar todas tus publicaciones en redes sociales**, incluidas las privadas. Para lograr esto, se emplea OAuth 2.0. _https://example.com_ solicitar√° tu permiso para **acceder a tus publicaciones en redes sociales**. En consecuencia, aparecer√° una pantalla de consentimiento en _https://socialmedia.com_, describiendo los **permisos solicitados y el desarrollador que realiza la solicitud**. Tras tu autorizaci√≥n, _https://example.com_ obtiene la capacidad de **acceder a tus publicaciones en tu nombre**.

Es esencial comprender los siguientes componentes dentro del marco de OAuth 2.0:

* **propietario del recurso**: T√∫, como el **usuario/entidad**, autorizas el acceso a tu recurso, como las publicaciones de tu cuenta de redes sociales.
* **servidor de recursos**: El **servidor que gestiona las solicitudes autenticadas** despu√©s de que la aplicaci√≥n ha asegurado un `access token` en nombre del `propietario del recurso`, por ejemplo, **https://socialmedia.com**.
* **aplicaci√≥n cliente**: La **aplicaci√≥n que busca autorizaci√≥n** del `propietario del recurso`, como **https://example.com**.
* **servidor de autorizaci√≥n**: El **servidor que emite `access tokens`** a la `aplicaci√≥n cliente` tras la autenticaci√≥n exitosa del `propietario del recurso` y la obtenci√≥n de autorizaci√≥n, por ejemplo, **https://socialmedia.com**.
* **client\_id**: Un identificador p√∫blico y √∫nico para la aplicaci√≥n.
* **client\_secret:** Una clave confidencial, conocida √∫nicamente por la aplicaci√≥n y el servidor de autorizaci√≥n, utilizada para generar `access_tokens`.
* **response\_type**: Un valor que especifica **el tipo de token solicitado**, como `code`.
* **scope**: El **nivel de acceso** que la `aplicaci√≥n cliente` est√° solicitando del `propietario del recurso`.
* **redirect\_uri**: La **URL a la que el usuario es redirigido despu√©s de la autorizaci√≥n**. Esto generalmente debe alinearse con la URL de redirecci√≥n pre-registrada.
* **state**: Un par√°metro para **mantener datos a trav√©s de la redirecci√≥n del usuario hacia y desde el servidor de autorizaci√≥n**. Su singularidad es cr√≠tica para servir como un **mecanismo de protecci√≥n CSRF**.
* **grant\_type**: Un par√°metro que indica **el tipo de concesi√≥n y el tipo de token que se devolver√°**.
* **code**: El c√≥digo de autorizaci√≥n del `servidor de autorizaci√≥n`, utilizado junto con `client_id` y `client_secret` por la aplicaci√≥n cliente para adquirir un `access_token`.
* **access\_token**: El **token que la aplicaci√≥n cliente utiliza para solicitudes API** en nombre del `propietario del recurso`.
* **refresh\_token**: Permite a la aplicaci√≥n **obtener un nuevo `access_token` sin volver a solicitar al usuario**.

### Flujo

El **flujo real de OAuth** procede de la siguiente manera:

1. Navegas a [https://example.com](https://example.com) y seleccionas el bot√≥n ‚ÄúIntegrar con Redes Sociales‚Äù.
2. El sitio env√≠a una solicitud a [https://socialmedia.com](https://socialmedia.com) pidiendo tu autorizaci√≥n para permitir que la aplicaci√≥n de https://example.com acceda a tus publicaciones. La solicitud est√° estructurada como:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. A continuaci√≥n, se le presenta una p√°gina de consentimiento.  
4. Tras su aprobaci√≥n, Social Media env√≠a una respuesta a la `redirect_uri` con los par√°metros `code` y `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, junto con su `client_id` y `client_secret`, para hacer una solicitud del lado del servidor para obtener un `access_token` en tu nombre, lo que permite el acceso a los permisos a los que diste tu consentimiento:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, el proceso concluye cuando https://example.com emplea tu `access_token` para hacer una llamada a la API de Social Media para acceder

## Vulnerabilidades <a href="#id-323a" id="id-323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

El `redirect_uri` es crucial para la seguridad en las implementaciones de OAuth y OpenID, ya que dirige a d√≥nde se env√≠an los datos sensibles, como los c√≥digos de autorizaci√≥n, despu√©s de la autorizaci√≥n. Si est√° mal configurado, podr√≠a permitir a los atacantes redirigir estas solicitudes a servidores maliciosos, habilitando la toma de control de cuentas.

Las t√©cnicas de explotaci√≥n var√≠an seg√∫n la l√≥gica de validaci√≥n del servidor de autorizaci√≥n. Pueden ir desde una coincidencia estricta de rutas hasta aceptar cualquier URL dentro del dominio o subdirectorio especificado. Los m√©todos de explotaci√≥n comunes incluyen redirecciones abiertas, recorrido de rutas, explotaci√≥n de expresiones regulares d√©biles e inyecci√≥n de HTML para el robo de tokens.

Adem√°s de `redirect_uri`, otros par√°metros de OAuth y OpenID como `client_uri`, `policy_uri`, `tos_uri` y `initiate_login_uri` tambi√©n son susceptibles a ataques de redirecci√≥n. Estos par√°metros son opcionales y su soporte var√≠a entre servidores.

Para aquellos que apuntan a un servidor OpenID, el punto final de descubrimiento (`**.well-known/openid-configuration**`) a menudo lista detalles de configuraci√≥n valiosos como `registration_endpoint`, `request_uri_parameter_supported` y "`require_request_uri_registration`. Estos detalles pueden ayudar a identificar el punto final de registro y otros aspectos espec√≠ficos de configuraci√≥n del servidor.

### XSS en la implementaci√≥n de redirecci√≥n <a href="#bda5" id="bda5"></a>

Como se menciona en este informe de recompensas por errores [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), podr√≠a ser posible que la **URL de redirecci√≥n se est√© reflejando en la respuesta** del servidor despu√©s de que el usuario se autentique, siendo **vulnerable a XSS**. Carga √∫til posible para probar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Manejo inadecuado del par√°metro de estado <a href="#bda5" id="bda5"></a>

En las implementaciones de OAuth, el uso indebido u omisi√≥n del **`state` parameter** puede aumentar significativamente el riesgo de ataques de **Cross-Site Request Forgery (CSRF)**. Esta vulnerabilidad surge cuando el par√°metro `state` es **no utilizado, utilizado como un valor est√°tico o no validado adecuadamente**, permitiendo a los atacantes eludir las protecciones CSRF.

Los atacantes pueden explotar esto interceptando el proceso de autorizaci√≥n para vincular su cuenta con la cuenta de una v√≠ctima, lo que lleva a posibles **tomas de control de cuentas**. Esto es especialmente cr√≠tico en aplicaciones donde se utiliza OAuth para **fines de autenticaci√≥n**.

Se han documentado ejemplos del mundo real de esta vulnerabilidad en varios **desaf√≠os CTF** y **plataformas de hacking**, destacando sus implicaciones pr√°cticas. El problema tambi√©n se extiende a integraciones con servicios de terceros como **Slack**, **Stripe** y **PayPal**, donde los atacantes pueden redirigir notificaciones o pagos a sus cuentas.

El manejo y validaci√≥n adecuados del **`state` parameter** son cruciales para protegerse contra CSRF y asegurar el flujo de OAuth.

### Pre Toma de Control de Cuenta <a href="#ebe4" id="ebe4"></a>

1. **Sin Verificaci√≥n de Correo Electr√≥nico en la Creaci√≥n de Cuenta**: Los atacantes pueden crear preventivamente una cuenta utilizando el correo electr√≥nico de la v√≠ctima. Si la v√≠ctima m√°s tarde utiliza un servicio de terceros para iniciar sesi√≥n, la aplicaci√≥n podr√≠a vincular inadvertidamente esta cuenta de terceros a la cuenta pre-creada del atacante, lo que lleva a un acceso no autorizado.
2. **Explotando la Verificaci√≥n de Correo Electr√≥nico Laxa de OAuth**: Los atacantes pueden explotar servicios de OAuth que no verifican correos electr√≥nicos registr√°ndose con su servicio y luego cambiando el correo electr√≥nico de la cuenta al de la v√≠ctima. Este m√©todo tambi√©n arriesga el acceso no autorizado a la cuenta, similar al primer escenario pero a trav√©s de un vector de ataque diferente.

### Divulgaci√≥n de Secretos <a href="#e177" id="e177"></a>

Identificar y proteger los par√°metros secretos de OAuth es crucial. Mientras que el **`client_id`** puede ser divulgado de manera segura, revelar el **`client_secret`** presenta riesgos significativos. Si el `client_secret` se ve comprometido, los atacantes pueden explotar la identidad y confianza de la aplicaci√≥n para **robar `access_tokens` de usuarios** e informaci√≥n privada.

Una vulnerabilidad com√∫n surge cuando las aplicaciones manejan err√≥neamente el intercambio del `code` de autorizaci√≥n por un `access_token` del lado del cliente en lugar del lado del servidor. Este error lleva a la exposici√≥n del `client_secret`, permitiendo a los atacantes generar `access_tokens` bajo la apariencia de la aplicaci√≥n. Adem√°s, a trav√©s de ingenier√≠a social, los atacantes podr√≠an escalar privilegios al agregar alcances adicionales a la autorizaci√≥n de OAuth, explotando a√∫n m√°s el estatus de confianza de la aplicaci√≥n.

### Fuerza Bruta del Secreto del Cliente

Puedes intentar **fuerza bruta del client\_secret** de un proveedor de servicios con el proveedor de identidad para intentar robar cuentas.\
La solicitud para BF puede parecer similar a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Una vez que el cliente tiene el **code y state**, si est√° **reflejado dentro del Referer header** cuando navega a una p√°gina diferente, entonces es vulnerable.

### Access Token Stored in Browser History

Ve al **historial del navegador y verifica si el access token est√° guardado all√≠**.

### Everlasting Authorization Code

El **authorization code deber√≠a vivir solo por un tiempo para limitar la ventana de tiempo en la que un atacante puede robarlo y usarlo**.

### Authorization/Refresh Token not bound to client

Si puedes obtener el **authorization code y usarlo con un cliente diferente, entonces puedes tomar el control de otras cuentas**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

En este informe de bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puedes ver que el **token** que **AWS Cognito** devuelve al usuario podr√≠a tener **suficientes permisos para sobrescribir los datos del usuario**. Por lo tanto, si puedes **cambiar el correo electr√≥nico del usuario por un correo electr√≥nico diferente**, podr√≠as ser capaz de **tomar el control** de otras cuentas.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para obtener informaci√≥n m√°s detallada sobre c√≥mo abusar de AWS Cognito, consulta:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abusando de otros tokens de Apps <a href="#bda5" id="bda5"></a>

Como [**se menciona en este informe**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), los flujos de OAuth que esperan recibir el **token** (y no un c√≥digo) podr√≠an ser vulnerables si no verifican que el token pertenece a la aplicaci√≥n.

Esto se debe a que un **atacante** podr√≠a crear una **aplicaci√≥n que soporte OAuth y login con Facebook** (por ejemplo) en su propia aplicaci√≥n. Luego, una vez que una v√≠ctima inicie sesi√≥n con Facebook en la **aplicaci√≥n del atacante**, el atacante podr√≠a obtener el **token OAuth del usuario otorgado a su aplicaci√≥n y usarlo para iniciar sesi√≥n en la aplicaci√≥n OAuth de la v√≠ctima usando el token de usuario de la v√≠ctima**.

{% hint style="danger" %}
Por lo tanto, si el atacante logra que el usuario acceda a su propia aplicaci√≥n OAuth, podr√° tomar el control de la cuenta de la v√≠ctima en aplicaciones que esperan un token y no est√°n verificando si el token fue otorgado a su ID de aplicaci√≥n.
{% endhint %}

### Dos enlaces y cookie <a href="#bda5" id="bda5"></a>

Seg√∫n [**este informe**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era posible hacer que una v√≠ctima abriera una p√°gina con un **returnUrl** apuntando al host del atacante. Esta informaci√≥n ser√≠a **almacenada en una cookie (RU)** y en un **paso posterior** el **prompt** **preguntar√°** al **usuario** si desea dar acceso a ese host del atacante.

Para eludir este prompt, era posible abrir una pesta√±a para iniciar el **flujo de Oauth** que establecer√≠a esta cookie RU usando el **returnUrl**, cerrar la pesta√±a antes de que se muestre el prompt y abrir una nueva pesta√±a sin ese valor. Entonces, el **prompt no informar√° sobre el host del atacante**, pero la cookie se establecer√≠a en √©l, por lo que el **token se enviar√° al host del atacante** en la redirecci√≥n.

### Bypass de Interacci√≥n del Prompt <a href="#bda5" id="bda5"></a>

Como se explica en [**este video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), algunas implementaciones de OAuth permiten indicar el par√°metro **`prompt`** GET como None (**`&prompt=none`**) para **evitar que se pida a los usuarios que confirmen** el acceso otorgado en un prompt en la web si ya est√°n conectados a la plataforma.

### response\_mode

Como [**se explica en este video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), podr√≠a ser posible indicar el par√°metro **`response_mode`** para indicar d√≥nde deseas que se proporcione el c√≥digo en la URL final:

* `response_mode=query` -> El c√≥digo se proporciona dentro de un par√°metro GET: `?code=2397rf3gu93f`
* `response_mode=fragment` -> El c√≥digo se proporciona dentro del par√°metro de fragmento de la URL `#code=2397rf3gu93f`
* `response_mode=form_post` -> El c√≥digo se proporciona dentro de un formulario POST con un input llamado `code` y el valor
* `response_mode=web_message` -> El c√≥digo se env√≠a en un mensaje post: `window.opener.postMessage({"code": "asdasdasd...`

### Par√°metros SSRFs <a href="#bda5" id="bda5"></a>

[**Consulta esta investigaci√≥n**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Para m√°s detalles sobre esta t√©cnica.**

El Registro Din√°mico de Clientes en OAuth sirve como un vector menos obvio pero cr√≠tico para vulnerabilidades de seguridad, espec√≠ficamente para ataques de **Server-Side Request Forgery (SSRF)**. Este endpoint permite a los servidores OAuth recibir detalles sobre aplicaciones cliente, incluyendo URLs sensibles que podr√≠an ser explotadas.

**Puntos Clave:**

* **El Registro Din√°mico de Clientes** a menudo se mapea a `/register` y acepta detalles como `client_name`, `client_secret`, `redirect_uris`, y URLs para logotipos o Conjuntos de Claves Web JSON (JWKs) a trav√©s de solicitudes POST.
* Esta caracter√≠stica se adhiere a las especificaciones establecidas en **RFC7591** y **OpenID Connect Registration 1.0**, que incluyen par√°metros potencialmente vulnerables a SSRF.
* El proceso de registro puede exponer inadvertidamente a los servidores a SSRF de varias maneras:
* **`logo_uri`**: Una URL para el logotipo de la aplicaci√≥n cliente que podr√≠a ser recuperada por el servidor, desencadenando SSRF o llevando a XSS si la URL se maneja incorrectamente.
* **`jwks_uri`**: Una URL al documento JWK del cliente, que si se elabora maliciosamente, puede hacer que el servidor realice solicitudes salientes a un servidor controlado por un atacante.
* **`sector_identifier_uri`**: Hace referencia a un array JSON de `redirect_uris`, que el servidor podr√≠a recuperar, creando una oportunidad de SSRF.
* **`request_uris`**: Enumera las URIs de solicitud permitidas para el cliente, que pueden ser explotadas si el servidor recupera estas URIs al inicio del proceso de autorizaci√≥n.

**Estrategia de Explotaci√≥n:**

* SSRF puede ser desencadenado registrando un nuevo cliente con URLs maliciosas en par√°metros como `logo_uri`, `jwks_uri`, o `sector_identifier_uri`.
* Si bien la explotaci√≥n directa a trav√©s de `request_uris` puede ser mitigada por controles de lista blanca, proporcionar un `request_uri` pre-registrado y controlado por el atacante puede facilitar SSRF durante la fase de autorizaci√≥n.

## Condiciones de Carrera de Proveedores OAuth

Si la plataforma que est√°s probando es un proveedor de OAuth [**lee esto para probar posibles Condiciones de Carrera**](race-condition.md).

## Referencias

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Consulta los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
