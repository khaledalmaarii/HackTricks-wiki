# Condition de course

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des flux de travail** alimentÃ©s par les outils communautaires **les plus avancÃ©s** au monde.\
Obtenez l'accÃ¨s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersÃ©curitÃ©** ? Vous voulez voir votre **entreprise annoncÃ©e dans HackTricks** ? ou souhaitez-vous accÃ©der Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**dÃ©pÃ´t hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**dÃ©pÃ´t hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Exploiter une condition de course

Le principal problÃ¨me pour abuser des conditions de course est que vous avez besoin que les requÃªtes soient traitÃ©es en parallÃ¨le avec un trÃ¨s court intervalle de temps (gÃ©nÃ©ralement >1ms). Dans la section suivante, diffÃ©rentes solutions sont proposÃ©es pour rendre cela possible.

<figure><img src="../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

### Attaque par un seul paquet (HTTP/2) / Synchronisation du dernier octet (HTTP/1.1)

HTTP2 permet d'envoyer **2 requÃªtes dans une seule connexion TCP** (alors qu'en HTTP/1.1 elles doivent Ãªtre sÃ©quentielles).\
L'utilisation d'un seul paquet TCP Ã©limine complÃ¨tement **l'effet de la gigue rÃ©seau**, ce qui a clairement un potentiel pour les attaques par condition de course aussi. Cependant, **deux requÃªtes ne suffisent pas pour une attaque de course fiable** Ã  cause de la **gigue cÃ´tÃ© serveur** - variations dans le temps de traitement des requÃªtes de l'application causÃ©es par des variables incontrÃ´lables comme la contention CPU.

Mais, en utilisant la technique '**synchronisation du dernier octet**' avec HTTP/1.1, il est possible de prÃ©-envoyer la majeure partie des donnÃ©es en retenant un petit fragment de chaque requÃªte, puis de 'complÃ©ter' **20-30 requÃªtes avec un seul paquet TCP**.

Pour **prÃ©-envoyer la majeure partie de chaque requÃªte** :

* Si la requÃªte n'a pas de corps, envoyez tous les en-tÃªtes, mais ne dÃ©finissez pas le drapeau END_STREAM. Retenez un cadre de donnÃ©es vide avec END_STREAM dÃ©fini.
* Si la requÃªte a un corps, envoyez les en-tÃªtes et toutes les donnÃ©es du corps sauf le dernier octet. Retenez un cadre de donnÃ©es contenant le dernier octet.

Ensuite, **prÃ©parez-vous Ã  envoyer les cadres finaux** :

* Attendez 100 ms pour vous assurer que les cadres initiaux ont Ã©tÃ© envoyÃ©s.
* Assurez-vous que TCP_NODELAY est dÃ©sactivÃ© - il est crucial que l'algorithme de Nagle regroupe les cadres finaux.
* Envoyez un paquet ping pour rÃ©chauffer la connexion locale. Si vous ne faites pas cela, la pile rÃ©seau du systÃ¨me d'exploitation placera le premier cadre final dans un paquet sÃ©parÃ©.

Enfin, envoyez les cadres retenus. Vous devriez pouvoir vÃ©rifier qu'ils ont atterri dans un seul paquet en utilisant Wireshark.

{% hint style="info" %}
Notez que cela **ne fonctionne pas pour les fichiers statiques** sur certains serveurs mais comme les fichiers statiques ne sont pas pertinents pour les attaques par condition de course. Mais les fichiers statiques sont sans importance pour les attaques par condition de course.
{% endhint %}

En utilisant cette technique, vous pouvez faire en sorte que 20-30 requÃªtes arrivent simultanÃ©ment au serveur - indÃ©pendamment de la gigue rÃ©seau :

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**S'adapter Ã  l'architecture cible**

Il convient de noter que de nombreuses applications sont situÃ©es derriÃ¨re un serveur frontal, et celles-ci peuvent dÃ©cider de transfÃ©rer certaines requÃªtes via des connexions existantes vers le serveur principal, et de crÃ©er de nouvelles connexions pour d'autres.

En consÃ©quence, il est important de ne pas attribuer un temps de traitement des requÃªtes incohÃ©rent au comportement de l'application, tel que des mÃ©canismes de verrouillage qui ne permettent qu'Ã  un seul fil d'accÃ©der Ã  une ressource Ã  la fois. De plus, le routage des requÃªtes frontales est souvent effectuÃ© sur une base par connexion, donc vous pourriez Ãªtre en mesure de lisser le temps de traitement des requÃªtes en effectuant un rÃ©chauffement de connexion cÃ´tÃ© serveur - **envoyant quelques requÃªtes sans consÃ©quence dans votre connexion avant de rÃ©aliser l'attaque** (cela consiste juste Ã  envoyer plusieurs requÃªtes avant de commencer l'attaque rÃ©elle).

#### MÃ©canismes de verrouillage basÃ©s sur la session <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

Certains frameworks tentent de prÃ©venir la corruption accidentelle des donnÃ©es en utilisant une forme de **verrouillage des requÃªtes**. Par exemple, le module de **gestionnaire de session natif de PHP** ne traite qu'**une requÃªte par session Ã  la fois**.

Il est extrÃªmement important de repÃ©rer ce type de comportement car il peut sinon masquer des vulnÃ©rabilitÃ©s trivialement exploitables. Si vous remarquez que toutes vos requÃªtes sont traitÃ©es sÃ©quentiellement, essayez d'envoyer chacune d'elles en utilisant un jeton de session diffÃ©rent.

#### **Abuser des limites de taux ou de ressources**

Si le rÃ©chauffement de la connexion ne fait aucune diffÃ©rence, il existe diverses solutions Ã  ce problÃ¨me.

En utilisant Turbo Intruder, vous pouvez introduire un court dÃ©lai cÃ´tÃ© client. Cependant, comme cela implique de diviser vos requÃªtes d'attaque rÃ©elles en plusieurs paquets TCP, vous ne pourrez pas utiliser la technique d'attaque par un seul paquet. En consÃ©quence, sur des cibles Ã  forte gigue, l'attaque est peu susceptible de fonctionner de maniÃ¨re fiable, quel que soit le dÃ©lai que vous dÃ©finissez.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Au lieu de cela, vous pourriez Ãªtre en mesure de rÃ©soudre ce problÃ¨me en abusant d'une fonctionnalitÃ© de sÃ©curitÃ© courante.

Les serveurs Web retardent souvent **le traitement des requÃªtes si trop sont envoyÃ©es trop rapidement**. En envoyant un grand nombre de requÃªtes factices pour dÃ©clencher intentionnellement la limite de taux ou de ressources, vous pourriez Ãªtre en mesure de provoquer un dÃ©lai cÃ´tÃ© serveur appropriÃ©. Cela rend l'attaque par un seul paquet viable mÃªme lorsque l'exÃ©cution retardÃ©e est requise.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Pour plus d'informations sur cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Exemples d'attaque

* **Turbo Intruder - Attaque par un seul paquet HTTP2 (1 point de terminaison)** : Vous pouvez envoyer la requÃªte Ã  **Turbo Intruder** (`Extensions` -> `Turbo Intruder` -> `Envoyer Ã  Turbo Intruder`), vous pouvez changer dans la requÃªte la valeur que vous souhaitez forcer par brute force pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` et ensuite sÃ©lectionner le **`examples/race-single-packer-attack.py`** dans le menu dÃ©roulant :

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer diffÃ©rentes valeurs**, vous pourriez modifier le code avec celui qui utilise une liste de mots du presse-papiers :
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si le web ne prend pas en charge HTTP2 (seulement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Attaque en un seul paquet HTTP2 (Plusieurs points de terminaison)** : Si vous devez envoyer une requÃªte Ã  1 point de terminaison puis plusieurs Ã  d'autres points de terminaison pour dÃ©clencher le RCE, vous pouvez modifier le script `race-single-packet-attack.py` avec quelque chose comme :
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Il est Ã©galement disponible dans **Repeater** via la nouvelle option '**Envoyer le groupe en parallÃ¨le**' dans Burp Suite.
* Pour **limit-overrun**, vous pourriez simplement ajouter **la mÃªme requÃªte 50 fois** dans le groupe.
* Pour **connection warming**, vous pourriez **ajouter** au **dÃ©but** du **groupe** quelques **requÃªtes** vers une partie non statique du serveur web.
* Pour **retarder** le processus **entre** le traitement **d'une requÃªte et d'une autre** en 2 Ã©tapes de sous-Ã©tats, vous pourriez **ajouter des requÃªtes supplÃ©mentaires entre** les deux requÃªtes.
* Pour un RC **multi-endpoint**, vous pourriez commencer par envoyer la **requÃªte** qui **va vers l'Ã©tat cachÃ©** puis **50 requÃªtes** juste aprÃ¨s qui **exploitent l'Ã©tat cachÃ©**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

Avant les recherches prÃ©cÃ©dentes, voici quelques payloads utilisÃ©s qui tentaient simplement d'envoyer les paquets le plus rapidement possible pour provoquer un RC.

* **Repeater :** Consultez les exemples de la section prÃ©cÃ©dente.
* **Intruder :** Envoyez la **requÃªte** Ã  **Intruder**, rÃ©glez le **nombre de threads** Ã  **30** dans le **menu Options et,** sÃ©lectionnez comme payload **Null payloads** et gÃ©nÃ©rez **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **MÃ©thodologie RC**

### DÃ©passement de limite / TOCTOU

C'est le type le plus basique de condition de concurrence oÃ¹ les **vulnÃ©rabilitÃ©s** **apparaissent** dans des endroits qui **limitent le nombre de fois oÃ¹ vous pouvez effectuer une action**. Comme utiliser plusieurs fois le mÃªme code de rÃ©duction dans une boutique en ligne. Un exemple trÃ¨s simple peut Ãªtre trouvÃ© dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bogue**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variations de ce type d'attaque, y compris :

* Utiliser plusieurs fois une carte cadeau
* Noter plusieurs fois un produit
* Retirer ou transfÃ©rer de l'argent au-delÃ  du solde de votre compte
* RÃ©utiliser une seule solution CAPTCHA
* Contourner une limite de taux anti-force brute

### **Sous-Ã©tats cachÃ©s**

D'autres RC plus compliquÃ©s exploiteront les **sous-Ã©tats dans l'Ã©tat de la machine** qui pourraient permettre Ã  un attaquant d'**abuser** d'Ã©tats auxquels il **n'Ã©tait jamais censÃ© avoir accÃ¨s**, mais il existe une **petite fenÃªtre** pour que l'attaquant y accÃ¨de.

1. **PrÃ©dire les sous-Ã©tats cachÃ©s et intÃ©ressants potentiels**

La premiÃ¨re Ã©tape consiste Ã  identifier tous les points de terminaison qui Ã©crivent dessus, ou lisent des donnÃ©es Ã  partir de celui-ci et utilisent ensuite ces donnÃ©es pour quelque chose d'important. Par exemple, les utilisateurs peuvent Ãªtre stockÃ©s dans une table de base de donnÃ©es qui est modifiÃ©e par l'inscription, les modifications de profil, l'initiation de rÃ©initialisation de mot de passe et la complÃ©tion de rÃ©initialisation de mot de passe.

Nous pouvons utiliser trois questions clÃ©s pour Ã©carter les points de terminaison qui sont peu susceptibles de provoquer des collisions. Pour chaque objet et les points de terminaison associÃ©s, demandez :

* **Comment l'Ã©tat est-il stockÃ© ?**

Les donnÃ©es stockÃ©es dans une structure de donnÃ©es persistante cÃ´tÃ© serveur sont idÃ©ales pour l'exploitation. Certains points de terminaison stockent leur Ã©tat entiÃ¨rement cÃ´tÃ© client, comme les rÃ©initialisations de mot de passe qui fonctionnent en envoyant un JWT par e-mail - ceux-ci peuvent Ãªtre ignorÃ©s en toute sÃ©curitÃ©.

Les applications stockent souvent un certain Ã©tat dans la session utilisateur. Celles-ci sont souvent quelque peu protÃ©gÃ©es contre les sous-Ã©tats - plus Ã  ce sujet plus tard.

* **Modifions-nous ou ajoutons-nous ?**

Les opÃ©rations qui modifient des donnÃ©es existantes (telles que le changement de l'adresse e-mail principale d'un compte) ont un potentiel de collision important, tandis que les actions qui ajoutent simplement Ã  des donnÃ©es existantes (telles que l'ajout d'une adresse e-mail supplÃ©mentaire) sont peu susceptibles d'Ãªtre vulnÃ©rables Ã  autre chose que des attaques de dÃ©passement de limite.

* **Sur quoi l'opÃ©ration est-elle basÃ©e ?**

La plupart des points de terminaison opÃ¨rent sur un enregistrement spÃ©cifique, qui est recherchÃ© Ã  l'aide d'une 'clÃ©', telle qu'un nom d'utilisateur, un jeton de rÃ©initialisation de mot de passe ou un nom de fichier. Pour une attaque rÃ©ussie, nous avons besoin de deux opÃ©rations qui utilisent la mÃªme clÃ©. Par exemple, imaginez deux implÃ©mentations plausibles de rÃ©initialisation de mot de passe :

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. **Chercher des indices**

Ã€ ce stade, il est temps de **lancer des attaques RC** sur les points de terminaison potentiellement intÃ©ressants pour essayer de trouver des rÃ©sultats inattendus par rapport aux rÃ©sultats habituels. **Tout Ã©cart par rapport Ã  la rÃ©ponse attendue**, tel qu'un changement dans une ou plusieurs rÃ©ponses, ou un effet secondaire comme un contenu d'e-mail diffÃ©rent ou un changement visible dans votre session, pourrait Ãªtre un indice indiquant que quelque chose ne va pas.

3. **Prouver le concept**

La derniÃ¨re Ã©tape consiste Ã  **prouver le concept et Ã  le transformer en une attaque viable**.

Lorsque vous envoyez un lot de requÃªtes, vous pouvez constater qu'une paire de requÃªtes initiales dÃ©clenche un Ã©tat final vulnÃ©rable, mais que les requÃªtes ultÃ©rieures l'Ã©crasent/l'invalident et que l'Ã©tat final n'est pas exploitable. Dans ce scÃ©nario, vous voudrez Ã©liminer toutes les requÃªtes inutiles - deux devraient suffire pour exploiter la plupart des vulnÃ©rabilitÃ©s. Cependant, rÃ©duire Ã  deux requÃªtes rendra l'attaque plus sensible au timing, vous devrez donc peut-Ãªtre rÃ©essayer l'attaque plusieurs fois ou l'automatiser.

### Attaques sensibles au temps

Parfois, vous ne trouverez peut-Ãªtre pas de conditions de concurrence, mais les **techniques de livraison de requÃªtes avec un timing prÃ©cis** peuvent encore rÃ©vÃ©ler la prÃ©sence d'autres vulnÃ©rabilitÃ©s.

Un tel exemple est lorsque des **horodatages de haute rÃ©solution sont utilisÃ©s au lieu de chaÃ®nes alÃ©atoires sÃ©curisÃ©es cryptographiquement** pour gÃ©nÃ©rer des jetons de sÃ©curitÃ©.

ConsidÃ©rez un **jeton de rÃ©initialisation de mot de passe qui est seulement randomisÃ© en utilisant un horodatage**. Dans ce cas, il pourrait Ãªtre possible de **dÃ©clencher deux rÃ©initialisations de mot de passe pour deux utilisateurs diffÃ©rents**, qui utilisent tous les deux le **mÃªme jeton**. Tout ce que vous avez Ã  faire est de synchroniser les requÃªtes pour qu'elles gÃ©nÃ¨rent le mÃªme horodatage.

{% hint style="warning" %}
Pour confirmer par exemple la situation prÃ©cÃ©dente, vous pourriez simplement demander **2 jetons de rÃ©initialisation de mot de passe en mÃªme temps** (en utilisant une attaque par paquet unique) et vÃ©rifier s'ils sont les **mÃªmes**.
{% endhint %}

VÃ©rifiez l'[**exemple dans ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Ã‰tudes de cas sur les sous-Ã©tats cachÃ©s

### Payer & ajouter un article

[**VÃ©rifiez ce laboratoire**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans un magasin et **ajouter un article supplÃ©mentaire** que vous **n'aurez pas Ã  payer**.

### Confirmer d'autres e-mails

L'idÃ©e est de **vÃ©rifier une adresse e-mail et de la changer pour une autre en mÃªme temps** pour dÃ©couvrir si la plateforme vÃ©rifie la nouvelle qui a Ã©tÃ© changÃ©e.

### Changer d'e-mail en 2 adresses e-mails basÃ©es sur les cookies

Selon [**ce compte-rendu**](https://portswigger.net/research/smashing-the-state-machine) Gitlab Ã©tait vulnÃ©rable Ã  une prise de contrÃ´le de cette maniÃ¨re car il pourrait **envoyer** le **jeton de vÃ©rification d'e-mail d'un e-mail Ã  l'autre e-mail**.

Vous pouvez Ã©galement vÃ©rifier [**ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) pour en savoir plus Ã  ce sujet.

### Ã‰tats de base de donnÃ©es cachÃ©s / Contournement de confirmation

Si **2 Ã©critures diffÃ©rentes** sont utilisÃ©es pour **ajouter** des **informations** dans une **base de donnÃ©es**, il existe une petite portion de temps oÃ¹ **seules les premiÃ¨res donnÃ©es ont Ã©tÃ© Ã©crites** dans la base de donnÃ©es. Par exemple, lors de la crÃ©ation d'un utilisateur, le **nom d'utilisateur** et le **mot de passe** pourraient Ãªtre **Ã©crits** et **ensuite le jeton** pour confirmer le compte nouvellement crÃ©Ã© est Ã©crit. Cela signifie que pendant un court moment, le **jeton pour confirmer un compte est nul**.

Par consÃ©quent, **enregistrer un compte et envoyer plusieurs requÃªtes avec un jeton vide** (`token=` ou `token[]=` ou toute autre variation) pour confirmer le compte immÃ©diatement pourrait permettre de **confirmer un compte** oÃ¹ vous ne contrÃ´lez pas l'e-mail.

VÃ©rifiez [**ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) pour voir un exemple.

### Contourner le 2FA

Le pseudo-code suivant montre comment un site Web pourrait Ãªtre vulnÃ©rable Ã  une variation de course de cette attaque :
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
Comme vous pouvez le voir, il s'agit en fait d'une **sÃ©quence multi-Ã©tapes dans la durÃ©e d'une seule requÃªte**. Plus important encore, elle passe par un sous-Ã©tat dans lequel l'**utilisateur a temporairement une session valide connectÃ©e**, **mais l'authentification multifacteur n'est pas encore appliquÃ©e**. Un attaquant pourrait potentiellement exploiter cela en envoyant une demande de connexion avec une demande Ã  un point de terminaison sensible et authentifiÃ©.

### Persistance Ã©ternelle OAuth2

Il existe plusieurs [**fournisseurs OAuth**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ces services vous permettent de crÃ©er une application et d'authentifier les utilisateurs que le fournisseur a enregistrÃ©s. Pour ce faire, le **client** devra **autoriser votre application** Ã  accÃ©der Ã  certaines de leurs donnÃ©es Ã  l'intÃ©rieur du **fournisseur OAuth**.\
Jusqu'ici, c'est juste une connexion classique avec Google/LinkedIn/GitHub... oÃ¹ une page s'affiche disant : "_L'application \<InsertCoolName> souhaite accÃ©der Ã  vos informations, voulez-vous l'autoriser ?_"

#### Condition de concurrence dans `authorization_code`

Le **problÃ¨me** apparaÃ®t lorsque vous **l'acceptez** et que cela envoie automatiquement un **`authorization_code`** Ã  l'application malveillante. Ensuite, cette **application abuse d'une condition de concurrence dans le fournisseur de services OAuth pour gÃ©nÃ©rer plus d'un AT/RT** (_Token d'Authentification/Token de RafraÃ®chissement_) Ã  partir du **`authorization_code`** pour votre compte. En gros, elle va abuser du fait que vous avez acceptÃ© l'application pour accÃ©der Ã  vos donnÃ©es pour **crÃ©er plusieurs comptes**. Ensuite, si vous **arrÃªtez d'autoriser l'application Ã  accÃ©der Ã  vos donnÃ©es, une paire d'AT/RT sera supprimÃ©e, mais les autres resteront valides**.

#### Condition de concurrence dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pourriez essayer de **l'abuser pour gÃ©nÃ©rer plusieurs AT/RT** et **mÃªme si l'utilisateur annule les permissions** pour que l'application malveillante accÃ¨de Ã  ses donnÃ©es, **plusieurs RT resteront valides**.

## **RC dans WebSockets**

Dans [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC), vous pouvez trouver un PoC en Java pour envoyer des messages WebSocket en **parallÃ¨le** pour abuser des **conditions de concurrence Ã©galement dans les WebSockets**.

## RÃ©fÃ©rences

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersÃ©curitÃ©** ? Vous voulez voir votre **entreprise annoncÃ©e dans HackTricks** ? ou voulez-vous avoir accÃ¨s Ã  la **derniÃ¨re version du PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* DÃ©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs exclusifs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**dÃ©pÃ´t hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**dÃ©pÃ´t hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** facilement, alimentÃ©s par les outils communautaires **les plus avancÃ©s**.\
AccÃ©dez-y dÃ¨s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
