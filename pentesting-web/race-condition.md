# Condition de course

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour crÃ©er facilement et **automatiser des flux de travail** alimentÃ©s par les outils communautaires les plus avancÃ©s au monde.\
AccÃ©dez dÃ¨s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersÃ©curitÃ©** ? Vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ? ou souhaitez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Exploitation de la condition de course

Le principal problÃ¨me de l'exploitation des conditions de course est que vous avez besoin que les requÃªtes soient traitÃ©es en parallÃ¨le avec une trÃ¨s courte diffÃ©rence de temps (gÃ©nÃ©ralement >1ms). Dans la section suivante, diffÃ©rentes solutions sont proposÃ©es pour rendre cela possible.

<figure><img src="../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

### Attaque Ã  un seul paquet (HTTP/2) / Synchronisation du dernier octet (HTTP/1.1)

HTTP2 permet d'envoyer **2 requÃªtes dans une seule connexion TCP** (alors que dans HTTP/1.1, elles doivent Ãªtre sÃ©quentielles).\
L'utilisation d'un seul paquet TCP Ã©limine complÃ¨tement l'effet des variations de rÃ©seau, il y a donc clairement un potentiel pour des attaques par condition de course. Cependant, **deux requÃªtes ne suffisent pas pour une attaque par condition de course fiable** grÃ¢ce Ã  la **variation cÃ´tÃ© serveur** - des variations dans le temps de traitement des requÃªtes de l'application causÃ©es par des variables incontrÃ´lables telles que la contention du processeur.

Mais, en utilisant la technique de '**synchronisation du dernier octet**' d'HTTP/1.1, il est possible d'envoyer prÃ©alablement la majeure partie des donnÃ©es en retenant un petit fragment de chaque requÃªte, puis de 'complÃ©ter' **20 Ã  30 requÃªtes avec un seul paquet TCP**.

Pour **envoyer prÃ©alablement la majeure partie de chaque requÃªte** :

- Si la requÃªte n'a pas de corps, envoyez tous les en-tÃªtes, mais ne dÃ©finissez pas le drapeau END\_STREAM. Retenez un cadre de donnÃ©es vide avec le drapeau END\_STREAM dÃ©fini.
- Si la requÃªte a un corps, envoyez les en-tÃªtes et toutes les donnÃ©es du corps sauf le dernier octet. Retenez un cadre de donnÃ©es contenant le dernier octet.

Ensuite, **prÃ©parez-vous Ã  envoyer les cadres finaux** :

- Attendez 100 ms pour vous assurer que les cadres initiaux ont Ã©tÃ© envoyÃ©s.
- Assurez-vous que TCP\_NODELAY est dÃ©sactivÃ© - il est crucial que l'algorithme de Nagle regroupe les cadres finaux.
- Envoyez un paquet de ping pour rÃ©chauffer la connexion locale. Si vous ne le faites pas, la pile rÃ©seau du systÃ¨me d'exploitation placera le premier cadre final dans un paquet sÃ©parÃ©.

Enfin, envoyez les cadres retenus. Vous devriez pouvoir vÃ©rifier qu'ils sont arrivÃ©s dans un seul paquet en utilisant Wireshark.

{% hint style="info" %}
Notez que cela **ne fonctionne pas pour les fichiers statiques** sur certains serveurs, mais les fichiers statiques ne sont pas pertinents pour les attaques par condition de course. Mais les fichiers statiques sont sans importance pour les attaques RC.
{% endhint %}

En utilisant cette technique, vous pouvez faire en sorte que 20 Ã  30 requÃªtes arrivent simultanÃ©ment sur le serveur, indÃ©pendamment des variations du rÃ©seau :

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

**Adaptation Ã  l'architecture cible**

Il est important de noter que de nombreuses applications se trouvent derriÃ¨re un serveur frontal, et celui-ci peut dÃ©cider de transfÃ©rer certaines requÃªtes sur des connexions existantes vers l'arriÃ¨re-plan, et de crÃ©er de nouvelles connexions pour d'autres.

Par consÃ©quent, il est important de ne pas attribuer des dÃ©lais de requÃªte incohÃ©rents au comportement de l'application, tel que des mÃ©canismes de verrouillage qui n'autorisent qu'un seul thread Ã  accÃ©der Ã  une ressource Ã  la fois. De plus, le routage des requÃªtes cÃ´tÃ© frontal est souvent effectuÃ© sur une base de connexion, vous pouvez donc lisser le dÃ©lai des requÃªtes en effectuant un prÃ©chauffage de la connexion cÃ´tÃ© serveur - **envoyer quelques requÃªtes insignifiantes sur votre connexion avant de lancer l'attaque** (il s'agit simplement d'envoyer plusieurs requÃªtes avant de commencer l'attaque proprement dite).

#### MÃ©canismes de verrouillage basÃ©s sur la session <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

Certains frameworks tentent de prÃ©venir la corruption accidentelle des donnÃ©es en utilisant une forme de **verrouillage de requÃªte**. Par exemple, le module de gestionnaire de session natif de **PHP ne traite qu'une seule requÃªte par session Ã  la fois**.

Il est extrÃªmement important de repÃ©rer ce type de comportement, car il peut masquer des vulnÃ©rabilitÃ©s facilement exploitables. Si vous remarquez que toutes vos requÃªtes sont traitÃ©es sÃ©quentiellement, essayez de les envoyer chacune avec un jeton de session diffÃ©rent.
#### **Abus des limites de taux ou de ressources**

Si le rÃ©chauffement de la connexion ne fait aucune diffÃ©rence, il existe diffÃ©rentes solutions Ã  ce problÃ¨me.

En utilisant Turbo Intruder, vous pouvez introduire un court dÃ©lai cÃ´tÃ© client. Cependant, comme cela implique de diviser vos requÃªtes d'attaque rÃ©elles en plusieurs paquets TCP, vous ne pourrez pas utiliser la technique d'attaque en un seul paquet. Par consÃ©quent, sur des cibles Ã  forte gigue, l'attaque est peu susceptible de fonctionner de maniÃ¨re fiable, quel que soit le dÃ©lai que vous dÃ©finissez.

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Au lieu de cela, vous pouvez rÃ©soudre ce problÃ¨me en abusant d'une fonctionnalitÃ© de sÃ©curitÃ© courante.

Les serveurs Web retardent souvent le traitement des requÃªtes s'il en est envoyÃ© trop rapidement. En envoyant un grand nombre de requÃªtes factices pour dÃ©clencher intentionnellement la limite de taux ou de ressources, vous pouvez provoquer un dÃ©lai appropriÃ© cÃ´tÃ© serveur. Cela rend l'attaque en un seul paquet viable mÃªme lorsque l'exÃ©cution retardÃ©e est nÃ©cessaire.

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Pour plus d'informations sur cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Exemples d'attaque

* **Tubo Intruder - Attaque en un seul paquet HTTP2 (1 point d'extrÃ©mitÃ©)**: Vous pouvez envoyer la requÃªte Ã  **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), vous pouvez modifier dans la requÃªte la valeur que vous souhaitez forcer par **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` puis sÃ©lectionnez **`examples/race-single-packer-attack.py`** dans la liste dÃ©roulante:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer des valeurs diffÃ©rentes**, vous pouvez modifier le code avec celui-ci qui utilise une liste de mots depuis le presse-papiers:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si le site web ne prend pas en charge HTTP2 (seulement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` Ã  la place de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Attaque Ã  un seul paquet HTTP2 (Plusieurs points d'extrÃ©mitÃ©)**: Si vous avez besoin d'envoyer une requÃªte Ã  un point d'extrÃ©mitÃ©, puis plusieurs Ã  d'autres points d'extrÃ©mitÃ© pour dÃ©clencher l'exÃ©cution de code Ã  distance (RCE), vous pouvez modifier le script `race-single-packet-attack.py` comme suit:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Il est Ã©galement disponible dans **Repeater** via la nouvelle option '**Envoyer le groupe en parallÃ¨le**' dans Burp Suite.
* Pour **dÃ©passer la limite**, vous pouvez simplement ajouter la **mÃªme requÃªte 50 fois** dans le groupe.
* Pour **chauffer la connexion**, vous pouvez **ajouter** au **dÃ©but** du **groupe** quelques **requÃªtes** vers une partie non statique du serveur web.
* Pour **retarder** le processus **entre** le traitement **d'une requÃªte et d'une autre** en deux Ã©tapes de sous-Ã©tats, vous pouvez **ajouter des requÃªtes supplÃ©mentaires entre** les deux requÃªtes.
* Pour un RC Ã  **multi-point d'extrÃ©mitÃ©**, vous pouvez commencer par envoyer la **requÃªte** qui **va vers l'Ã©tat cachÃ©** puis **50 requÃªtes** juste aprÃ¨s qui **exploitent l'Ã©tat cachÃ©**.

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### Bruteforce brut

Avant les recherches prÃ©cÃ©dentes, voici quelques charges utiles utilisÃ©es qui tentaient simplement d'envoyer les paquets aussi rapidement que possible pour provoquer un RC.

* **Repeater:** Consultez les exemples de la section prÃ©cÃ©dente.
* **Intruder**: Envoyez la **requÃªte** Ã  **Intruder**, dÃ©finissez le **nombre de threads** sur **30** dans le menu **Options**, sÃ©lectionnez comme charge utile **Null payloads** et gÃ©nÃ©rez **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **MÃ©thodologie RC**

### DÃ©passement de limite / TOCTOU

Il s'agit du type le plus basique de condition de concurrence oÃ¹ des **vulnÃ©rabilitÃ©s** apparaissent dans des endroits qui **limitent le nombre de fois oÃ¹ vous pouvez effectuer une action**. Par exemple, utiliser plusieurs fois le mÃªme code de rÃ©duction dans une boutique en ligne. Un exemple trÃ¨s simple peut Ãªtre trouvÃ© dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bogue**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variations de ce type d'attaque, notamment :

* Utiliser plusieurs fois une carte-cadeau
* Noter un produit plusieurs fois
* Retirer ou transfÃ©rer de l'argent en excÃ©dent de votre solde de compte
* RÃ©utiliser une solution CAPTCHA unique
* Contourner une limite de taux anti-brute force

### **Sous-Ã©tats cachÃ©s**

Les RC les plus complexes exploiteront des **sous-Ã©tats dans l'Ã©tat de la machine** qui pourraient permettre Ã  un attaquant d'**abuser** d'Ã©tats auxquels il n'Ã©tait **jamais censÃ© avoir accÃ¨s**, mais il existe une **petite fenÃªtre** pour que l'attaquant y accÃ¨de.

1. **PrÃ©dire les sous-Ã©tats cachÃ©s et intÃ©ressants potentiels**

La premiÃ¨re Ã©tape consiste Ã  identifier tous les points d'extrÃ©mitÃ© qui Ã©crivent ou lisent des donnÃ©es Ã  partir de celles-ci, puis utilisent ces donnÃ©es pour quelque chose d'important. Par exemple, les utilisateurs peuvent Ãªtre stockÃ©s dans une table de base de donnÃ©es qui est modifiÃ©e lors de l'inscription, de la modification du profil, de l'initiation de la rÃ©initialisation du mot de passe et de la finalisation de la rÃ©initialisation du mot de passe.

Nous pouvons utiliser trois questions clÃ©s pour exclure les points d'extrÃ©mitÃ© qui sont peu susceptibles de provoquer des collisions. Pour chaque objet et les points d'extrÃ©mitÃ© associÃ©s, demandez-vous :

* **Comment l'Ã©tat est-il stockÃ© ?**

Les donnÃ©es stockÃ©es dans une structure de donnÃ©es cÃ´tÃ© serveur persistante sont idÃ©ales pour l'exploitation. Certains points d'extrÃ©mitÃ© stockent leur Ã©tat entiÃ¨rement cÃ´tÃ© client, comme les rÃ©initialisations de mot de passe qui fonctionnent en envoyant un JWT par e-mail - ceux-ci peuvent Ãªtre ignorÃ©s en toute sÃ©curitÃ©.

Les applications stockent souvent certains Ã©tats dans la session utilisateur. Ceux-ci sont souvent quelque peu protÃ©gÃ©s contre les sous-Ã©tats - nous en parlerons plus tard.

* **Effectuons-nous une modification ou un ajout ?**

Les opÃ©rations qui modifient des donnÃ©es existantes (comme le changement de l'adresse e-mail principale d'un compte) ont un potentiel de collision important, tandis que les actions qui se contentent d'ajouter des donnÃ©es existantes (comme l'ajout d'une adresse e-mail supplÃ©mentaire) sont peu susceptibles d'Ãªtre vulnÃ©rables Ã  autre chose qu'Ã  des attaques de dÃ©passement de limite.

* **Sur quoi l'opÃ©ration est-elle basÃ©e ?**

La plupart des points d'extrÃ©mitÃ© fonctionnent sur un enregistrement spÃ©cifique, qui est recherchÃ© Ã  l'aide d'une "clÃ©", telle qu'un nom d'utilisateur, un jeton de rÃ©initialisation de mot de passe ou un nom de fichier. Pour une attaque rÃ©ussie, nous avons besoin de deux opÃ©rations qui utilisent la mÃªme clÃ©. Par exemple, imaginons deux implÃ©mentations plausibles de rÃ©initialisation de mot de passe :

<figure><img src="../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

2. **Rechercher des indices**

Ã€ ce stade, il est temps de **lancer des attaques RC** sur les points d'extrÃ©mitÃ© potentiellement intÃ©ressants pour essayer de trouver des rÃ©sultats inattendus par rapport aux rÃ©sultats habituels. **Toute dÃ©viation de la rÃ©ponse attendue**, telle qu'un changement dans une ou plusieurs rÃ©ponses, ou un effet de second ordre tel que des contenus d'e-mail diffÃ©rents ou un changement visible dans votre session, pourrait Ãªtre un indice indiquant un problÃ¨me.

3. **Prouver le concept**

La derniÃ¨re Ã©tape consiste Ã  **prouver le concept et Ã  le transformer en une attaque viable**.

Lorsque vous envoyez un lot de requÃªtes, vous pouvez constater qu'une paire de requÃªtes initiale dÃ©clenche un Ã©tat final vulnÃ©rable, mais que les requÃªtes ultÃ©rieures l'Ã©crasent/invalident et que l'Ã©tat final n'est pas exploitable. Dans ce scÃ©nario, vous voudrez Ã©liminer toutes les requÃªtes inutiles - deux devraient suffire pour exploiter la plupart des vulnÃ©rabilitÃ©s. Cependant, passer Ã  deux requÃªtes rendra l'attaque plus sensible au timing, vous devrez donc peut-Ãªtre rÃ©essayer l'attaque plusieurs fois ou l'automatiser.

### Attaques sensibles au temps

Parfois, vous ne trouverez peut-Ãªtre pas de conditions de concurrence, mais les **techniques permettant de livrer des requÃªtes avec une synchronisation prÃ©cise** peuvent nÃ©anmoins rÃ©vÃ©ler la prÃ©sence d'autres vulnÃ©rabilitÃ©s.

Un exemple est lorsque des **horodatages haute rÃ©solution sont utilisÃ©s au lieu de chaÃ®nes alÃ©atoires cryptographiquement** sÃ©curisÃ©es pour gÃ©nÃ©rer des jetons de sÃ©curitÃ©.

ConsidÃ©rons un **jeton de rÃ©initialisation de mot de passe qui n'est alÃ©atoire qu'Ã  l'aide d'un horodatage**. Dans ce cas, il pourrait Ãªtre possible de **dÃ©clencher deux rÃ©initialisations de mot de passe pour deux utilisateurs diffÃ©rents**, qui utilisent tous deux le **mÃªme jeton**. Il vous suffit de synchroniser les requÃªtes de maniÃ¨re Ã  ce qu'elles gÃ©nÃ¨rent le mÃªme horodatage.

{% hint style="warning" %}
Pour confirmer par exemple la situation prÃ©cÃ©dente, vous pourriez simplement demander **2 jetons de rÃ©initialisation de mot de passe en mÃªme temps** (en utilisant une attaque Ã  paquet unique) et vÃ©rifier s'ils sont **identiques**.
{% endhint %}

Consultez l'[**exemple dans ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Ã‰tudes de cas sur les sous-Ã©tats cachÃ©s

### Payer et ajouter un article

[**Consultez ce laboratoire**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans un magasin et **ajouter un article supplÃ©mentaire** pour lequel vous n'aurez pas besoin de payer.

### Confirmer d'autres e-mails

L'idÃ©e est de **vÃ©rifier une adresse e-mail et de la changer en une autre en mÃªme temps** pour savoir si la plateforme vÃ©rifie la nouvelle adresse modifiÃ©e.

### Changer l'e-mail en 2 adresses e-mail basÃ©es sur les cookies

Selon [**cet article**](https://portswigger.net/research/smashing-the-state-machine), Gitlab Ã©tait vulnÃ©rable Ã  une prise de contrÃ´le de cette maniÃ¨re car il pourrait **envoyer** le **jeton de vÃ©rification d'e-mail d'un e-mail Ã  l'autre**.

Vous pouvez Ã©galement consulter [**ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) pour en savoir plus Ã  ce sujet.

### Ã‰tats cachÃ©s de la base de donnÃ©es / Contournement de confirmation

Si **2 Ã©critures diffÃ©rentes** sont utilisÃ©es pour **ajouter** des **informations** dans une **base de donnÃ©es**, il existe une petite pÃ©riode de temps oÃ¹ **seules les premiÃ¨res donnÃ©es ont Ã©tÃ© Ã©crites** dans la base de donnÃ©es. Par exemple, lors de la crÃ©ation d'un utilisateur, le **nom d'utilisateur** et le **mot de passe** peuvent Ãªtre **Ã©crits**, puis le jeton pour confirmer le compte nouvellement crÃ©Ã© est Ã©crit. Cela signifie que pendant un court laps de temps, le **jeton pour confirmer un compte est nul**.

Par consÃ©quent, **enregistrer un compte et envoyer plusieurs requÃªtes avec un jeton vide** (`token=` ou `token[]=` ou toute autre variation) pour confirmer le compte immÃ©diatement pourrait permettre de confirmer un compte dont vous ne contrÃ´lez pas l'e-mail.

Consultez [**ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) pour voir un exemple.

### Contourner l'authentification Ã  deux facteurs (2FA)

Le pseudo-code suivant montre comment un site web pourrait Ãªtre vulnÃ©rable Ã  une variation de cette attaque basÃ©e sur la concurrence :
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
Comme vous pouvez le voir, il s'agit en fait d'une **sÃ©quence en plusieurs Ã©tapes dans le cadre d'une seule requÃªte**. Plus important encore, elle passe par un sous-Ã©tat dans lequel l'utilisateur dispose temporairement d'une session valide connectÃ©e, **mais oÃ¹ la MFA n'est pas encore appliquÃ©e**. Un attaquant pourrait potentiellement exploiter cela en envoyant une demande de connexion accompagnÃ©e d'une demande Ã  un point de terminaison sensible et authentifiÃ©.

### Persistance Ã©ternelle d'OAuth2

Il existe plusieurs [**fournisseurs OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ces services vous permettront de crÃ©er une application et d'authentifier les utilisateurs enregistrÃ©s auprÃ¨s du fournisseur. Pour ce faire, le **client** devra **autoriser votre application** Ã  accÃ©der Ã  certaines de leurs donnÃ©es Ã  l'intÃ©rieur du **fournisseur OAuth**.\
Jusqu'ici, il s'agit simplement d'une connexion classique avec Google/LinkedIn/GitHub... oÃ¹ vous Ãªtes invitÃ© avec une page disant : "_L'application \<InsertCoolName> souhaite accÃ©der Ã  vos informations, voulez-vous l'autoriser ?_"

#### Condition de concurrence dans `authorization_code`

Le **problÃ¨me** survient lorsque vous **l'acceptez** et envoie automatiquement un **`authorization_code`** Ã  l'application malveillante. Ensuite, cette **application exploite une condition de concurrence dans le fournisseur de services OAuth pour gÃ©nÃ©rer plus d'un AT/RT** (_Authentication Token/Refresh Token_) Ã  partir du **`authorization_code`** pour votre compte. Fondamentalement, elle exploitera le fait que vous avez acceptÃ© l'application pour accÃ©der Ã  vos donnÃ©es afin de **crÃ©er plusieurs comptes**. Ensuite, si vous **arrÃªtez d'autoriser l'application Ã  accÃ©der Ã  vos donnÃ©es, une paire AT/RT sera supprimÃ©e, mais les autres resteront valides**.

#### Condition de concurrence dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pouvez essayer de **l'exploiter pour gÃ©nÃ©rer plusieurs AT/RT** et **mÃªme si l'utilisateur annule les autorisations** pour l'application malveillante d'accÃ©der Ã  ses donnÃ©es, **plusieurs RT resteront valides**.

## RÃ©fÃ©rences

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersÃ©curitÃ©** ? Vous souhaitez voir votre **entreprise annoncÃ©e dans HackTricks** ? ou souhaitez-vous avoir accÃ¨s Ã  la **derniÃ¨re version de PEASS ou tÃ©lÃ©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* DÃ©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs.
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com).
* **Rejoignez le** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour crÃ©er et **automatiser facilement des workflows** alimentÃ©s par les outils communautaires les plus avancÃ©s au monde.\
AccÃ©dez dÃ¨s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
