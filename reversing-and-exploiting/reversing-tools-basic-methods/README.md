# Reversing Tools & Basic Methods

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

**Try Hard Security Group**

<figure><img src="../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Alati za Reversing bazirani na ImGui-u

Softver:

* ReverseKit: [https://github.com/zer0condition/ReverseKit](https://github.com/zer0condition/ReverseKit)

## Wasm dekompajler / Wat kompajler

Online:

* Koristite [https://webassembly.github.io/wabt/demo/wasm2wat/index.html](https://webassembly.github.io/wabt/demo/wasm2wat/index.html) za **dekompajliranje** iz wasm (binarno) u wat (캜isti tekst)
* Koristite [https://webassembly.github.io/wabt/demo/wat2wasm/](https://webassembly.github.io/wabt/demo/wat2wasm/) za **kompajliranje** iz wat u wasm
* Mo쬰te tako캠e probati da koristite [https://wwwg.github.io/web-wasmdec/](https://wwwg.github.io/web-wasmdec/) za dekompajliranje

Softver:

* [https://www.pnfsoftware.com/jeb/demo](https://www.pnfsoftware.com/jeb/demo)
* [https://github.com/wwwg/wasmdec](https://github.com/wwwg/wasmdec)

## .NET dekompajler

### [dotPeek](https://www.jetbrains.com/decompiler/)

dotPeek je dekompajler koji **dekompajlira i analizira vi코e formata**, uklju캜uju캖i **biblioteke** (.dll), **Windows metapodatke** (.winmd) i **izvr코ne datoteke** (.exe). Nakon dekompajliranja, skup mo쬰 biti sa캜uvan kao Visual Studio projekat (.csproj).

Prednost ovde je da ako izgubljeni izvorni kod zahteva obnovu iz zastarele skup코tine, ova akcija mo쬰 u코tedeti vreme. Nadalje, dotPeek pru쬬 korisnu navigaciju kroz dekompajlirani kod, 캜ine캖i ga jednim od savr코enih alata za **Xamarin analizu algoritma.**

### [.NET Reflector](https://www.red-gate.com/products/reflector/)

Sa sveobuhvatnim modelom dodataka i API-jem koji pro코iruje alat da odgovara va코im ta캜nim potrebama, .NET Reflector 코tedi vreme i pojednostavljuje razvoj. Pogledajmo mno코tvo usluga za reverzno in쬰njerstvo koje ovaj alat pru쬬:

* Pru쬬 uvid u to kako podaci prolaze kroz biblioteku ili komponentu
* Pru쬬 uvid u implementaciju i upotrebu .NET jezika i okvira
* Pronalazi nedokumentovanu i neeksponiranu funkcionalnost kako bi se vi코e iskoristile API-ji i tehnologije koje se koriste.
* Pronalazi zavisnosti i razli캜ite skupove
* Pronalazi ta캜nu lokaciju gre코aka u va코em kodu, komponentama tre캖ih strana i bibliotekama.
* Debaguje izvor sveg .NET koda sa kojim radite.

### [ILSpy](https://github.com/icsharpcode/ILSpy) & [dnSpy](https://github.com/dnSpy/dnSpy/releases)

[ILSpy dodatak za Visual Studio Code](https://github.com/icsharpcode/ilspy-vscode): Mo쬰te ga imati na bilo kom OS-u (mo쬰te ga instalirati direktno iz VSCode-a, nije potrebno preuzimanje sa gita. Kliknite na **Extensions** i **pretra쬴te ILSpy**).\
Ako trebate **dekompajlirati**, **izmeniti** i **ponovo kompajlirati** mo쬰te koristiti [**dnSpy**](https://github.com/dnSpy/dnSpy/releases) ili aktivno odr쬬vanu verziju, [**dnSpyEx**](https://github.com/dnSpyEx/dnSpy/releases). (**Desni klik -> Modify Method** da promenite ne코to unutar funkcije).

### DNSpy Logging

Da biste omogu캖ili **DNSpy-u da bele쬴 neke informacije u datoteku**, mo쬰te koristiti ovaj isje캜ak:

```cs
using System.IO;
path = "C:\\inetpub\\temp\\MyTest2.txt";
File.AppendAllText(path, "Password: " + password + "\n");
```

### DNSpy Debugiranje

Da biste debagovali kod koriste캖i DNSpy, treba da:

Prvo, promenite **Atribute skupa podataka** koji se odnose na **debugiranje**:

![](<../../.gitbook/assets/image (278).png>)

```aspnet
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
```

Do:

```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default |
DebuggableAttribute.DebuggingModes.DisableOptimizations |
DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints |
DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```

I kliknite na **compile**:

![](<../../.gitbook/assets/image (314) (1) (1).png>)

Zatim sa캜uvajte novu datoteku preko _**File >> Save module...**_:

![](<../../.gitbook/assets/image (279).png>)

Ovo je neophodno jer ako to ne uradite, u **runtime-u** 캖e biti primenjene neke **optimizacije** na kod i mogu캖e je da prilikom **debugiranja** **break-point** nikada ne캖e biti dostignut ili neke **promenljive ne캖e postojati**.

Zatim, ako se va코a .NET aplikacija **pokre캖e** preko **IIS-a**, mo쬰te je **restartovati** sa:

```
iisreset /noforce
```

Zatim, kako biste zapo캜eli sa debagovanjem, trebalo bi da zatvorite sve otvorene datoteke i unutar **Debug taba** izaberete **Attach to Process...**:

![](<../../.gitbook/assets/image (280).png>)

Zatim izaberite **w3wp.exe** da se pove쬰te sa **IIS serverom** i kliknite na **attach**:

![](<../../.gitbook/assets/image (281).png>)

Sada kada debagujemo proces, vreme je da ga zaustavimo i u캜itamo sve module. Prvo kliknite na _Debug >> Break All_ a zatim kliknite na _**Debug >> Windows >> Modules**_:

![](<../../.gitbook/assets/image (286).png>)

![](<../../.gitbook/assets/image (283).png>)

Kliknite na bilo koji modul u **Modules** i izaberite **Open All Modules**:

![](<../../.gitbook/assets/image (284).png>)

Desni klik na bilo koji modul u **Assembly Exploreru** i kliknite na **Sort Assemblies**:

![](<../../.gitbook/assets/image (285).png>)

## Java dekompajler

[https://github.com/skylot/jadx](https://github.com/skylot/jadx)\
[https://github.com/java-decompiler/jd-gui/releases](https://github.com/java-decompiler/jd-gui/releases)

## Debagovanje DLL-ova

### Kori코캖enje IDA

* **U캜itajte rundll32** (64-bitni u C:\Windows\System32\rundll32.exe i 32-bitni u C:\Windows\SysWOW64\rundll32.exe)
* Izaberite **Windbg** debager
* Izaberite "**Suspend on library load/unload**"

![](<../../.gitbook/assets/image (135).png>)

* Konfiguri코ite **parametre** izvr코enja postavljaju캖i **putanju do DLL-a** i funkciju koju 쬰lite da pozovete:

![](<../../.gitbook/assets/image (136).png>)

Zatim, kada zapo캜nete sa debagovanjem, **izvr코enje 캖e biti zaustavljeno kada se svaki DLL u캜ita**, zatim, kada rundll32 u캜ita va코 DLL, izvr코enje 캖e biti zaustavljeno.

Ali, kako mo쬰te pristupiti kodu DLL-a koji je u캜itan? Kori코캖enjem ovog metoda, ne znam kako.

### Kori코캖enje x64dbg/x32dbg

* **U캜itajte rundll32** (64-bitni u C:\Windows\System32\rundll32.exe i 32-bitni u C:\Windows\SysWOW64\rundll32.exe)
* **Promenite Command Line** ( _File --> Change Command Line_ ) i postavite putanju do dll-a i funkciju koju 쬰lite da pozovete, na primer: "C:\Windows\SysWOW64\rundll32.exe" "Z:\shared\Cybercamp\rev2\\\14.ridii\_2.dll",DLLMain
* Promenite _Options --> Settings_ i izaberite "**DLL Entry**".
* Zatim **pokrenite izvr코enje**, debager 캖e se zaustaviti na svakom dll main, u nekom trenutku 캖ete **zastati u dll Entry va코eg dll-a**. Odande, jednostavno potra쬴te ta캜ke gde 쬰lite postaviti prekid.

Primetite da kada je izvr코enje zaustavljeno iz bilo kog razloga u win64dbg-u mo쬰te videti **u kojem kodu se nalazite** gledaju캖i u **vrhu prozora win64dbg**:

![](<../../.gitbook/assets/image (137).png>)

Zatim, gledaju캖i ovo, mo쬰te videti kada je izvr코enje zaustavljeno u dll-u koji 쬰lite da debagujete.

## GUI aplikacije / Video igre

[**Cheat Engine**](https://www.cheatengine.org/downloads.php) je koristan program za pronala쬰nje gde su va쬹e vrednosti sa캜uvane unutar memorije pokrenute igre i njihovo menjanje. Vi코e informacija u:

{% content-ref url="cheat-engine.md" %}
[cheat-engine.md](cheat-engine.md)
{% endcontent-ref %}

## ARM & MIPS

{% embed url="https://github.com/nongiach/arm_now" %}

## Shellkodovi

### Debagovanje shellkoda sa blobrunnerom

[**Blobrunner**](https://github.com/OALabs/BlobRunner) 캖e **dodeliti** shellkod unutar prostora memorije, **pokazati** vam **adresu memorije** gde je shellkod dodeljen i **zaustaviti** izvr코enje.\
Zatim, treba da **pove쬰te debager** (Ida ili x64dbg) sa procesom i postavite **prekid na ozna캜enu adresu memorije** i **nastavite** izvr코enje. Na ovaj na캜in 캖ete debagovati shellkod.

Stranica sa izdanjima na githubu sadr쬴 zipove sa kompilovanim izdanjima: [https://github.com/OALabs/BlobRunner/releases/tag/v0.0.5](https://github.com/OALabs/BlobRunner/releases/tag/v0.0.5)\
Mo쬰te prona캖i malo izmenjenu verziju Blobrunnera na slede캖em linku. Da biste je kompajlirali, jednostavno **napravite C/C++ projekat u Visual Studio Code-u, kopirajte i nalepite kod i izgradite ga**.

{% content-ref url="blobrunner.md" %}
[blobrunner.md](blobrunner.md)
{% endcontent-ref %}

### Debagovanje shellkoda sa jmp2it

[**jmp2it** ](https://github.com/adamkramer/jmp2it/releases/tag/v1.4)je vrlo sli캜an blobrunneru. On 캖e **dodeliti** shellkod unutar prostora memorije i pokrenuti **ve캜nu petlju**. Zatim treba da **pove쬰te debager** sa procesom, **pokrenete, sa캜ekate 2-5 sekundi i pritisnete stop** i na캖i 캖ete se unutar **ve캜ne petlje**. Sko캜ite na slede캖u instrukciju ve캜ne petlje jer 캖e to biti poziv shellkodu, i na kraju 캖ete se na캖i kako izvr코avate shellkod.

![](<../../.gitbook/assets/image (397).png>)

Mo쬰te preuzeti kompilovanu verziju [jmp2it sa stranice sa izdanjima](https://github.com/adamkramer/jmp2it/releases/).

### Debagovanje shellkoda kori코캖enjem Cutter-a

[**Cutter**](https://github.com/rizinorg/cutter/releases/tag/v1.12.0) je GUI za radare. Kori코캖enjem Cutter-a mo쬰te emulirati shellkod i dinami캜ki ga inspicirati.

Imajte na umu da Cutter vam omogu캖ava da "Otvorite datoteku" i "Otvorite shellkod". U mom slu캜aju, kada sam otvorio shellkod kao datoteku, dekompajlirao ga je ispravno, ali kada sam ga otvorio kao shellkod, nije:

![](<../../.gitbook/assets/image (400).png>)

Da biste zapo캜eli emulaciju na mestu gde 쬰lite, postavite prekidnu ta캜ku tamo i izgleda da 캖e Cutter automatski pokrenuti emulaciju od tamo:

![](<../../.gitbook/assets/image (399).png>)

![](<../../.gitbook/assets/image (401).png>)

Mo쬰te videti stek na primer unutar heksadecimalnog prikaza:

![](<../../.gitbook/assets/image (402).png>)

### Dekodiranje shellkoda i dobijanje izvr코enih funkcija

Treba da probate [**scdbg**](http://sandsprite.com/blogs/index.php?uid=7\&pid=152).\
Re캖i 캖e vam stvari poput **koje funkcije** shellkod koristi i da li se shellkod **dekodira** u memoriji.

```bash
scdbg.exe -f shellcode # Get info
scdbg.exe -f shellcode -r #show analysis report at end of run
scdbg.exe -f shellcode -i -r #enable interactive hooks (file and network) and show analysis report at end of run
scdbg.exe -f shellcode -d #Dump decoded shellcode
scdbg.exe -f shellcode /findsc #Find offset where starts
scdbg.exe -f shellcode /foff 0x0000004D #Start the executing in that offset
```

scDbg tako캠e ima grafi캜ki pokreta캜 gde mo쬰te izabrati opcije koje 쬰lite i izvr코iti shellcode

![](<../../.gitbook/assets/image (398).png>)

Opcija **Create Dump** 캖e izbaciti kona캜ni shellcode ako je bilo kakva promena ura캠ena na shellcode-u dinami캜ki u memoriji (korisno za preuzimanje dekodiranog shellcode-a). **Start offset** mo쬰 biti koristan da se shellcode pokrene na odre캠enom offsetu. Opcija **Debug Shell** je korisna za debugovanje shellcode-a koriste캖i scDbg terminal (me캠utim, smatram da su bilo koje od opcija obja코njenih ranije bolje za ovu svrhu jer 캖ete mo캖i koristiti Ida ili x64dbg).

### Disasembliranje kori코캖enjem CyberChefa

Otpremite svoj fajl sa shellcode-om kao ulaz i koristite slede캖i recept za dekompilaciju: [https://gchq.github.io/CyberChef/#recipe=To\_Hex('Space',0)Disassemble\_x86('32','Full%20x86%20architecture',16,0,true,true)](https://gchq.github.io/CyberChef/#recipe=To\_Hex\('Space',0\)Disassemble\_x86\('32','Full%20x86%20architecture',16,0,true,true\))

## [Movfuscator](https://github.com/xoreaxeaxeax/movfuscator)

Ovaj obfuscator **modifikuje sve instrukcije za `mov`** (da, zaista kul). Tako캠e koristi prekide da promeni tok izvr코avanja. Za vi코e informacija o tome kako funkcioni코e:

* [https://www.youtube.com/watch?v=2VF\_wPkiBJY](https://www.youtube.com/watch?v=2VF\_wPkiBJY)
* [https://github.com/xoreaxeaxeax/movfuscator/blob/master/slides/domas\_2015\_the\_movfuscator.pdf](https://github.com/xoreaxeaxeax/movfuscator/blob/master/slides/domas\_2015\_the\_movfuscator.pdf)

Ako imate sre캖e, [demovfuscator](https://github.com/kirschju/demovfuscator) 캖e deobfuskovati binarni fajl. Ima nekoliko zavisnosti

```
apt-get install libcapstone-dev
apt-get install libz3-dev
```

I [instaliraj keystone](https://github.com/keystone-engine/keystone/blob/master/docs/COMPILE-NIX.md) (`apt-get install cmake; mkdir build; cd build; ../make-share.sh; make install`)

Ako igrate **CTF, ovaj workaround za pronala쬰nje zastave** mo쬰 biti veoma koristan: [https://dustri.org/b/defeating-the-recons-movfuscator-crackme.html](https://dustri.org/b/defeating-the-recons-movfuscator-crackme.html)

## Rust

Da biste prona코li **ulaznu ta캜ku**, pretra쬴te funkcije po `::main` kao u:

![](<../../.gitbook/assets/image (612).png>)

U ovom slu캜aju, binarni fajl se zvao authenticator, pa je prili캜no o캜igledno da je ovo interesantna glavna funkcija.\
Imaju캖i **ime** **funkcija** koje se pozivaju, pretra쬴te ih na **Internetu** da biste saznali o njihovim **ulazima** i **izlazima**.

## **Delphi**

Za Delphi kompilovane binarne fajlove mo쬰te koristiti [https://github.com/crypto2011/IDR](https://github.com/crypto2011/IDR)

Ako morate da obrnete Delphi binarni fajl, predla쬰m vam da koristite IDA dodatak [https://github.com/Coldzer0/IDA-For-Delphi](https://github.com/Coldzer0/IDA-For-Delphi)

Samo pritisnite **ATL+f7** (uvozite python dodatak u IDA) i izaberite python dodatak.

Ovaj dodatak 캖e izvr코iti binarni fajl i dinami캜ki re코iti imena funkcija na po캜etku debagovanja. Nakon pokretanja debagovanja ponovo pritisnite dugme Start (zelena strelica ili f9) i prekida캜 캖e se aktivirati na po캜etku stvarnog koda.

Tako캠e je veoma interesantno jer ako pritisnete dugme u grafi캜koj aplikaciji, debager 캖e se zaustaviti u funkciji koju izvr코ava to dugme.

## Golang

Ako morate da obrnete Golang binarni fajl, predla쬰m vam da koristite IDA dodatak [https://github.com/sibears/IDAGolangHelper](https://github.com/sibears/IDAGolangHelper)

Samo pritisnite **ATL+f7** (uvozite python dodatak u IDA) i izaberite python dodatak.

Ovo 캖e re코iti imena funkcija.

## Kompajlirani Python

Na ovoj stranici mo쬰te prona캖i kako da dobijete python kod iz ELF/EXE python kompajliranog binarnog fajla:

{% content-ref url="../../generic-methodologies-and-resources/basic-forensic-methodology/specific-software-file-type-tricks/.pyc.md" %}
[.pyc.md](../../generic-methodologies-and-resources/basic-forensic-methodology/specific-software-file-type-tricks/.pyc.md)
{% endcontent-ref %}

## GBA - Game Body Advance

Ako dobijete **binarni** fajl GBA igre, mo쬰te koristiti razli캜ite alate za **emulaciju** i **debugovanje**:

* [**no$gba**](https://problemkaputt.de/gba.htm) (_Preuzmite debug verziju_) - Sadr쬴 debager sa interfejsom
* [**mgba** ](https://mgba.io)- Sadr쬴 CLI debager
* [**gba-ghidra-loader**](https://github.com/pudii/gba-ghidra-loader) - Ghidra dodatak
* [**GhidraGBA**](https://github.com/SiD3W4y/GhidraGBA) - Ghidra dodatak

U [**no$gba**](https://problemkaputt.de/gba.htm), u _**Options --> Emulation Setup --> Controls**_\*\* \*\* mo쬰te videti kako da pritisnete Game Boy Advance **dugmi캖e**

![](<../../.gitbook/assets/image (578).png>)

Kada se pritisne, svako **dugme ima vrednost** koja ga identifikuje:

```
A = 1
B = 2
SELECT = 4
START = 8
RIGHT = 16
LEFT = 32
UP = 64
DOWN = 128
R = 256
L = 256
```

Dakle, u ovakvom programu, interesantan deo 캖e biti **kako program tretira korisni캜ki unos**. Na adresi **0x4000130** prona캖i 캖ete 캜esto kori코캖enu funkciju: **KEYINPUT**.

![](<../../.gitbook/assets/image (579).png>)

Na prethodnoj slici mo쬰te videti da se funkcija poziva iz **FUN\_080015a8** (adrese: _0x080015fa_ i _0x080017ac_).

U toj funkciji, nakon nekih inicijalnih operacija (bez ikakvog zna캜aja):

```c
void FUN_080015a8(void)

{
ushort uVar1;
undefined4 uVar2;
undefined4 uVar3;
ushort uVar4;
int iVar5;
ushort *puVar6;
undefined *local_2c;

DISPCNT = 0x1140;
FUN_08000a74();
FUN_08000ce4(1);
DISPCNT = 0x404;
FUN_08000dd0(&DAT_02009584,0x6000000,&DAT_030000dc);
FUN_08000354(&DAT_030000dc,0x3c);
uVar4 = DAT_030004d8;
```

Prona캠en je ovaj kod:

```c
do {
DAT_030004da = uVar4; //This is the last key pressed
DAT_030004d8 = KEYINPUT | 0xfc00;
puVar6 = &DAT_0200b03c;
uVar4 = DAT_030004d8;
do {
uVar2 = DAT_030004dc;
uVar1 = *puVar6;
if ((uVar1 & DAT_030004da & ~uVar4) != 0) {
```

Poslednji if proverava da li je **`uVar4`** u **poslednjim klju캜evima** i nije trenutni klju캜, tako캠e nazvan pu코tanje dugmeta (trenutni klju캜 je sme코ten u **`uVar1`**).

```c
if (uVar1 == 4) {
DAT_030000d4 = 0;
uVar3 = FUN_08001c24(DAT_030004dc);
FUN_08001868(uVar2,0,uVar3);
DAT_05000000 = 0x1483;
FUN_08001844(&DAT_0200ba18);
FUN_08001844(&DAT_0200ba20,&DAT_0200ba40);
DAT_030000d8 = 0;
uVar4 = DAT_030004d8;
}
else {
if (uVar1 == 8) {
if (DAT_030000d8 == 0xf3) {
DISPCNT = 0x404;
FUN_08000dd0(&DAT_02008aac,0x6000000,&DAT_030000dc);
FUN_08000354(&DAT_030000dc,0x3c);
uVar4 = DAT_030004d8;
}
}
else {
if (DAT_030000d4 < 8) {
DAT_030000d4 = DAT_030000d4 + 1;
FUN_08000864();
if (uVar1 == 0x10) {
DAT_030000d8 = DAT_030000d8 + 0x3a;
```

U prethodnom kodu mo쬰te videti da upore캠ujemo **uVar1** (mesto gde je **vrednost pritisnutog dugmeta**) sa nekim vrednostima:

* Prvo se upore캠uje sa **vredno코캖u 4** (dugme **SELECT**): U izazovu ovo dugme 캜isti ekran
* Zatim se upore캠uje sa **vredno코캖u 8** (dugme **START**): U izazovu se proverava da li je kod validan za dobijanje zastave.
* U ovom slu캜aju se varijabla **`DAT_030000d8`** upore캠uje sa 0xf3 i ako je vrednost ista, izvr코ava se odre캠eni kod.
* U svim ostalim slu캜ajevima se proverava neka kont (`DAT_030000d4`). To je kont jer se dodaje 1 odmah nakon unosa koda.\
  Ako je manje od 8, ne코to 코to uklju캜uje **dodavanje** vrednosti u **`DAT_030000d8`** se radi (u osnovi se dodaju vrednosti pritisnutih tastera u ovu promenljivu dok je kont manji od 8).

Dakle, u ovom izazovu, znaju캖i vrednosti dugmadi, trebalo je **pritisnuti kombinaciju du쬴ne manje od 8 캜ija rezultuju캖a zbirka bude 0xf3.**

**Reference za ovaj tutorijal:** [**https://exp.codes/Nostalgia/**](https://exp.codes/Nostalgia/)

## Game Boy

{% embed url="https://www.youtube.com/watch?v=VVbRe7wr3G4" %}

## Kursevi

* [https://github.com/0xZ0F/Z0FCourse\_ReverseEngineering](https://github.com/0xZ0F/Z0FCourse\_ReverseEngineering)
* [https://github.com/malrev/ABD](https://github.com/malrev/ABD) (Deobfuskacija binarnog koda)

**Try Hard Security Group**

<figure><img src="../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA 캛LANSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
