# API Comuni utilizzate nel Malware

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Generico

### Networking

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### Persistenza

| Registro         | File          | Servizio                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Crittografia

| Nome                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analisi/VM

| Nome Funzione                                             | Istruzioni Assembly |
| --------------------------------------------------------- | ------------------- |
| IsDebuggerPresent()                                       | CPUID()             |
| GetSystemInfo()                                           | IN()                |
| GlobalMemoryStatusEx()                                    |                     |
| GetVersion()                                              |                     |
| CreateToolhelp32Snapshot \[Controlla se un processo √® in esecuzione] |                     |
| CreateFileW/A \[Controlla se un file esiste]                    |                     |

### Stealth

| Nome                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Allocare memoria (packers)                                                     |
| VirtualProtect           | Cambiare le autorizzazioni di memoria (packer che d√† autorizzazione di esecuzione a una sezione) |
| ReadProcessMemory        | Iniezione in processi esterni                                          |
| WriteProcessMemoryA/W    | Iniezione in processi esterni                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | Iniezione DLL/Process...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Esecuzione

| Nome Funzione    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Varie

* GetAsyncKeyState() -- Key logging
* SetWindowsHookEx -- Key logging
* GetForeGroundWindow -- Ottieni il nome della finestra in esecuzione (o il sito web da un browser)
* LoadLibrary() -- Importa libreria
* GetProcAddress() -- Importa libreria
* CreateToolhelp32Snapshot() -- Elenca i processi in esecuzione
* GetDC() -- Schermata
* BitBlt() -- Schermata
* InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Accesso a Internet
* FindResource(), LoadResource(), LockResource() -- Accesso alle risorse dell'eseguibile

## Tecniche Malware

### Iniezione DLL

Esegue una DLL arbitraria all'interno di un altro processo

1. Trova il processo in cui iniettare la DLL dannosa: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Apri il processo: GetModuleHandle, GetProcAddress, OpenProcess
3. Scrivi il percorso della DLL all'interno del processo: VirtualAllocEx, WriteProcessMemory
4. Crea un thread nel processo che caricher√† la DLL dannosa: CreateRemoteThread, LoadLibrary

Altre funzioni da utilizzare: NTCreateThreadEx, RtlCreateUserThread

### Iniezione DLL Riflessiva

Carica una DLL dannosa senza chiamare normali chiamate API di Windows.\
La DLL √® mappata all'interno di un processo, risolver√† gli indirizzi di importazione, corregger√† le rilocazioni e chiamer√† la funzione DllMain.

### Dirottamento Thread

Trova un thread da un processo e fallo caricare una DLL dannosa

1. Trova un thread target: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Apri il thread: OpenThread
3. Sospendi il thread: SuspendThread
4. Scrivi il percorso della DLL dannosa all'interno del processo vittima: VirtualAllocEx, WriteProcessMemory
5. Riprendi il thread caricando la libreria: ResumeThread

### Iniezione PE

Iniezione di Esecuzione Portatile: L'eseguibile sar√† scritto nella memoria del processo vittima e verr√† eseguito da l√¨.

### Process Hollowing

Il malware rimuover√† il codice legittimo dalla memoria del processo e caricher√† un binario dannoso

1. Crea un nuovo processo: CreateProcess
2. Rimuovi la memoria: ZwUnmapViewOfSection, NtUnmapViewOfSection
3. Scrivi il binario dannoso nella memoria del processo: VirtualAllocEc, WriteProcessMemory
4. Imposta il punto di ingresso ed esegui: SetThreadContext, ResumeThread

## Hooking

* Il **SSDT** (**System Service Descriptor Table**) punta alle funzioni del kernel (ntoskrnl.exe) o al driver GUI (win32k.sys) in modo che i processi utente possano chiamare queste funzioni.
* Un rootkit pu√≤ modificare questi puntatori agli indirizzi che controlla
* **IRP** (**I/O Request Packets**) trasmettono pezzi di dati da un componente all'altro. Quasi tutto nel kernel utilizza gli IRP e ogni oggetto dispositivo ha la propria tabella delle funzioni che possono essere agganciate: DKOM (Direct Kernel Object Manipulation)
* L'**IAT** (**Import Address Table**) √® utile per risolvere le dipendenze. √à possibile agganciare questa tabella per dirottare il codice che verr√† chiamato.
* **EAT** (**Export Address Table**) Hooks. Questi hooks possono essere fatti da **userland**. L'obiettivo √® agganciare le funzioni esportate dalle DLL.
* **Inline Hooks**: Questo tipo √® difficile da raggiungere. Coinvolge la modifica del codice delle funzioni stesse. Forse inserendo un salto all'inizio di questo.
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>
